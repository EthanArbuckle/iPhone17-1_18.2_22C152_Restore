uint64_t llvm::StringMapImpl::FindKey(uint64_t *a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const unsigned __int8 **v13;
  int v14;
  void *v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;

  if (!*((_DWORD *)a1 + 2)) {
    return 0xFFFFFFFFLL;
  }
  v6 = llvm::xxh3_64bits(a2, (unint64_t)a3, a3);
  v7 = *((unsigned int *)a1 + 2);
  v8 = v7 - 1;
  result = (v7 - 1) & v6;
  v10 = *a1;
  v11 = *a1 + 8 * v7 + 8;
  if (a3)
  {
    v12 = 1;
    v13 = *(const unsigned __int8 ***)(v10 + 8 * result);
    if (!v13) {
      return 0xFFFFFFFFLL;
    }
    while (1)
    {
      if (v13 != (const unsigned __int8 **)-8
        && *(_DWORD *)(v11 + 4 * result) == v6
        && a3 == *v13)
      {
        v23 = result;
        v21 = v10;
        v22 = v6;
        v19 = v8;
        v20 = v12;
        v18 = v11;
        v16 = memcmp(a2, (char *)v13 + *((unsigned int *)a1 + 5), (size_t)a3);
        v8 = v19;
        v12 = v20;
        v11 = v18;
        v10 = v21;
        v6 = v22;
        v17 = v16;
        result = v23;
        if (!v17) {
          break;
        }
      }
      LODWORD(result) = (result + v12++) & v8;
      v13 = *(const unsigned __int8 ***)(v10 + 8 * result);
      if (!v13) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    v14 = 1;
    v15 = *(void **)(v10 + 8 * result);
    if (!v15) {
      return 0xFFFFFFFFLL;
    }
    while (v15 == (void *)-8 || *(_DWORD *)(v11 + 4 * result) != v6 || *v15)
    {
      result = (result + v14++) & v8;
      v15 = *(void **)(v10 + 8 * result);
      if (!v15) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

int32x2_t llvm::StringMapImpl::RemoveKey(uint64_t a1, const unsigned __int8 **a2)
{
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)a1, (int8x16_t *)((char *)a2 + *(unsigned int *)(a1 + 20)), *a2);
  if (Key != -1)
  {
    *(void *)(*(void *)a1 + 8 * Key) = -8;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 12), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 12) = result;
  }
  return result;
}

uint64_t llvm::StringMapImpl::RehashTable(llvm::StringMapImpl *this, uint64_t a2)
{
  uint64_t v2 = a2;
  unsigned int v5 = *((_DWORD *)this + 2);
  int v4 = *((_DWORD *)this + 3);
  if (3 * v5 < 4 * v4)
  {
    v5 *= 2;
  }
  else if (v5 - (v4 + *((_DWORD *)this + 4)) > v5 >> 3)
  {
    return a2;
  }
  Table = createTable(v5);
  v8 = *(_DWORD **)this;
  uint64_t v9 = *((unsigned int *)this + 2);
  if (v9)
  {
    uint64_t v10 = 0;
    unsigned int v11 = v5 - 1;
    uint64_t v12 = v2;
    do
    {
      uint64_t v13 = *(void *)(*(void *)this + 8 * v10);
      if (v13 != -8 && v13 != 0)
      {
        int v15 = v8[2 * v9 + 2 + v10];
        uint64_t v16 = v15 & v11;
        if (Table[v16])
        {
          int v17 = 1;
          do
          {
            int v18 = v16 + v17++;
            uint64_t v16 = v18 & v11;
          }
          while (Table[v16]);
        }
        Table[v16] = v13;
        *((_DWORD *)&Table[v5 + 1] + v16) = v15;
        if (v10 == v12) {
          uint64_t v2 = v16;
        }
        else {
          uint64_t v2 = v2;
        }
      }
      ++v10;
    }
    while (v10 != v9);
    v8 = *(_DWORD **)this;
  }
  free(v8);
  *(void *)this = Table;
  *((_DWORD *)this + 2) = v5;
  *((_DWORD *)this + 4) = 0;
  return v2;
}

unsigned char *llvm::StringSaver::save(uint64_t **a1, const void *a2, size_t a3)
{
  unsigned int v5 = (unsigned char *)llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(*a1, a3 + 1, 0);
  v6 = v5;
  if (a3) {
    memcpy(v5, a2, a3);
  }
  v6[a3] = 0;
  return v6;
}

BOOL llvm::StringRef::starts_with_insensitive(unsigned __int8 **a1, unsigned __int8 *a2, unint64_t a3)
{
  if ((unint64_t)a1[1] < a3) {
    return 0;
  }
  if (!a3) {
    return 1;
  }
  int v4 = *a1;
  unint64_t v5 = a3 - 1;
  do
  {
    int v7 = *v4++;
    unsigned __int8 v6 = v7;
    unsigned __int8 v8 = v7 + 32;
    if ((v7 - 65) < 0x1A) {
      unsigned __int8 v6 = v8;
    }
    int v9 = v6;
    int v11 = *a2++;
    unsigned __int8 v10 = v11;
    unsigned __int8 v12 = v11 + 32;
    if ((v11 - 65) >= 0x1A) {
      unsigned __int8 v13 = v10;
    }
    else {
      unsigned __int8 v13 = v12;
    }
    BOOL v15 = v5-- != 0;
    BOOL result = v9 == v13;
  }
  while (v9 == v13 && v15);
  return result;
}

uint64_t llvm::StringRef::edit_distance(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, unsigned int a5)
{
  return llvm::ComputeMappedEditDistance<char,unsigned int llvm::ComputeEditDistance<char>(llvm::ArrayRef<char>,llvm::ArrayRef<char>,BOOL,unsigned int)::{lambda(char const&)#1}>(*(void *)a1, *(void *)(a1 + 8), a2, a3, a4, a5);
}

uint64_t llvm::StringRef::find(uint64_t *a1, char *a2, size_t a3, unint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a1[1];
  size_t v6 = v5 - a4;
  if (v5 < a4) {
    return -1;
  }
  unint64_t v7 = a4;
  if (!a3) {
    return v7;
  }
  if (v6 < a3) {
    return -1;
  }
  uint64_t v10 = *a1;
  int v11 = (unsigned __int8 *)(*a1 + a4);
  size_t v12 = a3 - 1;
  if (a3 == 1)
  {
    unsigned __int8 v13 = memchr((void *)(*a1 + a4), *a2, v6);
    if (v13) {
      return (uint64_t)v13 - v10;
    }
    else {
      return -1;
    }
  }
  unint64_t v14 = (unint64_t)&v11[v6 - a3 + 1];
  size_t v15 = a3 - 2;
  if (a3 == 2)
  {
    uint64_t result = -1;
    while (*(unsigned __int16 *)(v10 + v7) != *(unsigned __int16 *)a2)
    {
      ++v7;
      if (v10 + v7 >= v14) {
        return result;
      }
    }
    return v7;
  }
  if (a3 > 0xFF || v6 <= 0xF)
  {
    while (memcmp((const void *)(v10 + v7), a2, a3))
    {
      ++v7;
      uint64_t result = -1;
      if (v10 + v7 >= v14) {
        return result;
      }
    }
    return v7;
  }
  uint64_t v16 = 0;
  int8x16_t v22 = vdupq_n_s8(a3);
  int8x16_t v23 = v22;
  v21[12] = v22;
  v21[13] = v22;
  v21[10] = v22;
  v21[11] = v22;
  v21[8] = v22;
  v21[9] = v22;
  v21[6] = v22;
  v21[7] = v22;
  v21[4] = v22;
  v21[5] = v22;
  v21[2] = v22;
  v21[3] = v22;
  unint64_t v17 = v12 & 0xFFFFFFFFFFFFFFFELL;
  v21[0] = v22;
  v21[1] = v22;
  do
  {
    *((unsigned char *)v21 + a2[v16]) = v15 + 1;
    *((unsigned char *)v21 + a2[v16 + 1]) = v15;
    v16 += 2;
    v15 -= 2;
  }
  while (v17 != v16);
  if (v12 != v17)
  {
    unsigned int v18 = v17 + 1;
    do
    {
      *((unsigned char *)v21 + a2[v17]) = v12 - v17;
      unint64_t v17 = v18++;
    }
    while (v12 != v17);
  }
  int v19 = a2[v12];
  while (1)
  {
    uint64_t v20 = v11[v12];
    if (v20 == v19 && !memcmp(v11, a2, v12)) {
      break;
    }
    v11 += *((unsigned __int8 *)v21 + v20);
    if ((unint64_t)v11 >= v14) {
      return -1;
    }
  }
  return (uint64_t)&v11[-v10];
}

uint64_t llvm::StringRef::find_first_of(void *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  for (; a3; --a3)
  {
    unsigned int v4 = *a2++;
    *(void *)((char *)&v7 + (((unint64_t)v4 >> 3) & 0x18)) |= 1 << v4;
  }
  unint64_t v5 = a1[1];
  if (v5 <= a4) {
    return -1;
  }
  while (((*(void *)((char *)&v7 + (((unint64_t)*(unsigned __int8 *)(*a1 + a4) >> 3) & 0x18)) >> *(unsigned char *)(*a1 + a4)) & 1) == 0)
  {
    if (v5 == ++a4) {
      return -1;
    }
  }
  return a4;
}

uint64_t llvm::StringRef::find_first_not_of(void *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  for (; a3; --a3)
  {
    unsigned int v4 = *a2++;
    *(void *)((char *)&v7 + (((unint64_t)v4 >> 3) & 0x18)) |= 1 << v4;
  }
  unint64_t v5 = a1[1];
  if (v5 <= a4) {
    return -1;
  }
  while (((*(void *)((char *)&v7 + (((unint64_t)*(unsigned __int8 *)(*a1 + a4) >> 3) & 0x18)) >> *(unsigned char *)(*a1 + a4)) & 1) != 0)
  {
    if (v5 == ++a4) {
      return -1;
    }
  }
  return a4;
}

uint64_t llvm::StringRef::find_last_of(void *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  for (; a3; --a3)
  {
    unsigned int v4 = *a2++;
    *(void *)((char *)&v10 + (((unint64_t)v4 >> 3) & 0x18)) |= 1 << v4;
  }
  if (a1[1] >= a4) {
    unint64_t v5 = a4;
  }
  else {
    unint64_t v5 = a1[1];
  }
  while (v5)
  {
    unint64_t v6 = v5 - 1;
    unint64_t v7 = *(unsigned __int8 *)(*a1 + v5 - 1);
    uint64_t v8 = *(void *)((char *)&v10 + ((v7 >> 3) & 0x18)) >> v7;
    unint64_t v5 = v6;
    if (v8) {
      return v6;
    }
  }
  return -1;
}

uint64_t llvm::StringRef::find_last_not_of(void *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  for (; a3; --a3)
  {
    unsigned int v4 = *a2++;
    *(void *)((char *)&v10 + (((unint64_t)v4 >> 3) & 0x18)) |= 1 << v4;
  }
  if (a1[1] >= a4) {
    unint64_t v5 = a4;
  }
  else {
    unint64_t v5 = a1[1];
  }
  while (v5)
  {
    unint64_t v6 = v5 - 1;
    unint64_t v7 = *(unsigned __int8 *)(*a1 + v5 - 1);
    uint64_t v8 = *(void *)((char *)&v10 + ((v7 >> 3) & 0x18)) >> v7;
    unint64_t v5 = v6;
    if ((v8 & 1) == 0) {
      return v6;
    }
  }
  return -1;
}

void llvm::StringRef::split(long long *a1, uint64_t a2, char *a3, size_t a4, int a5, char a6)
{
  long long v29 = *a1;
  if (a5)
  {
    int v8 = a5;
    unint64_t v11 = *((void *)&v29 + 1);
    if (a6)
    {
      do
      {
        unint64_t v12 = llvm::StringRef::find((uint64_t *)&v29, a3, a4, 0);
        if (v12 == -1) {
          break;
        }
        unint64_t v13 = v12;
        if (v12 >= v11) {
          unint64_t v14 = v11;
        }
        else {
          unint64_t v14 = v12;
        }
        uint64_t v15 = v29;
        unint64_t v16 = *(unsigned int *)(a2 + 8);
        if (v16 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v16 + 1, 16);
          unint64_t v16 = *(unsigned int *)(a2 + 8);
        }
        unint64_t v17 = (void *)(*(void *)a2 + 16 * v16);
        *unint64_t v17 = v15;
        v17[1] = v14;
        ++*(_DWORD *)(a2 + 8);
        unint64_t v18 = v13 + a4;
        if (v11 < v13 + a4) {
          unint64_t v18 = v11;
        }
        v11 -= v18;
        *(void *)&long long v29 = v15 + v18;
        *((void *)&v29 + 1) = v11;
        --v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        unint64_t v21 = llvm::StringRef::find((uint64_t *)&v29, a3, a4, 0);
        unint64_t v22 = v21;
        if (v21)
        {
          if (v21 == -1) {
            break;
          }
          if (v21 >= v11) {
            unint64_t v23 = v11;
          }
          else {
            unint64_t v23 = v21;
          }
          uint64_t v19 = v29;
          unint64_t v24 = *(unsigned int *)(a2 + 8);
          if (v24 >= *(unsigned int *)(a2 + 12))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v24 + 1, 16);
            unint64_t v24 = *(unsigned int *)(a2 + 8);
          }
          v25 = (void *)(*(void *)a2 + 16 * v24);
          void *v25 = v19;
          v25[1] = v23;
          ++*(_DWORD *)(a2 + 8);
        }
        else
        {
          uint64_t v19 = v29;
        }
        unint64_t v20 = v22 + a4;
        if (v11 < v22 + a4) {
          unint64_t v20 = v11;
        }
        v11 -= v20;
        *(void *)&long long v29 = v19 + v20;
        *((void *)&v29 + 1) = v11;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    unint64_t v11 = *((void *)&v29 + 1);
  }
  if ((a6 & 1) != 0 || v11)
  {
    uint64_t v26 = v29;
    uint64_t v27 = *(unsigned int *)(a2 + 8);
    if (v27 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v27 + 1, 16);
      LODWORD(v27) = *(_DWORD *)(a2 + 8);
    }
    v28 = (void *)(*(void *)a2 + 16 * v27);
    void *v28 = v26;
    v28[1] = v11;
    ++*(_DWORD *)(a2 + 8);
  }
}

uint64_t llvm::consumeUnsignedInteger(llvm *this, llvm::StringRef *a2, unint64_t *a3, unint64_t *a4)
{
  if (a2)
  {
    uint64_t v6 = *((void *)this + 1);
    if (!v6) {
      return 1;
    }
  }
  else
  {
    LODWORD(a2) = GetAutoSenseRadix((uint64_t)this);
    uint64_t v6 = *((void *)this + 1);
    if (!v6) {
      return 1;
    }
  }
  unint64_t v7 = 0;
  int v8 = *(unsigned __int8 **)this;
  *a3 = 0;
  uint64_t v9 = v6;
  do
  {
    if ((char)*v8 < 48) {
      break;
    }
    unsigned int v10 = *v8;
    if (v10 >= 0x3A)
    {
      if (v10 < 0x61)
      {
        if (v10 - 65 > 0x19) {
          break;
        }
        unsigned int v11 = v10 - 55;
        if (v11 >= a2) {
          break;
        }
      }
      else
      {
        if (v10 >= 0x7B) {
          break;
        }
        unsigned int v11 = v10 - 87;
        if (v11 >= a2) {
          break;
        }
      }
    }
    else
    {
      unsigned int v11 = v10 - 48;
      if (v11 >= a2) {
        break;
      }
    }
    unint64_t v12 = v7 * a2 + v11;
    *a3 = v12;
    if (v12 / a2 < v7) {
      return 1;
    }
    ++v8;
    unint64_t v7 = v12;
    --v9;
  }
  while (v9);
  if (v6 == v9) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)this = v8;
  *((void *)this + 1) = v9;
  return result;
}

uint64_t GetAutoSenseRadix(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if (v1 < 2) {
    return 10;
  }
  v3 = *(unsigned char **)a1;
  if (**(_WORD **)a1 == 30768 || *(_WORD *)v3 == 22576)
  {
    *(void *)a1 = v3 + 2;
    *(void *)(a1 + 8) = v1 - 2;
    return 16;
  }
  else if (*(_WORD *)v3 == 25136 || *(_WORD *)v3 == 16944)
  {
    *(void *)a1 = v3 + 2;
    *(void *)(a1 + 8) = v1 - 2;
    return 2;
  }
  else if (*(_WORD *)v3 == 28464)
  {
    *(void *)a1 = v3 + 2;
    *(void *)(a1 + 8) = v1 - 2;
    return 8;
  }
  else
  {
    if (*v3 != 48) {
      return 10;
    }
    int v5 = v3[1];
    unsigned int v4 = v3 + 1;
    if ((v5 - 48) > 9) {
      return 10;
    }
    *(void *)a1 = v4;
    *(void *)(a1 + 8) = v1 - 1;
    return 8;
  }
}

double llvm::consumeSignedInteger(char **a1, unsigned int AutoSenseRadix, unint64_t *a3)
{
  int v5 = a1[1];
  if (v5 && **a1 == 45)
  {
    uint64_t v6 = v5 - 1;
    *(void *)&long long v23 = *a1 + 1;
    *((void *)&v23 + 1) = v6;
    if (AutoSenseRadix)
    {
      if (!v6) {
        return result;
      }
    }
    else
    {
      AutoSenseRadix = GetAutoSenseRadix((uint64_t)&v23);
      uint64_t v6 = (char *)*((void *)&v23 + 1);
      if (!*((void *)&v23 + 1)) {
        return result;
      }
    }
    unint64_t v7 = 0;
    int v8 = (char *)v23;
    uint64_t v9 = &v6[v23];
    unsigned int v10 = v6;
    while (*v8 >= 48)
    {
      unsigned int v11 = *v8;
      if (v11 >= 0x3A)
      {
        if (v11 < 0x61)
        {
          if (v11 - 65 > 0x19) {
            break;
          }
          int v12 = -55;
        }
        else
        {
          if (v11 >= 0x7B) {
            break;
          }
          int v12 = -87;
        }
      }
      else
      {
        int v12 = -48;
      }
      unsigned int v13 = v12 + v11;
      if (v13 >= AutoSenseRadix) {
        break;
      }
      unint64_t v14 = v7 * AutoSenseRadix + v13;
      if (v14 / AutoSenseRadix < v7) {
        return result;
      }
      ++v8;
      unint64_t v7 = v14;
      if (!--v10)
      {
        if (!v6) {
          return result;
        }
        goto LABEL_44;
      }
    }
    unint64_t v14 = v7;
    uint64_t v9 = v8;
    if (v6 == v10) {
      return result;
    }
LABEL_44:
    *(void *)&long long v23 = v9;
    *((void *)&v23 + 1) = v10;
    if (v14 <= 0x8000000000000000)
    {
      double result = *(double *)&v23;
      *(_OWORD *)a1 = v23;
      *a3 = -(uint64_t)v14;
    }
  }
  else
  {
    if (AutoSenseRadix)
    {
      if (!v5) {
        return result;
      }
    }
    else
    {
      AutoSenseRadix = GetAutoSenseRadix((uint64_t)a1);
      int v5 = a1[1];
      if (!v5) {
        return result;
      }
    }
    unint64_t v15 = 0;
    unint64_t v16 = *a1;
    unint64_t v17 = &v5[(void)*a1];
    unint64_t v18 = v5;
    while (*v16 >= 48)
    {
      unsigned int v19 = *v16;
      if (v19 >= 0x3A)
      {
        if (v19 < 0x61)
        {
          if (v19 - 65 > 0x19) {
            break;
          }
          unsigned int v20 = v19 - 55;
          if (v20 >= AutoSenseRadix) {
            break;
          }
        }
        else
        {
          if (v19 >= 0x7B) {
            break;
          }
          unsigned int v20 = v19 - 87;
          if (v20 >= AutoSenseRadix) {
            break;
          }
        }
      }
      else
      {
        unsigned int v20 = v19 - 48;
        if (v20 >= AutoSenseRadix) {
          break;
        }
      }
      unint64_t v21 = v15 * AutoSenseRadix + v20;
      if (v21 / AutoSenseRadix < v15) {
        return result;
      }
      ++v16;
      unint64_t v15 = v21;
      if (!--v18) {
        goto LABEL_39;
      }
    }
    unint64_t v21 = v15;
    unint64_t v17 = v16;
    if (v5 == v18) {
      return result;
    }
LABEL_39:
    *a1 = v17;
    a1[1] = v18;
    if ((v21 & 0x8000000000000000) == 0) {
      *a3 = v21;
    }
  }
  return result;
}

uint64_t llvm::getAsUnsignedInteger(unsigned __int8 *a1, uint64_t a2, unsigned int AutoSenseRadix, unint64_t *a4)
{
  unsigned int v11 = a1;
  uint64_t v12 = a2;
  if (AutoSenseRadix)
  {
    if (!a2) {
      return 1;
    }
  }
  else
  {
    AutoSenseRadix = GetAutoSenseRadix((uint64_t)&v11);
    a2 = v12;
    if (!v12) {
      return 1;
    }
  }
  unint64_t v5 = 0;
  uint64_t v6 = v11;
  *a4 = 0;
  do
  {
    if ((char)*v6 < 48) {
      break;
    }
    unsigned int v7 = *v6;
    if (v7 >= 0x3A)
    {
      if (v7 < 0x61)
      {
        if (v7 - 65 > 0x19) {
          return a2 != 0;
        }
        unsigned int v8 = v7 - 55;
        if (v8 >= AutoSenseRadix) {
          return a2 != 0;
        }
      }
      else
      {
        if (v7 >= 0x7B) {
          return a2 != 0;
        }
        unsigned int v8 = v7 - 87;
        if (v8 >= AutoSenseRadix) {
          return a2 != 0;
        }
      }
    }
    else
    {
      unsigned int v8 = v7 - 48;
      if (v8 >= AutoSenseRadix) {
        return a2 != 0;
      }
    }
    unint64_t v9 = v5 * AutoSenseRadix + v8;
    *a4 = v9;
    if (v9 / AutoSenseRadix < v5) {
      return 1;
    }
    ++v6;
    unint64_t v5 = v9;
    --a2;
  }
  while (a2);
  return a2 != 0;
}

uint64_t llvm::getAsSignedInteger(char *a1, uint64_t a2, unsigned int a3, unint64_t *a4)
{
  unint64_t v5 = a1;
  uint64_t v6 = a2;
  llvm::consumeSignedInteger(&v5, a3, a4);
  if (v6) {
    return 1;
  }
  else {
    return result;
  }
}

BOOL llvm::StringRef::consumeInteger(llvm::StringRef *this, unsigned int a2, llvm::APInt *a3)
{
  unsigned int AutoSenseRadix = a2;
  long long v39 = *(_OWORD *)this;
  if (a2)
  {
    uint64_t v6 = *((void *)&v39 + 1);
    if (*((void *)&v39 + 1)) {
      goto LABEL_3;
    }
    return 1;
  }
  unsigned int AutoSenseRadix = GetAutoSenseRadix((uint64_t)&v39);
  uint64_t v6 = *((void *)&v39 + 1);
  if (!*((void *)&v39 + 1)) {
    return 1;
  }
LABEL_3:
  unsigned int v7 = (char *)v39;
  if (*(unsigned char *)v39 != 48)
  {
    uint64_t v8 = v39;
LABEL_11:
    *(void *)&long long v39 = v8;
    *((void *)&v39 + 1) = v6;
    unsigned int v11 = -(int)v6;
    unsigned int v12 = -1;
    do
    {
      int v13 = 1 << ++v12;
      v11 += v6;
    }
    while (1 << v12 < AutoSenseRadix);
    unsigned int v14 = *((_DWORD *)a3 + 2);
    if (v11 >= v14)
    {
      if (v11 > v14)
      {
        llvm::APInt::zext((const void **)a3, v11, (uint64_t)&__p);
        if (*((_DWORD *)a3 + 2) >= 0x41u && *(void *)a3) {
          operator delete[](*(void **)a3);
        }
        *(void *)a3 = __p;
        unsigned int v14 = v38;
        *((_DWORD *)a3 + 2) = v38;
      }
    }
    else
    {
      unsigned int v11 = *((_DWORD *)a3 + 2);
    }
    unsigned int v38 = 1;
    __p = 0;
    unsigned int v36 = 1;
    v35 = 0;
    if (v13 != AutoSenseRadix)
    {
      unsigned int v34 = v11;
      if (v11 >= 0x41)
      {
        llvm::APInt::initSlowCase((llvm::APInt *)&v33, AutoSenseRadix, 0);
        if (v38 >= 0x41 && __p) {
          operator delete[](__p);
        }
        __p = v33;
        unsigned int v38 = v34;
        unsigned int v34 = v11;
        llvm::APInt::initSlowCase((llvm::APInt *)&v33, 0, 0);
        if (v36 >= 0x41 && v35) {
          operator delete[](v35);
        }
      }
      else
      {
        unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v11;
        if (!v11) {
          LODWORD(v15) = 0;
        }
        __p = (void *)(v15 & AutoSenseRadix);
        unsigned int v38 = v34;
        unsigned int v34 = v11;
        v33 = 0;
      }
      v35 = v33;
      unsigned int v36 = v34;
      unsigned int v14 = *((_DWORD *)a3 + 2);
    }
    if (v14 > 0x40)
    {
      **(void **)a3 = 0;
      bzero((void *)(*(void *)a3 + 8), ((((unint64_t)v14 + 63) >> 3) - 8) & 0xFFFFFFF8);
      unint64_t v16 = (unsigned __int8 *)v39;
      if (v13 != AutoSenseRadix) {
        goto LABEL_38;
      }
    }
    else
    {
      *(void *)a3 = 0;
      unint64_t v16 = (unsigned __int8 *)v39;
      if (v13 != AutoSenseRadix)
      {
LABEL_38:
        unint64_t v17 = v7;
        while (*v7 >= 48)
        {
          unsigned int v18 = *v7;
          if (v18 >= 0x3A)
          {
            if (v18 < 0x61)
            {
              if (v18 - 65 > 0x19) {
                break;
              }
              int v19 = -55;
            }
            else
            {
              if (v18 >= 0x7B) {
                break;
              }
              int v19 = -87;
            }
          }
          else
          {
            int v19 = -48;
          }
          uint64_t v20 = v19 + v18;
          if (v20 >= AutoSenseRadix) {
            break;
          }
          llvm::APInt::operator*=((uint64_t)a3, (const unint64_t **)&__p);
          uint64_t v21 = v36;
          if (v36 > 0x40)
          {
            *(void *)v35 = v20;
            bzero((char *)v35 + 8, (((unint64_t)(v21 + 63) >> 3) - 8) & 0xFFFFFFF8);
          }
          else
          {
            if (v36) {
              unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v36;
            }
            else {
              unint64_t v22 = 0;
            }
            v35 = (void *)(v22 & v20);
          }
          llvm::APInt::operator+=((uint64_t)a3, (void **)&v35);
          unint64_t v16 = (unsigned __int8 *)(v7 + 1);
          ++v17;
          ++v7;
          if (!--v6) {
            goto LABEL_78;
          }
        }
LABEL_80:
        *(void *)&long long v39 = v16;
        *((void *)&v39 + 1) = v6;
        uint64_t v31 = *((void *)this + 1);
        BOOL v10 = v31 == v6;
        if (v31 != v6) {
LABEL_81:
        }
          *(_OWORD *)this = v39;
LABEL_82:
        if (v36 >= 0x41 && v35) {
          operator delete[](v35);
        }
        if (v38 >= 0x41 && __p) {
          operator delete[](__p);
        }
        return v10;
      }
    }
    unint64_t v17 = v7;
    while (1)
    {
      if (*v7 < 48) {
        goto LABEL_80;
      }
      unsigned int v23 = *v7;
      if (v23 >= 0x3A)
      {
        if (v23 <= 0x60)
        {
          if (v23 - 65 >= 0x1A) {
            goto LABEL_80;
          }
          int v24 = -55;
        }
        else
        {
          if (v23 > 0x7A) {
            goto LABEL_80;
          }
          int v24 = -87;
        }
      }
      else
      {
        int v24 = -48;
      }
      uint64_t v25 = v24 + v23;
      if (v25 >= AutoSenseRadix) {
        goto LABEL_80;
      }
      unsigned int v26 = *((_DWORD *)a3 + 2);
      if (v26 <= 0x40) {
        break;
      }
      llvm::APInt::shlSlowCase((const void **)a3, v12);
      unsigned int v26 = *((_DWORD *)a3 + 2);
      if (v26 >= 0x41)
      {
        **(void **)a3 |= v25;
        unint64_t v16 = (unsigned __int8 *)(v7 + 1);
        ++v17;
        ++v7;
        if (!--v6) {
          goto LABEL_78;
        }
      }
      else
      {
LABEL_74:
        if (v26) {
          unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v26;
        }
        else {
          unint64_t v29 = 0;
        }
        *(void *)a3 = (*(void *)a3 | v25) & v29;
        unint64_t v16 = (unsigned __int8 *)(v7 + 1);
        ++v17;
        ++v7;
        if (!--v6)
        {
LABEL_78:
          *(void *)&long long v39 = v17;
          *((void *)&v39 + 1) = v6;
          uint64_t v30 = *((void *)this + 1);
          BOOL v10 = v30 == v6;
          if (v30 != v6) {
            goto LABEL_81;
          }
          goto LABEL_82;
        }
      }
    }
    uint64_t v27 = *(void *)a3 << v12;
    if (v26 == v12) {
      uint64_t v27 = 0;
    }
    unint64_t v28 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v26;
    if (!v26) {
      unint64_t v28 = 0;
    }
    *(void *)a3 = v27 & v28;
    goto LABEL_74;
  }
  uint64_t v8 = v39;
  while (--v6)
  {
    int v9 = *++v7;
    ++v8;
    if (v9 != 48) {
      goto LABEL_11;
    }
  }
  long long v39 = (unint64_t)(v8 + 1);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *(void *)a3) {
    operator delete[](*(void **)a3);
  }
  BOOL v10 = 0;
  *(void *)a3 = 0;
  *((_DWORD *)a3 + 2) = 64;
  *(_OWORD *)this = v39;
  return v10;
}

uint64_t llvm::StringRef::getAsInteger(llvm::StringRef *this, unsigned int a2, llvm::APInt *a3)
{
  long long v4 = *(_OWORD *)this;
  LODWORD(result) = llvm::StringRef::consumeInteger((llvm::StringRef *)&v4, a2, a3);
  if (*((void *)&v4 + 1)) {
    return 1;
  }
  else {
    return result;
  }
}

uint64_t llvm::StringRef::getAsDouble(llvm::StringRef *this, double *a2, int a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v17, 0.0);
  unsigned int v7 = llvm::APFloatBase::IEEEdouble(v6);
  llvm::APFloat::Storage::Storage(v16, &v17, v7);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v17);
  llvm::APFloat::convertFromString((uint64_t)&v15, *(unsigned __int8 **)this, *((void *)this + 1), 1, (uint64_t)&v17);
  if (v18)
  {
    BOOL v10 = v17;
    unint64_t v17 = 0;
    if (v10)
    {
      int v13 = v10;
      llvm::handleErrors<llvm::consumeError(llvm::Error)::{lambda(llvm::ErrorInfoBase const&)#1}>((void **)&v13, &v14);
      uint64_t v8 = v13;
      if (v13) {
        uint64_t v8 = (llvm::APFloatBase *)(*(uint64_t (**)(llvm::APFloatBase *))(*(void *)v13 + 8))(v13);
      }
      uint64_t v9 = 1;
LABEL_10:
      if ((v18 & 1) == 0) {
        goto LABEL_15;
      }
      goto LABEL_13;
    }
  }
  else if (v17)
  {
    uint64_t v9 = 1;
    if ((v17 & 0x10) == 0 || !a3) {
      goto LABEL_10;
    }
  }
  uint64_t v9 = 0;
  *a2 = llvm::APFloat::convertToDouble(&v15);
  if ((v18 & 1) == 0) {
    goto LABEL_15;
  }
LABEL_13:
  uint64_t v8 = v17;
  unint64_t v17 = 0;
  if (v8) {
    uint64_t v8 = (llvm::APFloatBase *)(*(uint64_t (**)(llvm::APFloatBase *))(*(void *)v8 + 8))(v8);
  }
LABEL_15:
  unsigned int v11 = (void *)v16[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v8) == v11) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v16);
  }
  return v9;
}

unint64_t llvm::hash_value(void *a1, uint64_t a2)
{
  return llvm::hashing::detail::hash_combine_range_impl<char const>(a1, (uint64_t)a1 + a2);
}

unint64_t llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(void *a1, uint64_t a2)
{
  return llvm::hashing::detail::hash_combine_range_impl<char const>(a1, (uint64_t)a1 + a2);
}

uint64_t llvm::ComputeMappedEditDistance<char,unsigned int llvm::ComputeEditDistance<char>(llvm::ArrayRef<char>,llvm::ArrayRef<char>,BOOL,unsigned int)::{lambda(char const&)#1}>(uint64_t a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5, unsigned int a6)
{
  v61[32] = *MEMORY[0x1E4F143B8];
  if (a6)
  {
    unint64_t v12 = a4 - a2;
    if (a2 > a4) {
      unint64_t v12 = a2 - a4;
    }
    if (v12 > a6) {
      return a6 + 1;
    }
  }
  v59 = v61;
  uint64_t v60 = 0x4000000000;
  unint64_t v14 = a4 + 1;
  if (a4 == -1)
  {
    if (!a2) {
      return HIDWORD(v60);
    }
    uint64_t v13 = a6 + 1;
    unint64_t v15 = v61;
    goto LABEL_19;
  }
  if (v14 < 0x41)
  {
    uint64_t v16 = 0;
    unint64_t v15 = v61;
    unint64_t v17 = a4 + 1;
    goto LABEL_13;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v61, a4 + 1, 4);
  uint64_t v16 = v60;
  unint64_t v15 = v59;
  unint64_t v17 = v14 - v60;
  if (v14 != v60) {
LABEL_13:
  }
    bzero((char *)v15 + 4 * v16, 4 * v17);
  LODWORD(v60) = v14;
  if (v14 >= 2)
  {
    uint64_t v18 = 1;
    do
    {
      *((_DWORD *)v15 + v18) = v18;
      ++v18;
    }
    while (v60 > v18);
  }
  if (!a2) {
    goto LABEL_85;
  }
  uint64_t v13 = a6 + 1;
  if (a4)
  {
LABEL_19:
    if (v14 <= 2) {
      uint64_t v19 = 2;
    }
    else {
      uint64_t v19 = a4 + 1;
    }
    if (a5)
    {
      if (a6)
      {
        uint64_t v20 = v19 - 1;
        uint64_t v21 = 1;
        while (1)
        {
          uint64_t v22 = 0;
          *(_DWORD *)unint64_t v15 = v21;
          unsigned int v23 = v21;
          unsigned int v24 = v21 - 1;
          unsigned int v25 = v21;
          do
          {
            unsigned int v26 = (char *)v15 + 4 * v22;
            if (*(unsigned __int8 *)(a1 + v21 - 1) != a3[v22]) {
              ++v24;
            }
            unsigned int v27 = *((_DWORD *)v26 + 1);
            if (v27 < v23) {
              unsigned int v23 = *((_DWORD *)v26 + 1);
            }
            if (v23 + 1 < v24) {
              ++v23;
            }
            else {
              unsigned int v23 = v24;
            }
            *((_DWORD *)v26 + 1) = v23;
            if (v23 < v25) {
              unsigned int v25 = v23;
            }
            ++v22;
            unsigned int v24 = v27;
          }
          while (v20 != v22);
          if (v25 > a6) {
            goto LABEL_86;
          }
          if (++v21 > a2) {
            goto LABEL_85;
          }
        }
      }
      uint64_t v39 = 2;
      if (a2 + 1 > 2) {
        uint64_t v39 = a2 + 1;
      }
      uint64_t v40 = v19 - 1;
      uint64_t v41 = 1;
      do
      {
        uint64_t v42 = 0;
        *(_DWORD *)unint64_t v15 = v41;
        unsigned int v43 = v41;
        unsigned int v44 = v41 - 1;
        do
        {
          v45 = (char *)v15 + 4 * v42;
          if (*(unsigned __int8 *)(a1 + v41 - 1) != a3[v42]) {
            ++v44;
          }
          unsigned int v46 = *((_DWORD *)v45 + 1);
          if (v46 < v43) {
            unsigned int v43 = *((_DWORD *)v45 + 1);
          }
          if (v43 + 1 < v44) {
            ++v43;
          }
          else {
            unsigned int v43 = v44;
          }
          *((_DWORD *)v45 + 1) = v43;
          ++v42;
          unsigned int v44 = v46;
        }
        while (v40 != v42);
        ++v41;
      }
      while (v41 != v39);
    }
    else
    {
      if (a6)
      {
        uint64_t v28 = 1;
        while (1)
        {
          unint64_t v29 = a3;
          *(_DWORD *)unint64_t v15 = v28;
          uint64_t v30 = (unsigned int *)v15 + 1;
          uint64_t v31 = v19 - 1;
          unsigned int v32 = v28;
          unsigned int v33 = v28 - 1;
          unsigned int v34 = v28;
          do
          {
            unsigned int v35 = *v30;
            int v36 = *v29++;
            if (*(unsigned __int8 *)(a1 + v28 - 1) != v36)
            {
              v37 = v30 - 1;
              if (v35 < v32) {
                v37 = v30;
              }
              unsigned int v33 = *v37 + 1;
            }
            *v30++ = v33;
            if (v33 < v34) {
              unsigned int v34 = v33;
            }
            unsigned int v32 = v33;
            unsigned int v33 = v35;
            --v31;
          }
          while (v31);
          if (v34 > a6) {
            break;
          }
          if (++v28 > a2) {
            goto LABEL_85;
          }
        }
LABEL_86:
        if (v15 == v61) {
          return v13;
        }
LABEL_87:
        free(v15);
        return v13;
      }
      uint64_t v47 = 2;
      if (a2 + 1 > 2) {
        uint64_t v47 = a2 + 1;
      }
      uint64_t v48 = v19 - 1;
      uint64_t v49 = 1;
      do
      {
        v50 = a3;
        *(_DWORD *)unint64_t v15 = v49;
        v51 = (int *)v15 + 1;
        uint64_t v52 = v48;
        unsigned int v53 = v49;
        int v54 = v49 - 1;
        do
        {
          unsigned int v55 = *v51;
          int v56 = *v50++;
          if (*(unsigned __int8 *)(a1 + v49 - 1) != v56)
          {
            v57 = v51 - 1;
            if (v55 < v53) {
              v57 = v51;
            }
            int v54 = *v57 + 1;
          }
          *v51++ = v54;
          unsigned int v53 = v54;
          int v54 = v55;
          --v52;
        }
        while (v52);
        ++v49;
      }
      while (v49 != v47);
    }
LABEL_85:
    uint64_t v13 = *((unsigned int *)v15 + a4);
    goto LABEL_86;
  }
  if (!a6)
  {
    LODWORD(v38) = 2;
    if (a2 + 1 > 2) {
      LODWORD(v38) = a2 + 1;
    }
LABEL_84:
    *(_DWORD *)unint64_t v15 = v38 - 1;
    goto LABEL_85;
  }
  uint64_t v38 = 1;
  while (v38 <= a6)
  {
    if (++v38 > a2) {
      goto LABEL_84;
    }
  }
  *(_DWORD *)unint64_t v15 = v38;
  if (v15 != v61) {
    goto LABEL_87;
  }
  return v13;
}

uint64_t llvm::ThreadPool::ThreadPool(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 12) = 0;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((llvm::sys::RWMutexImpl *)(a1 + 40));
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 850045863;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 1018212795;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 1018212795;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 252) = 0u;
  *(unsigned char *)(a1 + 296) = 1;
  *(void *)(a1 + 300) = a2;
  *(_DWORD *)(a1 + 308) = llvm::ThreadPoolStrategy::compute_thread_count((llvm::ThreadPoolStrategy *)&v5);
  return a1;
}

BOOL llvm::ThreadPool::grow(pthread_rwlock_t **this, int a2)
{
  uint64_t v39 = this + 5;
  llvm::sys::RWMutexImpl::lock(this + 5);
  long long v4 = this[2];
  uint64_t v5 = this[3];
  unint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
  unint64_t v7 = *((unsigned int *)this + 77);
  if (v6 < v7)
  {
    unint64_t v8 = (unint64_t)((char *)v5 - (char *)v4) >> 3;
    for (i = (int)v7 >= a2 ? a2 : *((_DWORD *)this + 77); i > (int)v8; unint64_t v6 = v8)
    {
      unint64_t v12 = this[4];
      if (v5 < v12)
      {
        BOOL v10 = operator new(0x10uLL);
        *(void *)BOOL v10 = this;
        v10[2] = v8;
        pthread_t v11 = llvm::llvm_execute_on_thread_impl((void *(__cdecl *)(void *))llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>, v10, 0x100800000);
        v5->__sig = (uint64_t)v11;
        if (!v11) {
          operator delete(v10);
        }
        uint64_t v5 = (pthread_rwlock_t *)((char *)v5 + 8);
        goto LABEL_10;
      }
      if ((v6 + 1) >> 61) {
        abort();
      }
      uint64_t v13 = (char *)v12 - (char *)v4;
      uint64_t v14 = v13 >> 2;
      if (v13 >> 2 <= v6 + 1) {
        uint64_t v14 = v6 + 1;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v14;
      }
      if (v15)
      {
        if (v15 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v16 = (char *)operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unint64_t v17 = (pthread_t *)&v16[8 * v6];
      uint64_t v18 = operator new(0x10uLL);
      *(void *)uint64_t v18 = this;
      v18[2] = v8;
      pthread_t v19 = llvm::llvm_execute_on_thread_impl((void *(__cdecl *)(void *))llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>, v18, 0x100800000);
      *unint64_t v17 = v19;
      if (v19)
      {
        uint64_t v21 = this[2];
        uint64_t v20 = this[3];
        uint64_t v22 = (char *)((char *)v20 - (char *)v21);
        if (v20 != v21) {
          goto LABEL_24;
        }
      }
      else
      {
        operator delete(v18);
        uint64_t v21 = this[2];
        uint64_t v20 = this[3];
        uint64_t v22 = (char *)((char *)v20 - (char *)v21);
        if (v20 != v21)
        {
LABEL_24:
          unint64_t v23 = (unint64_t)(v22 - 8);
          if (v23 < 0x78)
          {
            unsigned int v24 = (pthread_rwlock_t *)&v16[8 * v6];
            goto LABEL_33;
          }
          unint64_t v26 = v23 >> 3;
          if ((char *)v20 - 8 * (v23 >> 3) - 8 < (char *)v17)
          {
            unint64_t v27 = (unint64_t)&v16[8 * v6 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8];
            unsigned int v24 = (pthread_rwlock_t *)&v16[8 * v6];
            if (v27 < (unint64_t)v20) {
              goto LABEL_48;
            }
          }
          unint64_t v28 = v26 + 1;
          uint64_t v29 = 8 * (v28 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v30 = (pthread_rwlock_t *)((char *)v20 - v29);
          unsigned int v24 = (pthread_rwlock_t *)&v17[v29 / 0xFFFFFFFFFFFFFFF8];
          uint64_t v31 = &v16[8 * v6 - 16];
          unsigned int v32 = &v20[-1].__opaque[176];
          uint64_t v33 = v28 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v35 = *((_OWORD *)v32 - 1);
            long long v34 = *(_OWORD *)v32;
            *((_OWORD *)v32 - 1) = 0uLL;
            *(_OWORD *)unsigned int v32 = 0uLL;
            *((_OWORD *)v31 - 1) = v35;
            *(_OWORD *)uint64_t v31 = v34;
            v31 -= 32;
            v32 -= 32;
            v33 -= 4;
          }
          while (v33);
          uint64_t v20 = v30;
          if (v28 != (v28 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_48:
            do
            {
LABEL_33:
              uint64_t v36 = *(void *)&v20[-1].__opaque[184];
              uint64_t v20 = (pthread_rwlock_t *)((char *)v20 - 8);
              v20->__sig = 0;
              *(void *)&v24[-1].__opaque[184] = v36;
              unsigned int v24 = (pthread_rwlock_t *)((char *)v24 - 8);
            }
            while (v20 != v21);
          }
          unsigned int v25 = this[2];
          uint64_t v20 = this[3];
          goto LABEL_35;
        }
      }
      unsigned int v25 = v20;
      unsigned int v24 = (pthread_rwlock_t *)&v16[8 * v6];
LABEL_35:
      uint64_t v5 = (pthread_rwlock_t *)(v17 + 1);
      this[2] = v24;
      this[3] = (pthread_rwlock_t *)(v17 + 1);
      this[4] = (pthread_rwlock_t *)&v16[8 * v15];
      while (v20 != v25)
      {
        uint64_t v37 = *(void *)&v20[-1].__opaque[184];
        uint64_t v20 = (pthread_rwlock_t *)((char *)v20 - 8);
        if (v37) {
          std::terminate();
        }
      }
      if (v25) {
        operator delete(v25);
      }
LABEL_10:
      this[3] = v5;
      long long v4 = this[2];
      unint64_t v8 = ((char *)v5 - (char *)v4) >> 3;
    }
  }

  return llvm::sys::RWMutexImpl::unlock_shared(v39);
}

uint64_t llvm::ThreadPool::processTasks(uint64_t a1, uint64_t a2)
{
  qos_class_t v4 = QOS_CLASS_UNSPECIFIED;
  uint64_t v5 = 0;
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (std::mutex *)(a1 + 104);
  unint64_t v7 = (std::condition_variable *)(a1 + 168);
  uint64_t v83 = a1 + 272;
  unsigned int v86 = (a2 >> 4) ^ (a2 >> 9);
  v84 = (std::condition_variable *)(a1 + 216);
  v85 = (std::condition_variable *)(a1 + 168);
  do
  {
    v90 = 0;
    __lk.__m_ = v6;
    __lk.__owns_ = 1;
    std::mutex::lock(v6);
    qos_class_t v9 = *(_DWORD *)(a1 + 12);
    BOOL v10 = v9 == v4;
    pthread_t v11 = *(NSObject **)a1;
    BOOL v12 = *(void *)a1 != (void)v5;
    if (*(unsigned char *)(a1 + 296) && (!*(void *)(a1 + 96) ? (BOOL v13 = v11 == v5) : (BOOL v13 = 0), v13))
    {
      while (1)
      {
        if (!v10)
        {
          pthread_set_qos_class_self_np(v9, 0);
          goto LABEL_35;
        }
        if (a2)
        {
          int v15 = *(_DWORD *)(a1 + 288);
          if (!v15) {
            goto LABEL_48;
          }
          uint64_t v16 = *(void *)(a1 + 272);
          unsigned int v17 = v15 - 1;
          int v18 = v17 & v86;
          uint64_t v19 = *(void *)(v16 + 16 * (v17 & v86));
          if (v19 != a2) {
            break;
          }
        }
LABEL_17:
        std::condition_variable::wait(v7, &__lk);
        qos_class_t v9 = *(_DWORD *)(a1 + 12);
        BOOL v10 = v9 == v4;
        pthread_t v11 = *(NSObject **)a1;
        BOOL v12 = *(void *)a1 != (void)v5;
        if (!*(unsigned char *)(a1 + 296) || *(void *)(a1 + 96) || v11 != v5) {
          goto LABEL_9;
        }
      }
      int v20 = 1;
      while (v19 != -4096)
      {
        int v21 = v18 + v20++;
        int v18 = v21 & v17;
        uint64_t v19 = *(void *)(v16 + 16 * (v21 & v17));
        if (v19 == a2) {
          goto LABEL_17;
        }
      }
LABEL_48:
      char v14 = 0;
      if (*(unsigned char *)(a1 + 296)) {
        goto LABEL_50;
      }
    }
    else
    {
LABEL_9:
      if (!v10)
      {
        pthread_set_qos_class_self_np(v9, 0);
        if (!v12)
        {
LABEL_35:
          uint64_t v22 = 0;
          int v23 = 0;
          int v24 = 2;
          qos_class_t v4 = v9;
          if (!__lk.__owns_) {
            goto LABEL_37;
          }
LABEL_36:
          std::mutex::unlock(__lk.__m_);
          goto LABEL_37;
        }
        qos_class_t v4 = v9;
LABEL_27:
        if (v5) {
          os_activity_scope_leave(&state);
        }
        if (v11)
        {
          os_activity_scope_enter(v11, &state);
          uint64_t v22 = 0;
          int v23 = 0;
          int v24 = 2;
          uint64_t v5 = v11;
          if (__lk.__owns_) {
            goto LABEL_36;
          }
        }
        else
        {
          uint64_t v5 = 0;
          uint64_t v22 = 0;
          int v23 = 0;
          int v24 = 2;
          if (__lk.__owns_) {
            goto LABEL_36;
          }
        }
        goto LABEL_37;
      }
      if (v12) {
        goto LABEL_27;
      }
      char v14 = 1;
      if (*(unsigned char *)(a1 + 296)) {
        goto LABEL_50;
      }
    }
    if (!*(void *)(a1 + 96)) {
      goto LABEL_59;
    }
LABEL_50:
    if (!a2) {
      char v14 = 1;
    }
    if ((v14 & 1) == 0)
    {
LABEL_59:
      if (v5)
      {
        os_activity_scope_leave(&state);
        uint64_t v5 = 0;
        uint64_t v22 = 0;
        int v23 = 0;
        int v24 = 1;
        if (__lk.__owns_) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v22 = 0;
        int v23 = 0;
        int v24 = 1;
        if (__lk.__owns_) {
          goto LABEL_36;
        }
      }
      goto LABEL_37;
    }
    ++*(_DWORD *)(a1 + 264);
    unint64_t v33 = *(void *)(a1 + 88);
    uint64_t v34 = *(void *)(*(void *)(a1 + 64) + 8 * (v33 / 0x66));
    long long v35 = v90;
    v90 = 0;
    if (v35 == v89)
    {
      (*(void (**)(void *))(v89[0] + 32))(v89);
      uint64_t v36 = (void *)(v34 + 40 * (v33 % 0x66));
      uint64_t v37 = (void *)v36[3];
      if (!v37) {
        goto LABEL_65;
      }
    }
    else
    {
      if (v35) {
        (*(void (**)(void *))(*v35 + 40))(v35);
      }
      uint64_t v36 = (void *)(v34 + 40 * (v33 % 0x66));
      uint64_t v37 = (void *)v36[3];
      if (!v37)
      {
LABEL_65:
        v90 = 0;
        goto LABEL_67;
      }
    }
    if (v37 == v36)
    {
      v90 = v89;
      (*(void (**)(void, void *))(*(void *)v36[3] + 24))(v36[3], v89);
    }
    else
    {
      v90 = v37;
      v36[3] = 0;
    }
LABEL_67:
    unint64_t v38 = *(void *)(a1 + 88);
    uint64_t v39 = *(void *)(*(void *)(a1 + 64) + 8 * (v38 / 0x66));
    unint64_t v40 = v38 % 0x66;
    uint64_t v22 = *(void *)(v39 + 40 * v40 + 32);
    if (!v22) {
      goto LABEL_85;
    }
    unsigned int v41 = *(_DWORD *)(a1 + 288);
    if (!v41) {
      goto LABEL_125;
    }
    uint64_t v42 = *(void *)(a1 + 272);
    unsigned int v43 = v41 - 1;
    unsigned int v44 = (v41 - 1) & ((v22 >> 4) ^ (v22 >> 9));
    v45 = (uint64_t *)(v42 + 16 * v44);
    uint64_t v46 = *v45;
    if (v22 != *v45)
    {
      uint64_t v47 = 0;
      int v48 = 1;
      while (v46 != -4096)
      {
        if (v47) {
          BOOL v49 = 0;
        }
        else {
          BOOL v49 = v46 == -8192;
        }
        if (v49) {
          uint64_t v47 = v45;
        }
        unsigned int v50 = v44 + v48++;
        unsigned int v44 = v50 & v43;
        v45 = (uint64_t *)(v42 + 16 * (v50 & v43));
        uint64_t v46 = *v45;
        if (v22 == *v45) {
          goto LABEL_84;
        }
      }
      if (v47) {
        v45 = v47;
      }
      int v73 = *(_DWORD *)(a1 + 280);
      if (4 * v73 + 4 < 3 * v41)
      {
        if (v41 + ~v73 - *(_DWORD *)(a1 + 284) <= v41 >> 3) {
          goto LABEL_126;
        }
        uint64_t v51 = *v45;
        ++*(_DWORD *)(a1 + 280);
        if (v51 != -4096) {
          goto LABEL_82;
        }
      }
      else
      {
LABEL_125:
        v41 *= 2;
LABEL_126:
        llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(v83, v41);
        uint64_t v74 = *(void *)(a1 + 272);
        int v75 = *(_DWORD *)(a1 + 288) - 1;
        unsigned int v76 = v75 & ((v22 >> 4) ^ (v22 >> 9));
        v45 = (uint64_t *)(v74 + 16 * v76);
        uint64_t v77 = *v45;
        if (v22 == *v45)
        {
LABEL_127:
          ++*(_DWORD *)(a1 + 280);
          if (v22 == -4096) {
            goto LABEL_83;
          }
        }
        else
        {
          v78 = 0;
          int v79 = 1;
          while (v77 != -4096)
          {
            if (v78) {
              BOOL v80 = 0;
            }
            else {
              BOOL v80 = v77 == -8192;
            }
            if (v80) {
              v78 = v45;
            }
            unsigned int v81 = v76 + v79++;
            unsigned int v76 = v81 & v75;
            v45 = (uint64_t *)(v74 + 16 * (v81 & v75));
            uint64_t v77 = *v45;
            if (v22 == *v45) {
              goto LABEL_127;
            }
          }
          if (v78) {
            v45 = v78;
          }
          uint64_t v82 = *v45;
          ++*(_DWORD *)(a1 + 280);
          if (v82 == -4096) {
            goto LABEL_83;
          }
        }
LABEL_82:
        --*(_DWORD *)(a1 + 284);
      }
LABEL_83:
      uint64_t *v45 = v22;
      *((_DWORD *)v45 + 2) = 0;
      unint64_t v52 = *(void *)(a1 + 88);
      uint64_t v39 = *(void *)(*(void *)(a1 + 64) + 8 * (v52 / 0x66));
      unint64_t v40 = v52 % 0x66;
    }
LABEL_84:
    ++*((_DWORD *)v45 + 2);
LABEL_85:
    unsigned int v53 = (void *)(v39 + 40 * v40);
    int v54 = (void *)v53[3];
    if (v54 == v53)
    {
      (*(void (**)(void *))(*v53 + 32))(v53);
    }
    else if (v54)
    {
      (*(void (**)(void *))(*v54 + 40))(v54);
    }
    int64x2_t v55 = vaddq_s64(*(int64x2_t *)(a1 + 88), (int64x2_t)xmmword_181110B10);
    *(int64x2_t *)(a1 + 88) = v55;
    if (v55.i64[0] >= 0xCCuLL)
    {
      operator delete(**(void ***)(a1 + 64));
      int v24 = 0;
      *(void *)(a1 + 64) += 8;
      *(void *)(a1 + 88) -= 102;
      int v23 = 1;
      if (__lk.__owns_) {
        goto LABEL_36;
      }
    }
    else
    {
      int v24 = 0;
      int v23 = 1;
      if (__lk.__owns_) {
        goto LABEL_36;
      }
    }
LABEL_37:
    if (!v23) {
      goto LABEL_104;
    }
    if (!v90) {
      std::__throw_bad_function_call[abi:nn180100]();
    }
    (*(void (**)(void *))(*v90 + 48))(v90);
    std::mutex::lock(v6);
    int v25 = *(_DWORD *)(a1 + 264) - 1;
    *(_DWORD *)(a1 + 264) = v25;
    if (!v22)
    {
      if (!v25 && !*(void *)(a1 + 96)) {
        goto LABEL_117;
      }
      goto LABEL_102;
    }
    uint64_t v26 = *(void *)(a1 + 272);
    uint64_t v27 = *(unsigned int *)(a1 + 288);
    unsigned int v28 = v22 >> 4;
    if (v27)
    {
      LODWORD(v29) = (v27 - 1) & (v28 ^ (v22 >> 9));
      uint64_t v30 = (uint64_t *)(v26 + 16 * v29);
      uint64_t v31 = *v30;
      if (*v30 == v22)
      {
        int v32 = *((_DWORD *)v30 + 2) - 1;
        *((_DWORD *)v30 + 2) = v32;
        if (v32) {
          goto LABEL_43;
        }
        goto LABEL_100;
      }
      int v56 = 1;
      while (v31 != -4096)
      {
        int v57 = v29 + v56++;
        uint64_t v29 = v57 & (v27 - 1);
        uint64_t v31 = *(void *)(v26 + 16 * v29);
        if (v31 == v22)
        {
          uint64_t v30 = (uint64_t *)(v26 + 16 * v29);
          int v58 = *((_DWORD *)v30 + 2) - 1;
          *((_DWORD *)v30 + 2) = v58;
          if (v58) {
            goto LABEL_43;
          }
          goto LABEL_100;
        }
      }
    }
    uint64_t v30 = (uint64_t *)(v26 + 16 * v27);
    int v59 = *((_DWORD *)v30 + 2) - 1;
    *((_DWORD *)v30 + 2) = v59;
    if (v59)
    {
LABEL_43:
      if (!v27) {
        goto LABEL_111;
      }
      goto LABEL_101;
    }
LABEL_100:
    *uint64_t v30 = -8192;
    *(int32x2_t *)(a1 + 280) = vadd_s32(*(int32x2_t *)(a1 + 280), (int32x2_t)0x1FFFFFFFFLL);
    uint64_t v26 = *(void *)(a1 + 272);
    if (!v27) {
      goto LABEL_111;
    }
LABEL_101:
    int v60 = v27 - 1;
    unsigned int v61 = v60 & (v28 ^ (v22 >> 9));
    uint64_t v62 = *(void *)(v26 + 16 * v61);
    if (v62 != v22)
    {
      int v63 = 1;
      while (v62 != -4096)
      {
        unsigned int v64 = v61 + v63++;
        unsigned int v61 = v64 & v60;
        uint64_t v62 = *(void *)(v26 + 16 * v61);
        if (v62 == v22) {
          goto LABEL_102;
        }
      }
LABEL_111:
      uint64_t v65 = *(void *)(a1 + 64);
      if (*(void *)(a1 + 72) != v65)
      {
        unint64_t v66 = *(void *)(a1 + 88);
        v67 = (unint64_t *)(v65 + 8 * (v66 / 0x66));
        unint64_t v68 = *v67;
        unint64_t v69 = *v67 + 40 * (v66 % 0x66);
        unint64_t v70 = *(void *)(v65 + 8 * ((*(void *)(a1 + 96) + v66) / 0x66)) + 40 * ((*(void *)(a1 + 96) + v66) % 0x66);
        while (v69 != v70)
        {
          if (*(void *)(v69 + 32) == v22) {
            goto LABEL_102;
          }
          v69 += 40;
          if (v69 - v68 == 4080)
          {
            unint64_t v71 = v67[1];
            ++v67;
            unint64_t v68 = v71;
            unint64_t v69 = v71;
          }
        }
      }
LABEL_117:
      int v72 = *(unsigned __int8 *)(a1 + 8);
      if (*(unsigned char *)(a1 + 8))
      {
        os_release(*(void **)a1);
        *(void *)a1 = 0;
      }
      std::mutex::unlock(v6);
      std::condition_variable::notify_all(v84);
      if (v22 || v72) {
        std::condition_variable::notify_all(v85);
      }
      goto LABEL_103;
    }
LABEL_102:
    std::mutex::unlock(v6);
LABEL_103:
    int v24 = 0;
LABEL_104:
    uint64_t result = (uint64_t)v90;
    if (v90 == v89)
    {
      uint64_t result = (*(uint64_t (**)(void *))(v89[0] + 32))(v89);
    }
    else if (v90)
    {
      uint64_t result = (*(uint64_t (**)(void))(*v90 + 40))();
    }
    unint64_t v7 = v85;
  }
  while ((v24 | 2) == 2);
  return result;
}

void llvm::ThreadPool::wait(uint64_t a1, uint64_t a2)
{
  qos_class_t v4 = (pthread_rwlock_t **)(a1 + 40);
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(a1 + 40));
  pthread_t current_id_impl = llvm::llvm_thread_get_current_id_impl();
  unint64_t v6 = *(mlir::GenericProgramPoint ***)(a1 + 16);
  unint64_t v7 = *(mlir::GenericProgramPoint ***)(a1 + 24);
  if (v6 == v7)
  {
LABEL_5:
    llvm::sys::RWMutexImpl::unlock_shared(v4);
    v25.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 104);
    v25.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 104));
    unsigned int v10 = (a2 >> 4) ^ (a2 >> 9);
    int v11 = *(_DWORD *)(a1 + 288);
    if (v11)
    {
      while (1)
      {
        uint64_t v12 = *(void *)(a1 + 272);
        int v13 = v11 - 1;
        unsigned int v14 = v13 & v10;
        uint64_t v15 = *(void *)(v12 + 16 * (v13 & v10));
        if (v15 != a2) {
          break;
        }
LABEL_7:
        std::condition_variable::wait((std::condition_variable *)(a1 + 216), &v25);
        int v11 = *(_DWORD *)(a1 + 288);
        if (!v11) {
          goto LABEL_13;
        }
      }
      int v16 = 1;
      while (v15 != -4096)
      {
        unsigned int v17 = v14 + v16++;
        unsigned int v14 = v17 & v13;
        uint64_t v15 = *(void *)(v12 + 16 * v14);
        if (v15 == a2) {
          goto LABEL_7;
        }
      }
    }
LABEL_13:
    uint64_t v18 = *(void *)(a1 + 64);
    if (*(void *)(a1 + 72) != v18)
    {
      unint64_t v19 = *(void *)(a1 + 88);
      int v20 = (unint64_t *)(v18 + 8 * (v19 / 0x66));
      unint64_t v21 = *v20;
      unint64_t v22 = *v20 + 40 * (v19 % 0x66);
      unint64_t v23 = *(void *)(v18 + 8 * ((*(void *)(a1 + 96) + v19) / 0x66)) + 40 * ((*(void *)(a1 + 96) + v19) % 0x66);
      while (v22 != v23)
      {
        if (*(void *)(v22 + 32) == a2) {
          goto LABEL_7;
        }
        v22 += 40;
        if (v22 - v21 == 4080)
        {
          unint64_t v24 = v20[1];
          ++v20;
          unint64_t v21 = v24;
          unint64_t v22 = v24;
        }
      }
    }
    if (v25.__owns_) {
      std::mutex::unlock(v25.__m_);
    }
  }
  else
  {
    pthread_t v8 = current_id_impl;
    while (1)
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(*v6);
      if (v8 == v9) {
        break;
      }
      if (++v6 == v7) {
        goto LABEL_5;
      }
    }
    llvm::sys::RWMutexImpl::unlock_shared(v4);
    llvm::ThreadPool::processTasks(a1, a2);
  }
}

void llvm::ThreadPool::~ThreadPool(llvm::ThreadPool *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  *((unsigned char *)this + 296) = 0;
  std::mutex::unlock(v2);
  std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)this + 5);
  qos_class_t v4 = (_opaque_pthread_t **)*((void *)this + 2);
  for (int i = (_opaque_pthread_t **)*((void *)this + 3); v4 != i; ++v4)
  {
    llvm::llvm_thread_join_impl(*v4, v3);
    *qos_class_t v4 = 0;
  }
  llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)this + 5);
  llvm::deallocate_buffer(*((llvm **)this + 34), (void *)(16 * *((unsigned int *)this + 72)));
}

BOOL llvm::ThreadPool::setActivity(llvm::ThreadPool *this, void *a2, char a3)
{
  unint64_t v6 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  *(void *)this = a2;
  os_retain(a2);
  *((unsigned char *)this + 8) = a3;
  std::mutex::unlock(v6);
  std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
  int v7 = *((_DWORD *)this + 77);

  return llvm::ThreadPool::grow((pthread_rwlock_t **)this, v7);
}

void llvm::ThreadPool::clearActivity(llvm::ThreadPool *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  if (*((_DWORD *)this + 66) || *((void *)this + 12))
  {
    *((unsigned char *)this + 8) = 1;
    std::mutex::unlock(v2);
  }
  else
  {
    os_release(*(void **)this);
    *(void *)this = 0;
    std::mutex::unlock(v2);
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
  }
}

void llvm::ThreadPool::raiseQOSIfNeeded(llvm::ThreadPool *this, qos_class_t a2)
{
  qos_class_t v4 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  if (*((_DWORD *)this + 3) >= a2)
  {
    std::mutex::unlock(v4);
  }
  else
  {
    *((_DWORD *)this + 3) = a2;
    std::mutex::unlock(v4);
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
  }
}

uint64_t std::deque<std::pair<std::function<void ()(void)>,llvm::ThreadPoolTaskGroup *>>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v3 = *(void ***)(a1 + 8);
    *(void *)(a1 + 40) = 0;
    unint64_t v10 = 0;
    goto LABEL_15;
  }
  unint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = &v2[v4 / 0x66];
  unint64_t v6 = (char *)*v5 + 40 * (v4 % 0x66);
  unint64_t v7 = (unint64_t)v2[(*(void *)(a1 + 40) + v4) / 0x66] + 40 * ((*(void *)(a1 + 40) + v4) % 0x66);
  if (v6 == (char *)v7) {
    goto LABEL_13;
  }
  do
  {
    pthread_t v8 = (char *)*((void *)v6 + 3);
    if (v8 == v6)
    {
      (*(void (**)(char *))(*(void *)v6 + 32))(v6);
      v6 += 40;
      if (v6 - (unsigned char *)*v5 != 4080) {
        continue;
      }
LABEL_11:
      qos_class_t v9 = (char *)v5[1];
      ++v5;
      unint64_t v6 = v9;
      continue;
    }
    if (v8) {
      (*(void (**)(char *))(*(void *)v8 + 40))(v8);
    }
    v6 += 40;
    if (v6 - (unsigned char *)*v5 == 4080) {
      goto LABEL_11;
    }
  }
  while (v6 != (char *)v7);
  uint64_t v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
LABEL_13:
  *(void *)(a1 + 40) = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
LABEL_15:
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 51;
LABEL_20:
    *(void *)(a1 + 32) = v12;
  }
  else if (v11 == 2)
  {
    uint64_t v12 = 102;
    goto LABEL_20;
  }
  if (v2 != v3)
  {
    do
    {
      int v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(uint64_t *a1, const llvm::Twine *a2)
{
  uint64_t v3 = *a1;
  v5[0] = "llvm-worker-{0}";
  v5[1] = 15;
  v5[2] = &v7;
  v5[3] = 1;
  v6[0] = &unk_1EC9A4588;
  v6[1] = a1 + 1;
  unint64_t v7 = v6;
  pthread_t v8 = v5;
  __int16 v9 = 263;
  llvm::set_thread_name((llvm *)&v8, a2);
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)(v3 + 300));
  llvm::ThreadPool::processTasks(v3, 0);
  operator delete(a1);
  return 0;
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<int const&>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<int,void>::format(*(unsigned int **)(a1 + 8), a2, a3, a4);
}

void llvm::initTimerOptions(llvm *this)
{
  if (atomic_load_explicit(qword_1EB2160F0, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_1EB216108, memory_order_acquire)) {
      goto LABEL_3;
    }
  }
  else
  {
    if (atomic_load_explicit(&qword_1EB216108, memory_order_acquire))
    {
LABEL_3:
      if (atomic_load_explicit(qword_1EB216120, memory_order_acquire)) {
        return;
      }
LABEL_7:
      return;
    }
  }
  if (!atomic_load_explicit(qword_1EB216120, memory_order_acquire)) {
    goto LABEL_7;
  }
}

llvm *llvm::CreateInfoOutputFile@<X0>(llvm **a1@<X8>)
{
  if (atomic_load_explicit(qword_1EB216138, memory_order_acquire))
  {
    uint64_t v3 = qword_1EB216138[0];
    int v4 = *(char *)(qword_1EB216138[0] + 23);
    if ((v4 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EB216138, (void *(*)(void))llvm::object_creator<std::string>::call, (void (*)(void *))llvm::object_deleter<std::string>::call);
    uint64_t v3 = qword_1EB216138[0];
    int v4 = *(char *)(qword_1EB216138[0] + 23);
    if ((v4 & 0x80000000) == 0)
    {
LABEL_3:
      if (v4 != 1)
      {
        if ((_BYTE)v4) {
          goto LABEL_10;
        }
        goto LABEL_19;
      }
      if (*(unsigned char *)v3 == 45) {
        goto LABEL_21;
      }
      goto LABEL_10;
    }
  }
  uint64_t v5 = *(void *)(v3 + 8);
  if (!v5)
  {
LABEL_19:
    uint64_t v14 = operator new(0x60uLL);
    uint64_t v15 = 2;
LABEL_22:
    uint64_t result = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream(v14, v15, 0, 0, 0);
    *a1 = result;
    return result;
  }
  if (v5 == 1 && **(unsigned char **)v3 == 45)
  {
LABEL_21:
    uint64_t v14 = operator new(0x60uLL);
    uint64_t v15 = 1;
    goto LABEL_22;
  }
LABEL_10:
  int v22 = 0;
  unint64_t v23 = std::system_category();
  unint64_t v6 = (llvm *)operator new(0x60uLL);
  unint64_t v7 = v6;
  char v8 = *(unsigned char *)(v3 + 23);
  if (v8 >= 0) {
    __int16 v9 = (char *)v3;
  }
  else {
    __int16 v9 = *(char **)v3;
  }
  if (v8 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(v3 + 23);
  }
  else {
    uint64_t v10 = *(void *)(v3 + 8);
  }
  uint64_t result = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v6, v9, v10, (uint64_t)&v22, 7);
  if (v22)
  {
    uint64_t v12 = (llvm::raw_ostream *)llvm::errs(result);
    int v13 = (void *)*((void *)v12 + 4);
    if (*((void *)v12 + 3) - (void)v13 > 0x1FuLL)
    {
      qmemcpy(v13, "Error opening info-output-file '", 32);
      *((void *)v12 + 4) += 32;
    }
    else
    {
      uint64_t v12 = llvm::raw_ostream::write(v12, "Error opening info-output-file '", 0x20uLL);
    }
    int v16 = *(char *)(v3 + 23);
    if (v16 >= 0) {
      unsigned int v17 = (const char *)v3;
    }
    else {
      unsigned int v17 = *(const char **)v3;
    }
    if (v16 >= 0) {
      size_t v18 = *(unsigned __int8 *)(v3 + 23);
    }
    else {
      size_t v18 = *(void *)(v3 + 8);
    }
    unint64_t v19 = llvm::raw_ostream::write(v12, v17, v18);
    int v20 = (_OWORD *)*((void *)v19 + 4);
    if (*((void *)v19 + 3) - (void)v20 > 0xFuLL)
    {
      *int v20 = *(_OWORD *)" for appending!\n";
      *((void *)v19 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v19, " for appending!\n", 0x10uLL);
    }
    unint64_t v21 = operator new(0x60uLL);
    *a1 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream(v21, 2, 0, 0, 0);
    return (llvm *)(*(uint64_t (**)(llvm *))(*(void *)v7 + 8))(v7);
  }
  else
  {
    *a1 = v7;
  }
  return result;
}

void *llvm::object_creator<std::string>::call()
{
  uint64_t result = operator new(0x18uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = 0;
  return result;
}

void llvm::object_deleter<std::string>::call(void **__p)
{
  if (__p)
  {
    unint64_t v1 = __p;
    if (*((char *)__p + 23) < 0)
    {
      operator delete(*__p);
      __p = v1;
    }
    else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
    {
      __break(0xC471u);
    }
    operator delete(__p);
  }
}

uint64_t anonymous namespace'::CreateTrackSpace::call(_anonymous_namespace_::CreateTrackSpace *this)
{
  unint64_t v1 = operator new(0xC0uLL);
  *(void *)&long long v4 = "Enable -time-passes memory tracking (this may be slow)";
  *((void *)&v4 + 1) = 54;
  int v3 = 1;
  return llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [13],llvm::cl::desc,llvm::cl::OptionHidden>((uint64_t)v1, (int8x16_t *)"track-memory", &v4, &v3);
}

uint64_t llvm::object_deleter<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>>::call(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [13],llvm::cl::desc,llvm::cl::OptionHidden>(uint64_t a1, int8x16_t *a2, _OWORD *a3, _WORD *a4)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  char v8 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v9 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v11 = *(unsigned int *)(a1 + 72);
  if (v11 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v8, v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v11) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AE0;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3F00;
  *(void *)(a1 + 152) = &unk_1EC9A4440;
  *(void *)(a1 + 160) = &unk_1EC9CE680;
  *(void *)(a1 + 184) = a1 + 160;
  uint64_t v12 = (const unsigned __int8 *)strlen(a2->i8);
  llvm::cl::Option::setArgStr(a1, a2, v12);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

uint64_t anonymous namespace'::CreateInfoOutputFilename::call(_anonymous_namespace_::CreateInfoOutputFilename *this)
{
  unint64_t v1 = operator new(0xD8uLL);
  *(void *)&long long v6 = "filename";
  *((void *)&v6 + 1) = 8;
  *(void *)&long long v5 = "File to append -stats and -timer output to";
  *((void *)&v5 + 1) = 42;
  int v4 = 1;
  if (!atomic_load_explicit(qword_1EB216138, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EB216138, (void *(*)(void))llvm::object_creator<std::string>::call, (void (*)(void *))llvm::object_deleter<std::string>::call);
  }
  int v3 = (const std::string *)qword_1EB216138[0];
  return llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::opt<char [17],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::OptionHidden,llvm::cl::LocationClass<std::string>>((uint64_t)v1, (int8x16_t *)"info-output-file", &v6, &v5, &v4, &v3);
}

uint64_t llvm::object_deleter<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>>::call(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::opt<char [17],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::OptionHidden,llvm::cl::LocationClass<std::string>>(uint64_t a1, int8x16_t *a2, _OWORD *a3, _OWORD *a4, _WORD *a5, const std::string **a6)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  uint64_t v12 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AC0;
  *(void *)a1 = &unk_1EC9A3E98;
  *(void *)(a1 + 176) = &unk_1EC9A4410;
  *(void *)(a1 + 184) = &unk_1EC9CE628;
  *(void *)(a1 + 208) = a1 + 184;
  llvm::cl::apply<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>,char [17],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::OptionHidden,llvm::cl::LocationClass<std::string>>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

std::string *llvm::cl::apply<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>,char [17],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::OptionHidden,llvm::cl::LocationClass<std::string>>(uint64_t a1, int8x16_t *__s, _OWORD *a3, _OWORD *a4, _WORD *a5, const std::string **a6)
{
  uint64_t v12 = (const unsigned __int8 *)strlen(__s->i8);
  llvm::cl::Option::setArgStr(a1, __s, v12);
  *(_OWORD *)(a1 + 48) = *a3;
  *(_OWORD *)(a1 + 32) = *a4;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  if (*(void *)(a1 + 128))
  {
    unsigned int v17 = "cl::location(x) specified more than once!";
    __int16 v18 = 259;
    uint64_t v14 = (llvm::raw_ostream *)llvm::errs(v13);
    return (std::string *)llvm::cl::Option::error((void *)a1, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    int v16 = *a6;
    *(void *)(a1 + 128) = *a6;
    *(unsigned char *)(a1 + 168) = 1;
    return std::string::operator=((std::string *)(a1 + 144), v16);
  }
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::handleOccurrence(uint64_t a1, __int16 a2, int a3, int a4, void *__src, size_t __len)
{
  memset(&__p, 0, sizeof(__p));
  if (!__src)
  {
    memset(&__dst, 0, sizeof(__dst));
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_18;
  }
  if (__len >= 0x17)
  {
    size_t v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v11 = __len | 7;
    }
    size_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = __len;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_11:
    memmove(p_dst, __src, __len);
    p_dst->__r_.__value_.__s.__data_[__len] = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
  p_dst = &__dst;
  if (__len) {
    goto LABEL_11;
  }
  __dst.__r_.__value_.__s.__data_[0] = 0;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_13;
  }
LABEL_12:
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_13:
  std::string __p = __dst;
  std::string::operator=(*(std::string **)(a1 + 128), &__p);
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v13 = *(void *)(a1 + 208);
  if (!v13)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_18:
    abort();
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v13 + 48))(v13, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::getValueExpectedFlagDefault()
{
  return 2;
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::~opt(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A3E98;
  uint64_t v2 = a1 + 184;
  uint64_t v3 = *(void *)(a1 + 208);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    *(void *)(a1 + 136) = &unk_1EC9A3BA0;
    if ((*(char *)(a1 + 167) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
    }
    *(void *)(a1 + 136) = &unk_1EC9A3BA0;
    if ((*(char *)(a1 + 167) & 0x80000000) == 0)
    {
LABEL_5:
      *(void *)a1 = &unk_1EC9A42A8;
      int v4 = *(void **)(a1 + 96);
      if (v4 == *(void **)(a1 + 88)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  operator delete(*(void **)(a1 + 144));
  *(void *)a1 = &unk_1EC9A42A8;
  int v4 = *(void **)(a1 + 96);
  if (v4 != *(void **)(a1 + 88)) {
LABEL_6:
  }
    free(v4);
LABEL_7:
  long long v5 = *(void **)(a1 + 64);
  if (v5 != (void *)(a1 + 80)) {
    free(v5);
  }
  return a1;
}

void llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::~opt(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3E98;
  uint64_t v2 = __p + 184;
  uint64_t v3 = (char *)*((void *)__p + 26);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    *((void *)__p + 17) = &unk_1EC9A3BA0;
    if ((__p[167] & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    *((void *)__p + 17) = &unk_1EC9A3BA0;
    if ((__p[167] & 0x80000000) == 0)
    {
LABEL_5:
      *(void *)std::string __p = &unk_1EC9A42A8;
      int v4 = (void *)*((void *)__p + 12);
      if (v4 == *((void **)__p + 11)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  operator delete(*((void **)__p + 18));
  *(void *)std::string __p = &unk_1EC9A42A8;
  int v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
LABEL_6:
  }
    free(v4);
LABEL_7:
  long long v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 176, a1);
}

llvm::raw_ostream *llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::printOptionInfo(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 176), a1, a2);
}

llvm::raw_ostream *llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::printOptionValue(llvm::raw_ostream *result, int a2, char a3)
{
  uint64_t v4 = (uint64_t)result;
  long long v5 = (const void **)*((void *)result + 16);
  if ((a3 & 1) == 0 && *((unsigned char *)result + 168))
  {
    uint64_t v6 = *((unsigned __int8 *)result + 167);
    if ((v6 & 0x80u) == 0) {
      unint64_t v7 = (unsigned __int8 *)*((unsigned __int8 *)result + 167);
    }
    else {
      unint64_t v7 = (unsigned __int8 *)*((void *)result + 19);
    }
    char v8 = (unsigned __int8 *)*((unsigned __int8 *)v5 + 23);
    int v9 = (char)v8;
    if ((char)v8 < 0) {
      char v8 = (unsigned __int8 *)v5[1];
    }
    if (v7 == v8)
    {
      uint64_t v10 = (const void **)((char *)result + 144);
      if (v9 >= 0) {
        size_t v11 = (unsigned __int8 *)*((void *)result + 16);
      }
      else {
        size_t v11 = (unsigned __int8 *)*v5;
      }
      if ((v6 & 0x80) != 0)
      {
        uint64_t result = (llvm::raw_ostream *)memcmp(*v10, v11, *((void *)result + 19));
        if (!result) {
          return result;
        }
      }
      else
      {
        if (!*((unsigned char *)result + 167)) {
          return result;
        }
        while (*(unsigned __int8 *)v10 == *v11)
        {
          uint64_t v10 = (const void **)((char *)v10 + 1);
          ++v11;
          if (!--v6) {
            return result;
          }
        }
      }
    }
  }
  int v12 = *((char *)v5 + 23);
  if (v12 >= 0) {
    uint64_t v13 = v5;
  }
  else {
    uint64_t v13 = *v5;
  }
  if (v12 >= 0) {
    size_t v14 = *((unsigned __int8 *)v5 + 23);
  }
  else {
    size_t v14 = (size_t)v5[1];
  }

  return llvm::cl::parser<std::string>::printOptionDiff((llvm *)(v4 + 176), v4, v13, v14, v4 + 136, a2);
}

void llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::setDefault(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    unint64_t v1 = (const std::string *)(a1 + 144);
    uint64_t v2 = *(std::string **)(a1 + 128);
    std::string::operator=(v2, v1);
  }
  else
  {
    memset(&__str, 0, sizeof(__str));
    std::string::operator=(*(std::string **)(a1 + 128), &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
}

void *std::__function::__func<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CE628;
  return result;
}

void std::__function::__func<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE628;
}

uint64_t std::__function::__func<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x8000000181127F7ALL) {
    return a1 + 8;
  }
  if (((v3 & 0x8000000181127F7ALL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181127F7ALL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181127F7ALL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::target_type()
{
}

uint64_t anonymous namespace'::CreateSortTimers::call(_anonymous_namespace_::CreateSortTimers *this)
{
  unint64_t v1 = operator new(0xC0uLL);
  *(void *)&long long v6 = "In the report, sort the timers in each group in wall clock time order";
  *((void *)&v6 + 1) = 69;
  char v4 = 1;
  long long v5 = &v4;
  int v3 = 1;
  return llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [12],llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((uint64_t)v1, (int8x16_t *)"sort-timers", &v6, &v5, &v3);
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [12],llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>(uint64_t a1, int8x16_t *a2, _OWORD *a3, unsigned char **a4, _WORD *a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  uint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AE0;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3F00;
  *(void *)(a1 + 152) = &unk_1EC9A4440;
  *(void *)(a1 + 160) = &unk_1EC9CE680;
  *(void *)(a1 + 184) = a1 + 160;
  size_t v14 = (const unsigned __int8 *)strlen(a2->i8);
  llvm::cl::Option::setArgStr(a1, a2, v14);
  *(_OWORD *)(a1 + 32) = *a3;
  uint64_t v15 = *a4;
  *(unsigned char *)(a1 + 128) = **a4;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v15;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(llvm::ToolOutputFile::CleanupInstaller *this)
{
  size_t v2 = *((unsigned __int8 *)this + 23);
  char v3 = v2;
  size_t v4 = *((void *)this + 1);
  if ((v2 & 0x80u) == 0) {
    uint64_t v5 = *((unsigned __int8 *)this + 23);
  }
  else {
    uint64_t v5 = *((void *)this + 1);
  }
  if (v5 == 1)
  {
    long long v6 = *(llvm::ToolOutputFile::CleanupInstaller **)this;
    if ((v2 & 0x80u) == 0) {
      long long v6 = this;
    }
    if (*(unsigned char *)v6 == 45)
    {
      if ((v2 & 0x80) == 0) {
        return;
      }
LABEL_19:
      operator delete(*(void **)this);
      return;
    }
  }
  if (!*((unsigned char *)this + 24))
  {
    __int16 v10 = 260;
    int v9 = this;
    llvm::sys::fs::remove((llvm::sys::fs *)&v9, (const llvm::Twine *)1);
    size_t v2 = *((unsigned __int8 *)this + 23);
    size_t v4 = *((void *)this + 1);
    char v3 = *((unsigned char *)this + 23);
  }
  if (v3 >= 0) {
    unint64_t v7 = this;
  }
  else {
    unint64_t v7 = *(llvm::ToolOutputFile::CleanupInstaller **)this;
  }
  if (v3 >= 0) {
    size_t v8 = v2;
  }
  else {
    size_t v8 = v4;
  }
  llvm::sys::DontRemoveFileOnSignal(v7, v8);
  if ((*((unsigned char *)this + 23) & 0x80) != 0) {
    goto LABEL_19;
  }
}

void *llvm::ToolOutputFile::ToolOutputFile(void *__dst, unsigned char *__src, size_t __len, uint64_t a4, int a5)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v12 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v12 = __len | 7;
    }
    size_t v13 = v12 + 1;
    size_t v14 = (char *)operator new(v12 + 1);
    __dst[1] = __len;
    __dst[2] = v13 | 0x8000000000000000;
    *std::string __dst = v14;
    memmove(v14, __src, __len);
    __int16 v10 = &v14[__len];
    goto LABEL_10;
  }
  *((unsigned char *)__dst + 23) = __len;
  __int16 v10 = (char *)__dst;
  if (!__len)
  {
LABEL_10:
    *__int16 v10 = 0;
    *((unsigned char *)__dst + 24) = 0;
    goto LABEL_11;
  }
  memmove(__dst, __src, __len);
  *((unsigned char *)__dst + __len) = 0;
  *((unsigned char *)__dst + 24) = 0;
  if (__len != 1 || *__src != 45)
  {
LABEL_11:
    llvm::sys::RemoveFileOnSignal(__src, __len);
    *((unsigned char *)__dst + 32) = 0;
    uint64_t v11 = (llvm *)(__dst + 4);
    *((unsigned char *)__dst + 128) = 0;
    if (__len != 1) {
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  *((unsigned char *)__dst + 32) = 0;
  uint64_t v11 = (llvm *)(__dst + 4);
  *((unsigned char *)__dst + 128) = 0;
LABEL_12:
  if (*__src == 45)
  {
    __dst[17] = llvm::outs(v11);
    uint64_t v15 = std::system_category();
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = v15;
    return __dst;
  }
LABEL_14:
  uint64_t v16 = llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v11, __src, __len, a4, a5);
  *((unsigned char *)__dst + 128) = 1;
  __dst[17] = v16;
  if (*(_DWORD *)a4) {
    *((unsigned char *)__dst + 24) = 1;
  }
  return __dst;
}

void llvm::Twine::str(llvm::Twine *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v3 = *((unsigned __int8 *)this + 32);
  if (v3 != 7)
  {
    if (v3 == 4 && *((unsigned char *)this + 33) == 1)
    {
      size_t v4 = *(long long **)this;
      if (*(char *)(*(void *)this + 23) < 0)
      {
        uint64_t v15 = *(const std::string::value_type **)v4;
        std::string::size_type v16 = *((void *)v4 + 1);
        std::string::__init_copy_ctor_external(a2, v15, v16);
      }
      else
      {
        long long v5 = *v4;
        a2->__r_.__value_.__r.__words[2] = *((void *)v4 + 2);
        *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v5;
      }
      return;
    }
LABEL_10:
    unsigned int v17 = &v19;
    long long v18 = xmmword_1811012D0;
    unint64_t v7 = llvm::Twine::toStringRef((uint64_t)this, (uint64_t)&v17);
    if (!v7)
    {
      a2->__r_.__value_.__r.__words[0] = 0;
      a2->__r_.__value_.__l.__size_ = 0;
      a2->__r_.__value_.__r.__words[2] = 0;
      uint64_t v11 = v17;
      if (v17 == &v19) {
        return;
      }
LABEL_22:
      free(v11);
      return;
    }
    size_t v9 = v8;
    if (v8 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    __int16 v10 = v7;
    if (v8 >= 0x17)
    {
      uint64_t v12 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v8 | 7) != 0x17) {
        uint64_t v12 = v8 | 7;
      }
      uint64_t v13 = v12 + 1;
      size_t v14 = (std::string *)operator new(v12 + 1);
      a2->__r_.__value_.__l.__size_ = v9;
      a2->__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
      a2->__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
      a2 = v14;
    }
    else
    {
      *((unsigned char *)&a2->__r_.__value_.__s + 23) = v8;
      if (!v8)
      {
LABEL_21:
        a2->__r_.__value_.__s.__data_[v9] = 0;
        uint64_t v11 = v17;
        if (v17 == &v19) {
          return;
        }
        goto LABEL_22;
      }
    }
    memmove(a2, v10, v9);
    goto LABEL_21;
  }
  if (*((unsigned char *)this + 33) != 1) {
    goto LABEL_10;
  }
  long long v6 = *(llvm::formatv_object_base **)this;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  LODWORD(v18) = 0;
  char v21 = 0;
  uint64_t v22 = 0;
  int v23 = 1;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  *((void *)&v18 + 1) = 0;
  unsigned int v17 = &unk_1EC9A38B8;
  unint64_t v24 = a2;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v17, 0, 0, 0);
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v17, v6);
  if (v20 != *((void *)&v18 + 1)) {
    llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v17);
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v17);
}

const char *llvm::Twine::toStringRef(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 33) == 1)
  {
    size_t v4 = 0;
    switch(*(unsigned char *)(a1 + 32))
    {
      case 1:
        goto LABEL_4;
      case 3:
        unint64_t v8 = *(const char **)a1;
        if (!*(void *)a1) {
          return 0;
        }
        strlen(*(const char **)a1);
        return v8;
      case 4:
        if (*(char *)(*(void *)a1 + 23) >= 0) {
          return *(const char **)a1;
        }
        else {
          return **(const char ***)a1;
        }
      case 5:
      case 6:
        size_t v4 = *(const char **)a1;
LABEL_4:
        uint64_t result = v4;
        break;
      default:
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    int v11 = 0;
    char v15 = 0;
    uint64_t v16 = 0;
    int v17 = 1;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    __int16 v10 = &unk_1EC9A3930;
    uint64_t v18 = a2;
    llvm::raw_ostream::SetBufferAndMode((uint64_t)&v10, 0, 0, 0);
    unint64_t v7 = llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)&v10, *(void *)a1, *(void *)(a1 + 8), *(unsigned char *)(a1 + 32));
    llvm::Twine::printOneChild(v7, (llvm::raw_ostream *)&v10, *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 33));
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v10);
    return *(const char **)a2;
  }
  return result;
}

void llvm::Twine::toVector(uint64_t a1, uint64_t a2)
{
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  int v12 = 1;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 0;
  long long v5 = &unk_1EC9A3930;
  uint64_t v13 = a2;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v5, 0, 0, 0);
  size_t v4 = llvm::Twine::printOneChild(v3, (llvm::raw_ostream *)&v5, *(void *)a1, *(void *)(a1 + 8), *(unsigned char *)(a1 + 32));
  llvm::Twine::printOneChild(v4, (llvm::raw_ostream *)&v5, *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 33));
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v5);
}

llvm::raw_ostream *llvm::Twine::print(llvm::Twine *this, llvm::raw_ostream *a2)
{
  size_t v4 = llvm::Twine::printOneChild(this, a2, *(void *)this, *((void *)this + 1), *((unsigned char *)this + 32));
  uint64_t v5 = *((void *)this + 2);
  size_t v6 = *((void *)this + 3);
  unsigned __int8 v7 = *((unsigned char *)this + 33);

  return llvm::Twine::printOneChild(v4, a2, v5, v6, v7);
}

void *llvm::Twine::toNullTerminatedStringRef(unsigned __int8 *a1, void *a2)
{
  size_t v2 = a2;
  if (a1[33] != 1) {
    goto LABEL_8;
  }
  unsigned int v4 = a1[32];
  if (v4 < 2) {
    goto LABEL_8;
  }
  if (v4 == 6) {
    return *(void **)a1;
  }
  if (v4 == 4)
  {
    size_t v2 = *(void **)a1;
    if ((*(char *)(*(void *)a1 + 23) & 0x80000000) == 0) {
      return *(void **)a1;
    }
    return (void *)*v2;
  }
  if (v4 != 3)
  {
LABEL_8:
    int v11 = 0;
    char v15 = 0;
    uint64_t v16 = 0;
    int v17 = 1;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    char v10 = &unk_1EC9A3930;
    uint64_t v18 = a2;
    llvm::raw_ostream::SetBufferAndMode((uint64_t)&v10, 0, 0, 0);
    uint64_t v8 = llvm::Twine::printOneChild(v7, (llvm::raw_ostream *)&v10, *(void *)a1, *((void *)a1 + 1), a1[32]);
    llvm::Twine::printOneChild(v8, (llvm::raw_ostream *)&v10, *((void *)a1 + 2), *((void *)a1 + 3), a1[33]);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v10);
    uint64_t v9 = v2[1];
    if ((unint64_t)(v9 + 1) > v2[2])
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v2, v2 + 3, v9 + 1, 1);
      uint64_t v9 = v2[1];
    }
    *(unsigned char *)(*v2 + v9) = 0;
    return (void *)*v2;
  }
  uint64_t v5 = *(void *)a1;
  if (!*(void *)a1) {
    return 0;
  }
  strlen(*(const char **)a1);
  return (void *)v5;
}

llvm::raw_ostream *llvm::Twine::printOneChild(llvm::raw_ostream *result, llvm::raw_ostream *a2, uint64_t a3, size_t a4, unsigned __int8 a5)
{
  int v8 = a5;
  if (a5 == 2)
  {
    do
    {
      uint64_t result = (llvm::raw_ostream *)llvm::Twine::printOneChild(result, a2, *(void *)a3, *(void *)(a3 + 8), *(unsigned __int8 *)(a3 + 32));
      unsigned __int8 v9 = *(unsigned char *)(a3 + 33);
      uint64_t v10 = a3 + 16;
      a3 = *(void *)(a3 + 16);
      a4 = *(void *)(v10 + 8);
      int v8 = v9;
    }
    while (v9 == 2);
  }
  switch(v8)
  {
    case 3:
      if (a3)
      {
        a4 = strlen((const char *)a3);
        uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
        if (a4 > *((void *)a2 + 3) - (void)result) {
          goto LABEL_5;
        }
        goto LABEL_10;
      }
      return result;
    case 4:
      int v14 = *(char *)(a3 + 23);
      if (v14 >= 0) {
        uint64_t v12 = (const char *)a3;
      }
      else {
        uint64_t v12 = *(const char **)a3;
      }
      if (v14 >= 0) {
        size_t v13 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        size_t v13 = *(void *)(a3 + 8);
      }
      int v11 = a2;
      return llvm::raw_ostream::write(v11, v12, v13);
    case 5:
    case 6:
      uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
      if (a4 <= *((void *)a2 + 3) - (void)result)
      {
LABEL_10:
        if (a4)
        {
          uint64_t result = (llvm::raw_ostream *)memcpy(result, (const void *)a3, a4);
          *((void *)a2 + 4) += a4;
        }
      }
      else
      {
LABEL_5:
        int v11 = a2;
        uint64_t v12 = (const char *)a3;
        size_t v13 = a4;
        return llvm::raw_ostream::write(v11, v12, v13);
      }
      return result;
    case 7:
      return llvm::raw_ostream::operator<<(a2, (llvm::formatv_object_base *)a3);
    case 8:
      char v15 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v15 >= *((void *)a2 + 3))
      {
        return llvm::raw_ostream::write(a2, a3);
      }
      else
      {
        *((void *)a2 + 4) = v15 + 1;
        *char v15 = a3;
      }
      return result;
    case 9:
      unint64_t v16 = a3;
      int v17 = a2;
      goto LABEL_29;
    case 10:
      unint64_t v18 = (int)a3;
      uint64_t v19 = a2;
      goto LABEL_32;
    case 11:
      unint64_t v16 = *(void *)a3;
      int v17 = a2;
      goto LABEL_29;
    case 12:
      unint64_t v18 = *(void *)a3;
      uint64_t v19 = a2;
      goto LABEL_32;
    case 13:
      unint64_t v16 = *(void *)a3;
      int v17 = a2;
LABEL_29:
      uint64_t result = llvm::raw_ostream::operator<<(v17, v16);
      break;
    case 14:
      unint64_t v18 = *(void *)a3;
      uint64_t v19 = a2;
LABEL_32:
      uint64_t result = llvm::raw_ostream::operator<<(v19, v18);
      break;
    case 15:
      unint64_t v20 = *(void *)a3;
      uint64_t result = llvm::raw_ostream::write_hex(a2, v20);
      break;
    default:
      return result;
  }
  return result;
}

void llvm::initTypeSizeOptions(llvm *this)
{
  if (!atomic_load_explicit(ScalableErrorAsWarning, memory_order_acquire)) {
}
  }

uint64_t anonymous namespace'::CreateScalableErrorAsWarning::call(_anonymous_namespace_::CreateScalableErrorAsWarning *this)
{
  unint64_t v1 = operator new(0xC0uLL);
  int v4 = 1;
  *(void *)&long long v3 = "Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error";
  *((void *)&v3 + 1) = 109;
  return llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [38],llvm::cl::OptionHidden,llvm::cl::desc>((uint64_t)v1, (int8x16_t *)"treat-scalable-fixed-error-as-warning", &v4, &v3);
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<char [38],llvm::cl::OptionHidden,llvm::cl::desc>(uint64_t a1, int8x16_t *a2, _WORD *a3, _OWORD *a4)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  int v8 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v9 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v11 = *(unsigned int *)(a1 + 72);
  if (v11 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v8, v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v11) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AE0;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3F00;
  *(void *)(a1 + 152) = &unk_1EC9A4440;
  *(void *)(a1 + 160) = &unk_1EC9CE680;
  *(void *)(a1 + 184) = a1 + 160;
  uint64_t v12 = (const unsigned __int8 *)strlen(a2->i8);
  llvm::cl::Option::setArgStr(a1, a2, v12);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

BOOL llvm::vfs::Status::equivalent(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 24) == *(void *)(a2 + 24) && *(void *)(a1 + 32) == *(void *)(a2 + 32);
}

BOOL llvm::vfs::Status::exists(llvm::vfs::Status *this)
{
  return *((_DWORD *)this + 16) > 1u;
}

void llvm::vfs::File::getObjectRefForContent(unsigned char *a1@<X8>)
{
  a1[16] &= ~1u;
  *a1 = 0;
  a1[8] = 0;
}

void *llvm::vfs::FileSystem::getBufferForFile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(void *(**)(void *__return_ptr))(*(void *)a1 + 24))(v19);
  if (v20)
  {
    uint64_t v14 = v19[0];
    uint64_t v15 = v19[1];
  }
  else
  {
    if (!a6) {
      goto LABEL_5;
    }
    uint64_t result = (*(void *(**)(uint64_t *__return_ptr))(*(void *)v19[0] + 40))(&v16);
    if ((v18 & 1) == 0)
    {
      *(void *)a6 = v16;
      *(unsigned char *)(a6 + 8) = v17;
LABEL_5:
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v19[0] + 32))(v19[0], a2, a3, a4, a5);
      if (v20) {
        return result;
      }
      goto LABEL_10;
    }
    uint64_t v14 = v16;
    uint64_t v15 = v17;
  }
  *(unsigned char *)(a7 + 16) |= 1u;
  *(void *)a7 = v14;
  *(void *)(a7 + 8) = v15;
  if (v20) {
    return result;
  }
LABEL_10:
  uint64_t result = (void *)v19[0];
  v19[0] = 0;
  if (result) {
    return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
  }
  return result;
}

unint64_t llvm::vfs::FileSystem::makeAbsolute(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  __int16 v9 = 261;
  int v4 = *(const char **)(a2 + 8);
  v8[0] = *(const char **)a2;
  v8[1] = v4;
  if (llvm::sys::path::is_absolute(v8, 0))
  {
    std::system_category();
    unint64_t v5 = 0;
    unsigned int v6 = 0;
  }
  else
  {
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 48))(&__p, a1);
    if (v12)
    {
      unsigned int v6 = __p;
      unint64_t v5 = (unint64_t)__p & 0xFFFFFFFF00000000;
    }
    else
    {
      __int16 v9 = 260;
      v8[0] = (const char *)&__p;
      llvm::sys::fs::make_absolute((uint64_t)v8, (char **)a2);
      std::system_category();
      unint64_t v5 = 0;
      unsigned int v6 = 0;
      if ((v12 & 1) == 0 && v11 < 0) {
        operator delete(__p);
      }
    }
  }
  return v5 & 0xFFFFFFFF00000000 | v6;
}

BOOL llvm::vfs::FileSystem::exists(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 16))(&__p);
  if (v6) {
    return 0;
  }
  BOOL v1 = v5 > 1;
  if (v4 < 0) {
    operator delete(__p);
  }
  return v1;
}

void llvm::vfs::getRealFileSystem(void *a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2161B8, memory_order_acquire) & 1) == 0)
  {
    unsigned int v5 = a1;
    int v3 = __cxa_guard_acquire(&qword_1EB2161B8);
    a1 = v5;
    if (v3)
    {
      char v4 = operator new(0x150uLL);
      v4[2] = 0;
      *(void *)char v4 = &unk_1EC997D78;
      *((unsigned char *)v4 + 16) = 0;
      *((unsigned char *)v4 + 328) = 0;
      _MergedGlobals_52 = (uint64_t)v4;
      atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
      __cxa_atexit((void (*)(void *))llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>::~IntrusiveRefCntPtr, &_MergedGlobals_52, &dword_180159000);
      __cxa_guard_release(&qword_1EB2161B8);
      a1 = v5;
    }
  }
  uint64_t v2 = _MergedGlobals_52;
  *a1 = _MergedGlobals_52;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
}

atomic_uint **llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>::~IntrusiveRefCntPtr(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t llvm::vfs::FileSystem::getDirectoryEntry@<X0>(const llvm::Twine *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)&v10.__val_ = std::generic_category();
  llvm::errorCodeToError((llvm *)0x2D, v10, &v8);
  uint64_t v5 = v8;
  uint64_t v8 = 0;
  uint64_t v9 = v5;
  llvm::FileError::build(a1, 0, 0, &v9, &v7);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t result = v8;
  if (v8) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v7;
  return result;
}

uint64_t llvm::vfs::FileSystem::isCASFS(llvm::vfs::FileSystem *this)
{
  return 0;
}

uint64_t std::optional<llvm::ErrorOr<anonymous namespace'::RealFileSystem::WorkingDirectory>>::operator=[abi:nn180100]<anonymous namespace'::RealFileSystem::WorkingDirectory,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 312))
  {
    char v13 = 0;
    uint64_t v7 = v9;
    long long v4 = xmmword_1811019F0;
    long long v8 = xmmword_1811019F0;
    if (*(void *)(a2 + 8))
    {
      llvm::SmallVectorImpl<char>::operator=((uint64_t)&v7, a2);
      long long v4 = xmmword_1811019F0;
    }
    std::error_code v10 = v12;
    long long v11 = v4;
    if (*(void *)(a2 + 160)) {
      llvm::SmallVectorImpl<char>::operator=((uint64_t)&v10, a2 + 152);
    }
    if ((v13 & 1) == 0)
    {
      if (v10 != v12) {
        free(v10);
      }
      if (v7 != v9) {
        free(v7);
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 304) &= ~1u;
    *(void *)a1 = a1 + 24;
    long long v5 = xmmword_1811019F0;
    *(_OWORD *)(a1 + 8) = xmmword_1811019F0;
    if (*(void *)(a2 + 8))
    {
      llvm::SmallVectorImpl<char>::operator=(a1, a2);
      long long v5 = xmmword_1811019F0;
    }
    *(void *)(a1 + 152) = a1 + 176;
    *(_OWORD *)(a1 + 160) = v5;
    if (*(void *)(a2 + 160)) {
      llvm::SmallVectorImpl<char>::operator=(a1 + 152, a2 + 152);
    }
    *(unsigned char *)(a1 + 312) = 1;
  }
  return a1;
}

void anonymous namespace'::RealFileSystem::~RealFileSystem(_anonymous_namespace_::RealFileSystem *this)
{
  *(void *)this = &unk_1EC997D78;
  if (*((unsigned char *)this + 328) && (*((unsigned char *)this + 320) & 1) == 0)
  {
    uint64_t v2 = (char *)*((void *)this + 21);
    if (v2 != (char *)this + 192) {
      free(v2);
    }
    int v3 = (char *)*((void *)this + 2);
    if (v3 != (char *)this + 40) {
      free(v3);
    }
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EC997D78;
  if (*((unsigned char *)this + 328) && (*((unsigned char *)this + 320) & 1) == 0)
  {
    uint64_t v2 = (char *)*((void *)this + 21);
    if (v2 != (char *)this + 192) {
      free(v2);
    }
    int v3 = (char *)*((void *)this + 2);
    if (v3 != (char *)this + 40) {
      free(v3);
    }
  }

  operator delete(this);
}

void anonymous namespace'::RealFileSystem::status(_anonymous_namespace_::RealFileSystem *this@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  v22[0].st_mtimespec.uint64_t tv_nsec = 0;
  v22[0].st_ctimespec.tv_sec = (__darwin_time_t)&v22[0].st_birthtimespec.tv_nsec;
  *(_OWORD *)&v22[0].st_ctimespec.uint64_t tv_nsec = xmmword_1811012D0;
  memset(v22, 0, 44);
  *(uint64_t *)((char *)&v22[0].st_atimespec.tv_nsec + 4) = 0xFFFFLL;
  WORD2(v22[0].st_mtimespec.tv_sec) = 0;
  if (*((unsigned char *)this + 328) && (*((unsigned char *)this + 320) & 1) == 0)
  {
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v22[0].st_ctimespec);
    *(_WORD *)&v19[16] = 261;
    uint64_t v6 = *((void *)this + 22);
    st_ctimespec.tv_sec = *((void *)this + 21);
    st_ctimespec.uint64_t tv_nsec = v6;
    llvm::sys::fs::make_absolute((uint64_t)&st_ctimespec, (char **)&v22[0].st_ctimespec);
    *(_WORD *)&v19[16] = 261;
    timespec st_ctimespec = v22[0].st_ctimespec;
    uint64_t v7 = llvm::sys::fs::status((llvm::sys::fs *)&st_ctimespec, v22, (llvm::sys::fs::file_status *)1);
    if (!v7) {
      goto LABEL_4;
    }
LABEL_7:
    *(unsigned char *)(a3 + 80) |= 1u;
    *(void *)a3 = v7;
    *(void *)(a3 + 8) = v8;
    tv_sec = (void *)v22[0].st_ctimespec.tv_sec;
    if ((uint64_t *)v22[0].st_ctimespec.tv_sec == &v22[0].st_birthtimespec.tv_nsec) {
      return;
    }
    goto LABEL_8;
  }
  long long v17 = *((_OWORD *)a2 + 1);
  timespec st_ctimespec = *(timespec *)a2;
  *(_OWORD *)uint64_t v19 = v17;
  *(void *)&v19[16] = *((void *)a2 + 4);
  uint64_t v7 = llvm::sys::fs::status((llvm::sys::fs *)&st_ctimespec, v22, (llvm::sys::fs::file_status *)1);
  if (v7) {
    goto LABEL_7;
  }
LABEL_4:
  uint64_t UniqueID = llvm::sys::fs::file_status::getUniqueID((llvm::sys::fs::file_status *)v22);
  uint64_t v11 = v10;
  uint64_t LastModificationTime = llvm::sys::fs::basic_file_status::getLastModificationTime((llvm::sys::fs::basic_file_status *)v22);
  __darwin_time_t v13 = v22[0].st_atimespec.tv_sec;
  uint64_t v14 = *(void *)&v22[0].st_rdev;
  uint64_t tv_nsec = v22[0].st_atimespec.tv_nsec;
  llvm::Twine::str(a2, (std::string *)&st_ctimespec);
  *(void *)&v19[8] = UniqueID;
  *(void *)&v19[16] = v11;
  *(void *)&long long v20 = LastModificationTime;
  *((void *)&v20 + 1) = v14;
  *(void *)&long long v21 = v13;
  *((void *)&v21 + 1) = tv_nsec;
  *(unsigned char *)(a3 + 80) &= ~1u;
  *(timespec *)a3 = st_ctimespec;
  *(void *)(a3 + 16) = *(void *)v19;
  *(_WORD *)(a3 + 72) = 0;
  *(_OWORD *)(a3 + 56) = v21;
  *(_OWORD *)(a3 + 40) = v20;
  *(_OWORD *)(a3 + 24) = *(_OWORD *)&v19[8];
  tv_sec = (void *)v22[0].st_ctimespec.tv_sec;
  if ((uint64_t *)v22[0].st_ctimespec.tv_sec != &v22[0].st_birthtimespec.tv_nsec) {
LABEL_8:
  }
    free(tv_sec);
}

void anonymous namespace'::RealFileSystem::openFileForRead(_anonymous_namespace_::RealFileSystem *this@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  v32[32] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = v32;
  long long v31 = xmmword_1811012D0;
  uint64_t v27 = v29;
  long long v28 = xmmword_1811012D0;
  if (!*((unsigned char *)this + 328) || (*((unsigned char *)this + 320) & 1) != 0)
  {
    long long v7 = *((_OWORD *)a2 + 1);
    v23[0] = *(_OWORD *)a2;
    v23[1] = v7;
    uint64_t v24 = *((void *)a2 + 4);
  }
  else
  {
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v27);
    LOWORD(v24) = 261;
    uint64_t v6 = *((void *)this + 22);
    *(void *)&v23[0] = *((void *)this + 21);
    *((void *)&v23[0] + 1) = v6;
    llvm::sys::fs::make_absolute((uint64_t)v23, (char **)&v27);
    LOWORD(v24) = 261;
    v23[0] = __PAIR128__(v28, (unint64_t)v27);
  }
  llvm::sys::fs::openNativeFileForRead((unsigned __int8 *)v23, 0, &v30, (uint64_t)&v25);
  if (v26)
  {
    uint64_t v15 = v25;
    uint64_t v25 = 0;
    uint64_t v22 = v15;
    uint64_t v16 = llvm::errorToErrorCode(&v22);
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v16;
    *(void *)(a3 + 8) = v17;
    if (v22) {
      (*(void (**)(void *))(*v22 + 8))(v22);
    }
    goto LABEL_23;
  }
  uint64_t v8 = (char *)operator new(0x78uLL);
  int v9 = (int)v25;
  llvm::Twine::str(a2, &__p);
  std::string::size_type size = __p.__r_.__value_.__l.__size_;
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  __darwin_time_t v13 = v30;
  size_t v12 = v31;
  *(void *)uint64_t v8 = &unk_1EC99C730;
  *((_DWORD *)v8 + 2) = v9;
  LOWORD(v24) = 261;
  *(void *)&v23[0] = p_p;
  *((void *)&v23[0] + 1) = size;
  llvm::Twine::str((llvm::Twine *)v23, (std::string *)(v8 + 16));
  *((_WORD *)v8 + 44) = 0;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  uint64_t v14 = v8 + 96;
  if (!v13)
  {
    *uint64_t v14 = 0;
    *((void *)v8 + 13) = 0;
    *((void *)v8 + 14) = 0;
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v8;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  if (v12 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v12 >= 0x17)
  {
    uint64_t v18 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v18 = v12 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v14 = operator new(v18 + 1);
    *((void *)v8 + 13) = v12;
    *((void *)v8 + 14) = v19 | 0x8000000000000000;
    *((void *)v8 + 12) = v14;
    goto LABEL_20;
  }
  v8[119] = v12;
  if (v12) {
LABEL_20:
  }
    memmove(v14, v13, v12);
  *((unsigned char *)v14 + v12) = 0;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_22:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_23:
  if (v26)
  {
    long long v20 = v25;
    uint64_t v25 = 0;
    if (v20) {
      (*(void (**)(void *))(*v20 + 8))(v20);
    }
  }
  if (v27 != v29) {
    free(v27);
  }
  if (v30 != v32) {
    free(v30);
  }
}

void anonymous namespace'::RealFileSystem::dir_begin(_anonymous_namespace_::RealFileSystem *this@<X0>, const llvm::Twine *a2@<X1>, std::error_code *a3@<X2>, void *a4@<X8>)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v29;
  long long v28 = xmmword_1811019F0;
  if (!*((unsigned char *)this + 328) || (*((unsigned char *)this + 320) & 1) != 0)
  {
    long long v8 = *((_OWORD *)a2 + 1);
    v24[0] = *(_OWORD *)a2;
    v24[1] = v8;
    uint64_t v25 = *((void *)a2 + 4);
  }
  else
  {
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v27);
    __int16 v32 = 261;
    uint64_t v7 = *((void *)this + 22);
    *(void *)&long long v30 = *((void *)this + 21);
    *((void *)&v30 + 1) = v7;
    llvm::sys::fs::make_absolute((uint64_t)&v30, (char **)&v27);
    LOWORD(v25) = 261;
    v24[0] = __PAIR128__(v28, (unint64_t)v27);
  }
  int v9 = (std::__shared_weak_count *)operator new(0x58uLL);
  v9->__shared_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CFD78;
  v9[1].__shared_owners_ = 0;
  v9[1].__shared_weak_owners_ = 0;
  v9[2].__vftable = 0;
  LODWORD(v9[2].__shared_owners_) = 9;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC997C78;
  p_uint64_t shared_weak_owners = &v9[2].__shared_weak_owners_;
  uint64_t v11 = (uint64_t *)llvm::sys::fs::directory_iterator::directory_iterator((llvm::sys::fs::directory_iterator *)&v9[2].__shared_weak_owners_, (const char **)v24, a3, 1);
  uint64_t v31 = 1;
  long long v30 = 0uLL;
  BOOL v12 = llvm::sys::fs::directory_iterator::operator==(v11, (uint64_t *)&v30);
  BOOL v13 = v12;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v30 + 1);
  if (*((void *)&v30 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v30 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    if (v13) {
      goto LABEL_21;
    }
  }
  else if (v12)
  {
    goto LABEL_21;
  }
  uint64_t v15 = *p_shared_weak_owners;
  if (*(char *)(*p_shared_weak_owners + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
    uint64_t v15 = *p_shared_weak_owners;
    int v17 = *(_DWORD *)(*p_shared_weak_owners + 32);
    if (v17 != 9) {
      goto LABEL_13;
    }
  }
  else
  {
    long long v16 = *(_OWORD *)(v15 + 8);
    v26.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v16;
    int v17 = *(_DWORD *)(v15 + 32);
    if (v17 != 9) {
      goto LABEL_13;
    }
  }
  llvm::sys::fs::directory_entry::status((llvm::sys::fs::directory_entry *)(v15 + 8), (uint64_t)&v30);
  if (v34) {
    int v17 = 9;
  }
  else {
    int v17 = v33;
  }
LABEL_13:
  *(void *)&long long v30 = v26.__r_.__value_.__l.__size_;
  std::string::size_type v18 = v26.__r_.__value_.__r.__words[0];
  *(void *)((char *)&v30 + 7) = *(std::string::size_type *)((char *)&v26.__r_.__value_.__r.__words[1] + 7);
  char v19 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
  memset(&v26, 0, sizeof(v26));
  if (SHIBYTE(v9[2].__vftable) < 0)
  {
    operator delete((void *)v9[1].__shared_owners_);
    int v21 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
    uint64_t v22 = v30;
    v9[1].__shared_owners_ = v18;
    v9[1].__shared_weak_owners_ = v22;
    *(uint64_t *)((char *)&v9[1].__shared_weak_owners_ + 7) = *(void *)((char *)&v30 + 7);
    HIBYTE(v9[2].__vftable) = v19;
    LODWORD(v9[2].__shared_owners_) = v17;
    if (v21 < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v20 = v30;
    v9[1].__shared_owners_ = v18;
    v9[1].__shared_weak_owners_ = v20;
    *(uint64_t *)((char *)&v9[1].__shared_weak_owners_ + 7) = *(void *)((char *)&v30 + 7);
    HIBYTE(v9[2].__vftable) = v19;
    LODWORD(v9[2].__shared_owners_) = v17;
  }
LABEL_21:
  *a4 = v9 + 1;
  a4[1] = v9;
  uint64_t shared_weak_owners = HIBYTE(v9[2].__vftable);
  if ((shared_weak_owners & 0x80u) != 0) {
    uint64_t shared_weak_owners = v9[1].__shared_weak_owners_;
  }
  if (!shared_weak_owners)
  {
    *a4 = 0;
    a4[1] = 0;
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v27 != v29) {
    free(v27);
  }
}

unint64_t anonymous namespace'::RealFileSystem::setCurrentWorkingDirectory(_anonymous_namespace_::RealFileSystem *this, const llvm::Twine *a2)
{
  v29[16] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 328))
  {
    unint64_t is_directory = llvm::sys::fs::set_current_path(a2, a2);
    unsigned int v5 = is_directory;
    return is_directory & 0xFFFFFFFF00000000 | v5;
  }
  uint64_t v27 = v29;
  long long v28 = xmmword_1811019F0;
  uint64_t v24 = v26;
  long long v25 = xmmword_1811019F0;
  int v21 = v23;
  long long v22 = xmmword_1811019F0;
  if (*((unsigned char *)this + 320))
  {
    long long v6 = *((_OWORD *)a2 + 1);
    *(_OWORD *)long long v16 = *(_OWORD *)a2;
    *(_OWORD *)&v16[16] = v6;
    uint64_t v17 = *((void *)a2 + 4);
  }
  else
  {
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v21);
    LOWORD(v17) = 261;
    uint64_t v3 = *((void *)this + 22);
    *(void *)long long v16 = *((void *)this + 21);
    *(void *)&v16[8] = v3;
    llvm::sys::fs::make_absolute((uint64_t)v16, &v21);
    LOWORD(v17) = 261;
    *(void *)long long v16 = v21;
    *(void *)&v16[8] = v22;
  }
  llvm::Twine::toVector((uint64_t)v16, (uint64_t)&v27);
  char v15 = 0;
  LOWORD(v17) = 261;
  *(void *)long long v16 = v27;
  *(void *)&v16[8] = v28;
  unint64_t is_directory = llvm::sys::fs::is_directory((llvm::sys::fs *)v16, (const llvm::Twine *)&v15, v7);
  if (!is_directory)
  {
    if (!v15)
    {
      unint64_t is_directory = 20;
      std::generic_category();
      unsigned int v5 = 20;
      goto LABEL_8;
    }
    LOWORD(v17) = 261;
    *(void *)long long v16 = v27;
    *(void *)&v16[8] = v28;
    unint64_t is_directory = llvm::sys::fs::real_path(v16, &v24, 0);
    if (!is_directory)
    {
      *(void *)long long v16 = &v16[24];
      *(_OWORD *)&v16[8] = xmmword_1811019F0;
      uint64_t v9 = v28;
      if (!(void)v28) {
        goto LABEL_25;
      }
      if ((unint64_t)v28 < 0x81)
      {
        uint64_t v11 = &v16[24];
        size_t v10 = v28;
      }
      else
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v16, &v16[24], v28, 1);
        size_t v10 = v28;
        if (!(void)v28)
        {
LABEL_24:
          *(void *)&v16[8] = v9;
LABEL_25:
          std::string::size_type v18 = v20;
          long long v19 = xmmword_1811019F0;
          uint64_t v12 = v25;
          if (!(void)v25)
          {
LABEL_32:
            if (v18 != v20) {
              free(v18);
            }
            if (*(unsigned char **)v16 != &v16[24]) {
              free(*(void **)v16);
            }
            std::system_category();
            unsigned int v5 = 0;
            goto LABEL_8;
          }
          if ((unint64_t)v25 < 0x81)
          {
            uint64_t v14 = v20;
            size_t v13 = v25;
          }
          else
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v18, v20, v25, 1);
            size_t v13 = v25;
            if (!(void)v25)
            {
LABEL_31:
              *(void *)&long long v19 = v12;
              goto LABEL_32;
            }
            uint64_t v14 = v18;
          }
          memcpy(v14, v24, v13);
          goto LABEL_31;
        }
        uint64_t v11 = *(unsigned char **)v16;
      }
      memcpy(v11, v27, v10);
      goto LABEL_24;
    }
  }
  unsigned int v5 = is_directory;
LABEL_8:
  if (v21 != v23) {
    free(v21);
  }
  if (v24 != v26) {
    free(v24);
  }
  if (v27 != v29) {
    free(v27);
  }
  return is_directory & 0xFFFFFFFF00000000 | v5;
}

void anonymous namespace'::RealFileSystem::getCurrentWorkingDirectory(_anonymous_namespace_::RealFileSystem *this@<X0>, uint64_t a2@<X8>)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 328))
  {
    if (*((unsigned char *)this + 320))
    {
      uint64_t v10 = *((void *)this + 2);
      uint64_t v9 = *((void *)this + 3);
      *(unsigned char *)(a2 + 24) |= 1u;
      *(void *)a2 = v10;
      *(void *)(a2 + 8) = v9;
      return;
    }
    size_t v3 = *((void *)this + 3);
    if (v3 <= 0x7FFFFFFFFFFFFFF7)
    {
      long long v4 = (const void *)*((void *)this + 2);
      if (v3 >= 0x17)
      {
        uint64_t v11 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v3 | 7) != 0x17) {
          uint64_t v11 = v3 | 7;
        }
        uint64_t v12 = v11 + 1;
        unsigned int v5 = operator new(v11 + 1);
        *(void *)&__dst[8] = v3;
        *(void *)&__dst[16] = v12 | 0x8000000000000000;
        *(void *)std::string __dst = v5;
      }
      else
      {
        __dst[23] = *((void *)this + 3);
        unsigned int v5 = __dst;
        if (!v3) {
          goto LABEL_15;
        }
      }
      memmove(v5, v4, v3);
LABEL_15:
      v5[v3] = 0;
      *(unsigned char *)(a2 + 24) &= ~1u;
      *(_OWORD *)a2 = *(_OWORD *)__dst;
      *(void *)(a2 + 16) = *(void *)&__dst[16];
      return;
    }
LABEL_27:
    abort();
  }
  *(void *)std::string __dst = v21;
  *(_OWORD *)&__dst[8] = xmmword_1811019F0;
  uint64_t v6 = llvm::sys::fs::current_path((uint64_t)__dst);
  if (!v6)
  {
    size_t v13 = *(void *)&__dst[8];
    if (*(void *)&__dst[8] > 0x7FFFFFFFFFFFFFF7uLL) {
      goto LABEL_27;
    }
    uint64_t v14 = *(const void **)__dst;
    if (*(void *)&__dst[8] >= 0x17uLL)
    {
      uint64_t v16 = (*(void *)&__dst[8] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((*(void *)&__dst[8] | 7) != 0x17) {
        uint64_t v16 = *(void *)&__dst[8] | 7;
      }
      uint64_t v17 = v16 + 1;
      char v15 = (long long *)operator new(v16 + 1);
      *((void *)&v18 + 1) = v13;
      unint64_t v19 = v17 | 0x8000000000000000;
      *(void *)&long long v18 = v15;
    }
    else
    {
      HIBYTE(v19) = __dst[8];
      char v15 = &v18;
      if (!*(void *)&__dst[8])
      {
LABEL_24:
        *((unsigned char *)v15 + v13) = 0;
        *(unsigned char *)(a2 + 24) &= ~1u;
        *(_OWORD *)a2 = v18;
        long long v8 = *(void **)__dst;
        *(void *)(a2 + 16) = v19;
        if (v8 == v21) {
          return;
        }
        goto LABEL_25;
      }
    }
    memmove(v15, v14, v13);
    goto LABEL_24;
  }
  *(unsigned char *)(a2 + 24) |= 1u;
  *(void *)a2 = v6;
  *(void *)(a2 + 8) = v7;
  long long v8 = *(void **)__dst;
  if (*(void **)__dst == v21) {
    return;
  }
LABEL_25:
  free(v8);
}

unint64_t anonymous namespace'::RealFileSystem::getRealPath(uint64_t a1, uint64_t a2, void *a3)
{
  v13[32] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = v13;
  long long v12 = xmmword_1811012D0;
  if (!*(unsigned char *)(a1 + 328) || (*(unsigned char *)(a1 + 320) & 1) != 0)
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    v9[0] = *(_OWORD *)a2;
    v9[1] = v6;
    uint64_t v10 = *(void *)(a2 + 32);
  }
  else
  {
    llvm::Twine::toVector(a2, (uint64_t)&v11);
    LOWORD(v10) = 261;
    uint64_t v5 = *(void *)(a1 + 176);
    *(void *)&v9[0] = *(void *)(a1 + 168);
    *((void *)&v9[0] + 1) = v5;
    llvm::sys::fs::make_absolute((uint64_t)v9, (char **)&v11);
    LOWORD(v10) = 261;
    v9[0] = __PAIR128__(v12, (unint64_t)v11);
  }
  unint64_t v7 = llvm::sys::fs::real_path((unsigned __int8 *)v9, a3, 0);
  if (v11 != v13) {
    free(v11);
  }
  return v7;
}

uint64_t anonymous namespace'::RealFileSystem::isLocal(_anonymous_namespace_::RealFileSystem *this, const llvm::Twine *a2, const llvm::Twine *a3)
{
  v13[32] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = v13;
  long long v12 = xmmword_1811012D0;
  if (!*((unsigned char *)this + 328) || (*((unsigned char *)this + 320) & 1) != 0)
  {
    long long v6 = *((_OWORD *)a2 + 1);
    v9[0] = *(_OWORD *)a2;
    v9[1] = v6;
    uint64_t v10 = *((void *)a2 + 4);
  }
  else
  {
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v11);
    LOWORD(v10) = 261;
    uint64_t v5 = *((void *)this + 22);
    *(void *)&v9[0] = *((void *)this + 21);
    *((void *)&v9[0] + 1) = v5;
    llvm::sys::fs::make_absolute((uint64_t)v9, (char **)&v11);
    LOWORD(v10) = 261;
    v9[0] = __PAIR128__(v12, (unint64_t)v11);
  }
  uint64_t is_local = llvm::sys::fs::is_local((llvm::sys::fs *)v9, a3, (BOOL *)a3);
  if (v11 != v13) {
    free(v11);
  }
  return is_local;
}

llvm::raw_ostream *anonymous namespace'::RealFileSystem::printImpl(llvm::raw_ostream *result, llvm::raw_ostream *this, uint64_t a3, int a4)
{
  uint64_t v5 = (uint64_t)result;
  if (a4)
  {
    int v6 = a4;
    do
    {
      while (1)
      {
        unint64_t v7 = (_WORD *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v7 <= 1uLL) {
          break;
        }
        *unint64_t v7 = 8224;
        *((void *)this + 4) += 2;
        if (!--v6) {
          goto LABEL_6;
        }
      }
      uint64_t result = llvm::raw_ostream::write(this, "  ", 2uLL);
      --v6;
    }
    while (v6);
  }
LABEL_6:
  long long v8 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v8 > 0x14uLL)
  {
    qmemcpy(v8, "RealFileSystem using ", 21);
    *((void *)this + 4) += 21;
    uint64_t v9 = *((void *)this + 4);
    unint64_t v10 = *((void *)this + 3) - v9;
    if (*(unsigned char *)(v5 + 328))
    {
LABEL_8:
      if (v10 > 2)
      {
        *(unsigned char *)(v9 + 2) = 110;
        *(_WORD *)uint64_t v9 = 30575;
        *((void *)this + 4) += 3;
        uint64_t v11 = *((void *)this + 4);
        if ((unint64_t)(*((void *)this + 3) - v11) <= 4) {
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, "own", 3uLL);
        uint64_t v11 = *((void *)this + 4);
        if ((unint64_t)(*((void *)this + 3) - v11) <= 4) {
          goto LABEL_18;
        }
      }
LABEL_14:
      *(unsigned char *)(v11 + 4) = 10;
      *(_DWORD *)uint64_t v11 = 1146569504;
      *((void *)this + 4) += 5;
      return result;
    }
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(this, "RealFileSystem using ", 0x15uLL);
    uint64_t v9 = *((void *)this + 4);
    unint64_t v10 = *((void *)this + 3) - v9;
    if (*(unsigned char *)(v5 + 328)) {
      goto LABEL_8;
    }
  }
  if (v10 > 6)
  {
    *(_DWORD *)(v9 + 3) = 1936942435;
    *(_DWORD *)uint64_t v9 = 1668248176;
    *((void *)this + 4) += 7;
    uint64_t v11 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v11) > 4) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(this, "process", 7uLL);
    uint64_t v11 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v11) > 4) {
      goto LABEL_14;
    }
  }
LABEL_18:

  return llvm::raw_ostream::write(this, " CWD\n", 5uLL);
}

uint64_t llvm::ErrorOr<anonymous namespace'::RealFileSystem::WorkingDirectory>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  if ((*(unsigned char *)(a1 + 304) & 1) == 0)
  {
    long long v4 = *(void **)(a1 + 152);
    if (v4 != (void *)(a1 + 176)) {
      free(v4);
    }
    if (*(void *)a1 != a1 + 24) {
      free(*(void **)a1);
    }
  }
  char v5 = *(unsigned char *)(a1 + 304);
  if ((*(unsigned char *)(a2 + 304) & 1) == 0)
  {
    *(unsigned char *)(a1 + 304) = v5 & 0xFE;
    *(void *)a1 = a1 + 24;
    long long v6 = xmmword_1811019F0;
    *(_OWORD *)(a1 + 8) = xmmword_1811019F0;
    if (*(void *)(a2 + 8))
    {
      llvm::SmallVectorImpl<char>::operator=(a1, a2);
      long long v6 = xmmword_1811019F0;
    }
    *(void *)(a1 + 152) = a1 + 176;
    *(_OWORD *)(a1 + 160) = v6;
    if (*(void *)(a2 + 160)) {
      llvm::SmallVectorImpl<char>::operator=(a1 + 152, a2 + 152);
    }
    return a1;
  }
  *(unsigned char *)(a1 + 304) = v5 | 1;
  if (*(unsigned char *)(a2 + 304))
  {
    long long v8 = *(const std::error_category **)(a2 + 8);
    *(void *)a1 = *(void *)a2;
  }
  else
  {
    long long v8 = std::system_category();
    *(void *)a1 = 0;
  }
  *(void *)(a1 + 8) = v8;
  return a1;
}

void anonymous namespace'::RealFile::~RealFile(_anonymous_namespace_::RealFile *this, int *a2)
{
  *(void *)this = &unk_1EC99C730;
  llvm::sys::fs::closeFile((_anonymous_namespace_::RealFile *)((char *)this + 8), a2);
  *((_DWORD *)this + 2) = -1;
  if ((*((char *)this + 119) & 0x80000000) == 0)
  {
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(*((void **)this + 2));
    return;
  }
  operator delete(*((void **)this + 12));
  if (*((char *)this + 39) < 0) {
    goto LABEL_5;
  }
}

{
  _anonymous_namespace_::RealFile *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EC99C730;
  llvm::sys::fs::closeFile((_anonymous_namespace_::RealFile *)((char *)this + 8), a2);
  *((_DWORD *)this + 2) = -1;
  if (*((char *)this + 119) < 0)
  {
    operator delete(*((void **)this + 12));
    if ((*((char *)this + 39) & 0x80000000) == 0)
    {
LABEL_3:
      size_t v3 = this;
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 2));
  size_t v3 = this;

LABEL_5:
  operator delete(v3);
}

void anonymous namespace'::RealFile::status(_anonymous_namespace_::RealFile *this@<X0>, llvm::sys::fs::file_status *a2@<X2>, uint64_t a3@<X8>)
{
  char v5 = (char *)this + 16;
  if (!*((_DWORD *)this + 20))
  {
    memset(&v27, 0, 44);
    *(uint64_t *)((char *)&v27.st_atimespec.tv_nsec + 4) = 0xFFFFLL;
    WORD2(v27.st_mtimespec.tv_sec) = 0;
    v27.st_mtimespec.uint64_t tv_nsec = 0;
    uint64_t v6 = llvm::sys::fs::status((llvm::sys::fs *)*((unsigned int *)this + 2), &v27, a2);
    if (v6)
    {
      *(unsigned char *)(a3 + 80) |= 1u;
      *(void *)a3 = v6;
      *(void *)(a3 + 8) = v7;
      return;
    }
    int v8 = *((char *)this + 39);
    BOOL v9 = v8 < 0;
    unint64_t v10 = (char *)*((void *)this + 2);
    if (v8 >= 0) {
      unint64_t v10 = v5;
    }
    uint64_t v11 = *((unsigned __int8 *)this + 39);
    if (v9) {
      uint64_t v11 = *((void *)this + 3);
    }
    __int16 v21 = 261;
    v20[0] = v10;
    v20[1] = v11;
    uint64_t UniqueID = llvm::sys::fs::file_status::getUniqueID((llvm::sys::fs::file_status *)&v27);
    uint64_t v14 = v13;
    uint64_t LastModificationTime = llvm::sys::fs::basic_file_status::getLastModificationTime((llvm::sys::fs::basic_file_status *)&v27);
    __darwin_time_t tv_sec = v27.st_atimespec.tv_sec;
    uint64_t v17 = *(void *)&v27.st_rdev;
    uint64_t tv_nsec = v27.st_atimespec.tv_nsec;
    llvm::Twine::str((llvm::Twine *)v20, &v22);
    *(void *)&long long v23 = UniqueID;
    *((void *)&v23 + 1) = v14;
    *(void *)&long long v24 = LastModificationTime;
    *((void *)&v24 + 1) = v17;
    *(void *)&long long v25 = tv_sec;
    *((void *)&v25 + 1) = tv_nsec;
    __int16 v26 = 0;
    if (*((char *)this + 39) < 0) {
      operator delete(*(void **)v5);
    }
    *(std::string *)char v5 = v22;
    long long v19 = v24;
    *(_OWORD *)((char *)this + 40) = v23;
    *(_OWORD *)((char *)this + 56) = v19;
    *(_OWORD *)((char *)this + 72) = v25;
    *((_WORD *)this + 44) = v26;
    *(unsigned char *)(a3 + 80) &= ~1u;
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_13:
    std::string::__init_copy_ctor_external((std::string *)a3, *((const std::string::value_type **)this + 2), *((void *)this + 3));
    goto LABEL_14;
  }
  *(unsigned char *)(a3 + 80) &= ~1u;
  if (*((char *)this + 39) < 0) {
    goto LABEL_13;
  }
LABEL_3:
  *(_OWORD *)a3 = *(_OWORD *)v5;
  *(void *)(a3 + 16) = *((void *)v5 + 2);
LABEL_14:
  *(_OWORD *)(a3 + 24) = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)(a3 + 40) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)(a3 + 56) = *(_OWORD *)((char *)this + 72);
  *(_WORD *)(a3 + 72) = *((_WORD *)this + 44);
}

double anonymous namespace'::RealFile::getName@<D0>(_anonymous_namespace_::RealFile *this@<X0>, std::string *a2@<X8>)
{
  size_t v3 = (const std::string::value_type **)((char *)this + 96);
  if (*((char *)this + 119) < 0)
  {
    std::string::size_type v4 = *((void *)this + 13);
    if (v4)
    {
      std::string::__init_copy_ctor_external(&v15, *v3, v4);
      goto LABEL_23;
    }
LABEL_6:
    uint64_t v7 = (std::string::size_type *)*((void *)this + 2);
    char v5 = (std::string::size_type *)((char *)this + 16);
    uint64_t v6 = v7;
    int v8 = *((char *)v5 + 23);
    if (v8 >= 0) {
      BOOL v9 = v5;
    }
    else {
      BOOL v9 = v6;
    }
    if (v8 >= 0) {
      std::string::size_type v10 = *((unsigned __int8 *)v5 + 23);
    }
    else {
      std::string::size_type v10 = v5[1];
    }
    if (!v9)
    {
      memset(&v15, 0, sizeof(v15));
      goto LABEL_23;
    }
    if (v10 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v10 >= 0x17)
    {
      uint64_t v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v12 = v10 | 7;
      }
      uint64_t v13 = v12 + 1;
      uint64_t v11 = (std::string *)operator new(v12 + 1);
      v15.__r_.__value_.__l.__size_ = v10;
      v15.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
      v15.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
    }
    else
    {
      *((unsigned char *)&v15.__r_.__value_.__s + 23) = v10;
      uint64_t v11 = &v15;
      if (!v10) {
        goto LABEL_22;
      }
    }
    memmove(v11, v9, v10);
LABEL_22:
    v11->__r_.__value_.__s.__data_[v10] = 0;
    goto LABEL_23;
  }
  if (!*((unsigned char *)this + 119)) {
    goto LABEL_6;
  }
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)v3;
  v15.__r_.__value_.__r.__words[2] = *((void *)this + 14);
LABEL_23:
  a2[1].__r_.__value_.__s.__data_[0] &= ~1u;
  double result = *(double *)&v15.__r_.__value_.__l.__data_;
  *a2 = v15;
  return result;
}

void anonymous namespace'::RealFile::getBuffer(_anonymous_namespace_::RealFile *this@<X0>, const llvm::Twine *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, char a5@<W4>, uint64_t a6@<X8>)
{
}

uint64_t anonymous namespace'::RealFile::close(_anonymous_namespace_::RealFile *this, int *a2)
{
  uint64_t result = llvm::sys::fs::closeFile((_anonymous_namespace_::RealFile *)((char *)this + 8), a2);
  *((_DWORD *)this + 2) = -1;
  return result;
}

void anonymous namespace'::RealFile::setPath(_anonymous_namespace_::RealFile *this, const llvm::Twine *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  llvm::Twine::str(a2, &__p);
  std::string::size_type v4 = (void **)((char *)this + 96);
  if (*((char *)this + 119) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)std::string::size_type v4 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *((void *)this + 14) = *((void *)&__p.__r_.__value_.__l + 2);
  (*(void (**)(std::string *__return_ptr, _anonymous_namespace_::RealFile *))(*(void *)this + 16))(&__p, this);
  char v5 = v24;
  if ((v24 & 1) == 0)
  {
    long long v12 = v19;
    uint64_t v6 = v20;
    uint64_t v7 = v22;
    uint64_t v8 = v21;
    uint64_t v9 = v23;
    llvm::Twine::str(a2, &v13);
    long long v14 = v12;
    *(void *)&long long v15 = v6;
    *((void *)&v15 + 1) = v8;
    *(void *)&long long v16 = v7;
    *((void *)&v16 + 1) = v9;
    __int16 v17 = 0;
    std::string::size_type v10 = (void **)((char *)this + 16);
    if (*((char *)this + 39) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)std::string::size_type v10 = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
    *((void *)this + 4) = *((void *)&v13.__r_.__value_.__l + 2);
    long long v11 = v15;
    *(_OWORD *)((char *)this + 40) = v14;
    *(_OWORD *)((char *)this + 56) = v11;
    *(_OWORD *)((char *)this + 72) = v16;
    *((_WORD *)this + 44) = v17;
    char v5 = v24;
  }
  if ((v5 & 1) == 0 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void std::__shared_ptr_emplace<anonymous namespace'::RealFSDirIter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CFD78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::RealFSDirIter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CFD78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::RealFSDirIter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::RealFSDirIter::~RealFSDirIter(_anonymous_namespace_::RealFSDirIter *this)
{
  *(void *)this = &unk_1EC997C78;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (!v2 || atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    *(void *)this = &unk_1EC9A4500;
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      return;
    }
LABEL_6:
    operator delete(*((void **)this + 1));
    return;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  *(void *)this = &unk_1EC9A4500;
  if (*((char *)this + 31) < 0) {
    goto LABEL_6;
  }
}

{
  std::__shared_weak_count *v2;
  _anonymous_namespace_::RealFSDirIter *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EC997C78;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    *(void *)this = &unk_1EC9A4500;
    if ((*((char *)this + 31) & 0x80000000) == 0)
    {
LABEL_4:
      size_t v3 = this;
      goto LABEL_6;
    }
  }
  else
  {
    *(void *)this = &unk_1EC9A4500;
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      goto LABEL_4;
    }
  }
  operator delete(*((void **)this + 1));
  size_t v3 = this;

LABEL_6:
  operator delete(v3);
}

unint64_t anonymous namespace'::RealFSDirIter::increment(_anonymous_namespace_::RealFSDirIter *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  std::system_category();
  uint64_t v2 = (char *)this + 40;
  unint64_t v3 = llvm::sys::fs::detail::directory_iterator_increment(*((void *)this + 5));
  long long v18 = 0;
  uint64_t v17 = 0;
  uint64_t v19 = 1;
  BOOL v4 = llvm::sys::fs::directory_iterator::operator==((uint64_t *)this + 5, &v17);
  if (!v4)
  {
    uint64_t v9 = *(void *)v2;
    if (*(char *)(*(void *)v2 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      uint64_t v9 = *(void *)v2;
      int v7 = *(_DWORD *)(*(void *)v2 + 32);
      if (v7 != 9) {
        goto LABEL_9;
      }
    }
    else
    {
      long long v10 = *(_OWORD *)(v9 + 8);
      __p.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v10;
      int v7 = *(_DWORD *)(v9 + 32);
      if (v7 != 9) {
        goto LABEL_9;
      }
    }
    llvm::sys::fs::directory_entry::status((llvm::sys::fs::directory_entry *)(v9 + 8), (uint64_t)v20);
    if (v22) {
      int v7 = 9;
    }
    else {
      int v7 = v21;
    }
LABEL_9:
    v20[0] = __p.__r_.__value_.__l.__size_;
    std::string::size_type v5 = __p.__r_.__value_.__r.__words[0];
    *(void *)((char *)v20 + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
    char v6 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    memset(&__p, 0, sizeof(__p));
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      goto LABEL_3;
    }
    goto LABEL_10;
  }
  std::string::size_type v5 = 0;
  char v6 = 0;
  *(void *)((char *)v20 + 7) = 0;
  v20[0] = 0;
  int v7 = 9;
  if ((*((char *)this + 31) & 0x80000000) == 0)
  {
LABEL_3:
    uint64_t v8 = v20[0];
    *((void *)this + 1) = v5;
    *((void *)this + 2) = v8;
    *(void *)((char *)this + 23) = *(void *)((char *)v20 + 7);
    *((unsigned char *)this + 31) = v6;
    *((_DWORD *)this + 8) = v7;
    goto LABEL_15;
  }
LABEL_10:
  operator delete(*((void **)this + 1));
  BOOL v11 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0;
  uint64_t v12 = v20[0];
  *((void *)this + 1) = v5;
  *((void *)this + 2) = v12;
  *(void *)((char *)this + 23) = *(void *)((char *)v20 + 7);
  *((unsigned char *)this + 31) = v6;
  *((_DWORD *)this + 8) = v7;
  char v13 = !v11 || v4;
  if ((v13 & 1) == 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_15:
  long long v14 = v18;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  return v3;
}

llvm::sys::fs::directory_iterator *llvm::sys::fs::directory_iterator::directory_iterator(llvm::sys::fs::directory_iterator *this, const char **a2, std::error_code *a3, char a4)
{
  char v4 = a4;
  v18[16] = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 16) = a4;
  uint64_t v8 = (char *)operator new(0x70uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)uint64_t v8 = &unk_1EC9CFDB0;
  *((void *)v8 + 7) = 0;
  *(_OWORD *)(v8 + 40) = 0u;
  *((_DWORD *)v8 + 14) = 9;
  v8[60] = 1;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *(_OWORD *)(v8 + 92) = 0u;
  *((_DWORD *)v8 + 27) = 0xFFFF;
  *(_OWORD *)(v8 + 24) = 0u;
  uint64_t v9 = (uint64_t)(v8 + 24);
  *(void *)this = v8 + 24;
  *((void *)this + 1) = v8;
  int v10 = *((unsigned __int8 *)a2 + 33);
  long long v16 = v18;
  long long v17 = xmmword_1811019F0;
  if (v10 == 1)
  {
    size_t v11 = 0;
    uint64_t v12 = 0;
    switch(*((unsigned char *)a2 + 32))
    {
      case 1:
        break;
      case 3:
        uint64_t v12 = *a2;
        if (*a2) {
          size_t v11 = strlen(*a2);
        }
        else {
          size_t v11 = 0;
        }
        break;
      case 4:
        int v15 = (*a2)[23];
        if (v15 >= 0) {
          uint64_t v12 = *a2;
        }
        else {
          uint64_t v12 = *(const void **)*a2;
        }
        if (v15 >= 0) {
          size_t v11 = *((unsigned __int8 *)*a2 + 23);
        }
        else {
          size_t v11 = *((void *)*a2 + 1);
        }
        break;
      case 5:
      case 6:
        uint64_t v12 = *a2;
        size_t v11 = (size_t)a2[1];
        break;
      default:
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    llvm::Twine::toVector((uint64_t)a2, (uint64_t)&v16);
    uint64_t v12 = v16;
    size_t v11 = v17;
    char v4 = *((unsigned char *)this + 16) != 0;
  }
  *(void *)&a3->__val_ = llvm::sys::fs::detail::directory_iterator_construct(v9, v12, v11, v4);
  a3->__cat_ = v13;
  if (v16 != v18) {
    free(v16);
  }
  return this;
}

void std::__shared_ptr_emplace<llvm::sys::fs::detail::DirIterState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CFDB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<llvm::sys::fs::detail::DirIterState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CFDB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<llvm::sys::fs::detail::DirIterState>::__on_zero_shared(uint64_t a1)
{
  llvm::sys::fs::detail::directory_iterator_destruct(a1 + 24);
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    operator delete(v2);
  }
}

BOOL llvm::sys::fs::directory_iterator::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  if (*a1 == *a2) {
    return 1;
  }
  if (v3)
  {
    if (v2)
    {
      uint64_t v4 = *(unsigned __int8 *)(v2 + 31);
      size_t v5 = *(void *)(v2 + 16);
      if ((v4 & 0x80u) == 0) {
        uint64_t v6 = *(unsigned __int8 *)(v2 + 31);
      }
      else {
        uint64_t v6 = *(void *)(v2 + 16);
      }
      uint64_t v7 = *(unsigned __int8 *)(v3 + 31);
      int v8 = (char)v7;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = *(void *)(v3 + 16);
      }
      if (v6 == v7)
      {
        uint64_t v9 = (const void **)(v2 + 8);
        uint64_t v12 = *(unsigned __int8 **)(v3 + 8);
        int v10 = (unsigned __int8 *)(v3 + 8);
        size_t v11 = v12;
        if (v8 >= 0) {
          char v13 = v10;
        }
        else {
          char v13 = v11;
        }
        if ((v4 & 0x80) != 0) {
          return memcmp(*v9, v13, v5) == 0;
        }
        if (v4)
        {
          uint64_t v14 = v4 - 1;
          do
          {
            int v16 = *(unsigned __int8 *)v9;
            uint64_t v9 = (const void **)((char *)v9 + 1);
            int v15 = v16;
            int v18 = *v13++;
            int v17 = v18;
            BOOL v19 = v14-- != 0;
            char v20 = v19;
            BOOL result = v15 == v17;
          }
          while (v15 == v17 && (v20 & 1) != 0);
          return result;
        }
        return 1;
      }
      return 0;
    }
    long long v42 = 0u;
    long long v43 = 0u;
    DWORD2(v43) = 9;
    BYTE12(v43) = 1;
    long long v44 = 0u;
    memset(v45, 0, sizeof(v45));
    int v46 = 0xFFFF;
    uint64_t v33 = *(unsigned __int8 *)(v3 + 31);
    size_t v23 = *(void *)(v3 + 16);
    if ((v33 & 0x80u) == 0) {
      uint64_t v34 = *(unsigned __int8 *)(v3 + 31);
    }
    else {
      uint64_t v34 = *(void *)(v3 + 16);
    }
    if (v34) {
      return 0;
    }
    uint64_t v25 = (const void **)(v3 + 8);
    if ((v33 & 0x80) == 0)
    {
      if (!v33) {
        return 1;
      }
      uint64_t v35 = v33 - 1;
      uint64_t v36 = (unsigned __int8 *)&v42;
      do
      {
        int v38 = *(unsigned __int8 *)v25;
        uint64_t v25 = (const void **)((char *)v25 + 1);
        int v37 = v38;
        int v40 = *v36++;
        int v39 = v40;
        BOOL v19 = v35-- != 0;
        char v41 = v19;
        BOOL result = v37 == v39;
      }
      while (v37 == v39 && (v41 & 1) != 0);
      return result;
    }
    return memcmp(*v25, &v42, v23) == 0;
  }
  long long v42 = 0u;
  long long v43 = 0u;
  DWORD2(v43) = 9;
  BYTE12(v43) = 1;
  long long v44 = 0u;
  memset(v45, 0, sizeof(v45));
  int v46 = 0xFFFF;
  uint64_t v22 = *(unsigned __int8 *)(v2 + 31);
  size_t v23 = *(void *)(v2 + 16);
  if ((v22 & 0x80u) == 0) {
    uint64_t v24 = *(unsigned __int8 *)(v2 + 31);
  }
  else {
    uint64_t v24 = *(void *)(v2 + 16);
  }
  if (v24) {
    return 0;
  }
  uint64_t v25 = (const void **)(v2 + 8);
  if ((v22 & 0x80) != 0) {
    return memcmp(*v25, &v42, v23) == 0;
  }
  if (!*(unsigned char *)(v2 + 31)) {
    return 1;
  }
  uint64_t v26 = v22 - 1;
  stat v27 = (unsigned __int8 *)&v42;
  do
  {
    int v29 = *(unsigned __int8 *)v25;
    uint64_t v25 = (const void **)((char *)v25 + 1);
    int v28 = v29;
    int v31 = *v27++;
    int v30 = v31;
    BOOL v19 = v26-- != 0;
    char v32 = v19;
    BOOL result = v28 == v30;
  }
  while (v28 == v30 && (v32 & 1) != 0);
  return result;
}

uint64_t llvm::FileError::build@<X0>(llvm::Twine *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t *a4@<X3>, void *a5@<X8>)
{
  uint64_t v9 = *a4;
  *a4 = 0;
  int v15 = &v16;
  uint64_t v16 = 0;
  uint64_t v17 = v9;
  llvm::handleErrors<llvm::FileError::build(llvm::Twine const&,std::optional<unsigned long>,llvm::Error)::{lambda(std::unique_ptr<llvm::ErrorInfoBase>)#1}>((uint64_t)&v17, &v15, (uint64_t *)&v18);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  int v10 = (char *)operator new(0x38uLL);
  uint64_t v11 = v16;
  uint64_t v16 = 0;
  *((void *)v10 + 1) = 0;
  uint64_t v12 = (void **)(v10 + 8);
  *(void *)int v10 = &unk_1EC9A4928;
  v10[40] = 0;
  *((void *)v10 + 6) = 0;
  *((void *)v10 + 2) = 0;
  *((void *)v10 + 3) = 0;
  v10[32] = 0;
  llvm::Twine::str(a1, &v18);
  if (v10[31] < 0) {
    operator delete(*v12);
  }
  *(_OWORD *)uint64_t v12 = *(_OWORD *)&v18.__r_.__value_.__l.__data_;
  *((void *)v10 + 3) = *((void *)&v18.__r_.__value_.__l + 2);
  uint64_t v13 = *((void *)v10 + 6);
  *((void *)v10 + 6) = v11;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  *((void *)v10 + 4) = a2;
  v10[40] = a3;
  *a5 = v10;
  uint64_t result = v16;
  uint64_t v16 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::handleErrors<llvm::FileError::build(llvm::Twine const&,std::optional<unsigned long>,llvm::Error)::{lambda(std::unique_ptr<llvm::ErrorInfoBase>)#1}>@<X0>(uint64_t result@<X0>, uint64_t **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *(void **)result;
  if (*(void *)result)
  {
    *(void *)uint64_t result = 0;
    if ((*(unsigned int (**)(void *, void *))(*v4 + 48))(v4, &llvm::ErrorList::ID))
    {
      *a3 = 0;
      uint64_t v6 = (uint64_t **)v4[1];
      uint64_t v7 = (uint64_t **)v4[2];
      if (v6 != v7)
      {
        uint64_t v8 = 0;
        do
        {
          uint64_t v12 = v8;
          uint64_t v9 = *v6;
          std::string::size_type *v6 = 0;
          if ((*(unsigned int (**)(uint64_t *, void *))(*v9 + 48))(v9, &llvm::ErrorInfoBase::ID))
          {
            uint64_t v10 = **a2;
            **a2 = (uint64_t)v9;
            if (v10) {
              (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
            }
            uint64_t v9 = 0;
          }
          uint64_t v11 = v9;
          llvm::ErrorList::join(&v12, &v11, &v13);
          uint64_t v8 = v13;
          *a3 = v13;
          uint64_t v13 = 0;
          if (v11) {
            (*(void (**)(uint64_t *))(*v11 + 8))(v11);
          }
          if (v12) {
            (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
          }
          ++v6;
        }
        while (v6 != v7);
      }
      return (*(uint64_t (**)(void *))(*v4 + 8))(v4);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void *, void *))(*v4 + 48))(v4, &llvm::ErrorInfoBase::ID);
      if (result)
      {
        uint64_t result = **a2;
        **a2 = (uint64_t)v4;
        if (result) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
        uint64_t v4 = 0;
      }
      *a3 = (uint64_t)v4;
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void llvm::initWithColorOptions(llvm *this)
{
  if (!atomic_load_explicit(UseColor, memory_order_acquire)) {
}
  }

uint64_t DefaultAutoDetectFunction(const llvm::raw_ostream *a1)
{
  if (atomic_load_explicit(UseColor, memory_order_acquire))
  {
    if (*(_DWORD *)(UseColor[0] + 128))
    {
LABEL_3:
      if (!atomic_load_explicit(UseColor, memory_order_acquire)) {
      return *(_DWORD *)(UseColor[0] + 128) == 1;
      }
    }
  }
  else
  {
    if (*(_DWORD *)(UseColor[0] + 128)) {
      goto LABEL_3;
    }
  }
  uint64_t v3 = *(uint64_t (**)(const llvm::raw_ostream *))(*(void *)a1 + 56);

  return v3(a1);
}

llvm::raw_ostream *llvm::WithColor::error(llvm::raw_ostream *a1, const void *a2, size_t a3, char a4)
{
  if (!a3)
  {
LABEL_5:
    uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  uint64_t v7 = (void *)*((void *)a1 + 4);
  if (a3 <= *((void *)a1 + 3) - (void)v7)
  {
    memcpy(v7, a2, a3);
    uint64_t v9 = (_WORD *)(*((void *)a1 + 4) + a3);
    *((void *)a1 + 4) = v9;
    uint64_t v8 = a1;
    if (*((void *)a1 + 3) - (void)v9 > 1uLL) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(a1, (const char *)a2, a3);
    uint64_t v9 = (_WORD *)*((void *)v8 + 4);
    if (*((void *)v8 + 3) - (void)v9 > 1uLL)
    {
LABEL_4:
      *uint64_t v9 = 8250;
      *((void *)v8 + 4) += 2;
      goto LABEL_5;
    }
  }
  llvm::raw_ostream::write(v8, ": ", 2uLL);
  uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
  if (a4) {
    goto LABEL_11;
  }
LABEL_9:
  if (((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    (*(void (**)(llvm::raw_ostream *, uint64_t, uint64_t, void))(*(void *)a1 + 24))(a1, 1, 1, 0);
  }
LABEL_11:
  uint64_t v11 = (_DWORD *)*((void *)a1 + 4);
  if (*((void *)a1 + 3) - (void)v11 > 6uLL)
  {
    *(_DWORD *)((char *)v11 + 3) = 540701295;
    *uint64_t v11 = 1869771365;
    *((void *)a1 + 4) += 7;
    uint64_t v12 = a1;
    if (a4) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = llvm::raw_ostream::write(a1, "error: ", 7uLL);
    if (a4) {
      return v12;
    }
  }
  if (!((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    return v12;
  }
  (*(void (**)(llvm::raw_ostream *))(*(void *)a1 + 32))(a1);
  return v12;
}

llvm::raw_ostream *llvm::WithColor::warning(llvm::raw_ostream *a1, const void *a2, size_t a3, char a4)
{
  if (!a3)
  {
LABEL_5:
    uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  uint64_t v7 = (void *)*((void *)a1 + 4);
  if (a3 <= *((void *)a1 + 3) - (void)v7)
  {
    memcpy(v7, a2, a3);
    uint64_t v9 = (_WORD *)(*((void *)a1 + 4) + a3);
    *((void *)a1 + 4) = v9;
    uint64_t v8 = a1;
    if (*((void *)a1 + 3) - (void)v9 > 1uLL) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(a1, (const char *)a2, a3);
    uint64_t v9 = (_WORD *)*((void *)v8 + 4);
    if (*((void *)v8 + 3) - (void)v9 > 1uLL)
    {
LABEL_4:
      *uint64_t v9 = 8250;
      *((void *)v8 + 4) += 2;
      goto LABEL_5;
    }
  }
  llvm::raw_ostream::write(v8, ": ", 2uLL);
  uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
  if (a4) {
    goto LABEL_11;
  }
LABEL_9:
  if (((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    (*(void (**)(llvm::raw_ostream *, uint64_t, uint64_t, void))(*(void *)a1 + 24))(a1, 5, 1, 0);
  }
LABEL_11:
  uint64_t v11 = *((void *)a1 + 4);
  if ((unint64_t)(*((void *)a1 + 3) - v11) > 8)
  {
    *(unsigned char *)(v11 + 8) = 32;
    *(void *)uint64_t v11 = *(void *)"warning: ";
    *((void *)a1 + 4) += 9;
    uint64_t v12 = a1;
    if (a4) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = llvm::raw_ostream::write(a1, "warning: ", 9uLL);
    if (a4) {
      return v12;
    }
  }
  if (!((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    return v12;
  }
  (*(void (**)(llvm::raw_ostream *))(*(void *)a1 + 32))(a1);
  return v12;
}

llvm::raw_ostream *llvm::WithColor::note(llvm::raw_ostream *a1, const void *a2, size_t a3, char a4)
{
  if (!a3)
  {
LABEL_5:
    uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  uint64_t v7 = (void *)*((void *)a1 + 4);
  if (a3 <= *((void *)a1 + 3) - (void)v7)
  {
    memcpy(v7, a2, a3);
    uint64_t v9 = (_WORD *)(*((void *)a1 + 4) + a3);
    *((void *)a1 + 4) = v9;
    uint64_t v8 = a1;
    if (*((void *)a1 + 3) - (void)v9 > 1uLL) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(a1, (const char *)a2, a3);
    uint64_t v9 = (_WORD *)*((void *)v8 + 4);
    if (*((void *)v8 + 3) - (void)v9 > 1uLL)
    {
LABEL_4:
      *uint64_t v9 = 8250;
      *((void *)v8 + 4) += 2;
      goto LABEL_5;
    }
  }
  llvm::raw_ostream::write(v8, ": ", 2uLL);
  uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
  if (a4) {
    goto LABEL_11;
  }
LABEL_9:
  if (((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    (*(void (**)(llvm::raw_ostream *, void, uint64_t, void))(*(void *)a1 + 24))(a1, 0, 1, 0);
  }
LABEL_11:
  uint64_t v11 = *((void *)a1 + 4);
  if ((unint64_t)(*((void *)a1 + 3) - v11) > 5)
  {
    *(_WORD *)(v11 + 4) = 8250;
    *(_DWORD *)uint64_t v11 = 1702129518;
    *((void *)a1 + 4) += 6;
    uint64_t v12 = a1;
    if (a4) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = llvm::raw_ostream::write(a1, "note: ", 6uLL);
    if (a4) {
      return v12;
    }
  }
  if (!((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    return v12;
  }
  (*(void (**)(llvm::raw_ostream *))(*(void *)a1 + 32))(a1);
  return v12;
}

llvm::raw_ostream *llvm::WithColor::remark(llvm::raw_ostream *a1, const void *a2, size_t a3, char a4)
{
  if (!a3)
  {
LABEL_5:
    uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  uint64_t v7 = (void *)*((void *)a1 + 4);
  if (a3 <= *((void *)a1 + 3) - (void)v7)
  {
    memcpy(v7, a2, a3);
    uint64_t v9 = (_WORD *)(*((void *)a1 + 4) + a3);
    *((void *)a1 + 4) = v9;
    uint64_t v8 = a1;
    if (*((void *)a1 + 3) - (void)v9 > 1uLL) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(a1, (const char *)a2, a3);
    uint64_t v9 = (_WORD *)*((void *)v8 + 4);
    if (*((void *)v8 + 3) - (void)v9 > 1uLL)
    {
LABEL_4:
      *uint64_t v9 = 8250;
      *((void *)v8 + 4) += 2;
      goto LABEL_5;
    }
  }
  llvm::raw_ostream::write(v8, ": ", 2uLL);
  uint64_t v10 = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks;
  if (a4) {
    goto LABEL_11;
  }
LABEL_9:
  if (((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    (*(void (**)(llvm::raw_ostream *, uint64_t, uint64_t, void))(*(void *)a1 + 24))(a1, 4, 1, 0);
  }
LABEL_11:
  uint64_t v11 = (void *)*((void *)a1 + 4);
  if (*((void *)a1 + 3) - (void)v11 > 7uLL)
  {
    *uint64_t v11 = 0x203A6B72616D6572;
    *((void *)a1 + 4) += 8;
    uint64_t v12 = a1;
    if (a4) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = llvm::raw_ostream::write(a1, "remark: ", 8uLL);
    if (a4) {
      return v12;
    }
  }
  if (!((unsigned int (*)(const llvm::raw_ostream *))v10[379])(a1)) {
    return v12;
  }
  (*(void (**)(llvm::raw_ostream *))(*(void *)a1 + 32))(a1);
  return v12;
}

void llvm::WithColor::~WithColor(llvm::WithColor *this)
{
  int v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    if (v2 != 1) {
      return;
    }
  }
  else if (!llvm::WithColor::AutoDetectFunction(*(const llvm::raw_ostream **)this))
  {
    return;
  }
  (*(void (**)(void))(**(void **)this + 32))();
}

void *llvm::WithColor::changeColor(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *((_DWORD *)a1 + 2);
  if (!v8)
  {
    if (!llvm::WithColor::AutoDetectFunction((const llvm::raw_ostream *)*a1)) {
      return a1;
    }
    goto LABEL_3;
  }
  if (v8 == 1) {
LABEL_3:
  }
    (*(void (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*a1 + 24))(*a1, a2, a3, a4);
  return a1;
}

uint64_t anonymous namespace'::CreateUseColor::call(_anonymous_namespace_::CreateUseColor *this)
{
  BOOL v1 = operator new(0xC0uLL);
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_53, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_53))
  {
    qword_1EB2161C8 = (uint64_t)"Color Options";
    qword_1EB2161D0 = 13;
    unk_1EB2161D8 = "";
    qword_1EB2161E0 = 0;
    llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)&qword_1EB2161C8);
    __cxa_guard_release(&_MergedGlobals_53);
  }
  uint64_t v6 = (llvm::cl::OptionCategory *)&qword_1EB2161C8;
  *(void *)&long long v5 = "Use colors in output (default=autodetect)";
  *((void *)&v5 + 1) = 41;
  int v3 = 0;
  uint64_t v4 = &v3;
  return llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::opt<char [6],llvm::cl::cat,llvm::cl::desc,llvm::cl::initializer<llvm::cl::BOOLOrDefault>>((uint64_t)v1, (int8x16_t *)"color", &v6, &v5, &v4);
}

uint64_t llvm::object_deleter<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>>::call(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::opt<char [6],llvm::cl::cat,llvm::cl::desc,llvm::cl::initializer<llvm::cl::BOOLOrDefault>>(uint64_t a1, int8x16_t *a2, llvm::cl::OptionCategory **a3, _OWORD *a4, _DWORD **a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  uint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AA0;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3DC8;
  *(void *)(a1 + 152) = &unk_1EC9A43E0;
  *(void *)(a1 + 160) = &unk_1EC9CE588;
  *(void *)(a1 + 184) = a1 + 160;
  uint64_t v14 = (const unsigned __int8 *)strlen(a2->i8);
  llvm::cl::Option::setArgStr(a1, a2, v14);
  llvm::cl::Option::addCategory((llvm::cl::Option *)a1, *a3);
  *(_OWORD *)(a1 + 32) = *a4;
  int v15 = *a5;
  *(_DWORD *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v15;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

uint64_t llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::handleOccurrence(uint64_t a1, __int16 a2, int a3, int a4, _DWORD *a5, size_t a6)
{
  int v11 = 0;
  uint64_t v8 = llvm::cl::parser<llvm::cl::BOOLOrDefault>::parse((int)a1 + 152, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::getValueExpectedFlagDefault();
}

uint64_t llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::getValueExpectedFlagDefault()
{
  return 1;
}

void *llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::~opt(void *a1)
{
  *a1 = &unk_1EC9A3DC8;
  int v2 = a1 + 20;
  int v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    *a1 = &unk_1EC9A42A8;
    uint64_t v4 = (void *)a1[12];
    if (v4 != (void *)a1[11]) {
LABEL_5:
    }
      free(v4);
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    *a1 = &unk_1EC9A42A8;
    uint64_t v4 = (void *)a1[12];
    if (v4 != (void *)a1[11]) {
      goto LABEL_5;
    }
  }
  long long v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::~opt(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3DC8;
  int v2 = __p + 160;
  int v3 = (char *)*((void *)__p + 23);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    *(void *)std::string __p = &unk_1EC9A42A8;
    uint64_t v4 = (void *)*((void *)__p + 12);
    if (v4 != *((void **)__p + 11)) {
LABEL_5:
    }
      free(v4);
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    *(void *)std::string __p = &unk_1EC9A42A8;
    uint64_t v4 = (void *)*((void *)__p + 12);
    if (v4 != *((void **)__p + 11)) {
      goto LABEL_5;
    }
  }
  long long v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

uint64_t llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::printOptionInfo(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

void llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::printOptionValue(uint64_t a1, int a2, char a3)
{
  if ((a3 & 1) != 0 || !*(unsigned char *)(a1 + 148) || *(_DWORD *)(a1 + 144) != *(_DWORD *)(a1 + 128))
  {
    int v3 = *(_DWORD *)(a1 + 128);
    int v5 = *(_DWORD *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 148);
    uint64_t v4 = &unk_1EC9A3AA0;
    llvm::cl::parser<llvm::cl::BOOLOrDefault>::printOptionDiff((llvm *)(a1 + 152), a1, v3, (uint64_t)&v4, a2);
  }
}

uint64_t llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::setDefault(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *std::__function::__func<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1},std::allocator<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1}>,void ()(llvm::cl::BOOLOrDefault const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CE588;
  return result;
}

void std::__function::__func<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1},std::allocator<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1}>,void ()(llvm::cl::BOOLOrDefault const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE588;
}

uint64_t std::__function::__func<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1},std::allocator<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1}>,void ()(llvm::cl::BOOLOrDefault const&)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x8000000181128243) {
    return a1 + 8;
  }
  if (((v3 & 0x8000000181128243 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181128243)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181128243 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1},std::allocator<llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::{lambda(llvm::cl::BOOLOrDefault const&)#1}>,void ()(llvm::cl::BOOLOrDefault const&)>::target_type()
{
}

uint64_t llvm::raw_ostream::preferred_buffer_size(llvm::raw_ostream *this)
{
  return 1024;
}

void llvm::raw_ostream::SetBuffered(llvm::raw_ostream *this)
{
  uint64_t v2 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)this + 88))(this);
  uint64_t v4 = (void **)((char *)this + 16);
  uint64_t v3 = (const char *)*((void *)this + 2);
  int v5 = (const char *)*((void *)this + 4);
  if (v2)
  {
    size_t v6 = v2;
    if (v5 != v3)
    {
      *((void *)this + 4) = v3;
      llvm::raw_ostream::flush_tied_then_write(this, v3, v5 - v3);
    }
    uint64_t v7 = (char *)operator new[](v6);
    if (*((_DWORD *)this + 14) == 1)
    {
      if (*v4) {
        operator delete[](*v4);
      }
    }
    *((void *)this + 2) = v7;
    *((void *)this + 3) = &v7[v6];
    *((void *)this + 4) = v7;
    *((_DWORD *)this + 14) = 1;
  }
  else
  {
    if (v5 != v3)
    {
      *((void *)this + 4) = v3;
      llvm::raw_ostream::flush_tied_then_write(this, v3, v5 - v3);
    }
    if (*((_DWORD *)this + 14) == 1 && *v4) {
      operator delete[](*v4);
    }
    *((_DWORD *)this + 14) = 0;
    *((void *)this + 3) = 0;
    *((void *)this + 4) = 0;
    *uint64_t v4 = 0;
  }
}

void llvm::raw_ostream::SetBufferAndMode(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(_DWORD *)(a1 + 56) == 1)
  {
    uint64_t v8 = *(void **)(a1 + 16);
    if (v8) {
      operator delete[](v8);
    }
  }
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a2 + a3;
  *(void *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 56) = a4;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *a1, unint64_t a2)
{
  return a1;
}

{
  llvm::write_integer(a1, a2, 0, 0);
  return a1;
}

{
  llvm::write_hex(a1, a2, 3, 0, 0);
  return a1;
}

llvm::raw_ostream *llvm::raw_ostream::write_hex(llvm::raw_ostream *this, unint64_t a2)
{
  return this;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *a1, uint64_t a2)
{
  v16[16] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *((void *)a1 + 3) - *((void *)a1 + 4);
  if (v4 <= 3)
  {
    unint64_t v7 = 127;
  }
  else
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
    if (v5 < v4) {
      unsigned int v6 = v5;
    }
    else {
      unsigned int v6 = v5 + 1;
    }
    if (v5 >= 0) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = (2 * v4);
    }
    if (v4 >= v7)
    {
      *((void *)a1 + 4) += v7;
      return a1;
    }
  }
  uint64_t v14 = (char *)v16;
  long long v15 = xmmword_1811019F0;
  do
  {
    uint64_t v12 = v15;
    if ((void)v15 != v7)
    {
      if ((unint64_t)v15 <= v7)
      {
        if (*((void *)&v15 + 1) < v7)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v14, v16, v7, 1);
          uint64_t v12 = v15;
        }
        if (v7 != v12) {
          bzero(&v14[v12], v7 - v12);
        }
      }
      *(void *)&long long v15 = v7;
    }
    int v8 = (*(uint64_t (**)(uint64_t, char *, unint64_t))(*(void *)a2 + 8))(a2, v14, v7);
    if (v8 < v7) {
      unsigned int v9 = v8;
    }
    else {
      unsigned int v9 = v8 + 1;
    }
    if (v8 >= 0) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = (2 * v7);
    }
    BOOL v11 = v7 >= v10;
    unint64_t v7 = v10;
  }
  while (!v11);
  llvm::raw_ostream::write(a1, v14, v10);
  if (v14 != (char *)v16) {
    free(v14);
  }
  return a1;
}

{
  int v4;
  BOOL v5;
  int v6;
  BOOL v7;
  BOOL v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  size_t v12;
  void *v14;
  int v15;
  void *__p;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  int v21;
  void **v22;
  void *v23;
  long long v24;
  void v25[3];

  v25[2] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 20))
  {
    unint64_t v4 = *(unsigned __int8 *)(a2 + 22);
    if (*(unsigned char *)(a2 + 22)) {
      int v5 = *(unsigned char *)(a2 + 21) == 0;
    }
    else {
      int v5 = 0;
    }
    if (v5) {
      unsigned int v6 = 3;
    }
    else {
      unsigned int v6 = 1;
    }
    if (*(unsigned char *)(a2 + 21)) {
      unint64_t v7 = v4 == 0;
    }
    else {
      unint64_t v7 = 0;
    }
    if (v7) {
      unsigned int v6 = 0;
    }
    if (*(unsigned char *)(a2 + 21)) {
      int v8 = v4 == 0;
    }
    else {
      int v8 = 1;
    }
    if (v8) {
      unsigned int v9 = v6;
    }
    else {
      unsigned int v9 = 2;
    }
    llvm::write_hex(a1, *(void *)a2, v9, *(unsigned int *)(a2 + 16), 1);
  }
  else
  {
    uint64_t v22 = &v23;
    size_t v23 = v25;
    uint64_t v24 = xmmword_181101A00;
    long long v15 = 0;
    BOOL v19 = 0;
    char v20 = 0;
    int v21 = 0;
    uint64_t v14 = &unk_1EC9A3930;
    std::string __p = 0;
    uint64_t v17 = 0;
    std::string v18 = 0;
    llvm::write_integer((llvm::raw_ostream *)&v14, *(void *)(a2 + 8), 0, 0);
    size_t v10 = *(unsigned int *)(a2 + 16);
    if ((unint64_t)v24 < v10)
    {
      BOOL v11 = v10 - v24;
      if ((v10 - v24) >= 0x50)
      {
        do
        {
          if (v11 >= 0x4F) {
            uint64_t v12 = 79;
          }
          else {
            uint64_t v12 = v11;
          }
          llvm::raw_ostream::write(a1, "                                                                                ", v12);
          v11 -= v12;
        }
        while (v11);
      }
      else
      {
        llvm::raw_ostream::write(a1, "                                                                                ", (v10 - v24));
      }
    }
    llvm::raw_ostream::write(a1, (const char *)v23, v24);
    uint64_t v14 = &unk_1EC9A1858;
    if (v21 == 1 && __p) {
      operator delete[](__p);
    }
    if (v23 != v25) {
      free(v23);
    }
  }
  return a1;
}

uint64_t llvm::raw_ostream::write_escaped(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  if (a3)
  {
    unsigned int v6 = a2;
    unint64_t v7 = &a2[a3];
    do
    {
      unint64_t v10 = *v6;
      if (*v6 > 0x21u)
      {
        if (v10 == 34)
        {
          while (1)
          {
            v45 = *(unsigned char **)(a1 + 32);
            if ((unint64_t)v45 < *(void *)(a1 + 24)) {
              goto LABEL_122;
            }
            int v46 = *(const char **)(a1 + 16);
            if (v46) {
              break;
            }
            if (!*(_DWORD *)(a1 + 56))
            {
              char v48 = 92;
              llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
              goto LABEL_3;
            }
            llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
          }
          *(void *)(a1 + 32) = v46;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v46, v45 - v46);
          v45 = *(unsigned char **)(a1 + 32);
LABEL_122:
          *(void *)(a1 + 32) = v45 + 1;
          unsigned char *v45 = 92;
          while (1)
          {
LABEL_3:
            int v8 = *(unsigned char **)(a1 + 32);
            if ((unint64_t)v8 < *(void *)(a1 + 24)) {
              goto LABEL_8;
            }
            unsigned int v9 = *(const char **)(a1 + 16);
            if (v9) {
              break;
            }
            if (!*(_DWORD *)(a1 + 56))
            {
              char v48 = 34;
              goto LABEL_141;
            }
            llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
          }
          *(void *)(a1 + 32) = v9;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v9, v8 - v9);
          int v8 = *(unsigned char **)(a1 + 32);
LABEL_8:
          *(void *)(a1 + 32) = v8 + 1;
          unsigned char *v8 = 34;
          goto LABEL_9;
        }
        if (v10 == 92)
        {
          uint64_t v13 = *(unsigned char **)(a1 + 32);
          if ((unint64_t)v13 >= *(void *)(a1 + 24))
          {
            while (1)
            {
              uint64_t v14 = *(const char **)(a1 + 16);
              if (v14) {
                break;
              }
              if (!*(_DWORD *)(a1 + 56))
              {
                char v48 = 92;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
                while (1)
                {
LABEL_45:
                  int v21 = *(unsigned char **)(a1 + 32);
                  if ((unint64_t)v21 < *(void *)(a1 + 24)) {
                    goto LABEL_52;
                  }
                  uint64_t v22 = *(const char **)(a1 + 16);
                  if (v22) {
                    break;
                  }
                  if (!*(_DWORD *)(a1 + 56))
                  {
                    char v48 = 92;
                    goto LABEL_141;
                  }
                  llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                }
                *(void *)(a1 + 32) = v22;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v22, v21 - v22);
                int v21 = *(unsigned char **)(a1 + 32);
LABEL_52:
                *(void *)(a1 + 32) = v21 + 1;
                *int v21 = 92;
                goto LABEL_9;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
              uint64_t v13 = *(unsigned char **)(a1 + 32);
              if ((unint64_t)v13 < *(void *)(a1 + 24)) {
                goto LABEL_44;
              }
            }
            *(void *)(a1 + 32) = v14;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v14, v13 - v14);
            uint64_t v13 = *(unsigned char **)(a1 + 32);
          }
LABEL_44:
          *(void *)(a1 + 32) = v13 + 1;
          *uint64_t v13 = 92;
          goto LABEL_45;
        }
LABEL_25:
        unint64_t v16 = *(void *)(a1 + 24);
        long long v15 = *(unsigned char **)(a1 + 32);
        if ((v10 - 32) <= 0x5E)
        {
          if ((unint64_t)v15 >= v16)
          {
            while (1)
            {
              uint64_t v17 = *(const char **)(a1 + 16);
              if (v17) {
                break;
              }
              if (!*(_DWORD *)(a1 + 56))
              {
                char v48 = v10;
                goto LABEL_141;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
              long long v15 = *(unsigned char **)(a1 + 32);
              if ((unint64_t)v15 < *(void *)(a1 + 24)) {
                goto LABEL_59;
              }
            }
            *(void *)(a1 + 32) = v17;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v17, v15 - v17);
            long long v15 = *(unsigned char **)(a1 + 32);
          }
LABEL_59:
          *(void *)(a1 + 32) = v15 + 1;
          *long long v15 = v10;
          goto LABEL_9;
        }
        if (a4)
        {
          if ((unint64_t)v15 >= v16)
          {
            while (1)
            {
              std::string v18 = *(const char **)(a1 + 16);
              if (v18) {
                break;
              }
              if (!*(_DWORD *)(a1 + 56))
              {
                char v48 = 92;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
                while (1)
                {
LABEL_62:
                  uint64_t v24 = *(unsigned char **)(a1 + 32);
                  if ((unint64_t)v24 < *(void *)(a1 + 24)) {
                    goto LABEL_73;
                  }
                  uint64_t v25 = *(const char **)(a1 + 16);
                  if (v25) {
                    break;
                  }
                  if (!*(_DWORD *)(a1 + 56))
                  {
                    char v48 = 120;
                    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
                    goto LABEL_74;
                  }
                  llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                }
                *(void *)(a1 + 32) = v25;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v25, v24 - v25);
                uint64_t v24 = *(unsigned char **)(a1 + 32);
LABEL_73:
                *(void *)(a1 + 32) = v24 + 1;
                *uint64_t v24 = 120;
LABEL_74:
                char v29 = llvm::hexdigit(unsigned int,BOOL)::LUT[v10 >> 4];
                int v30 = *(char **)(a1 + 32);
                if ((unint64_t)v30 >= *(void *)(a1 + 24))
                {
                  while (1)
                  {
                    int v31 = *(const char **)(a1 + 16);
                    if (v31) {
                      break;
                    }
                    if (!*(_DWORD *)(a1 + 56))
                    {
                      char v48 = v29;
                      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
LABEL_87:
                      char v35 = llvm::hexdigit(unsigned int,BOOL)::LUT[v10 & 0xF];
                      uint64_t v36 = *(char **)(a1 + 32);
                      if ((unint64_t)v36 >= *(void *)(a1 + 24))
                      {
                        while (1)
                        {
                          int v37 = *(const char **)(a1 + 16);
                          if (v37) {
                            break;
                          }
                          if (!*(_DWORD *)(a1 + 56))
                          {
                            char v48 = v35;
                            goto LABEL_141;
                          }
                          llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                          uint64_t v36 = *(char **)(a1 + 32);
                          if ((unint64_t)v36 < *(void *)(a1 + 24)) {
                            goto LABEL_99;
                          }
                        }
                        *(void *)(a1 + 32) = v37;
                        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v37, v36 - v37);
                        uint64_t v36 = *(char **)(a1 + 32);
                      }
LABEL_99:
                      *(void *)(a1 + 32) = v36 + 1;
                      *uint64_t v36 = v35;
                      goto LABEL_9;
                    }
                    llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                    int v30 = *(char **)(a1 + 32);
                    if ((unint64_t)v30 < *(void *)(a1 + 24)) {
                      goto LABEL_86;
                    }
                  }
                  *(void *)(a1 + 32) = v31;
                  llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v31, v30 - v31);
                  int v30 = *(char **)(a1 + 32);
                }
LABEL_86:
                *(void *)(a1 + 32) = v30 + 1;
                *int v30 = v29;
                goto LABEL_87;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
              long long v15 = *(unsigned char **)(a1 + 32);
              if ((unint64_t)v15 < *(void *)(a1 + 24)) {
                goto LABEL_61;
              }
            }
            *(void *)(a1 + 32) = v18;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v18, v15 - v18);
            long long v15 = *(unsigned char **)(a1 + 32);
          }
LABEL_61:
          *(void *)(a1 + 32) = v15 + 1;
          *long long v15 = 92;
          goto LABEL_62;
        }
        if ((unint64_t)v15 >= v16)
        {
          while (1)
          {
            size_t v23 = *(const char **)(a1 + 16);
            if (v23) {
              break;
            }
            if (!*(_DWORD *)(a1 + 56))
            {
              char v48 = 92;
              llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
              unsigned int v26 = (v10 >> 6) | 0x30;
              stat v27 = *(unsigned char **)(a1 + 32);
              if ((unint64_t)v27 >= *(void *)(a1 + 24))
              {
LABEL_68:
                while (1)
                {
                  int v28 = *(const char **)(a1 + 16);
                  if (v28) {
                    break;
                  }
                  if (!*(_DWORD *)(a1 + 56))
                  {
                    char v48 = v26;
                    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
                    unsigned int v32 = (v10 >> 3) & 7 | 0x30;
                    uint64_t v33 = *(unsigned char **)(a1 + 32);
                    if ((unint64_t)v33 >= *(void *)(a1 + 24))
                    {
LABEL_81:
                      while (1)
                      {
                        uint64_t v34 = *(const char **)(a1 + 16);
                        if (v34) {
                          break;
                        }
                        if (!*(_DWORD *)(a1 + 56))
                        {
                          char v48 = v32;
                          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
                          char v38 = v10 & 7 | 0x30;
                          int v39 = *(char **)(a1 + 32);
                          if ((unint64_t)v39 >= *(void *)(a1 + 24))
                          {
LABEL_94:
                            while (1)
                            {
                              int v40 = *(const char **)(a1 + 16);
                              if (v40) {
                                break;
                              }
                              if (!*(_DWORD *)(a1 + 56))
                              {
                                char v48 = v38;
                                goto LABEL_141;
                              }
                              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                              int v39 = *(char **)(a1 + 32);
                              if ((unint64_t)v39 < *(void *)(a1 + 24)) {
                                goto LABEL_101;
                              }
                            }
                            *(void *)(a1 + 32) = v40;
                            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v40, v39 - v40);
                            int v39 = *(char **)(a1 + 32);
                          }
LABEL_101:
                          *(void *)(a1 + 32) = v39 + 1;
                          *int v39 = v38;
                          goto LABEL_9;
                        }
                        llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                        uint64_t v33 = *(unsigned char **)(a1 + 32);
                        if ((unint64_t)v33 < *(void *)(a1 + 24)) {
                          goto LABEL_93;
                        }
                      }
                      *(void *)(a1 + 32) = v34;
                      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v34, v33 - v34);
                      uint64_t v33 = *(unsigned char **)(a1 + 32);
                    }
LABEL_93:
                    *(void *)(a1 + 32) = v33 + 1;
                    unsigned char *v33 = v32;
                    char v38 = v10 & 7 | 0x30;
                    int v39 = *(char **)(a1 + 32);
                    if ((unint64_t)v39 >= *(void *)(a1 + 24)) {
                      goto LABEL_94;
                    }
                    goto LABEL_101;
                  }
                  llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                  stat v27 = *(unsigned char **)(a1 + 32);
                  if ((unint64_t)v27 < *(void *)(a1 + 24)) {
                    goto LABEL_80;
                  }
                }
                *(void *)(a1 + 32) = v28;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v28, v27 - v28);
                stat v27 = *(unsigned char **)(a1 + 32);
              }
LABEL_80:
              *(void *)(a1 + 32) = v27 + 1;
              *stat v27 = v26;
              unsigned int v32 = (v10 >> 3) & 7 | 0x30;
              uint64_t v33 = *(unsigned char **)(a1 + 32);
              if ((unint64_t)v33 >= *(void *)(a1 + 24)) {
                goto LABEL_81;
              }
              goto LABEL_93;
            }
            llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
            long long v15 = *(unsigned char **)(a1 + 32);
            if ((unint64_t)v15 < *(void *)(a1 + 24)) {
              goto LABEL_67;
            }
          }
          *(void *)(a1 + 32) = v23;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v23, v15 - v23);
          long long v15 = *(unsigned char **)(a1 + 32);
        }
LABEL_67:
        *(void *)(a1 + 32) = v15 + 1;
        *long long v15 = 92;
        unsigned int v26 = (v10 >> 6) | 0x30;
        stat v27 = *(unsigned char **)(a1 + 32);
        if ((unint64_t)v27 >= *(void *)(a1 + 24)) {
          goto LABEL_68;
        }
        goto LABEL_80;
      }
      if (v10 == 9)
      {
        while (1)
        {
          char v41 = *(unsigned char **)(a1 + 32);
          if ((unint64_t)v41 < *(void *)(a1 + 24)) {
            goto LABEL_109;
          }
          long long v42 = *(const char **)(a1 + 16);
          if (v42) {
            break;
          }
          if (!*(_DWORD *)(a1 + 56))
          {
            char v48 = 92;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
            long long v43 = *(unsigned char **)(a1 + 32);
            if ((unint64_t)v43 >= *(void *)(a1 + 24))
            {
LABEL_110:
              while (1)
              {
                long long v44 = *(const char **)(a1 + 16);
                if (v44) {
                  break;
                }
                if (!*(_DWORD *)(a1 + 56))
                {
                  char v48 = 116;
                  goto LABEL_141;
                }
                llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
                long long v43 = *(unsigned char **)(a1 + 32);
                if ((unint64_t)v43 < *(void *)(a1 + 24)) {
                  goto LABEL_115;
                }
              }
              *(void *)(a1 + 32) = v44;
              llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v44, v43 - v44);
              long long v43 = *(unsigned char **)(a1 + 32);
            }
            goto LABEL_115;
          }
          llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
        }
        *(void *)(a1 + 32) = v42;
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v42, v41 - v42);
        char v41 = *(unsigned char **)(a1 + 32);
LABEL_109:
        *(void *)(a1 + 32) = v41 + 1;
        *char v41 = 92;
        long long v43 = *(unsigned char **)(a1 + 32);
        if ((unint64_t)v43 >= *(void *)(a1 + 24)) {
          goto LABEL_110;
        }
LABEL_115:
        *(void *)(a1 + 32) = v43 + 1;
        *long long v43 = 116;
        goto LABEL_9;
      }
      if (v10 != 10) {
        goto LABEL_25;
      }
      BOOL v11 = *(unsigned char **)(a1 + 32);
      if ((unint64_t)v11 < *(void *)(a1 + 24)) {
        goto LABEL_38;
      }
      while (1)
      {
        uint64_t v12 = *(const char **)(a1 + 16);
        if (v12)
        {
          *(void *)(a1 + 32) = v12;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v12, v11 - v12);
          BOOL v11 = *(unsigned char **)(a1 + 32);
LABEL_38:
          *(void *)(a1 + 32) = v11 + 1;
          *BOOL v11 = 92;
          goto LABEL_39;
        }
        if (!*(_DWORD *)(a1 + 56)) {
          break;
        }
        llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
        BOOL v11 = *(unsigned char **)(a1 + 32);
        if ((unint64_t)v11 < *(void *)(a1 + 24)) {
          goto LABEL_38;
        }
      }
      char v48 = 92;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
      while (1)
      {
LABEL_39:
        BOOL v19 = *(unsigned char **)(a1 + 32);
        if ((unint64_t)v19 < *(void *)(a1 + 24)) {
          goto LABEL_50;
        }
        char v20 = *(const char **)(a1 + 16);
        if (v20)
        {
          *(void *)(a1 + 32) = v20;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v20, v19 - v20);
          BOOL v19 = *(unsigned char **)(a1 + 32);
LABEL_50:
          *(void *)(a1 + 32) = v19 + 1;
          *BOOL v19 = 110;
          goto LABEL_9;
        }
        if (!*(_DWORD *)(a1 + 56)) {
          break;
        }
        llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a1);
      }
      char v48 = 110;
LABEL_141:
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, &v48, 1);
LABEL_9:
      ++v6;
    }
    while (v6 != v7);
  }
  return a1;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *a1, double a2)
{
  return a1;
}

uint64_t llvm::raw_ostream::flush_nonempty(llvm::raw_ostream *this)
{
  int v1 = (const char *)*((void *)this + 2);
  uint64_t v2 = *((void *)this + 4) - (void)v1;
  *((void *)this + 4) = v1;
  return llvm::raw_ostream::flush_tied_then_write(this, v1, v2);
}

uint64_t llvm::raw_ostream::flush_tied_then_write(llvm::raw_ostream *this, const char *a2, uint64_t a3)
{
  unsigned int v6 = (llvm::raw_ostream *)*((void *)this + 6);
  if (v6)
  {
    unint64_t v7 = (const char *)*((void *)v6 + 4);
    int v8 = (const char *)*((void *)v6 + 2);
    if (v7 != v8)
    {
      *((void *)v6 + 4) = v8;
      llvm::raw_ostream::flush_tied_then_write(v6, v8, v7 - v8);
    }
  }
  unsigned int v9 = *(uint64_t (**)(llvm::raw_ostream *, const char *, uint64_t))(*(void *)this + 72);

  return v9(this, a2, a3);
}

llvm::raw_ostream *llvm::raw_ostream::write(llvm::raw_ostream *this, char a2)
{
  unint64_t v4 = (char *)*((void *)this + 4);
  if ((unint64_t)v4 >= *((void *)this + 3))
  {
    while (1)
    {
      unsigned int v6 = (const char *)*((void *)this + 2);
      if (v6)
      {
        *((void *)this + 4) = v6;
        llvm::raw_ostream::flush_tied_then_write(this, v6, v4 - v6);
        unint64_t v4 = (char *)*((void *)this + 4);
        goto LABEL_2;
      }
      if (!*((_DWORD *)this + 14)) {
        break;
      }
      llvm::raw_ostream::SetBuffered(this);
      unint64_t v4 = (char *)*((void *)this + 4);
      if ((unint64_t)v4 < *((void *)this + 3)) {
        goto LABEL_2;
      }
    }
    char v7 = a2;
    llvm::raw_ostream::flush_tied_then_write(this, &v7, 1);
    return this;
  }
  else
  {
LABEL_2:
    *((void *)this + 4) = v4 + 1;
    *unint64_t v4 = a2;
    return this;
  }
}

llvm::raw_ostream *llvm::raw_ostream::write(llvm::raw_ostream *this, const char *a2, size_t a3)
{
  size_t v3 = a3;
  uint64_t v7 = *((void *)this + 3);
  unsigned int v6 = (unsigned char *)*((void *)this + 4);
  size_t v8 = v7 - (void)v6;
  if (v7 - (uint64_t)v6 < a3)
  {
    while (1)
    {
      while (1)
      {
        BOOL v11 = (unsigned char *)*((void *)this + 2);
        if (!v11) {
          break;
        }
        if (v6 == v11)
        {
          v8 *= v3 / v8;
          v3 -= v8;
          llvm::raw_ostream::flush_tied_then_write(this, a2, v8);
          unsigned int v6 = (unsigned char *)*((void *)this + 4);
          size_t v10 = *((void *)this + 3) - (void)v6;
          if (v3 <= v10)
          {
            llvm::raw_ostream::copy_to_buffer((void **)this, &a2[v8], v3);
            return this;
          }
        }
        else
        {
          llvm::raw_ostream::copy_to_buffer((void **)this, a2, v8);
          uint64_t v12 = (const char *)*((void *)this + 2);
          uint64_t v13 = *((void *)this + 4) - (void)v12;
          *((void *)this + 4) = v12;
          llvm::raw_ostream::flush_tied_then_write(this, v12, v13);
          v3 -= v8;
          unsigned int v6 = (unsigned char *)*((void *)this + 4);
          size_t v10 = *((void *)this + 3) - (void)v6;
        }
        a2 += v8;
        size_t v8 = v10;
        if (v10 >= v3) {
          goto LABEL_2;
        }
      }
      if (!*((_DWORD *)this + 14)) {
        break;
      }
      llvm::raw_ostream::SetBuffered(this);
      unsigned int v6 = (unsigned char *)*((void *)this + 4);
      size_t v8 = *((void *)this + 3) - (void)v6;
      if (v8 >= v3) {
        goto LABEL_2;
      }
    }
    llvm::raw_ostream::flush_tied_then_write(this, a2, v3);
    return this;
  }
  else
  {
LABEL_2:
    switch(v3)
    {
      case 0uLL:
        break;
      case 1uLL:
        goto LABEL_6;
      case 2uLL:
        goto LABEL_5;
      case 3uLL:
        goto LABEL_4;
      case 4uLL:
        v6[3] = a2[3];
        unsigned int v6 = (unsigned char *)*((void *)this + 4);
LABEL_4:
        void v6[2] = a2[2];
        unsigned int v6 = (unsigned char *)*((void *)this + 4);
LABEL_5:
        v6[1] = a2[1];
        unsigned int v6 = (unsigned char *)*((void *)this + 4);
LABEL_6:
        unsigned char *v6 = *a2;
        break;
      default:
        memcpy(v6, a2, v3);
        break;
    }
    *((void *)this + 4) += v3;
    return this;
  }
}

void **llvm::raw_ostream::copy_to_buffer(void **this, const char *a2, size_t __n)
{
  unint64_t v4 = this;
  switch(__n)
  {
    case 0uLL:
      goto LABEL_6;
    case 1uLL:
      goto LABEL_5;
    case 2uLL:
      goto LABEL_4;
    case 3uLL:
      goto LABEL_3;
    case 4uLL:
      *((unsigned char *)this[4] + 3) = a2[3];
LABEL_3:
      *((unsigned char *)this[4] + 2) = a2[2];
LABEL_4:
      *((unsigned char *)this[4] + 1) = a2[1];
LABEL_5:
      *(unsigned char *)this[4] = *a2;
LABEL_6:
      this[4] = (char *)this[4] + __n;
      break;
    default:
      this = (void **)memcpy(this[4], a2, __n);
      v4[4] = (char *)v4[4] + __n;
      break;
  }
  return this;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *a1, llvm::formatv_object_base *a2)
{
  return a1;
}

void llvm::formatv_object_base::format(llvm::formatv_object_base *this, llvm::raw_ostream *a2)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  llvm::formatv_object_base::parseFormatString(*(unsigned char **)this, *((void *)this + 1), (uint64_t)&v19);
  unint64_t v4 = v19;
  if (v20)
  {
    int v5 = (char *)v19 + 32;
    unint64_t v6 = (unint64_t)v20 << 6;
    do
    {
      int v7 = *((_DWORD *)v5 - 8);
      if (v7)
      {
        if (v7 == 2 || (unint64_t v8 = *((void *)v5 - 1), v8 >= *((void *)this + 3)))
        {
          uint64_t v12 = (const char *)*((void *)v5 - 3);
          unint64_t v13 = *((void *)v5 - 2);
          uint64_t v14 = (void *)*((void *)a2 + 4);
          if (v13 > *((void *)a2 + 3) - (void)v14)
          {
            llvm::raw_ostream::write(a2, v12, *((void *)v5 - 2));
          }
          else if (v13)
          {
            memcpy(v14, v12, *((void *)v5 - 2));
            *((void *)a2 + 4) += v13;
          }
        }
        else
        {
          int v9 = *((_DWORD *)v5 + 2);
          uint64_t v10 = *(void *)v5;
          char v11 = v5[12];
          uint64_t v15 = *(void *)(*((void *)this + 2) + 8 * v8);
          int v16 = v9;
          uint64_t v17 = v10;
          char v18 = v11;
          llvm::FmtAlign::format(&v15, (uint64_t)a2);
        }
      }
      v5 += 64;
      v6 -= 64;
    }
    while (v6);
    unint64_t v4 = v19;
  }
  if (v4 != v21) {
    free(v4);
  }
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *this, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 16) - *(void *)(a2 + 8);
  if (v4 < 1)
  {
    LODWORD(v4) = 0;
    unsigned int v6 = 0;
    goto LABEL_17;
  }
  int v5 = *(_DWORD *)(a2 + 20);
  if (v5 == 3)
  {
    unsigned int v6 = v4 - ((unint64_t)v4 >> 1);
    uint64_t v4 = (unint64_t)v4 >> 1;
    if (v4 < 0x50) {
      goto LABEL_17;
    }
  }
  else
  {
    if (v5 != 2)
    {
      if (v5 == 1) {
        unsigned int v6 = *(_DWORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
      }
      else {
        unsigned int v6 = 0;
      }
      LODWORD(v4) = 0;
LABEL_17:
      llvm::raw_ostream::write(this, "                                                                                ", v4);
      unint64_t v8 = *(const char **)a2;
      size_t v9 = *(void *)(a2 + 8);
      uint64_t v10 = (void *)*((void *)this + 4);
      if (v9 <= *((void *)this + 3) - (void)v10) {
        goto LABEL_18;
      }
LABEL_15:
      llvm::raw_ostream::write(this, v8, v9);
      goto LABEL_20;
    }
    unsigned int v6 = 0;
    if (v4 < 0x50) {
      goto LABEL_17;
    }
  }
  do
  {
    if (v4 >= 0x4F) {
      size_t v7 = 79;
    }
    else {
      size_t v7 = v4;
    }
    llvm::raw_ostream::write(this, "                                                                                ", v7);
    LODWORD(v4) = v4 - v7;
  }
  while (v4);
  unint64_t v8 = *(const char **)a2;
  size_t v9 = *(void *)(a2 + 8);
  uint64_t v10 = (void *)*((void *)this + 4);
  if (v9 > *((void *)this + 3) - (void)v10) {
    goto LABEL_15;
  }
LABEL_18:
  if (v9)
  {
    memcpy(v10, v8, v9);
    *((void *)this + 4) += v9;
  }
LABEL_20:
  if (v6 >= 0x50)
  {
    do
    {
      if (v6 >= 0x4F) {
        size_t v11 = 79;
      }
      else {
        size_t v11 = v6;
      }
      llvm::raw_ostream::write(this, "                                                                                ", v11);
      v6 -= v11;
    }
    while (v6);
  }
  else
  {
    llvm::raw_ostream::write(this, "                                                                                ", v6);
  }
  return this;
}

llvm::raw_ostream *llvm::raw_ostream::indent(llvm::raw_ostream *this, unsigned int a2)
{
  unsigned int v2 = a2;
  if (a2 < 0x50) {
    return llvm::raw_ostream::write(this, "                                                                                ", a2);
  }
  do
  {
    if (v2 >= 0x4F) {
      size_t v3 = 79;
    }
    else {
      size_t v3 = v2;
    }
    this = llvm::raw_ostream::write(this, "                                                                                ", v3);
    v2 -= v3;
  }
  while (v2);
  return this;
}

void llvm::raw_svector_ostream::~raw_svector_ostream(llvm::raw_svector_ostream *this)
{
  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    int v1 = (void *)*((void *)this + 2);
    if (v1) {
      operator delete[](v1);
    }
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    unsigned int v2 = (void *)*((void *)this + 2);
    if (v2) {
      operator delete[](v2);
    }
  }

  operator delete(this);
}

uint64_t llvm::raw_ostream::changeColor(uint64_t a1, int a2, int a3, llvm::sys::Process *a4)
{
  if (*(unsigned char *)(a1 + 40)
    && (!mlir::Diagnostic::operator mlir::LogicalResult()
     || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1)))
  {
    if (mlir::Diagnostic::operator mlir::LogicalResult())
    {
      unint64_t v8 = *(const char **)(a1 + 32);
      size_t v9 = *(const char **)(a1 + 16);
      if (v8 != v9)
      {
        *(void *)(a1 + 32) = v9;
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v9, v8 - v9);
      }
    }
    if (a2 == 8)
    {
      uint64_t v10 = llvm::sys::Process::OutputBold(a4);
      if (!v10) {
        return a1;
      }
      goto LABEL_11;
    }
    uint64_t v10 = llvm::sys::Process::OutputColor((llvm::sys::Process *)(char)a2, a3, (int)a4);
    if (v10)
    {
LABEL_11:
      size_t v11 = strlen(v10);
      llvm::raw_ostream::write((llvm::raw_ostream *)a1, v10, v11);
    }
  }
  return a1;
}

llvm::raw_ostream *llvm::raw_ostream::resetColor(llvm::raw_ostream *this)
{
  if (*((unsigned char *)this + 40)
    && (!mlir::Diagnostic::operator mlir::LogicalResult()
     || (*(unsigned int (**)(llvm::raw_ostream *))(*(void *)this + 48))(this)))
  {
    unsigned int v2 = (llvm::sys::Process *)mlir::Diagnostic::operator mlir::LogicalResult();
    if (v2)
    {
      size_t v3 = (const char *)*((void *)this + 4);
      uint64_t v4 = (const char *)*((void *)this + 2);
      if (v3 != v4)
      {
        *((void *)this + 4) = v4;
        unsigned int v2 = (llvm::sys::Process *)llvm::raw_ostream::flush_tied_then_write(this, v4, v3 - v4);
      }
    }
    int v5 = llvm::sys::Process::ResetColor(v2);
    if (v5)
    {
      unsigned int v6 = v5;
      size_t v7 = strlen(v5);
      llvm::raw_ostream::write(this, v6, v7);
    }
  }
  return this;
}

llvm::raw_ostream *llvm::raw_ostream::reverseColor(llvm::raw_ostream *this)
{
  if (*((unsigned char *)this + 40)
    && (!mlir::Diagnostic::operator mlir::LogicalResult()
     || (*(unsigned int (**)(llvm::raw_ostream *))(*(void *)this + 48))(this)))
  {
    unsigned int v2 = (llvm::sys::Process *)mlir::Diagnostic::operator mlir::LogicalResult();
    if (v2)
    {
      size_t v3 = (const char *)*((void *)this + 4);
      uint64_t v4 = (const char *)*((void *)this + 2);
      if (v3 != v4)
      {
        *((void *)this + 4) = v4;
        unsigned int v2 = (llvm::sys::Process *)llvm::raw_ostream::flush_tied_then_write(this, v4, v3 - v4);
      }
    }
    int v5 = llvm::sys::Process::OutputReverse(v2);
    if (v5)
    {
      unsigned int v6 = v5;
      size_t v7 = strlen(v5);
      llvm::raw_ostream::write(this, v6, v7);
    }
  }
  return this;
}

uint64_t llvm::raw_fd_ostream::raw_fd_ostream(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, int a5, char a6, int a7)
{
  int FD = getFD(a2, a3, a4, a5, a6, a7);

  return llvm::raw_fd_ostream::raw_fd_ostream(a1, FD, 1, 0, 0);
}

uint64_t llvm::raw_fd_ostream::raw_fd_ostream(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a3 == 1 && *a2 == 45)
  {
    size_t v7 = std::system_category();
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = v7;
    llvm::sys::ChangeStdinMode();
    int v8 = 1;
  }
  else
  {
    int v14 = 0;
    __int16 v13 = 261;
    v12[0] = a2;
    v12[1] = a3;
    uint64_t v9 = llvm::sys::fs::openFile((unsigned __int8 *)v12, &v14, 0, 2, a5, 438);
    *(void *)a4 = v9;
    *(void *)(a4 + 8) = v10;
    if (v9) {
      int v8 = -1;
    }
    else {
      int v8 = v14;
    }
  }
  return llvm::raw_fd_ostream::raw_fd_ostream(a1, v8, 1, 0, 0);
}

uint64_t getFD(unsigned char *a1, uint64_t a2, uint64_t a3, int a4, char a5, int a6)
{
  if (a2 == 1 && *a1 == 45)
  {
    size_t v7 = std::system_category();
    *(_DWORD *)a3 = 0;
    *(void *)(a3 + 8) = v7;
    llvm::sys::ChangeStdinMode();
    return 1;
  }
  else
  {
    unsigned int v15 = 0;
    __int16 v14 = 261;
    v13[0] = a1;
    v13[1] = a2;
    if (a5) {
      int v10 = 3;
    }
    else {
      int v10 = 2;
    }
    uint64_t v11 = llvm::sys::fs::openFile((unsigned __int8 *)v13, (int *)&v15, a4, v10, a6, 438);
    *(void *)a3 = v11;
    *(void *)(a3 + 8) = v12;
    if (v11) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v15;
    }
  }
}

uint64_t llvm::raw_fd_ostream::raw_fd_ostream(uint64_t a1, int a2, char a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 8) = a5;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = a4 ^ 1;
  *(_DWORD *)(a1 + 60) = a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EC9A19D0;
  *(unsigned char *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 65) = 0;
  *(void *)(a1 + 80) = std::system_category();
  *(void *)(a1 + 88) = 0;
  if ((*(_DWORD *)(a1 + 60) & 0x80000000) != 0)
  {
    *(unsigned char *)(a1 + 64) = 0;
    return a1;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, 1);
    int v6 = *(_DWORD *)(a1 + 60);
    if (v6 <= 2) {
      *(unsigned char *)(a1 + 64) = 0;
    }
    off_t v7 = lseek(v6, 0, 1);
    memset(v12, 0, sizeof(v12));
    uint64_t v13 = 0xFFFFLL;
    __int16 v14 = 0;
    uint64_t v15 = 0;
    int v9 = llvm::sys::fs::status((llvm::sys::fs *)*(unsigned int *)(a1 + 60), (const stat *)v12, v8);
    *(unsigned char *)(a1 + 66) = *(_DWORD *)&v12[40] == 2;
    *(unsigned char *)(a1 + 65) = v9 == 0 && v7 != -1;
    if (v9 == 0 && v7 != -1) {
      off_t v10 = v7;
    }
    else {
      off_t v10 = 0;
    }
    *(void *)(a1 + 88) = v10;
    return a1;
  }
}

void llvm::raw_fd_ostream::~raw_fd_ostream(llvm::raw_fd_ostream *this)
{
  *(void *)this = &unk_1EC9A19D0;
  if ((*((_DWORD *)this + 15) & 0x80000000) == 0)
  {
    unsigned int v2 = (const char *)*((void *)this + 4);
    size_t v3 = (const char *)*((void *)this + 2);
    if (v2 != v3)
    {
      *((void *)this + 4) = v3;
      llvm::raw_ostream::flush_tied_then_write(this, v3, v2 - v3);
    }
    if (*((unsigned char *)this + 64))
    {
      uint64_t v4 = llvm::sys::Process::SafelyCloseFileDescriptor((llvm::sys::Process *)*((unsigned int *)this + 15));
      if (v4)
      {
        *((void *)this + 9) = v4;
        *((void *)this + 10) = v5;
      }
    }
  }
  if (*((_DWORD *)this + 18))
  {
    uint64_t v11 = "IO failure on output stream: ";
    __int16 v12 = 259;
    std::error_code v7 = *(std::error_code *)((char *)this + 72);
    std::error_code::message(&v8, &v7);
    __int16 v10 = 260;
    int v9 = &v8;
    llvm::operator+((uint64_t *)&v11, (uint64_t *)&v9, (uint64_t)v13);
    llvm::report_fatal_error((llvm::Twine *)v13, 0);
  }
  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    int v6 = (void *)*((void *)this + 2);
    if (v6) {
      operator delete[](v6);
    }
  }
}

{
  void *v1;
  uint64_t vars8;

  llvm::raw_fd_ostream::~raw_fd_ostream(this);

  operator delete(v1);
}

uint64_t llvm::raw_fd_ostream::write_impl(llvm::raw_fd_ostream *this, const char *__buf, unint64_t a3)
{
  unint64_t v3 = a3;
  *((void *)this + 11) += a3;
  while (1)
  {
    size_t v6 = v3 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v3;
    uint64_t result = write(*((_DWORD *)this + 15), __buf, v6);
    if (result < 0) {
      break;
    }
    __buf += result;
    v3 -= result;
LABEL_3:
    if (!v3) {
      return result;
    }
  }
  uint64_t result = (uint64_t)__error();
  if (*(_DWORD *)result == 4) {
    goto LABEL_3;
  }
  uint64_t result = (uint64_t)__error();
  if (*(_DWORD *)result == 35) {
    goto LABEL_3;
  }
  uint64_t result = (uint64_t)__error();
  if (*(_DWORD *)result == 35) {
    goto LABEL_3;
  }
  uint64_t v8 = *__error();
  uint64_t result = (uint64_t)std::generic_category();
  *((void *)this + 9) = v8;
  *((void *)this + 10) = result;
  return result;
}

const char *llvm::raw_fd_ostream::pwrite_impl(const char **this, const char *a2, size_t a3, off_t a4)
{
  uint64_t v8 = (*((uint64_t (**)(const char **))*this + 10))(this);
  int v9 = this[4];
  __int16 v10 = this[2];
  uint64_t v11 = &v9[v8];
  if (v9 != v10)
  {
    this[4] = v10;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)this, v10, v9 - v10);
  }
  off_t v12 = v11 - v10;
  off_t v13 = lseek(*((_DWORD *)this + 15), a4, 0);
  this[11] = (const char *)v13;
  if (v13 == -1)
  {
    __int16 v14 = (const char *)*__error();
    uint64_t v15 = std::generic_category();
    this[9] = v14;
    this[10] = (const char *)v15;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)this, a2, a3);
  int v16 = this[4];
  uint64_t v17 = this[2];
  if (v16 != v17)
  {
    this[4] = v17;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)this, v17, v16 - v17);
  }
  uint64_t result = (const char *)lseek(*((_DWORD *)this + 15), v12, 0);
  this[11] = result;
  if (result == (const char *)-1)
  {
    BOOL v19 = (const char *)*__error();
    uint64_t result = (const char *)std::generic_category();
    this[9] = v19;
    this[10] = result;
  }
  return result;
}

uint64_t llvm::raw_fd_ostream::preferred_buffer_size(llvm::raw_fd_ostream *this)
{
  if (fstat(*((_DWORD *)this + 15), &v3)) {
    return 0;
  }
  if ((v3.st_mode & 0xF000) == 0x2000
    && ((*(uint64_t (**)(llvm::raw_fd_ostream *))(*(void *)this + 48))(this) & 1) != 0)
  {
    return 0;
  }
  return v3.st_blksize;
}

BOOL llvm::raw_fd_ostream::is_displayed(llvm::raw_fd_ostream *this)
{
  return llvm::sys::Process::FileDescriptorIsDisplayed((llvm::sys::Process *)*((unsigned int *)this + 15));
}

BOOL llvm::raw_fd_ostream::has_colors(llvm::raw_fd_ostream *this)
{
  if (*((unsigned char *)this + 68)) {
    return *((unsigned char *)this + 67) != 0;
  }
  BOOL result = llvm::sys::Process::FileDescriptorHasColors((llvm::sys::Process *)*((unsigned int *)this + 15));
  *(_WORD *)((char *)this + 67) = result | 0x100;
  return result;
}

llvm *llvm::raw_fd_ostream::lock@<X0>(llvm::raw_fd_ostream *this@<X0>, uint64_t a2@<X8>)
{
  BOOL result = (llvm *)llvm::sys::fs::lockFile((llvm::sys::fs *)*((unsigned int *)this + 15), 1);
  if (result)
  {
    BOOL result = (llvm *)llvm::errorCodeToError(result, v5, &v7);
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v7;
  }
  else
  {
    int v6 = *((_DWORD *)this + 15);
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(_DWORD *)a2 = v6;
  }
  return result;
}

void *llvm::outs(llvm *this)
{
  int v2 = 0;
  stat v3 = std::system_category();
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_54, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&_MergedGlobals_54))
  {
    return &unk_1EB216240;
  }
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&unk_1EB216240, "-", 1, (uint64_t)&v2, 0);
  __cxa_atexit((void (*)(void *))llvm::raw_fd_ostream::~raw_fd_ostream, &unk_1EB216240, &dword_180159000);
  __cxa_guard_release(&_MergedGlobals_54);
  return &unk_1EB216240;
}

void *llvm::errs(llvm *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB2161F0, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(qword_1EB2161F0))
  {
    return &unk_1EB2162A0;
  }
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&unk_1EB2162A0, 2, 0, 1, 0);
  __cxa_atexit((void (*)(void *))llvm::raw_fd_ostream::~raw_fd_ostream, &unk_1EB2162A0, &dword_180159000);
  __cxa_guard_release(qword_1EB2161F0);
  return &unk_1EB2162A0;
}

void llvm::raw_null_ostream::~raw_null_ostream(llvm::raw_null_ostream *this)
{
  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    int v1 = (void *)*((void *)this + 2);
    if (v1) {
      operator delete[](v1);
    }
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    int v2 = (void *)*((void *)this + 2);
    if (v2) {
      operator delete[](v2);
    }
  }

  operator delete(this);
}

std::string *llvm::raw_string_ostream::write_impl(std::string **this, const char *a2, std::string::size_type a3)
{
  return std::string::append(this[8], a2, a3);
}

uint64_t llvm::raw_svector_ostream::current_pos(llvm::raw_svector_ostream *this)
{
  return *(void *)(*((void *)this + 8) + 8);
}

void llvm::raw_svector_ostream::write_impl(llvm::raw_svector_ostream *this, const char *__src, size_t __n)
{
  std::error_code v5 = (void *)*((void *)this + 8);
  uint64_t v6 = v5[1];
  unint64_t v7 = v6 + __n;
  if (v5[2] < v7)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(*((void *)this + 8), v5 + 3, v7, 1);
    uint64_t v6 = v5[1];
  }
  if (__n)
  {
    memcpy((void *)(*v5 + v6), __src, __n);
    uint64_t v6 = v5[1];
  }
  v5[1] = v6 + __n;
}

void *llvm::raw_svector_ostream::pwrite_impl(llvm::raw_svector_ostream *this, const char *a2, size_t a3, uint64_t a4)
{
  return memcpy((void *)(**((void **)this + 8) + a4), a2, a3);
}

uint64_t llvm::raw_null_ostream::current_pos(llvm::raw_null_ostream *this)
{
  return 0;
}

void llvm::raw_string_ostream::~raw_string_ostream(llvm::raw_string_ostream *this)
{
  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    int v2 = (void *)*((void *)this + 2);
    if (v2) {
      operator delete[](v2);
    }
  }

  operator delete(this);
}

void llvm::raw_string_ostream::reserveExtraSpace(llvm::raw_string_ostream *this, uint64_t a2)
{
  int v2 = (std::string *)*((void *)this + 8);
  std::string::size_type v3 = (*(uint64_t (**)(llvm::raw_string_ostream *))(*(void *)this + 80))(this)
     + a2
     + *((void *)this + 4)
     - *((void *)this + 2);

  std::string::reserve(v2, v3);
}

uint64_t llvm::raw_string_ostream::current_pos(llvm::raw_string_ostream *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (*(char *)(v1 + 23) < 0) {
    return *(void *)(v1 + 8);
  }
  else {
    return *(unsigned __int8 *)(v1 + 23);
  }
}

void llvm::raw_svector_ostream::reserveExtraSpace(llvm::raw_svector_ostream *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 8);
  unint64_t v3 = (*(uint64_t (**)(llvm::raw_svector_ostream *))(*(void *)this + 80))(this)
     + a2
     + *((void *)this + 4)
     - *((void *)this + 2);
  if (*(void *)(v2 + 16) < v3)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(v2, (void *)(v2 + 24), v3, 1);
  }
}

uint64_t llvm::raw_fd_ostream::current_pos(llvm::raw_fd_ostream *this)
{
  return *((void *)this + 11);
}

void llvm::FmtAlign::format(void *a1, uint64_t a2)
{
  v39[8] = *MEMORY[0x1E4F143B8];
  if (a1[2])
  {
    int v37 = (char *)v39;
    *(_OWORD *)char v38 = xmmword_181101A40;
    int v28 = 0;
    char v32 = 0;
    uint64_t v33 = 0;
    char v35 = &v37;
    int v34 = 0;
    stat v27 = &unk_1EC9A3930;
    std::string __p = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    (*(void (**)(void, void **))(*(void *)*a1 + 24))(*a1, &v27);
    unint64_t v4 = a1[2];
    size_t v5 = v38[0];
    unint64_t v6 = v4 - v38[0];
    if (v4 > v38[0])
    {
      int v7 = *((_DWORD *)a1 + 2);
      if (v7 == 1)
      {
        unint64_t v13 = v6 >> 1;
        if ((v6 >> 1))
        {
          int v14 = 0;
          do
          {
            while (1)
            {
              char v15 = *((unsigned char *)a1 + 24);
              int v16 = *(char **)(a2 + 32);
              if ((unint64_t)v16 >= *(void *)(a2 + 24)) {
                break;
              }
LABEL_28:
              *(void *)(a2 + 32) = v16 + 1;
              *int v16 = v15;
              if (++v14 == v13) {
                goto LABEL_31;
              }
            }
            while (1)
            {
              uint64_t v17 = *(const char **)(a2 + 16);
              if (v17)
              {
                *(void *)(a2 + 32) = v17;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, v17, v16 - v17);
                int v16 = *(char **)(a2 + 32);
                goto LABEL_28;
              }
              if (!*(_DWORD *)(a2 + 56)) {
                break;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a2);
              int v16 = *(char **)(a2 + 32);
              if ((unint64_t)v16 < *(void *)(a2 + 24)) {
                goto LABEL_28;
              }
            }
            char v36 = v15;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, &v36, 1);
            ++v14;
          }
          while (v14 != v13);
LABEL_31:
          size_t v5 = v38[0];
        }
        llvm::raw_ostream::write((llvm::raw_ostream *)a2, v37, v5);
        int v18 = v6 - v13;
        if (v18)
        {
          for (int i = 0; i != v18; ++i)
          {
            while (1)
            {
              char v20 = *((unsigned char *)a1 + 24);
              int v21 = *(char **)(a2 + 32);
              if ((unint64_t)v21 >= *(void *)(a2 + 24)) {
                break;
              }
LABEL_40:
              *(void *)(a2 + 32) = v21 + 1;
              *int v21 = v20;
              if (++i == v18) {
                goto LABEL_57;
              }
            }
            while (1)
            {
              uint64_t v22 = *(const char **)(a2 + 16);
              if (v22)
              {
                *(void *)(a2 + 32) = v22;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, v22, v21 - v22);
                int v21 = *(char **)(a2 + 32);
                goto LABEL_40;
              }
              if (!*(_DWORD *)(a2 + 56)) {
                break;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a2);
              int v21 = *(char **)(a2 + 32);
              if ((unint64_t)v21 < *(void *)(a2 + 24)) {
                goto LABEL_40;
              }
            }
            char v36 = v20;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, &v36, 1);
          }
        }
        goto LABEL_57;
      }
      if (!v7)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)a2, v37, v38[0]);
        if (v6)
        {
          int v8 = 0;
          do
          {
            while (1)
            {
              char v9 = *((unsigned char *)a1 + 24);
              __int16 v10 = *(char **)(a2 + 32);
              if ((unint64_t)v10 >= *(void *)(a2 + 24)) {
                break;
              }
LABEL_13:
              *(void *)(a2 + 32) = v10 + 1;
              *__int16 v10 = v9;
              if (++v8 == v6) {
                goto LABEL_57;
              }
            }
            while (1)
            {
              uint64_t v11 = *(const char **)(a2 + 16);
              if (v11)
              {
                *(void *)(a2 + 32) = v11;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, v11, v10 - v11);
                __int16 v10 = *(char **)(a2 + 32);
                goto LABEL_13;
              }
              if (!*(_DWORD *)(a2 + 56)) {
                break;
              }
              llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a2);
              __int16 v10 = *(char **)(a2 + 32);
              if ((unint64_t)v10 < *(void *)(a2 + 24)) {
                goto LABEL_13;
              }
            }
            char v36 = v9;
            llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, &v36, 1);
            ++v8;
          }
          while (v8 != v6);
        }
        goto LABEL_57;
      }
      if (v6)
      {
        int v23 = 0;
        do
        {
          while (1)
          {
            char v24 = *((unsigned char *)a1 + 24);
            uint64_t v25 = *(char **)(a2 + 32);
            if ((unint64_t)v25 >= *(void *)(a2 + 24)) {
              break;
            }
LABEL_52:
            *(void *)(a2 + 32) = v25 + 1;
            char *v25 = v24;
            if (++v23 == v6) {
              goto LABEL_55;
            }
          }
          while (1)
          {
            unsigned int v26 = *(const char **)(a2 + 16);
            if (v26)
            {
              *(void *)(a2 + 32) = v26;
              llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, v26, v25 - v26);
              uint64_t v25 = *(char **)(a2 + 32);
              goto LABEL_52;
            }
            if (!*(_DWORD *)(a2 + 56)) {
              break;
            }
            llvm::raw_ostream::SetBuffered((llvm::raw_ostream *)a2);
            uint64_t v25 = *(char **)(a2 + 32);
            if ((unint64_t)v25 < *(void *)(a2 + 24)) {
              goto LABEL_52;
            }
          }
          char v36 = v24;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a2, &v36, 1);
          ++v23;
        }
        while (v23 != v6);
LABEL_55:
        size_t v5 = v38[0];
      }
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)a2, v37, v5);
LABEL_57:
    stat v27 = &unk_1EC9A1858;
    if (v34 == 1 && __p) {
      operator delete[](__p);
    }
    if (v37 != (char *)v39) {
      free(v37);
    }
    return;
  }
  off_t v12 = *(void (**)(void))(*(void *)*a1 + 24);

  v12();
}

uint64_t llvm_regcomp(uint64_t a1, char *__s, int a3)
{
  if ((~a3 & 0x11) == 0) {
    return 16;
  }
  uint64_t v80 = v3;
  uint64_t v81 = v4;
  int v7 = __s;
  if ((a3 & 0x20) != 0)
  {
    unint64_t v10 = *(void *)(a1 + 16);
    size_t v9 = v10 - (void)__s;
    if (v10 < (unint64_t)__s) {
      return 16;
    }
  }
  else
  {
    size_t v9 = strlen(__s);
  }
  uint64_t v11 = malloc(0x18FuLL);
  if (!v11) {
    return 12;
  }
  off_t v12 = v11;
  uint64_t v68 = 0;
  uint64_t v65 = 0;
  long long v67 = 0u;
  unint64_t v13 = 3 * (v9 >> 1);
  int64_t v14 = v13 + 1;
  *(void *)&long long v67 = v13 + 1;
  char v15 = calloc(v13 + 1, 8uLL);
  __ptr = v15;
  if (!v15)
  {
    free(v12);
    return 12;
  }
  int v16 = v15;
  unint64_t v69 = v12;
  uint64_t v17 = &v7[v9];
  int v63 = v7;
  unsigned int v64 = &v7[v9];
  LODWORD(v65) = 0;
  LODWORD(v68) = 0;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  void v12[4] = 256;
  *(void *)(v12 + 5) = 0;
  int v18 = v12 + 5;
  *(void *)(v12 + 7) = 0;
  v12[9] = 0;
  *(_OWORD *)(v12 + 34) = 0u;
  *(_OWORD *)(v12 + 66) = 0u;
  v12[10] = a3 & 0xFFFFFF7F;
  v12[26] = 0;
  *((void *)v12 + 14) = 0;
  *(_OWORD *)(v12 + 18) = xmmword_1811283A0;
  *((void *)v12 + 11) = v12 + 66;
  *((void *)v12 + 12) = 0;
  *(_OWORD *)(v12 + 38) = 0u;
  *(_OWORD *)(v12 + 42) = 0u;
  *(_OWORD *)(v12 + 46) = 0u;
  *(_OWORD *)(v12 + 50) = 0u;
  *(_OWORD *)(v12 + 54) = 0u;
  *(_OWORD *)(v12 + 58) = 0u;
  *(_OWORD *)(v12 + 62) = 0u;
  *(_OWORD *)(v12 + 70) = 0u;
  *(_OWORD *)(v12 + 74) = 0u;
  *(_OWORD *)(v12 + 78) = 0u;
  *(_OWORD *)(v12 + 82) = 0u;
  *(_OWORD *)(v12 + 86) = 0u;
  *(_OWORD *)(v12 + 90) = 0u;
  *(_OWORD *)(v12 + 94) = 0u;
  v12[30] = 0;
  if (v13 < 0x7FFFFFFFFFFFFFFFLL) {
    goto LABEL_17;
  }
  uint64_t v19 = v13 + 3;
  if ((uint64_t)(v13 + 2) >= 0) {
    uint64_t v19 = v13 + 2;
  }
  unint64_t v20 = (v19 & 0xFFFFFFFFFFFFFFFELL) + (v19 >> 1);
  if (v14 >= (uint64_t)v20)
  {
LABEL_17:
    int v22 = 1;
  }
  else if (v20 >> 61 || (int v21 = realloc(v15, 24 * (v19 >> 1))) == 0)
  {
    int v22 = 0;
    LODWORD(v65) = 12;
    int v7 = &nuls;
    int v63 = &nuls;
    unsigned int v64 = &nuls;
    uint64_t v17 = &nuls;
  }
  else
  {
    __ptr = v21;
    *(void *)&long long v67 = v20;
    int v22 = 1;
    int v16 = v21;
  }
  *((void *)&v67 + 1) = 1;
  *int v16 = 0x8000000;
  *((void *)v12 + 7) = *((void *)&v67 + 1) - 1;
  if (a3)
  {
    p_ere((uint64_t)&v63, 128);
  }
  else if ((a3 & 0x10) != 0)
  {
    if (v17 - v7 <= 0)
    {
      if (v22) {
        LODWORD(v65) = 14;
      }
      int v7 = &nuls;
      int v63 = &nuls;
      unsigned int v64 = &nuls;
      uint64_t v17 = &nuls;
    }
    if (v17 - v7 >= 1)
    {
      do
      {
        int v63 = v7 + 1;
        ordinary((uint64_t)&v63, *v7);
        int v7 = v63;
      }
      while (v64 - v63 > 0);
    }
  }
  else
  {
    p_bre((uint64_t)&v63, 128, 128);
  }
  unint64_t v23 = *((void *)&v67 + 1);
  if (!v65)
  {
    if (*((uint64_t *)&v67 + 1) < (uint64_t)v67
      || ((uint64_t)v67 >= -1 ? (uint64_t v24 = v67 + 1) : (uint64_t v24 = v67 + 2),
          unint64_t v25 = (v24 & 0xFFFFFFFFFFFFFFFELL) + (v24 >> 1),
          (uint64_t)v67 >= (uint64_t)v25))
    {
      int v26 = 0;
    }
    else
    {
      if (v25 >> 61)
      {
LABEL_37:
        int v26 = 12;
        LODWORD(v65) = 12;
LABEL_38:
        int v63 = &nuls;
        unsigned int v64 = &nuls;
        goto LABEL_40;
      }
      int v57 = realloc(__ptr, 24 * (v24 >> 1));
      if (!v57)
      {
        int v26 = v65;
        if (v65) {
          goto LABEL_38;
        }
        goto LABEL_37;
      }
      __ptr = v57;
      *(void *)&long long v67 = v25;
      int v26 = v65;
    }
LABEL_40:
    uint64_t v27 = (*((void *)&v67 + 1))++;
    *((void *)__ptr + v27) = 0x8000000;
    unint64_t v23 = *((void *)&v67 + 1);
    *((void *)v12 + 8) = *((void *)&v67 + 1) - 1;
    if (!v26)
    {
      uint64_t v28 = *((void *)v12 + 11);
      for (uint64_t i = -128; i != 128; ++i)
      {
        if (!*(unsigned char *)(v28 + i) && *v18 >= 1)
        {
          unsigned int v30 = (*v18 + 7) >> 3;
          uint64_t v31 = *((void *)v12 + 4);
          while (!*(unsigned char *)(v31 + i))
          {
            v31 += (int)v12[4];
            if (!--v30) {
              goto LABEL_42;
            }
          }
          int v32 = v12[21];
          v12[21] = v32 + 1;
          *(unsigned char *)(v28 + i) = v32;
          if (i <= 126)
          {
            uint64_t v33 = i;
            do
            {
              ++v33;
              if (!*(unsigned char *)(v28 + v33))
              {
                if (*v18 < 1)
                {
LABEL_51:
                  *(unsigned char *)(v28 + v33) = v32;
                }
                else
                {
                  unsigned int v34 = (*v18 + 7) >> 3;
                  uint64_t v35 = *((void *)v12 + 4);
                  while (*(unsigned __int8 *)(v35 + i) == *(unsigned __int8 *)(v35
                                                                                               + v33))
                  {
                    v35 += (int)v12[4];
                    if (!--v34) {
                      goto LABEL_51;
                    }
                  }
                }
              }
            }
            while (v33 != 127);
          }
        }
LABEL_42:
        ;
      }
      unint64_t v23 = *((void *)&v67 + 1);
    }
    goto LABEL_61;
  }
  *((void *)v12 + 8) = *((void *)&v67 + 1) - 1;
LABEL_61:
  *((void *)v12 + 6) = v23;
  if (v23 >> 61)
  {
    *((void *)v12 + 1) = __ptr;
    int v36 = v65;
    if (!v65)
    {
      int v36 = 12;
      LODWORD(v65) = 12;
    }
    int v63 = &nuls;
    unsigned int v64 = &nuls;
    goto LABEL_87;
  }
  int v37 = (char *)realloc(__ptr, 8 * v23);
  *((void *)v12 + 1) = v37;
  int v36 = v65;
  if (!v37)
  {
    if (!v65)
    {
      int v36 = 12;
      LODWORD(v65) = 12;
    }
    int v63 = &nuls;
    unsigned int v64 = &nuls;
    *((void *)v12 + 1) = __ptr;
    goto LABEL_87;
  }
  if (v65)
  {
LABEL_87:
    int v48 = 0;
    uint64_t v49 = 0;
    int v50 = v12[18];
    goto LABEL_88;
  }
  char v38 = v37;
  int v39 = 0;
  int v40 = 0;
  uint64_t v41 = 0;
  long long v42 = (uint64_t *)(v37 + 8);
  long long v43 = (uint64_t *)(v37 + 8);
  do
  {
    uint64_t v45 = *v43++;
    LODWORD(v44) = v45;
    unint64_t v46 = ((unint64_t)(v45 & 0xF8000000) - 0x10000000) >> 27;
    if (v46 > 0xD) {
      goto LABEL_82;
    }
    if (((1 << v46) & 0x1880) != 0) {
      goto LABEL_69;
    }
    if (((1 << v46) & 0x2200) != 0)
    {
      long long v43 = v42;
      while (1)
      {
        v43 += v44 & 0x7FFFFFF;
        uint64_t v44 = *v43;
        uint64_t v47 = *v43 & 0xF8000000;
        if (v47 == 1610612736) {
          break;
        }
        if (v47 != -2013265920)
        {
          if (v47 == -1879048192) {
            break;
          }
          v12[18] |= 4u;
          goto LABEL_96;
        }
      }
LABEL_82:
      if (v41 > (int)v12[26])
      {
        v12[26] = v41;
        int v39 = v40;
      }
      uint64_t v41 = 0;
      goto LABEL_69;
    }
    if (v46) {
      goto LABEL_82;
    }
    if (!v41) {
      int v40 = v42;
    }
    ++v41;
LABEL_69:
    long long v42 = v43;
  }
  while ((v44 & 0xF8000000) != 0x8000000);
  uint64_t v58 = (int)v12[26];
  if (v58)
  {
    int v59 = malloc(v58 + 1);
    *((void *)v12 + 12) = v59;
    if (v59)
    {
      if ((int)v58 >= 1)
      {
        do
        {
          do
          {
            uint64_t v61 = *v39++;
            char v60 = v61;
          }
          while ((v61 & 0xF8000000) != 0x10000000);
          *v59++ = v60;
        }
        while (v58-- > 1);
      }
      unsigned char *v59 = 0;
    }
    else
    {
      v12[26] = 0;
    }
  }
LABEL_96:
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  unint64_t v52 = (uint64_t *)(v38 + 8);
  do
  {
    uint64_t v53 = *v52++;
    uint64_t v54 = v53 & 0xF8000000;
    if (v51 <= v49) {
      uint64_t v55 = v49;
    }
    else {
      uint64_t v55 = v51;
    }
    uint64_t v56 = v51 - 1;
    if (v54 == 1207959552) {
      ++v51;
    }
    if (v54 == 1342177280)
    {
      uint64_t v51 = v56;
      uint64_t v49 = v55;
    }
  }
  while (v54 != 0x8000000);
  int v50 = v12[18];
  if (v51)
  {
    v50 |= 4u;
    v12[18] = v50;
  }
  int v48 = 1;
LABEL_88:
  *((void *)v12 + 16) = v49;
  *off_t v12 = 53829;
  *(void *)(a1 + 8) = *((void *)v12 + 14);
  *(void *)(a1 + 24) = v12;
  *(_DWORD *)a1 = 62053;
  if ((v50 & 4) != 0)
  {
    if (v48)
    {
      int v36 = 15;
      LODWORD(v65) = 15;
    }
    int v63 = &nuls;
    unsigned int v64 = &nuls;
  }
  if (!v36) {
    return 0;
  }
  llvm_regfree(a1);
  return v65;
}

void p_ere(uint64_t a1, int a2)
{
  uint64_t v156 = 0;
  uint64_t v157 = 0;
  char v158 = 0;
LABEL_5:
  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = *(char **)a1;
  int v8 = *(char **)(a1 + 8);
  uint64_t v4 = v6;
  if ((uint64_t)&v8[-*(void *)a1] < 1) {
    goto LABEL_338;
  }
  while (2)
  {
    int v9 = *v7;
    uint64_t v4 = *(void *)(a1 + 40);
    if (v9 == 124 || v9 == a2) {
      goto LABEL_337;
    }
    uint64_t v11 = v7 + 1;
    *(void *)a1 = v7 + 1;
    int v12 = *v7;
    switch(*v7)
    {
      case '$':
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_99;
        }
        uint64_t v13 = *(void *)(a1 + 32);
        if (v4 < v13) {
          goto LABEL_98;
        }
        uint64_t v14 = v13 >= -1 ? v13 + 1 : v13 + 2;
        unint64_t v15 = (v14 & 0xFFFFFFFFFFFFFFFELL) + (v14 >> 1);
        if (v13 >= (uint64_t)v15) {
          goto LABEL_98;
        }
        if (v15 >> 61) {
          goto LABEL_25;
        }
        long long v42 = realloc(*(void **)(a1 + 24), 24 * (v14 >> 1));
        if (v42)
        {
          *(void *)(a1 + 24) = v42;
          *(void *)(a1 + 32) = v15;
        }
        else
        {
          if (!*(_DWORD *)(a1 + 16)) {
LABEL_25:
          }
            *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_98:
        uint64_t v43 = *(void *)(a1 + 24);
        uint64_t v44 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v44 + 1;
        *(void *)(v43 + 8 * v44) = 0x20000000;
LABEL_99:
        uint64_t v45 = *(void *)(a1 + 56);
        *(_DWORD *)(v45 + 72) |= 2u;
        ++*(_DWORD *)(v45 + 80);
        char v24 = 1;
        int v7 = *(char **)a1;
        int v8 = *(char **)(a1 + 8);
        uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
        if (v25 >= 1) {
          goto LABEL_142;
        }
        goto LABEL_10;
      case '(':
        if (v8 - v11 <= 0)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 8;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          uint64_t v11 = &nuls;
          int v8 = &nuls;
          uint64_t v30 = *(void *)(a1 + 56);
          uint64_t v17 = *(void *)(v30 + 112) + 1;
          *(void *)(v30 + 112) = v17;
          if (v17 <= 9)
          {
LABEL_29:
            *(void *)(a1 + 8 * v17 + 64) = v4;
            if (!*(_DWORD *)(a1 + 16))
            {
LABEL_30:
              uint64_t v18 = *(void *)(a1 + 32);
              if (*(void *)(a1 + 40) >= v18)
              {
                uint64_t v19 = v18 >= -1 ? v18 + 1 : v18 + 2;
                unint64_t v20 = (v19 & 0xFFFFFFFFFFFFFFFELL) + (v19 >> 1);
                if (v18 < (uint64_t)v20)
                {
                  if (v20 >> 61)
                  {
                    *(_DWORD *)(a1 + 16) = 12;
                    uint64_t v11 = &nuls;
                    int v8 = &nuls;
                    *(void *)a1 = &nuls;
                    *(void *)(a1 + 8) = &nuls;
                  }
                  else
                  {
                    unint64_t v46 = realloc(*(void **)(a1 + 24), 24 * (v19 >> 1));
                    if (v46)
                    {
                      *(void *)(a1 + 24) = v46;
                      *(void *)(a1 + 32) = v20;
                      uint64_t v11 = *(char **)a1;
                      int v8 = *(char **)(a1 + 8);
                    }
                    else
                    {
                      if (!*(_DWORD *)(a1 + 16)) {
                        *(_DWORD *)(a1 + 16) = 12;
                      }
                      *(void *)a1 = &nuls;
                      *(void *)(a1 + 8) = &nuls;
                      uint64_t v11 = &nuls;
                      int v8 = &nuls;
                    }
                  }
                }
              }
              uint64_t v56 = *(void *)(a1 + 24);
              uint64_t v57 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v57 + 1;
              *(void *)(v56 + 8 * v57) = v17 | 0x68000000;
              if (v8 - v11 < 1) {
                goto LABEL_129;
              }
              goto LABEL_118;
            }
LABEL_74:
            if (v8 - v11 < 1) {
              goto LABEL_129;
            }
LABEL_118:
            if (*v11 == 41)
            {
              if (v17 <= 9) {
                goto LABEL_120;
              }
              goto LABEL_130;
            }
LABEL_129:
            p_ere(a1, 41);
            if (v17 <= 9)
            {
LABEL_120:
              *(void *)(a1 + 8 * v17 + 144) = *(void *)(a1 + 40);
              if (!*(_DWORD *)(a1 + 16))
              {
LABEL_121:
                uint64_t v58 = *(void *)(a1 + 32);
                if (*(void *)(a1 + 40) >= v58)
                {
                  uint64_t v59 = v58 >= -1 ? v58 + 1 : v58 + 2;
                  unint64_t v60 = (v59 & 0xFFFFFFFFFFFFFFFELL) + (v59 >> 1);
                  if (v58 < (uint64_t)v60)
                  {
                    if (v60 >> 61)
                    {
LABEL_127:
                      *(_DWORD *)(a1 + 16) = 12;
LABEL_128:
                      *(void *)a1 = &nuls;
                      *(void *)(a1 + 8) = &nuls;
                      goto LABEL_135;
                    }
                    uint64_t v62 = realloc(*(void **)(a1 + 24), 24 * (v59 >> 1));
                    if (!v62)
                    {
                      if (*(_DWORD *)(a1 + 16)) {
                        goto LABEL_128;
                      }
                      goto LABEL_127;
                    }
                    *(void *)(a1 + 24) = v62;
                    *(void *)(a1 + 32) = v60;
                  }
                }
LABEL_135:
                uint64_t v63 = *(void *)(a1 + 24);
                uint64_t v64 = *(void *)(a1 + 40);
                *(void *)(a1 + 40) = v64 + 1;
                *(void *)(v63 + 8 * v64) = v17 | 0x70000000;
                uint64_t v61 = *(char **)a1;
                if ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) < 1) {
                  goto LABEL_137;
                }
LABEL_136:
                *(void *)a1 = v61 + 1;
                if (*v61 == 41) {
                  goto LABEL_141;
                }
                goto LABEL_137;
              }
LABEL_131:
              uint64_t v61 = *(char **)a1;
              if ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) < 1) {
                goto LABEL_137;
              }
              goto LABEL_136;
            }
LABEL_130:
            if (!*(_DWORD *)(a1 + 16)) {
              goto LABEL_121;
            }
            goto LABEL_131;
          }
        }
        else
        {
          uint64_t v16 = *(void *)(a1 + 56);
          uint64_t v17 = *(void *)(v16 + 112) + 1;
          *(void *)(v16 + 112) = v17;
          if (v17 <= 9) {
            goto LABEL_29;
          }
        }
        if (!*(_DWORD *)(a1 + 16)) {
          goto LABEL_30;
        }
        goto LABEL_74;
      case ')':
LABEL_137:
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_140;
        }
        int v29 = 8;
        goto LABEL_139;
      case '*':
      case '+':
      case '?':
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = 13;
        }
        goto LABEL_140;
      case '.':
        if ((*(unsigned char *)(*(void *)(a1 + 56) + 40) & 8) != 0)
        {
          *(void *)a1 = &nonnewline_bracket;
          *(void *)(a1 + 8) = &unk_1811283B3;
          p_bracket(a1);
          *(void *)a1 = v11;
          *(void *)(a1 + 8) = v8;
          char v24 = 1;
          int v7 = *(char **)a1;
          int v8 = *(char **)(a1 + 8);
          uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
          if (v25 >= 1) {
            goto LABEL_142;
          }
          goto LABEL_10;
        }
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_141;
        }
        uint64_t v21 = *(void *)(a1 + 32);
        if (v4 < v21) {
          goto LABEL_110;
        }
        uint64_t v22 = v21 >= -1 ? v21 + 1 : v21 + 2;
        unint64_t v23 = (v22 & 0xFFFFFFFFFFFFFFFELL) + (v22 >> 1);
        if (v21 >= (uint64_t)v23) {
          goto LABEL_110;
        }
        if (v23 >> 61) {
          goto LABEL_45;
        }
        uint64_t v53 = realloc(*(void **)(a1 + 24), 24 * (v22 >> 1));
        if (v53)
        {
          *(void *)(a1 + 24) = v53;
          *(void *)(a1 + 32) = v23;
        }
        else
        {
          if (!*(_DWORD *)(a1 + 16)) {
LABEL_45:
          }
            *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_110:
        uint64_t v54 = *(void *)(a1 + 24);
        uint64_t v55 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v55 + 1;
        *(void *)(v54 + 8 * v55) = 671088640;
        char v24 = 1;
        int v7 = *(char **)a1;
        int v8 = *(char **)(a1 + 8);
        uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
        if (v25 >= 1) {
          goto LABEL_142;
        }
        goto LABEL_10;
      case '[':
        p_bracket(a1);
        char v24 = 1;
        int v7 = *(char **)a1;
        int v8 = *(char **)(a1 + 8);
        uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
        if (v25 < 1) {
          goto LABEL_10;
        }
        goto LABEL_142;
      case '\\':
        if (v8 - v11 <= 0)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 5;
          }
          *(void *)a1 = &byte_1E8EBF171;
          *(void *)(a1 + 8) = &nuls;
          int v12 = nuls;
          if ((nuls - 49) > 8)
          {
LABEL_84:
            ordinary(a1, v12);
            char v24 = 1;
            int v7 = *(char **)a1;
            int v8 = *(char **)(a1 + 8);
            uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
            if (v25 < 1) {
              goto LABEL_10;
            }
            goto LABEL_142;
          }
        }
        else
        {
          *(void *)a1 = v7 + 2;
          int v12 = *v11;
          if ((v12 - 49) > 8) {
            goto LABEL_84;
          }
        }
        uint64_t v31 = (v12 - 48);
        uint64_t v32 = a1 + 8 * v31;
        uint64_t v35 = *(void *)(v32 + 144);
        unsigned int v34 = (void *)(v32 + 144);
        uint64_t v33 = v35;
        int v36 = *(_DWORD *)(a1 + 16);
        if (v35)
        {
          if (v36)
          {
            uint64_t v37 = *(void *)(a1 + 8 * v31 + 64) + 1;
            uint64_t v38 = v33 - v37;
            if (v33 == v37) {
              goto LABEL_82;
            }
LABEL_299:
            if (v38 >= 1)
            {
              unint64_t v128 = *(void *)(a1 + 32) + v38;
              if (v128 >> 61 || (v129 = realloc(*(void **)(a1 + 24), 8 * v128)) == 0)
              {
                if (!*(_DWORD *)(a1 + 16)) {
                  *(_DWORD *)(a1 + 16) = 12;
                }
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
              }
              else
              {
                *(void *)(a1 + 24) = v129;
                *(void *)(a1 + 32) = v128;
              }
            }
            memmove((void *)(*(void *)(a1 + 24) + 8 * *(void *)(a1 + 40)), (const void *)(*(void *)(a1 + 24) + 8 * v37), 8 * v38);
            *(void *)(a1 + 40) += v38;
            if (!*(_DWORD *)(a1 + 16)) {
              goto LABEL_307;
            }
LABEL_318:
            char v24 = 1;
            *(_DWORD *)(*(void *)(a1 + 56) + 120) = 1;
            int v7 = *(char **)a1;
            int v8 = *(char **)(a1 + 8);
            uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
            if (v25 < 1) {
              goto LABEL_10;
            }
LABEL_142:
            int v65 = *v7;
            if ((v65 - 42) >= 2 && v65 != 63)
            {
              BOOL v66 = v65 == 123 && (unint64_t)v25 >= 2;
              if (!v66 || v7[1] - 48 > 9) {
                goto LABEL_10;
              }
            }
            long long v67 = v7 + 1;
            *(void *)a1 = v67;
            if ((v24 & 1) == 0)
            {
              if (!*(_DWORD *)(a1 + 16)) {
                *(_DWORD *)(a1 + 16) = 13;
              }
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
              long long v67 = &nuls;
              int v8 = &nuls;
            }
            if ((char)v65 <= 62)
            {
              if ((char)v65 != 42)
              {
                if ((char)v65 != 43) {
                  goto LABEL_271;
                }
                doinsert((void *)a1, 1207959552, *(void *)(a1 + 40) - v4 + 1, v4);
                if (*(_DWORD *)(a1 + 16)) {
                  goto LABEL_271;
                }
                uint64_t v68 = *(void *)(a1 + 32);
                uint64_t v69 = *(void *)(a1 + 40);
                if (v69 < v68) {
                  goto LABEL_236;
                }
                uint64_t v70 = v68 >= -1 ? v68 + 1 : v68 + 2;
                unint64_t v71 = (v70 & 0xFFFFFFFFFFFFFFFELL) + (v70 >> 1);
                if (v68 >= (uint64_t)v71) {
                  goto LABEL_236;
                }
                if (v71 >> 61) {
                  goto LABEL_164;
                }
                v101 = realloc(*(void **)(a1 + 24), 24 * (v70 >> 1));
                if (v101)
                {
                  *(void *)(a1 + 24) = v101;
                  *(void *)(a1 + 32) = v71;
                  goto LABEL_236;
                }
                if (!*(_DWORD *)(a1 + 16)) {
LABEL_164:
                }
                  *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
LABEL_236:
                uint64_t v102 = (v69 - v4) | 0x50000000;
LABEL_254:
                uint64_t v112 = *(void *)(a1 + 24);
                uint64_t v113 = *(void *)(a1 + 40);
                *(void *)(a1 + 40) = v113 + 1;
                *(void *)(v112 + 8 * v113) = v102;
                goto LABEL_271;
              }
              doinsert((void *)a1, 1207959552, *(void *)(a1 + 40) - v4 + 1, v4);
              uint64_t v77 = *(void *)(a1 + 40);
              uint64_t v78 = v77 - v4;
              if (*(_DWORD *)(a1 + 16))
              {
LABEL_240:
                doinsert((void *)a1, 1476395008, v78 + 1, v4);
                if (!*(_DWORD *)(a1 + 16))
                {
                  uint64_t v106 = *(void *)(a1 + 32);
                  uint64_t v107 = *(void *)(a1 + 40);
                  if (v107 < v106) {
                    goto LABEL_253;
                  }
                  uint64_t v108 = v106 >= -1 ? v106 + 1 : v106 + 2;
                  unint64_t v109 = (v108 & 0xFFFFFFFFFFFFFFFELL) + (v108 >> 1);
                  if (v106 >= (uint64_t)v109) {
                    goto LABEL_253;
                  }
                  if (v109 >> 61) {
                    goto LABEL_247;
                  }
                  v111 = realloc(*(void **)(a1 + 24), 24 * (v108 >> 1));
                  if (v111)
                  {
                    *(void *)(a1 + 24) = v111;
                    *(void *)(a1 + 32) = v109;
                    goto LABEL_253;
                  }
                  if (!*(_DWORD *)(a1 + 16)) {
LABEL_247:
                  }
                    *(_DWORD *)(a1 + 16) = 12;
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
LABEL_253:
                  uint64_t v102 = (v107 - v4) | 0x60000000;
                  goto LABEL_254;
                }
LABEL_271:
                int v7 = *(char **)a1;
                int v8 = *(char **)(a1 + 8);
                uint64_t v120 = (uint64_t)&v8[-*(void *)a1];
                if (v120 >= 1)
                {
                  if ((int v121 = *v7, (v121 - 42) < 2)
                    || v121 == 63
                    || (v121 == 123 ? (BOOL v122 = (unint64_t)v120 >= 2) : (BOOL v122 = 0),
                        v122 && v7[1] - 48 <= 9))
                  {
                    if (!*(_DWORD *)(a1 + 16)) {
                      *(_DWORD *)(a1 + 16) = 13;
                    }
                    *(void *)a1 = &nuls;
                    *(void *)(a1 + 8) = &nuls;
                    int v7 = &nuls;
                    int v8 = &nuls;
                  }
                }
                goto LABEL_10;
              }
              uint64_t v79 = *(void *)(a1 + 32);
              if (v77 >= v79)
              {
                uint64_t v80 = v79 >= -1 ? v79 + 1 : v79 + 2;
                unint64_t v81 = (v80 & 0xFFFFFFFFFFFFFFFELL) + (v80 >> 1);
                if (v79 < (uint64_t)v81)
                {
                  if (v81 >> 61) {
                    goto LABEL_182;
                  }
                  v103 = realloc(*(void **)(a1 + 24), 24 * (v80 >> 1));
                  if (v103)
                  {
                    *(void *)(a1 + 24) = v103;
                    *(void *)(a1 + 32) = v81;
                    goto LABEL_239;
                  }
                  if (!*(_DWORD *)(a1 + 16)) {
LABEL_182:
                  }
                    *(_DWORD *)(a1 + 16) = 12;
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
                }
              }
LABEL_239:
              uint64_t v104 = *(void *)(a1 + 24);
              uint64_t v105 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v105 + 1;
              *(void *)(v104 + 8 * v105) = v78 | 0x50000000;
              uint64_t v78 = *(void *)(a1 + 40) - v4;
              goto LABEL_240;
            }
            if ((char)v65 != 63)
            {
              if ((char)v65 != 123) {
                goto LABEL_271;
              }
              uint64_t v72 = v8 - v67;
              if (v8 - v67 < 1)
              {
                uint64_t v74 = 0;
              }
              else
              {
                uint64_t v73 = 0;
                uint64_t v74 = 0;
                while (v67[v73] - 48 <= 9 && (int)v74 <= 255)
                {
                  *(void *)a1 = &v67[v73 + 1];
                  uint64_t v74 = (v67[v73++] + 10 * v74 - 48);
                  if (v72-- <= 1)
                  {
                    long long v76 = &v67[v73];
                    goto LABEL_195;
                  }
                }
                long long v76 = &v67[v73];
                if (v73)
                {
LABEL_195:
                  if ((int)v74 < 256) {
                    goto LABEL_199;
                  }
                }
              }
              if (!*(_DWORD *)(a1 + 16)) {
                *(_DWORD *)(a1 + 16) = 10;
              }
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
              long long v76 = &nuls;
              int v8 = &nuls;
LABEL_199:
              uint64_t v87 = v74;
              if (v8 - v76 < 1) {
                goto LABEL_259;
              }
              uint64_t v87 = v74;
              if (*v76 != 44) {
                goto LABEL_259;
              }
              v88 = v76 + 1;
              *(void *)a1 = v76 + 1;
              if (v76[1] - 48 > 9)
              {
                uint64_t v87 = 256;
                goto LABEL_259;
              }
              uint64_t v89 = v8 - v88;
              if (v8 - v88 < 1)
              {
                uint64_t v87 = 0;
              }
              else
              {
                uint64_t v90 = 0;
                uint64_t v87 = 0;
                do
                {
                  uint64_t v91 = &v88[v90];
                  if (v88[v90] - 48 > 9 || (int)v87 > 255) {
                    goto LABEL_208;
                  }
                  *(void *)a1 = v91 + 1;
                  uint64_t v87 = (*v91 + 10 * v87 - 48);
                  ++v90;
                  --v89;
                }
                while (v89 > 0);
                LODWORD(v90) = 1;
LABEL_208:
                if (v90 && (int)v87 < 256)
                {
                  if ((int)v74 <= (int)v87) {
                    goto LABEL_259;
                  }
LABEL_256:
                  if (!*(_DWORD *)(a1 + 16)) {
                    *(_DWORD *)(a1 + 16) = 10;
                  }
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
LABEL_259:
                  repeat((uint64_t *)a1, v4, v74, v87);
                  v115 = *(char **)a1;
                  uint64_t v114 = *(void *)(a1 + 8);
                  if (v114 - *(void *)a1 < 1)
                  {
LABEL_267:
                    if (!*(_DWORD *)(a1 + 16))
                    {
                      int v119 = 9;
                      goto LABEL_269;
                    }
                  }
                  else
                  {
                    if (*v115 == 125)
                    {
                      *(void *)a1 = v115 + 1;
                      goto LABEL_271;
                    }
                    v116 = (unsigned __int8 *)(v115 + 1);
                    uint64_t v117 = ~(unint64_t)v115 + v114;
                    do
                    {
                      *(void *)a1 = v116;
                      if (v117 <= 0) {
                        goto LABEL_267;
                      }
                      int v118 = *v116++;
                      --v117;
                    }
                    while (v118 != 125);
                    if (!*(_DWORD *)(a1 + 16))
                    {
                      int v119 = 10;
LABEL_269:
                      *(_DWORD *)(a1 + 16) = v119;
                    }
                  }
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
                  goto LABEL_271;
                }
              }
              if (*(_DWORD *)(a1 + 16))
              {
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                if ((int)v74 <= (int)v87) {
                  goto LABEL_259;
                }
              }
              else
              {
                *(_DWORD *)(a1 + 16) = 10;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                if ((int)v74 <= (int)v87) {
                  goto LABEL_259;
                }
              }
              goto LABEL_256;
            }
            doinsert((void *)a1, 2013265920, *(void *)(a1 + 40) - v4 + 1, v4);
            if (*(_DWORD *)(a1 + 16)) {
              goto LABEL_271;
            }
            uint64_t v82 = *(void *)(a1 + 32);
            uint64_t v83 = *(void *)(a1 + 40);
            if (v83 < v82
              || (v82 >= -1 ? (uint64_t v84 = v82 + 1) : (uint64_t v84 = v82 + 2),
                  unint64_t v85 = (v84 & 0xFFFFFFFFFFFFFFFELL) + (v84 >> 1),
                  v82 >= (uint64_t)v85))
            {
              int v86 = 0;
            }
            else
            {
              if (v85 >> 61)
              {
LABEL_191:
                int v86 = 12;
                *(_DWORD *)(a1 + 16) = 12;
LABEL_192:
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                goto LABEL_213;
              }
              v110 = realloc(*(void **)(a1 + 24), 24 * (v84 >> 1));
              if (!v110)
              {
                int v86 = *(_DWORD *)(a1 + 16);
                if (v86) {
                  goto LABEL_192;
                }
                goto LABEL_191;
              }
              *(void *)(a1 + 24) = v110;
              *(void *)(a1 + 32) = v85;
              int v86 = *(_DWORD *)(a1 + 16);
            }
LABEL_213:
            v92 = *(void **)(a1 + 24);
            uint64_t v93 = *(void *)(a1 + 40);
            *(void *)(a1 + 40) = v93 + 1;
            v92[v93] = (v83 - v4) | 0x80000000;
            if (v86) {
              goto LABEL_271;
            }
            v92[v4] = v92[v4] & 0xF8000000 | (*(void *)(a1 + 40) - v4);
            uint64_t v94 = *(void *)(a1 + 32);
            if (*(void *)(a1 + 40) < v94
              || (v94 >= -1 ? (uint64_t v95 = v94 + 1) : (uint64_t v95 = v94 + 2),
                  unint64_t v96 = (v95 & 0xFFFFFFFFFFFFFFFELL) + (v95 >> 1),
                  v94 >= (uint64_t)v96))
            {
              uint64_t v97 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v97 + 1;
              v92[v97] = 2281701376;
            }
            else
            {
              if (v96 >> 61)
              {
                *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
LABEL_327:
                uint64_t v136 = *(void *)(a1 + 40);
                *(void *)(a1 + 40) = v136 + 1;
                v92[v136] = 2281701376;
                goto LABEL_271;
              }
              v92 = realloc(v92, 24 * (v95 >> 1));
              if (!v92)
              {
                if (!*(_DWORD *)(a1 + 16)) {
                  *(_DWORD *)(a1 + 16) = 12;
                }
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                v92 = *(void **)(a1 + 24);
                goto LABEL_327;
              }
              *(void *)(a1 + 24) = v92;
              *(void *)(a1 + 32) = v96;
              int v123 = *(_DWORD *)(a1 + 16);
              uint64_t v124 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v124 + 1;
              v92[v124] = 2281701376;
              if (v123) {
                goto LABEL_271;
              }
            }
            v92[*(void *)(a1 + 40) - 1] = v92[*(void *)(a1 + 40) - 1] & 0xF8000000 | 1;
            uint64_t v98 = *(void *)(a1 + 32);
            if (*(void *)(a1 + 40) >= v98)
            {
              uint64_t v99 = v98 >= -1 ? v98 + 1 : v98 + 2;
              unint64_t v100 = (v99 & 0xFFFFFFFFFFFFFFFELL) + (v99 >> 1);
              if (v98 < (uint64_t)v100)
              {
                if (v100 >> 61)
                {
                  *(_DWORD *)(a1 + 16) = 12;
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
                }
                else
                {
                  v92 = realloc(v92, 24 * (v99 >> 1));
                  if (v92)
                  {
                    *(void *)(a1 + 24) = v92;
                    *(void *)(a1 + 32) = v100;
                  }
                  else
                  {
                    if (!*(_DWORD *)(a1 + 16)) {
                      *(_DWORD *)(a1 + 16) = 12;
                    }
                    *(void *)a1 = &nuls;
                    *(void *)(a1 + 8) = &nuls;
                    v92 = *(void **)(a1 + 24);
                  }
                }
              }
            }
            uint64_t v137 = *(void *)(a1 + 40);
            *(void *)(a1 + 40) = v137 + 1;
            v92[v137] = 2415919106;
            goto LABEL_271;
          }
          uint64_t v39 = *(void *)(a1 + 32);
          if (v4 >= v39)
          {
            uint64_t v40 = v39 >= -1 ? v39 + 1 : v39 + 2;
            unint64_t v41 = (v40 & 0xFFFFFFFFFFFFFFFELL) + (v40 >> 1);
            if (v39 < (uint64_t)v41)
            {
              if (v41 >> 61) {
                goto LABEL_94;
              }
              v125 = realloc(*(void **)(a1 + 24), 24 * (v40 >> 1));
              if (v125)
              {
                *(void *)(a1 + 24) = v125;
                *(void *)(a1 + 32) = v41;
              }
              else
              {
                if (!*(_DWORD *)(a1 + 16)) {
LABEL_94:
                }
                  *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
              }
            }
          }
          uint64_t v126 = *(void *)(a1 + 24);
          uint64_t v127 = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v127 + 1;
          *(void *)(v126 + 8 * v127) = v31 | 0x38000000;
          uint64_t v37 = *(void *)(a1 + 8 * v31 + 64) + 1;
          uint64_t v38 = *v34 - v37;
          if (v38) {
            goto LABEL_299;
          }
LABEL_82:
          if (*(_DWORD *)(a1 + 16)) {
            goto LABEL_318;
          }
LABEL_307:
          uint64_t v130 = *(void *)(a1 + 32);
          if (*(void *)(a1 + 40) >= v130)
          {
            uint64_t v131 = v130 >= -1 ? v130 + 1 : v130 + 2;
            unint64_t v132 = (v131 & 0xFFFFFFFFFFFFFFFELL) + (v131 >> 1);
            if (v130 < (uint64_t)v132)
            {
              if (v132 >> 61) {
                goto LABEL_313;
              }
              v133 = realloc(*(void **)(a1 + 24), 24 * (v131 >> 1));
              if (v133)
              {
                *(void *)(a1 + 24) = v133;
                *(void *)(a1 + 32) = v132;
              }
              else
              {
                if (!*(_DWORD *)(a1 + 16)) {
LABEL_313:
                }
                  *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
              }
            }
          }
          uint64_t v134 = *(void *)(a1 + 24);
          uint64_t v135 = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v135 + 1;
          *(void *)(v134 + 8 * v135) = v31 | 0x40000000;
          goto LABEL_318;
        }
        if (!v36)
        {
          int v29 = 6;
LABEL_139:
          *(_DWORD *)(a1 + 16) = v29;
        }
LABEL_140:
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
LABEL_141:
        char v24 = 1;
        int v7 = *(char **)a1;
        int v8 = *(char **)(a1 + 8);
        uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
        if (v25 >= 1) {
          goto LABEL_142;
        }
LABEL_10:
        if (v8 - v7 > 0) {
          continue;
        }
        uint64_t v4 = *(void *)(a1 + 40);
LABEL_337:
        if (v4 == v6)
        {
LABEL_338:
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 14;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          int v7 = &nuls;
          int v8 = &nuls;
        }
        if (v8 - v7 >= 1 && *v7 == 124)
        {
          *(void *)a1 = v7 + 1;
          if ((v158 & 1) == 0)
          {
            doinsert((void *)a1, 2013265920, v4 - v6 + 1, v6);
            uint64_t v4 = *(void *)(a1 + 40);
            uint64_t v157 = v6;
            if (*(_DWORD *)(a1 + 16)) {
              goto LABEL_3;
            }
LABEL_345:
            uint64_t v138 = *(void *)(a1 + 32);
            if (v4 < v138
              || (v138 >= -1 ? (uint64_t v139 = v138 + 1) : (uint64_t v139 = v138 + 2),
                  unint64_t v140 = (v139 & 0xFFFFFFFFFFFFFFFELL) + (v139 >> 1),
                  v138 >= (uint64_t)v140))
            {
              int v141 = 0;
            }
            else
            {
              if (v140 >> 61)
              {
LABEL_351:
                int v141 = 12;
                *(_DWORD *)(a1 + 16) = 12;
LABEL_352:
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                goto LABEL_354;
              }
              v147 = realloc(*(void **)(a1 + 24), 24 * (v139 >> 1));
              if (!v147)
              {
                int v141 = *(_DWORD *)(a1 + 16);
                if (v141) {
                  goto LABEL_352;
                }
                goto LABEL_351;
              }
              *(void *)(a1 + 24) = v147;
              *(void *)(a1 + 32) = v140;
              int v141 = *(_DWORD *)(a1 + 16);
            }
LABEL_354:
            v142 = *(void **)(a1 + 24);
            uint64_t v143 = *(void *)(a1 + 40);
            *(void *)(a1 + 40) = v143 + 1;
            v142[v143] = (v4 - v6) | 0x80000000;
            uint64_t v5 = *(void *)(a1 + 40);
            if (v141)
            {
              uint64_t v4 = *(void *)(a1 + 40);
            }
            else
            {
              v142[v157] = v142[v157] & 0xF8000000 | (v5 - v157);
              uint64_t v144 = *(void *)(a1 + 32);
              uint64_t v4 = *(void *)(a1 + 40);
              if (v4 >= v144)
              {
                uint64_t v145 = v144 >= -1 ? v144 + 1 : v144 + 2;
                unint64_t v146 = (v145 & 0xFFFFFFFFFFFFFFFELL) + (v145 >> 1);
                if (v144 < (uint64_t)v146)
                {
                  if (v146 >> 61)
                  {
                    *(_DWORD *)(a1 + 16) = 12;
                    *(void *)a1 = &nuls;
                    *(void *)(a1 + 8) = &nuls;
                  }
                  else
                  {
                    v142 = realloc(v142, 24 * (v145 >> 1));
                    if (v142)
                    {
                      *(void *)(a1 + 24) = v142;
                      *(void *)(a1 + 32) = v146;
                    }
                    else
                    {
                      if (!*(_DWORD *)(a1 + 16)) {
                        *(_DWORD *)(a1 + 16) = 12;
                      }
                      *(void *)a1 = &nuls;
                      *(void *)(a1 + 8) = &nuls;
                      v142 = *(void **)(a1 + 24);
                    }
                  }
                }
              }
              uint64_t v148 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v148 + 1;
              v142[v148] = 2281701376;
            }
            goto LABEL_4;
          }
          uint64_t v6 = v156;
          if (!*(_DWORD *)(a1 + 16)) {
            goto LABEL_345;
          }
LABEL_3:
          uint64_t v5 = v4;
LABEL_4:
          uint64_t v156 = v5 - 1;
          uint64_t v157 = v4;
          char v158 = 1;
          goto LABEL_5;
        }
        if ((v158 & 1) != 0 && !*(_DWORD *)(a1 + 16))
        {
          v149 = *(void **)(a1 + 24);
          v149[v157] = v149[v157] & 0xF8000000 | (v4 - v157);
          uint64_t v150 = *(void *)(a1 + 32);
          uint64_t v151 = *(void *)(a1 + 40);
          uint64_t v152 = v151 - v156;
          if (v151 >= v150)
          {
            uint64_t v153 = v150 >= -1 ? v150 + 1 : v150 + 2;
            unint64_t v154 = (v153 & 0xFFFFFFFFFFFFFFFELL) + (v153 >> 1);
            if (v150 < (uint64_t)v154)
            {
              if (v154 >> 61)
              {
                *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
              }
              else
              {
                v149 = realloc(v149, 24 * (v153 >> 1));
                if (v149)
                {
                  *(void *)(a1 + 24) = v149;
                  *(void *)(a1 + 32) = v154;
                }
                else
                {
                  if (!*(_DWORD *)(a1 + 16)) {
                    *(_DWORD *)(a1 + 16) = 12;
                  }
                  *(void *)a1 = &nuls;
                  *(void *)(a1 + 8) = &nuls;
                  v149 = *(void **)(a1 + 24);
                }
              }
            }
          }
          uint64_t v155 = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v155 + 1;
          v149[v155] = v152 | 0x90000000;
        }
        return;
      case '^':
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_106;
        }
        uint64_t v26 = *(void *)(a1 + 32);
        if (v4 < v26) {
          goto LABEL_105;
        }
        uint64_t v27 = v26 >= -1 ? v26 + 1 : v26 + 2;
        unint64_t v28 = (v27 & 0xFFFFFFFFFFFFFFFELL) + (v27 >> 1);
        if (v26 >= (uint64_t)v28) {
          goto LABEL_105;
        }
        if (v28 >> 61) {
          goto LABEL_59;
        }
        uint64_t v47 = realloc(*(void **)(a1 + 24), 24 * (v27 >> 1));
        if (v47)
        {
          *(void *)(a1 + 24) = v47;
          *(void *)(a1 + 32) = v28;
        }
        else
        {
          if (!*(_DWORD *)(a1 + 16)) {
LABEL_59:
          }
            *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_105:
        uint64_t v48 = *(void *)(a1 + 24);
        uint64_t v49 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v49 + 1;
        *(void *)(v48 + 8 * v49) = 402653184;
LABEL_106:
        char v24 = 0;
        int v50 = *(int32x2_t **)(a1 + 56);
        int32x2_t v51 = v50[9];
        int32x2_t v52 = vadd_s32(v51, (int32x2_t)0x100000001);
        v51.i32[0] |= 1u;
        v51.i32[1] = v52.i32[1];
        v50[9] = v51;
        int v7 = *(char **)a1;
        int v8 = *(char **)(a1 + 8);
        uint64_t v25 = (uint64_t)&v8[-*(void *)a1];
        if (v25 < 1) {
          goto LABEL_10;
        }
        goto LABEL_142;
      case '{':
        if (v8 - v11 >= 1 && *v11 - 48 <= 9)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 13;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
        goto LABEL_84;
      case '|':
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_140;
        }
        int v29 = 14;
        goto LABEL_139;
      default:
        goto LABEL_84;
    }
  }
}

void p_bre(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(char **)a1;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v7 = (uint64_t)&v6[-*(void *)a1];
  if (v7 < 1) {
    goto LABEL_17;
  }
  if (*v5 == 94)
  {
    *(void *)a1 = ++v5;
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_15;
    }
    uint64_t v9 = *(void *)(a1 + 32);
    if (v4 >= v9)
    {
      uint64_t v10 = v9 >= -1 ? v9 + 1 : v9 + 2;
      unint64_t v11 = (v10 & 0xFFFFFFFFFFFFFFFELL) + (v10 >> 1);
      if (v9 < (uint64_t)v11)
      {
        if (v11 >> 61) {
          goto LABEL_10;
        }
        int v12 = realloc(*(void **)(a1 + 24), 24 * (v10 >> 1));
        if (v12)
        {
          *(void *)(a1 + 24) = v12;
          *(void *)(a1 + 32) = v11;
          uint64_t v5 = *(char **)a1;
          uint64_t v6 = *(char **)(a1 + 8);
          goto LABEL_14;
        }
        if (!*(_DWORD *)(a1 + 16)) {
LABEL_10:
        }
          *(_DWORD *)(a1 + 16) = 12;
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        uint64_t v5 = &nuls;
        uint64_t v6 = &nuls;
      }
    }
LABEL_14:
    uint64_t v13 = *(void *)(a1 + 24);
    uint64_t v14 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v14 + 1;
    *(void *)(v13 + 8 * v14) = 402653184;
LABEL_15:
    unint64_t v15 = *(int32x2_t **)(a1 + 56);
    int32x2_t v16 = v15[9];
    int32x2_t v17 = vadd_s32(v16, (int32x2_t)0x100000001);
    v16.i32[0] |= 1u;
    v16.i32[1] = v17.i32[1];
    v15[9] = v16;
    uint64_t v7 = v6 - v5;
    if (v6 - v5 >= 1) {
      goto LABEL_16;
    }
LABEL_17:
    if (*(void *)(a1 + 40) == v4) {
      goto LABEL_247;
    }
    return;
  }
LABEL_16:
  uint64_t v107 = v4;
  int v18 = 0;
  char v19 = 0;
  while (v7 == 1 || *v5 != a2 || v5[1] != a3)
  {
    uint64_t v23 = *(void *)(a1 + 40);
    char v24 = v5 + 1;
    *(void *)a1 = v5 + 1;
    int v25 = *v5;
    if (v25 == 92)
    {
      if (v6 - v24 <= 0)
      {
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = 5;
        }
        *(void *)(a1 + 8) = &nuls;
        uint64_t v6 = &nuls;
        char v24 = &nuls;
      }
      *(void *)a1 = v24 + 1;
      int v25 = *v24++ | 0x100;
    }
    if (v25 <= 295)
    {
      if (v25 == 42)
      {
        if (v19)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 13;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_72:
        ordinary(a1, (char)v25);
        goto LABEL_149;
      }
      if (v25 != 46)
      {
        if (v25 == 91)
        {
          p_bracket(a1);
          goto LABEL_149;
        }
        goto LABEL_72;
      }
      if ((*(unsigned char *)(*(void *)(a1 + 56) + 40) & 8) != 0)
      {
        *(void *)a1 = &nonnewline_bracket;
        *(void *)(a1 + 8) = &unk_1811283B3;
        p_bracket(a1);
        *(void *)a1 = v24;
        *(void *)(a1 + 8) = v6;
        goto LABEL_149;
      }
      if (*(_DWORD *)(a1 + 16)) {
        goto LABEL_149;
      }
      uint64_t v44 = *(void *)(a1 + 32);
      if (v23 >= v44)
      {
        uint64_t v45 = v44 >= -1 ? v44 + 1 : v44 + 2;
        unint64_t v46 = (v45 & 0xFFFFFFFFFFFFFFFELL) + (v45 >> 1);
        if (v44 < (uint64_t)v46)
        {
          if (v46 >> 61) {
            goto LABEL_81;
          }
          uint64_t v59 = realloc(*(void **)(a1 + 24), 24 * (v45 >> 1));
          if (v59)
          {
            *(void *)(a1 + 24) = v59;
            *(void *)(a1 + 32) = v46;
          }
          else
          {
            if (!*(_DWORD *)(a1 + 16)) {
LABEL_81:
            }
              *(_DWORD *)(a1 + 16) = 12;
            *(void *)a1 = &nuls;
            *(void *)(a1 + 8) = &nuls;
          }
        }
      }
      uint64_t v60 = *(void *)(a1 + 24);
      uint64_t v61 = *(void *)(a1 + 40);
      *(void *)(a1 + 40) = v61 + 1;
      *(void *)(v60 + 8 * v61) = 671088640;
      goto LABEL_149;
    }
    switch(v25)
    {
      case 296:
        uint64_t v37 = *(void *)(a1 + 56);
        uint64_t v38 = *(void *)(v37 + 112) + 1;
        *(void *)(v37 + 112) = v38;
        if (v38 > 9)
        {
          if (*(_DWORD *)(a1 + 16))
          {
LABEL_66:
            BOOL v43 = v6 - v24 == 1;
            if (v6 - v24 < 1) {
              goto LABEL_126;
            }
LABEL_122:
            if (v43 || *v24 != 92 || v24[1] != 41) {
              p_bre(a1, 92, 41);
            }
            goto LABEL_126;
          }
        }
        else
        {
          *(void *)(a1 + 8 * v38 + 64) = v23;
          if (*(_DWORD *)(a1 + 16)) {
            goto LABEL_66;
          }
        }
        uint64_t v39 = *(void *)(a1 + 32);
        if (*(void *)(a1 + 40) >= v39)
        {
          uint64_t v40 = v39 >= -1 ? v39 + 1 : v39 + 2;
          unint64_t v41 = (v40 & 0xFFFFFFFFFFFFFFFELL) + (v40 >> 1);
          if (v39 < (uint64_t)v41)
          {
            if (v41 >> 61)
            {
              *(_DWORD *)(a1 + 16) = 12;
              char v24 = &nuls;
              uint64_t v6 = &nuls;
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
            }
            else
            {
              uint64_t v58 = realloc(*(void **)(a1 + 24), 24 * (v40 >> 1));
              if (v58)
              {
                *(void *)(a1 + 24) = v58;
                *(void *)(a1 + 32) = v41;
                char v24 = *(char **)a1;
                uint64_t v6 = *(char **)(a1 + 8);
              }
              else
              {
                if (!*(_DWORD *)(a1 + 16)) {
                  *(_DWORD *)(a1 + 16) = 12;
                }
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
                char v24 = &nuls;
                uint64_t v6 = &nuls;
              }
            }
          }
        }
        uint64_t v62 = *(void *)(a1 + 24);
        uint64_t v63 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v63 + 1;
        *(void *)(v62 + 8 * v63) = v38 | 0x68000000;
        BOOL v43 = v6 - v24 == 1;
        if (v6 - v24 >= 1) {
          goto LABEL_122;
        }
LABEL_126:
        if (v38 > 9)
        {
          if (*(_DWORD *)(a1 + 16))
          {
LABEL_137:
            long long v67 = *(char **)a1;
            if ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) < 2) {
              goto LABEL_145;
            }
            goto LABEL_142;
          }
        }
        else
        {
          *(void *)(a1 + 8 * v38 + 144) = *(void *)(a1 + 40);
          if (*(_DWORD *)(a1 + 16)) {
            goto LABEL_137;
          }
        }
        uint64_t v64 = *(void *)(a1 + 32);
        if (*(void *)(a1 + 40) < v64) {
          goto LABEL_141;
        }
        uint64_t v65 = v64 >= -1 ? v64 + 1 : v64 + 2;
        unint64_t v66 = (v65 & 0xFFFFFFFFFFFFFFFELL) + (v65 >> 1);
        if (v64 >= (uint64_t)v66) {
          goto LABEL_141;
        }
        if (v66 >> 61) {
          goto LABEL_134;
        }
        uint64_t v68 = realloc(*(void **)(a1 + 24), 24 * (v65 >> 1));
        if (v68)
        {
          *(void *)(a1 + 24) = v68;
          *(void *)(a1 + 32) = v66;
        }
        else
        {
          if (!*(_DWORD *)(a1 + 16)) {
LABEL_134:
          }
            *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_141:
        uint64_t v69 = *(void *)(a1 + 24);
        uint64_t v70 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v70 + 1;
        *(void *)(v69 + 8 * v70) = v38 | 0x70000000;
        long long v67 = *(char **)a1;
        if ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) < 2) {
          goto LABEL_145;
        }
LABEL_142:
        if (*v67 == 92 && v67[1] == 41)
        {
          *(void *)a1 = v67 + 2;
          break;
        }
LABEL_145:
        if (!*(_DWORD *)(a1 + 16))
        {
          int v42 = 8;
LABEL_147:
          *(_DWORD *)(a1 + 16) = v42;
        }
LABEL_148:
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        break;
      case 297:
      case 381:
        goto LABEL_145;
      case 305:
      case 306:
      case 307:
      case 308:
      case 309:
      case 310:
      case 311:
      case 312:
      case 313:
        uint64_t v26 = (v25 & 0xFFFFFEFF) - 48;
        uint64_t v27 = a1 + 8 * v26;
        uint64_t v30 = *(void *)(v27 + 144);
        int v29 = (void *)(v27 + 144);
        uint64_t v28 = v30;
        int v31 = *(_DWORD *)(a1 + 16);
        if (!v30)
        {
          if (!v31) {
            *(_DWORD *)(a1 + 16) = 6;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          goto LABEL_106;
        }
        if (v31)
        {
          uint64_t v32 = *(void *)(a1 + 8 * v26 + 64) + 1;
          uint64_t v33 = v28 - v32;
          if (v28 == v32) {
            goto LABEL_37;
          }
          goto LABEL_87;
        }
        uint64_t v34 = *(void *)(a1 + 32);
        if (v23 < v34) {
          goto LABEL_86;
        }
        uint64_t v35 = v34 >= -1 ? v34 + 1 : v34 + 2;
        unint64_t v36 = (v35 & 0xFFFFFFFFFFFFFFFELL) + (v35 >> 1);
        if (v34 >= (uint64_t)v36) {
          goto LABEL_86;
        }
        if (v36 >> 61) {
          goto LABEL_52;
        }
        uint64_t v47 = realloc(*(void **)(a1 + 24), 24 * (v35 >> 1));
        if (v47)
        {
          *(void *)(a1 + 24) = v47;
          *(void *)(a1 + 32) = v36;
        }
        else
        {
          if (!*(_DWORD *)(a1 + 16)) {
LABEL_52:
          }
            *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
LABEL_86:
        uint64_t v48 = *(void *)(a1 + 24);
        uint64_t v49 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v49 + 1;
        *(void *)(v48 + 8 * v49) = v26 | 0x38000000;
        uint64_t v32 = *(void *)(a1 + 8 * v26 + 64) + 1;
        uint64_t v33 = *v29 - v32;
        if (!v33)
        {
LABEL_37:
          if (*(_DWORD *)(a1 + 16)) {
            goto LABEL_106;
          }
LABEL_95:
          uint64_t v52 = *(void *)(a1 + 32);
          if (*(void *)(a1 + 40) >= v52)
          {
            uint64_t v53 = v52 >= -1 ? v52 + 1 : v52 + 2;
            unint64_t v54 = (v53 & 0xFFFFFFFFFFFFFFFELL) + (v53 >> 1);
            if (v52 < (uint64_t)v54)
            {
              if (v54 >> 61) {
                goto LABEL_101;
              }
              uint64_t v55 = realloc(*(void **)(a1 + 24), 24 * (v53 >> 1));
              if (v55)
              {
                *(void *)(a1 + 24) = v55;
                *(void *)(a1 + 32) = v54;
              }
              else
              {
                if (!*(_DWORD *)(a1 + 16)) {
LABEL_101:
                }
                  *(_DWORD *)(a1 + 16) = 12;
                *(void *)a1 = &nuls;
                *(void *)(a1 + 8) = &nuls;
              }
            }
          }
          uint64_t v56 = *(void *)(a1 + 24);
          uint64_t v57 = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v57 + 1;
          *(void *)(v56 + 8 * v57) = v26 | 0x40000000;
          goto LABEL_106;
        }
LABEL_87:
        if (v33 >= 1)
        {
          unint64_t v50 = *(void *)(a1 + 32) + v33;
          if (v50 >> 61 || (int32x2_t v51 = realloc(*(void **)(a1 + 24), 8 * v50)) == 0)
          {
            if (!*(_DWORD *)(a1 + 16)) {
              *(_DWORD *)(a1 + 16) = 12;
            }
            *(void *)a1 = &nuls;
            *(void *)(a1 + 8) = &nuls;
          }
          else
          {
            *(void *)(a1 + 24) = v51;
            *(void *)(a1 + 32) = v50;
          }
        }
        memmove((void *)(*(void *)(a1 + 24) + 8 * *(void *)(a1 + 40)), (const void *)(*(void *)(a1 + 24) + 8 * v32), 8 * v33);
        *(void *)(a1 + 40) += v33;
        if (!*(_DWORD *)(a1 + 16)) {
          goto LABEL_95;
        }
LABEL_106:
        *(_DWORD *)(*(void *)(a1 + 56) + 120) = 1;
        break;
      case 379:
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_148;
        }
        int v42 = 13;
        goto LABEL_147;
      default:
        goto LABEL_72;
    }
LABEL_149:
    uint64_t v5 = *(char **)a1;
    uint64_t v6 = *(char **)(a1 + 8);
    uint64_t v7 = (uint64_t)&v6[-*(void *)a1];
    if (v7 < 1) {
      goto LABEL_169;
    }
    int v71 = *v5;
    if (v71 == 42)
    {
      *(void *)a1 = v5 + 1;
      doinsert((void *)a1, 1207959552, *(void *)(a1 + 40) - v23 + 1, v23);
      uint64_t v72 = *(void *)(a1 + 40);
      uint64_t v73 = v72 - v23;
      if (!*(_DWORD *)(a1 + 16))
      {
        uint64_t v74 = *(void *)(a1 + 32);
        if (v72 >= v74)
        {
          uint64_t v75 = v74 >= -1 ? v74 + 1 : v74 + 2;
          unint64_t v76 = (v75 & 0xFFFFFFFFFFFFFFFELL) + (v75 >> 1);
          if (v74 < (uint64_t)v76)
          {
            if (v76 >> 61) {
              goto LABEL_158;
            }
            uint64_t v91 = realloc(*(void **)(a1 + 24), 24 * (v75 >> 1));
            if (v91)
            {
              *(void *)(a1 + 24) = v91;
              *(void *)(a1 + 32) = v76;
            }
            else
            {
              if (!*(_DWORD *)(a1 + 16)) {
LABEL_158:
              }
                *(_DWORD *)(a1 + 16) = 12;
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
            }
          }
        }
        uint64_t v92 = *(void *)(a1 + 24);
        uint64_t v93 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v93 + 1;
        *(void *)(v92 + 8 * v93) = v73 | 0x50000000;
        uint64_t v73 = *(void *)(a1 + 40) - v23;
      }
      doinsert((void *)a1, 1476395008, v73 + 1, v23);
      if (*(_DWORD *)(a1 + 16)) {
        goto LABEL_22;
      }
      uint64_t v94 = *(void *)(a1 + 32);
      uint64_t v95 = *(void *)(a1 + 40);
      if (v95 >= v94)
      {
        uint64_t v96 = v94 >= -1 ? v94 + 1 : v94 + 2;
        unint64_t v97 = (v96 & 0xFFFFFFFFFFFFFFFELL) + (v96 >> 1);
        if (v94 < (uint64_t)v97)
        {
          if (v97 >> 61) {
            goto LABEL_223;
          }
          unint64_t v20 = realloc(*(void **)(a1 + 24), 24 * (v96 >> 1));
          if (v20)
          {
            *(void *)(a1 + 24) = v20;
            *(void *)(a1 + 32) = v97;
          }
          else
          {
            if (!*(_DWORD *)(a1 + 16)) {
LABEL_223:
            }
              *(_DWORD *)(a1 + 16) = 12;
            *(void *)a1 = &nuls;
            *(void *)(a1 + 8) = &nuls;
          }
        }
      }
      uint64_t v21 = *(void *)(a1 + 24);
      uint64_t v22 = *(void *)(a1 + 40);
      *(void *)(a1 + 40) = v22 + 1;
      *(void *)(v21 + 8 * v22) = (v95 - v23) | 0x60000000;
      goto LABEL_22;
    }
    if ((unint64_t)v7 >= 2 && v71 == 92 && v5[1] == 123)
    {
      *(void *)a1 = v5 + 2;
      uint64_t v77 = v6 - (v5 + 2);
      if (v77 < 1)
      {
        uint64_t v79 = 0;
      }
      else
      {
        uint64_t v78 = 0;
        uint64_t v79 = 0;
        while (1)
        {
          uint64_t v80 = &v5[v78];
          if (v5[v78 + 2] - 48 > 9 || (int)v79 > 255) {
            break;
          }
          *(void *)a1 = &v5[v78 + 3];
          uint64_t v79 = (v80[2] + 10 * v79 - 48);
          ++v78;
          if (--v77 <= 0)
          {
            unint64_t v81 = &v5[v78 + 2];
            goto LABEL_174;
          }
        }
        unint64_t v81 = v80 + 2;
        if (!v78) {
          goto LABEL_175;
        }
LABEL_174:
        if ((int)v79 < 256) {
          goto LABEL_178;
        }
      }
LABEL_175:
      if (!*(_DWORD *)(a1 + 16)) {
        *(_DWORD *)(a1 + 16) = 10;
      }
      *(void *)a1 = &nuls;
      *(void *)(a1 + 8) = &nuls;
      unint64_t v81 = &nuls;
      uint64_t v6 = &nuls;
LABEL_178:
      uint64_t v82 = v79;
      if (v6 - v81 >= 1)
      {
        uint64_t v82 = v79;
        if (*v81 == 44)
        {
          uint64_t v83 = v81 + 1;
          *(void *)a1 = v83;
          int64_t v84 = v6 - v83;
          if (v6 - v83 < 1 || *v83 - 48 > 9)
          {
            uint64_t v82 = 256;
          }
          else
          {
            uint64_t v85 = 0;
            uint64_t v82 = 0;
            while (1)
            {
              int v86 = (unsigned __int8 *)&v83[v85];
              if (v83[v85] - 48 > 9 || (int)v82 > 255) {
                break;
              }
              *(void *)a1 = v86 + 1;
              uint64_t v82 = ((char)*v86 + 10 * v82 - 48);
              ++v85;
              if (--v84 <= 0)
              {
                LODWORD(v85) = 1;
                break;
              }
            }
            if (!v85 || (int)v82 >= 256)
            {
              if (!*(_DWORD *)(a1 + 16)) {
                *(_DWORD *)(a1 + 16) = 10;
              }
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
            }
            if ((int)v79 > (int)v82)
            {
              if (!*(_DWORD *)(a1 + 16)) {
                *(_DWORD *)(a1 + 16) = 10;
              }
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
            }
          }
        }
      }
      repeat((uint64_t *)a1, v23, v79, v82);
      uint64_t v87 = *(char **)a1;
      uint64_t v88 = *(void *)(a1 + 8) - *(void *)a1;
      if (v88 <= 1)
      {
        if (v88 == 1)
        {
LABEL_202:
          uint64_t v89 = v87 + 1;
          while (1)
          {
            if (--v88)
            {
              if (*(v89 - 1) == 92 && *v89 == 125) {
                break;
              }
            }
            *(void *)a1 = v89++;
            if (v88 <= 0) {
              goto LABEL_209;
            }
          }
          if (!*(_DWORD *)(a1 + 16))
          {
            int v90 = 10;
            goto LABEL_211;
          }
        }
        else
        {
LABEL_209:
          if (!*(_DWORD *)(a1 + 16))
          {
            int v90 = 9;
LABEL_211:
            *(_DWORD *)(a1 + 16) = v90;
          }
        }
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        goto LABEL_22;
      }
      if (*v87 != 92 || v87[1] != 125) {
        goto LABEL_202;
      }
      *(void *)a1 = v87 + 2;
LABEL_22:
      int v18 = 0;
      uint64_t v5 = *(char **)a1;
      uint64_t v6 = *(char **)(a1 + 8);
      uint64_t v7 = (uint64_t)&v6[-*(void *)a1];
      char v19 = 1;
      if (v7 <= 0) {
        break;
      }
    }
    else
    {
LABEL_169:
      if (v25 != 36) {
        goto LABEL_22;
      }
      int v18 = 1;
      char v19 = 1;
      if (v7 <= 0) {
        break;
      }
    }
  }
  uint64_t v98 = *(void *)(a1 + 40);
  if (v18)
  {
    uint64_t v99 = v98 - 1;
    *(void *)(a1 + 40) = v98 - 1;
    if (!*(_DWORD *)(a1 + 16))
    {
      uint64_t v100 = *(void *)(a1 + 32);
      if (v98 > v100)
      {
        uint64_t v101 = v100 >= -1 ? v100 + 1 : v100 + 2;
        unint64_t v102 = (v101 & 0xFFFFFFFFFFFFFFFELL) + (v101 >> 1);
        if (v100 < (uint64_t)v102)
        {
          if (v102 >> 61) {
            goto LABEL_239;
          }
          v103 = realloc(*(void **)(a1 + 24), 24 * (v101 >> 1));
          if (v103)
          {
            *(void *)(a1 + 24) = v103;
            *(void *)(a1 + 32) = v102;
          }
          else
          {
            if (!*(_DWORD *)(a1 + 16)) {
LABEL_239:
            }
              *(_DWORD *)(a1 + 16) = 12;
            *(void *)a1 = &nuls;
            *(void *)(a1 + 8) = &nuls;
          }
        }
      }
      uint64_t v104 = *(void *)(a1 + 24);
      uint64_t v105 = *(void *)(a1 + 40);
      *(void *)(a1 + 40) = v105 + 1;
      *(void *)(v104 + 8 * v105) = 0x20000000;
      uint64_t v99 = *(void *)(a1 + 40);
    }
    uint64_t v106 = *(void *)(a1 + 56);
    *(_DWORD *)(v106 + 72) |= 2u;
    ++*(_DWORD *)(v106 + 80);
    if (v99 == v107)
    {
LABEL_247:
      if (!*(_DWORD *)(a1 + 16)) {
        *(_DWORD *)(a1 + 16) = 14;
      }
      *(void *)a1 = &nuls;
      *(void *)(a1 + 8) = &nuls;
    }
  }
  else if (v98 == v107)
  {
    goto LABEL_247;
  }
}

void *doinsert(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*((_DWORD *)result + 4))
  {
    uint64_t v7 = result;
    uint64_t v8 = *((void *)result + 4);
    uint64_t v9 = *((void *)result + 5);
    if (v9 >= v8)
    {
      uint64_t v10 = v8 >= -1 ? v8 + 1 : v8 + 2;
      unint64_t v11 = (v10 & 0xFFFFFFFFFFFFFFFELL) + (v10 >> 1);
      if (v8 < (uint64_t)v11)
      {
        if (v11 >> 61)
        {
LABEL_8:
          v7[4] = 12;
LABEL_9:
          *(void *)uint64_t v7 = &nuls;
          *((void *)v7 + 1) = &nuls;
          goto LABEL_12;
        }
        int v12 = realloc(*((void **)result + 3), 24 * (v10 >> 1));
        if (!v12)
        {
          if (v7[4]) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        *((void *)v7 + 3) = v12;
        *((void *)v7 + 4) = v11;
      }
    }
LABEL_12:
    uint64_t v13 = *((void *)v7 + 3);
    uint64_t v14 = *((void *)v7 + 5);
    *((void *)v7 + 5) = v14 + 1;
    *(void *)(v13 + 8 * v14) = a3 | a2;
    uint64_t v15 = *(void *)(v13 + 8 * v9);
    uint64_t v16 = *((void *)v7 + 9);
    if (v16 >= a4)
    {
      *((void *)v7 + 9) = v16 + 1;
      uint64_t v17 = *((void *)v7 + 19);
      if (v17 < a4)
      {
LABEL_14:
        uint64_t v18 = *((void *)v7 + 10);
        if (v18 < a4) {
          goto LABEL_15;
        }
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v17 = *((void *)v7 + 19);
      if (v17 < a4) {
        goto LABEL_14;
      }
    }
    *((void *)v7 + 19) = v17 + 1;
    uint64_t v18 = *((void *)v7 + 10);
    if (v18 < a4)
    {
LABEL_15:
      uint64_t v19 = *((void *)v7 + 20);
      if (v19 < a4) {
        goto LABEL_16;
      }
      goto LABEL_35;
    }
LABEL_34:
    *((void *)v7 + 10) = v18 + 1;
    uint64_t v19 = *((void *)v7 + 20);
    if (v19 < a4)
    {
LABEL_16:
      uint64_t v20 = *((void *)v7 + 11);
      if (v20 < a4) {
        goto LABEL_17;
      }
      goto LABEL_36;
    }
LABEL_35:
    *((void *)v7 + 20) = v19 + 1;
    uint64_t v20 = *((void *)v7 + 11);
    if (v20 < a4)
    {
LABEL_17:
      uint64_t v21 = *((void *)v7 + 21);
      if (v21 < a4) {
        goto LABEL_18;
      }
      goto LABEL_37;
    }
LABEL_36:
    *((void *)v7 + 11) = v20 + 1;
    uint64_t v21 = *((void *)v7 + 21);
    if (v21 < a4)
    {
LABEL_18:
      uint64_t v22 = *((void *)v7 + 12);
      if (v22 < a4) {
        goto LABEL_19;
      }
      goto LABEL_38;
    }
LABEL_37:
    *((void *)v7 + 21) = v21 + 1;
    uint64_t v22 = *((void *)v7 + 12);
    if (v22 < a4)
    {
LABEL_19:
      uint64_t v23 = *((void *)v7 + 22);
      if (v23 < a4) {
        goto LABEL_20;
      }
      goto LABEL_39;
    }
LABEL_38:
    *((void *)v7 + 12) = v22 + 1;
    uint64_t v23 = *((void *)v7 + 22);
    if (v23 < a4)
    {
LABEL_20:
      uint64_t v24 = *((void *)v7 + 13);
      if (v24 < a4) {
        goto LABEL_21;
      }
      goto LABEL_40;
    }
LABEL_39:
    *((void *)v7 + 22) = v23 + 1;
    uint64_t v24 = *((void *)v7 + 13);
    if (v24 < a4)
    {
LABEL_21:
      uint64_t v25 = *((void *)v7 + 23);
      if (v25 < a4) {
        goto LABEL_22;
      }
      goto LABEL_41;
    }
LABEL_40:
    *((void *)v7 + 13) = v24 + 1;
    uint64_t v25 = *((void *)v7 + 23);
    if (v25 < a4)
    {
LABEL_22:
      uint64_t v26 = *((void *)v7 + 14);
      if (v26 < a4) {
        goto LABEL_23;
      }
      goto LABEL_42;
    }
LABEL_41:
    *((void *)v7 + 23) = v25 + 1;
    uint64_t v26 = *((void *)v7 + 14);
    if (v26 < a4)
    {
LABEL_23:
      uint64_t v27 = *((void *)v7 + 24);
      if (v27 < a4) {
        goto LABEL_24;
      }
      goto LABEL_43;
    }
LABEL_42:
    *((void *)v7 + 14) = v26 + 1;
    uint64_t v27 = *((void *)v7 + 24);
    if (v27 < a4)
    {
LABEL_24:
      uint64_t v28 = *((void *)v7 + 15);
      if (v28 < a4) {
        goto LABEL_25;
      }
      goto LABEL_44;
    }
LABEL_43:
    *((void *)v7 + 24) = v27 + 1;
    uint64_t v28 = *((void *)v7 + 15);
    if (v28 < a4)
    {
LABEL_25:
      uint64_t v29 = *((void *)v7 + 25);
      if (v29 < a4) {
        goto LABEL_26;
      }
      goto LABEL_45;
    }
LABEL_44:
    *((void *)v7 + 15) = v28 + 1;
    uint64_t v29 = *((void *)v7 + 25);
    if (v29 < a4)
    {
LABEL_26:
      uint64_t v30 = *((void *)v7 + 16);
      if (v30 < a4) {
        goto LABEL_27;
      }
      goto LABEL_46;
    }
LABEL_45:
    *((void *)v7 + 25) = v29 + 1;
    uint64_t v30 = *((void *)v7 + 16);
    if (v30 < a4)
    {
LABEL_27:
      uint64_t v31 = *((void *)v7 + 26);
      if (v31 < a4) {
        goto LABEL_28;
      }
      goto LABEL_47;
    }
LABEL_46:
    *((void *)v7 + 16) = v30 + 1;
    uint64_t v31 = *((void *)v7 + 26);
    if (v31 < a4)
    {
LABEL_28:
      uint64_t v32 = *((void *)v7 + 17);
      if (v32 < a4) {
        goto LABEL_29;
      }
      goto LABEL_48;
    }
LABEL_47:
    *((void *)v7 + 26) = v31 + 1;
    uint64_t v32 = *((void *)v7 + 17);
    if (v32 < a4)
    {
LABEL_29:
      uint64_t v33 = *((void *)v7 + 27);
      if (v33 < a4)
      {
LABEL_31:
        BOOL result = memmove((void *)(v13 + 8 * a4 + 8), (const void *)(v13 + 8 * a4), 8 * (*((void *)v7 + 5) + ~a4));
        *(void *)(*((void *)v7 + 3) + 8 * a4) = v15;
        return result;
      }
LABEL_30:
      *((void *)v7 + 27) = v33 + 1;
      goto LABEL_31;
    }
LABEL_48:
    *((void *)v7 + 17) = v32 + 1;
    uint64_t v33 = *((void *)v7 + 27);
    if (v33 < a4) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  return result;
}

void p_bracket(uint64_t a1)
{
  uint64_t v2 = *(char **)a1;
  if ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >= 6)
  {
    if (strncmp(*(const char **)a1, "[:<:]]", 6uLL))
    {
      if (strncmp(v2, "[:>:]]", 6uLL)) {
        goto LABEL_4;
      }
      if (!*(_DWORD *)(a1 + 16))
      {
        uint64_t v29 = *(void *)(a1 + 32);
        if (*(void *)(a1 + 40) < v29) {
          goto LABEL_258;
        }
        uint64_t v30 = v29 >= -1 ? v29 + 1 : v29 + 2;
        unint64_t v31 = (v30 & 0xFFFFFFFFFFFFFFFELL) + (v30 >> 1);
        if (v29 >= (uint64_t)v31) {
          goto LABEL_258;
        }
        if (v31 >> 61) {
          goto LABEL_36;
        }
        v116 = realloc(*(void **)(a1 + 24), 24 * (v30 >> 1));
        if (v116)
        {
          *(void *)(a1 + 24) = v116;
          *(void *)(a1 + 32) = v31;
          uint64_t v2 = *(char **)a1;
          goto LABEL_258;
        }
        if (!*(_DWORD *)(a1 + 16)) {
LABEL_36:
        }
          *(_DWORD *)(a1 + 16) = 12;
        uint64_t v2 = &nuls;
        *(void *)(a1 + 8) = &nuls;
LABEL_258:
        uint64_t v96 = *(void *)(a1 + 24);
        uint64_t v97 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v97 + 1;
        uint64_t v98 = 2684354560;
        goto LABEL_259;
      }
LABEL_260:
      *(void *)a1 = v2 + 6;
      return;
    }
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_260;
    }
    uint64_t v26 = *(void *)(a1 + 32);
    if (*(void *)(a1 + 40) >= v26)
    {
      uint64_t v27 = v26 >= -1 ? v26 + 1 : v26 + 2;
      unint64_t v28 = (v27 & 0xFFFFFFFFFFFFFFFELL) + (v27 >> 1);
      if (v26 < (uint64_t)v28)
      {
        if (v28 >> 61) {
          goto LABEL_27;
        }
        uint64_t v95 = realloc(*(void **)(a1 + 24), 24 * (v27 >> 1));
        if (v95)
        {
          *(void *)(a1 + 24) = v95;
          *(void *)(a1 + 32) = v28;
          uint64_t v2 = *(char **)a1;
          goto LABEL_234;
        }
        if (!*(_DWORD *)(a1 + 16)) {
LABEL_27:
        }
          *(_DWORD *)(a1 + 16) = 12;
        uint64_t v2 = &nuls;
        *(void *)(a1 + 8) = &nuls;
      }
    }
LABEL_234:
    uint64_t v96 = *(void *)(a1 + 24);
    uint64_t v97 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v97 + 1;
    uint64_t v98 = 2550136832;
LABEL_259:
    *(void *)(v96 + 8 * v97) = v98;
    goto LABEL_260;
  }
LABEL_4:
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(unsigned int *)(v3 + 20);
  size_t v5 = *(int *)(v3 + 16);
  *(_DWORD *)(v3 + 20) = v4 + 1;
  int v6 = *(_DWORD *)(a1 + 48);
  if ((int)v4 < v6)
  {
    uint64_t v7 = *(void *)(v3 + 24);
    if (!v7) {
      goto LABEL_195;
    }
    goto LABEL_6;
  }
  unint64_t v20 = (v6 + 8);
  *(_DWORD *)(a1 + 48) = v20;
  if (v6 < -8) {
    goto LABEL_195;
  }
  uint64_t v21 = realloc(*(void **)(v3 + 24), 32 * (v6 + 8));
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v21) {
    goto LABEL_195;
  }
  size_t v22 = (int)(v20 >> 3) * (uint64_t)(int)v5;
  *(void *)(v3 + 24) = v21;
  uint64_t v23 = (char *)realloc(*(void **)(v3 + 32), v22);
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v23) {
    goto LABEL_195;
  }
  *(void *)(v3 + 32) = v23;
  if ((int)v4 >= 1)
  {
    uint64_t v24 = *(void *)(v3 + 24);
    if (v4 == 1)
    {
      uint64_t v25 = 0;
LABEL_192:
      unint64_t v81 = (void *)(v24 + 32 * v25);
      do
      {
        *unint64_t v81 = &v23[(v25 >> 3) * (uint64_t)(int)v5];
        v81 += 4;
        ++v25;
      }
      while (v4 != v25);
      goto LABEL_194;
    }
    uint64_t v78 = 0;
    uint64_t v25 = v4 & 0xFFFFFFFE;
    uint64_t v79 = (char **)(v24 + 32);
    do
    {
      uint64_t v80 = &v23[(v78 >> 3) * (uint64_t)(int)v5];
      *(v79 - 4) = v80;
      *uint64_t v79 = v80;
      v79 += 8;
      v78 += 2;
    }
    while (v25 != v78);
    if (v25 != v4) {
      goto LABEL_192;
    }
  }
LABEL_194:
  bzero(&v23[v22 - v5], v5);
  uint64_t v7 = *(void *)(v3 + 24);
  if (!v7) {
    goto LABEL_195;
  }
LABEL_6:
  uint64_t v8 = *(void *)(v3 + 32);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)(v7 + 32 * (int)v4);
    uint64_t v10 = v8 + (int)v5 * (uint64_t)((int)v4 / 8);
    uint64_t v11 = 1;
    int v12 = 1 << (v4 & 7);
    *((unsigned char *)v9 + 8) = v12;
    uint64_t v13 = v9 + 1;
    *((unsigned char *)v9 + 9) = 0;
    uint64_t v14 = (char *)v9 + 9;
    _OWORD v9[2] = 0;
    uint64_t v15 = v9 + 2;
    *uint64_t v9 = v10;
    v9[3] = 0;
    uint64_t v16 = *(const char **)a1;
    uint64_t v17 = *(void *)(a1 + 8);
    if (v17 - *(void *)a1 < 1) {
      goto LABEL_40;
    }
    int v18 = *(unsigned __int8 *)v16;
    uint64_t v11 = v18 != 94;
    if (v18 == 94)
    {
      *(void *)a1 = ++v16;
      if (v17 - (uint64_t)v16 < 1)
      {
        uint64_t v11 = 0;
        uint64_t v33 = *(char **)a1;
        uint64_t v32 = *(char **)(a1 + 8);
        uint64_t v34 = (uint64_t)&v32[-*(void *)a1];
        if (v34 >= 1) {
          goto LABEL_41;
        }
        goto LABEL_199;
      }
      int v18 = *(unsigned __int8 *)v16;
    }
    if (v18 == 93)
    {
      uint64_t v19 = 93;
    }
    else
    {
      if (v18 != 45) {
        goto LABEL_40;
      }
      uint64_t v19 = 45;
    }
    *(void *)a1 = v16 + 1;
    *(unsigned char *)(v10 + v19) |= v12;
    *v14 += v18;
LABEL_40:
    uint64_t v33 = *(char **)a1;
    uint64_t v32 = *(char **)(a1 + 8);
    uint64_t v34 = (uint64_t)&v32[-*(void *)a1];
    if (v34 >= 1)
    {
LABEL_41:
      uint64_t v35 = v7 + 32 * (int)v4 + 24;
      while (1)
      {
        int v36 = *v33;
        if (v36 == 93) {
          goto LABEL_199;
        }
        if ((unint64_t)v34 >= 2 && v36 == 45)
        {
          if (v33[1] == 93)
          {
            *(void *)a1 = v33 + 1;
            *(unsigned char *)(*v9 + 45) |= *v13;
            *v14 += 45;
            uint64_t v33 = *(char **)a1;
            uint64_t v32 = *(char **)(a1 + 8);
            goto LABEL_199;
          }
          goto LABEL_81;
        }
        if (v36 == 45) {
          goto LABEL_81;
        }
        if (v36 != 91 || (unint64_t)v34 <= 1)
        {
LABEL_55:
          int v38 = p_b_symbol(a1);
          int v39 = v38;
          uint64_t v40 = *(const char **)a1;
          uint64_t v41 = *(void *)(a1 + 8);
          if (v41 - *(void *)a1 < 2
            || *v40 != 45
            || (int v42 = v40 + 1, v40[1] == 93)
            || ((*(void *)a1 = v42, v41 - (uint64_t)v42 < 1) || *v42 != 45
              ? (int v38 = p_b_symbol(a1))
              : (*(void *)a1 = v40 + 2, int v38 = 45),
                v39 <= v38))
          {
            do
            {
              *(unsigned char *)(*v9 + v39) |= *v13;
              *v14 += v39++;
            }
            while (v38 + 1 != v39);
            uint64_t v33 = *(char **)a1;
            uint64_t v32 = *(char **)(a1 + 8);
            goto LABEL_44;
          }
LABEL_81:
          if (*(_DWORD *)(a1 + 16)) {
            goto LABEL_43;
          }
          int v51 = 11;
LABEL_42:
          *(_DWORD *)(a1 + 16) = v51;
          goto LABEL_43;
        }
        int v43 = v33[1];
        if (v43 != 61) {
          break;
        }
        uint64_t v52 = v33 + 2;
        *(void *)a1 = v33 + 2;
        if (v32 - (v33 + 2) <= 0)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 7;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          uint64_t v32 = &nuls;
          uint64_t v52 = &nuls;
        }
        int v53 = *(unsigned __int8 *)v52;
        if (v53 == 93 || v53 == 45)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 3;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          uint64_t v32 = &nuls;
          uint64_t v52 = &nuls;
        }
        uint64_t v174 = v35;
        uint64_t v54 = v32 - v52;
        if (v54 < 1)
        {
LABEL_105:
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 7;
          }
          unsigned int v60 = 0;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
LABEL_108:
          uint64_t v35 = v174;
        }
        else
        {
          uint64_t v55 = 0;
          size_t v56 = 0;
          while (v54 - 1 == v56 || v52[v56] != 61 || v52[v56 + 1] != 93)
          {
            *(void *)a1 = &v52[++v56];
            --v55;
            if (v54 + v55 <= 0) {
              goto LABEL_105;
            }
          }
          unsigned int v172 = v11;
          uint64_t v57 = &off_1E4FC0410;
          uint64_t v58 = "NUL";
          do
          {
            if (!strncmp(v58, v52, v56) && strlen(v58) == v56)
            {
              unsigned int v60 = *((unsigned __int8 *)v57 - 8);
LABEL_153:
              uint64_t v11 = v172;
              goto LABEL_108;
            }
            uint64_t v59 = *v57;
            v57 += 2;
            uint64_t v58 = v59;
          }
          while (v59);
          if (v56 == 1)
          {
            unsigned int v60 = *(unsigned __int8 *)v52;
            goto LABEL_153;
          }
          uint64_t v11 = v172;
          uint64_t v35 = v174;
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 3;
          }
          unsigned int v60 = 0;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
        }
        *(unsigned char *)(*v9 + v60) |= *v13;
        *v14 += v60;
        uint64_t v61 = *(char **)a1;
        uint64_t v32 = *(char **)(a1 + 8);
        if ((uint64_t)&v32[-*(void *)a1] < 1)
        {
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 7;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          uint64_t v61 = &nuls;
          uint64_t v32 = &nuls;
        }
        if (v32 - v61 > 1 && *v61 == 61 && v61[1] == 93)
        {
LABEL_177:
          uint64_t v33 = v61 + 2;
          *(void *)a1 = v33;
          goto LABEL_44;
        }
        if (!*(_DWORD *)(a1 + 16))
        {
          int v51 = 3;
          goto LABEL_42;
        }
LABEL_43:
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        uint64_t v33 = &nuls;
        uint64_t v32 = &nuls;
LABEL_44:
        uint64_t v34 = v32 - v33;
        if (v32 - v33 <= 0) {
          goto LABEL_199;
        }
      }
      if (v43 != 58) {
        goto LABEL_55;
      }
      v173 = (void **)v35;
      uint64_t v44 = (uint64_t)(v33 + 2);
      *(void *)a1 = v33 + 2;
      if (v32 - (v33 + 2) <= 0)
      {
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = 7;
        }
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        uint64_t v32 = &nuls;
        uint64_t v44 = (uint64_t)&nuls;
      }
      int v45 = *(unsigned __int8 *)v44;
      if (v45 == 93 || v45 == 45)
      {
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = 4;
        }
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        uint64_t v32 = &nuls;
        uint64_t v44 = (uint64_t)&nuls;
      }
      if ((uint64_t)&v32[-v44] < 1)
      {
        uint64_t v50 = v44;
      }
      else
      {
        uint64_t v46 = v11;
        uint64_t v47 = -v44;
        uint64_t v48 = (const char *)(v44 + 1);
        do
        {
          uint64_t v49 = *((unsigned __int8 *)v48 - 1);
          if (*(v48 - 1) < 0)
          {
            if (!__maskrune(v49, 0x100uLL)) {
              goto LABEL_78;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v49 + 60) & 0x100) == 0)
          {
LABEL_78:
            uint64_t v50 = *(void *)a1;
            goto LABEL_120;
          }
          *(void *)a1 = v48;
          --v47;
          ++v48;
        }
        while (*(void *)(a1 + 8) + v47 > 0);
        uint64_t v50 = -v47;
LABEL_120:
        uint64_t v11 = v46;
      }
      size_t v62 = v50 - v44;
      if (!strncmp("alnum", (const char *)v44, v50 - v44) && !aAlnum[v62])
      {
        uint64_t v63 = cclasses;
      }
      else if (!strncmp("alpha", (const char *)v44, v62) && !aAlpha[v62])
      {
        uint64_t v63 = off_1E4FC02E0;
      }
      else if (!strncmp("blank", (const char *)v44, v62) && !aBlank[v62])
      {
        uint64_t v63 = off_1E4FC02F8;
      }
      else if (!strncmp("cntrl", (const char *)v44, v62) && !aCntrl[v62])
      {
        uint64_t v63 = off_1E4FC0310;
      }
      else if (!strncmp("digit", (const char *)v44, v62) && !aDigit[v62])
      {
        uint64_t v63 = off_1E4FC0328;
      }
      else if (!strncmp("graph", (const char *)v44, v62) && !aGraph[v62])
      {
        uint64_t v63 = off_1E4FC0340;
      }
      else if (!strncmp("lower", (const char *)v44, v62) && !aLower[v62])
      {
        uint64_t v63 = off_1E4FC0358;
      }
      else if (!strncmp("print", (const char *)v44, v62) && !aPrint[v62])
      {
        uint64_t v63 = off_1E4FC0370;
      }
      else if (!strncmp("punct", (const char *)v44, v62) && !aPunct[v62])
      {
        uint64_t v63 = off_1E4FC0388;
      }
      else if (!strncmp("space", (const char *)v44, v62) && !aSpace[v62])
      {
        uint64_t v63 = off_1E4FC03A0;
      }
      else if (!strncmp("upper", (const char *)v44, v62) && !aUpper[v62])
      {
        uint64_t v63 = off_1E4FC03B8;
      }
      else
      {
        if (strncmp("xdigit", (const char *)v44, v62) || aXdigit[v62])
        {
          uint64_t v35 = (uint64_t)v173;
          if (!*(_DWORD *)(a1 + 16)) {
            *(_DWORD *)(a1 + 16) = 4;
          }
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          goto LABEL_170;
        }
        uint64_t v63 = off_1E4FC03D0;
      }
      uint64_t v35 = (uint64_t)v173;
      uint64_t v64 = v63[1];
      unsigned __int8 v65 = *v64;
      if (*v64)
      {
        unint64_t v66 = (unsigned __int8 *)(v64 + 1);
        do
        {
          *(unsigned char *)(*v9 + v65) |= *v13;
          *v14 += v65;
          int v67 = *v66++;
          unsigned __int8 v65 = v67;
        }
        while (v67);
      }
      uint64_t v68 = v63[2];
      if (*v68)
      {
        do
        {
          while (1)
          {
            while (1)
            {
              uint64_t v71 = *v15;
              size_t v72 = *v15 + strlen(v68) + 1;
              *uint64_t v15 = v72;
              uint64_t v73 = (char *)realloc(*v173, v72);
              if (!v73) {
                break;
              }
              *v173 = v73;
              llvm_strlcpy(&v73[v71 - 1], (unint64_t)v68, *v15 - v71 + 1);
              uint64_t v69 = &v68[strlen(v68)];
              int v70 = *((unsigned __int8 *)v69 + 1);
              uint64_t v68 = v69 + 1;
              if (!v70) {
                goto LABEL_170;
              }
            }
            if (*v173) {
              free(*v173);
            }
            *v173 = 0;
            if (!*(_DWORD *)(a1 + 16)) {
              break;
            }
            *(void *)a1 = &nuls;
            *(void *)(a1 + 8) = &nuls;
            uint64_t v74 = &v68[strlen(v68)];
            int v75 = *((unsigned __int8 *)v74 + 1);
            uint64_t v68 = v74 + 1;
            if (!v75) {
              goto LABEL_170;
            }
          }
          *(_DWORD *)(a1 + 16) = 12;
          *(void *)a1 = &nuls;
          *(void *)(a1 + 8) = &nuls;
          unint64_t v76 = &v68[strlen(v68)];
          int v77 = *((unsigned __int8 *)v76 + 1);
          uint64_t v68 = v76 + 1;
        }
        while (v77);
      }
LABEL_170:
      uint64_t v61 = *(char **)a1;
      uint64_t v32 = *(char **)(a1 + 8);
      if ((uint64_t)&v32[-*(void *)a1] < 1)
      {
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = 7;
        }
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        uint64_t v61 = &nuls;
        uint64_t v32 = &nuls;
      }
      if (v32 - v61 > 1 && *v61 == 58 && v61[1] == 93) {
        goto LABEL_177;
      }
      if (!*(_DWORD *)(a1 + 16))
      {
        int v51 = 4;
        goto LABEL_42;
      }
      goto LABEL_43;
    }
LABEL_199:
    if (v32 - v33 >= 1 && (*(void *)a1 = v33 + 1, *v33 == 93))
    {
      if (!*(_DWORD *)(a1 + 16))
      {
        uint64_t v83 = *(void *)(a1 + 56);
        if ((*(unsigned char *)(v83 + 40) & 2) != 0)
        {
          unint64_t v84 = *(unsigned int *)(v83 + 16);
          if ((int)v84 >= 1)
          {
            char v85 = v11;
            uint64_t v86 = MEMORY[0x1E4F14390];
            while (1)
            {
              unint64_t v91 = v84 - 1;
              uint64_t v92 = (v84 - 1);
              if ((*v13 & *(unsigned char *)(*v9 + v92)) == 0) {
                goto LABEL_214;
              }
              if (v84 > 0x80)
              {
                if (!__maskrune(v84 - 1, 0x100uLL)) {
                  goto LABEL_214;
                }
              }
              else if ((*(_DWORD *)(v86 + 4 * v84 + 56) & 0x100) == 0)
              {
                goto LABEL_214;
              }
              if (v91 > 0x7Fu)
              {
                if (__maskrune(v91, 0x8000uLL))
                {
LABEL_224:
                  unsigned __int8 v94 = __tolower(v91);
                  if (v91 == (char)v94) {
                    goto LABEL_214;
                  }
                  goto LABEL_213;
                }
                int v93 = __maskrune(v91, 0x1000uLL);
              }
              else
              {
                if ((*(_DWORD *)(v86 + 4 * v92 + 60) & 0x8000) != 0) {
                  goto LABEL_224;
                }
                int v93 = *(_DWORD *)(v86 + 4 * v92 + 60) & 0x1000;
              }
              if (v93)
              {
                unsigned __int8 v94 = __toupper(v91);
                if (v91 == (char)v94) {
                  goto LABEL_214;
                }
              }
              else
              {
                unsigned __int8 v94 = v91;
                if (v91 == (char)v91) {
                  goto LABEL_214;
                }
              }
LABEL_213:
              *(unsigned char *)(*v9 + v94) |= *v13;
              *v14 += v94;
LABEL_214:
              unint64_t v84 = v91;
              if (v91 + 1 <= 1)
              {
                uint64_t v83 = *(void *)(a1 + 56);
                LOBYTE(v11) = v85;
                break;
              }
            }
          }
        }
        if ((v11 & 1) == 0)
        {
          int v99 = *(_DWORD *)(v83 + 16);
          if (v99 >= 1)
          {
            unsigned int v100 = v99 + 1;
            do
            {
              while (1)
              {
                char v101 = v100 - 2;
                uint64_t v102 = *v9;
                uint64_t v103 = (v100 - 2);
                int v104 = *(unsigned __int8 *)(*v9 + v103);
                int v105 = *v13;
                if ((v105 & v104) != 0) {
                  break;
                }
                *(unsigned char *)(v102 + v103) = v105 | v104;
                *v14 += v101;
                if (--v100 <= 1) {
                  goto LABEL_242;
                }
              }
              *(unsigned char *)(v102 + v103) = v104 & ~(_BYTE)v105;
              *v14 -= v101;
              --v100;
            }
            while (v100 > 1);
LABEL_242:
            uint64_t v83 = *(void *)(a1 + 56);
          }
          if ((*(unsigned char *)(v83 + 40) & 8) != 0)
          {
            *(unsigned char *)(*v9 + 10) &= ~*v13;
            *v14 -= 10;
            uint64_t v83 = *(void *)(a1 + 56);
          }
        }
        int v106 = *(_DWORD *)(v83 + 16);
        uint64_t v107 = v106;
        if (!v106)
        {
          uint64_t v112 = *(int *)(v83 + 20);
          if ((int)v112 >= 1)
          {
            uint64_t v113 = *(uint64_t **)(v83 + 24);
            unint64_t v114 = (unint64_t)&v113[4 * v112];
            while (v113 == v9 || *((unsigned __int8 *)v113 + 9) != *v14)
            {
              v113 += 4;
              if ((unint64_t)v113 >= v114) {
                goto LABEL_295;
              }
            }
            uint64_t v115 = 0;
            goto LABEL_289;
          }
LABEL_295:
          uint64_t v113 = v9;
          goto LABEL_296;
        }
        unint64_t v108 = 0;
        unsigned int v109 = 0;
        uint64_t v110 = *v9;
        unsigned int v111 = *v13;
        if (v107 >= 8 && (unint64_t)(v107 - 257) >= 0xFFFFFFFFFFFFFF00)
        {
          if (v107 < 0x20)
          {
            unsigned int v109 = 0;
            unint64_t v108 = 0;
LABEL_268:
            unint64_t v135 = v108;
            unint64_t v108 = v107 & 0xFFFFFFFFFFFFFFF8;
            int32x4_t v136 = 0uLL;
            int32x4_t v137 = (int32x4_t)v109;
            int8x8_t v138 = vdup_n_s8(v111);
            v139.i64[0] = 0x100000001;
            v139.i64[1] = 0x100000001;
            do
            {
              uint16x8_t v140 = vmovl_u8((uint8x8_t)vtst_s8(*(int8x8_t *)(v110 + (v135 & 0xF8)), v138));
              int32x4_t v136 = vaddq_s32(v136, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v140), v139));
              int32x4_t v137 = vaddq_s32(v137, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v140.i8), v139));
              v135 += 8;
            }
            while (v108 != v135);
            unsigned int v109 = vaddvq_s32(vaddq_s32(v137, v136));
            if (v108 == v107) {
              goto LABEL_274;
            }
            goto LABEL_271;
          }
          uint64_t v117 = 0;
          int8x16_t v118 = vdupq_n_s8(v111);
          int32x4_t v119 = 0uLL;
          v120.i64[0] = 0x100000001;
          v120.i64[1] = 0x100000001;
          unint64_t v108 = v107 & 0xFFFFFFFFFFFFFFE0;
          int32x4_t v121 = 0uLL;
          int32x4_t v122 = 0uLL;
          int32x4_t v123 = 0uLL;
          int32x4_t v124 = 0uLL;
          int32x4_t v125 = 0uLL;
          int32x4_t v126 = 0uLL;
          int32x4_t v127 = 0uLL;
          do
          {
            unint64_t v128 = (int8x16_t *)(v110 + (v117 & 0xE0));
            uint8x16_t v129 = (uint8x16_t)vtstq_s8(*v128, v118);
            uint16x8_t v130 = vmovl_u8(*(uint8x8_t *)v129.i8);
            uint16x8_t v131 = vmovl_high_u8(v129);
            uint8x16_t v132 = (uint8x16_t)vtstq_s8(v128[1], v118);
            uint16x8_t v133 = vmovl_u8(*(uint8x8_t *)v132.i8);
            uint16x8_t v134 = vmovl_high_u8(v132);
            int32x4_t v123 = vaddq_s32(v123, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v131), v120));
            int32x4_t v122 = vaddq_s32(v122, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v131.i8), v120));
            int32x4_t v121 = vaddq_s32(v121, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v130), v120));
            int32x4_t v119 = vaddq_s32(v119, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v130.i8), v120));
            int32x4_t v127 = vaddq_s32(v127, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v134), v120));
            int32x4_t v126 = vaddq_s32(v126, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v134.i8), v120));
            int32x4_t v125 = vaddq_s32(v125, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v133), v120));
            int32x4_t v124 = vaddq_s32(v124, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v133.i8), v120));
            v117 += 32;
          }
          while (v108 != v117);
          unsigned int v109 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v124, v119), vaddq_s32(v126, v122)), vaddq_s32(vaddq_s32(v125, v121), vaddq_s32(v127, v123))));
          if (v108 == v107) {
            goto LABEL_274;
          }
          if ((v107 & 0x18) != 0) {
            goto LABEL_268;
          }
        }
        do
        {
LABEL_271:
          if ((*(unsigned char *)(v110 + v108) & v111) != 0) {
            ++v109;
          }
          ++v108;
        }
        while (v107 != v108);
LABEL_274:
        if (v109 == 1)
        {
          int v141 = 0;
          uint64_t v142 = 0;
          while ((*(unsigned char *)(v110 + v142) & v111) == 0)
          {
            ++v142;
            v141 += 0x1000000;
            if (v107 == v142)
            {
              int v143 = 0;
              goto LABEL_306;
            }
          }
          int v143 = v141 >> 24;
LABEL_306:
          uint64_t v151 = *(void *)(v83 + 88);
          if ((*(unsigned char *)(v83 + 40) & 2) == 0) {
            goto LABEL_323;
          }
          if (v143 > 0x7Fu)
          {
            if (!__maskrune(v143, 0x100uLL)) {
              goto LABEL_323;
            }
            if (!__maskrune(v143, 0x8000uLL))
            {
              int v153 = __maskrune(v143, 0x1000uLL);
LABEL_320:
              char v154 = v143;
              if (v153) {
                char v154 = __toupper(v143);
              }
LABEL_322:
              if (v143 != v154)
              {
                bothcases((__n128 *)a1, v143);
                uint64_t v164 = *(void *)(a1 + 56);
                uint64_t v160 = *(int *)(v164 + 16);
                uint64_t v89 = *(void *)(v164 + 24) + 32 * *(int *)(v164 + 20);
                if (!v160)
                {
LABEL_211:
                  if ((uint64_t *)(v89 - 32) == v9) {
                    --*(_DWORD *)(*(void *)(a1 + 56) + 20);
                  }
                  return;
                }
LABEL_341:
                for (uint64_t i = 0; i != v160; ++i)
                {
                  *(unsigned char *)(*v9 + i) &= ~*v13;
                  *v14 -= i;
                }
                goto LABEL_211;
              }
LABEL_323:
              if (*(_DWORD *)(a1 + 16))
              {
                uint64_t v158 = v143;
                if (*(unsigned char *)(v151 + v143)) {
                  goto LABEL_325;
                }
                goto LABEL_340;
              }
              uint64_t v161 = *(void *)(a1 + 32);
              if (*(void *)(a1 + 40) >= v161)
              {
                uint64_t v162 = v161 >= -1 ? v161 + 1 : v161 + 2;
                unint64_t v163 = (v162 & 0xFFFFFFFFFFFFFFFELL) + (v162 >> 1);
                if (v161 < (uint64_t)v163)
                {
                  if (v163 >> 61)
                  {
LABEL_333:
                    *(_DWORD *)(a1 + 16) = 12;
LABEL_334:
                    *(void *)a1 = &nuls;
                    *(void *)(a1 + 8) = &nuls;
                    goto LABEL_339;
                  }
                  v165 = realloc(*(void **)(a1 + 24), 24 * (v162 >> 1));
                  if (!v165)
                  {
                    if (*(_DWORD *)(a1 + 16)) {
                      goto LABEL_334;
                    }
                    goto LABEL_333;
                  }
                  *(void *)(a1 + 24) = v165;
                  *(void *)(a1 + 32) = v163;
                }
              }
LABEL_339:
              uint64_t v166 = *(void *)(a1 + 24);
              uint64_t v167 = *(void *)(a1 + 40);
              *(void *)(a1 + 40) = v167 + 1;
              *(void *)(v166 + 8 * v167) = v143 | 0x10000000u;
              uint64_t v158 = v143;
              if (*(unsigned char *)(v151 + v143))
              {
LABEL_325:
                uint64_t v159 = *(void *)(a1 + 56);
                uint64_t v160 = *(int *)(v159 + 16);
                uint64_t v89 = *(void *)(v159 + 24) + 32 * *(int *)(v159 + 20);
                if (!v160) {
                  goto LABEL_211;
                }
                goto LABEL_341;
              }
LABEL_340:
              uint64_t v168 = *(void *)(a1 + 56);
              int v169 = *(_DWORD *)(v168 + 84);
              *(_DWORD *)(v168 + 84) = v169 + 1;
              *(unsigned char *)(v151 + v158) = v169;
              uint64_t v170 = *(void *)(a1 + 56);
              uint64_t v160 = *(int *)(v170 + 16);
              uint64_t v89 = *(void *)(v170 + 24) + 32 * *(int *)(v170 + 20);
              if (!v160) {
                goto LABEL_211;
              }
              goto LABEL_341;
            }
          }
          else
          {
            int v152 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v143 + 60);
            if ((v152 & 0x100) == 0) {
              goto LABEL_323;
            }
            if ((v152 & 0x8000) == 0)
            {
              int v153 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v143 + 60) & 0x1000;
              goto LABEL_320;
            }
          }
          char v154 = __tolower(v143);
          goto LABEL_322;
        }
        uint64_t v144 = *(unsigned int *)(v83 + 20);
        if ((int)v144 >= 1)
        {
          uint64_t v113 = *(uint64_t **)(v83 + 24);
          unint64_t v114 = (unint64_t)&v113[4 * v144];
          while (v113 == v9 || *((unsigned __int8 *)v113 + 9) != *v14)
          {
LABEL_282:
            v113 += 4;
            if ((unint64_t)v113 >= v114) {
              goto LABEL_295;
            }
          }
          uint64_t v145 = 0;
          while (((*(unsigned char *)(*v113 + v145) & v113[1]) == 0) != ((*(unsigned char *)(*v9 + v145) & *v13) != 0))
          {
            if (v107 == ++v145) {
              goto LABEL_288;
            }
          }
          if (v107 != v145) {
            goto LABEL_282;
          }
LABEL_288:
          uint64_t v115 = v107;
LABEL_289:
          if (v107)
          {
            uint64_t v146 = 0;
            do
            {
              *(unsigned char *)(*v9 + v146) &= ~*v13;
              *v14 -= v146++;
            }
            while (v115 != v146);
            uint64_t v83 = *(void *)(a1 + 56);
          }
          if ((uint64_t *)(v114 - 32) == v9) {
            --*(_DWORD *)(v83 + 20);
          }
LABEL_296:
          if (*(_DWORD *)(a1 + 16)) {
            return;
          }
          uint64_t v147 = (int)(((uint64_t)v113 - *(void *)(v83 + 24)) >> 5);
          uint64_t v148 = *(void *)(a1 + 32);
          if (*(void *)(a1 + 40) >= v148)
          {
            uint64_t v149 = v148 >= -1 ? v148 + 1 : v148 + 2;
            unint64_t v150 = (v149 & 0xFFFFFFFFFFFFFFFELL) + (v149 >> 1);
            if (v148 < (uint64_t)v150)
            {
              if (v150 >> 61) {
                goto LABEL_303;
              }
              uint64_t v155 = realloc(*(void **)(a1 + 24), 24 * (v149 >> 1));
              if (v155)
              {
                *(void *)(a1 + 24) = v155;
                *(void *)(a1 + 32) = v150;
                goto LABEL_318;
              }
              if (!*(_DWORD *)(a1 + 16)) {
LABEL_303:
              }
                *(_DWORD *)(a1 + 16) = 12;
              *(void *)a1 = &nuls;
              *(void *)(a1 + 8) = &nuls;
            }
          }
LABEL_318:
          uint64_t v156 = *(void *)(a1 + 24);
          uint64_t v157 = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v157 + 1;
          *(void *)(v156 + 8 * v157) = v147 | 0x30000000;
          return;
        }
        goto LABEL_295;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 16)) {
        *(_DWORD *)(a1 + 16) = 7;
      }
      *(void *)a1 = &nuls;
      *(void *)(a1 + 8) = &nuls;
    }
    uint64_t v87 = *(void *)(a1 + 56);
    uint64_t v88 = *(int *)(v87 + 16);
    uint64_t v89 = *(void *)(v87 + 24) + 32 * *(int *)(v87 + 20);
    if (v88)
    {
      for (uint64_t j = 0; j != v88; ++j)
      {
        *(unsigned char *)(*v9 + j) &= ~*v13;
        *v14 -= j;
      }
    }
    goto LABEL_211;
  }
LABEL_195:
  free(*(void **)(v3 + 24));
  uint64_t v82 = *(void *)(a1 + 56);
  *(void *)(v82 + 24) = 0;
  free(*(void **)(v82 + 32));
  *(void *)(*(void *)(a1 + 56) + 32) = 0;
  if (!*(_DWORD *)(a1 + 16)) {
    *(_DWORD *)(a1 + 16) = 12;
  }
  *(void *)a1 = &nuls;
  *(void *)(a1 + 8) = &nuls;
}

void ordinary(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(v4 + 88);
  __darwin_ct_rune_t v6 = a2;
  if ((*(unsigned char *)(v4 + 40) & 2) == 0) {
    goto LABEL_13;
  }
  if (a2 > 0x7Fu)
  {
    if (!__maskrune(a2, 0x100uLL)) {
      goto LABEL_13;
    }
    if (!__maskrune(v6, 0x8000uLL))
    {
      int v9 = __maskrune(v6, 0x1000uLL);
      char v8 = a2;
      if (!v9) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
LABEL_9:
    char v8 = __tolower(v6);
    goto LABEL_12;
  }
  int v7 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * a2 + 60);
  if ((v7 & 0x100) == 0) {
    goto LABEL_13;
  }
  if ((v7 & 0x8000) != 0) {
    goto LABEL_9;
  }
  char v8 = a2;
  if ((v7 & 0x1000) != 0) {
LABEL_11:
  }
    char v8 = __toupper(v6);
LABEL_12:
  if (a2 != v8)
  {
    char v20 = a2;
    __int16 v21 = 93;
    long long v19 = *(_OWORD *)a1;
    *(void *)a1 = &v20;
    *(void *)(a1 + 8) = (char *)&v21 + 1;
    p_bracket(a1);
    *(_OWORD *)a1 = v19;
    return;
  }
LABEL_13:
  if (*(_DWORD *)(a1 + 16))
  {
    uint64_t v10 = a2;
    if (*(unsigned char *)(v5 + a2)) {
      return;
    }
LABEL_28:
    uint64_t v17 = *(void *)(a1 + 56);
    int v18 = *(_DWORD *)(v17 + 84);
    *(_DWORD *)(v17 + 84) = v18 + 1;
    *(unsigned char *)(v5 + v10) = v18;
    return;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40) >= v11)
  {
    uint64_t v12 = v11 >= -1 ? v11 + 1 : v11 + 2;
    unint64_t v13 = (v12 & 0xFFFFFFFFFFFFFFFELL) + (v12 >> 1);
    if (v11 < (uint64_t)v13)
    {
      if (v13 >> 61)
      {
LABEL_22:
        *(_DWORD *)(a1 + 16) = 12;
LABEL_23:
        *(void *)a1 = &nuls;
        *(void *)(a1 + 8) = &nuls;
        goto LABEL_27;
      }
      uint64_t v14 = realloc(*(void **)(a1 + 24), 24 * (v12 >> 1));
      if (!v14)
      {
        if (*(_DWORD *)(a1 + 16)) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      *(void *)(a1 + 24) = v14;
      *(void *)(a1 + 32) = v13;
    }
  }
LABEL_27:
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v16 + 1;
  *(void *)(v15 + 8 * v16) = v6 | 0x10000000u;
  uint64_t v10 = a2;
  if (!*(unsigned char *)(v5 + a2)) {
    goto LABEL_28;
  }
}

uint64_t *repeat(uint64_t *result, uint64_t a2, int a3, uint64_t a4)
{
  if (*((_DWORD *)result + 4)) {
    return result;
  }
  int v7 = result;
  uint64_t v8 = result[5];
  while (2)
  {
    if (a4 == 256) {
      int v9 = 3;
    }
    else {
      int v9 = 2;
    }
    if ((int)a4 >= 2) {
      int v10 = v9;
    }
    else {
      int v10 = a4;
    }
    uint64_t v11 = v8;
    uint64_t v12 = a2;
    while (1)
    {
      uint64_t v13 = v11;
      if (a3 == 256) {
        int v14 = 3;
      }
      else {
        int v14 = 2;
      }
      if (a3 < 2) {
        int v14 = a3;
      }
      int v15 = v10 + 8 * v14;
      if (v15 != 19) {
        break;
      }
      uint64_t v16 = v13 - v12;
      if (v13 == v12)
      {
        uint64_t v11 = v13;
        --a3;
        uint64_t v12 = v13;
      }
      else
      {
        if (v16 >= 1)
        {
          unint64_t v17 = v7[4] + v16;
          if (v17 >> 61) {
            goto LABEL_21;
          }
          int v18 = realloc((void *)v7[3], 8 * v17);
          if (v18)
          {
            v7[3] = (uint64_t)v18;
            v7[4] = v17;
            goto LABEL_25;
          }
          if (!*((_DWORD *)v7 + 4)) {
LABEL_21:
          }
            *((_DWORD *)v7 + 4) = 12;
          *int v7 = (uint64_t)&nuls;
          v7[1] = (uint64_t)&nuls;
        }
LABEL_25:
        BOOL result = (uint64_t *)memmove((void *)(v7[3] + 8 * v7[5]), (const void *)(v7[3] + 8 * v12), 8 * v16);
        uint64_t v8 = v7[5] + v16;
        v7[5] = v8;
        uint64_t v11 = v8;
        --a3;
        uint64_t v12 = v13;
        if (*((_DWORD *)v7 + 4)) {
          return result;
        }
      }
    }
    switch(v15)
    {
      case 0:
        v7[5] = v12;
        return result;
      case 1:
      case 2:
      case 3:
        doinsert(v7, 2013265920, v13 - v12 + 1, v12);
        BOOL result = (uint64_t *)repeat(v7, v12 + 1, 1, a4);
        if (*((_DWORD *)v7 + 4)) {
          return result;
        }
        uint64_t v43 = v7[4];
        uint64_t v42 = v7[5];
        uint64_t v44 = v42 - v12;
        if (v42 < v43
          || (v43 >= -1 ? (uint64_t v45 = v43 + 1) : (uint64_t v45 = v43 + 2),
              unint64_t v46 = (v45 & 0xFFFFFFFFFFFFFFFELL) + (v45 >> 1),
              v43 >= (uint64_t)v46))
        {
          int v47 = 0;
        }
        else
        {
          if (v46 >> 61)
          {
LABEL_105:
            int v47 = 12;
            *((_DWORD *)v7 + 4) = 12;
LABEL_106:
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
            goto LABEL_119;
          }
          uint64_t v61 = realloc((void *)v7[3], 24 * (v45 >> 1));
          if (!v61)
          {
            int v47 = *((_DWORD *)v7 + 4);
            if (v47) {
              goto LABEL_106;
            }
            goto LABEL_105;
          }
          v7[3] = (uint64_t)v61;
          v7[4] = v46;
          int v47 = *((_DWORD *)v7 + 4);
        }
LABEL_119:
        BOOL result = (uint64_t *)v7[3];
        uint64_t v53 = v7[5];
        v7[5] = v53 + 1;
        result[v53] = v44 | 0x80000000;
        if (v47) {
          return result;
        }
        result[v12] = result[v12] & 0xF8000000 | (v7[5] - v12);
        uint64_t v54 = v7[4];
        if (v7[5] < v54
          || (v54 >= -1 ? (uint64_t v55 = v54 + 1) : (uint64_t v55 = v54 + 2),
              unint64_t v56 = (v55 & 0xFFFFFFFFFFFFFFFELL) + (v55 >> 1),
              v54 >= (uint64_t)v56))
        {
          uint64_t v57 = v7[5];
          v7[5] = v57 + 1;
          result[v57] = 2281701376;
        }
        else
        {
          if (v56 >> 61)
          {
            *((_DWORD *)v7 + 4) = 12;
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
LABEL_150:
            uint64_t v66 = v7[5];
            v7[5] = v66 + 1;
            uint64_t v67 = 2281701376;
LABEL_157:
            result[v66] = v67;
            return result;
          }
          BOOL result = (uint64_t *)realloc(result, 24 * (v55 >> 1));
          if (!result)
          {
            if (!*((_DWORD *)v7 + 4)) {
              *((_DWORD *)v7 + 4) = 12;
            }
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
            BOOL result = (uint64_t *)v7[3];
            goto LABEL_150;
          }
          v7[3] = (uint64_t)result;
          v7[4] = v56;
          int v62 = *((_DWORD *)v7 + 4);
          uint64_t v63 = v7[5];
          v7[5] = v63 + 1;
          result[v63] = 2281701376;
          if (v62) {
            return result;
          }
        }
        result[v7[5] - 1] = result[v7[5] - 1] & 0xF8000000 | 1;
        uint64_t v58 = v7[4];
        if (v7[5] >= v58)
        {
          uint64_t v59 = v58 >= -1 ? v58 + 1 : v58 + 2;
          unint64_t v60 = (v59 & 0xFFFFFFFFFFFFFFFELL) + (v59 >> 1);
          if (v58 < (uint64_t)v60)
          {
            if (v60 >> 61)
            {
              *((_DWORD *)v7 + 4) = 12;
              *int v7 = (uint64_t)&nuls;
              v7[1] = (uint64_t)&nuls;
            }
            else
            {
              BOOL result = (uint64_t *)realloc(result, 24 * (v59 >> 1));
              if (result)
              {
                v7[3] = (uint64_t)result;
                v7[4] = v60;
              }
              else
              {
                if (!*((_DWORD *)v7 + 4)) {
                  *((_DWORD *)v7 + 4) = 12;
                }
                *int v7 = (uint64_t)&nuls;
                v7[1] = (uint64_t)&nuls;
                BOOL result = (uint64_t *)v7[3];
              }
            }
          }
        }
        uint64_t v66 = v7[5];
        v7[5] = v66 + 1;
        uint64_t v67 = 2415919106;
        goto LABEL_157;
      case 9:
        return result;
      case 10:
        uint64_t v19 = v13 - v12;
        BOOL result = (uint64_t *)doinsert(v7, 2013265920, v13 - v12 + 1, v12);
        a2 = v7[5];
        if (*((_DWORD *)v7 + 4)) {
          goto LABEL_86;
        }
        uint64_t v20 = v7[4];
        if (a2 < v20
          || (v20 >= -1 ? (uint64_t v21 = v20 + 1) : (uint64_t v21 = v20 + 2),
              unint64_t v22 = (v21 & 0xFFFFFFFFFFFFFFFELL) + (v21 >> 1),
              v20 >= (uint64_t)v22))
        {
          int v23 = 0;
        }
        else
        {
          if (v22 >> 61)
          {
LABEL_37:
            int v23 = 12;
            *((_DWORD *)v7 + 4) = 12;
LABEL_38:
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
            goto LABEL_45;
          }
          uint64_t v35 = realloc((void *)v7[3], 24 * (v21 >> 1));
          if (!v35)
          {
            int v23 = *((_DWORD *)v7 + 4);
            if (v23) {
              goto LABEL_38;
            }
            goto LABEL_37;
          }
          v7[3] = (uint64_t)v35;
          v7[4] = v22;
          int v23 = *((_DWORD *)v7 + 4);
        }
LABEL_45:
        BOOL result = (uint64_t *)v7[3];
        uint64_t v26 = v7[5];
        v7[5] = v26 + 1;
        result[v26] = (a2 - v12) | 0x80000000;
        a2 = v7[5];
        if (v23) {
          goto LABEL_86;
        }
        result[v12] = result[v12] & 0xF8000000 | (a2 - v12);
        uint64_t v27 = v7[4];
        if (v7[5] < v27
          || (v27 >= -1 ? (uint64_t v28 = v27 + 1) : (uint64_t v28 = v27 + 2),
              unint64_t v29 = (v28 & 0xFFFFFFFFFFFFFFFELL) + (v28 >> 1),
              v27 >= (uint64_t)v29))
        {
          uint64_t v31 = v7[5];
          v7[5] = v31 + 1;
          result[v31] = 2281701376;
          a2 = v7[5];
        }
        else
        {
          if (v29 >> 61)
          {
            *((_DWORD *)v7 + 4) = 12;
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
LABEL_80:
            uint64_t v38 = v7[5];
            v7[5] = v38 + 1;
            uint64_t v39 = 2281701376;
            goto LABEL_85;
          }
          BOOL result = (uint64_t *)realloc(result, 24 * (v28 >> 1));
          if (!result)
          {
            if (!*((_DWORD *)v7 + 4)) {
              *((_DWORD *)v7 + 4) = 12;
            }
            *int v7 = (uint64_t)&nuls;
            v7[1] = (uint64_t)&nuls;
            BOOL result = (uint64_t *)v7[3];
            goto LABEL_80;
          }
          v7[3] = (uint64_t)result;
          v7[4] = v29;
          int v36 = *((_DWORD *)v7 + 4);
          uint64_t v37 = v7[5];
          a2 = v37 + 1;
          v7[5] = v37 + 1;
          result[v37] = 2281701376;
          if (v36) {
            goto LABEL_86;
          }
        }
        result[a2 - 1] = result[a2 - 1] & 0xF8000000 | 1;
        uint64_t v32 = v7[4];
        if (v7[5] >= v32)
        {
          uint64_t v33 = v32 >= -1 ? v32 + 1 : v32 + 2;
          unint64_t v34 = (v33 & 0xFFFFFFFFFFFFFFFELL) + (v33 >> 1);
          if (v32 < (uint64_t)v34)
          {
            if (v34 >> 61)
            {
              *((_DWORD *)v7 + 4) = 12;
              *int v7 = (uint64_t)&nuls;
              v7[1] = (uint64_t)&nuls;
            }
            else
            {
              BOOL result = (uint64_t *)realloc(result, 24 * (v33 >> 1));
              if (result)
              {
                v7[3] = (uint64_t)result;
                v7[4] = v34;
              }
              else
              {
                if (!*((_DWORD *)v7 + 4)) {
                  *((_DWORD *)v7 + 4) = 12;
                }
                *int v7 = (uint64_t)&nuls;
                v7[1] = (uint64_t)&nuls;
                BOOL result = (uint64_t *)v7[3];
              }
            }
          }
        }
        uint64_t v38 = v7[5];
        v7[5] = v38 + 1;
        uint64_t v39 = 2415919106;
LABEL_85:
        result[v38] = v39;
        a2 = v7[5];
LABEL_86:
        if (v13 == v12)
        {
          a3 = 1;
          uint64_t v8 = a2;
          a4 = (a4 - 1);
          if (!*((_DWORD *)v7 + 4)) {
            continue;
          }
        }
        else
        {
          if (v19 >= 1)
          {
            unint64_t v40 = v7[4] + v19;
            if (v40 >> 61 || (uint64_t v41 = realloc((void *)v7[3], 8 * v40)) == 0)
            {
              if (!*((_DWORD *)v7 + 4)) {
                *((_DWORD *)v7 + 4) = 12;
              }
              *int v7 = (uint64_t)&nuls;
              v7[1] = (uint64_t)&nuls;
            }
            else
            {
              v7[3] = (uint64_t)v41;
              v7[4] = v40;
            }
          }
          BOOL result = (uint64_t *)memmove((void *)(v7[3] + 8 * v7[5]), (const void *)(v7[3] + 8 * (v12 + 1)), 8 * v19);
          uint64_t v8 = v7[5] + v19;
          v7[5] = v8;
          a3 = 1;
          a4 = (a4 - 1);
          if (!*((_DWORD *)v7 + 4)) {
            continue;
          }
        }
        return result;
      case 11:
        BOOL result = (uint64_t *)doinsert(v7, 1207959552, v13 - v12 + 1, v12);
        if (*((_DWORD *)v7 + 4)) {
          return result;
        }
        uint64_t v49 = v7[4];
        uint64_t v48 = v7[5];
        uint64_t v50 = v48 - v12;
        if (v48 < v49) {
          goto LABEL_144;
        }
        uint64_t v51 = v49 >= -1 ? v49 + 1 : v49 + 2;
        unint64_t v52 = (v51 & 0xFFFFFFFFFFFFFFFELL) + (v51 >> 1);
        if (v49 >= (uint64_t)v52) {
          goto LABEL_144;
        }
        if (v52 >> 61) {
          goto LABEL_115;
        }
        BOOL result = (uint64_t *)realloc((void *)v7[3], 24 * (v51 >> 1));
        if (result)
        {
          v7[3] = (uint64_t)result;
          v7[4] = v52;
        }
        else
        {
          if (!*((_DWORD *)v7 + 4)) {
LABEL_115:
          }
            *((_DWORD *)v7 + 4) = 12;
          *int v7 = (uint64_t)&nuls;
          v7[1] = (uint64_t)&nuls;
        }
LABEL_144:
        uint64_t v64 = v7[3];
        uint64_t v65 = v7[5];
        v7[5] = v65 + 1;
        *(void *)(v64 + 8 * v65) = v50 | 0x50000000;
        return result;
      case 18:
        uint64_t v24 = v13 - v12;
        if (v13 == v12) {
          goto LABEL_56;
        }
        if (v24 < 1) {
          goto LABEL_55;
        }
        unint64_t v25 = v7[4] + v24;
        if (v25 >> 61) {
          goto LABEL_42;
        }
        uint64_t v30 = realloc((void *)v7[3], 8 * v25);
        if (v30)
        {
          v7[3] = (uint64_t)v30;
          v7[4] = v25;
        }
        else
        {
          if (!*((_DWORD *)v7 + 4)) {
LABEL_42:
          }
            *((_DWORD *)v7 + 4) = 12;
          *int v7 = (uint64_t)&nuls;
          v7[1] = (uint64_t)&nuls;
        }
LABEL_55:
        BOOL result = (uint64_t *)memmove((void *)(v7[3] + 8 * v7[5]), (const void *)(v7[3] + 8 * v12), 8 * v24);
        uint64_t v8 = v7[5] + v24;
        v7[5] = v8;
LABEL_56:
        --a3;
        a2 = v13;
        a4 = (a4 - 1);
        if (!*((_DWORD *)v7 + 4)) {
          continue;
        }
        return result;
      default:
        *((_DWORD *)v7 + 4) = 15;
        *int v7 = (uint64_t)&nuls;
        v7[1] = (uint64_t)&nuls;
        return result;
    }
  }
}

uint64_t p_b_symbol(uint64_t a1)
{
  uint64_t v2 = *(char **)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3 - *(void *)a1 < 1)
  {
    if (!*(_DWORD *)(a1 + 16)) {
      *(_DWORD *)(a1 + 16) = 7;
    }
    uint64_t v2 = &nuls;
    *(void *)a1 = &nuls;
    *(void *)(a1 + 8) = &nuls;
    goto LABEL_16;
  }
  uint64_t v4 = v3 - (void)v2;
  if (v3 - (uint64_t)v2 <= 1 || *v2 != 91 || v2[1] != 46)
  {
LABEL_16:
    *(void *)a1 = v2 + 1;
    return *v2;
  }
  uint64_t v5 = v2 + 2;
  *(void *)a1 = v2 + 2;
  if (v3 - (uint64_t)(v2 + 2) < 1)
  {
LABEL_23:
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_26;
    }
    int v15 = 7;
  }
  else
  {
    size_t v6 = 0;
    uint64_t v7 = -2;
    while (1)
    {
      uint64_t v8 = &v2[v6];
      if (v4 - 3 != v6 && v8[2] == 46 && v2[v6 + 3] == 93) {
        break;
      }
      *(void *)a1 = v8 + 3;
      ++v6;
      --v7;
      if (v4 + v7 <= 0) {
        goto LABEL_23;
      }
    }
    int v9 = &v2[v6 + 2];
    int v10 = "NUL";
    uint64_t v11 = &off_1E4FC0410;
    do
    {
      if (!strncmp(v10, v5, v6) && strlen(v10) == v6)
      {
        char v12 = *((unsigned char *)v11 - 8);
        if (v3 - (uint64_t)v9 <= 1) {
          goto LABEL_32;
        }
LABEL_27:
        if (*v9 == 46 && v9[1] == 93)
        {
          *(void *)a1 = v9 + 2;
          return v12;
        }
        goto LABEL_32;
      }
      int v14 = *v11;
      v11 += 2;
      int v10 = v14;
    }
    while (v14);
    if (v6 == 1)
    {
      char v12 = *v5;
      if (v3 - (uint64_t)v9 <= 1) {
        goto LABEL_32;
      }
      goto LABEL_27;
    }
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_26;
    }
    int v15 = 3;
  }
  *(_DWORD *)(a1 + 16) = v15;
LABEL_26:
  char v12 = 0;
  *(void *)a1 = &nuls;
  *(void *)(a1 + 8) = &nuls;
LABEL_32:
  if (!*(_DWORD *)(a1 + 16)) {
    *(_DWORD *)(a1 + 16) = 3;
  }
  *(void *)a1 = &nuls;
  *(void *)(a1 + 8) = &nuls;
  return v12;
}

__n128 bothcases(__n128 *a1, char a2)
{
  char v5 = a2;
  __int16 v6 = 93;
  __n128 v4 = *a1;
  a1->n128_u64[0] = (unint64_t)&v5;
  a1->n128_u64[1] = (unint64_t)&v6 + 1;
  p_bracket();
  __n128 result = v4;
  *a1 = v4;
  return result;
}

size_t llvm_regerror(int a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 == 255)
  {
    __int16 v6 = *(const char **)(a2 + 16);
    if (!strcmp("REG_NOMATCH", v6))
    {
      uint64_t v12 = 1;
    }
    else if (!strcmp("REG_BADPAT", v6))
    {
      uint64_t v12 = 2;
    }
    else if (!strcmp("REG_ECOLLATE", v6))
    {
      uint64_t v12 = 3;
    }
    else if (!strcmp("REG_ECTYPE", v6))
    {
      uint64_t v12 = 4;
    }
    else if (!strcmp("REG_EESCAPE", v6))
    {
      uint64_t v12 = 5;
    }
    else if (!strcmp("REG_ESUBREG", v6))
    {
      uint64_t v12 = 6;
    }
    else if (!strcmp("REG_EBRACK", v6))
    {
      uint64_t v12 = 7;
    }
    else if (!strcmp("REG_EPAREN", v6))
    {
      uint64_t v12 = 8;
    }
    else if (!strcmp("REG_EBRACE", v6))
    {
      uint64_t v12 = 9;
    }
    else if (!strcmp("REG_BADBR", v6))
    {
      uint64_t v12 = 10;
    }
    else if (!strcmp("REG_ERANGE", v6))
    {
      uint64_t v12 = 11;
    }
    else if (!strcmp("REG_ESPACE", v6))
    {
      uint64_t v12 = 12;
    }
    else if (!strcmp("REG_BADRPT", v6))
    {
      uint64_t v12 = 13;
    }
    else if (!strcmp("REG_EMPTY", v6))
    {
      uint64_t v12 = 14;
    }
    else if (!strcmp("REG_ASSERT", v6))
    {
      uint64_t v12 = 15;
    }
    else
    {
      if (strcmp("REG_INVARG", v6))
      {
        uint64_t v7 = "0";
        goto LABEL_48;
      }
      uint64_t v12 = 16;
    }
    uint64_t v16 = v12;
    uint64_t v13 = "%d";
  }
  else
  {
    uint64_t v8 = &rerrs;
    do
    {
      int v10 = *v8;
      v8 += 6;
      int v9 = v10;
      if (v10) {
        BOOL v11 = v9 == (a1 & 0xFFFFFEFF);
      }
      else {
        BOOL v11 = 1;
      }
    }
    while (!v11);
    if ((a1 & 0x100) == 0)
    {
      uint64_t v7 = (char *)*((void *)v8 - 1);
      goto LABEL_48;
    }
    if (v9)
    {
      uint64_t v7 = __str;
      llvm_strlcpy(__str, *((void *)v8 - 2), 50);
      goto LABEL_48;
    }
    uint64_t v16 = a1 & 0xFFFFFEFF;
    uint64_t v13 = "REG_0x%x";
  }
  uint64_t v7 = __str;
  snprintf(__str, 0x32uLL, v13, v16);
LABEL_48:
  size_t v14 = strlen(v7);
  if (a4) {
    llvm_strlcpy(a3, (unint64_t)v7, a4);
  }
  return v14 + 1;
}

uint64_t llvm_regexec(uint64_t a1, char *__s, unint64_t a3, void *a4, char a5)
{
  if (*(_DWORD *)a1 != 62053) {
    return 2;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (*(_DWORD *)v5 != 53829 || (*(unsigned char *)(v5 + 72) & 4) != 0) {
    return 2;
  }
  int v8 = a5 & 7;
  int64_t v9 = *(void *)(v5 + 48);
  if (v9 > 64)
  {
    uint64_t v19 = *(void *)(v5 + 56);
    uint64_t v18 = *(void *)(v5 + 64);
    if ((*(unsigned char *)(v5 + 40) & 4) != 0) {
      unint64_t v20 = 0;
    }
    else {
      unint64_t v20 = a3;
    }
    if ((a5 & 4) != 0)
    {
      size_t v21 = a4[1];
      unint64_t v22 = &__s[*a4];
      int v23 = &__s[v21];
      if (&__s[v21] < v22) {
        return 16;
      }
    }
    else
    {
      size_t v21 = strlen(__s);
      unint64_t v22 = __s;
      int v23 = &__s[v21];
      if (&__s[v21] < __s) {
        return 16;
      }
    }
    long long v121 = 0u;
    long long v122 = 0u;
    long long v120 = 0u;
    uint64_t v31 = *(unsigned __int8 **)(v5 + 96);
    int8x16_t v118 = v23;
    unint64_t v108 = a4;
    if (v31)
    {
      uint64_t v32 = v22;
      if (v22 < v23)
      {
        uint64_t v105 = v19;
        int __dsta = v8;
        unint64_t v112 = v20;
        uint64_t v33 = v5;
        int v34 = *v31;
        uint64_t v35 = (char *)(__s - v22 + v21);
        uint64_t v102 = &__s[v21];
        int v36 = (char *)(&__s[v21] - v22);
        uint64_t v32 = v22;
        do
        {
          if (*v32 == v34)
          {
            int64_t v37 = *(int *)(v33 + 104);
            if ((uint64_t)v36 >= v37 && !memcmp(v32, v31, v37)) {
              goto LABEL_150;
            }
          }
          ++v32;
          --v36;
          --v35;
        }
        while (v35);
        uint64_t v32 = v102;
LABEL_150:
        uint64_t v5 = v33;
        unint64_t v20 = v112;
        int v23 = v118;
        int v8 = __dsta;
        uint64_t v19 = v105;
      }
      if (v32 == v23) {
        return 1;
      }
    }
    uint64_t v119 = v5;
    LODWORD(v120) = v8;
    *(void *)&long long v121 = __s;
    *((void *)&v121 + 1) = v22;
    *(void *)&long long v123 = 0;
    *(void *)&long long v122 = v23;
    int v70 = (char *)malloc(4 * v9);
    v124[0] = v70;
    if (!v70) {
      return 12;
    }
    uint64_t v71 = v19 + 1;
    *(void *)&long long v125 = &v70[v9];
    *((void *)&v125 + 1) = &v70[2 * v9];
    v124[1] = v70;
    *((void *)&v123 + 1) = 4;
    int32x4_t v126 = &v70[3 * v9];
    bzero(v126, v9);
    uint64_t v110 = v5;
    unint64_t v114 = v20;
LABEL_155:
    if (*((char **)&v121 + 1) == v22) {
      int v72 = 128;
    }
    else {
      int v72 = *(v22 - 1);
    }
    long long v73 = v125;
    uint64_t v74 = v124[1];
    bzero(v124[1], *(void *)(v119 + 48));
    v74[v71] = 1;
    lstep(v119, v71, v18, (uint64_t)v74, 132, (uint64_t)v74);
    memmove((void *)v73, v74, *(void *)(v119 + 48));
    int v75 = 0;
    if (v22 != (char *)v122)
    {
LABEL_159:
      int v76 = *v22;
      goto LABEL_161;
    }
    while (1)
    {
      int v76 = 128;
LABEL_161:
      uint64_t v77 = v119;
      if (!memcmp(v74, (const void *)v73, *(void *)(v119 + 48))) {
        int v75 = v22;
      }
      if (v72 == 128)
      {
        if (v120) {
          goto LABEL_166;
        }
      }
      else if (v72 != 10 || (*(unsigned char *)(v77 + 40) & 8) == 0)
      {
LABEL_166:
        int v78 = 0;
        int v79 = 0;
        int v80 = 130;
        if (v76 == 128) {
          goto LABEL_173;
        }
        goto LABEL_167;
      }
      int v79 = *(_DWORD *)(v77 + 76);
      int v78 = 129;
      int v80 = 131;
      if (v76 == 128)
      {
LABEL_173:
        if ((v120 & 2) == 0) {
          goto LABEL_169;
        }
        goto LABEL_174;
      }
LABEL_167:
      if (v76 == 10 && (*(unsigned char *)(v77 + 40) & 8) != 0)
      {
LABEL_169:
        v79 += *(_DWORD *)(v77 + 80);
        if (v79 < 1) {
          goto LABEL_177;
        }
        goto LABEL_175;
      }
LABEL_174:
      int v80 = v78;
      if (v79 < 1) {
        goto LABEL_177;
      }
LABEL_175:
      unsigned int v81 = v79 + 1;
      do
      {
        lstep(v119, v71, v18, (uint64_t)v74, v80, (uint64_t)v74);
        --v81;
      }
      while (v81 > 1);
LABEL_177:
      if (v80 == 129)
      {
        if (v76 == 128)
        {
          int v80 = 129;
          if (v72 == 128) {
            goto LABEL_211;
          }
        }
        else
        {
LABEL_188:
          if (v76 > 0x7Fu)
          {
            int v84 = __maskrune(v76, 0x500uLL);
            if (v76 == 95 || v84 != 0) {
              int v80 = 133;
            }
            if (v72 == 128) {
              goto LABEL_211;
            }
          }
          else
          {
            if (v76 == 95 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v76 + 60) & 0x500) != 0) {
              int v80 = 133;
            }
            if (v72 == 128) {
              goto LABEL_211;
            }
          }
        }
        unsigned int v82 = v72;
        goto LABEL_203;
      }
      if (v72 == 128) {
        goto LABEL_211;
      }
      unsigned int v82 = v72;
      if (v72 > 0x7Fu)
      {
        if (__maskrune(v72, 0x500uLL)) {
          goto LABEL_203;
        }
      }
      else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v72 + 60) & 0x500) != 0)
      {
        goto LABEL_203;
      }
      if (v72 != 95 && v76 != 128) {
        goto LABEL_188;
      }
LABEL_203:
      if (v82 > 0x7F)
      {
        if (!__maskrune(v82, 0x500uLL))
        {
LABEL_207:
          if (v72 != 95) {
            goto LABEL_211;
          }
        }
      }
      else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v82 + 60) & 0x500) == 0)
      {
        goto LABEL_207;
      }
      if (v80 == 130
        || v76 != 128
        && (v76 > 0x7Fu
          ? (int v86 = __maskrune(v76, 0x500uLL))
          : (int v86 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v76 + 60) & 0x500),
            !v86 && v76 != 95))
      {
        int v80 = 134;
LABEL_212:
        lstep(v119, v71, v18, (uint64_t)v74, v80, (uint64_t)v74);
        goto LABEL_213;
      }
LABEL_211:
      if ((v80 - 133) <= 1) {
        goto LABEL_212;
      }
LABEL_213:
      if (v22 == v118 || v74[v18])
      {
        *((void *)&v122 + 1) = v75;
        if (!v74[v18])
        {
          free(*((void **)&v120 + 1));
          free((void *)v123);
          uint64_t v16 = 1;
          goto LABEL_261;
        }
        if (!v114 && !*(_DWORD *)(v110 + 120)) {
          goto LABEL_256;
        }
        uint64_t v87 = lslow(&v119, v75, v118, v71, v18);
        if (!v87)
        {
          do
          {
            ++*((void *)&v122 + 1);
            uint64_t v88 = lslow(&v119, *((char **)&v122 + 1), v118, v71, v18);
          }
          while (!v88);
          uint64_t v87 = v88;
        }
        if (v114 == 1 && !*(_DWORD *)(v110 + 120)) {
          goto LABEL_251;
        }
        uint64_t v89 = (char *)*((void *)&v120 + 1);
        uint64_t v90 = *(void *)(v119 + 112);
        if (!*((void *)&v120 + 1))
        {
          uint64_t v89 = (char *)malloc(16 * v90 + 16);
          *((void *)&v120 + 1) = v89;
          if (!v89)
          {
            uint64_t v16 = 12;
            goto LABEL_261;
          }
        }
        if (v90)
        {
          uint64_t v91 = 2;
          if ((unint64_t)(v90 + 1) > 2) {
            uint64_t v91 = v90 + 1;
          }
          memset(v89 + 16, 255, 16 * v91 - 16);
        }
        if (*(_DWORD *)(v110 + 120) || (BYTE1(v120) & 4) != 0)
        {
          uint64_t v93 = *(void *)(v110 + 128);
          unsigned __int8 v94 = (void *)v123;
          if (v93 >= 1 && !(void)v123)
          {
            unsigned __int8 v94 = malloc(8 * v93 + 8);
            *(void *)&long long v123 = v94;
          }
          if (v93 < 1 || v94)
          {
            uint64_t v92 = lbackref(&v119, *((unsigned char **)&v122 + 1), v87, v71, v18, 0, 0);
            goto LABEL_246;
          }
          free(v89);
          uint64_t v16 = 12;
          goto LABEL_261;
        }
        uint64_t v92 = (uint64_t)ldissect(&v119, *((char **)&v122 + 1), v87, v71, v18);
LABEL_246:
        if (v92) {
          goto LABEL_250;
        }
        while (1)
        {
          uint64_t v95 = (char *)*((void *)&v122 + 1);
          if ((unint64_t)v87 <= *((void *)&v122 + 1)) {
            break;
          }
          uint64_t v87 = lslow(&v119, *((char **)&v122 + 1), v87 - 1, v71, v18);
          uint64_t v95 = (char *)*((void *)&v122 + 1);
          if (!v87) {
            break;
          }
          if (lbackref(&v119, *((unsigned char **)&v122 + 1), v87, v71, v18, 0, 0)) {
            goto LABEL_250;
          }
        }
        unint64_t v22 = v95 + 1;
        if (v95 == v118)
        {
LABEL_250:
          if (v114)
          {
LABEL_251:
            uint64_t v96 = &v87[-v121];
            *unint64_t v108 = *((void *)&v122 + 1) - v121;
            v108[1] = v96;
            if (v114 >= 2)
            {
              uint64_t v97 = v119;
              uint64_t v98 = (long long *)(*((void *)&v120 + 1) + 16);
              int v99 = v108 + 2;
              for (unint64_t i = 1; i != v114; ++i)
              {
                while (i > *(void *)(v97 + 112))
                {
                  *int v99 = -1;
                  v99[1] = -1;
                  v99 += 2;
                  ++i;
                  ++v98;
                  if (v114 == i) {
                    goto LABEL_256;
                  }
                }
                long long v101 = *v98++;
                *(_OWORD *)int v99 = v101;
                v99 += 2;
              }
            }
          }
LABEL_256:
          if (*((void *)&v120 + 1)) {
            free(*((void **)&v120 + 1));
          }
          if ((void)v123) {
            free((void *)v123);
          }
          uint64_t v16 = 0;
LABEL_261:
          free(v124[0]);
          return v16;
        }
        goto LABEL_155;
      }
      memmove(*((void **)&v73 + 1), v74, *(void *)(v119 + 48));
      memmove(v74, (const void *)v73, *(void *)(v119 + 48));
      lstep(v119, v71, v18, *((uint64_t *)&v73 + 1), v76, (uint64_t)v74);
      ++v22;
      int v72 = v76;
      if (v22 != (char *)v122) {
        goto LABEL_159;
      }
    }
  }
  uint64_t v11 = *(void *)(v5 + 56);
  uint64_t v10 = *(void *)(v5 + 64);
  if ((*(unsigned char *)(v5 + 40) & 4) != 0) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = a3;
  }
  if ((a5 & 4) == 0)
  {
    size_t v13 = strlen(__s);
    size_t v14 = __s;
    int v15 = &__s[v13];
    if (&__s[v13] >= __s) {
      goto LABEL_20;
    }
    return 16;
  }
  size_t v13 = a4[1];
  size_t v14 = &__s[*a4];
  int v15 = &__s[v13];
  if (&__s[v13] < v14) {
    return 16;
  }
LABEL_20:
  uint64_t v107 = a4;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  uint64_t v24 = *(unsigned __int8 **)(v5 + 96);
  uint64_t v117 = v15;
  if (v24)
  {
    unint64_t v25 = v14;
    if (v14 < v15)
    {
      uint64_t v111 = v11;
      int __dst = v8;
      uint64_t v26 = v5;
      int v27 = *v24;
      uint64_t v28 = (char *)(__s - v14 + v13);
      int v104 = &__s[v13];
      unint64_t v29 = (char *)(&__s[v13] - v14);
      unint64_t v25 = v14;
      while (1)
      {
        if (*v25 == v27)
        {
          int64_t v30 = *(int *)(v26 + 104);
          if ((uint64_t)v29 >= v30 && !memcmp(v25, v24, v30)) {
            break;
          }
        }
        ++v25;
        --v29;
        if (!--v28)
        {
          unint64_t v25 = v104;
          break;
        }
      }
      uint64_t v5 = v26;
      int v15 = v117;
      int v8 = __dst;
      uint64_t v11 = v111;
    }
    if (v25 == v15) {
      return 1;
    }
  }
  uint64_t v38 = v11 + 1;
  uint64_t v119 = v5;
  LODWORD(v120) = v8;
  *(void *)&long long v121 = __s;
  *((void *)&v121 + 1) = v14;
  *(void *)&long long v122 = v15;
  unint64_t v103 = v12;
  uint64_t v106 = 1 << (v11 + 1);
  *(_OWORD *)int32x4_t v124 = 0u;
  long long v125 = 0u;
  uint64_t v109 = v5;
  while (2)
  {
    if (*((char **)&v121 + 1) == v14) {
      int v39 = 128;
    }
    else {
      int v39 = *(v14 - 1);
    }
    uint64_t v40 = v119;
    unint64_t v41 = sstep(v119, v38, v10, v106, 132, v106);
    uint64_t v42 = 0;
    unint64_t v43 = v41;
    unint64_t v113 = v41;
    if (v14 != (char *)v122)
    {
LABEL_47:
      int v44 = *v14;
      if (v43 == v41) {
        uint64_t v42 = v14;
      }
      if (v39 == 128) {
        goto LABEL_107;
      }
LABEL_50:
      if (v39 == 10 && (*(unsigned char *)(v40 + 40) & 8) != 0) {
        goto LABEL_108;
      }
LABEL_52:
      int v45 = 0;
      int v46 = 0;
      int v47 = 130;
      if (v44 == 128) {
        goto LABEL_109;
      }
LABEL_53:
      if (v44 != 10 || (*(unsigned char *)(v40 + 40) & 8) == 0) {
        goto LABEL_57;
      }
LABEL_55:
      v46 += *(_DWORD *)(v40 + 80);
      uint64_t v48 = v42;
      if (v46 >= 1)
      {
LABEL_58:
        unsigned int v49 = v46 + 1;
        do
        {
          unint64_t v43 = sstep(v40, v38, v10, v43, v47, v43);
          --v49;
        }
        while (v49 > 1);
      }
      goto LABEL_60;
    }
    while (1)
    {
      int v44 = 128;
      if (v43 == v41) {
        uint64_t v42 = v14;
      }
      if (v39 != 128) {
        goto LABEL_50;
      }
LABEL_107:
      if (v120) {
        goto LABEL_52;
      }
LABEL_108:
      int v46 = *(_DWORD *)(v40 + 76);
      int v45 = 129;
      int v47 = 131;
      if (v44 != 128) {
        goto LABEL_53;
      }
LABEL_109:
      if ((v120 & 2) == 0) {
        goto LABEL_55;
      }
LABEL_57:
      int v47 = v45;
      uint64_t v48 = v42;
      if (v46 >= 1) {
        goto LABEL_58;
      }
LABEL_60:
      if (v47 == 129)
      {
        uint64_t v42 = v48;
        if (v44 == 128)
        {
          int v47 = 129;
          if (v39 == 128) {
            goto LABEL_99;
          }
        }
        else
        {
LABEL_71:
          if (v44 > 0x7Fu)
          {
            int v52 = __maskrune(v44, 0x500uLL);
            if (v44 == 95 || v52 != 0) {
              int v47 = 133;
            }
            if (v39 == 128) {
              goto LABEL_99;
            }
          }
          else
          {
            if (v44 == 95 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v44 + 60) & 0x500) != 0) {
              int v47 = 133;
            }
            if (v39 == 128) {
              goto LABEL_99;
            }
          }
        }
        unsigned int v50 = v39;
        goto LABEL_86;
      }
      uint64_t v42 = v48;
      if (v39 == 128) {
        goto LABEL_99;
      }
      unsigned int v50 = v39;
      if (v39 > 0x7Fu)
      {
        if (__maskrune(v39, 0x500uLL)) {
          goto LABEL_86;
        }
      }
      else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x500) != 0)
      {
        goto LABEL_86;
      }
      if (v39 != 95 && v44 != 128) {
        goto LABEL_71;
      }
LABEL_86:
      if (v50 > 0x7F)
      {
        if (__maskrune(v50, 0x500uLL)) {
          goto LABEL_91;
        }
      }
      else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v50 + 60) & 0x500) != 0)
      {
        goto LABEL_91;
      }
      if (v39 != 95) {
        goto LABEL_99;
      }
LABEL_91:
      if (v47 == 130) {
        goto LABEL_92;
      }
      if (v44 != 128)
      {
        if (v44 > 0x7Fu)
        {
          if (__maskrune(v44, 0x500uLL)) {
            goto LABEL_99;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v44 + 60) & 0x500) != 0)
        {
          goto LABEL_99;
        }
        if (v44 != 95)
        {
LABEL_92:
          int v47 = 134;
LABEL_100:
          unint64_t v43 = sstep(v119, v38, v10, v43, v47, v43);
          goto LABEL_101;
        }
      }
LABEL_99:
      if ((v47 - 133) <= 1) {
        goto LABEL_100;
      }
LABEL_101:
      uint64_t v54 = v43 & (1 << v10);
      if (v14 == v117 || v54) {
        break;
      }
      uint64_t v40 = v119;
      unint64_t v41 = v113;
      unint64_t v43 = sstep(v119, v38, v10, v43, v44, v113);
      ++v14;
      int v39 = v44;
      if (v14 != (char *)v122) {
        goto LABEL_47;
      }
    }
    *((void *)&v122 + 1) = v42;
    if (!v54)
    {
      free(*((void **)&v120 + 1));
      free((void *)v123);
      return 1;
    }
    if (!v103 && !*(_DWORD *)(v109 + 120)) {
      goto LABEL_144;
    }
    uint64_t v55 = sslow(&v119, v42, v117, v38, v10);
    if (!v55)
    {
      do
      {
        ++*((void *)&v122 + 1);
        unint64_t v56 = sslow(&v119, *((char **)&v122 + 1), v117, v38, v10);
      }
      while (!v56);
      uint64_t v55 = v56;
    }
    if (v103 == 1 && !*(_DWORD *)(v109 + 120)) {
      goto LABEL_139;
    }
    uint64_t v57 = (char *)*((void *)&v120 + 1);
    uint64_t v58 = *(void *)(v119 + 112);
    if (!*((void *)&v120 + 1))
    {
      uint64_t v57 = (char *)malloc(16 * v58 + 16);
      *((void *)&v120 + 1) = v57;
      if (!v57) {
        return 12;
      }
    }
    if (v58)
    {
      uint64_t v59 = 2;
      if ((unint64_t)(v58 + 1) > 2) {
        uint64_t v59 = v58 + 1;
      }
      memset(v57 + 16, 255, 16 * v59 - 16);
    }
    if (*(_DWORD *)(v109 + 120) || (BYTE1(v120) & 4) != 0)
    {
      uint64_t v61 = *(void *)(v109 + 128);
      int v62 = (void *)v123;
      if (v61 >= 1 && !(void)v123)
      {
        int v62 = malloc(8 * v61 + 8);
        *(void *)&long long v123 = v62;
      }
      if (v61 >= 1 && !v62)
      {
        free(v57);
        return 12;
      }
      uint64_t v60 = sbackref(&v119, *((unsigned char **)&v122 + 1), v55, v38, v10, 0, 0);
    }
    else
    {
      uint64_t v60 = (uint64_t)sdissect(&v119, *((char **)&v122 + 1), v55, v38, v10);
    }
    if (!v60)
    {
      while (1)
      {
        uint64_t v63 = (char *)*((void *)&v122 + 1);
        if ((unint64_t)v55 <= *((void *)&v122 + 1)) {
          break;
        }
        uint64_t v55 = sslow(&v119, *((char **)&v122 + 1), v55 - 1, v38, v10);
        uint64_t v63 = (char *)*((void *)&v122 + 1);
        if (!v55) {
          break;
        }
        if (sbackref(&v119, *((unsigned char **)&v122 + 1), v55, v38, v10, 0, 0)) {
          goto LABEL_138;
        }
      }
      size_t v14 = v63 + 1;
      if (v63 != v117) {
        continue;
      }
    }
    break;
  }
LABEL_138:
  if (!v103) {
    goto LABEL_144;
  }
LABEL_139:
  uint64_t v64 = &v55[-v121];
  *uint64_t v107 = *((void *)&v122 + 1) - v121;
  v107[1] = v64;
  if (v103 >= 2)
  {
    uint64_t v65 = v119;
    uint64_t v66 = (long long *)(*((void *)&v120 + 1) + 16);
    uint64_t v67 = v107 + 2;
    for (unint64_t j = 1; j != v103; ++j)
    {
      while (j > *(void *)(v65 + 112))
      {
        void *v67 = -1;
        v67[1] = -1;
        v67 += 2;
        ++j;
        ++v66;
        if (v103 == j) {
          goto LABEL_144;
        }
      }
      long long v69 = *v66++;
      *(_OWORD *)uint64_t v67 = v69;
      v67 += 2;
    }
  }
LABEL_144:
  if (*((void *)&v120 + 1)) {
    free(*((void **)&v120 + 1));
  }
  if ((void)v123) {
    free((void *)v123);
  }
  return 0;
}

char *sslow(uint64_t *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a4;
  if (a4 >= a5) {
    goto LABEL_15;
  }
  while (1)
  {
    uint64_t v8 = *(void *)(*(void *)(*a1 + 8) + 8 * v6);
    int v9 = v8 & 0xF8000000;
    if ((v8 & 0xF8000000) == 0x70000000 || v9 == 1744830464) {
      goto LABEL_4;
    }
    if (v9 != 0x10000000) {
      goto LABEL_15;
    }
    if (a2 == a3 || *a2 != (char)v8) {
      return 0;
    }
    ++a2;
LABEL_4:
    if (a5 == ++v6)
    {
      uint64_t v6 = a5;
LABEL_15:
      unint64_t v26 = a1[12];
      if (a2 == (char *)a1[4]) {
        int v13 = 128;
      }
      else {
        int v13 = *(a2 - 1);
      }
      uint64_t v14 = *a1;
      unint64_t v15 = sstep(*a1, v6, a5, 1 << v6, 132, 1 << v6);
      uint64_t v11 = 0;
      uint64_t v27 = 1 << a5;
      uint64_t v16 = a1;
      if (a2 == (char *)a1[5]) {
        goto LABEL_73;
      }
LABEL_19:
      int v17 = *a2;
      if (v13 != 128)
      {
LABEL_20:
        if (v13 == 10 && (*(unsigned char *)(v14 + 40) & 8) != 0) {
          goto LABEL_75;
        }
LABEL_22:
        int v18 = 0;
        int v19 = 0;
        int v20 = 130;
        if (v17 == 128) {
          goto LABEL_76;
        }
LABEL_23:
        if (v17 != 10 || (*(unsigned char *)(v14 + 40) & 8) == 0) {
          goto LABEL_27;
        }
LABEL_25:
        v19 += *(_DWORD *)(v14 + 80);
        if (v19 >= 1)
        {
LABEL_28:
          unsigned int v21 = v19 + 1;
          do
          {
            unint64_t v15 = sstep(v14, v6, a5, v15, v20, v15);
            --v21;
          }
          while (v21 > 1);
        }
        goto LABEL_30;
      }
      while (1)
      {
        if (v16[1]) {
          goto LABEL_22;
        }
LABEL_75:
        int v19 = *(_DWORD *)(v14 + 76);
        int v18 = 129;
        int v20 = 131;
        if (v17 != 128) {
          goto LABEL_23;
        }
LABEL_76:
        if ((v16[1] & 2) == 0) {
          goto LABEL_25;
        }
LABEL_27:
        int v20 = v18;
        if (v19 >= 1) {
          goto LABEL_28;
        }
LABEL_30:
        if (v20 == 129)
        {
          uint64_t v16 = a1;
          if (v17 == 128)
          {
            int v20 = 129;
            if (v13 == 128) {
              goto LABEL_61;
            }
          }
          else
          {
LABEL_41:
            if (v17 > 0x7Fu)
            {
              int v24 = __maskrune(v17, 0x500uLL);
              if (v17 == 95 || v24 != 0) {
                int v20 = 133;
              }
              if (v13 == 128) {
                goto LABEL_61;
              }
            }
            else
            {
              if (v17 == 95 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v17 + 60) & 0x500) != 0) {
                int v20 = 133;
              }
              if (v13 == 128) {
                goto LABEL_61;
              }
            }
          }
          unsigned int v22 = v13;
          goto LABEL_56;
        }
        uint64_t v16 = a1;
        if (v13 == 128) {
          goto LABEL_61;
        }
        unsigned int v22 = v13;
        if (v13 > 0x7Fu)
        {
          if (__maskrune(v13, 0x500uLL)) {
            goto LABEL_56;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v13 + 60) & 0x500) != 0)
        {
          goto LABEL_56;
        }
        if (v13 != 95 && v17 != 128) {
          goto LABEL_41;
        }
LABEL_56:
        if (v22 > 0x7F)
        {
          if (__maskrune(v22, 0x500uLL)) {
            goto LABEL_66;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x500) != 0)
        {
          goto LABEL_66;
        }
        if (v13 != 95) {
          goto LABEL_61;
        }
LABEL_66:
        if (v20 == 130) {
          goto LABEL_67;
        }
        if (v17 != 128)
        {
          if (v17 > 0x7Fu)
          {
            if (__maskrune(v17, 0x500uLL)) {
              goto LABEL_61;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v17 + 60) & 0x500) != 0)
          {
            goto LABEL_61;
          }
          if (v17 != 95)
          {
LABEL_67:
            int v20 = 134;
            goto LABEL_68;
          }
        }
LABEL_61:
        if ((v20 - 133) > 1)
        {
          if ((v15 & v27) != 0) {
            uint64_t v11 = a2;
          }
          if (a2 == a3) {
            return v11;
          }
          goto LABEL_71;
        }
LABEL_68:
        unint64_t v15 = sstep(*v16, v6, a5, v15, v20, v15);
        if ((v15 & v27) != 0) {
          uint64_t v11 = a2;
        }
        if (a2 == a3) {
          return v11;
        }
LABEL_71:
        if (v15 == v26) {
          return v11;
        }
        uint64_t v14 = *v16;
        unint64_t v15 = sstep(*v16, v6, a5, v15, v17, v26);
        ++a2;
        int v13 = v17;
        if (a2 != (char *)v16[5]) {
          goto LABEL_19;
        }
LABEL_73:
        int v17 = 128;
        if (v13 != 128) {
          goto LABEL_20;
        }
      }
    }
  }
}

char *sdissect(uint64_t *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= a5) {
    return a2;
  }
  uint64_t v6 = a5;
  uint64_t v7 = a4;
  uint64_t v10 = a5 - 1;
  while (2)
  {
    uint64_t v11 = v7;
    uint64_t v12 = *(void *)(*a1 + 8);
    uint64_t v13 = *(void *)(v12 + 8 * v7);
    int v14 = v13 & 0xF8000000;
    if ((v13 & 0xF8000000) == 0x48000000 || v14 == 1476395008)
    {
      uint64_t v16 = (v13 & 0x7FFFFFF) + v7;
    }
    else
    {
      BOOL v17 = v14 != 2013265920 || (v13 & 0xF8000000) == 2415919104;
      uint64_t v16 = v7;
      if (!v17)
      {
        uint64_t v18 = *(void *)(v12 + 8 * v7);
        uint64_t v16 = v7;
        do
        {
          v16 += v18 & 0x7FFFFFF;
          uint64_t v18 = *(void *)(v12 + 8 * v16);
        }
        while ((v18 & 0xF8000000) != 0x90000000);
      }
    }
    uint64_t v7 = v16 + 1;
    switch(((unint64_t)(v13 & 0xF8000000) - 0x8000000) >> 27)
    {
      case 1uLL:
      case 4uLL:
      case 5uLL:
        ++a2;
        goto LABEL_4;
      case 8uLL:
        int v19 = sslow(a1, a2, a3, v11, v16 + 1);
        if (sslow(a1, v19, a3, v16 + 1, v6) == a3) {
          goto LABEL_78;
        }
        while (2)
        {
          unsigned int v21 = v19 - 1;
          if (v7 >= v6) {
            goto LABEL_21;
          }
          unsigned int v22 = (void *)(*(void *)(*a1 + 8) + 8 * v16 + 16);
          uint64_t v23 = v16;
          while (1)
          {
            int v24 = *((_DWORD *)v22 - 2);
            if ((v24 & 0xF8000000) != 0x70000000) {
              break;
            }
            ++v22;
            if (v10 == ++v23) {
              goto LABEL_21;
            }
          }
          if ((v24 & 0xF8000000) != 0x10000000) {
            goto LABEL_21;
          }
          int v20 = a2;
          if (v21 == a2) {
            goto LABEL_22;
          }
          uint64_t v25 = v23 + 2;
          int v26 = (char)v24;
          if (v25 >= v6)
          {
            while ((char)v24 != *v21)
            {
              if (--v21 == a2)
              {
LABEL_34:
                int v20 = a2;
                goto LABEL_22;
              }
            }
LABEL_21:
            int v20 = v21;
            goto LABEL_22;
          }
          uint64_t v27 = v19;
          while (2)
          {
            if (v26 != *(v27 - 1)) {
              goto LABEL_35;
            }
            if ((*v22 & 0xF8000000) == 0x10000000 && v27 < v19)
            {
              if (*v27 == (char)*v22) {
                goto LABEL_21;
              }
LABEL_35:
              --v21;
              uint64_t v28 = v27 - 2;
              --v27;
              if (v28 == a2) {
                goto LABEL_34;
              }
              continue;
            }
            break;
          }
          int v20 = v27 - 1;
LABEL_22:
          int v19 = sslow(a1, a2, v20, v11, v16 + 1);
          if (sslow(a1, v19, a3, v16 + 1, v6) != a3) {
            continue;
          }
          break;
        }
LABEL_78:
        uint64_t v50 = v11 + 1;
        uint64_t v51 = a2;
        do
        {
          int v52 = v51;
          uint64_t v51 = a2;
          uint64_t v53 = sslow(a1, a2, v19, v50, v16);
          a2 = v53;
        }
        while (v53 && v53 != v51);
        if (v53) {
          uint64_t v54 = v51;
        }
        else {
          uint64_t v54 = v52;
        }
        if (v53) {
          uint64_t v55 = v53;
        }
        else {
          uint64_t v55 = v51;
        }
        sdissect(a1, v54, v55, v50, v16);
        a2 = v19;
        uint64_t v6 = a5;
        goto LABEL_4;
      case 0xAuLL:
        int64_t v30 = sslow(a1, a2, a3, v11, v16 + 1);
        if (sslow(a1, v30, a3, v16 + 1, v6) == a3) {
          goto LABEL_88;
        }
        break;
      case 0xCuLL:
        *(void *)(a1[2] + 16 * (v13 & 0x7FFFFFF)) = &a2[-a1[3]];
        goto LABEL_4;
      case 0xDuLL:
        *(void *)(a1[2] + 16 * (v13 & 0x7FFFFFF) + 8) = &a2[-a1[3]];
        goto LABEL_4;
      case 0xEuLL:
        unint64_t v41 = a3;
        do
        {
          uint64_t v42 = sslow(a1, a2, v41, v11, v7);
          unint64_t v43 = sslow(a1, v42, a3, v7, v6);
          unint64_t v41 = v42 - 1;
        }
        while (v43 != a3);
        uint64_t v44 = v11 + (*(void *)(*(void *)(*a1 + 8) + 8 * v11) & 0x7FFFFFFLL) - 1;
        uint64_t v45 = v11 + 1;
        while (sslow(a1, a2, v42, v45, v44) != v42)
        {
          uint64_t v46 = *(void *)(*a1 + 8);
          uint64_t v47 = *(void *)(v46 + 8 * (v44 + 1)) & 0x7FFFFFFLL;
          uint64_t v48 = v47 + v44 + 1;
          uint64_t v49 = v47 + v44;
          uint64_t v45 = v44 + 2;
          if ((*(void *)(v46 + 8 * v48) & 0xF8000000) == 0x88000000) {
            uint64_t v44 = v49;
          }
          else {
            uint64_t v44 = v48;
          }
        }
        sdissect(a1, a2, v42, v45, v44);
        a2 = v42;
        goto LABEL_4;
      default:
        goto LABEL_4;
    }
    while (2)
    {
      uint64_t v32 = v30 - 1;
      if (v7 >= v6) {
        goto LABEL_46;
      }
      uint64_t v33 = (void *)(*(void *)(*a1 + 8) + 8 * v16 + 16);
      uint64_t v34 = v16;
      while (1)
      {
        int v35 = *((_DWORD *)v33 - 2);
        if ((v35 & 0xF8000000) != 0x70000000) {
          break;
        }
        ++v33;
        if (v10 == ++v34) {
          goto LABEL_46;
        }
      }
      if ((v35 & 0xF8000000) != 0x10000000)
      {
LABEL_46:
        uint64_t v31 = v32;
        goto LABEL_47;
      }
      uint64_t v31 = a2;
      if (v32 == a2) {
        goto LABEL_47;
      }
      uint64_t v36 = v34 + 2;
      int v37 = (char)v35;
      if (v36 >= v6)
      {
        while ((char)v35 != *v32)
        {
          if (--v32 == a2)
          {
LABEL_59:
            uint64_t v31 = a2;
            goto LABEL_47;
          }
        }
        goto LABEL_46;
      }
      uint64_t v38 = v30;
      while (1)
      {
        if (v37 != *(v38 - 1)) {
          goto LABEL_60;
        }
        if ((*v33 & 0xF8000000) != 0x10000000 || v38 >= v30) {
          break;
        }
        if (*v38 == (char)*v33) {
          goto LABEL_46;
        }
LABEL_60:
        --v32;
        int v39 = v38 - 2;
        --v38;
        if (v39 == a2) {
          goto LABEL_59;
        }
      }
      uint64_t v31 = v38 - 1;
LABEL_47:
      int64_t v30 = sslow(a1, a2, v31, v11, v16 + 1);
      if (sslow(a1, v30, a3, v16 + 1, v6) != a3) {
        continue;
      }
      break;
    }
LABEL_88:
    uint64_t v56 = v11 + 1;
    if (sslow(a1, a2, v30, v56, v16)) {
      sdissect(a1, a2, v30, v56, v16);
    }
    a2 = v30;
LABEL_4:
    if (v7 < v6) {
      continue;
    }
    return a2;
  }
}

uint64_t sbackref(uint64_t *a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a4 < a5)
  {
    uint64_t v12 = a4;
    while (1)
    {
LABEL_3:
      uint64_t v14 = v12;
      while (2)
      {
        uint64_t v15 = *a1;
        uint64_t v16 = *(void *)(*a1 + 8);
        uint64_t v17 = *(void *)(v16 + 8 * v14);
        switch(((unint64_t)(v17 & 0xF8000000) - 0x10000000) >> 27)
        {
          case 0uLL:
            if (a2 == a3) {
              return 0;
            }
            int v26 = (char)*a2++;
            if (v26 != (char)v17) {
              return 0;
            }
            goto LABEL_5;
          case 1uLL:
            if (a2 == (unsigned char *)a1[4] && (a1[1] & 1) == 0) {
              goto LABEL_5;
            }
            if ((unint64_t)a2 >= a1[5] || *(a2 - 1) != 10) {
              return 0;
            }
            goto LABEL_4;
          case 2uLL:
            uint64_t v27 = (unsigned char *)a1[5];
            if (a2 == v27 && (a1[1] & 2) == 0) {
              goto LABEL_5;
            }
            if (a2 >= v27 || *a2 != 10) {
              return 0;
            }
LABEL_4:
            if ((*(unsigned char *)(v15 + 40) & 8) != 0) {
              goto LABEL_5;
            }
            return 0;
          case 3uLL:
            if (a2 == a3) {
              return 0;
            }
            ++a2;
            goto LABEL_5;
          case 4uLL:
            if (a2 == a3) {
              return 0;
            }
            uint64_t v28 = *(void *)(v15 + 24) + 32 * (v17 & 0x7FFFFFF);
            unsigned int v29 = *a2++;
            if ((*(unsigned char *)(v28 + 8) & *(unsigned char *)(*(void *)v28 + v29)) == 0) {
              return 0;
            }
            goto LABEL_5;
          case 0xAuLL:
          case 0x10uLL:
            goto LABEL_5;
          case 0xEuLL:
            ++v14;
            uint64_t v30 = *(void *)(v16 + 8 * v14);
            do
            {
              v14 += v30 & 0x7FFFFFF;
              uint64_t v30 = *(void *)(v16 + 8 * v14);
            }
            while ((v30 & 0xF8000000) != 0x90000000);
            goto LABEL_5;
          case 0x11uLL:
            uint64_t v31 = (unsigned char *)a1[4];
            if (a2 == v31 && (a1[1] & 1) == 0
              || (unint64_t)a2 < a1[5] && *(a2 - 1) == 10 && (*(unsigned char *)(v15 + 40) & 8) != 0)
            {
              goto LABEL_61;
            }
            if (a2 <= v31) {
              return 0;
            }
            uint64_t v32 = *(a2 - 1);
            if ((char)*(a2 - 1) < 0) {
              int v33 = __maskrune(*(a2 - 1), 0x500uLL);
            }
            else {
              int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v32 + 60) & 0x500;
            }
            uint64_t result = 0;
            if (v32 == 95 || v33) {
              return result;
            }
LABEL_61:
            if ((unint64_t)a2 >= a1[5]) {
              return 0;
            }
            int v37 = (char)*a2;
            uint64_t v38 = *a2;
            if ((v37 & 0x80000000) == 0) {
              goto LABEL_63;
            }
            goto LABEL_69;
          case 0x12uLL:
            uint64_t v34 = (unsigned char *)a1[5];
            if (a2 == v34 && (a1[1] & 2) == 0) {
              goto LABEL_67;
            }
            if (a2 >= v34) {
              return 0;
            }
            uint64_t v35 = *a2;
            if (v35 == 10)
            {
              if ((*(unsigned char *)(v15 + 40) & 8) != 0) {
                goto LABEL_67;
              }
LABEL_56:
              int v36 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v35 + 60) & 0x500;
              uint64_t result = 0;
              if (v35 == 95) {
                return result;
              }
              goto LABEL_66;
            }
            if ((v35 & 0x80) == 0) {
              goto LABEL_56;
            }
            int v36 = __maskrune(*a2, 0x500uLL);
            uint64_t result = 0;
            if (v35 == 95) {
              return result;
            }
LABEL_66:
            if (v36) {
              return result;
            }
LABEL_67:
            if ((unint64_t)a2 <= a1[4]) {
              return 0;
            }
            int v37 = (char)*(a2 - 1);
            uint64_t v38 = *(a2 - 1);
            if (v37 < 0)
            {
LABEL_69:
              int v39 = __maskrune(v37, 0x500uLL);
              if (v38 == 95) {
                goto LABEL_5;
              }
            }
            else
            {
LABEL_63:
              int v39 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x500;
              if (v38 == 95) {
                goto LABEL_5;
              }
            }
            if (!v39) {
              return 0;
            }
LABEL_5:
            ++v14;
            goto LABEL_6;
          default:
            uint64_t v12 = v14 + 1;
            unint64_t v18 = ((unint64_t)(v17 & 0xF8000000) - 939524096) >> 27;
            if (v18 == 4)
            {
              uint64_t result = sbackref(a1, a2, a3, v14 + 1, a5, a6, a7);
              if (result) {
                return result;
              }
              uint64_t v14 = (v17 & 0x7FFFFFF) + v12;
LABEL_6:
              if (v14 >= a5) {
                goto LABEL_79;
              }
              continue;
            }
            uint64_t result = 0;
            switch(v18)
            {
              case 0uLL:
                uint64_t v20 = v17 & 0x7FFFFFF;
                uint64_t v21 = a1[2];
                uint64_t v22 = *(void *)(v21 + 16 * v20 + 8);
                if (v22 == -1) {
                  return 0;
                }
                uint64_t v23 = *(void *)(v21 + 16 * v20);
                size_t v24 = v22 - v23;
                if (v22 != v23) {
                  goto LABEL_16;
                }
                if ((int)a7 > 100) {
                  return 0;
                }
                a7 = (a7 + 1);
LABEL_16:
                if (a2 > &a3[-v24] || memcmp(a2, (const void *)(a1[3] + v23), v24)) {
                  return 0;
                }
                do
                  uint64_t v25 = *(void *)(v16 + 8 * v14++);
                while (v25 != (v20 | 0x40000000));
                a2 += v24;
                goto LABEL_6;
              case 2uLL:
                ++a6;
                *(void *)(a1[7] + 8 * a6) = a2;
                if (v12 >= a5) {
                  goto LABEL_79;
                }
                goto LABEL_3;
              case 3uLL:
                uint64_t v40 = a1[7];
                if (a2 == *(unsigned char **)(v40 + 8 * a6))
                {
                  --a6;
                  if (v12 >= a5) {
                    goto LABEL_79;
                  }
                }
                else
                {
                  *(void *)(v40 + 8 * a6) = a2;
                  uint64_t result = sbackref(a1, a2, a3, v12 - (v17 & 0x7FFFFFF), a5, a6, a7);
                  if (result) {
                    return result;
                  }
                  --a6;
                  if (v12 >= a5) {
                    goto LABEL_79;
                  }
                }
                break;
              case 6uLL:
                uint64_t v41 = 16 * (v17 & 0x7FFFFFF);
                uint64_t v42 = a1[2];
                uint64_t v43 = *(void *)(v42 + v41);
                *(void *)(v42 + v41) = &a2[-a1[3]];
                uint64_t result = sbackref(a1, a2, a3, v12, a5, a6, a7);
                if (!result) {
                  *(void *)(a1[2] + v41) = v43;
                }
                return result;
              case 7uLL:
                uint64_t v44 = v17 & 0x7FFFFFF;
                uint64_t v45 = a1[2] + 16 * v44;
                uint64_t v46 = *(void *)(v45 + 8);
                *(void *)(v45 + 8) = &a2[-a1[3]];
                uint64_t result = sbackref(a1, a2, a3, v12, a5, a6, a7);
                if (!result) {
                  *(void *)(a1[2] + 16 * v44 + 8) = v46;
                }
                return result;
              case 8uLL:
                uint64_t result = sbackref(a1, a2, a3, v14 + 1, a5, a6, a7);
                if (result) {
                  return result;
                }
                uint64_t v47 = v14 + (v17 & 0x7FFFFFF) - 1;
                while (1)
                {
                  uint64_t v48 = *(void *)(*a1 + 8);
                  if ((*(void *)(v48 + 8 * v47) & 0xF8000000) == 0x90000000) {
                    break;
                  }
                  uint64_t v49 = v47 + 2;
                  uint64_t v50 = *(void *)(v48 + 8 * (v47 + 1)) & 0x7FFFFFFLL;
                  uint64_t v51 = v50 + v47 + 1;
                  uint64_t v52 = v50 + v47;
                  if ((*(void *)(v48 + 8 * v51) & 0xF8000000) == 0x88000000) {
                    uint64_t v47 = v52;
                  }
                  else {
                    uint64_t v47 = v51;
                  }
                  uint64_t result = sbackref(a1, a2, a3, v49, a5, a6, a7);
                  if (result) {
                    return result;
                  }
                }
                return 0;
              default:
                return result;
            }
            break;
        }
        break;
      }
    }
  }
LABEL_79:
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  else {
    return 0;
  }
}

unint64_t sstep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unint64_t a6)
{
  if (a2 != a3)
  {
    unint64_t v7 = 1 << a2;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      uint64_t v10 = *(void *)(v8 + 8 * a2);
      switch(((unint64_t)(v10 & 0xF8000000) - 0x8000000) >> 27)
      {
        case 1uLL:
          BOOL v9 = a5 == (char)v10;
          goto LABEL_5;
        case 2uLL:
          BOOL v9 = (a5 & 0xFFFFFFFD) == 129;
          goto LABEL_5;
        case 3uLL:
          BOOL v9 = (a5 & 0xFFFFFFFE) == 130;
          goto LABEL_5;
        case 4uLL:
          if (a5 <= 127) {
            a6 |= 2 * (v7 & a4);
          }
          break;
        case 5uLL:
          if (a5 > 127) {
            break;
          }
          uint64_t v12 = *(void *)(a1 + 24) + 32 * (v10 & 0x7FFFFFF);
          if ((*(unsigned char *)(v12 + 8) & *(unsigned char *)(*(void *)v12 + a5)) == 0) {
            break;
          }
          unint64_t v11 = v7 & a4;
LABEL_11:
          a6 |= 2 * v11;
          break;
        case 6uLL:
        case 7uLL:
        case 8uLL:
        case 0xBuLL:
        case 0xCuLL:
        case 0xDuLL:
        case 0x11uLL:
          unint64_t v11 = v7 & a6;
          goto LABEL_11;
        case 9uLL:
          uint64_t v13 = a6 | (2 * (v7 & a6));
          a6 = ((v13 & v7) >> v10) | v13;
          if (((v7 >> v10) & v13) == 0 && (a6 & (v7 >> v10)) != 0)
          {
            a2 += ~(unint64_t)(v10 & 0x7FFFFFF);
            unint64_t v7 = 1 << a2;
          }
          break;
        case 0xAuLL:
        case 0xEuLL:
          a6 |= (((a6 | (2 * (v7 & a6))) & v7) << v10) | (2 * (v7 & a6));
          break;
        case 0xFuLL:
          if ((v7 & a6) != 0)
          {
            uint64_t v15 = *(void *)(v8 + 8 * a2 + 8);
            if ((v15 & 0xF8000000) == 0x90000000)
            {
              LOBYTE(v16) = 1;
            }
            else
            {
              uint64_t v16 = 1;
              do
              {
                v16 += v15 & 0x7FFFFFF;
                uint64_t v15 = *(void *)(v8 + 8 * (v16 + a2));
              }
              while ((v15 & 0xF8000000) != 0x90000000);
            }
            a6 |= (v7 & a6) << v16;
          }
          break;
        case 0x10uLL:
          a6 |= 2 * (v7 & a6);
          if ((*(void *)(v8 + 8 * ((v10 & 0x7FFFFFF) + a2)) & 0xF8000000) != 0x90000000) {
            a6 |= (a6 & v7) << v10;
          }
          break;
        case 0x12uLL:
          BOOL v9 = a5 == 133;
          goto LABEL_5;
        case 0x13uLL:
          BOOL v9 = a5 == 134;
LABEL_5:
          if (v9) {
            a6 |= 2 * (v7 & a4);
          }
          break;
        default:
          break;
      }
      ++a2;
      v7 *= 2;
    }
    while (a2 != a3);
  }
  return a6;
}

char *lslow(uint64_t *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a4;
  if (a4 >= a5) {
    goto LABEL_15;
  }
  while (1)
  {
    uint64_t v9 = *(void *)(*(void *)(*a1 + 8) + 8 * v6);
    int v10 = v9 & 0xF8000000;
    if ((v9 & 0xF8000000) == 0x70000000 || v10 == 1744830464) {
      goto LABEL_4;
    }
    if (v10 != 0x10000000) {
      goto LABEL_15;
    }
    if (a2 == a3 || *a2 != (char)v9) {
      return 0;
    }
    ++a2;
LABEL_4:
    if (a5 == ++v6)
    {
      uint64_t v6 = a5;
LABEL_15:
      uint64_t v14 = (void *)a1[10];
      int __dst = (void *)a1[12];
      __s2 = (void *)a1[13];
      if (a2 == (char *)a1[4]) {
        int v15 = 128;
      }
      else {
        int v15 = *(a2 - 1);
      }
      bzero(v14, *(void *)(*a1 + 48));
      *((unsigned char *)v14 + v6) = 1;
      lstep(*a1, v6, a5, (uint64_t)v14, 132, (uint64_t)v14);
      uint64_t v12 = 0;
      if (a2 == (char *)a1[5]) {
        goto LABEL_76;
      }
LABEL_19:
      int v16 = *a2;
      if (v15 != 128)
      {
LABEL_20:
        if (v15 == 10 && (*(unsigned char *)(*a1 + 40) & 8) != 0)
        {
          int v17 = *(_DWORD *)(*a1 + 76);
          int v18 = 129;
          int v19 = 131;
          if (v16 != 128) {
            goto LABEL_27;
          }
        }
        else
        {
LABEL_26:
          int v18 = 0;
          int v17 = 0;
          int v19 = 130;
          if (v16 != 128) {
            goto LABEL_27;
          }
        }
LABEL_23:
        if ((a1[1] & 2) == 0)
        {
          v17 += *(_DWORD *)(*a1 + 80);
          if (v17 >= 1)
          {
LABEL_32:
            unsigned int v20 = v17 + 1;
            do
            {
              lstep(*a1, v6, a5, (uint64_t)v14, v19, (uint64_t)v14);
              --v20;
            }
            while (v20 > 1);
          }
          goto LABEL_34;
        }
LABEL_29:
        int v19 = v18;
        if (v17 >= 1) {
          goto LABEL_32;
        }
        goto LABEL_34;
      }
      while (1)
      {
        if (a1[1]) {
          goto LABEL_26;
        }
        int v17 = *(_DWORD *)(*a1 + 76);
        int v18 = 129;
        int v19 = 131;
        if (v16 == 128) {
          goto LABEL_23;
        }
LABEL_27:
        if (v16 != 10 || (*(unsigned char *)(*a1 + 40) & 8) == 0) {
          goto LABEL_29;
        }
        v17 += *(_DWORD *)(*a1 + 80);
        if (v17 >= 1) {
          goto LABEL_32;
        }
LABEL_34:
        if (v19 == 129)
        {
          if (v16 == 128)
          {
            int v19 = 129;
            if (v15 == 128) {
              goto LABEL_65;
            }
          }
          else
          {
LABEL_45:
            if (v16 > 0x7Fu)
            {
              int v23 = __maskrune(v16, 0x500uLL);
              if (v16 == 95 || v23 != 0) {
                int v19 = 133;
              }
              if (v15 == 128)
              {
LABEL_65:
                uint64_t v25 = __s2;
LABEL_66:
                if ((v19 - 133) > 1) {
                  goto LABEL_71;
                }
                goto LABEL_70;
              }
            }
            else
            {
              if (v16 == 95 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x500) != 0) {
                int v19 = 133;
              }
              if (v15 == 128) {
                goto LABEL_65;
              }
            }
          }
          unsigned int v21 = v15;
          goto LABEL_60;
        }
        if (v15 == 128) {
          goto LABEL_65;
        }
        unsigned int v21 = v15;
        if (v15 > 0x7Fu)
        {
          if (__maskrune(v15, 0x500uLL)) {
            goto LABEL_60;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x500) != 0)
        {
          goto LABEL_60;
        }
        if (v15 != 95 && v16 != 128) {
          goto LABEL_45;
        }
LABEL_60:
        if (v21 > 0x7F)
        {
          if (__maskrune(v21, 0x500uLL)) {
            goto LABEL_68;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x500) != 0)
        {
          goto LABEL_68;
        }
        if (v15 != 95) {
          goto LABEL_65;
        }
LABEL_68:
        if (v19 == 130)
        {
          int v19 = 134;
          uint64_t v25 = __s2;
        }
        else
        {
          uint64_t v25 = __s2;
          if (v16 == 128) {
            goto LABEL_66;
          }
          if (v16 > 0x7Fu)
          {
            if (__maskrune(v16, 0x500uLL)) {
              goto LABEL_66;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x500) != 0)
          {
            goto LABEL_66;
          }
          if (v16 == 95) {
            goto LABEL_66;
          }
          int v19 = 134;
        }
LABEL_70:
        lstep(*a1, v6, a5, (uint64_t)v14, v19, (uint64_t)v14);
LABEL_71:
        if (*((unsigned char *)v14 + a5)) {
          uint64_t v12 = a2;
        }
        size_t v26 = *(void *)(*a1 + 48);
        int v27 = memcmp(v14, v25, v26);
        if (a2 == a3 || !v27) {
          return v12;
        }
        memmove(__dst, v14, v26);
        memmove(v14, v25, *(void *)(*a1 + 48));
        lstep(*a1, v6, a5, (uint64_t)__dst, v16, (uint64_t)v14);
        ++a2;
        int v15 = v16;
        if (a2 != (char *)a1[5]) {
          goto LABEL_19;
        }
LABEL_76:
        int v16 = 128;
        if (v15 != 128) {
          goto LABEL_20;
        }
      }
    }
  }
}

char *ldissect(uint64_t *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= a5) {
    return a2;
  }
  uint64_t v6 = a5;
  uint64_t v7 = a4;
  uint64_t v10 = a5 - 1;
  while (2)
  {
    uint64_t v11 = v7;
    uint64_t v12 = *(void *)(*a1 + 8);
    uint64_t v13 = *(void *)(v12 + 8 * v7);
    int v14 = v13 & 0xF8000000;
    if ((v13 & 0xF8000000) == 0x48000000 || v14 == 1476395008)
    {
      uint64_t v16 = (v13 & 0x7FFFFFF) + v7;
    }
    else
    {
      BOOL v17 = v14 != 2013265920 || (v13 & 0xF8000000) == 2415919104;
      uint64_t v16 = v7;
      if (!v17)
      {
        uint64_t v18 = *(void *)(v12 + 8 * v7);
        uint64_t v16 = v7;
        do
        {
          v16 += v18 & 0x7FFFFFF;
          uint64_t v18 = *(void *)(v12 + 8 * v16);
        }
        while ((v18 & 0xF8000000) != 0x90000000);
      }
    }
    uint64_t v7 = v16 + 1;
    switch(((unint64_t)(v13 & 0xF8000000) - 0x8000000) >> 27)
    {
      case 1uLL:
      case 4uLL:
      case 5uLL:
        ++a2;
        goto LABEL_4;
      case 8uLL:
        int v19 = lslow(a1, a2, a3, v11, v16 + 1);
        if (lslow(a1, v19, a3, v16 + 1, v6) == a3) {
          goto LABEL_78;
        }
        while (2)
        {
          unsigned int v21 = v19 - 1;
          if (v7 >= v6) {
            goto LABEL_21;
          }
          uint64_t v22 = (void *)(*(void *)(*a1 + 8) + 8 * v16 + 16);
          uint64_t v23 = v16;
          while (1)
          {
            int v24 = *((_DWORD *)v22 - 2);
            if ((v24 & 0xF8000000) != 0x70000000) {
              break;
            }
            ++v22;
            if (v10 == ++v23) {
              goto LABEL_21;
            }
          }
          if ((v24 & 0xF8000000) != 0x10000000) {
            goto LABEL_21;
          }
          unsigned int v20 = a2;
          if (v21 == a2) {
            goto LABEL_22;
          }
          uint64_t v25 = v23 + 2;
          int v26 = (char)v24;
          if (v25 >= v6)
          {
            while ((char)v24 != *v21)
            {
              if (--v21 == a2)
              {
LABEL_34:
                unsigned int v20 = a2;
                goto LABEL_22;
              }
            }
LABEL_21:
            unsigned int v20 = v21;
            goto LABEL_22;
          }
          int v27 = v19;
          while (2)
          {
            if (v26 != *(v27 - 1)) {
              goto LABEL_35;
            }
            if ((*v22 & 0xF8000000) == 0x10000000 && v27 < v19)
            {
              if (*v27 == (char)*v22) {
                goto LABEL_21;
              }
LABEL_35:
              --v21;
              uint64_t v28 = v27 - 2;
              --v27;
              if (v28 == a2) {
                goto LABEL_34;
              }
              continue;
            }
            break;
          }
          unsigned int v20 = v27 - 1;
LABEL_22:
          int v19 = lslow(a1, a2, v20, v11, v16 + 1);
          if (lslow(a1, v19, a3, v16 + 1, v6) != a3) {
            continue;
          }
          break;
        }
LABEL_78:
        uint64_t v50 = v11 + 1;
        uint64_t v51 = a2;
        do
        {
          uint64_t v52 = v51;
          uint64_t v51 = a2;
          uint64_t v53 = lslow(a1, a2, v19, v50, v16);
          a2 = v53;
        }
        while (v53 && v53 != v51);
        if (v53) {
          uint64_t v54 = v51;
        }
        else {
          uint64_t v54 = v52;
        }
        if (v53) {
          uint64_t v55 = v53;
        }
        else {
          uint64_t v55 = v51;
        }
        ldissect(a1, v54, v55, v50, v16);
        a2 = v19;
        uint64_t v6 = a5;
        goto LABEL_4;
      case 0xAuLL:
        uint64_t v30 = lslow(a1, a2, a3, v11, v16 + 1);
        if (lslow(a1, v30, a3, v16 + 1, v6) == a3) {
          goto LABEL_88;
        }
        break;
      case 0xCuLL:
        *(void *)(a1[2] + 16 * (v13 & 0x7FFFFFF)) = &a2[-a1[3]];
        goto LABEL_4;
      case 0xDuLL:
        *(void *)(a1[2] + 16 * (v13 & 0x7FFFFFF) + 8) = &a2[-a1[3]];
        goto LABEL_4;
      case 0xEuLL:
        uint64_t v41 = a3;
        do
        {
          uint64_t v42 = lslow(a1, a2, v41, v11, v7);
          uint64_t v43 = lslow(a1, v42, a3, v7, v6);
          uint64_t v41 = v42 - 1;
        }
        while (v43 != a3);
        uint64_t v44 = v11 + (*(void *)(*(void *)(*a1 + 8) + 8 * v11) & 0x7FFFFFFLL) - 1;
        uint64_t v45 = v11 + 1;
        while (lslow(a1, a2, v42, v45, v44) != v42)
        {
          uint64_t v46 = *(void *)(*a1 + 8);
          uint64_t v47 = *(void *)(v46 + 8 * (v44 + 1)) & 0x7FFFFFFLL;
          uint64_t v48 = v47 + v44 + 1;
          uint64_t v49 = v47 + v44;
          uint64_t v45 = v44 + 2;
          if ((*(void *)(v46 + 8 * v48) & 0xF8000000) == 0x88000000) {
            uint64_t v44 = v49;
          }
          else {
            uint64_t v44 = v48;
          }
        }
        ldissect(a1, a2, v42, v45, v44);
        a2 = v42;
        goto LABEL_4;
      default:
        goto LABEL_4;
    }
    while (2)
    {
      uint64_t v32 = v30 - 1;
      if (v7 >= v6) {
        goto LABEL_46;
      }
      int v33 = (void *)(*(void *)(*a1 + 8) + 8 * v16 + 16);
      uint64_t v34 = v16;
      while (1)
      {
        int v35 = *((_DWORD *)v33 - 2);
        if ((v35 & 0xF8000000) != 0x70000000) {
          break;
        }
        ++v33;
        if (v10 == ++v34) {
          goto LABEL_46;
        }
      }
      if ((v35 & 0xF8000000) != 0x10000000)
      {
LABEL_46:
        uint64_t v31 = v32;
        goto LABEL_47;
      }
      uint64_t v31 = a2;
      if (v32 == a2) {
        goto LABEL_47;
      }
      uint64_t v36 = v34 + 2;
      int v37 = (char)v35;
      if (v36 >= v6)
      {
        while ((char)v35 != *v32)
        {
          if (--v32 == a2)
          {
LABEL_59:
            uint64_t v31 = a2;
            goto LABEL_47;
          }
        }
        goto LABEL_46;
      }
      uint64_t v38 = v30;
      while (1)
      {
        if (v37 != *(v38 - 1)) {
          goto LABEL_60;
        }
        if ((*v33 & 0xF8000000) != 0x10000000 || v38 >= v30) {
          break;
        }
        if (*v38 == (char)*v33) {
          goto LABEL_46;
        }
LABEL_60:
        --v32;
        int v39 = v38 - 2;
        --v38;
        if (v39 == a2) {
          goto LABEL_59;
        }
      }
      uint64_t v31 = v38 - 1;
LABEL_47:
      uint64_t v30 = lslow(a1, a2, v31, v11, v16 + 1);
      if (lslow(a1, v30, a3, v16 + 1, v6) != a3) {
        continue;
      }
      break;
    }
LABEL_88:
    uint64_t v56 = v11 + 1;
    if (lslow(a1, a2, v30, v56, v16)) {
      ldissect(a1, a2, v30, v56, v16);
    }
    a2 = v30;
LABEL_4:
    if (v7 < v6) {
      continue;
    }
    return a2;
  }
}

uint64_t lbackref(uint64_t *a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a4 < a5)
  {
    uint64_t v12 = a4;
    while (1)
    {
LABEL_3:
      uint64_t v14 = v12;
      while (2)
      {
        uint64_t v15 = *a1;
        uint64_t v16 = *(void *)(*a1 + 8);
        uint64_t v17 = *(void *)(v16 + 8 * v14);
        switch(((unint64_t)(v17 & 0xF8000000) - 0x10000000) >> 27)
        {
          case 0uLL:
            if (a2 == a3) {
              return 0;
            }
            int v26 = (char)*a2++;
            if (v26 != (char)v17) {
              return 0;
            }
            goto LABEL_5;
          case 1uLL:
            if (a2 == (unsigned char *)a1[4] && (a1[1] & 1) == 0) {
              goto LABEL_5;
            }
            if ((unint64_t)a2 >= a1[5] || *(a2 - 1) != 10) {
              return 0;
            }
            goto LABEL_4;
          case 2uLL:
            int v27 = (unsigned char *)a1[5];
            if (a2 == v27 && (a1[1] & 2) == 0) {
              goto LABEL_5;
            }
            if (a2 >= v27 || *a2 != 10) {
              return 0;
            }
LABEL_4:
            if ((*(unsigned char *)(v15 + 40) & 8) != 0) {
              goto LABEL_5;
            }
            return 0;
          case 3uLL:
            if (a2 == a3) {
              return 0;
            }
            ++a2;
            goto LABEL_5;
          case 4uLL:
            if (a2 == a3) {
              return 0;
            }
            uint64_t v28 = *(void *)(v15 + 24) + 32 * (v17 & 0x7FFFFFF);
            unsigned int v29 = *a2++;
            if ((*(unsigned char *)(v28 + 8) & *(unsigned char *)(*(void *)v28 + v29)) == 0) {
              return 0;
            }
            goto LABEL_5;
          case 0xAuLL:
          case 0x10uLL:
            goto LABEL_5;
          case 0xEuLL:
            ++v14;
            uint64_t v30 = *(void *)(v16 + 8 * v14);
            do
            {
              v14 += v30 & 0x7FFFFFF;
              uint64_t v30 = *(void *)(v16 + 8 * v14);
            }
            while ((v30 & 0xF8000000) != 0x90000000);
            goto LABEL_5;
          case 0x11uLL:
            uint64_t v31 = (unsigned char *)a1[4];
            if (a2 == v31 && (a1[1] & 1) == 0
              || (unint64_t)a2 < a1[5] && *(a2 - 1) == 10 && (*(unsigned char *)(v15 + 40) & 8) != 0)
            {
              goto LABEL_61;
            }
            if (a2 <= v31) {
              return 0;
            }
            uint64_t v32 = *(a2 - 1);
            if ((char)*(a2 - 1) < 0) {
              int v33 = __maskrune(*(a2 - 1), 0x500uLL);
            }
            else {
              int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v32 + 60) & 0x500;
            }
            uint64_t result = 0;
            if (v32 == 95 || v33) {
              return result;
            }
LABEL_61:
            if ((unint64_t)a2 >= a1[5]) {
              return 0;
            }
            int v37 = (char)*a2;
            uint64_t v38 = *a2;
            if ((v37 & 0x80000000) == 0) {
              goto LABEL_63;
            }
            goto LABEL_69;
          case 0x12uLL:
            uint64_t v34 = (unsigned char *)a1[5];
            if (a2 == v34 && (a1[1] & 2) == 0) {
              goto LABEL_67;
            }
            if (a2 >= v34) {
              return 0;
            }
            uint64_t v35 = *a2;
            if (v35 == 10)
            {
              if ((*(unsigned char *)(v15 + 40) & 8) != 0) {
                goto LABEL_67;
              }
LABEL_56:
              int v36 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v35 + 60) & 0x500;
              uint64_t result = 0;
              if (v35 == 95) {
                return result;
              }
              goto LABEL_66;
            }
            if ((v35 & 0x80) == 0) {
              goto LABEL_56;
            }
            int v36 = __maskrune(*a2, 0x500uLL);
            uint64_t result = 0;
            if (v35 == 95) {
              return result;
            }
LABEL_66:
            if (v36) {
              return result;
            }
LABEL_67:
            if ((unint64_t)a2 <= a1[4]) {
              return 0;
            }
            int v37 = (char)*(a2 - 1);
            uint64_t v38 = *(a2 - 1);
            if (v37 < 0)
            {
LABEL_69:
              int v39 = __maskrune(v37, 0x500uLL);
              if (v38 == 95) {
                goto LABEL_5;
              }
            }
            else
            {
LABEL_63:
              int v39 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x500;
              if (v38 == 95) {
                goto LABEL_5;
              }
            }
            if (!v39) {
              return 0;
            }
LABEL_5:
            ++v14;
            goto LABEL_6;
          default:
            uint64_t v12 = v14 + 1;
            unint64_t v18 = ((unint64_t)(v17 & 0xF8000000) - 939524096) >> 27;
            if (v18 == 4)
            {
              uint64_t result = lbackref(a1, a2, a3, v14 + 1, a5, a6, a7);
              if (result) {
                return result;
              }
              uint64_t v14 = (v17 & 0x7FFFFFF) + v12;
LABEL_6:
              if (v14 >= a5) {
                goto LABEL_79;
              }
              continue;
            }
            uint64_t result = 0;
            switch(v18)
            {
              case 0uLL:
                uint64_t v20 = v17 & 0x7FFFFFF;
                uint64_t v21 = a1[2];
                uint64_t v22 = *(void *)(v21 + 16 * v20 + 8);
                if (v22 == -1) {
                  return 0;
                }
                uint64_t v23 = *(void *)(v21 + 16 * v20);
                size_t v24 = v22 - v23;
                if (v22 != v23) {
                  goto LABEL_16;
                }
                if ((int)a7 > 100) {
                  return 0;
                }
                a7 = (a7 + 1);
LABEL_16:
                if (a2 > &a3[-v24] || memcmp(a2, (const void *)(a1[3] + v23), v24)) {
                  return 0;
                }
                do
                  uint64_t v25 = *(void *)(v16 + 8 * v14++);
                while (v25 != (v20 | 0x40000000));
                a2 += v24;
                goto LABEL_6;
              case 2uLL:
                ++a6;
                *(void *)(a1[7] + 8 * a6) = a2;
                if (v12 >= a5) {
                  goto LABEL_79;
                }
                goto LABEL_3;
              case 3uLL:
                uint64_t v40 = a1[7];
                if (a2 == *(unsigned char **)(v40 + 8 * a6))
                {
                  --a6;
                  if (v12 >= a5) {
                    goto LABEL_79;
                  }
                }
                else
                {
                  *(void *)(v40 + 8 * a6) = a2;
                  uint64_t result = lbackref(a1, a2, a3, v12 - (v17 & 0x7FFFFFF), a5, a6, a7);
                  if (result) {
                    return result;
                  }
                  --a6;
                  if (v12 >= a5) {
                    goto LABEL_79;
                  }
                }
                break;
              case 6uLL:
                uint64_t v41 = 16 * (v17 & 0x7FFFFFF);
                uint64_t v42 = a1[2];
                uint64_t v43 = *(void *)(v42 + v41);
                *(void *)(v42 + v41) = &a2[-a1[3]];
                uint64_t result = lbackref(a1, a2, a3, v12, a5, a6, a7);
                if (!result) {
                  *(void *)(a1[2] + v41) = v43;
                }
                return result;
              case 7uLL:
                uint64_t v44 = v17 & 0x7FFFFFF;
                uint64_t v45 = a1[2] + 16 * v44;
                uint64_t v46 = *(void *)(v45 + 8);
                *(void *)(v45 + 8) = &a2[-a1[3]];
                uint64_t result = lbackref(a1, a2, a3, v12, a5, a6, a7);
                if (!result) {
                  *(void *)(a1[2] + 16 * v44 + 8) = v46;
                }
                return result;
              case 8uLL:
                uint64_t result = lbackref(a1, a2, a3, v14 + 1, a5, a6, a7);
                if (result) {
                  return result;
                }
                uint64_t v47 = v14 + (v17 & 0x7FFFFFF) - 1;
                while (1)
                {
                  uint64_t v48 = *(void *)(*a1 + 8);
                  if ((*(void *)(v48 + 8 * v47) & 0xF8000000) == 0x90000000) {
                    break;
                  }
                  uint64_t v49 = v47 + 2;
                  uint64_t v50 = *(void *)(v48 + 8 * (v47 + 1)) & 0x7FFFFFFLL;
                  uint64_t v51 = v50 + v47 + 1;
                  uint64_t v52 = v50 + v47;
                  if ((*(void *)(v48 + 8 * v51) & 0xF8000000) == 0x88000000) {
                    uint64_t v47 = v52;
                  }
                  else {
                    uint64_t v47 = v51;
                  }
                  uint64_t result = lbackref(a1, a2, a3, v49, a5, a6, a7);
                  if (result) {
                    return result;
                  }
                }
                return 0;
              default:
                return result;
            }
            break;
        }
        break;
      }
    }
  }
LABEL_79:
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  else {
    return 0;
  }
}

uint64_t lstep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(void *)(v8 + 8 * v7);
      switch(((unint64_t)(v9 & 0xF8000000) - 0x8000000) >> 27)
      {
        case 1uLL:
          if (a5 == (char)v9) {
            goto LABEL_4;
          }
          break;
        case 2uLL:
          if ((a5 & 0xFFFFFFFD) == 0x81) {
            goto LABEL_4;
          }
          break;
        case 3uLL:
          if ((a5 & 0xFFFFFFFE) == 0x82) {
            goto LABEL_4;
          }
          break;
        case 4uLL:
          if (a5 <= 127) {
            goto LABEL_4;
          }
          break;
        case 5uLL:
          if (a5 <= 127)
          {
            uint64_t v11 = *(void *)(a1 + 24) + 32 * (v9 & 0x7FFFFFF);
            if ((*(unsigned char *)(v11 + 8) & *(unsigned char *)(*(void *)v11 + a5)) != 0) {
              goto LABEL_4;
            }
          }
          break;
        case 6uLL:
        case 7uLL:
        case 8uLL:
        case 0xBuLL:
        case 0xCuLL:
        case 0xDuLL:
        case 0x11uLL:
          *(unsigned char *)(a6 + a2 + 1) |= *(unsigned char *)(a6 + a2);
          break;
        case 9uLL:
          char v12 = *(unsigned char *)(a6 + a2);
          *(unsigned char *)(a6 + a2 + 1) |= v12;
          uint64_t v13 = v9 & 0x7FFFFFF;
          int v14 = *(unsigned __int8 *)(a6 + a2 - v13);
          char v15 = v14 | v12;
          *(unsigned char *)(a6 + a2 - v13) = v15;
          if (v14) {
            BOOL v16 = 1;
          }
          else {
            BOOL v16 = v15 == 0;
          }
          if (!v16)
          {
            v7 += ~v13;
            a2 = v7;
          }
          break;
        case 0xAuLL:
        case 0xEuLL:
          char v10 = *(unsigned char *)(a6 + a2);
          *(unsigned char *)(a6 + a2 + 1) |= v10;
          *(unsigned char *)(a6 + (v9 & 0x7FFFFFF) + a2) |= v10;
          break;
        case 0xFuLL:
          if (*(unsigned char *)(a6 + a2))
          {
            uint64_t v17 = *(void *)(v8 + 8 * v7 + 8);
            if ((v17 & 0xF8000000) == 0x90000000)
            {
              uint64_t v18 = 1;
            }
            else
            {
              uint64_t v18 = 1;
              do
              {
                v18 += v17 & 0x7FFFFFF;
                uint64_t v17 = *(void *)(v8 + 8 * (v18 + v7));
              }
              while ((v17 & 0xF8000000) != 0x90000000);
            }
            *(unsigned char *)(a6 + v18 + a2) |= *(unsigned char *)(a6 + a2);
          }
          break;
        case 0x10uLL:
          char v19 = *(unsigned char *)(a6 + a2);
          *(unsigned char *)(a6 + a2 + 1) |= v19;
          uint64_t v20 = v9 & 0x7FFFFFF;
          if ((*(void *)(*(void *)(a1 + 8) + 8 * (v20 + v7)) & 0xF8000000) != 0x90000000) {
            *(unsigned char *)(a6 + v20 + a2) |= v19;
          }
          break;
        case 0x12uLL:
          if (a5 == 133) {
            goto LABEL_4;
          }
          break;
        case 0x13uLL:
          if (a5 == 134) {
LABEL_4:
          }
            *(unsigned char *)(a2 + a6 + 1) |= *(unsigned char *)(a4 + a2);
          break;
        default:
          break;
      }
      ++v7;
      ++a2;
    }
    while (v7 != a3);
  }
  return a6;
}

void llvm_regfree(uint64_t a1)
{
  if (*(_DWORD *)a1 == 62053)
  {
    uint64_t v1 = *(void **)(a1 + 24);
    if (v1)
    {
      if (*(_DWORD *)v1 == 53829)
      {
        *(_DWORD *)a1 = 0;
        *(_DWORD *)uint64_t v1 = 0;
        uint64_t v2 = (void *)v1[1];
        if (v2) {
          free(v2);
        }
        uint64_t v3 = (void *)v1[3];
        if (v3) {
          free(v3);
        }
        __n128 v4 = (void *)v1[4];
        if (v4) {
          free(v4);
        }
        uint64_t v5 = (void *)v1[12];
        if (v5) {
          free(v5);
        }
        free(v1);
      }
    }
  }
}

unsigned __int8 *llvm_strlcpy(unsigned char *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = (unsigned __int8 *)a2;
  if (a3)
  {
    uint64_t v4 = a3 - 1;
    uint64_t v3 = (unsigned __int8 *)a2;
    while (v4)
    {
      int v5 = *v3++;
      *a1++ = v5;
      --v4;
      if (!v5) {
        return &v3[~a2];
      }
    }
    *a1 = 0;
  }
  while (*v3++)
    ;
  return &v3[~a2];
}

uint64_t llvm::xxh3_64bits(int8x16_t *a1, unint64_t a2, const unsigned __int8 *a3)
{
  if (a2 > 0x10)
  {
    if (a2 <= 0x80)
    {
      int8x16_t v4 = veorq_s8(*a1, (int8x16_t)xmmword_1811283C0);
      uint64_t v5 = ((v4.u64[1] * (unsigned __int128)v4.u64[0]) >> 64) ^ (v4.i64[1] * v4.i64[0]);
      uint64_t v6 = (int8x16_t *)((char *)a1 + a2);
      int8x16_t v7 = veorq_s8(*(int8x16_t *)((char *)&a1[-1] + a2), (int8x16_t)xmmword_1811283D0);
      uint64_t v8 = v5 - 0x61C8864E7A143579 * a2;
      uint64_t v9 = ((v7.u64[1] * (unsigned __int128)v7.u64[0]) >> 64) ^ (v7.i64[1] * v7.i64[0]);
      if (a2 >= 0x21)
      {
        int8x16_t v10 = veorq_s8(a1[1], (int8x16_t)xmmword_1811283E0);
        v8 += ((v10.u64[1] * (unsigned __int128)v10.u64[0]) >> 64) ^ (v10.i64[1] * v10.i64[0]);
        int8x16_t v11 = veorq_s8(v6[-2], (int8x16_t)xmmword_1811283F0);
        v9 += ((v11.u64[1] * (unsigned __int128)v11.u64[0]) >> 64) ^ (v11.i64[1] * v11.i64[0]);
        if (a2 >= 0x41)
        {
          int8x16_t v12 = veorq_s8(a1[2], (int8x16_t)xmmword_181128400);
          v8 += ((v12.u64[1] * (unsigned __int128)v12.u64[0]) >> 64) ^ (v12.i64[1] * v12.i64[0]);
          int8x16_t v13 = veorq_s8(v6[-3], (int8x16_t)xmmword_181128410);
          v9 += ((v13.u64[1] * (unsigned __int128)v13.u64[0]) >> 64) ^ (v13.i64[1] * v13.i64[0]);
          if (a2 >= 0x61)
          {
            int8x16_t v14 = veorq_s8(a1[3], (int8x16_t)xmmword_181128420);
            uint64_t v15 = ((v14.u64[1] * (unsigned __int128)v14.u64[0]) >> 64) ^ (v14.i64[1] * v14.i64[0]);
            int8x16_t v16 = veorq_s8(v6[-4], (int8x16_t)xmmword_181128430);
            v8 += v15;
            v9 += ((v16.u64[1] * (unsigned __int128)v16.u64[0]) >> 64) ^ (v16.i64[1] * v16.i64[0]);
          }
        }
      }
      unint64_t v3 = v9 + v8;
      return (0x165667919E3779F9 * (v3 ^ (v3 >> 37))) ^ ((0x165667919E3779F9 * (v3 ^ (v3 >> 37))) >> 32);
    }
    if (a2 > 0xF0) {
      return XXH3_hashLong_64b((const unsigned __int8 *)a1, a2, a3);
    }
    else {
      return XXH3_len_129to240_64b(a1, a2, a3);
    }
  }
  else
  {
    if (a2 >= 9)
    {
      unint64_t v3 = bswap64(a1->i64[0] ^ 0x6782737BEA4239B9)
         + a2
         + (*(uint64_t *)((char *)&a1->i64[-1] + a2) ^ 0xAF56BC3B0996523ALL)
         + ((((*(uint64_t *)((char *)&a1->i64[-1] + a2) ^ 0xAF56BC3B0996523ALL)
            * (unsigned __int128)(a1->i64[0] ^ 0x6782737BEA4239B9uLL)) >> 64) ^ ((*(uint64_t *)((char *)&a1->i64[-1] + a2) ^ 0xAF56BC3B0996523ALL)
                                                                               * (a1->i64[0] ^ 0x6782737BEA4239B9)));
      return (0x165667919E3779F9 * (v3 ^ (v3 >> 37))) ^ ((0x165667919E3779F9 * (v3 ^ (v3 >> 37))) >> 32);
    }
    if (a2 < 4)
    {
      if (a2) {
        return XXH3_len_1to3_64b((const unsigned __int8 *)a1, a2, a3);
      }
      else {
        return 0x2D06800538D394C2;
      }
    }
    else
    {
      unint64_t v18 = (*(unsigned int *)((char *)&a1->u32[-1] + a2) | ((unint64_t)a1->u32[0] << 32)) ^ 0xC73AB174C5ECD5A2;
      unint64_t v19 = 0x9FB21C651E98DF25 * (__ROR8__(v18, 15) ^ __ROR8__(v18, 40) ^ v18);
      return (0x9FB21C651E98DF25 * ((a2 + (v19 >> 35)) ^ v19)) ^ ((0x9FB21C651E98DF25 * ((a2 + (v19 >> 35)) ^ v19)) >> 28);
    }
  }
}

unint64_t XXH3_len_129to240_64b(int8x16_t *a1, unint64_t a2, const unsigned __int8 *a3)
{
  int8x16_t v3 = veorq_s8(a1[2], (int8x16_t)xmmword_1811283E0);
  uint64_t v4 = v3.i64[1];
  uint64_t v5 = v3.i64[0];
  int8x16_t v6 = veorq_s8(a1[3], (int8x16_t)xmmword_1811283F0);
  uint64_t v7 = v6.i64[1];
  uint64_t v8 = v6.i64[0];
  int8x16_t v9 = veorq_s8(a1[4], (int8x16_t)xmmword_181128400);
  uint64_t v10 = v9.i64[1];
  uint64_t v11 = v9.i64[0];
  int8x16_t v12 = veorq_s8(a1[5], (int8x16_t)xmmword_181128410);
  uint64_t v13 = v12.i64[1];
  uint64_t v14 = v12.i64[0];
  int8x16_t v15 = veorq_s8(a1[6], (int8x16_t)xmmword_181128420);
  uint64_t v16 = ((((a1->i64[1] ^ 0x1CAD21F72C81017CuLL) * (unsigned __int128)(a1->i64[0] ^ 0xBE4BA423396CFEB8)) >> 64) ^ ((a1->i64[1] ^ 0x1CAD21F72C81017CLL) * (a1->i64[0] ^ 0xBE4BA423396CFEB8)))
      - 0x61C8864E7A143579 * a2
      + ((((a1[1].i64[1] ^ 0x1F67B3B7A4A44072uLL) * (unsigned __int128)(a1[1].i64[0] ^ 0xDB979083E96DD4DELL)) >> 64) ^ ((a1[1].i64[1] ^ 0x1F67B3B7A4A44072) * (a1[1].i64[0] ^ 0xDB979083E96DD4DELL)))
      + ((((unint64_t)v4 * (unsigned __int128)(unint64_t)v5) >> 64) ^ (v4 * v5))
      + ((((unint64_t)v7 * (unsigned __int128)(unint64_t)v8) >> 64) ^ (v7 * v8))
      + ((((unint64_t)v10 * (unsigned __int128)(unint64_t)v11) >> 64) ^ (v10 * v11));
  uint64_t v17 = ((((unint64_t)v13 * (unsigned __int128)(unint64_t)v14) >> 64) ^ (v13 * v14))
      + (((v15.u64[1] * (unsigned __int128)v15.u64[0]) >> 64) ^ (v15.i64[1] * v15.i64[0]));
  int8x16_t v18 = veorq_s8(a1[7], (int8x16_t)xmmword_181128430);
  uint64_t v19 = v17 + (((v18.u64[1] * (unsigned __int128)v18.u64[0]) >> 64) ^ (v18.i64[1] * v18.i64[0]));
  unint64_t v20 = 0x165667919E3779F9 * ((v16 + v19) ^ ((unint64_t)(v16 + v19) >> 37));
  uint64_t v21 = v20 ^ HIDWORD(v20);
  if ((a2 >> 4) >= 9)
  {
    uint64_t v22 = (a2 >> 4);
    if ((unint64_t)(v22 - 8) < 4)
    {
      uint64_t v23 = 8;
LABEL_7:
      int v37 = &kSecret[2 * v23 - 16];
      uint64_t v38 = (const unsigned __int8 *)&a1[v23];
      uint64_t v39 = v22 - v23;
      do
      {
        int8x16_t v40 = *(int8x16_t *)v38;
        v38 += 16;
        int8x16_t v41 = veorq_s8(v40, *(int8x16_t *)((char *)v37 + 3));
        v21 += ((v41.u64[1] * (unsigned __int128)v41.u64[0]) >> 64) ^ (v41.i64[1] * v41.i64[0]);
        v37 += 2;
        --v39;
      }
      while (v39);
      goto LABEL_9;
    }
    unint64_t v24 = 0;
    uint64_t v25 = (a2 >> 4) & 3;
    uint64_t v26 = v22 - 8 - v25;
    uint64_t v23 = v22 - v25;
    int64x2_t v27 = 0uLL;
    int64x2_t v28 = (int64x2_t)(unint64_t)v21;
    do
    {
      unsigned int v29 = (const double *)((char *)&kSecret[v24 / 8] + 3);
      float64x2x2_t v45 = vld2q_f64(v29);
      uint64_t v30 = (const double *)((char *)&kSecret[v24 / 8 + 4] + 3);
      float64x2x2_t v46 = vld2q_f64(v30);
      i64 = (const double *)a1[v24 / 0x10 + 8].i64;
      float64x2x2_t v47 = vld2q_f64(i64);
      uint64_t v32 = (const double *)a1[v24 / 0x10 + 10].i64;
      float64x2x2_t v48 = vld2q_f64(v32);
      int8x16_t v33 = veorq_s8((int8x16_t)v47.val[0], (int8x16_t)v45.val[0]);
      int8x16_t v34 = veorq_s8((int8x16_t)v48.val[0], (int8x16_t)v46.val[0]);
      v45.val[0] = (float64x2_t)veorq_s8((int8x16_t)v47.val[1], (int8x16_t)v45.val[1]);
      v45.val[1] = (float64x2_t)veorq_s8((int8x16_t)v48.val[1], (int8x16_t)v46.val[1]);
      *(void *)&float64_t v35 = ((*(unint64_t *)&v45.val[1].f64[0] * (unsigned __int128)v34.u64[0]) >> 64) ^ (*(void *)&v45.val[1].f64[0] * v34.i64[0]);
      *(void *)&float64_t v36 = ((*(unint64_t *)&v45.val[1].f64[1] * (unsigned __int128)v34.u64[1]) >> 64) ^ (*(void *)&v45.val[1].f64[1] * v34.i64[1]);
      *(void *)&v45.val[1].f64[0] = ((*(unint64_t *)&v45.val[0].f64[0] * (unsigned __int128)v33.u64[0]) >> 64) ^ (*(void *)&v45.val[0].f64[0] * v33.i64[0]);
      *(void *)&v45.val[1].f64[1] = ((*(unint64_t *)&v45.val[0].f64[1] * (unsigned __int128)v33.u64[1]) >> 64) ^ (*(void *)&v45.val[0].f64[1] * v33.i64[1]);
      v46.val[0].f64[0] = v35;
      v46.val[0].f64[1] = v36;
      int64x2_t v28 = vaddq_s64(v28, (int64x2_t)v45.val[1]);
      int64x2_t v27 = vaddq_s64(v27, (int64x2_t)v46.val[0]);
      v24 += 64;
      v26 -= 4;
    }
    while (v26);
    uint64_t v21 = vaddvq_s64(vaddq_s64(v27, v28));
    if (v25) {
      goto LABEL_7;
    }
  }
LABEL_9:
  int8x16_t v42 = veorq_s8(*(int8x16_t *)((char *)&a1[-1] + a2), (int8x16_t)xmmword_181128440);
  unint64_t v43 = v21 + (((v42.u64[1] * (unsigned __int128)v42.u64[0]) >> 64) ^ (v42.i64[1] * v42.i64[0]));
  return (0x165667919E3779F9 * (v43 ^ (v43 >> 37))) ^ ((0x165667919E3779F9 * (v43 ^ (v43 >> 37))) >> 32);
}

unint64_t XXH3_hashLong_64b(const unsigned __int8 *a1, uint64_t a2, const unsigned __int8 *a3)
{
  unint64_t v3 = 0xC2B2AE3D27D4EB4FLL;
  unint64_t v4 = 0x85EBCA77C2B2AE63;
  unint64_t v5 = 0x27D4EB2F165667C5;
  unint64_t v6 = 0x165667B19E3779F9;
  unint64_t v7 = 3266489917;
  unint64_t v8 = 2246822519;
  unint64_t v65 = a2 - 1;
  if ((unint64_t)(a2 - 1) >= 0x400)
  {
    uint64_t v11 = 0;
    unint64_t v12 = (unint64_t)(a2 - 1) >> 10;
    uint64_t v13 = a1;
    unint64_t v9 = 2654435761;
    unint64_t v10 = 0x9E3779B185EBCA87;
    do
    {
      uint64_t v14 = 0;
      int8x16_t v15 = kSecret;
      uint64_t v16 = kSecret;
      do
      {
        unint64_t v18 = *(void *)&v13[v14];
        unint64_t v17 = *(void *)&v13[v14 + 8];
        unint64_t v19 = v7 + (*(_DWORD *)v15 ^ v18) * ((*v15 ^ v18) >> 32);
        uint64_t v20 = v16[1];
        ++v16;
        v10 += v18 + (v20 ^ v17) * ((v20 ^ v17) >> 32);
        unint64_t v21 = *(void *)&v13[v14 + 16];
        unint64_t v22 = *(void *)&v13[v14 + 24];
        unint64_t v23 = v3 + (*((_DWORD *)v15 + 4) ^ v21) * ((v15[2] ^ v21) >> 32);
        v6 += v21 + (*((_DWORD *)v15 + 6) ^ v22) * ((v15[3] ^ v22) >> 32);
        unint64_t v24 = *(void *)&v13[v14 + 32];
        unint64_t v25 = *(void *)&v13[v14 + 40];
        unint64_t v7 = v19 + v17;
        unint64_t v3 = v23 + v22;
        v4 += (*((_DWORD *)v15 + 8) ^ v24) * ((v15[4] ^ v24) >> 32) + v25;
        v8 += v24 + (v15[5] ^ v25) * ((v15[5] ^ v25) >> 32);
        unint64_t v26 = *(void *)&v13[v14 + 48];
        uint64_t v27 = *(void *)&v13[v14 + 56];
        v5 += (*((_DWORD *)v15 + 12) ^ v26) * ((v15[6] ^ v26) >> 32) + v27;
        v9 += v26
            + (v15[7] ^ v27)
            * (unint64_t)(HIDWORD(v15[7]) ^ HIDWORD(v27));
        v14 += 64;
        int8x16_t v15 = v16;
      }
      while (v14 != 1024);
      unint64_t v7 = 2654435761u * (v7 ^ (v7 >> 47) ^ 0xC3EBD33483ACC5EALL);
      unint64_t v10 = 2654435761u * (v10 ^ (v10 >> 47) ^ 0xEB6313FAFFA081C5);
      unint64_t v3 = 2654435761u * (v3 ^ (v3 >> 47) ^ 0x49DAF0B751DD0D17);
      unint64_t v6 = 2654435761u * (v6 ^ (v6 >> 47) ^ 0x9E68D429265516D3);
      unint64_t v4 = 2654435761u * (v4 ^ (v4 >> 47) ^ 0xFCA1477D58BE162BLL);
      unint64_t v8 = 2654435761u * (v8 ^ (v8 >> 47) ^ 0xCE31D07AD1B8F88FLL);
      unint64_t v5 = 2654435761u * (v5 ^ (v5 >> 47) ^ 0x280416958F3ACB45);
      unint64_t v9 = 2654435761u * (v9 ^ (v9 >> 47) ^ 0x7E404BBBCAFBD7AFLL);
      ++v11;
      v13 += 1024;
    }
    while (v11 != v12);
  }
  else
  {
    unint64_t v9 = 2654435761;
    unint64_t v10 = 0x9E3779B185EBCA87;
  }
  uint64_t v28 = (v65 >> 6) & 0xF;
  if (v28)
  {
    uint64_t v29 = 0;
    uint64_t v30 = a1;
    uint64_t v31 = a2;
    uint64_t v32 = &a1[v65 & 0xFFFFFFFFFFFFFC00];
    uint64_t v33 = v28 << 6;
    int8x16_t v34 = kSecret;
    float64_t v35 = kSecret;
    do
    {
      unint64_t v36 = *(void *)&v32[v29];
      unint64_t v37 = *(void *)&v32[v29 + 8];
      unint64_t v38 = v7 + (*(_DWORD *)v34 ^ v36) * ((*v34 ^ v36) >> 32);
      uint64_t v39 = v35[1];
      ++v35;
      v10 += v36 + (v39 ^ v37) * ((v39 ^ v37) >> 32);
      unint64_t v40 = *(void *)&v32[v29 + 16];
      unint64_t v41 = *(void *)&v32[v29 + 24];
      unint64_t v42 = v3 + (*((_DWORD *)v34 + 4) ^ v40) * ((v34[2] ^ v40) >> 32);
      v6 += v40 + (*((_DWORD *)v34 + 6) ^ v41) * ((v34[3] ^ v41) >> 32);
      unint64_t v43 = *(void *)&v32[v29 + 32];
      unint64_t v44 = *(void *)&v32[v29 + 40];
      unint64_t v7 = v38 + v37;
      unint64_t v3 = v42 + v41;
      v4 += (*((_DWORD *)v34 + 8) ^ v43) * ((v34[4] ^ v43) >> 32) + v44;
      v8 += v43 + (v34[5] ^ v44) * ((v34[5] ^ v44) >> 32);
      unint64_t v46 = *(void *)&v32[v29 + 48];
      unint64_t v45 = *(void *)&v32[v29 + 56];
      v5 += (*((_DWORD *)v34 + 12) ^ v46) * ((v34[6] ^ v46) >> 32) + v45;
      v9 += v46 + (*((_DWORD *)v34 + 14) ^ v45) * ((v34[7] ^ v45) >> 32);
      v29 += 64;
      int8x16_t v34 = v35;
    }
    while (v33 != v29);
  }
  else
  {
    uint64_t v30 = a1;
    uint64_t v31 = a2;
  }
  uint64_t v47 = *(void *)&v30[v31 - 64];
  uint64_t v48 = *(void *)&v30[v31 - 56];
  unint64_t v49 = v7 + (v47 ^ 0xD9C97E9F) * ((v47 ^ 0xEA647378D9C97E9FLL) >> 32);
  unint64_t v50 = v10 + v47 + (v48 ^ 0x3483ACC5) * ((v48 ^ 0xC5C3EBD33483ACC5) >> 32);
  uint64_t v51 = *(void *)&v30[v31 - 48];
  uint64_t v52 = *(void *)&v30[v31 - 40];
  unint64_t v53 = v3 + (v51 ^ 0xFAFFA081) * ((v51 ^ 0x17EB6313FAFFA081uLL) >> 32);
  unint64_t v54 = v6 + v51 + (v52 ^ 0xB751DD0D) * ((v52 ^ 0xD349DAF0B751DD0DLL) >> 32);
  uint64_t v55 = *(void *)&v30[v31 - 32];
  uint64_t v56 = *(void *)&v30[v31 - 24];
  uint64_t v57 = v4 + (v55 ^ 0x29265516) * ((v55 ^ 0x2B9E68D429265516uLL) >> 32) + v56;
  unint64_t v58 = v8 + v55 + (v56 ^ 0x7D58BE16) * ((v56 ^ 0x8FFCA1477D58BE16) >> 32);
  uint64_t v59 = *(void *)&v30[v31 - 16];
  uint64_t v60 = *(void *)&v30[v31 - 8];
  uint64_t v61 = v5 + (v59 ^ 0x7AD1B8F8) * (unint64_t)(HIDWORD(v59) ^ 0x45CE31D0u) + v60;
  unint64_t v62 = v9 + v59 + (v60 ^ 0x958F3ACB) * ((v60 ^ 0xAF280416958F3ACBLL) >> 32);
  unint64_t v63 = ((((v50 ^ 0xA44072DB979083E9) * (unsigned __int128)((v49 + v48) ^ 0x6DD4DE1CAD21F72CLL)) >> 64) ^ ((v50 ^ 0xA44072DB979083E9) * ((v49 + v48) ^ 0x6DD4DE1CAD21F72CLL)))
      - 0x61C8864E7A143579 * v31
      + ((((v54 ^ 0xD05A8278E5C0CC4ELL) * (unsigned __int128)((v53 + v52) ^ 0xE679CB1F67B3B7A4)) >> 64) ^ ((v54 ^ 0xD05A8278E5C0CC4ELL) * ((v53 + v52) ^ 0xE679CB1F67B3B7A4)))
      + ((((v58 ^ 0x9035E08E2443F774) * (unsigned __int128)(v57 ^ 0x4608B82172FFCC7DuLL)) >> 64) ^ ((v58 ^ 0x9035E08E2443F774) * (v57 ^ 0x4608B82172FFCC7DLL)))
      + ((((v62 ^ 0x65D088CB00C391BBLL) * (unsigned __int128)(v61 ^ 0x52283C4C263A81E6uLL)) >> 64) ^ ((v62 ^ 0x65D088CB00C391BBLL) * (v61 ^ 0x52283C4C263A81E6)));
  return (0x165667919E3779F9 * (v63 ^ (v63 >> 37))) ^ ((0x165667919E3779F9 * (v63 ^ (v63 >> 37))) >> 32);
}

unint64_t XXH3_len_1to3_64b(const unsigned __int8 *a1, unint64_t a2, const unsigned __int8 *a3)
{
  unint64_t v3 = 0xC2B2AE3D27D4EB4FLL
     * (((a2 << 8) | ((unint64_t)*a1 << 16) | ((unint64_t)a1[a2 >> 1] << 24) | a1[a2 - 1]) ^ 0x87275A9B);
  return (0x165667B19E3779F9 * (v3 ^ (v3 >> 29))) ^ ((0x165667B19E3779F9 * (v3 ^ (v3 >> 29))) >> 32);
}

uint64_t llvm::sys::StrError@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (this)
  {
    __strerrbuf[0] = 0;
    strerror_r(this, __strerrbuf, 0x7CFuLL);
    return MEMORY[0x1852FD9E0](a2, __strerrbuf);
  }
  return this;
}

unint64_t llvm::sys::path::begin@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  unint64_t v5 = (unsigned __int8 *)result;
  *(void *)a4 = result;
  *(void *)(a4 + 8) = a2;
  uint64_t v20 = (unsigned __int8 *)result;
  unint64_t v21 = a2;
  if (!a2)
  {
    uint64_t v8 = 0;
    goto LABEL_55;
  }
  if (a3 >= 2)
  {
    uint64_t result = *(unsigned __int8 *)result;
    if (a2 < 2) {
      goto LABEL_38;
    }
    if ((result & 0x80) != 0)
    {
      uint64_t result = __maskrune(result, 0x100uLL);
      if (!result) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t result = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * result + 60) & 0x100;
      if (!result) {
        goto LABEL_11;
      }
    }
    if (v5[1] == 58)
    {
      uint64_t v8 = 2;
      goto LABEL_55;
    }
  }
LABEL_11:
  uint64_t result = *v5;
  if (a2 >= 3)
  {
    BOOL v9 = a3 > 1 && result == 92;
    BOOL v10 = v9;
    BOOL v11 = result != 47 && !v10;
    if (!v11 && result == v5[1])
    {
      int v12 = v5[2];
      BOOL v13 = a3 > 1 && v12 == 92;
      BOOL v14 = v13;
      if (v12 != 47 && !v14)
      {
        if (a3 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = 2;
        }
        if (a3 <= 1) {
          uint64_t v16 = "/";
        }
        else {
          uint64_t v16 = "\\/";
        }
        unint64_t v17 = 2;
LABEL_53:
        uint64_t result = llvm::StringRef::find_first_of(&v20, (unsigned __int8 *)v16, v15, v17);
        unint64_t v5 = v20;
        uint64_t v8 = v21;
        if (v21 >= result) {
          uint64_t v8 = result;
        }
        goto LABEL_55;
      }
    }
  }
LABEL_38:
  BOOL v19 = a3 > 1 && result == 92;
  uint64_t v8 = 1;
  if (result != 47 && !v19)
  {
    if (a3 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = 2;
    }
    if (a3 <= 1) {
      uint64_t v16 = "/";
    }
    else {
      uint64_t v16 = "\\/";
    }
    unint64_t v17 = 0;
    goto LABEL_53;
  }
LABEL_55:
  *(void *)(a4 + 16) = v5;
  *(void *)(a4 + 24) = v8;
  *(void *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 40) = a3;
  return result;
}

void *llvm::sys::path::const_iterator::operator++(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result + 2;
  unint64_t v3 = result[3];
  unint64_t v4 = result[4] + v3;
  result[4] = v4;
  unint64_t v5 = result[1];
  if (v4 == v5)
  {
    *uint64_t v2 = 0;
    result[3] = 0;
    return result;
  }
  if (v3 <= 2)
  {
    BOOL v12 = 0;
    unsigned int v8 = *((_DWORD *)result + 10);
    uint64_t v13 = *result;
    int v14 = *(unsigned __int8 *)(*result + v4);
    if (v14 != 47) {
      goto LABEL_24;
    }
  }
  else
  {
    unint64_t v6 = (unsigned __int8 *)result[2];
    int v7 = *v6;
    unsigned int v8 = *((_DWORD *)result + 10);
    if (v7 == 47 || (v7 == 92 ? (BOOL v9 = v8 >= 2) : (BOOL v9 = 0), v9))
    {
      if (v6[1] == v7)
      {
        int v10 = v6[2];
        BOOL v12 = v8 < 2 || v10 != 92;
        if (v10 == 47) {
          BOOL v12 = 0;
        }
        uint64_t v13 = *result;
        int v14 = *(unsigned __int8 *)(*result + v4);
        if (v14 == 47) {
          goto LABEL_43;
        }
LABEL_24:
        if (v14 != 92 || v8 < 2) {
          goto LABEL_28;
        }
        goto LABEL_43;
      }
    }
    BOOL v12 = 0;
    uint64_t v13 = *result;
    int v14 = *(unsigned __int8 *)(*result + v4);
    if (v14 != 47) {
      goto LABEL_24;
    }
  }
LABEL_43:
  if (v12 || v3 && v8 >= 2 && *(unsigned char *)(*v2 + v3 - 1) == 58)
  {
    if (v5 >= v4) {
      unint64_t v22 = v4;
    }
    else {
      unint64_t v22 = result[1];
    }
    result[2] = v13 + v22;
    result[3] = v5 > v4;
    return result;
  }
  while (1)
  {
    int v23 = *(unsigned __int8 *)(v13 + v4);
    BOOL v24 = v8 > 1 && v23 == 92;
    BOOL v25 = v24;
    if (v23 != 47 && !v25) {
      break;
    }
    result[4] = ++v4;
    if (v5 == v4)
    {
      if (v3 != 1 || *(unsigned char *)*v2 != 47)
      {
        result[4] = v5 - 1;
        result[2] = ".";
        result[3] = 1;
        return result;
      }
      goto LABEL_29;
    }
  }
LABEL_28:
  unint64_t v5 = v4;
LABEL_29:
  if (v8 <= 1) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = 2;
  }
  if (v8 <= 1) {
    unint64_t v17 = "/";
  }
  else {
    unint64_t v17 = "\\/";
  }
  unint64_t first_of = llvm::StringRef::find_first_of(result, (unsigned __int8 *)v17, v16, v5);
  unint64_t v19 = v1[4];
  unint64_t v20 = v1[1];
  if (v20 >= v19) {
    unint64_t v21 = v1[4];
  }
  else {
    unint64_t v21 = v1[1];
  }
  if (v21 <= first_of) {
    unint64_t v19 = first_of;
  }
  if (v19 >= v20) {
    unint64_t v19 = v1[1];
  }
  v1[2] = *v1 + v21;
  v1[3] = v19 - v21;
  return v1;
}

unsigned __int8 **llvm::sys::path::reverse_iterator::operator++(unsigned __int8 **a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  unsigned int v4 = *((_DWORD *)a1 + 10);
  uint64_t v47 = *a1;
  unint64_t v48 = v3;
  if (v4 >= 2 && v3 >= 3 && v2[1] == 58)
  {
    int v6 = v2[2];
    unint64_t first_of = 2;
    if (v6 == 47 || v6 == 92) {
      goto LABEL_47;
    }
  }
  if (v3 < 4)
  {
    if (!v3)
    {
LABEL_46:
      unint64_t first_of = -1;
      goto LABEL_47;
    }
    int v8 = *v2;
  }
  else
  {
    int v8 = *v2;
    BOOL v10 = v4 > 1 && v8 == 92;
    BOOL v11 = v8 != 47 && !v10;
    if (!v11 && v8 == v2[1])
    {
      int v12 = v2[2];
      BOOL v13 = v4 > 1 && v12 == 92;
      BOOL v14 = v13;
      if (v12 != 47 && !v14)
      {
        if (v4 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = 2;
        }
        if (v4 <= 1) {
          uint64_t v16 = "/";
        }
        else {
          uint64_t v16 = "\\/";
        }
        unint64_t first_of = llvm::StringRef::find_first_of(&v47, (unsigned __int8 *)v16, v15, 2uLL);
        goto LABEL_47;
      }
    }
  }
  unint64_t first_of = 0;
  BOOL v18 = v4 > 1 && v8 == 92;
  if (v8 != 47 && !v18) {
    goto LABEL_46;
  }
LABEL_47:
  unint64_t v19 = a1[4];
  if (v19)
  {
    unint64_t v20 = first_of + 1;
    unint64_t v21 = a1[4];
    while ((unsigned __int8 *)v20 != v21)
    {
      int v22 = v21[(void)*a1 - 1];
      if (v22 != 47 && (v22 != 92 || *((_DWORD *)a1 + 10) < 2u))
      {
        unint64_t v20 = (unint64_t)v21;
        break;
      }
      if (!--v21) {
        goto LABEL_63;
      }
    }
    BOOL v24 = *a1;
    BOOL v25 = a1[1];
    if (v19 != v25 || v25 == 0) {
      goto LABEL_75;
    }
  }
  else
  {
LABEL_63:
    unint64_t v20 = 0;
    BOOL v24 = *a1;
    BOOL v25 = a1[1];
    if (v19 != v25 || v25 == 0) {
      goto LABEL_75;
    }
  }
  uint64_t v28 = v19 - 1;
  int v29 = v28[(void)v24];
  if (v29 == 47 || (v29 == 92 ? (BOOL v30 = *((_DWORD *)a1 + 10) >= 2u) : (BOOL v30 = 0), v30))
  {
    if (first_of == -1 || v20 - 1 > first_of)
    {
      a1[4] = v28;
      a1[2] = ".";
      a1[3] = (unsigned __int8 *)1;
      return a1;
    }
  }
LABEL_75:
  unsigned int v31 = *((_DWORD *)a1 + 10);
  if ((unint64_t)v25 >= v20) {
    unint64_t v32 = v20;
  }
  else {
    unint64_t v32 = (unint64_t)v25;
  }
  uint64_t v47 = v24;
  unint64_t v48 = v32;
  if (v32)
  {
    unint64_t v33 = v32 - 1;
    int v34 = v24[v32 - 1];
    if (v34 == 47 || v31 >= 2 && v34 == 92) {
      goto LABEL_108;
    }
  }
  else
  {
    unint64_t v33 = -1;
  }
  if (v31 <= 1) {
    uint64_t v35 = 1;
  }
  else {
    uint64_t v35 = 2;
  }
  if (v31 <= 1) {
    unint64_t v36 = "/";
  }
  else {
    unint64_t v36 = "\\/";
  }
  uint64_t last_of = llvm::StringRef::find_last_of(&v47, (unsigned __int8 *)v36, v35, v33);
  if (v31 >= 2 && last_of == -1)
  {
    unint64_t v38 = v48 - 2;
    if (v48 < v48 - 2) {
      unint64_t v38 = v48;
    }
    while (v38)
    {
      uint64_t last_of = v38 - 1;
      int v39 = v47[--v38];
      if (v39 == 58) {
        goto LABEL_96;
      }
    }
  }
  else
  {
LABEL_96:
    if (last_of != -1)
    {
      if (last_of != 1
        || ((unint64_t v33 = 0, v40 = *v47, v31 > 1) ? (v41 = v40 == 92) : (v41 = 0),
            !v41 ? (char v42 = 0) : (char v42 = 1),
            v40 != 47 && (v42 & 1) == 0))
      {
        unint64_t v33 = last_of + 1;
      }
      goto LABEL_108;
    }
  }
  unint64_t v33 = 0;
LABEL_108:
  unint64_t v43 = (unint64_t)a1[1];
  if (v43 >= v33) {
    unint64_t v44 = v33;
  }
  else {
    unint64_t v44 = (unint64_t)a1[1];
  }
  if (v44 <= v20) {
    unint64_t v45 = v20;
  }
  else {
    unint64_t v45 = v33;
  }
  if (v45 < v43) {
    unint64_t v43 = v45;
  }
  a1[2] = &(*a1)[v44];
  a1[3] = (unsigned __int8 *)(v43 - v44);
  a1[4] = (unsigned __int8 *)v33;
  return a1;
}

unint64_t llvm::sys::path::root_path(unint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v5 = a1;
  llvm::sys::path::begin(a1, a2, a3, (uint64_t)&v21);
  long long v18 = v21;
  long long v19 = v22;
  long long v20 = v23;
  if ((void)v21 == v5 && (void)v23 == a2) {
    return 0;
  }
  if (*((void *)&v22 + 1) < 3uLL)
  {
    BOOL v8 = 0;
  }
  else
  {
    int v7 = *(unsigned __int8 *)v22;
    if (v7 == 47 || (BOOL v8 = 0, a3 >= 2) && v7 == 92) {
      BOOL v8 = *(unsigned __int8 *)(v22 + 1) == v7;
    }
  }
  BOOL v9 = 0;
  if (*((void *)&v22 + 1) && a3 >= 2) {
    BOOL v9 = *(unsigned __int8 *)(v22 + *((void *)&v22 + 1) - 1) == 58;
  }
  if (v8 || v9)
  {
    llvm::sys::path::const_iterator::operator++(&v18);
    if ((void)v18 == v5 && (void)v20 == a2) {
      return v22;
    }
    int v10 = *(unsigned __int8 *)v19;
    BOOL v11 = a3 > 1 && v10 == 92;
    BOOL v12 = v11;
    if (v10 != 47 && !v12) {
      return v22;
    }
  }
  else
  {
    int v14 = *(unsigned __int8 *)v22;
    if (a3 > 1 && v14 == 92 || v14 == 47) {
      return v22;
    }
    else {
      return 0;
    }
  }
  return v5;
}

uint64_t llvm::sys::path::root_directory(unint64_t a1, unint64_t a2, unsigned int a3)
{
  llvm::sys::path::begin(a1, a2, a3, (uint64_t)&v21);
  long long v18 = v21;
  long long v19 = v22;
  long long v20 = v23;
  if ((void)v21 == a1 && (void)v23 == a2) {
    return 0;
  }
  if (*((void *)&v22 + 1) < 3uLL)
  {
    BOOL v8 = 0;
  }
  else
  {
    int v7 = *(unsigned __int8 *)v22;
    if (v7 == 47 || (BOOL v8 = 0, a3 >= 2) && v7 == 92) {
      BOOL v8 = *(unsigned __int8 *)(v22 + 1) == v7;
    }
  }
  BOOL v9 = 0;
  if (*((void *)&v22 + 1) && a3 >= 2) {
    BOOL v9 = *(unsigned __int8 *)(v22 + *((void *)&v22 + 1) - 1) == 58;
  }
  if (!v8 && !v9
    || (llvm::sys::path::const_iterator::operator++(&v18), (void)v18 == a1) && (void)v20 == a2
    || ((uint64_t result = v19, v11 = *(unsigned __int8 *)v19, a3 > 1) ? (v12 = v11 == 92) : (v12 = 0),
        !v12 ? (int v13 = 0) : (int v13 = 1),
        v11 != 47 ? (BOOL v14 = v13 == 0) : (BOOL v14 = 0),
        v14))
  {
    if (!v8)
    {
      int v15 = *(unsigned __int8 *)v22;
      if (a3 > 1 && v15 == 92 || v15 == 47) {
        return v22;
      }
      else {
        return 0;
      }
    }
    return 0;
  }
  return result;
}

void llvm::sys::path::append(void *a1, const llvm::Twine *a2, void **a3, void **a4, const char **a5, void **a6)
{
  v72[4] = *MEMORY[0x1E4F143B8];
  int v70 = (char *)v72;
  long long v71 = xmmword_1810FE500;
  uint64_t v67 = v69;
  long long v68 = xmmword_1810FE500;
  uint64_t v64 = v66;
  long long v65 = xmmword_1810FE500;
  uint64_t v61 = v63;
  long long v62 = xmmword_1810FE500;
  unint64_t v58 = v60;
  uint64_t v59 = 0x400000000;
  unsigned int v11 = *((unsigned __int8 *)a3 + 32);
  if (v11 < 2)
  {
    unsigned int v12 = 0;
    unsigned int v13 = *((unsigned __int8 *)a4 + 32);
    if (v13 < 2) {
      goto LABEL_3;
    }
LABEL_69:
    if (*((unsigned char *)a4 + 33) == 1)
    {
      if (v13 - 5 < 2)
      {
        BOOL v41 = *a4;
        size_t v42 = (size_t)a4[1];
        if (v12 < HIDWORD(v59)) {
          goto LABEL_77;
        }
        goto LABEL_108;
      }
      if (v13 == 4)
      {
        int v50 = *((char *)*a4 + 23);
        if (v50 >= 0) {
          BOOL v41 = *a4;
        }
        else {
          BOOL v41 = (void *)**a4;
        }
        if (v50 >= 0) {
          size_t v42 = *((unsigned __int8 *)*a4 + 23);
        }
        else {
          size_t v42 = (*a4)[1];
        }
        if (v12 >= HIDWORD(v59)) {
          goto LABEL_108;
        }
        goto LABEL_77;
      }
      if (v13 == 3)
      {
        BOOL v41 = *a4;
        if (*a4)
        {
          size_t v42 = strlen((const char *)*a4);
          if (v12 < HIDWORD(v59)) {
            goto LABEL_77;
          }
          goto LABEL_108;
        }
        size_t v42 = 0;
        if (v12 >= HIDWORD(v59))
        {
LABEL_108:
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v12 + 1, 16);
          unsigned int v12 = v59;
        }
LABEL_77:
        unint64_t v43 = (char *)v58 + 16 * v12;
        *unint64_t v43 = v41;
        v43[1] = v42;
        unsigned int v12 = v59 + 1;
        LODWORD(v59) = v59 + 1;
        unsigned int v14 = *((unsigned __int8 *)a5 + 32);
        if (v14 < 2)
        {
LABEL_4:
          unsigned int v15 = *((unsigned __int8 *)a6 + 32);
          if (v15 < 2) {
            goto LABEL_5;
          }
LABEL_87:
          if (*((unsigned char *)a6 + 33) == 1)
          {
            if (v15 - 5 < 2)
            {
              uint64_t v47 = *a6;
              size_t v48 = (size_t)a6[1];
              if (v12 < HIDWORD(v59)) {
                goto LABEL_95;
              }
              goto LABEL_112;
            }
            if (v15 == 4)
            {
              int v52 = *((char *)*a6 + 23);
              if (v52 >= 0) {
                uint64_t v47 = *a6;
              }
              else {
                uint64_t v47 = (void *)**a6;
              }
              if (v52 >= 0) {
                size_t v48 = *((unsigned __int8 *)*a6 + 23);
              }
              else {
                size_t v48 = (*a6)[1];
              }
              if (v12 >= HIDWORD(v59)) {
                goto LABEL_112;
              }
              goto LABEL_95;
            }
            if (v15 == 3)
            {
              uint64_t v47 = *a6;
              if (*a6)
              {
                size_t v48 = strlen((const char *)*a6);
                if (v12 < HIDWORD(v59)) {
                  goto LABEL_95;
                }
                goto LABEL_112;
              }
              size_t v48 = 0;
              if (v12 >= HIDWORD(v59))
              {
LABEL_112:
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v12 + 1, 16);
                unsigned int v12 = v59;
              }
LABEL_95:
              unint64_t v49 = (char *)v58 + 16 * v12;
              *unint64_t v49 = v47;
              v49[1] = v48;
              unsigned int v12 = v59 + 1;
              LODWORD(v59) = v12;
              uint64_t v16 = (const char **)v58;
              if (v12) {
                goto LABEL_6;
              }
LABEL_96:
              if (v16 == (const char **)v60) {
                goto LABEL_98;
              }
              goto LABEL_97;
            }
          }
          llvm::Twine::toVector((uint64_t)a6, (uint64_t)&v61);
          uint64_t v47 = v61;
          size_t v48 = v62;
          unsigned int v12 = v59;
          if (v59 < HIDWORD(v59)) {
            goto LABEL_95;
          }
          goto LABEL_112;
        }
        goto LABEL_78;
      }
    }
    llvm::Twine::toVector((uint64_t)a4, (uint64_t)&v67);
    BOOL v41 = v67;
    size_t v42 = v68;
    unsigned int v12 = v59;
    if (v59 < HIDWORD(v59)) {
      goto LABEL_77;
    }
    goto LABEL_108;
  }
  if (*((unsigned char *)a3 + 33) != 1) {
    goto LABEL_58;
  }
  if (v11 - 5 < 2)
  {
    unsigned int v38 = 0;
    unint64_t v36 = (const char *)*a3;
    size_t v37 = (size_t)a3[1];
    goto LABEL_68;
  }
  if (v11 != 4)
  {
    if (v11 == 3)
    {
      unint64_t v36 = (const char *)*a3;
      if (*a3) {
        size_t v37 = strlen((const char *)*a3);
      }
      else {
        size_t v37 = 0;
      }
      unsigned int v38 = 0;
      goto LABEL_68;
    }
LABEL_58:
    llvm::Twine::toVector((uint64_t)a3, (uint64_t)&v70);
    unint64_t v36 = v70;
    size_t v37 = v71;
    unsigned int v38 = v59;
    goto LABEL_68;
  }
  unsigned int v38 = 0;
  int v39 = *((char *)*a3 + 23);
  if (v39 >= 0) {
    unint64_t v36 = (const char *)*a3;
  }
  else {
    unint64_t v36 = (const char *)**a3;
  }
  if (v39 >= 0) {
    size_t v37 = *((unsigned __int8 *)*a3 + 23);
  }
  else {
    size_t v37 = (*a3)[1];
  }
LABEL_68:
  int v40 = (const char **)((char *)v58 + 16 * v38);
  *int v40 = v36;
  v40[1] = (const char *)v37;
  unsigned int v12 = v59 + 1;
  LODWORD(v59) = v59 + 1;
  unsigned int v13 = *((unsigned __int8 *)a4 + 32);
  if (v13 >= 2) {
    goto LABEL_69;
  }
LABEL_3:
  unsigned int v14 = *((unsigned __int8 *)a5 + 32);
  if (v14 < 2) {
    goto LABEL_4;
  }
LABEL_78:
  if (*((unsigned char *)a5 + 33) != 1) {
    goto LABEL_85;
  }
  if (v14 - 5 < 2)
  {
    unint64_t v44 = *a5;
    size_t v45 = (size_t)a5[1];
    if (v12 < HIDWORD(v59)) {
      goto LABEL_86;
    }
    goto LABEL_110;
  }
  if (v14 == 4)
  {
    int v51 = (*a5)[23];
    if (v51 >= 0) {
      unint64_t v44 = *a5;
    }
    else {
      unint64_t v44 = *(void **)*a5;
    }
    if (v51 >= 0) {
      size_t v45 = *((unsigned __int8 *)*a5 + 23);
    }
    else {
      size_t v45 = *((void *)*a5 + 1);
    }
    if (v12 >= HIDWORD(v59)) {
      goto LABEL_110;
    }
    goto LABEL_86;
  }
  if (v14 != 3)
  {
LABEL_85:
    llvm::Twine::toVector((uint64_t)a5, (uint64_t)&v64);
    unint64_t v44 = v64;
    size_t v45 = v65;
    unsigned int v12 = v59;
    if (v59 < HIDWORD(v59)) {
      goto LABEL_86;
    }
    goto LABEL_110;
  }
  unint64_t v44 = *a5;
  if (*a5)
  {
    size_t v45 = strlen(*a5);
    if (v12 < HIDWORD(v59)) {
      goto LABEL_86;
    }
    goto LABEL_110;
  }
  size_t v45 = 0;
  if (v12 >= HIDWORD(v59))
  {
LABEL_110:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v12 + 1, 16);
    unsigned int v12 = v59;
  }
LABEL_86:
  unint64_t v46 = (char *)v58 + 16 * v12;
  *unint64_t v46 = v44;
  v46[1] = v45;
  unsigned int v12 = v59 + 1;
  LODWORD(v59) = v59 + 1;
  unsigned int v15 = *((unsigned __int8 *)a6 + 32);
  if (v15 >= 2) {
    goto LABEL_87;
  }
LABEL_5:
  uint64_t v16 = (const char **)v58;
  if (!v12) {
    goto LABEL_96;
  }
LABEL_6:
  if (a2 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = 2;
  }
  long long v18 = "/";
  if (a2 > 1) {
    long long v18 = "\\/";
  }
  unint64_t v54 = (unsigned __int8 *)v18;
  uint64_t v55 = v17;
  if (a2 <= 1) {
    int v19 = 1;
  }
  else {
    int v19 = (int)a2;
  }
  if (v19 == 3) {
    char v20 = 92;
  }
  else {
    char v20 = 47;
  }
  char v53 = v20;
  uint64_t v21 = a1[1];
  uint64_t v22 = 16 * v12;
  do
  {
    if (!v21
      || ((int v23 = *(unsigned __int8 *)(v21 + *a1 - 1), a2 > 1) ? (v24 = v23 == 92) : (v24 = 0),
          !v24 ? (int v25 = 0) : (int v25 = 1),
          v23 != 47 ? (BOOL v26 = v25 == 0) : (BOOL v26 = 0),
          v26))
    {
      unint64_t v33 = v16[1];
      if (!v33 || (int v34 = *(unsigned __int8 *)*v16, v34 != 47) && (a2 < 2 || v34 != 92))
      {
        if (v21)
        {
          __int16 v57 = 261;
          v56[0] = *v16;
          v56[1] = v33;
          char has_root_name = llvm::sys::path::has_root_name(v56, a2);
          uint64_t v21 = a1[1];
          if ((has_root_name & 1) == 0)
          {
            if ((unint64_t)(v21 + 1) > a1[2])
            {
              llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v21 + 1, 1);
              uint64_t v21 = a1[1];
            }
            *(unsigned char *)(*a1 + v21) = v53;
            uint64_t v21 = a1[1] + 1;
            a1[1] = v21;
          }
        }
      }
      unsigned int v31 = *v16;
      size_t v32 = (size_t)v16[1];
      if (a1[2] < v21 + v32)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v21 + v32, 1);
        uint64_t v21 = a1[1];
      }
      if (v32)
      {
LABEL_19:
        memcpy((void *)(*a1 + v21), v31, v32);
        uint64_t v21 = a1[1];
      }
    }
    else
    {
      unint64_t first_not_of = llvm::StringRef::find_first_not_of(v16, v54, v55, 0);
      unint64_t v28 = first_not_of;
      int v29 = (unsigned __int8 *)v16[1];
      if ((unint64_t)v29 >= first_not_of) {
        unint64_t v30 = first_not_of;
      }
      else {
        unint64_t v30 = (unint64_t)v16[1];
      }
      unsigned int v31 = &(*v16)[v30];
      size_t v32 = (size_t)&v29[-v30];
      uint64_t v21 = a1[1];
      if (a1[2] < (unint64_t)&v29[v21 - v30])
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, (unint64_t)&v29[v21 - v30], 1);
        uint64_t v21 = a1[1];
      }
      if ((unint64_t)v29 > v28) {
        goto LABEL_19;
      }
    }
    v21 += v32;
    a1[1] = v21;
    v16 += 2;
    v22 -= 16;
  }
  while (v22);
  uint64_t v16 = (const char **)v58;
  if (v58 != v60) {
LABEL_97:
  }
    free(v16);
LABEL_98:
  if (v61 != v63) {
    free(v61);
  }
  if (v64 != v66) {
    free(v64);
  }
  if (v67 != v69) {
    free(v67);
  }
  if (v70 != (char *)v72) {
    free(v70);
  }
}

uint64_t llvm::sys::path::has_root_name(const char **this, const llvm::Twine *a2)
{
  unsigned int v2 = a2;
  v20[16] = *MEMORY[0x1E4F143B8];
  long long v18 = v20;
  long long v19 = xmmword_1811019F0;
  if (*((unsigned char *)this + 33) == 1)
  {
    size_t v3 = 0;
    unsigned int v4 = 0;
    switch(*((unsigned char *)this + 32))
    {
      case 1:
        break;
      case 3:
        unsigned int v4 = (void *)*this;
        if (*this) {
          size_t v3 = strlen(*this);
        }
        else {
          size_t v3 = 0;
        }
        break;
      case 4:
        int v13 = (*this)[23];
        if (v13 >= 0) {
          unsigned int v4 = (void *)*this;
        }
        else {
          unsigned int v4 = *(void **)*this;
        }
        if (v13 >= 0) {
          size_t v3 = *((unsigned __int8 *)*this + 23);
        }
        else {
          size_t v3 = *((void *)*this + 1);
        }
        break;
      case 5:
      case 6:
        unsigned int v4 = (void *)*this;
        size_t v3 = (size_t)this[1];
        break;
      default:
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    llvm::Twine::toVector((uint64_t)this, (uint64_t)&v18);
    unsigned int v4 = v18;
    size_t v3 = v19;
  }
  llvm::sys::path::begin((unint64_t)v4, v3, v2, (uint64_t)&v14);
  if (v14 == v4 && v17 == v3)
  {
    uint64_t v8 = 0;
    BOOL v9 = v18;
    if (v18 == v20) {
      return v8;
    }
    goto LABEL_24;
  }
  if (v16 < 3)
  {
    BOOL v7 = 0;
  }
  else
  {
    int v6 = *v15;
    if (v6 == 47 || (BOOL v7 = 0, v2 >= 2) && v6 == 92) {
      BOOL v7 = v15[1] == v6;
    }
  }
  BOOL v10 = 0;
  if (v2 >= 2 && v16) {
    BOOL v10 = v15[v16 - 1] == 58;
  }
  unsigned int v11 = v7 || v10;
  if (v16) {
    uint64_t v8 = v11;
  }
  else {
    uint64_t v8 = 0;
  }
  BOOL v9 = v18;
  if (v18 != v20) {
LABEL_24:
  }
    free(v9);
  return v8;
}

void llvm::sys::path::append(void *a1, void **a2, void **a3, const char **a4, void **a5)
{
}

unsigned __int8 *llvm::sys::path::parent_path(unsigned __int8 *a1, unint64_t a2, unsigned int a3)
{
    return 0;
  else {
    return a1;
  }
}

unint64_t anonymous namespace'::parent_path_end(unsigned __int8 *a1, unint64_t a2, unsigned int a3)
{
  size_t v42 = a1;
  unint64_t v43 = a2;
  if (a2)
  {
    unint64_t v6 = a2 - 1;
    int v7 = a1[a2 - 1];
    if (v7 == 47 || a3 >= 2 && v7 == 92) {
      goto LABEL_34;
    }
  }
  else
  {
    unint64_t v6 = -1;
  }
  BOOL v8 = a3 > 1;
  if (a3 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = 2;
  }
  if (a3 <= 1) {
    BOOL v10 = "/";
  }
  else {
    BOOL v10 = "\\/";
  }
  uint64_t last_of = llvm::StringRef::find_last_of(&v42, (unsigned __int8 *)v10, v9, v6);
  if (a3 >= 2 && last_of == -1)
  {
    unint64_t v12 = v43 - 2;
    if (v43 < v43 - 2) {
      unint64_t v12 = v43;
    }
    while (v12)
    {
      uint64_t last_of = v12 - 1;
      int v13 = v42[--v12];
      if (v13 == 58) {
        goto LABEL_19;
      }
    }
    unint64_t v6 = 0;
    goto LABEL_32;
  }
LABEL_19:
  if (last_of == -1)
  {
    unint64_t v6 = 0;
    if (a2) {
      goto LABEL_33;
    }
    goto LABEL_95;
  }
  if (last_of == 1)
  {
    unint64_t v6 = 0;
    int v14 = *v42;
    BOOL v15 = a3 > 1 && v14 == 92;
    BOOL v16 = v15;
    if (v14 == 47 || v16)
    {
LABEL_32:
      if (a2) {
        goto LABEL_33;
      }
LABEL_95:
      int v19 = 0;
      goto LABEL_96;
    }
  }
  unint64_t v6 = last_of + 1;
  if (!a2) {
    goto LABEL_95;
  }
LABEL_33:
  int v7 = a1[v6];
LABEL_34:
  BOOL v18 = a3 > 1 && v7 == 92;
  int v19 = v7 == 47 || v18;
  size_t v42 = a1;
  unint64_t v43 = a2;
  BOOL v8 = a3 > 1;
  if (a3 >= 2 && a2 >= 3 && a1[1] == 58)
  {
    int v20 = a1[2];
    BOOL v21 = 1;
    unint64_t first_of = 2;
    if (v20 == 47 || v20 == 92) {
      goto LABEL_83;
    }
  }
  int v23 = *a1;
  if (a2 >= 4)
  {
    BOOL v24 = a3 > 1 && v23 == 92;
    BOOL v25 = v24;
    if ((v23 == 47 || v25) && v23 == a1[1])
    {
      int v26 = a1[2];
      BOOL v27 = a3 > 1 && v26 == 92;
      BOOL v28 = v27;
      if (v26 != 47 && !v28)
      {
        if (a3 <= 1) {
          uint64_t v29 = 1;
        }
        else {
          uint64_t v29 = 2;
        }
        if (a3 <= 1) {
          unint64_t v30 = "/";
        }
        else {
          unint64_t v30 = "\\/";
        }
        unint64_t first_of = llvm::StringRef::find_first_of(&v42, (unsigned __int8 *)v30, v29, 2uLL);
        if (first_of == -1) {
          goto LABEL_96;
        }
LABEL_84:
        if (v6 >= first_of) {
          unint64_t v33 = first_of;
        }
        else {
          unint64_t v33 = v6;
        }
        while (v6 > first_of)
        {
          unint64_t v34 = v6 - 1;
          int v35 = a1[v6 - 1];
          BOOL v36 = v35 == 92 && v8;
          --v6;
          if (v35 != 47)
          {
            unint64_t v6 = v34;
            if (!v36)
            {
              unint64_t v33 = v34 + 1;
              goto LABEL_105;
            }
          }
        }
        goto LABEL_105;
      }
    }
  }
  unint64_t first_of = 0;
  BOOL v32 = a3 > 1 && v23 == 92;
  if (v23 == 47 || v32)
  {
    BOOL v21 = a3 > 1;
LABEL_83:
    BOOL v8 = v21;
    goto LABEL_84;
  }
LABEL_96:
  while (v6)
  {
    unint64_t v37 = v6 - 1;
    int v38 = a1[v6 - 1];
    BOOL v39 = v38 == 92 && v8;
    --v6;
    if (v38 != 47)
    {
      unint64_t v6 = v37;
      if (!v39)
      {
        unint64_t v33 = v37 + 1;
        goto LABEL_104;
      }
    }
  }
  unint64_t v33 = 0;
LABEL_104:
  unint64_t first_of = -1;
LABEL_105:
  if (v33 == first_of) {
    int v40 = v19;
  }
  else {
    int v40 = 1;
  }
  if (v40) {
    return v33;
  }
  else {
    return first_of + 1;
  }
}

void llvm::SmallVectorImpl<char>::swap(void *a1, void *a2)
{
  if (a1 == a2) {
    return;
  }
  unsigned int v4 = (void *)*a1;
  if ((void *)*a1 != a1 + 3 && (void *)*a2 != a2 + 3)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = a2[1];
    *a1 = *a2;
    a1[1] = v6;
    *a2 = v4;
    a2[1] = v5;
    uint64_t v7 = a1[2];
    a1[2] = a2[2];
    a2[2] = v7;
    return;
  }
  unint64_t v8 = a2[1];
  if (a1[2] < v8)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v8, 1);
    unint64_t v9 = a1[1];
    if (a2[2] >= v9)
    {
LABEL_7:
      unint64_t v10 = a2[1];
      if (v9 >= v10) {
        unint64_t v11 = a2[1];
      }
      else {
        unint64_t v11 = v9;
      }
      if (!v11) {
        goto LABEL_11;
      }
      goto LABEL_20;
    }
  }
  else
  {
    unint64_t v9 = a1[1];
    if (a2[2] >= v9) {
      goto LABEL_7;
    }
  }
  llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v9, 1);
  unint64_t v9 = a1[1];
  unint64_t v10 = a2[1];
  if (v9 >= v10) {
    unint64_t v11 = a2[1];
  }
  else {
    unint64_t v11 = a1[1];
  }
  if (!v11)
  {
LABEL_11:
    unint64_t v12 = v9 - v10;
    if (v9 > v10) {
      goto LABEL_12;
    }
    goto LABEL_23;
  }
LABEL_20:
  for (uint64_t i = 0; i != v11; ++i)
  {
    uint64_t v14 = *a2;
    char v15 = *(unsigned char *)(*a1 + i);
    *(unsigned char *)(*a1 + i) = *(unsigned char *)(*a2 + i);
    *(unsigned char *)(v14 + i) = v15;
  }
  unint64_t v9 = a1[1];
  unint64_t v10 = a2[1];
  unint64_t v12 = v9 - v10;
  if (v9 > v10)
  {
LABEL_12:
    if (v11 != v9)
    {
      memcpy((void *)(*a2 + v10), (const void *)(*a1 + v11), *a1 + v9 - (*a1 + v11));
      unint64_t v10 = a2[1];
    }
    a2[1] = v12 + v10;
    a1[1] = v11;
    return;
  }
LABEL_23:
  unint64_t v16 = v10 - v9;
  if (v10 > v9)
  {
    if (v11 != v10)
    {
      memcpy((void *)(*a1 + v9), (const void *)(*a2 + v11), *a2 + v10 - (*a2 + v11));
      unint64_t v9 = a1[1];
    }
    a1[1] = v16 + v9;
    a2[1] = v11;
  }
}

void llvm::sys::path::native(void **a1, unsigned int a2)
{
  v22[16] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return;
  }
  unsigned int v4 = (char *)*a1;
  if (a2 > 1)
  {
    if (a2 == 3) {
      char v5 = 92;
    }
    else {
      char v5 = 47;
    }
    do
    {
      int v6 = *v4;
      if (v6 == 92 || v6 == 47) {
        *unsigned int v4 = v5;
      }
      ++v4;
      --v2;
    }
    while (v2);
    if (*(unsigned char *)*a1 != 126) {
      return;
    }
    if (a1[1] != (void *)1)
    {
      int v11 = *((unsigned __int8 *)*a1 + 1);
      if (v11 != 92 && v11 != 47) {
        return;
      }
    }
    __src = v22;
    long long v21 = xmmword_1811019F0;
    llvm::sys::path::home_directory(&__src);
    unint64_t v12 = (char *)*a1;
    int v13 = a1[1];
    uint64_t v14 = (uint64_t)v13 - 1;
    uint64_t v15 = v21;
    unint64_t v16 = (unint64_t)v13 + v21 - 1;
    if (*((void *)&v21 + 1) < v16)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v22, v16, 1);
      uint64_t v15 = v21;
      if (v13 == (void *)1)
      {
LABEL_37:
        size_t v17 = v15 + v14;
        *(void *)&long long v21 = v17;
        if (&__src == a1)
        {
LABEL_56:
          if (__src != v22) {
            free(__src);
          }
          return;
        }
LABEL_46:
        size_t v19 = (size_t)a1[1];
        if (v19 >= v17)
        {
          if (v17) {
            memmove(*a1, __src, v17);
          }
        }
        else
        {
          if ((unint64_t)a1[2] >= v17)
          {
            if (v19) {
              memmove(*a1, __src, (size_t)a1[1]);
            }
          }
          else
          {
            a1[1] = 0;
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v17, 1);
            size_t v19 = 0;
          }
          if (v19 != (void)v21) {
            memcpy((char *)*a1 + v19, (char *)__src + v19, v21 - v19);
          }
        }
        a1[1] = (void *)v17;
        goto LABEL_56;
      }
    }
    else if (v13 == (void *)1)
    {
      goto LABEL_37;
    }
    memcpy((char *)__src + v15, v12 + 1, (size_t)v13 - 1);
    size_t v17 = v21 + v14;
    *(void *)&long long v21 = v17;
    if (&__src == a1) {
      goto LABEL_56;
    }
    goto LABEL_46;
  }
  uint64_t v7 = (char *)*a1;
  if (v2 < 8)
  {
LABEL_40:
    BOOL v18 = &v4[v2];
    do
    {
      if (*v7 == 92) {
        *uint64_t v7 = 47;
      }
      ++v7;
    }
    while (v7 != v18);
    return;
  }
  uint64_t v7 = &v4[v2 & 0xFFFFFFFFFFFFFFF8];
  unint64_t v8 = v4 + 3;
  unint64_t v9 = v2 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    int8x8_t v10 = vceq_s8(*(int8x8_t *)(v8 - 3), (int8x8_t)0x5C5C5C5C5C5C5C5CLL);
    if (v10.i8[0])
    {
      *(v8 - 3) = 47;
      if ((v10.i8[1] & 1) == 0)
      {
LABEL_16:
        if ((v10.i8[2] & 1) == 0) {
          goto LABEL_17;
        }
        goto LABEL_25;
      }
    }
    else if ((v10.i8[1] & 1) == 0)
    {
      goto LABEL_16;
    }
    *(v8 - 2) = 47;
    if ((v10.i8[2] & 1) == 0)
    {
LABEL_17:
      if ((v10.i8[3] & 1) == 0) {
        goto LABEL_18;
      }
      goto LABEL_26;
    }
LABEL_25:
    *(v8 - 1) = 47;
    if ((v10.i8[3] & 1) == 0)
    {
LABEL_18:
      if ((v10.i8[4] & 1) == 0) {
        goto LABEL_19;
      }
      goto LABEL_27;
    }
LABEL_26:
    unsigned char *v8 = 47;
    if ((v10.i8[4] & 1) == 0)
    {
LABEL_19:
      if ((v10.i8[5] & 1) == 0) {
        goto LABEL_20;
      }
      goto LABEL_28;
    }
LABEL_27:
    v8[1] = 47;
    if ((v10.i8[5] & 1) == 0)
    {
LABEL_20:
      if (v10.i8[6]) {
        goto LABEL_29;
      }
      goto LABEL_21;
    }
LABEL_28:
    v8[2] = 47;
    if (v10.i8[6])
    {
LABEL_29:
      v8[3] = 47;
      if ((v10.i8[7] & 1) == 0) {
        goto LABEL_13;
      }
      goto LABEL_30;
    }
LABEL_21:
    if ((v10.i8[7] & 1) == 0) {
      goto LABEL_13;
    }
LABEL_30:
    v8[4] = 47;
LABEL_13:
    v8 += 8;
    v9 -= 8;
  }
  while (v9);
  if (v2 != (v2 & 0xFFFFFFFFFFFFFFF8)) {
    goto LABEL_40;
  }
}

uint64_t llvm::sys::path::home_directory(void *a1)
{
  unint64_t v2 = getenv("HOME");
  if (v2)
  {
    pw_dir = v2;
    unsigned int v4 = 0;
  }
  else
  {
    uint64_t v11 = sysconf(71);
    if (v11 >= 1) {
      size_t v12 = v11;
    }
    else {
      size_t v12 = 0x4000;
    }
    unsigned int v4 = operator new[](v12);
    bzero(v4, v12);
    uint64_t v14 = 0;
    uid_t v13 = getuid();
    getpwuid_r(v13, &v15, (char *)v4, v12, &v14);
    if (!v14 || (pw_dir = v14->pw_dir) == 0)
    {
      uint64_t v9 = 0;
      goto LABEL_15;
    }
  }
  a1[1] = 0;
  size_t v5 = strlen(pw_dir);
  size_t v6 = v5;
  if (a1[2] >= v5)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    if (!v5) {
      goto LABEL_7;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v5, 1);
    uint64_t v7 = a1[1];
  }
  memcpy((void *)(*a1 + v7), pw_dir, v6);
  uint64_t v8 = a1[1];
LABEL_7:
  a1[1] = v8 + v6;
  uint64_t v9 = 1;
  if (!v4) {
    return 1;
  }
LABEL_15:
  operator delete[](v4);
  return v9;
}

uint64_t llvm::sys::path::filename(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  v4[0] = a1;
  v4[1] = a2;
  uint64_t v7 = a2;
  int v8 = a3;
  llvm::sys::path::reverse_iterator::operator++(v4);
  return v5;
}

BOOL llvm::sys::path::has_root_directory(const char **this, const llvm::Twine *a2)
{
  unsigned int v2 = a2;
  v11[16] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  long long v10 = xmmword_1811019F0;
  if (*((unsigned char *)this + 33) == 1)
  {
    size_t v3 = 0;
    unsigned int v4 = 0;
    switch(*((unsigned char *)this + 32))
    {
      case 1:
        break;
      case 3:
        unsigned int v4 = (void *)*this;
        if (*this) {
          size_t v3 = strlen(*this);
        }
        else {
          size_t v3 = 0;
        }
        break;
      case 4:
        int v8 = (*this)[23];
        if (v8 >= 0) {
          unsigned int v4 = (void *)*this;
        }
        else {
          unsigned int v4 = *(void **)*this;
        }
        if (v8 >= 0) {
          size_t v3 = *((unsigned __int8 *)*this + 23);
        }
        else {
          size_t v3 = *((void *)*this + 1);
        }
        break;
      case 5:
      case 6:
        unsigned int v4 = (void *)*this;
        size_t v3 = (size_t)this[1];
        break;
      default:
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    llvm::Twine::toVector((uint64_t)this, (uint64_t)&v9);
    unsigned int v4 = v9;
    size_t v3 = v10;
  }
  llvm::sys::path::root_directory((unint64_t)v4, v3, v2);
  uint64_t v6 = v5;
  if (v9 != v11) {
    free(v9);
  }
  return v6 != 0;
}

BOOL llvm::sys::path::has_parent_path(const char **this, const llvm::Twine *a2)
{
  unsigned int v2 = a2;
  v12[16] = *MEMORY[0x1E4F143B8];
  long long v10 = v12;
  long long v11 = xmmword_1811019F0;
  if (*((unsigned char *)this + 33) == 1)
  {
    size_t v3 = 0;
    unsigned int v4 = 0;
    switch(*((unsigned char *)this + 32))
    {
      case 1:
        break;
      case 3:
        unsigned int v4 = (unsigned __int8 *)*this;
        if (*this) {
          size_t v3 = strlen(*this);
        }
        else {
          size_t v3 = 0;
        }
        break;
      case 4:
        int v9 = (*this)[23];
        if (v9 >= 0) {
          unsigned int v4 = (unsigned __int8 *)*this;
        }
        else {
          unsigned int v4 = *(unsigned __int8 **)*this;
        }
        if (v9 >= 0) {
          size_t v3 = *((unsigned __int8 *)*this + 23);
        }
        else {
          size_t v3 = *((void *)*this + 1);
        }
        break;
      case 5:
      case 6:
        unsigned int v4 = (unsigned __int8 *)*this;
        size_t v3 = (size_t)this[1];
        break;
      default:
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    llvm::Twine::toVector((uint64_t)this, (uint64_t)&v10);
    unsigned int v4 = (unsigned __int8 *)v10;
    size_t v3 = v11;
  }
  if (v10 != v12) {
    free(v10);
  }
  if (v3 >= v5) {
    unint64_t v6 = v5;
  }
  else {
    unint64_t v6 = v3;
  }
  return v5 != -1 && v6 != 0;
}

uint64_t llvm::sys::path::is_absolute(const char **this, const llvm::Twine *a2)
{
  v15[16] = *MEMORY[0x1E4F143B8];
  uid_t v13 = v15;
  long long v14 = xmmword_1811019F0;
  if (*((unsigned char *)this + 33) == 1)
  {
    size_t v3 = 0;
    unsigned int v4 = 0;
    switch(*((unsigned char *)this + 32))
    {
      case 1:
        break;
      case 3:
        unsigned int v4 = *this;
        if (*this) {
          size_t v3 = strlen(*this);
        }
        else {
          size_t v3 = 0;
        }
        break;
      case 4:
        int v9 = (*this)[23];
        if (v9 >= 0) {
          unsigned int v4 = *this;
        }
        else {
          unsigned int v4 = *(const char **)*this;
        }
        if (v9 >= 0) {
          size_t v3 = *((unsigned __int8 *)*this + 23);
        }
        else {
          size_t v3 = *((void *)*this + 1);
        }
        break;
      case 5:
      case 6:
        unsigned int v4 = *this;
        size_t v3 = (size_t)this[1];
        break;
      default:
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    llvm::Twine::toVector((uint64_t)this, (uint64_t)&v13);
    unsigned int v4 = (const char *)v13;
    size_t v3 = v14;
  }
  __int16 v12 = 261;
  long long v10 = v4;
  size_t v11 = v3;
  BOOL has_root_directory = llvm::sys::path::has_root_directory(&v10, a2);
  if (a2 < 2)
  {
    int has_root_name = 1;
    uint64_t v7 = v13;
    if (v13 == v15) {
      return has_root_directory & has_root_name;
    }
    goto LABEL_9;
  }
  __int16 v12 = 261;
  long long v10 = v4;
  size_t v11 = v3;
  int has_root_name = llvm::sys::path::has_root_name(&v10, a2);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_9:
  }
    free(v7);
  return has_root_directory & has_root_name;
}

uint64_t llvm::sys::path::is_relative(const char **this, const llvm::Twine *a2)
{
  return llvm::sys::path::is_absolute(this, a2) ^ 1;
}

uint64_t llvm::sys::fs::status(llvm::sys::fs *this, const stat *a2, llvm::sys::fs::file_status *a3)
{
  int v3 = (int)a3;
  v13[16] = *MEMORY[0x1E4F143B8];
  size_t v11 = v13;
  long long v12 = xmmword_1811019F0;
  unint64_t v5 = llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)this, &v11);
  if (v3) {
    unint64_t v6 = (llvm::sys::fs *)MEMORY[0x1E4F14A68](v5, v10);
  }
  else {
    unint64_t v6 = (llvm::sys::fs *)MEMORY[0x1E4F14950](v5, v10);
  }
  uint64_t v8 = llvm::sys::fs::fillStatus(v6, v10, a2, v7);
  if (v11 != v13) {
    free(v11);
  }
  return v8;
}

{
  llvm::sys::fs *v4;
  llvm::sys::fs::file_status *v5;
  stat v7;

  unsigned int v4 = (llvm::sys::fs *)fstat((int)this, &v7);
  return llvm::sys::fs::fillStatus(v4, &v7.st_dev, a2, v5);
}

uint64_t llvm::sys::fs::file_status::getUniqueID(llvm::sys::fs::file_status *this)
{
  return *((int *)this + 12);
}

void llvm::sys::fs::createUniquePath(uint64_t a1, uint64_t a2, int a3)
{
  v22[16] = *MEMORY[0x1E4F143B8];
  int v20 = (char *)v22;
  long long v21 = xmmword_1811019F0;
  llvm::Twine::toVector(a1, (uint64_t)&v20);
  if (a3)
  {
    v19[4] = 261;
    size_t v17 = v20;
    *(void *)&long long v18 = v21;
    if ((llvm::sys::path::is_absolute((const char **)&v17, 0) & 1) == 0)
    {
      size_t v17 = v19;
      long long v18 = xmmword_1811019F0;
      llvm::sys::path::system_temp_directory(1, (uint64_t)&v17);
      __int16 v16 = 261;
      v15[0] = v20;
      v15[1] = (void *)v21;
      __int16 v14 = 257;
      __int16 v12 = 257;
      __int16 v10 = 257;
      llvm::sys::path::append(&v17, 0, v15, &v13, &v11, &v9);
      llvm::SmallVectorImpl<char>::swap(&v20, &v17);
      if (v17 != v19) {
        free(v17);
      }
    }
  }
  if (&v20 == (char **)a2)
  {
    unint64_t v5 = *(void *)(a2 + 8);
  }
  else
  {
    unint64_t v5 = v21;
    unint64_t v6 = *(void *)(a2 + 8);
    if (v6 >= (unint64_t)v21)
    {
      if ((void)v21) {
        memmove(*(void **)a2, v20, v21);
      }
    }
    else
    {
      if (*(void *)(a2 + 16) >= (unint64_t)v21)
      {
        if (v6) {
          memmove(*(void **)a2, v20, *(void *)(a2 + 8));
        }
      }
      else
      {
        *(void *)(a2 + 8) = 0;
        llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (void *)(a2 + 24), v5, 1);
        unint64_t v6 = 0;
      }
      if (v6 != (void)v21) {
        memcpy((void *)(*(void *)a2 + v6), &v20[v6], v21 - v6);
      }
    }
    *(void *)(a2 + 8) = v5;
  }
  if (v5 + 1 > *(void *)(a2 + 16))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (void *)(a2 + 24), v5 + 1, 1);
    *(unsigned char *)(*(void *)a2 + *(void *)(a2 + 8)) = 0;
    uint64_t v7 = v21;
    if (!v21) {
      goto LABEL_24;
    }
  }
  else
  {
    *(unsigned char *)(*(void *)a2 + v5) = 0;
    uint64_t v7 = v21;
    if (!v21) {
      goto LABEL_24;
    }
  }
  uint64_t v8 = 0;
  do
  {
    if (v20[v8] == 37) {
      *(unsigned char *)(*(void *)a2 + v8) = a0123456789abcd_0[llvm::sys::Process::GetRandomNumber() & 0xF];
    }
    ++v8;
  }
  while (v7 != v8);
LABEL_24:
  if (v20 != (char *)v22) {
    free(v20);
  }
}

void llvm::sys::path::system_temp_directory(int a1, uint64_t a2)
{
  int v3 = 65537;
  *(void *)(a2 + 8) = 0;
  if (a1)
  {
    unsigned int v4 = getenv("TMPDIR");
    if (v4 || (unsigned int v4 = getenv("TMP")) != 0 || (unsigned int v4 = getenv("TEMP")) != 0 || (unsigned int v4 = getenv("TEMPDIR")) != 0)
    {
      size_t v5 = strlen(v4);
      size_t v6 = v5;
      if (*(void *)(a2 + 16) >= v5)
      {
        uint64_t v7 = 0;
        uint64_t v12 = 0;
        if (!v5)
        {
LABEL_24:
          *(void *)(a2 + 8) = v12 + v6;
          return;
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (void *)(a2 + 24), v5, 1);
        uint64_t v7 = *(void *)(a2 + 8);
      }
      memcpy((void *)(*(void *)a2 + v7), v4, v6);
      uint64_t v12 = *(void *)(a2 + 8);
      goto LABEL_24;
    }
  }
  else
  {
    int v3 = 65538;
  }
  size_t v8 = confstr(v3, 0, 0);
  size_t v9 = *(void *)(a2 + 8);
  if (!v8) {
    goto LABEL_26;
  }
  unint64_t v10 = v8;
  while (v9 == v10)
  {
    size_t v11 = confstr(v3, *(char **)a2, v9);
    if (!v11) {
      goto LABEL_25;
    }
LABEL_20:
    unint64_t v10 = v11;
    size_t v9 = *(void *)(a2 + 8);
    if (v11 == v9)
    {
      *(void *)(a2 + 8) = v11 - 1;
      return;
    }
  }
  if (v9 <= v10)
  {
    if (*(void *)(a2 + 16) < v10)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (void *)(a2 + 24), v10, 1);
      size_t v9 = *(void *)(a2 + 8);
    }
    if (v10 != v9) {
      bzero((void *)(*(void *)a2 + v9), v10 - v9);
    }
  }
  *(void *)(a2 + 8) = v10;
  size_t v11 = confstr(v3, *(char **)a2, v10);
  if (v11) {
    goto LABEL_20;
  }
LABEL_25:
  size_t v9 = 0;
  *(void *)(a2 + 8) = 0;
LABEL_26:
  if (*(void *)(a2 + 16) < v9 + 9)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (void *)(a2 + 24), v9 + 9, 1);
    size_t v9 = *(void *)(a2 + 8);
  }
  size_t v13 = *(void *)a2 + v9;
  *(void *)size_t v13 = *(void *)"/var/tmp/";
  *(unsigned char *)(v13 + 8) = 47;
  *(void *)(a2 + 8) += 9;
}

void createUniqueEntity(uint64_t a1, int *a2, void *a3, int a4, int a5, int a6, uint64_t a7)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  std::system_category();
  if (a5 == 2)
  {
    int v22 = 129;
    while (1)
    {
      llvm::sys::fs::createUniquePath(a1, (uint64_t)a3, a4);
      int v23 = (unsigned char *)*a3;
      __int16 v37 = 257;
      if (*v23)
      {
        *(void *)BOOL v36 = v23;
        char v24 = 3;
      }
      else
      {
        char v24 = 1;
      }
      LOBYTE(v37) = v24;
      int v38 = &v40;
      long long v39 = xmmword_1811019F0;
      BOOL v25 = (const char *)llvm::Twine::toNullTerminatedStringRef(v36, &v38);
      if (access(v25, 0) == -1) {
        break;
      }
      int v26 = std::system_category();
      int v27 = 0;
      BOOL v28 = v38;
      if (v38 != &v40) {
        goto LABEL_21;
      }
LABEL_22:
      if (v26 == std::generic_category() && v27 == 2) {
        goto LABEL_39;
      }
      if (!v27 && --v22 >= 2) {
        continue;
      }
      return;
    }
    int v27 = *__error();
    int v26 = std::generic_category();
    BOOL v28 = v38;
    if (v38 == &v40) {
      goto LABEL_22;
    }
LABEL_21:
    free(v28);
    goto LABEL_22;
  }
  if (a5 == 1)
  {
    int v14 = 129;
    while (1)
    {
      llvm::sys::fs::createUniquePath(a1, (uint64_t)a3, a4);
      passwd v15 = (unsigned char *)*a3;
      __int16 v41 = 257;
      if (*v15)
      {
        int v38 = v15;
        char v16 = 3;
      }
      else
      {
        char v16 = 1;
      }
      LOBYTE(v41) = v16;
      int v18 = llvm::sys::fs::openFile((unsigned __int8 *)&v38, a2, 1, 3, a6, a7);
      if (!v18) {
        break;
      }
      size_t v19 = v17;
      int v20 = std::generic_category();
      if (v18 == 17 && v20 == v19)
      {
        if (--v14 <= 1) {
          return;
        }
      }
      else
      {
        long long v21 = std::generic_category();
        if (v18 != 13) {
          return;
        }
        if (v21 != v19) {
          return;
        }
        if (--v14 <= 1) {
          return;
        }
      }
    }
  }
  else
  {
    if (a5)
    {
      llvm::sys::fs::createUniquePath(a1, (uint64_t)a3, a4);
      __break(1u);
      return;
    }
    int v29 = 129;
    while (1)
    {
      llvm::sys::fs::createUniquePath(a1, (uint64_t)a3, a4);
      unint64_t v30 = (unsigned char *)*a3;
      __int16 v41 = 257;
      if (*v30)
      {
        int v38 = v30;
        char v31 = 3;
      }
      else
      {
        char v31 = 1;
      }
      LOBYTE(v41) = v31;
      int directory = llvm::sys::fs::create_directory((unsigned __int8 *)&v38, 0, 0x1F8u);
      if (!directory) {
        break;
      }
      unint64_t v34 = v32;
      int v35 = std::generic_category();
      if (directory == 17 && v35 == v34 && --v29 > 1) {
        continue;
      }
      return;
    }
  }
LABEL_39:
  std::system_category();
}

uint64_t llvm::sys::fs::createTemporaryFile(long long *a1, long long *a2, uint64_t a3, int *a4, void *a5, int a6)
{
  return llvm::sys::fs::createTemporaryFile(a1, a2, a3, a4, a5, 1, a6);
}

uint64_t llvm::sys::fs::createTemporaryFile(long long *a1, long long *a2, uint64_t a3, int *a4, void *a5, int a6, int a7)
{
  v39[16] = *MEMORY[0x1E4F143B8];
  size_t v11 = "-%%%%%%";
  if (a3) {
    size_t v11 = "-%%%%%%.";
  }
  if (*v11) {
    int v12 = 3;
  }
  else {
    int v12 = 1;
  }
  int v13 = *((unsigned __int8 *)a1 + 32);
  if (v13 == 1)
  {
    *(void *)&long long v26 = v11;
    LOBYTE(v28) = v12;
    BYTE1(v28) = 1;
    if (v12 != 1) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }
  if (!*((unsigned char *)a1 + 32))
  {
    LOWORD(v28) = 256;
LABEL_11:
    __int16 v14 = 256;
LABEL_21:
    __int16 v33 = v14;
    goto LABEL_27;
  }
  if (!*v11)
  {
    long long v25 = a1[1];
    long long v26 = *a1;
    long long v27 = v25;
    uint64_t v28 = *((void *)a1 + 4);
    int v12 = v28;
    if (v28 != 1) {
      goto LABEL_10;
    }
LABEL_20:
    int v29 = a2;
    uint64_t v30 = a3;
    __int16 v14 = 261;
    goto LABEL_21;
  }
  passwd v15 = *(long long **)a1;
  uint64_t v16 = *((void *)a1 + 1);
  BOOL v17 = *((unsigned char *)a1 + 33) == 1;
  BYTE1(v28) = v12;
  if (v17) {
    int v12 = v13;
  }
  else {
    int v12 = 2;
  }
  if (v17) {
    int v18 = v15;
  }
  else {
    int v18 = a1;
  }
  *(void *)&long long v26 = v18;
  *((void *)&v26 + 1) = v16;
  *(void *)&long long v27 = v11;
  LOBYTE(v28) = v12;
LABEL_10:
  if (!v12) {
    goto LABEL_11;
  }
  if (BYTE1(v28) != 1) {
    LOBYTE(v12) = 2;
  }
  size_t v19 = &v26;
  if (BYTE1(v28) == 1) {
    size_t v19 = (long long *)v26;
  }
  int v29 = v19;
  uint64_t v30 = *((void *)&v26 + 1);
  char v31 = a2;
  uint64_t v32 = a3;
  LOBYTE(v33) = v12;
  HIBYTE(v33) = 5;
LABEL_27:
  __int16 v37 = v39;
  long long v38 = xmmword_1811019F0;
  int v20 = llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v29, &v37);
  char v21 = 1;
  char v36 = 1;
  if (*(unsigned char *)v20)
  {
    unint64_t v34 = v20;
    char v21 = 3;
  }
  char v35 = v21;
  createUniqueEntity((uint64_t)&v34, a4, a5, 1, a6, a7, 384);
  uint64_t v23 = v22;
  if (v37 != v39) {
    free(v37);
  }
  return v23;
}

uint64_t llvm::sys::fs::createTemporaryFile(long long *a1, long long *a2, uint64_t a3, void *a4, int a5)
{
  int v7 = 0;
  uint64_t result = llvm::sys::fs::createTemporaryFile(a1, a2, a3, &v7, a4, 1, a5);
  uint64_t v6 = result;
  if (!result)
  {
    close(v7);
    return v6;
  }
  return result;
}

void llvm::sys::fs::make_absolute(uint64_t a1, char **a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  size_t v5 = *a2;
  unint64_t v4 = (unint64_t)a2[1];
  __int16 v41 = 261;
  long long v38 = v5;
  *(void *)&long long v39 = v4;
  BOOL has_root_directory = llvm::sys::path::has_root_directory((const char **)&v38, 0);
  __int16 v41 = 261;
  long long v38 = v5;
  *(void *)&long long v39 = v4;
  char has_root_name = llvm::sys::path::has_root_name((const char **)&v38, 0);
  if (!has_root_directory)
  {
    char v8 = has_root_name;
    long long v38 = (char *)&v40;
    long long v39 = xmmword_1811019F0;
    llvm::Twine::toVector(a1, (uint64_t)&v38);
    if ((v8 & 1) == 0)
    {
      v37[4] = 261;
      char v35 = v5;
      *(void *)&long long v36 = v4;
      __int16 v34 = 257;
      __int16 v32 = 257;
      __int16 v30 = 257;
      llvm::sys::path::append(&v38, 0, (void **)&v35, v33, (const char **)v31, v29);
      llvm::SmallVectorImpl<char>::swap(a2, &v38);
LABEL_30:
      if (v38 != (char *)&v40) {
        free(v38);
      }
      return;
    }
    char v35 = v5;
    *(void *)&long long v36 = v4;
    if (!v4) {
      goto LABEL_21;
    }
    int v9 = *v5;
    if (v4 < 3)
    {
      if (v9 == 47) {
        goto LABEL_21;
      }
    }
    else if (v9 == 47)
    {
      if (v5[1] != 47 || v5[2] == 47) {
        goto LABEL_21;
      }
      unint64_t v10 = 2;
      goto LABEL_12;
    }
    unint64_t v10 = 0;
LABEL_12:
    unint64_t first_of = llvm::StringRef::find_first_of(&v35, "/", 1, v10);
    unint64_t v12 = v36;
    if ((unint64_t)v36 >= first_of) {
      unint64_t v12 = first_of;
    }
    if (v12 >= 3 && *(unsigned char *)v35 == 47)
    {
      int v13 = *((unsigned __int8 *)v35 + 1);
      if (v13 != 47) {
        unint64_t v12 = 0;
      }
      long long v26 = (void *)v12;
      if (v13 == 47) {
        __int16 v14 = v35;
      }
      else {
        __int16 v14 = 0;
      }
      goto LABEL_22;
    }
LABEL_21:
    long long v26 = 0;
    __int16 v14 = 0;
LABEL_22:
    passwd v15 = (void *)llvm::sys::path::root_directory((unint64_t)v38, v39, 0);
    BOOL v17 = v16;
    int v18 = v38;
    unint64_t v19 = v39;
    llvm::sys::path::root_path((unint64_t)v38, v39, 0);
    if (v19 >= v20) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = v19;
    }
    uint64_t v22 = &v18[v21];
    uint64_t v23 = (void *)(v19 - v21);
    llvm::sys::path::root_path((unint64_t)v5, v4, 0);
    long long v36 = xmmword_1811019F0;
    char v35 = v37;
    if (v4 >= v24) {
      unint64_t v25 = v24;
    }
    else {
      unint64_t v25 = v4;
    }
    __int16 v34 = 261;
    v33[0] = v14;
    v33[1] = v26;
    __int16 v32 = 261;
    v31[0] = v15;
    v31[1] = v17;
    __int16 v30 = 261;
    v29[0] = v22;
    v29[1] = v23;
    __int16 v28 = 261;
    v27[0] = &v5[v25];
    v27[1] = (void *)(v4 - v25);
    llvm::sys::path::append(&v35, 0, v33, v31, (const char **)v29, v27);
    llvm::SmallVectorImpl<char>::swap(a2, &v35);
    if (v35 != v37) {
      free(v35);
    }
    goto LABEL_30;
  }
}

uint64_t llvm::sys::fs::make_absolute(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v10[4] = 261;
  uint64_t v2 = *(void *)(a1 + 8);
  char v8 = *(void **)a1;
  *(void *)&long long v9 = v2;
  if (!llvm::sys::path::is_absolute((const char **)&v8, 0))
  {
    char v8 = v10;
    long long v9 = xmmword_1811019F0;
    uint64_t v3 = llvm::sys::fs::current_path((uint64_t)&v8);
    if (v3)
    {
      unint64_t v4 = v8;
      if (v8 == v10) {
        return v3;
      }
    }
    else
    {
      __int16 v7 = 261;
      v6[0] = v8;
      v6[1] = v9;
      llvm::sys::fs::make_absolute((uint64_t)v6, (char **)a1);
      std::system_category();
      unint64_t v4 = v8;
      if (v8 == v10) {
        return v3;
      }
    }
    free(v4);
    return v3;
  }
  std::system_category();
  return 0;
}

uint64_t llvm::sys::fs::current_path(uint64_t a1)
{
  v34[16] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  uint64_t v2 = getenv("PWD");
  v31.st_blkstd::string::size_type size = 0;
  *(void *)&v31.st_gen = 0;
  LODWORD(v31.st_mtimespec.tv_sec) = 0;
  v31.st_mtimespec.uint64_t tv_nsec = 0;
  if (v2)
  {
    uint64_t v3 = v2;
    char v4 = 1;
    char v30 = 1;
    if (*v2)
    {
      __int16 v28 = v2;
      char v4 = 3;
    }
    char v29 = v4;
    if (llvm::sys::path::is_absolute((const char **)&v28, 0))
    {
      char v5 = 1;
      char v27 = 1;
      if (*v3)
      {
        unint64_t v25 = v3;
        char v5 = 3;
      }
      char v26 = v5;
      __int16 v32 = v34;
      long long v33 = xmmword_1811019F0;
      uint64_t v6 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v25, &v32);
      __int16 v7 = (llvm::sys::fs *)stat(v6, (stat *)v31.st_qspare);
      int v9 = llvm::sys::fs::fillStatus(v7, (int *)v31.st_qspare, (const stat *)&v31.st_ctimespec, v8);
      if (v32 != v34) {
        free(v32);
      }
      if (!v9)
      {
        uint64_t v23 = ".";
        __int16 v24 = 259;
        __int16 v32 = v34;
        long long v33 = xmmword_1811019F0;
        unint64_t v10 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v23, &v32);
        uint64_t v11 = (llvm::sys::fs *)stat(v10, (stat *)v31.st_qspare);
        int v13 = llvm::sys::fs::fillStatus(v11, (int *)v31.st_qspare, &v31, v12);
        if (v32 != v34) {
          free(v32);
        }
        if (!v13
          && v31.st_blksize == LODWORD(v31.st_mtimespec.tv_sec)
          && *(void *)&v31.st_gen == v31.st_mtimespec.tv_nsec)
        {
          size_t v14 = strlen(v3);
          uint64_t v15 = *(void *)(a1 + 8);
          if (*(void *)(a1 + 16) < v15 + v14)
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod(a1, (void *)(a1 + 24), v15 + v14, 1);
            uint64_t v15 = *(void *)(a1 + 8);
          }
          if (v14)
          {
            memcpy((void *)(*(void *)a1 + v15), v3, v14);
            uint64_t v15 = *(void *)(a1 + 8);
          }
          *(void *)(a1 + 8) = v15 + v14;
          goto LABEL_27;
        }
      }
    }
  }
  unint64_t v16 = *(void *)(a1 + 8);
  if (v16 != 1024)
  {
    if (v16 <= 0x400 && *(void *)(a1 + 16) <= 0x3FFuLL) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod(a1, (void *)(a1 + 24), 0x400uLL, 1);
    }
    *(void *)(a1 + 8) = 1024;
  }
  if (getcwd(*(char **)a1, 0x400uLL))
  {
LABEL_26:
    *(void *)(a1 + 8) = strlen(*(const char **)a1);
LABEL_27:
    std::system_category();
    return 0;
  }
  while (*__error() == 12)
  {
    size_t v20 = *(void *)(a1 + 8);
    uint64_t v19 = *(void *)(a1 + 16);
    size_t v21 = 2 * v19;
    if (v20 != 2 * v19)
    {
      if (v19 >= 1 && v20 <= v21) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod(a1, (void *)(a1 + 24), 2 * v19, 1);
      }
      *(void *)(a1 + 8) = v21;
    }
    if (getcwd(*(char **)a1, v21)) {
      goto LABEL_26;
    }
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *__error();
  std::generic_category();
  return v17;
}

uint64_t llvm::sys::fs::create_directory(unsigned __int8 *a1, char a2, mode_t a3)
{
  v11[16] = *MEMORY[0x1E4F143B8];
  int v9 = v11;
  long long v10 = xmmword_1811019F0;
  char v5 = (const char *)llvm::Twine::toNullTerminatedStringRef(a1, &v9);
  if (mkdir(v5, a3) == -1 && (*__error() != 17 || (a2 & 1) == 0))
  {
    uint64_t v6 = *__error();
    std::generic_category();
    __int16 v7 = v9;
    if (v9 == v11) {
      return v6;
    }
    goto LABEL_5;
  }
  std::system_category();
  uint64_t v6 = 0;
  __int16 v7 = v9;
  if (v9 != v11) {
LABEL_5:
  }
    free(v7);
  return v6;
}

unint64_t llvm::sys::fs::openFileForRead(unsigned __int8 *a1, int *a2, int a3, void *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = llvm::sys::fs::openFile(a1, a2, 2, 1, a3, 438);
  uint64_t v7 = v6;
  if (v6)
  {
    unint64_t v8 = v6 & 0xFFFFFFFF00000000;
  }
  else
  {
    if (a4)
    {
      a4[1] = 0;
      if (fcntl(*a2, 50, __s) != -1)
      {
        size_t v10 = strlen(__s);
        uint64_t v11 = a4[1];
        if (a4[2] < v11 + v10)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, v11 + v10, 1);
          uint64_t v11 = a4[1];
        }
        if (v10)
        {
          memcpy((void *)(*a4 + v11), __s, v10);
          uint64_t v11 = a4[1];
        }
        a4[1] = v11 + v10;
      }
    }
    std::system_category();
    unint64_t v8 = 0;
  }
  return v8 | v7;
}

uint64_t llvm::sys::fs::is_directory(llvm::sys::fs *this, const llvm::Twine *a2, BOOL *a3)
{
  v13[16] = *MEMORY[0x1E4F143B8];
  memset(v9, 0, 44);
  uint64_t v11 = v13;
  long long v12 = xmmword_1811019F0;
  char v4 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)this, &v11);
  char v5 = (llvm::sys::fs *)stat(v4, &v10);
  uint64_t v7 = llvm::sys::fs::fillStatus(v5, &v10.st_dev, (const stat *)v9, v6);
  if (v11 != v13) {
    free(v11);
  }
  if (!v7)
  {
    *(unsigned char *)a2 = DWORD2(v9[2]) == 3;
    std::system_category();
  }
  return v7;
}

void llvm::sys::fs::directory_entry::replace_filename(uint64_t a1, void **a2, int a3, long long *a4)
{
  v32[16] = *MEMORY[0x1E4F143B8];
  int v8 = *(char *)(a1 + 23);
  if (v8 >= 0) {
    int v9 = (unsigned __int8 *)a1;
  }
  else {
    int v9 = *(unsigned __int8 **)a1;
  }
  if (v8 >= 0) {
    unint64_t v10 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    unint64_t v10 = *(void *)(a1 + 8);
  }
  size_t v12 = 0;
  if (v10 >= v11) {
    unint64_t v13 = v11;
  }
  else {
    unint64_t v13 = v10;
  }
  if (v11 == -1) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = v13;
  }
  if (v11 == -1) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v9;
  }
  __src = v32;
  *(_OWORD *)__len = xmmword_1811019F0;
  if (v14 >= 0x81)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v32, v14, 1);
    size_t v12 = __len[0];
  }
  if (v14)
  {
    memcpy((char *)__src + v12, v15, v14);
    size_t v12 = __len[0];
  }
  __len[0] = v12 + v14;
  __int16 v29 = 257;
  __int16 v26 = 257;
  __int16 v24 = 257;
  llvm::sys::path::append(&__src, 0, a2, (void **)&__dst, &v25, &v23);
  size_t v16 = __len[0];
  if (__len[0] >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v17 = __src;
  if (__len[0] >= 0x17)
  {
    size_t v21 = (__len[0] & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len[0] | 7) != 0x17) {
      size_t v21 = __len[0] | 7;
    }
    size_t v22 = v21 + 1;
    p_dst = (long long *)operator new(v21 + 1);
    *((void *)&__dst + 1) = v16;
    unint64_t v28 = v22 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
LABEL_30:
    memmove(p_dst, v17, v16);
    *((unsigned char *)p_dst + v16) = 0;
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_31;
  }
  HIBYTE(v28) = __len[0];
  p_dst = &__dst;
  if (__len[0]) {
    goto LABEL_30;
  }
  LOBYTE(__dst) = 0;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
    goto LABEL_24;
  }
LABEL_31:
  operator delete(*(void **)a1);
LABEL_24:
  *(_OWORD *)a1 = __dst;
  *(void *)(a1 + 16) = v28;
  *(_DWORD *)(a1 + 24) = a3;
  long long v19 = *a4;
  long long v20 = a4[2];
  *(_OWORD *)(a1 + 48) = a4[1];
  *(_OWORD *)(a1 + 64) = v20;
  *(_OWORD *)(a1 + 32) = v19;
  if (__src != v32) {
    free(__src);
  }
}

ssize_t llvm::sys::fs::readNativeFileToEOF@<X0>(int a1@<W0>, void *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  unint64_t v8 = a2[1];
  int v9 = a2 + 3;
  if (a3 >= 0x7FFFFFFF) {
    size_t v10 = 0x7FFFFFFFLL;
  }
  else {
    size_t v10 = a3;
  }
  uint64_t v11 = a2[1];
  unint64_t v12 = v8 + a3;
  BOOL v13 = v8 > v8 + a3;
  if (v8 != v8 + a3)
  {
LABEL_5:
    if (!v13 && a2[2] < v12) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, v9, v12, 1);
    }
    a2[1] = v12;
  }
  while (1)
  {
    unint64_t v14 = (void *)(*a2 + v11);
    while (1)
    {
      *__error() = 0;
      ssize_t result = read(a1, v14, v10);
      if (result != -1) {
        break;
      }
      if (*__error() != 4)
      {
        uint64_t v17 = (llvm *)*__error();
        *(void *)&v20.__val_ = std::generic_category();
        ssize_t result = (ssize_t)llvm::errorCodeToError(v17, v20, &v19);
        uint64_t v18 = v19;
        goto LABEL_16;
      }
    }
    if (!result) {
      break;
    }
    v11 += result;
    unint64_t v16 = a2[1];
    unint64_t v12 = v11 + a3;
    BOOL v13 = v16 > v11 + a3;
    if (v16 != v11 + a3) {
      goto LABEL_5;
    }
  }
  uint64_t v18 = 0;
LABEL_16:
  *a4 = v18;
  a2[1] = v11;
  return result;
}

unint64_t llvm::sys::fs::getMainExecutable@<X0>(unsigned char *a1@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bufstd::string::size_type size = 1024;
  unint64_t result = _NSGetExecutablePath(buf, &bufsize);
  if (result || (unint64_t result = (unint64_t)realpath_DARWIN_EXTSN(buf, __s)) == 0)
  {
    a1[23] = 0;
    *a1 = 0;
    return result;
  }
  unint64_t result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v6 = result;
  if (result >= 0x17)
  {
    uint64_t v7 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v7 = result | 7;
    }
    uint64_t v8 = v7 + 1;
    int v9 = operator new(v7 + 1);
    *((void *)a1 + 1) = v6;
    *((void *)a1 + 2) = v8 | 0x8000000000000000;
    *(void *)a1 = v9;
    a1 = v9;
  }
  else
  {
    a1[23] = result;
    if (!result) {
      goto LABEL_12;
    }
  }
  unint64_t result = (unint64_t)memcpy(a1, __s, v6);
LABEL_12:
  a1[v6] = 0;
  return result;
}

uint64_t llvm::sys::fs::basic_file_status::getLastModificationTime(llvm::sys::fs::basic_file_status *this)
{
  uint64_t v1 = *((unsigned int *)this + 5);
  return v1 + 1000 * std::chrono::system_clock::from_time_t(*((void *)this + 1)).__d_.__rep_;
}

uint64_t llvm::sys::fs::set_current_path(llvm::sys::fs *this, const llvm::Twine *a2)
{
  v8[16] = *MEMORY[0x1E4F143B8];
  size_t v6 = v8;
  long long v7 = xmmword_1811019F0;
  uint64_t v2 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)this, &v6);
  if (chdir(v2) == -1)
  {
    uint64_t v3 = *__error();
    std::generic_category();
    char v4 = v6;
    if (v6 == v8) {
      return v3;
    }
    goto LABEL_3;
  }
  std::system_category();
  uint64_t v3 = 0;
  char v4 = v6;
  if (v6 != v8) {
LABEL_3:
  }
    free(v4);
  return v3;
}

uint64_t llvm::sys::fs::remove(llvm::sys::fs *this, const llvm::Twine *a2)
{
  char v2 = (char)a2;
  v12[16] = *MEMORY[0x1E4F143B8];
  size_t v10 = v12;
  long long v11 = xmmword_1811019F0;
  uint64_t v3 = (const std::__fs::filesystem::path *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)this, &v10);
  if (lstat((const char *)v3, &v9))
  {
    if (*__error() != 2 || (v2 & 1) == 0) {
      goto LABEL_4;
    }
  }
  else
  {
    int v6 = v9.st_mode & 0xF000;
    if (v6 != 0x4000 && v6 != 0x8000 && v6 != 40960)
    {
      unsigned int v5 = 1;
LABEL_15:
      std::generic_category();
      long long v7 = v10;
      if (v10 == v12) {
        return v5;
      }
      goto LABEL_12;
    }
    if (remove(v3, v4) == -1 && (*__error() != 2 || (v2 & 1) == 0))
    {
LABEL_4:
      unsigned int v5 = *__error();
      goto LABEL_15;
    }
  }
  std::system_category();
  unsigned int v5 = 0;
  long long v7 = v10;
  if (v10 != v12) {
LABEL_12:
  }
    free(v7);
  return v5;
}

uint64_t llvm::sys::fs::is_local(llvm::sys::fs *this, const llvm::Twine *a2, BOOL *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::Twine::str(this, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int v5 = statfs((const char *)p_p, &v10);
  int v6 = v5;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v6) {
      goto LABEL_6;
    }
LABEL_9:
    *(unsigned char *)a2 = (v10.f_flags & 0x1000) != 0;
    std::system_category();
    return 0;
  }
  if (!v5) {
    goto LABEL_9;
  }
LABEL_6:
  uint64_t v7 = *__error();
  std::generic_category();
  return v7;
}

uint64_t llvm::sys::fs::access(unsigned __int8 *a1, int a2)
{
  v11[16] = *MEMORY[0x1E4F143B8];
  stat v9 = v11;
  long long v10 = xmmword_1811019F0;
  uint64_t v3 = (const char *)llvm::Twine::toNullTerminatedStringRef(a1, &v9);
  char v4 = v3;
  if (!a2)
  {
LABEL_9:
    if (access(v3, a2) != -1) {
      goto LABEL_10;
    }
LABEL_13:
    uint64_t v5 = *__error();
    std::generic_category();
    int v6 = v9;
    if (v9 == v11) {
      return v5;
    }
    goto LABEL_11;
  }
  if (a2 != 2)
  {
    a2 = 2;
    goto LABEL_9;
  }
  if (access(v3, 5) == -1) {
    goto LABEL_13;
  }
  if (stat(v4, &v8) || (v8.st_mode & 0xF000) != 0x8000)
  {
    std::generic_category();
    uint64_t v5 = 13;
    int v6 = v9;
    if (v9 == v11) {
      return v5;
    }
    goto LABEL_11;
  }
LABEL_10:
  std::system_category();
  uint64_t v5 = 0;
  int v6 = v9;
  if (v9 != v11) {
LABEL_11:
  }
    free(v6);
  return v5;
}

BOOL llvm::sys::fs::can_execute(llvm::sys::fs *this, const llvm::Twine *a2)
{
  return llvm::sys::fs::access((unsigned __int8 *)this, 2) == 0;
}

void llvm::sys::fs::expandTildeExpr(uint64_t *a1)
{
  v41[16] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v3 = (unsigned char *)*a1;
    if (*(unsigned char *)*a1 == 126)
    {
      char v4 = v3 + 1;
      unint64_t v5 = v1 - 1;
      if (v1 == 1)
      {
LABEL_7:
        unint64_t v6 = -1;
      }
      else
      {
        unint64_t v6 = 0;
        while (v4[v6] != 47)
        {
          if (v5 == ++v6) {
            goto LABEL_7;
          }
        }
      }
      if (v5 >= v6) {
        size_t v7 = v6;
      }
      else {
        size_t v7 = v1 - 1;
      }
      if (v5 >= v7 + 1) {
        size_t v8 = v7 + 1;
      }
      else {
        size_t v8 = v1 - 1;
      }
      long long v39 = (char *)v41;
      long long v40 = xmmword_1811019F0;
      if (!v7)
      {
        if (llvm::sys::path::home_directory(&v39))
        {
          *(unsigned char *)*a1 = *v39;
          llvm::SmallVectorImpl<char>::insert<char *,void>(a1, *a1 + 1, v39 + 1, &v39[v40]);
        }
        goto LABEL_43;
      }
      size_t v26 = v8;
      uint64_t v9 = sysconf(71);
      if (v9 >= 1) {
        size_t v10 = v9;
      }
      else {
        size_t v10 = 0x4000;
      }
      uint64_t v11 = operator new[](v10);
      bzero(v11, v10);
      if (v7 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      unint64_t v25 = v7 + 1;
      if (v7 >= 0x17)
      {
        uint64_t v13 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v7 | 7) != 0x17) {
          uint64_t v13 = v7 | 7;
        }
        uint64_t v14 = v13 + 1;
        unint64_t v12 = (void **)operator new(v13 + 1);
        __dst[1] = (void *)v7;
        int64_t v37 = v14 | 0x8000000000000000;
        __dst[0] = v12;
      }
      else
      {
        HIBYTE(v37) = v7;
        unint64_t v12 = __dst;
      }
      memmove(v12, v3 + 1, v7);
      *((unsigned char *)v12 + v7) = 0;
      char v35 = 0;
      if (v37 >= 0) {
        uint64_t v15 = (const char *)__dst;
      }
      else {
        uint64_t v15 = (const char *)__dst[0];
      }
      getpwnam_r(v15, &v38, (char *)v11, v10, &v35);
      if (!v35 || !v35->pw_dir)
      {
LABEL_40:
        if (SHIBYTE(v37) < 0) {
          operator delete(__dst[0]);
        }
        operator delete[](v11);
LABEL_43:
        if (v39 != (char *)v41) {
          free(v39);
        }
        return;
      }
      uint64_t v16 = 0;
      uint64_t v17 = &v4[v26];
      *(void *)&long long v40 = 0;
      size_t v18 = v1 - (v26 + 1);
      if (*((void *)&v40 + 1) < v18)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v39, v41, &v3[v1] - v17, 1);
        uint64_t v16 = v40;
      }
      uint64_t v19 = v11;
      if (v5 > v25)
      {
        memcpy(&v39[v16], v17, v18);
        uint64_t v16 = v40;
      }
      std::error_code v20 = (void *)(v16 + v18);
      *(void *)&long long v40 = v16 + v18;
      a1[1] = 0;
      pw_dir = v35->pw_dir;
      size_t v22 = strlen(pw_dir);
      size_t v23 = v22;
      if (a1[2] >= v22)
      {
        uint64_t v24 = 0;
        if (!v22)
        {
LABEL_39:
          a1[1] = v24 + v23;
          __int16 v34 = 261;
          v33[0] = v39;
          v33[1] = v20;
          __int16 v32 = 257;
          __int16 v30 = 257;
          __int16 v28 = 257;
          llvm::sys::path::append(a1, 0, v33, &v31, &v29, &v27);
          uint64_t v11 = v19;
          goto LABEL_40;
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v22, 1);
        uint64_t v24 = a1[1];
      }
      memcpy((void *)(*a1 + v24), pw_dir, v23);
      uint64_t v24 = a1[1];
      std::error_code v20 = (void *)v40;
      goto LABEL_39;
    }
  }
}

uint64_t llvm::sys::fs::fillStatus(llvm::sys::fs *this, int *a2, const stat *a3, llvm::sys::fs::file_status *a4)
{
  if (this)
  {
    uint64_t v5 = *__error();
    unint64_t v6 = std::generic_category();
    if (v6 == std::generic_category() && v5 == 2)
    {
      a3->st_atimespec.__darwin_time_t tv_sec = 0;
      *(_OWORD *)&a3->st_dev = 0u;
      *(_OWORD *)&a3->st_uid = 0u;
      a3->st_atimespec.uint64_t tv_nsec = 0xFFFF00000001;
      LODWORD(a3->st_mtimespec.tv_sec) = 0;
      WORD2(a3->st_mtimespec.tv_sec) = 0;
      a3->st_mtimespec.uint64_t tv_nsec = 0;
      return 2;
    }
    else
    {
      *(_OWORD *)(&a3->st_rdev + 1) = 0u;
      *(_OWORD *)&a3->st_dev = 0u;
      *(_OWORD *)&a3->st_uid = 0u;
      *(uint64_t *)((char *)&a3->st_atimespec.tv_nsec + 4) = 0xFFFFLL;
      WORD2(a3->st_mtimespec.tv_sec) = 0;
      a3->st_mtimespec.uint64_t tv_nsec = 0;
      return v5;
    }
  }
  else
  {
    uid_t v8 = a2[10];
    gid_t v9 = a2[14];
    unint64_t v10 = *((unsigned __int16 *)a2 + 2);
    int v11 = v10 & 0xFFF;
    uint64_t v12 = (v10 >> 12) ^ 8;
    if (v12 == 15) {
      int v13 = 9;
    }
    else {
      int v13 = dword_181128574[v12];
    }
    int v14 = *a2;
    __int16 v15 = *((_WORD *)a2 + 3);
    uint64_t v16 = *((void *)a2 + 1);
    __darwin_ino64_t v17 = *((void *)a2 + 6);
    __darwin_time_t v18 = *((void *)a2 + 12);
    uint64_t v19 = *((void *)a2 + 2);
    *(void *)&a3->st_dev = *((void *)a2 + 4);
    a3->st_ino = v17;
    a3->st_uid = v8;
    a3->st_gid = v9;
    *(void *)&a3->st_rdev = v19;
    a3->st_atimespec.__darwin_time_t tv_sec = v18;
    LODWORD(a3->st_atimespec.tv_nsec) = v13;
    HIDWORD(a3->st_atimespec.tv_nsec) = v11;
    LODWORD(a3->st_mtimespec.tv_sec) = v14;
    WORD2(a3->st_mtimespec.tv_sec) = v15;
    a3->st_mtimespec.uint64_t tv_nsec = v16;
    std::system_category();
    return 0;
  }
}

uint64_t llvm::sys::fs::mapped_file_region::mapped_file_region(uint64_t a1, int a2, int a3, size_t a4, off_t a5, void *a6)
{
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = a3;
  if (a3 == 1) {
    int v9 = 65;
  }
  else {
    int v9 = 66;
  }
  BOOL v10 = a3 == 0;
  if (a3) {
    int v11 = 3;
  }
  else {
    int v11 = 1;
  }
  if (v10) {
    int v12 = 24642;
  }
  else {
    int v12 = v9;
  }
  int v13 = mmap(0, a4, v11, v12, a2, a5);
  *(void *)(a1 + 8) = v13;
  if (v13 != (void *)-1)
  {
    int v14 = std::system_category();
    *a6 = 0;
    a6[1] = v14;
    return a1;
  }
  uint64_t v16 = *__error();
  __darwin_ino64_t v17 = std::generic_category();
  *a6 = v16;
  a6[1] = v17;
  if (!v16) {
    return a1;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

void *llvm::sys::fs::mapped_file_region::unmapImpl(llvm::sys::fs::mapped_file_region *this)
{
  unint64_t result = (void *)*((void *)this + 1);
  if (result) {
    return (void *)munmap(result, *(void *)this);
  }
  return result;
}

void *llvm::sys::fs::mapped_file_region::dontNeedImpl(llvm::sys::fs::mapped_file_region *this)
{
  unint64_t result = (void *)*((void *)this + 1);
  if (result) {
    return (void *)posix_madvise(result, *(void *)this, 4);
  }
  return result;
}

unint64_t llvm::sys::fs::detail::directory_iterator_construct(uint64_t a1, const void *a2, unint64_t a3, char a4)
{
  v28[16] = *MEMORY[0x1E4F143B8];
  size_t v26 = (char *)v28;
  long long v27 = xmmword_1811019F0;
  if (a3 < 0x81)
  {
    uint64_t v8 = 0;
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v26, v28, a3, 1);
  uint64_t v8 = v27;
  if (a3)
  {
LABEL_5:
    memcpy(&v26[v8], a2, a3);
    uint64_t v8 = v27;
  }
LABEL_6:
  uint64_t v9 = v8 + a3;
  *(void *)&long long v27 = v9;
  if ((unint64_t)(v9 + 1) <= *((void *)&v27 + 1))
  {
    v26[v9] = 0;
    BOOL v10 = opendir(v26);
    if (v10) {
      goto LABEL_8;
    }
LABEL_14:
    unsigned int v14 = *__error();
    std::generic_category();
    unint64_t v15 = 0;
    uint64_t v16 = v26;
    if (v26 == (char *)v28) {
      return v15 | v14;
    }
    goto LABEL_11;
  }
  llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v26, v28, v9 + 1, 1);
  v26[v27] = 0;
  BOOL v10 = opendir(v26);
  if (!v10) {
    goto LABEL_14;
  }
LABEL_8:
  *(void *)a1 = v10;
  v18.__r_.__value_.__r.__words[0] = (std::string::size_type)".";
  *(_WORD *)&v19[8] = 259;
  __int16 v25 = 257;
  __int16 v23 = 257;
  __int16 v21 = 257;
  llvm::sys::path::append(&v26, 0, &v18, v24, &v22, &v20);
  __int16 v25 = 261;
  v24[0] = v26;
  v24[1] = (void *)v27;
  llvm::Twine::str((llvm::Twine *)v24, &v18);
  *(_DWORD *)uint64_t v19 = 9;
  v19[4] = a4;
  memset(&v19[8], 0, 44);
  *(_DWORD *)&v19[52] = 0xFFFF;
  int v11 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v11);
  }
  *(_OWORD *)int v11 = *(_OWORD *)&v18.__r_.__value_.__l.__data_;
  *(void *)(a1 + 24) = *((void *)&v18.__r_.__value_.__l + 2);
  long long v12 = *(_OWORD *)&v19[16];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v19;
  *(_OWORD *)(a1 + 48) = v12;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v19[32];
  *(void *)(a1 + 80) = *(void *)&v19[48];
  unint64_t v13 = llvm::sys::fs::detail::directory_iterator_increment(a1);
  unsigned int v14 = v13;
  unint64_t v15 = v13 & 0xFFFFFFFF00000000;
  uint64_t v16 = v26;
  if (v26 != (char *)v28) {
LABEL_11:
  }
    free(v16);
  return v15 | v14;
}

unint64_t llvm::sys::fs::detail::directory_iterator_increment(uint64_t a1)
{
  *__error() = 0;
  char v2 = readdir(*(DIR **)a1);
  if (!v2)
  {
    if (*__error())
    {
      unsigned int v6 = *__error();
      std::generic_category();
LABEL_21:
      unint64_t v8 = 0;
      return v8 | v6;
    }
    if (*(void *)a1) {
      closedir(*(DIR **)a1);
    }
    *(void *)a1 = 0;
    int v11 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v11);
    }
    *int v11 = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 32) = 9;
    *(unsigned char *)(a1 + 36) = 1;
    *(_OWORD *)(a1 + 37) = 0u;
    *(_OWORD *)(a1 + 53) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(_DWORD *)(a1 + 84) = 0xFFFF;
LABEL_20:
    std::system_category();
    unsigned int v6 = 0;
    goto LABEL_21;
  }
  uint64_t v3 = v2;
  d_name = v2->d_name;
  uint64_t v5 = (void *)strlen(v2->d_name);
  if (v5 == (void *)2)
  {
    if (*d_name != 46 || v3->d_name[1] != 46)
    {
LABEL_11:
      __int16 v16 = 261;
      v15[0] = d_name;
      v15[1] = v5;
      uint64_t v9 = v3->d_type & 0xF ^ 8;
      if (v9 == 15) {
        int v10 = 9;
      }
      else {
        int v10 = dword_181128574[v9];
      }
      long long v14 = 0u;
      memset(v13, 0, sizeof(v13));
      HIDWORD(v14) = 0xFFFF;
      llvm::sys::fs::directory_entry::replace_filename(a1 + 8, v15, v10, v13);
      goto LABEL_20;
    }
  }
  else if (v5 != (void *)1 || *d_name != 46)
  {
    goto LABEL_11;
  }
  uint64_t v7 = llvm::sys::fs::detail::directory_iterator_increment(a1);
  unsigned int v6 = v7;
  unint64_t v8 = v7 & 0xFFFFFFFF00000000;
  return v8 | v6;
}

uint64_t llvm::sys::fs::detail::directory_iterator_destruct(uint64_t a1)
{
  char v2 = *(DIR **)a1;
  if (v2) {
    closedir(v2);
  }
  *(void *)a1 = 0;
  memset(v5, 0, 35);
  HIBYTE(v5[1]) = 0;
  uint64_t v3 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v3);
  }
  *(_OWORD *)(a1 + 37) = v5[0];
  dirent *v3 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 9;
  *(unsigned char *)(a1 + 36) = 1;
  *(_OWORD *)(a1 + 53) = v5[1];
  *(_OWORD *)(a1 + 68) = 0u;
  *(_DWORD *)(a1 + 84) = 0xFFFF;
  std::system_category();
  return 0;
}

double llvm::sys::fs::directory_entry::status@<D0>(llvm::sys::fs::directory_entry *this@<X0>, uint64_t a2@<X8>)
{
  v18[16] = *MEMORY[0x1E4F143B8];
  memset(&v15, 0, 44);
  HIDWORD(v15.st_atimespec.tv_nsec) = 0xFFFF;
  __int16 v14 = 260;
  unint64_t v13 = this;
  int v3 = *((unsigned __int8 *)this + 28);
  __int16 v16 = v18;
  long long v17 = xmmword_1811019F0;
  char v4 = llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v13, &v16);
  uint64_t v5 = (uint64_t (*)(void *, timespec *))MEMORY[0x1E4F14A68];
  if (!v3) {
    uint64_t v5 = (uint64_t (*)(void *, timespec *))MEMORY[0x1E4F14950];
  }
  unsigned int v6 = (llvm::sys::fs *)v5(v4, &v15.st_ctimespec);
  uint64_t v8 = llvm::sys::fs::fillStatus(v6, (int *)&v15.st_ctimespec, &v15, v7);
  uint64_t v11 = v10;
  if (v16 != v18) {
    free(v16);
  }
  if (v8)
  {
    *(unsigned char *)(a2 + 48) |= 1u;
    *(void *)a2 = v8;
    *(void *)(a2 + 8) = v11;
  }
  else
  {
    *(unsigned char *)(a2 + 48) &= ~1u;
    long long v12 = *(_OWORD *)&v15.st_uid;
    *(_OWORD *)a2 = *(_OWORD *)&v15.st_dev;
    *(_OWORD *)(a2 + 16) = v12;
    double result = *(double *)&v15.st_atimespec.tv_sec;
    *(timespec *)(a2 + 32) = v15.st_atimespec;
  }
  return result;
}

uint64_t llvm::sys::fs::openFile(unsigned __int8 *a1, int *a2, int a3, int a4, int a5, uint64_t a6)
{
  v20[16] = *MEMORY[0x1E4F143B8];
  int v8 = 2 * (a4 == 3);
  if (a4 == 2) {
    int v8 = 1;
  }
  if (a4 == 1) {
    int v8 = 0;
  }
  if ((a5 & 4) != 0) {
    a3 = 3;
  }
  int v10 = v8 | 0x600;
  int v11 = v8 | 0x200;
  if (a3 == 1) {
    v8 |= 0xA00u;
  }
  if (a3 == 3) {
    int v8 = v11;
  }
  if (!a3) {
    int v8 = v10;
  }
  int v12 = v8 | ((a5 << 20) & 0x1000000 | (2 * (a5 & 4))) ^ 0x1000000;
  std::string v18 = v20;
  long long v19 = xmmword_1811019F0;
  unint64_t v13 = (const char *)llvm::Twine::toNullTerminatedStringRef(a1, &v18);
  while (1)
  {
    *__error() = 0;
    int v14 = open(v13, v12, a6);
    if (v14 != -1) {
      break;
    }
    if (*__error() != 4)
    {
      *a2 = -1;
      goto LABEL_21;
    }
  }
  *a2 = v14;
  if ((v14 & 0x80000000) == 0)
  {
    std::system_category();
    uint64_t v15 = 0;
    __int16 v16 = v18;
    if (v18 == v20) {
      return v15;
    }
    goto LABEL_22;
  }
LABEL_21:
  uint64_t v15 = *__error();
  std::generic_category();
  __int16 v16 = v18;
  if (v18 == v20) {
    return v15;
  }
LABEL_22:
  free(v16);
  return v15;
}

llvm *llvm::sys::fs::openNativeFileForRead@<X0>(unsigned __int8 *a1@<X0>, int a2@<W1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  int v8 = 0;
  double result = (llvm *)llvm::sys::fs::openFileForRead(a1, &v8, a2, a3);
  if (result)
  {
    double result = (llvm *)llvm::errorCodeToError(result, v6, &v7);
    *(unsigned char *)(a4 + 8) |= 1u;
    *(void *)a4 = v7;
  }
  else
  {
    *(unsigned char *)(a4 + 8) &= ~1u;
    *(_DWORD *)a4 = v8;
  }
  return result;
}

ssize_t llvm::sys::fs::readNativeFileSlice@<X0>(int a1@<W0>, void *a2@<X1>, unint64_t a3@<X2>, off_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a3 >= 0x7FFFFFFF) {
    size_t v9 = 0x7FFFFFFFLL;
  }
  else {
    size_t v9 = a3;
  }
  while (1)
  {
    *__error() = 0;
    ssize_t result = pread(a1, a2, v9, a4);
    if (result != -1) {
      break;
    }
    if (*__error() != 4)
    {
      int v11 = (llvm *)*__error();
      *(void *)&v13.__val_ = std::generic_category();
      llvm::errorCodeToError(v11, v13, &v12);
      *(unsigned char *)(a5 + 8) |= 1u;
      ssize_t result = v12;
      goto LABEL_8;
    }
  }
  *(unsigned char *)(a5 + 8) &= ~1u;
LABEL_8:
  *(void *)a5 = result;
  return result;
}

uint64_t llvm::sys::fs::lockFile(llvm::sys::fs *this, int a2)
{
  v5[1] = 0;
  uint64_t v6 = 0;
  if (a2) {
    __int16 v2 = 3;
  }
  else {
    __int16 v2 = 1;
  }
  WORD2(v6) = v2;
  v5[0] = 0;
  if (fcntl((int)this, 9, v5) == -1)
  {
    uint64_t v4 = *__error();
    std::generic_category();
    return v4;
  }
  else
  {
    std::system_category();
    return 0;
  }
}

uint64_t llvm::sys::fs::unlockFile(llvm::sys::fs *this)
{
  int v4 = 2;
  v3[0] = 0;
  v3[1] = 0;
  if (fcntl((int)this, 8, v3) == -1)
  {
    uint64_t v2 = *__error();
    std::generic_category();
    return v2;
  }
  else
  {
    std::system_category();
    return 0;
  }
}

uint64_t llvm::sys::fs::closeFile(llvm::sys::fs *this, int *a2)
{
  uint64_t v2 = (llvm::sys::Process *)*(unsigned int *)this;
  *(_DWORD *)this = -1;
  return llvm::sys::Process::SafelyCloseFileDescriptor(v2);
}

unint64_t llvm::sys::fs::real_path(unsigned __int8 *a1, void *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  a2[1] = 0;
  if (a1[32] <= 1u)
  {
    std::system_category();
    unsigned int v3 = 0;
    goto LABEL_13;
  }
  if (!a3)
  {
    uint64_t v15 = v17;
    long long v16 = xmmword_1811019F0;
    uint64_t v7 = (const char *)llvm::Twine::toNullTerminatedStringRef(a1, &v15);
    if (realpath_DARWIN_EXTSN(v7, (char *)&v12))
    {
      size_t v8 = strlen((const char *)&v12);
      uint64_t v9 = a2[1];
      if (a2[2] < v9 + v8)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v9 + v8, 1);
        uint64_t v9 = a2[1];
      }
      if (v8)
      {
        memcpy((void *)(*a2 + v9), &v12, v8);
        uint64_t v9 = a2[1];
      }
      a2[1] = v9 + v8;
      std::system_category();
      unsigned int v3 = 0;
      int v10 = v15;
      if (v15 == v17) {
        goto LABEL_13;
      }
    }
    else
    {
      unsigned int v3 = *__error();
      std::generic_category();
      int v10 = v15;
      if (v15 == v17) {
        goto LABEL_13;
      }
    }
    free(v10);
LABEL_13:
    unint64_t v6 = 0;
    return v6 | v3;
  }
  ssize_t v12 = v14;
  long long v13 = xmmword_1811019F0;
  llvm::Twine::toVector((uint64_t)a1, (uint64_t)&v12);
  llvm::sys::fs::expandTildeExpr((uint64_t *)&v12);
  v17[4] = 261;
  uint64_t v15 = v12;
  *(void *)&long long v16 = v13;
  uint64_t v5 = llvm::sys::fs::real_path(&v15, a2, 0);
  unsigned int v3 = v5;
  unint64_t v6 = v5 & 0xFFFFFFFF00000000;
  if (v12 != v14) {
    free(v12);
  }
  return v6 | v3;
}

char *llvm::SmallVectorImpl<char>::insert<char *,void>(uint64_t *a1, uint64_t a2, char *__src, char *a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  uint64_t v9 = a2 - *a1;
  size_t v10 = a4 - __src;
  unint64_t v11 = v8 + a4 - __src;
  unint64_t v12 = a1[2];
  if (*a1 + v8 != a2)
  {
    if (v12 < v11)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v11, 1);
      uint64_t v7 = *a1;
      uint64_t v8 = a1[1];
    }
    long long v13 = (char *)(v7 + v9);
    int v14 = (char *)(v7 + v8);
    unint64_t v15 = v8 - v9;
    if (v8 - v9 < v10)
    {
      a1[1] = v8 + v10;
      if (v9 != v8) {
        memcpy((void *)(v7 + v10 + v9), (const void *)(v7 + v9), v8 - v9);
      }
      if (!v15)
      {
        uint64_t v18 = __src;
        goto LABEL_27;
      }
      if (v15 < 0x20 || (unint64_t)(v13 - __src) < 0x20)
      {
        long long v16 = (char *)(v7 + v9);
        unint64_t v17 = v8 - v9;
        uint64_t v18 = __src;
      }
      else
      {
        long long v16 = &v13[v15 & 0xFFFFFFFFFFFFFFE0];
        unint64_t v17 = v15 & 0x1F;
        uint64_t v18 = &__src[v15 & 0xFFFFFFFFFFFFFFE0];
        long long v19 = (long long *)(__src + 16);
        std::error_code v20 = (_OWORD *)(v9 + v7 + 16);
        unint64_t v21 = v15 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v22 = *v19;
          *(v20 - 1) = *(v19 - 1);
          *std::error_code v20 = v22;
          v19 += 2;
          v20 += 2;
          v21 -= 32;
        }
        while (v21);
        if (v15 == (v15 & 0xFFFFFFFFFFFFFFE0))
        {
LABEL_27:
          if (v18 != a4) {
            memcpy((void *)(v7 + v8), v18, a4 - v18);
          }
          return v13;
        }
      }
      do
      {
        char v28 = *v18++;
        *v16++ = v28;
        --v17;
      }
      while (v17);
      goto LABEL_27;
    }
    uint64_t v23 = v8;
    if (a1[2] < v10 + v8)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v10 + v8, 1);
      uint64_t v23 = a1[1];
    }
    uint64_t v24 = &v14[-v10];
    if (a4 == __src) {
      goto LABEL_43;
    }
    uint64_t v25 = *a1;
    size_t v26 = (unsigned char *)(*a1 + v23);
    if (v10 < 8)
    {
      long long v27 = &v14[-v10];
      goto LABEL_41;
    }
    long long v27 = &v14[-v10];
    if ((unint64_t)(a4 - __src - (v8 + v7) + v23 + v25) >= 0x20)
    {
      if (v10 < 0x20)
      {
        unint64_t v29 = 0;
        goto LABEL_36;
      }
      unint64_t v29 = v10 & 0xFFFFFFFFFFFFFFE0;
      __int16 v30 = (long long *)(&__src[v8] - a4 + v7 + 16);
      stat v31 = (_OWORD *)(v23 + v25 + 16);
      unint64_t v32 = v10 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v33 = *v30;
        *(v31 - 1) = *(v30 - 1);
        *stat v31 = v33;
        v30 += 2;
        v31 += 2;
        v32 -= 32;
      }
      while (v32);
      if (v10 == v29) {
        goto LABEL_42;
      }
      if ((v10 & 0x18) != 0)
      {
LABEL_36:
        v26 += v10 & 0xFFFFFFFFFFFFFFF8;
        long long v27 = &v24[v10 & 0xFFFFFFFFFFFFFFF8];
        __int16 v34 = (uint64_t *)(v7 + &__src[v8 + v29] - a4);
        char v35 = (void *)(v25 + v23 + v29);
        unint64_t v36 = v29 - (v10 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          uint64_t v37 = *v34++;
          *v35++ = v37;
          v36 += 8;
        }
        while (v36);
        if (v10 == (v10 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      long long v27 = &v24[v29];
      v26 += v29;
    }
    do
    {
LABEL_41:
      char v38 = *v27++;
      *v26++ = v38;
    }
    while (v27 != v14);
LABEL_42:
    uint64_t v23 = a1[1];
LABEL_43:
    a1[1] = v23 + v10;
    if (v24 != v13) {
      memmove(&v13[v10], (const void *)(v7 + v9), &v14[-v10] - v13);
    }
    if (a4 != __src) {
      memmove((void *)(v7 + v9), __src, v10);
    }
    return v13;
  }
  if (v12 < v11)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v11, 1);
    uint64_t v7 = *a1;
    uint64_t v8 = a1[1];
  }
  if (__src != a4)
  {
    memcpy((void *)(v7 + v8), __src, v10);
    uint64_t v7 = *a1;
    uint64_t v8 = a1[1];
  }
  a1[1] = v8 + v10;
  return (char *)(v7 + v9);
}

double llvm::sys::Process::GetEnv@<D0>(const void *a1@<X0>, size_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!a1)
  {
    *(void *)long long __dst = 0;
    size_t v22 = 0;
    int64_t v23 = 0;
    uint64_t v7 = getenv(__dst);
    if (v7) {
      goto LABEL_19;
    }
    goto LABEL_7;
  }
  if (a2 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_29;
  }
  if (a2 >= 0x17)
  {
    uint64_t v10 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v10 = a2 | 7;
    }
    uint64_t v11 = v10 + 1;
    unint64_t v6 = operator new(v10 + 1);
    size_t v22 = a2;
    int64_t v23 = v11 | 0x8000000000000000;
    *(void *)long long __dst = v6;
    goto LABEL_14;
  }
  HIBYTE(v23) = a2;
  unint64_t v6 = __dst;
  if (a2) {
LABEL_14:
  }
    memmove(v6, a1, a2);
  *((unsigned char *)v6 + a2) = 0;
  if (v23 >= 0) {
    unint64_t v12 = __dst;
  }
  else {
    unint64_t v12 = *(char **)__dst;
  }
  uint64_t v7 = getenv(v12);
  if (v7)
  {
LABEL_19:
    long long v13 = v7;
    size_t v14 = strlen(v7);
    if (v14 <= 0x7FFFFFFFFFFFFFF7)
    {
      size_t v15 = v14;
      if (v14 >= 0x17)
      {
        uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v14 | 7) != 0x17) {
          uint64_t v17 = v14 | 7;
        }
        uint64_t v18 = v17 + 1;
        long long v16 = (long long *)operator new(v17 + 1);
        *((void *)&v19 + 1) = v15;
        unint64_t v20 = v18 | 0x8000000000000000;
        *(void *)&long long v19 = v16;
      }
      else
      {
        HIBYTE(v20) = v14;
        long long v16 = &v19;
        if (!v14)
        {
LABEL_27:
          *((unsigned char *)v16 + v15) = 0;
          double result = *(double *)&v19;
          *(_OWORD *)a3 = v19;
          *(void *)(a3 + 16) = v20;
          *(unsigned char *)(a3 + 24) = 1;
          if ((SHIBYTE(v23) & 0x80000000) == 0) {
            return result;
          }
          goto LABEL_8;
        }
      }
      memmove(v16, v13, v15);
      goto LABEL_27;
    }
LABEL_29:
    abort();
  }
LABEL_7:
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 24) = 0;
  if ((SHIBYTE(v23) & 0x80000000) == 0) {
    return result;
  }
LABEL_8:
  uint64_t v9 = *(char **)__dst;

  operator delete(v9);
  return result;
}

void llvm::sys::Process::getPageSize(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB216308, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB216308))
  {
    _MergedGlobals_55 = getpagesize();
    __cxa_guard_release(&qword_1EB216308);
  }
  int v3 = _MergedGlobals_55;
  if (_MergedGlobals_55 == -1)
  {
    int v4 = (llvm *)*__error();
    *(void *)&v6.__val_ = std::generic_category();
    llvm::errorCodeToError(v4, v6, &v5);
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v5;
  }
  else
  {
    *(unsigned char *)(a1 + 8) &= ~1u;
    *(_DWORD *)a1 = v3;
  }
}

uint64_t llvm::sys::Process::SafelyCloseFileDescriptor(llvm::sys::Process *this)
{
  int v1 = (int)this;
  sigset_t v5 = -1;
  sigset_t v6 = -1;
  unsigned int v2 = pthread_sigmask(3, &v6, &v5);
  if (!v2)
  {
    if ((close(v1) & 0x80000000) == 0)
    {
      int v3 = pthread_sigmask(3, &v5, 0);
LABEL_5:
      unsigned int v2 = v3;
      goto LABEL_6;
    }
    unsigned int v2 = *__error();
    int v3 = pthread_sigmask(3, &v5, 0);
    if (!v2) {
      goto LABEL_5;
    }
  }
LABEL_6:
  std::generic_category();
  return v2;
}

BOOL llvm::sys::Process::FileDescriptorIsDisplayed(llvm::sys::Process *this)
{
  return isatty((int)this) != 0;
}

BOOL checkTerminalEnvironmentForColors(void)
{
  v0 = getenv("TERM");
  int v1 = v0;
  if (!v0) {
    return 0;
  }
  size_t v2 = strlen(v0);
  if (v2 == 6)
  {
    if (*(_DWORD *)v1 == 2003269987 && *((_WORD *)v1 + 2) == 28265) {
      return v1 != 0;
    }
LABEL_22:
    if (*(_DWORD *)v1 == 1701995379 && *((_WORD *)v1 + 2) == 28261) {
      return v1 != 0;
    }
LABEL_26:
    if (*(_DWORD *)v1 == 1919251576 && v1[4] == 109) {
      return v1 != 0;
    }
    BOOL v8 = *(_DWORD *)v1 == 808547446 && v1[4] == 48;
    if (v8 || *(_DWORD *)v1 == 1953921138) {
      return v1 != 0;
    }
    if (*(_DWORD *)&v1[v2 - 5] == 1869377379 && v1[v2 - 1] == 114) {
      return v1 != 0;
    }
    return 0;
  }
  if (v2 == 5)
  {
    if (*(_DWORD *)v1 == 1970170220 && v1[4] == 120) {
      return v1 != 0;
    }
    goto LABEL_26;
  }
  if (v2 != 4)
  {
    if (v2 < 6) {
      return 0;
    }
    goto LABEL_22;
  }
  if (*(_DWORD *)v1 != 1769172577 && *(_DWORD *)v1 != 1953921138) {
    return 0;
  }
  return v1 != 0;
}

BOOL llvm::sys::Process::FileDescriptorHasColors(llvm::sys::Process *this)
{
  int v1 = (int)this;
  if (!isatty((int)this)) {
    return 0;
  }
  {
    __cxa_atexit(MEMORY[0x1E4FBA268], &terminalHasColors(int)::TermColorMutex, &dword_180159000);
  }
  std::mutex::lock(&terminalHasColors(int)::TermColorMutex);
  size_t v2 = set_curterm(0);
  int v8 = 0;
  int v3 = setupterm(0, v1, &v8);
  BOOL v4 = 0;
  if (!v3)
  {
    int v5 = tigetnum("colors");
    if (v5 < 0) {
      BOOL v4 = checkTerminalEnvironmentForColors();
    }
    else {
      BOOL v4 = v5 != 0;
    }
    uint64_t v7 = set_curterm(v2);
    del_curterm(v7);
  }
  std::mutex::unlock(&terminalHasColors(int)::TermColorMutex);
  return v4;
}

char *llvm::sys::Process::OutputColor(llvm::sys::Process *this, int a2, int a3)
{
  return &colorcodes[160 * a3 + 80 * a2 + 10 * (this & 7)];
}

const char *llvm::sys::Process::OutputBold(llvm::sys::Process *this)
{
  return "\x1B[1m";
}

const char *llvm::sys::Process::OutputReverse(llvm::sys::Process *this)
{
  return "\x1B[7m";
}

const char *llvm::sys::Process::ResetColor(llvm::sys::Process *this)
{
  return "\x1B[0m";
}

uint64_t llvm::sys::ExecuteAndWait(void *a1, size_t a2, uint64_t a3, uint64_t a4, long long *a5, long long *a6, uint64_t a7, unsigned int a8, unsigned int a9, uint64_t a10, unsigned char *a11, uint64_t a12)
{
  v17[0] = 0;
  v17[2] = 0;
  long long v15 = *a5;
  uint64_t v16 = *((void *)a5 + 2);
  if (Execute(v17, a1, a2, a3, a4, (uint64_t)&v15, a6, a7, a9, a10))
  {
    if (a11) {
      *a11 = 0;
    }
    llvm::sys::Wait(v17, a8 | ((unint64_t)(a8 != 0) << 32), a10, a12, 0);
    return v13;
  }
  else
  {
    if (a11) {
      *a11 = 1;
    }
    return 0xFFFFFFFFLL;
  }
}

BOOL Execute(pid_t *a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  __src = a2;
  size_t __len = a3;
  v101[0] = 261;
  v99.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  v99.__r_.__value_.__l.__size_ = a3;
  if (llvm::sys::fs::access((unsigned __int8 *)&v99, 0))
  {
    if (!a10) {
      return 0;
    }
    *((unsigned char *)&v97[0].__r_.__value_.__s + 23) = 12;
    strcpy((char *)v97, "Executable \"");
    if (!a2)
    {
      std::string::size_type size = 0;
      std::string::size_type v26 = 0;
      unsigned int v27 = 0;
      memset(&__dst, 0, sizeof(__dst));
      goto LABEL_27;
    }
    if (a3 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (a3 >= 0x17)
      {
        uint64_t v31 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a3 | 7) != 0x17) {
          uint64_t v31 = a3 | 7;
        }
        uint64_t v32 = v31 + 1;
        p_dst = (std::string *)operator new(v31 + 1);
        __dst.__r_.__value_.__l.__size_ = a3;
        __dst.__r_.__value_.__r.__words[2] = v32 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = a3;
        p_dst = &__dst;
        if (!a3) {
          goto LABEL_26;
        }
      }
      memmove(p_dst, a2, a3);
LABEL_26:
      p_dst->__r_.__value_.__s.__data_[a3] = 0;
      unsigned int v27 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      std::string::size_type v26 = __dst.__r_.__value_.__r.__words[0];
LABEL_27:
      if ((v27 & 0x80u) == 0) {
        long long v33 = &__dst;
      }
      else {
        long long v33 = (std::string *)v26;
      }
      if ((v27 & 0x80u) == 0) {
        std::string::size_type v34 = v27;
      }
      else {
        std::string::size_type v34 = size;
      }
      char v35 = std::string::append(v97, (const std::string::value_type *)v33, v34);
      std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v99.__r_.__value_.__l.__data_ = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
      v99.__r_.__value_.__r.__words[2] = v36;
      v35->__r_.__value_.__l.__size_ = 0;
      v35->__r_.__value_.__r.__words[2] = 0;
      v35->__r_.__value_.__r.__words[0] = 0;
      char v93 = 16;
      strcpy(__s, "\" doesn't exist!");
      uint64_t v37 = std::string::append(&v99, __s, 0x10uLL);
      std::string::size_type v38 = v37->__r_.__value_.__r.__words[0];
      *(void *)uint64_t v105 = v37->__r_.__value_.__l.__size_;
      *(void *)&v105[7] = *(std::string::size_type *)((char *)&v37->__r_.__value_.__r.__words[1] + 7);
      char v39 = HIBYTE(v37->__r_.__value_.__r.__words[2]);
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      if (*(char *)(a10 + 23) < 0) {
        operator delete(*(void **)a10);
      }
      uint64_t v40 = *(void *)v105;
      *(void *)a10 = v38;
      *(void *)(a10 + 8) = v40;
      *(void *)(a10 + 15) = *(void *)&v105[7];
      *(unsigned char *)(a10 + 23) = v39;
      if (v93 < 0)
      {
        operator delete(*(void **)__s);
        if ((SHIBYTE(v99.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_37:
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_38;
          }
          goto LABEL_42;
        }
      }
      else if ((SHIBYTE(v99.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_37;
      }
      operator delete(v99.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_38:
        if ((SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return 0;
        }
LABEL_43:
        operator delete(v97[0].__r_.__value_.__l.__data_);
        return 0;
      }
LABEL_42:
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return 0;
      }
      goto LABEL_43;
    }
LABEL_180:
    abort();
  }
  long long v19 = a7;
  int v84 = a1;
  *(_OWORD *)&v99.__r_.__value_.__l.__data_ = 0uLL;
  v99.__r_.__value_.__r.__words[2] = (std::string::size_type)v101;
  uint64_t v100 = 0x400000000;
  uint64_t v102 = (llvm **)v104;
  uint64_t v103 = 0;
  v104[0] = 0;
  v104[1] = 1;
  *(void *)__s = &v99;
  toNullTerminatedCStringArray(&v97[0].__r_.__value_.__l.__data_, a4, a5, (uint64_t **)__s);
  unint64_t v20 = (char **)v97[0].__r_.__value_.__r.__words[0];
  if (*(unsigned char *)(a6 + 16))
  {
    toNullTerminatedCStringArray(&v97[0].__r_.__value_.__l.__data_, *(void *)a6, *(void *)(a6 + 8), (uint64_t **)__s);
    unint64_t v21 = (char **)v97[0].__r_.__value_.__r.__words[0];
    size_t v22 = a1;
    if (a9) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v21 = 0;
    size_t v22 = a1;
    if (a9)
    {
LABEL_10:
      pid_t v23 = fork();
      if (v23)
      {
        if (v23 == -1)
        {
          *((unsigned char *)&v97[0].__r_.__value_.__s + 23) = 13;
          strcpy((char *)v97, "Couldn't fork");
          MakeErrMsg(a10, (const void **)&v97[0].__r_.__value_.__l.__data_, (llvm::sys *)0xFFFFFFFFLL);
          BOOL v24 = 0;
          if (!v21) {
            goto LABEL_142;
          }
        }
        else
        {
          *size_t v22 = v23;
          v22[1] = v23;
          BOOL v24 = 1;
          if (!v21) {
            goto LABEL_142;
          }
        }
        goto LABEL_141;
      }
      if (!a8) {
        goto LABEL_181;
      }
      long long v89 = *a7;
      uint64_t v90 = *((void *)a7 + 2);
      BOOL v24 = 0;
      if (RedirectIO((uint64_t)&v89, 0, a10)) {
        goto LABEL_140;
      }
      long long v87 = *(long long *)((char *)a7 + 24);
      uint64_t v88 = *((void *)a7 + 5);
      if ((RedirectIO((uint64_t)&v87, 1, a10) & 1) == 0)
      {
        if (!*((unsigned char *)a7 + 40)
          || !*((unsigned char *)a7 + 64)
          || (size_t v41 = *((void *)a7 + 4), v41 != *((void *)a7 + 7))
          || v41 && memcmp(*((const void **)a7 + 3), *((const void **)a7 + 6), v41))
        {
          long long v85 = a7[3];
          uint64_t v86 = *((void *)a7 + 8);
          if (RedirectIO((uint64_t)&v85, 2, a10)) {
            goto LABEL_53;
          }
LABEL_181:
          SetMemoryLimits(a9);
          std::string::basic_string<llvm::StringRef,0>(v97, (uint64_t)&__src);
          if ((v97[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v80 = v97;
          }
          else {
            int v80 = (std::string *)v97[0].__r_.__value_.__r.__words[0];
          }
          if (!v21)
          {
            execv((const char *)v80, v20);
            if (*__error() == 2) {
              int v81 = 127;
            }
            else {
              int v81 = 126;
            }
            _exit(v81);
          }
          execve((const char *)v80, v20, v21);
          if (*__error() == 2) {
            int v82 = 127;
          }
          else {
            int v82 = 126;
          }
          _exit(v82);
        }
        if (dup2(1, 2) != -1) {
          goto LABEL_181;
        }
        std::string::basic_string[abi:nn180100]<0>(v97, "Can't redirect stderr to stdout");
        MakeErrMsg(a10, (const void **)&v97[0].__r_.__value_.__l.__data_, (llvm::sys *)0xFFFFFFFFLL);
        if (SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v97[0].__r_.__value_.__l.__data_);
        }
      }
LABEL_53:
      BOOL v24 = 0;
      if (!v21) {
        goto LABEL_142;
      }
      goto LABEL_141;
    }
  }
  *(void *)uint64_t v105 = 0;
  memset(&v98, 0, sizeof(v98));
  memset(v97, 0, sizeof(v97));
  if (!a8)
  {
    uint64_t v42 = v21;
    unint64_t v43 = 0;
    goto LABEL_58;
  }
  if (!*((unsigned char *)a7 + 16))
  {
    unint64_t v54 = 0;
    if (*((unsigned char *)a7 + 40)) {
      goto LABEL_95;
    }
LABEL_85:
    uint64_t v55 = 0;
    if (*((unsigned char *)v19 + 64)) {
      goto LABEL_106;
    }
    goto LABEL_86;
  }
  std::string::size_type v28 = *((void *)a7 + 1);
  if (v28 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_180;
  }
  unint64_t v29 = *(const void **)a7;
  if (v28 >= 0x17)
  {
    uint64_t v57 = (v28 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v28 | 7) != 0x17) {
      uint64_t v57 = v28 | 7;
    }
    uint64_t v58 = v57 + 1;
    __int16 v30 = (std::string *)operator new(v57 + 1);
    __dst.__r_.__value_.__l.__size_ = v28;
    __dst.__r_.__value_.__r.__words[2] = v58 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
    goto LABEL_91;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *((void *)v19 + 1);
  __int16 v30 = &__dst;
  if (v28) {
LABEL_91:
  }
    memmove(v30, v29, v28);
  v30->__r_.__value_.__s.__data_[v28] = 0;
  if (SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97[0].__r_.__value_.__l.__data_);
  }
  v97[0] = __dst;
  unint64_t v54 = v97;
  if (!*((unsigned char *)v19 + 40)) {
    goto LABEL_85;
  }
LABEL_95:
  std::string::size_type v59 = *((void *)v19 + 4);
  if (v59 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_180;
  }
  uint64_t v60 = (const void *)*((void *)v19 + 3);
  if (v59 >= 0x17)
  {
    uint64_t v62 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v59 | 7) != 0x17) {
      uint64_t v62 = v59 | 7;
    }
    uint64_t v63 = v62 + 1;
    uint64_t v61 = (std::string *)operator new(v62 + 1);
    __dst.__r_.__value_.__l.__size_ = v59;
    __dst.__r_.__value_.__r.__words[2] = v63 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
    goto LABEL_102;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *((void *)v19 + 4);
  uint64_t v61 = &__dst;
  if (v59) {
LABEL_102:
  }
    memmove(v61, v60, v59);
  v61->__r_.__value_.__s.__data_[v59] = 0;
  uint64_t v55 = &v97[1];
  if (SHIBYTE(v97[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97[1].__r_.__value_.__l.__data_);
  }
  v97[1] = __dst;
  if (*((unsigned char *)v19 + 64))
  {
LABEL_106:
    std::string::size_type v64 = *((void *)v19 + 7);
    if (v64 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_180;
    }
    long long v65 = (const void *)*((void *)v19 + 6);
    if (v64 >= 0x17)
    {
      uint64_t v67 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v64 | 7) != 0x17) {
        uint64_t v67 = v64 | 7;
      }
      uint64_t v68 = v67 + 1;
      uint64_t v66 = (std::string *)operator new(v67 + 1);
      __dst.__r_.__value_.__l.__size_ = v64;
      __dst.__r_.__value_.__r.__words[2] = v68 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v66;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *((void *)v19 + 7);
      uint64_t v66 = &__dst;
      if (!v64)
      {
LABEL_114:
        v66->__r_.__value_.__s.__data_[v64] = 0;
        uint64_t v56 = &v98;
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v98.__r_.__value_.__l.__data_);
        }
        std::string v98 = __dst;
        posix_spawn_file_actions_init((posix_spawn_file_actions_t *)v105);
        if (!v54) {
          goto LABEL_127;
        }
        goto LABEL_117;
      }
    }
    memmove(v66, v65, v64);
    goto LABEL_114;
  }
LABEL_86:
  uint64_t v56 = 0;
  posix_spawn_file_actions_init((posix_spawn_file_actions_t *)v105);
  if (!v54) {
    goto LABEL_127;
  }
LABEL_117:
  if (SHIBYTE(v54->__r_.__value_.__r.__words[2]) < 0)
  {
    if (v54->__r_.__value_.__l.__size_) {
      long long v69 = (const char *)v54->__r_.__value_.__r.__words[0];
    }
    else {
      long long v69 = "/dev/null";
    }
  }
  else if (*((unsigned char *)&v54->__r_.__value_.__s + 23))
  {
    long long v69 = (const char *)v54;
  }
  else
  {
    long long v69 = "/dev/null";
  }
  long long v71 = (llvm::sys *)posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)v105, 0, v69, 0, 0x1B6u);
  if (v71)
  {
LABEL_136:
    long long v73 = v71;
    uint64_t v74 = (char *)operator new(0x28uLL);
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
    *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = xmmword_1811286F0;
    strcpy(v74, "Cannot posix_spawn_file_actions_addopen");
    MakeErrMsg(a10, (const void **)&__dst.__r_.__value_.__l.__data_, v73);
    operator delete(v74);
    BOOL v24 = 0;
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_137;
    }
    goto LABEL_138;
  }
LABEL_127:
  if (v55)
  {
    if (SHIBYTE(v55->__r_.__value_.__r.__words[2]) < 0) {
      int v72 = v55->__r_.__value_.__l.__size_ ? (const char *)v55->__r_.__value_.__r.__words[0] : "/dev/null";
    }
    else {
      int v72 = *((unsigned char *)&v55->__r_.__value_.__s + 23) ? (const char *)v55 : "/dev/null";
    }
    long long v71 = (llvm::sys *)posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)v105, 1, v72, 513, 0x1B6u);
    if (v71) {
      goto LABEL_136;
    }
  }
  if (*((unsigned char *)v19 + 40)
    && *((unsigned char *)v19 + 64)
    && (size_t v76 = *((void *)v19 + 4), v76 == *((void *)v19 + 7))
    && (!v76 || !memcmp(*((const void **)v19 + 3), *((const void **)v19 + 6), v76)))
  {
    unint64_t v43 = (posix_spawn_file_actions_t *)v105;
    int v78 = (llvm::sys *)posix_spawn_file_actions_adddup2((posix_spawn_file_actions_t *)v105, 1, 2);
    if (v78)
    {
      int v79 = v78;
      std::string::basic_string[abi:nn180100]<0>(&__dst, "Can't redirect stderr to stdout");
      MakeErrMsg(a10, (const void **)&__dst.__r_.__value_.__l.__data_, v79);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      BOOL v24 = 0;
      if ((SHIBYTE(v98.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_138;
      }
LABEL_137:
      operator delete(v98.__r_.__value_.__l.__data_);
      goto LABEL_138;
    }
  }
  else
  {
    if (!v56)
    {
      uint64_t v42 = v21;
      unint64_t v43 = (posix_spawn_file_actions_t *)v105;
      goto LABEL_58;
    }
    if (SHIBYTE(v56->__r_.__value_.__r.__words[2]) < 0)
    {
      if (v56->__r_.__value_.__l.__size_) {
        uint64_t v77 = (const char *)v56->__r_.__value_.__r.__words[0];
      }
      else {
        uint64_t v77 = "/dev/null";
      }
    }
    else if (*((unsigned char *)&v56->__r_.__value_.__s + 23))
    {
      uint64_t v77 = (const char *)v56;
    }
    else
    {
      uint64_t v77 = "/dev/null";
    }
    unint64_t v43 = (posix_spawn_file_actions_t *)v105;
    long long v71 = (llvm::sys *)posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)v105, 2, v77, 513, 0x1B6u);
    if (v71) {
      goto LABEL_136;
    }
  }
  uint64_t v42 = v21;
LABEL_58:
  unsigned int v44 = 0;
  uint64_t v83 = v42;
  if (v42) {
    size_t v45 = v42;
  }
  else {
    size_t v45 = (char *const *)*MEMORY[0x1E4F147F0];
  }
  do
  {
    pid_t v91 = 0;
    unint64_t v46 = __src;
    if (!__src)
    {
      memset(&__dst, 0, sizeof(__dst));
      unint64_t v49 = &__dst;
      goto LABEL_74;
    }
    size_t v47 = __len;
    if (__len > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_180;
    }
    if (__len >= 0x17)
    {
      size_t v50 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len | 7) != 0x17) {
        size_t v50 = __len | 7;
      }
      size_t v51 = v50 + 1;
      size_t v48 = (std::string *)operator new(v50 + 1);
      __dst.__r_.__value_.__l.__size_ = v47;
      __dst.__r_.__value_.__r.__words[2] = v51 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
LABEL_70:
      memmove(v48, v46, v47);
      goto LABEL_71;
    }
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
    size_t v48 = &__dst;
    if (__len) {
      goto LABEL_70;
    }
LABEL_71:
    v48->__r_.__value_.__s.__data_[v47] = 0;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v49 = &__dst;
    }
    else {
      unint64_t v49 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
LABEL_74:
    int v52 = (llvm::sys *)posix_spawn(&v91, (const char *)v49, v43, 0, v20, v45);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v52 != 4) {
      break;
    }
  }
  while (v44++ < 7);
  if (v43) {
    posix_spawn_file_actions_destroy(v43);
  }
  BOOL v24 = v52 == 0;
  unint64_t v21 = v83;
  if (!v52)
  {
    pid_t v70 = v91;
    pid_t *v84 = v91;
    v84[1] = v70;
    if ((SHIBYTE(v98.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_138;
    }
    goto LABEL_137;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 18;
  strcpy((char *)&__dst, "posix_spawn failed");
  MakeErrMsg(a10, (const void **)&__dst.__r_.__value_.__l.__data_, v52);
  if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_137;
  }
LABEL_138:
  if ((SHIBYTE(v97[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_140;
    }
LABEL_154:
    operator delete(v97[0].__r_.__value_.__l.__data_);
    if (!v21) {
      goto LABEL_142;
    }
LABEL_141:
    operator delete(v21);
    goto LABEL_142;
  }
  operator delete(v97[1].__r_.__value_.__l.__data_);
  if (SHIBYTE(v97[0].__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_154;
  }
LABEL_140:
  if (v21) {
    goto LABEL_141;
  }
LABEL_142:
  if (v20) {
    operator delete(v20);
  }
  if (v100) {
    llvm::deallocate_buffer(*(llvm **)v99.__r_.__value_.__r.__words[2], (void *)0x1000);
  }
  if (v103) {
    llvm::deallocate_buffer(*v102, v102[1]);
  }
  if (v102 != v104) {
    free(v102);
  }
  if ((_WORD *)v99.__r_.__value_.__r.__words[2] != v101) {
    free((void *)v99.__r_.__value_.__r.__words[2]);
  }
  return v24;
}

uint64_t llvm::sys::Wait(pid_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  pid_t v9 = *a1;
  uint64_t v10 = a2 & 0xFF00000000;
  if ((a2 & 0xFF00000000) != 0)
  {
    unsigned int v11 = a2;
    BOOL v12 = a2 == 0;
    v28.__sigaction_u.__sa_handler = (void (__cdecl *)(int))TimeOutHandler;
    *(void *)&v28.sa_mask = 0;
    sigaction(14, &v28, &v27);
    alarm(v11);
    int v26 = 0;
    if (!a4) {
      goto LABEL_7;
    }
  }
  else
  {
    BOOL v12 = 0;
    int v26 = 0;
    if (!a4) {
      goto LABEL_7;
    }
  }
  if (*(unsigned char *)(a4 + 24)) {
    *(unsigned char *)(a4 + 24) = 0;
  }
LABEL_7:
  if (v10)
  {
    pid_t v13 = wait4(v9, &v26, v12, &v25);
  }
  else
  {
    while (1)
    {
      pid_t v13 = wait4(v9, &v26, v12, &v25);
      if (v13 != -1) {
        break;
      }
      if (*__error() != 4)
      {
        unsigned int v14 = -1;
        if (*a1 == -1) {
          goto LABEL_22;
        }
        goto LABEL_19;
      }
    }
  }
  unsigned int v14 = v13;
  if (v13 != *a1)
  {
    if (!v13) {
      return v14;
    }
    if (v10 && *__error() == 4 && (a5 & 1) == 0)
    {
      kill(*a1, 9);
      alarm(0);
      sigaction(14, &v27, 0);
      if (wait(&v26) == v9)
      {
        v24[23] = 15;
        strcpy(v24, "Child timed out");
        MakeErrMsg(a3, (const void **)v24, 0);
      }
      else
      {
        size_t v22 = (char *)operator new(0x28uLL);
        *(void *)BOOL v24 = v22;
        *(_OWORD *)&v24[8] = xmmword_181128700;
        strcpy(v22, "Child timed out but wouldn't die");
        MakeErrMsg(a3, (const void **)v24, (llvm::sys *)0xFFFFFFFFLL);
        operator delete(v22);
      }
      return v14;
    }
LABEL_19:
    if (*__error() != 4)
    {
      unint64_t v21 = (char *)operator new(0x20uLL);
      *(void *)BOOL v24 = v21;
      *(_OWORD *)&v24[8] = xmmword_181128710;
      strcpy(v21, "Error waiting for child process");
      MakeErrMsg(a3, (const void **)v24, (llvm::sys *)0xFFFFFFFFLL);
      operator delete(v21);
      return v14;
    }
  }
  if (v10)
  {
    alarm(0);
    sigaction(14, &v27, 0);
  }
LABEL_22:
  if (a4
    && (__darwin_time_t v15 = v25.ru_utime.tv_usec + 1000000 * v25.ru_utime.tv_sec,
        uint64_t ru_maxrss = v25.ru_maxrss,
        int v17 = *(unsigned __int8 *)(a4 + 24),
        *(void *)a4 = v15 + 1000000 * v25.ru_stime.tv_sec + v25.ru_stime.tv_usec,
        *(void *)(a4 + 8) = v15,
        *(void *)(a4 + 16) = ru_maxrss,
        !v17))
  {
    *(unsigned char *)(a4 + 24) = 1;
    char v18 = BYTE1(v26);
    int v19 = v26 & 0x7F;
    if (v19 == 127) {
      return v14;
    }
  }
  else
  {
    char v18 = BYTE1(v26);
    int v19 = v26 & 0x7F;
    if (v19 == 127) {
      return v14;
    }
  }
  if (v19)
  {
    if (a3)
    {
      unint64_t v20 = strsignal(v19);
      MEMORY[0x1852FD9E0](a3, v20);
      if ((v26 & 0x80) != 0) {
        std::string::append((std::string *)a3, " (core dumped)");
      }
    }
  }
  else if (v18 == 126)
  {
    if (a3) {
      MEMORY[0x1852FD9E0](a3, "Program could not be executed");
    }
  }
  else if (v18 == 127 && a3)
  {
    llvm::sys::StrError(2, v24);
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = *(_OWORD *)v24;
    *(void *)(a3 + 16) = *(void *)&v24[16];
  }
  return v14;
}

double llvm::sys::findProgramByName@<D0>(void *__s@<X0>, size_t __n@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  size_t v7 = __n;
  v48[32] = *MEMORY[0x1E4F143B8];
  if (__n)
  {
    pid_t v9 = memchr(__s, 47, __n);
    if (v9)
    {
      if (v9 - (unsigned char *)__s != -1)
      {
        if (v7 > 0x7FFFFFFFFFFFFFF7) {
LABEL_43:
        }
          abort();
        if (v7 >= 0x17)
        {
          uint64_t v32 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v7 | 7) != 0x17) {
            uint64_t v32 = v7 | 7;
          }
          uint64_t v33 = v32 + 1;
          uint64_t v10 = (long long *)operator new(v32 + 1);
          *((void *)&v47 + 1) = v7;
          v48[0] = v33 | 0x8000000000000000;
          *(void *)&long long v47 = v10;
        }
        else
        {
          HIBYTE(v48[0]) = v7;
          uint64_t v10 = &v47;
        }
        memmove(v10, __s, v7);
        *((unsigned char *)v10 + v7) = 0;
        *(unsigned char *)(a5 + 24) &= ~1u;
        double result = *(double *)&v47;
        *(_OWORD *)a5 = v47;
        *(void *)(a5 + 16) = v48[0];
        return result;
      }
    }
  }
  *(void *)&long long v47 = v48;
  *((void *)&v47 + 1) = 0x1000000000;
  if (a4)
  {
    uint64_t v11 = a3 + 16 * a4;
    goto LABEL_11;
  }
  sigaction v28 = getenv("PATH");
  if (v28)
  {
    uint64_t v29 = (uint64_t)v28;
    size_t v30 = strlen(v28);
    llvm::SplitString(v29, v30, (uint64_t)&v47, ":", 1);
    if (DWORD2(v47))
    {
      a3 = v47;
      uint64_t v11 = v47 + 16 * DWORD2(v47);
      do
      {
LABEL_11:
        unint64_t v12 = *(void *)(a3 + 8);
        if (!v12) {
          goto LABEL_10;
        }
        pid_t v13 = *(const void **)a3;
        __src = v46;
        long long __len = xmmword_1811019F0;
        if (v12 < 0x81)
        {
          uint64_t v14 = 0;
          __darwin_time_t v15 = v46;
        }
        else
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v46, v12, 1);
          __darwin_time_t v15 = __src;
          uint64_t v14 = __len;
        }
        memcpy(&v15[v14], v13, v12);
        *(void *)&long long __len = __len + v12;
        __int16 v43 = 261;
        *(void *)&long long __dst = __s;
        *((void *)&__dst + 1) = v7;
        __int16 v40 = 257;
        __int16 v38 = 257;
        __int16 v36 = 257;
        llvm::sys::path::append(&__src, (void **)&__dst, &v39, &v37, &v35);
        if ((unint64_t)(__len + 1) > *((void *)&__len + 1))
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v46, __len + 1, 1);
          *((unsigned char *)__src + __len) = 0;
          int v17 = __src;
          __int16 v43 = 257;
          if (!*(unsigned char *)__src)
          {
LABEL_20:
            LOBYTE(v43) = 1;
            BOOL can_execute = llvm::sys::fs::can_execute((llvm::sys::fs *)&__dst, v16);
            BOOL v20 = can_execute;
            unint64_t v21 = __src;
            if (!can_execute) {
              goto LABEL_30;
            }
LABEL_21:
            size_t v23 = __len;
            if ((unint64_t)__len > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_43;
            }
            size_t v24 = v7;
            if ((unint64_t)__len >= 0x17)
            {
              uint64_t v26 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
              if (((unint64_t)__len | 7) != 0x17) {
                uint64_t v26 = __len | 7;
              }
              uint64_t v27 = v26 + 1;
              p_dst = (long long *)operator new(v26 + 1);
              *((void *)&__dst + 1) = v23;
              unint64_t v42 = v27 | 0x8000000000000000;
              *(void *)&long long __dst = p_dst;
            }
            else
            {
              HIBYTE(v42) = __len;
              p_dst = &__dst;
              if (!(void)__len) {
                goto LABEL_29;
              }
            }
            memmove(p_dst, v21, v23);
LABEL_29:
            *((unsigned char *)p_dst + v23) = 0;
            *(unsigned char *)(a5 + 24) &= ~1u;
            double result = *(double *)&__dst;
            *(_OWORD *)a5 = __dst;
            *(void *)(a5 + 16) = v42;
            unint64_t v21 = __src;
            size_t v7 = v24;
            goto LABEL_30;
          }
        }
        else
        {
          *((unsigned char *)__src + __len) = 0;
          int v17 = __src;
          __int16 v43 = 257;
          if (!*(unsigned char *)__src) {
            goto LABEL_20;
          }
        }
        *(void *)&long long __dst = v17;
        LOBYTE(v43) = 3;
        BOOL v18 = llvm::sys::fs::can_execute((llvm::sys::fs *)&__dst, v16);
        BOOL v20 = v18;
        unint64_t v21 = __src;
        if (v18) {
          goto LABEL_21;
        }
LABEL_30:
        if (v21 != v46) {
          free(v21);
        }
        if (v20) {
          goto LABEL_36;
        }
LABEL_10:
        a3 += 16;
      }
      while (a3 != v11);
    }
  }
  *(unsigned char *)(a5 + 24) |= 1u;
  uint64_t v31 = std::generic_category();
  *(void *)a5 = 2;
  *(void *)(a5 + 8) = v31;
LABEL_36:
  if ((void *)v47 != v48) {
    free((void *)v47);
  }
  return result;
}

void *std::string::basic_string<llvm::StringRef,0>(void *__dst, uint64_t a2)
{
  size_t v2 = *(void *)(a2 + 8);
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  BOOL v4 = *(const void **)a2;
  if (v2 >= 0x17)
  {
    uint64_t v6 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v6 = v2 | 7;
    }
    uint64_t v7 = v6 + 1;
    int v5 = operator new(v6 + 1);
    __dst[1] = v2;
    __dst[2] = v7 | 0x8000000000000000;
    *long long __dst = v5;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v2;
    int v5 = __dst;
    if (!v2) {
      goto LABEL_9;
    }
  }
  memmove(v5, v4, v2);
LABEL_9:
  *((unsigned char *)v5 + v2) = 0;
  return __dst;
}

void MakeErrMsg(uint64_t a1, const void **a2, llvm::sys *this)
{
  stat v22[2] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  uint64_t v3 = (uint64_t)this;
  if (this == -1) {
    uint64_t v3 = *__error();
  }
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = (size_t)a2[1];
  }
  unint64_t v8 = v7 + 2;
  if (v7 + 2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v8 >= 0x17)
  {
    uint64_t v10 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v10 = v8 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7 + 2;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_14;
  }
  memset(&__dst, 0, sizeof(__dst));
  p_dst = &__dst;
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v7 + 2;
  if (v7)
  {
LABEL_14:
    if (v6 >= 0) {
      unint64_t v12 = a2;
    }
    else {
      unint64_t v12 = *a2;
    }
    memmove(p_dst, v12, v7);
  }
  strcpy((char *)p_dst + v7, ": ");
  llvm::sys::StrError(v3, __p);
  if ((v20 & 0x80u) == 0) {
    pid_t v13 = __p;
  }
  else {
    pid_t v13 = (void **)__p[0];
  }
  if ((v20 & 0x80u) == 0) {
    std::string::size_type v14 = v20;
  }
  else {
    std::string::size_type v14 = (std::string::size_type)__p[1];
  }
  __darwin_time_t v15 = std::string::append(&__dst, (const std::string::value_type *)v13, v14);
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[0];
  v22[0] = v15->__r_.__value_.__l.__size_;
  *(void *)((char *)v22 + 7) = *(std::string::size_type *)((char *)&v15->__r_.__value_.__r.__words[1] + 7);
  char v17 = HIBYTE(v15->__r_.__value_.__r.__words[2]);
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  uint64_t v18 = v22[0];
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v18;
  *(void *)(a1 + 15) = *(void *)((char *)v22 + 7);
  *(unsigned char *)(a1 + 23) = v17;
  if (((char)v20 & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_30:
    operator delete(__dst.__r_.__value_.__l.__data_);
    return;
  }
  operator delete(__p[0]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_30;
  }
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    int v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

uint64_t llvm::sys::ChangeStdinMode()
{
  return 0;
}

void toNullTerminatedCStringArray(char **a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (!a3)
  {
    uint64_t v7 = 0;
    unint64_t v30 = 0;
    goto LABEL_37;
  }
  size_t v5 = a4;
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  uint64_t v8 = a2 + 16 * a3;
  do
  {
    while (1)
    {
      pid_t v9 = llvm::StringSaver::save(v5, *(const void **)v6, *(void *)(v6 + 8));
      uint64_t v10 = v9;
      unint64_t v11 = (unint64_t)a1[2];
      if ((unint64_t)v7 >= v11) {
        break;
      }
      *(void *)uint64_t v7 = v9;
      v7 += 8;
      a1[1] = v7;
      v6 += 16;
      if (v6 == v8) {
        goto LABEL_34;
      }
    }
    unint64_t v12 = *a1;
    uint64_t v13 = v7 - *a1;
    uint64_t v14 = v13 >> 3;
    unint64_t v15 = (v13 >> 3) + 1;
    if (v15 >> 61) {
      goto LABEL_60;
    }
    uint64_t v16 = v11 - (void)v12;
    if (v16 >> 2 > v15) {
      unint64_t v15 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (!v17)
    {
      uint64_t v18 = 0;
      int v19 = (char *)(8 * v14);
      *(void *)(8 * v14) = v10;
      uint64_t v20 = 8 * v14 + 8;
      if (v7 == v12) {
        goto LABEL_20;
      }
LABEL_16:
      unint64_t v21 = v7 - 8 - v12;
      if (v21 >= 0x168)
      {
        if (&v18[v13 - 8 - (v21 & 0xFFFFFFFFFFFFFFF8)] > &v18[v13 - 8])
        {
          size_t v22 = v7;
        }
        else if (&v7[-(v21 & 0xFFFFFFFFFFFFFFF8) - 8] > v7 - 8)
        {
          size_t v22 = v7;
        }
        else if ((unint64_t)(v7 - &v18[v13]) >= 0x20)
        {
          uint64_t v24 = (v21 >> 3) + 1;
          uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
          size_t v22 = &v7[-v25];
          v19 -= v25;
          uint64_t v26 = &v18[8 * v14 - 16];
          uint64_t v27 = v7 - 16;
          uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v29 = *(_OWORD *)v27;
            *(v26 - 1) = *((_OWORD *)v27 - 1);
            *uint64_t v26 = v29;
            v26 -= 2;
            v27 -= 32;
            v28 -= 4;
          }
          while (v28);
          if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_19;
          }
        }
        else
        {
          size_t v22 = v7;
        }
      }
      else
      {
        size_t v22 = v7;
      }
      do
      {
        uint64_t v23 = *((void *)v22 - 1);
        v22 -= 8;
        *((void *)v19 - 1) = v23;
        v19 -= 8;
      }
      while (v22 != v12);
LABEL_19:
      uint64_t v7 = *a1;
      goto LABEL_20;
    }
    if (v17 >> 61) {
      goto LABEL_61;
    }
    uint64_t v18 = operator new(8 * v17);
    int v19 = &v18[8 * v14];
    *(void *)int v19 = v10;
    uint64_t v20 = (uint64_t)(v19 + 8);
    if (v7 != v12) {
      goto LABEL_16;
    }
LABEL_20:
    *a1 = v19;
    a1[1] = (char *)v20;
    a1[2] = &v18[8 * v17];
    if (v7) {
      operator delete(v7);
    }
    uint64_t v7 = (char *)v20;
    size_t v5 = a4;
    a1[1] = (char *)v20;
    v6 += 16;
  }
  while (v6 != v8);
LABEL_34:
  unint64_t v30 = (unint64_t)a1[2];
  if ((unint64_t)v7 < v30)
  {
    *(void *)uint64_t v7 = 0;
    uint64_t v31 = (uint64_t)(v7 + 8);
    goto LABEL_59;
  }
LABEL_37:
  uint64_t v32 = *a1;
  uint64_t v33 = v7 - *a1;
  uint64_t v34 = v33 >> 3;
  unint64_t v35 = (v33 >> 3) + 1;
  if (v35 >> 61) {
LABEL_60:
  }
    abort();
  uint64_t v36 = v30 - (void)v32;
  if (v36 >> 2 > v35) {
    unint64_t v35 = v36 >> 2;
  }
  if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v37 = v35;
  }
  if (v37)
  {
    if (v37 >> 61) {
LABEL_61:
    }
      std::__throw_bad_array_new_length[abi:nn180100]();
    __int16 v38 = operator new(8 * v37);
    char v39 = &v38[8 * v34];
    __int16 v40 = &v38[8 * v37];
    *(void *)char v39 = 0;
    uint64_t v31 = (uint64_t)(v39 + 8);
    size_t v41 = (char *)(v7 - v32);
    if (v7 == v32) {
      goto LABEL_57;
    }
LABEL_48:
    unint64_t v42 = (unint64_t)(v41 - 8);
    if (v42 < 0x58)
    {
      __int16 v43 = v7;
      goto LABEL_55;
    }
    if ((unint64_t)(v7 - v38 - v33) < 0x20)
    {
      __int16 v43 = v7;
      goto LABEL_55;
    }
    uint64_t v44 = (v42 >> 3) + 1;
    uint64_t v45 = 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
    __int16 v43 = &v7[-v45];
    v39 -= v45;
    unint64_t v46 = &v38[8 * v34 - 16];
    long long v47 = v7 - 16;
    uint64_t v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v49 = *(_OWORD *)v47;
      *(v46 - 1) = *((_OWORD *)v47 - 1);
      *unint64_t v46 = v49;
      v46 -= 2;
      v47 -= 32;
      v48 -= 4;
    }
    while (v48);
    if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
    {
      do
      {
LABEL_55:
        uint64_t v50 = *((void *)v43 - 1);
        v43 -= 8;
        *((void *)v39 - 1) = v50;
        v39 -= 8;
      }
      while (v43 != v32);
    }
    uint64_t v7 = *a1;
  }
  else
  {
    __int16 v38 = 0;
    char v39 = (char *)(8 * v34);
    __int16 v40 = 0;
    *(void *)(8 * v34) = 0;
    uint64_t v31 = 8 * v34 + 8;
    size_t v41 = (char *)(v7 - v32);
    if (v7 != v32) {
      goto LABEL_48;
    }
  }
LABEL_57:
  *a1 = v39;
  a1[1] = (char *)v31;
  a1[2] = v40;
  if (v7) {
    operator delete(v7);
  }
LABEL_59:
  a1[1] = (char *)v31;
}

uint64_t RedirectIO(uint64_t a1, int a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  memset(&v22, 0, sizeof(v22));
  std::string::size_type v5 = *(void *)(a1 + 8);
  if (v5)
  {
    if (v5 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v6 = *(const void **)a1;
    if (v5 >= 0x17)
    {
      uint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v5 | 7) != 0x17) {
        uint64_t v9 = v5 | 7;
      }
      uint64_t v10 = v9 + 1;
      p_dst = (std::string *)operator new(v9 + 1);
      __dst.__r_.__value_.__l.__size_ = v5;
      __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(a1 + 8);
      p_dst = &__dst;
    }
    memmove(p_dst, v6, v5);
    p_dst->__r_.__value_.__s.__data_[v5] = 0;
    std::string v22 = __dst;
  }
  else
  {
    MEMORY[0x1852FD9E0](&v22, "/dev/null");
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v22;
  }
  else {
    unint64_t v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if (a2) {
    int v12 = open((const char *)v11, 513, 438);
  }
  else {
    int v12 = open((const char *)v11, 0, 438);
  }
  if (v12 == -1)
  {
    std::operator+<char>();
    uint64_t v14 = std::string::append(&v19, "' for ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v20.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (a2) {
      uint64_t v16 = "output";
    }
    else {
      uint64_t v16 = "input";
    }
    unint64_t v17 = std::string::append(&v20, v16);
    std::string __dst = *v17;
    v17->__r_.__value_.__r.__words[0] = 0;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    MakeErrMsg(a3, (const void **)&__dst.__r_.__value_.__l.__data_, (llvm::sys *)0xFFFFFFFFLL);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_27:
        if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_28;
        }
        goto LABEL_35;
      }
    }
    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_27;
    }
    operator delete(v20.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_28:
      uint64_t v8 = 1;
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_29;
      }
      return v8;
    }
LABEL_35:
    operator delete(v19.__r_.__value_.__l.__data_);
    uint64_t v8 = 1;
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v8;
    }
    goto LABEL_29;
  }
  int v13 = v12;
  if (dup2(v12, a2) == -1)
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 11;
    strcpy((char *)&__dst, "Cannot dup2");
    MakeErrMsg(a3, (const void **)&__dst.__r_.__value_.__l.__data_, (llvm::sys *)0xFFFFFFFFLL);
    close(v13);
    uint64_t v8 = 1;
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v8;
    }
    goto LABEL_29;
  }
  close(v13);
  uint64_t v8 = 0;
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
LABEL_29:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
  return v8;
}

uint64_t SetMemoryLimits(unsigned int a1)
{
  rlim_t v1 = (unint64_t)a1 << 20;
  getrlimit(2, &v3);
  v3.rlim_cur = v1;
  setrlimit(2, &v3);
  getrlimit(5, &v3);
  v3.rlim_cur = v1;
  return setrlimit(5, &v3);
}

llvm::sys::RWMutexImpl *llvm::sys::RWMutexImpl::RWMutexImpl(llvm::sys::RWMutexImpl *this)
{
  *(void *)this = 0;
  size_t v2 = (pthread_rwlock_t *)malloc(0xC8uLL);
  if (!v2) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  rlimit v3 = v2;
  bzero(v2, 0xC8uLL);
  pthread_rwlock_init(v3, 0);
  *(void *)this = v3;
  return this;
}

void llvm::sys::RWMutexImpl::~RWMutexImpl(pthread_rwlock_t **this)
{
  rlim_t v1 = *this;
  pthread_rwlock_destroy(*this);
  free(v1);
}

BOOL llvm::sys::RWMutexImpl::lock_shared(pthread_rwlock_t **this)
{
  return pthread_rwlock_rdlock(*this) == 0;
}

BOOL llvm::sys::RWMutexImpl::unlock_shared(pthread_rwlock_t **this)
{
  return pthread_rwlock_unlock(*this) == 0;
}

BOOL llvm::sys::RWMutexImpl::lock(pthread_rwlock_t **this)
{
  return pthread_rwlock_wrlock(*this) == 0;
}

void llvm::initSignalsOptions(llvm *this)
{
  if (atomic_load_explicit(&qword_1EB216348, memory_order_acquire))
  {
    if (atomic_load_explicit(qword_1EB216360, memory_order_acquire)) {
      return;
    }
LABEL_5:
    return;
  }
  if (!atomic_load_explicit(qword_1EB216360, memory_order_acquire)) {
    goto LABEL_5;
  }
}

uint64_t llvm::sys::RunSignalHandlers(llvm::sys *this)
{
  int v1 = 2;
  int v2 = 2;
  atomic_compare_exchange_strong(dword_1EB2163D0, (unsigned int *)&v2, 3u);
  if (v2 == 2)
  {
    uint64_t result = qword_1EB2163C0(*(void *)algn_1EB2163C8);
    qword_1EB2163C0 = 0;
    *(void *)algn_1EB2163C8 = 0;
    atomic_store(0, (unsigned int *)dword_1EB2163D0);
  }
  atomic_compare_exchange_strong(dword_1EB2163E8, (unsigned int *)&v1, 3u);
  if (v1 == 2)
  {
    uint64_t result = qword_1EB2163D8(unk_1EB2163E0);
    qword_1EB2163D8 = 0;
    unk_1EB2163E0 = 0;
    atomic_store(0, (unsigned int *)dword_1EB2163E8);
  }
  int v4 = 2;
  int v5 = 2;
  atomic_compare_exchange_strong(dword_1EB216400, (unsigned int *)&v5, 3u);
  if (v5 == 2)
  {
    uint64_t result = qword_1EB2163F0(*(void *)algn_1EB2163F8);
    qword_1EB2163F0 = 0;
    *(void *)algn_1EB2163F8 = 0;
    atomic_store(0, (unsigned int *)dword_1EB216400);
  }
  atomic_compare_exchange_strong(dword_1EB216418, (unsigned int *)&v4, 3u);
  if (v4 == 2)
  {
    uint64_t result = qword_1EB216408(unk_1EB216410);
    qword_1EB216408 = 0;
    unk_1EB216410 = 0;
    atomic_store(0, (unsigned int *)dword_1EB216418);
  }
  int v6 = 2;
  int v7 = 2;
  atomic_compare_exchange_strong(dword_1EB216430, (unsigned int *)&v7, 3u);
  if (v7 == 2)
  {
    uint64_t result = qword_1EB216420(*(void *)algn_1EB216428);
    qword_1EB216420 = 0;
    *(void *)algn_1EB216428 = 0;
    atomic_store(0, (unsigned int *)dword_1EB216430);
  }
  atomic_compare_exchange_strong(dword_1EB216448, (unsigned int *)&v6, 3u);
  if (v6 == 2)
  {
    uint64_t result = qword_1EB216438(unk_1EB216440);
    qword_1EB216438 = 0;
    unk_1EB216440 = 0;
    atomic_store(0, (unsigned int *)dword_1EB216448);
  }
  int v8 = 2;
  int v9 = 2;
  atomic_compare_exchange_strong(dword_1EB216460, (unsigned int *)&v9, 3u);
  if (v9 != 2)
  {
    atomic_compare_exchange_strong(dword_1EB216478, (unsigned int *)&v8, 3u);
    if (v8 != 2) {
      return result;
    }
LABEL_17:
    uint64_t result = qword_1EB216468(unk_1EB216470);
    qword_1EB216468 = 0;
    unk_1EB216470 = 0;
    atomic_store(0, (unsigned int *)dword_1EB216478);
    return result;
  }
  uint64_t result = qword_1EB216450(*(void *)algn_1EB216458);
  qword_1EB216450 = 0;
  *(void *)algn_1EB216458 = 0;
  atomic_store(0, (unsigned int *)dword_1EB216460);
  atomic_compare_exchange_strong(dword_1EB216478, (unsigned int *)&v8, 3u);
  if (v8 == 2) {
    goto LABEL_17;
  }
  return result;
}

uint64_t printSymbolizedStackTrace(uint64_t a1, uint64_t a2, intptr_t *a3, int a4, llvm::raw_ostream *a5)
{
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v96 = a1;
  *((void *)&v96 + 1) = a2;
  uint64_t v95 = a3;
  int v94 = a4;
  if (DisableSymbolicationFlag
    || getenv("LLVM_DISABLE_SYMBOLIZATION")
    || llvm::StringRef::find((uint64_t *)&v96, "llvm-symbolizer", 0xFuLL, 0) != -1)
  {
    return 0;
  }
  int v8 = std::system_category();
  v131 |= 1u;
  *(void *)&long long v129 = 0;
  *((void *)&v129 + 1) = v8;
  int v9 = getenv("LLVM_SYMBOLIZER_PATH");
  if (v9)
  {
    uint64_t v10 = v9;
    size_t v11 = strlen(v9);
    llvm::sys::findProgramByName(v10, v11, 0, 0, (uint64_t)&__p);
    char v12 = v131;
    if ((v131 & 1) == 0 && SHIBYTE(v130) < 0)
    {
      operator delete((void *)v129);
      char v12 = v131;
    }
    if (v99)
    {
      char v13 = v12 | 1;
      long long v129 = __p;
    }
    else
    {
      char v13 = v12 & 0xFE;
      long long v129 = __p;
      uint64_t v130 = v98;
    }
    char v131 = v13;
  }
  else if (*((void *)&v96 + 1))
  {
    *(void *)uint64_t v115 = llvm::sys::path::parent_path((unsigned __int8 *)v96, *((unint64_t *)&v96 + 1), 0);
    *(void *)&v115[8] = v14;
    if (v14)
    {
      llvm::sys::findProgramByName("llvm-symbolizer", 0xFuLL, (uint64_t)v115, 1, (uint64_t)&__p);
      llvm::ErrorOr<std::string>::operator=((uint64_t)&v129, &__p);
      if ((v99 & 1) == 0 && SHIBYTE(v98) < 0) {
        operator delete((void *)__p);
      }
    }
  }
  char v15 = v131;
  if (v131)
  {
    llvm::sys::findProgramByName("llvm-symbolizer", 0xFuLL, 0, 0, (uint64_t)&__p);
    char v16 = v131;
    if ((v131 & 1) == 0 && SHIBYTE(v130) < 0)
    {
      operator delete((void *)v129);
      char v16 = v131;
    }
    if (v99)
    {
      char v15 = v16 | 1;
      long long v129 = __p;
    }
    else
    {
      char v15 = v16 & 0xFE;
      long long v129 = __p;
      uint64_t v130 = v98;
    }
    char v131 = v15;
  }
  if (v15)
  {
    uint64_t v6 = 0;
    goto LABEL_170;
  }
  LOWORD(v100) = 261;
  long long __p = v96;
  if (llvm::sys::fs::access((unsigned __int8 *)&__p, 0)) {
    llvm::sys::fs::getMainExecutable(__dst);
  }
  else {
    std::string::basic_string<llvm::StringRef,0>(__dst, (uint64_t)&v96);
  }
  v122[4] = 0;
  v122[5] = 0;
  long long v123 = (llvm **)v125;
  uint64_t v124 = 0x400000000;
  int32x4_t v126 = (llvm **)v128;
  uint64_t v127 = 0;
  v128[0] = 0;
  v128[1] = 1;
  uint64_t v17 = v94;
  if (v94)
  {
    if (v94 < 0) {
      abort();
    }
    uint64_t v18 = operator new(8 * v94);
    bzero(v18, 8 * v17);
    std::string v19 = operator new(8 * v17);
    bzero(v19, 8 * v17);
  }
  else
  {
    uint64_t v18 = 0;
    std::string v19 = 0;
  }
  std::string v20 = v95;
  uint32_t v21 = _dyld_image_count();
  if (v21)
  {
    uint32_t v22 = v21;
    uint64_t v23 = v17;
    if (v17)
    {
      for (uint32_t i = 0; i != v22; ++i)
      {
        image_name = _dyld_get_image_name(i);
        intptr_t image_vmaddr_slide = _dyld_get_image_vmaddr_slide(i);
        image_header = _dyld_get_image_header(i);
        if (image_header)
        {
          uint32_t ncmds = image_header->ncmds;
          if (ncmds)
          {
            int v29 = 0;
            p_cputype = &image_header[1].cputype;
            do
            {
              uint64_t v31 = (const char **)v18;
              uint64_t v32 = v23;
              uint64_t v33 = v20;
              uint64_t v34 = v19;
              if ((*p_cputype & 0x7FFFFFFF) == 0x19)
              {
                do
                {
                  if (!*v31)
                  {
                    intptr_t v35 = *v33;
                    intptr_t v36 = *((void *)p_cputype + 3) + image_vmaddr_slide;
                    if (v36 <= *v33 && *((void *)p_cputype + 4) + v36 > v35)
                    {
                      *uint64_t v31 = image_name;
                      *uint64_t v34 = v35 - image_vmaddr_slide;
                    }
                  }
                  ++v34;
                  ++v33;
                  ++v31;
                  --v32;
                }
                while (v32);
              }
              p_cputype = (int32_t *)((char *)p_cputype + p_cputype[1]);
              ++v29;
            }
            while (v29 != ncmds);
          }
        }
      }
    }
    else
    {
      for (uint32_t j = 0; j != v22; ++j)
      {
        _dyld_get_image_name(j);
        _dyld_get_image_vmaddr_slide(j);
        _dyld_get_image_header(j);
      }
    }
  }
  unsigned int v91 = 0;
  *(void *)long long v121 = v122;
  *(_OWORD *)&v121[8] = xmmword_1810FE500;
  int8x16_t v118 = v120;
  long long v119 = xmmword_1810FE500;
  *(void *)&long long __p = "symbolizer-input";
  LOWORD(v100) = 259;
  llvm::sys::fs::createTemporaryFile(&__p, (long long *)"", 0, (int *)&v91, v121, 0);
  *(void *)&long long __p = "symbolizer-output";
  LOWORD(v100) = 259;
  llvm::sys::fs::createTemporaryFile(&__p, (long long *)"", 0, &v118, 0);
  uint64_t v38 = *(void *)&v121[8];
  if ((unint64_t)(*(void *)&v121[8] + 1) > *(void *)&v121[16])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v121, v122, *(void *)&v121[8] + 1, 1);
    uint64_t v38 = *(void *)&v121[8];
  }
  *(unsigned char *)(*(void *)v121 + v38) = 0;
  LOWORD(v100) = 257;
  if (**(unsigned char **)v121)
  {
    *(void *)&long long __p = *(void *)v121;
    char v39 = 3;
  }
  else
  {
    char v39 = 1;
  }
  LOBYTE(v100) = v39;
  *(void *)uint64_t v115 = v116;
  *(_OWORD *)&v115[8] = xmmword_1811019F0;
  char v117 = 1;
  llvm::Twine::toVector((uint64_t)&__p, (uint64_t)v115);
  uint64_t v40 = v119;
  if ((unint64_t)(v119 + 1) > *((void *)&v119 + 1))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v118, v120, v119 + 1, 1);
    uint64_t v40 = v119;
  }
  *((unsigned char *)v118 + v40) = 0;
  LOWORD(v100) = 257;
  if (*(unsigned char *)v118)
  {
    *(void *)&long long __p = v118;
    char v41 = 3;
  }
  else
  {
    char v41 = 1;
  }
  LOBYTE(v100) = v41;
  *(void *)unint64_t v112 = v113;
  *(_OWORD *)&v112[8] = xmmword_1811019F0;
  char v114 = 1;
  llvm::Twine::toVector((uint64_t)&__p, (uint64_t)v112);
  llvm::raw_fd_ostream::raw_fd_ostream(&__p, v91, 1, 0, 0);
  if (v94 >= 1)
  {
    for (uint64_t k = 0; k < v94; ++k)
    {
      unint64_t v46 = (const void *)*((void *)v18 + k);
      if (!v46) {
        continue;
      }
      size_t v47 = strlen(*((const char **)v18 + k));
      size_t v48 = v47;
      long long v49 = v100;
      if (v47 <= v99 - v100)
      {
        if (v47)
        {
          memcpy(v100, v46, v47);
          long long v49 = &v100[v48];
          v100 += v48;
        }
        p_p = (char **)&__p;
        size_t v51 = &v100;
        if (v99 != v49)
        {
LABEL_75:
          *long long v49 = 32;
          ++*v51;
          uint64_t v44 = llvm::raw_ostream::operator<<((llvm::raw_ostream *)p_p, *((void *)v19 + k));
          uint64_t v45 = (unsigned char *)*((void *)v44 + 4);
          if (*((unsigned char **)v44 + 3) == v45)
          {
LABEL_76:
            llvm::raw_ostream::write(v44, "\n", 1uLL);
            continue;
          }
          goto LABEL_66;
        }
      }
      else
      {
        p_p = (char **)llvm::raw_ostream::write((llvm::raw_ostream *)&__p, (const char *)v46, v47);
        size_t v51 = p_p + 4;
        long long v49 = p_p[4];
        if (p_p[3] != v49) {
          goto LABEL_75;
        }
      }
      __int16 v43 = llvm::raw_ostream::write((llvm::raw_ostream *)p_p, " ", 1uLL);
      uint64_t v44 = llvm::raw_ostream::operator<<(v43, *((void *)v19 + k));
      uint64_t v45 = (unsigned char *)*((void *)v44 + 4);
      if (*((unsigned char **)v44 + 3) == v45) {
        goto LABEL_76;
      }
LABEL_66:
      unsigned char *v45 = 10;
      ++*((void *)v44 + 4);
    }
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&__p);
  long long v104 = *(_OWORD *)v121;
  char v105 = 1;
  uint64_t v106 = v118;
  uint64_t v107 = v119;
  char v108 = 1;
  uint64_t v109 = "";
  uint64_t v110 = 0;
  char v111 = 1;
  v103[0] = xmmword_1E4FC0B98;
  v103[1] = *(_OWORD *)&off_1E4FC0BA8;
  v103[2] = xmmword_1E4FC0BB8;
  v103[3] = *(_OWORD *)&off_1E4FC0BC8;
  if (v130 >= 0) {
    int v52 = &v129;
  }
  else {
    int v52 = (long long *)v129;
  }
  if (v130 >= 0) {
    size_t v53 = HIBYTE(v130);
  }
  else {
    size_t v53 = *((void *)&v129 + 1);
  }
  LOBYTE(v89) = 0;
  char v90 = 0;
  uint64_t v6 = 0;
  if (llvm::sys::ExecuteAndWait(v52, v53, (uint64_t)v103, 4, &v89, &v104, 3, 0, 0, 0, 0, 0)) {
    goto LABEL_143;
  }
  unint64_t v54 = (unsigned char *)llvm::SmallString<32u>::c_str(&v118);
  LOWORD(v100) = 257;
  if (*v54)
  {
    *(void *)&long long __p = v54;
    char v55 = 3;
  }
  else
  {
    char v55 = 1;
  }
  LOBYTE(v100) = v55;
  llvm::MemoryBuffer::getFile((unsigned __int8 *)&__p, 0, 1, 0, 0, (uint64_t)&v101);
  char v56 = v102;
  if (v102)
  {
    uint64_t v6 = 0;
    goto LABEL_140;
  }
  uint64_t v57 = *(void *)(v101 + 16) - *(void *)(v101 + 8);
  *(void *)&long long v88 = *(void *)(v101 + 8);
  *((void *)&v88 + 1) = v57;
  *(void *)&long long __p = &v98;
  *((void *)&__p + 1) = 0x2000000000;
  llvm::StringRef::split(&v88, (uint64_t)&__p, "\n", 1uLL, -1, 1);
  uint64_t v58 = (const char **)__p;
  uint64_t v87 = 0;
  if (v94 < 1) {
    goto LABEL_134;
  }
  for (int m = 0; m < v94; LODWORD(v87) = m)
  {
    v86[0] = a5;
    v86[1] = (char *)&v87 + 4;
    v86[2] = &v94;
    v86[3] = &v95;
    v86[4] = &v87;
    if (*((void *)v18 + m))
    {
      uint64_t v60 = (const char **)__p;
      if (v58 == (const char **)(__p + 16 * DWORD2(__p)))
      {
LABEL_136:
        uint64_t v58 = v60;
        uint64_t v6 = 0;
        goto LABEL_137;
      }
      v58 += 2;
      while (1)
      {
        size_t v62 = (size_t)*(v58 - 1);
        if (!v62) {
          goto LABEL_132;
        }
        uint64_t v63 = *(v58 - 2);
        printSymbolizedStackTrace(llvm::StringRef,void **,int,llvm::raw_ostream &)::$_0::operator()((uint64_t)v86);
        if (v62 == 1 || *v63 != 16191)
        {
          std::string::size_type v64 = (void *)*((void *)a5 + 4);
          if (v62 <= *((void *)a5 + 3) - (void)v64)
          {
            memcpy(v64, v63, v62);
            uint64_t v66 = (unsigned char *)(*((void *)a5 + 4) + v62);
            *((void *)a5 + 4) = v66;
            long long v65 = a5;
          }
          else
          {
            long long v65 = llvm::raw_ostream::write(a5, (const char *)v63, v62);
            uint64_t v66 = (unsigned char *)*((void *)v65 + 4);
          }
          if ((unint64_t)v66 >= *((void *)v65 + 3))
          {
            llvm::raw_ostream::write(v65, 32);
          }
          else
          {
            *((void *)v65 + 4) = v66 + 1;
            *uint64_t v66 = 32;
          }
        }
        uint64_t v60 = (const char **)__p;
        if (v58 == (const char **)(__p + 16 * DWORD2(__p))) {
          goto LABEL_136;
        }
        uint64_t v67 = *v58;
        unint64_t v68 = (unint64_t)v58[1];
        if (v68 >= 2 && *(_WORD *)v67 == 16191)
        {
          int v72 = (unsigned char *)*((void *)a5 + 4);
          if (*((unsigned char **)a5 + 3) == v72)
          {
            long long v73 = llvm::raw_ostream::write(a5, "(", 1uLL);
          }
          else
          {
            *int v72 = 40;
            ++*((void *)a5 + 4);
            long long v73 = a5;
          }
          uint64_t v74 = (const void *)*((void *)v18 + (int)v87);
          if (v74)
          {
            size_t v75 = strlen(*((const char **)v18 + (int)v87));
            size_t v76 = (void *)*((void *)v73 + 4);
            if (v75 <= *((void *)v73 + 3) - (void)v76)
            {
              if (v75)
              {
                memcpy(v76, v74, v75);
                *((void *)v73 + 4) += v75;
              }
            }
            else
            {
              long long v73 = llvm::raw_ostream::write(v73, (const char *)v74, v75);
            }
          }
          uint64_t v77 = (unsigned char *)*((void *)v73 + 4);
          if ((unint64_t)v77 >= *((void *)v73 + 3))
          {
            long long v73 = llvm::raw_ostream::write(v73, 43);
          }
          else
          {
            *((void *)v73 + 4) = v77 + 1;
            *uint64_t v77 = 43;
          }
          v82[0] = *((void *)v19 + (int)v87);
          v82[1] = 0;
          int v83 = 0;
          __int16 v84 = 1;
          char v85 = 1;
          pid_t v70 = llvm::raw_ostream::operator<<(v73, (uint64_t)v82);
          int v78 = (unsigned char *)*((void *)v70 + 4);
          if (*((unsigned char **)v70 + 3) != v78)
          {
            unsigned char *v78 = 41;
            ++*((void *)v70 + 4);
            goto LABEL_125;
          }
          uint64_t v67 = ")";
          size_t v71 = 1;
        }
        else
        {
          long long v69 = (void *)*((void *)a5 + 4);
          if (v68 <= *((void *)a5 + 3) - (void)v69)
          {
            if (v68)
            {
              memcpy(v69, v67, (size_t)v58[1]);
              *((void *)a5 + 4) += v68;
            }
            goto LABEL_125;
          }
          pid_t v70 = a5;
          size_t v71 = (size_t)v58[1];
        }
        llvm::raw_ostream::write(v70, v67, v71);
LABEL_125:
        int v79 = (unsigned char *)*((void *)a5 + 4);
        if (*((unsigned char **)a5 + 3) == v79)
        {
          llvm::raw_ostream::write(a5, "\n", 1uLL);
        }
        else
        {
          *int v79 = 10;
          ++*((void *)a5 + 4);
        }
        uint64_t v60 = (const char **)__p;
        uint64_t v61 = v58 + 2;
        v58 += 4;
        if (v61 == (void *)(__p + 16 * DWORD2(__p))) {
          goto LABEL_136;
        }
      }
    }
    printSymbolizedStackTrace(llvm::StringRef,void **,int,llvm::raw_ostream &)::$_0::operator()((uint64_t)v86);
    int v80 = (unsigned char *)*((void *)a5 + 4);
    if ((unint64_t)v80 >= *((void *)a5 + 3))
    {
      llvm::raw_ostream::write(a5, 10);
    }
    else
    {
      *((void *)a5 + 4) = v80 + 1;
      *int v80 = 10;
    }
LABEL_132:
    int m = v87 + 1;
  }
  uint64_t v58 = (const char **)__p;
LABEL_134:
  uint64_t v6 = 1;
LABEL_137:
  if (v58 != (const char **)&v98) {
    free(v58);
  }
  char v56 = v102;
LABEL_140:
  if ((v56 & 1) == 0)
  {
    uint64_t v81 = v101;
    uint64_t v101 = 0;
    if (v81) {
      (*(void (**)(uint64_t))(*(void *)v81 + 8))(v81);
    }
  }
LABEL_143:
  if (v114)
  {
    LOWORD(v100) = 261;
    long long __p = *(_OWORD *)v112;
    llvm::sys::fs::remove((llvm::sys::fs *)&__p, (const llvm::Twine *)1);
  }
  if (*(unsigned char **)v112 != v113) {
    free(*(void **)v112);
  }
  if (v117)
  {
    LOWORD(v100) = 261;
    long long __p = *(_OWORD *)v115;
    llvm::sys::fs::remove((llvm::sys::fs *)&__p, (const llvm::Twine *)1);
  }
  if (*(unsigned char **)v115 != v116) {
    free(*(void **)v115);
  }
  if (v118 != v120) {
    free(v118);
  }
  if (*(void **)v121 != v122) {
    free(*(void **)v121);
  }
  if (v19) {
    operator delete(v19);
  }
  if (v18) {
    operator delete(v18);
  }
  if (v124) {
    llvm::deallocate_buffer(*v123, (void *)0x1000);
  }
  if (v127) {
    llvm::deallocate_buffer(*v126, v126[1]);
  }
  if (v126 != v128) {
    free(v126);
  }
  if (v123 != (llvm **)v125) {
    free(v123);
  }
  if (v93 < 0) {
    operator delete(__dst[0]);
  }
  char v15 = v131;
LABEL_170:
  if ((v15 & 1) == 0 && SHIBYTE(v130) < 0) {
    operator delete((void *)v129);
  }
  return v6;
}

uint64_t llvm::ErrorOr<std::string>::operator=(uint64_t a1, long long *a2)
{
  if ((long long *)a1 == a2) {
    return a1;
  }
  char v4 = *(unsigned char *)(a1 + 24);
  if ((v4 & 1) == 0 && *(char *)(a1 + 23) < 0)
  {
    operator delete(*(void **)a1);
    char v4 = *(unsigned char *)(a1 + 24);
    if ((*((unsigned char *)a2 + 24) & 1) == 0) {
      goto LABEL_5;
    }
  }
  else if ((*((unsigned char *)a2 + 24) & 1) == 0)
  {
LABEL_5:
    *(unsigned char *)(a1 + 24) = v4 & 0xFE;
    long long v5 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v5;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    return a1;
  }
  *(unsigned char *)(a1 + 24) = v4 | 1;
  if (*((unsigned char *)a2 + 24))
  {
    int v7 = (const std::error_category *)*((void *)a2 + 1);
    *(void *)a1 = *(void *)a2;
  }
  else
  {
    int v7 = std::system_category();
    *(void *)a1 = 0;
  }
  *(void *)(a1 + 8) = v7;
  return a1;
}

uint64_t llvm::SmallString<32u>::c_str(void *a1)
{
  uint64_t v2 = a1[1];
  if ((unint64_t)(v2 + 1) > a1[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v2 + 1, 1);
    *(unsigned char *)(*a1 + a1[1]) = 0;
    return *a1;
  }
  else
  {
    *(unsigned char *)(*a1 + v2) = 0;
    return *a1;
  }
}

void printSymbolizedStackTrace(llvm::StringRef,void **,int,llvm::raw_ostream &)::$_0::operator()(uint64_t a1)
{
  rlimit v3 = *(llvm::raw_ostream **)a1;
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  int v4 = (*v2)++;
  v16[0] = "#{0}";
  v16[1] = 4;
  v16[2] = &v19;
  void v16[3] = 1;
  uint64_t v17 = &unk_1EC9A46A8;
  int v18 = v4;
  std::string v19 = &v17;
  long long __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  LODWORD(v24) = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  int v30 = 1;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  p_p = &__p;
  uint64_t v23 = &unk_1EC9A38B8;
  uint64_t v31 = &__p;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v23, 0, 0, 0);
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v23, (llvm::formatv_object_base *)v16);
  if (v27 != v25) {
    llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v23);
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v23);
  if (v22 >= 0)
  {
    uint64_t v6 = HIBYTE(v22);
  }
  else
  {
    p_p = __p;
    uint64_t v6 = v21;
  }
  long double v7 = log10((double)**(int **)(a1 + 16));
  uint64_t v23 = p_p;
  uint64_t v24 = v6;
  LODWORD(v25) = (v7 + 2.0);
  HIDWORD(v25) = 2;
  int v8 = llvm::raw_ostream::operator<<(v3, (uint64_t)&v23);
  int v9 = (unsigned char *)*((void *)v8 + 4);
  if ((unint64_t)v9 >= *((void *)v8 + 3))
  {
    int v8 = llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((void *)v8 + 4) = v9 + 1;
    *int v9 = 32;
  }
  v12[0] = *(void *)(**(void **)(a1 + 24) + 8 * **(int **)(a1 + 32));
  v12[1] = 0;
  int v13 = 18;
  __int16 v14 = 1;
  char v15 = 1;
  uint64_t v10 = llvm::raw_ostream::operator<<(v8, (uint64_t)v12);
  size_t v11 = (unsigned char *)*((void *)v10 + 4);
  if ((unint64_t)v11 >= *((void *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
    if (SHIBYTE(v22) < 0) {
LABEL_14:
    }
      operator delete(__p);
  }
  else
  {
    *((void *)v10 + 4) = v11 + 1;
    *size_t v11 = 32;
    if (SHIBYTE(v22) < 0) {
      goto LABEL_14;
    }
  }
}

uint64_t printMarkupStackTrace(const void *a1, size_t a2)
{
  int v4 = getenv("LLVM_ENABLE_SYMBOLIZER_MARKUP");
  if (!v4 || !*v4) {
    return 0;
  }
  __int16 v10 = 261;
  v9[0] = a1;
  v9[1] = a2;
  if (!llvm::sys::fs::access((unsigned __int8 *)v9, 0))
  {
    if (a2 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (a2 >= 0x17)
    {
      uint64_t v7 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a2 | 7) != 0x17) {
        uint64_t v7 = a2 | 7;
      }
      uint64_t v8 = v7 + 1;
      uint64_t v6 = (void **)operator new(v7 + 1);
      __dst[1] = (void *)a2;
      unint64_t v12 = v8 | 0x8000000000000000;
      __dst[0] = v6;
    }
    else
    {
      HIBYTE(v12) = a2;
      uint64_t v6 = __dst;
      if (!a2)
      {
LABEL_14:
        *((unsigned char *)v6 + a2) = 0;
        if ((SHIBYTE(v12) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_15;
      }
    }
    memmove(v6, a1, a2);
    goto LABEL_14;
  }
  llvm::sys::fs::getMainExecutable(__dst);
  if ((SHIBYTE(v12) & 0x80000000) == 0) {
    return 0;
  }
LABEL_15:
  operator delete(__dst[0]);
  return 0;
}

__int32 *llvm::sys::CleanupOnSignal(llvm::sys *this)
{
  __int32 v1 = (int)this;
  uint64_t v2 = wmemchr((__int32 *)&InfoSigs, (__int32)this, 2uLL);
  rlimit v3 = IntSigs;
  if (v2) {
    rlimit v3 = v2;
  }
  if ((char *)v3 - (char *)&InfoSigs == 8)
  {
    unint64_t v4 = atomic_exchange(&qword_1EB216340, 0);
    if (v4)
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = (const char *)atomic_exchange((atomic_ullong *volatile)v5, 0);
        if (v6 && !stat(v6, &v12) && (v12.st_mode & 0xF000) == 0x8000)
        {
          unlink(v6);
          atomic_exchange((atomic_ullong *volatile)v5, (unint64_t)v6);
        }
        unint64_t v5 = atomic_load((unint64_t *)(v5 + 8));
      }
      while (v5);
    }
    atomic_exchange(&qword_1EB216340, v4);
    uint64_t result = wmemchr(IntSigs, v1, 4uLL);
    size_t v11 = "N4llvm6detail23provider_format_adapterIiEE";
    if (result) {
      size_t v11 = (const char *)result;
    }
    if (v1 != 13 && v11 - (const char *)IntSigs == 16) {
      return (__int32 *)llvm::sys::RunSignalHandlers((llvm::sys *)result);
    }
  }
  else
  {
    uint64_t result = __error();
    uint64_t v8 = result;
    __int32 v9 = *result;
    __int16 v10 = (uint64_t (*)(void))atomic_load(&qword_1EB216330);
    if (v10) {
      uint64_t result = (__int32 *)v10();
    }
    __int32 *v8 = v9;
  }
  return result;
}

int *InfoSignalHandler()
{
  uint64_t result = __error();
  __int32 v1 = result;
  int v2 = *result;
  rlimit v3 = (uint64_t (*)(void))atomic_load(&qword_1EB216330);
  if (v3) {
    uint64_t result = (int *)v3();
  }
  *__int32 v1 = v2;
  return result;
}

void llvm::sys::RunInterruptHandlers(llvm::sys *this)
{
  unint64_t v1 = atomic_exchange(&qword_1EB216340, 0);
  if (v1)
  {
    unint64_t v2 = v1;
    do
    {
      rlimit v3 = (const char *)atomic_exchange((atomic_ullong *volatile)v2, 0);
      if (v3 && !stat(v3, &v4) && (v4.st_mode & 0xF000) == 0x8000)
      {
        unlink(v3);
        atomic_exchange((atomic_ullong *volatile)v2, (unint64_t)v3);
      }
      unint64_t v2 = atomic_load((unint64_t *)(v2 + 8));
    }
    while (v2);
  }
  atomic_exchange(&qword_1EB216340, v1);
}

void RegisterHandlers(void)
{
  if (!atomic_load_explicit(qword_1EB216390, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EB216390, (void *(*)(void))llvm::object_creator<llvm::sys::SmartMutex<true>>::call, (void (*)(void *))llvm::object_deleter<llvm::sys::SmartMutex<true>>::call);
  }
  v0 = (std::recursive_mutex *)qword_1EB216390[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1EB216390[0]);
  if (!atomic_load((unsigned int *)_MergedGlobals_56))
  {
    unsigned int v2 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    rlimit v3 = (sigaction *)((char *)&unk_1EB216480 + 24 * v2);
    sigaction(1, &v39, v3);
    LODWORD(v3[1].__sigaction_u.__sa_handler) = 1;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v4 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    unint64_t v5 = (sigaction *)((char *)&unk_1EB216480 + 24 * v4);
    sigaction(2, &v39, v5);
    LODWORD(v5[1].__sigaction_u.__sa_handler) = 2;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v6 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v7 = (sigaction *)((char *)&unk_1EB216480 + 24 * v6);
    sigaction(15, &v39, v7);
    LODWORD(v7[1].__sigaction_u.__sa_handler) = 15;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v8 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    __int32 v9 = (sigaction *)((char *)&unk_1EB216480 + 24 * v8);
    sigaction(31, &v39, v9);
    LODWORD(v9[1].__sigaction_u.__sa_handler) = 31;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v10 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    size_t v11 = (sigaction *)((char *)&unk_1EB216480 + 24 * v10);
    sigaction(4, &v39, v11);
    LODWORD(v11[1].__sigaction_u.__sa_handler) = 4;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v12 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    int v13 = (sigaction *)((char *)&unk_1EB216480 + 24 * v12);
    sigaction(5, &v39, v13);
    LODWORD(v13[1].__sigaction_u.__sa_handler) = 5;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v14 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    char v15 = (sigaction *)((char *)&unk_1EB216480 + 24 * v14);
    sigaction(6, &v39, v15);
    LODWORD(v15[1].__sigaction_u.__sa_handler) = 6;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v16 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v17 = (sigaction *)((char *)&unk_1EB216480 + 24 * v16);
    sigaction(8, &v39, v17);
    LODWORD(v17[1].__sigaction_u.__sa_handler) = 8;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v18 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    std::string v19 = (sigaction *)((char *)&unk_1EB216480 + 24 * v18);
    sigaction(10, &v39, v19);
    LODWORD(v19[1].__sigaction_u.__sa_handler) = 10;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v20 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v21 = (sigaction *)((char *)&unk_1EB216480 + 24 * v20);
    sigaction(11, &v39, v21);
    LODWORD(v21[1].__sigaction_u.__sa_handler) = 11;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v22 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v23 = (sigaction *)((char *)&unk_1EB216480 + 24 * v22);
    sigaction(3, &v39, v23);
    LODWORD(v23[1].__sigaction_u.__sa_handler) = 3;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v24 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v25 = (sigaction *)((char *)&unk_1EB216480 + 24 * v24);
    sigaction(12, &v39, v25);
    LODWORD(v25[1].__sigaction_u.__sa_handler) = 12;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v26 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v27 = (sigaction *)((char *)&unk_1EB216480 + 24 * v26);
    sigaction(24, &v39, v27);
    LODWORD(v27[1].__sigaction_u.__sa_handler) = 24;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v28 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v29 = (sigaction *)((char *)&unk_1EB216480 + 24 * v28);
    sigaction(25, &v39, v29);
    LODWORD(v29[1].__sigaction_u.__sa_handler) = 25;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v30 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x1500000000;
    uint64_t v31 = (sigaction *)((char *)&unk_1EB216480 + 24 * v30);
    sigaction(7, &v39, v31);
    LODWORD(v31[1].__sigaction_u.__sa_handler) = 7;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    if (atomic_load((unint64_t *)&qword_1EB216338))
    {
      unsigned int v33 = atomic_load((unsigned int *)_MergedGlobals_56);
      v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SignalHandler;
      *(void *)&v39.sa_masuint64_t k = 0x1500000000;
      uint64_t v34 = &_MergedGlobals_56[6 * v33];
      sigaction(13, &v39, (sigaction *)v34 + 23);
      v34[96] = 13;
      atomic_fetch_add(_MergedGlobals_56, 1u);
    }
    unsigned int v35 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))InfoSignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x100000000;
    intptr_t v36 = (sigaction *)((char *)&unk_1EB216480 + 24 * v35);
    sigaction(30, &v39, v36);
    LODWORD(v36[1].__sigaction_u.__sa_handler) = 30;
    atomic_fetch_add(_MergedGlobals_56, 1u);
    unsigned int v37 = atomic_load((unsigned int *)_MergedGlobals_56);
    v39.__sigaction_u.__sa_handler = (void (__cdecl *)(int))InfoSignalHandler;
    *(void *)&v39.sa_masuint64_t k = 0x100000000;
    uint64_t v38 = (sigaction *)((char *)&unk_1EB216480 + 24 * v37);
    sigaction(29, &v39, v38);
    LODWORD(v38[1].__sigaction_u.__sa_handler) = 29;
    atomic_fetch_add(_MergedGlobals_56, 1u);
  }
  std::recursive_mutex::unlock(v0);
}

uint64_t llvm::sys::RemoveFileOnSignal(void *__src, size_t __len)
{
  if (atomic_load_explicit(qword_1EB216378, memory_order_acquire))
  {
    if (__src) {
      goto LABEL_3;
    }
LABEL_8:
    std::string __dst = 0;
    size_t v14 = 0;
    p_dst = (const char *)&__dst;
    int64_t v15 = 0;
    goto LABEL_16;
  }
  if (!__src) {
    goto LABEL_8;
  }
LABEL_3:
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v6 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v6 = __len | 7;
    }
    size_t v7 = v6 + 1;
    unsigned int v4 = (void **)operator new(v6 + 1);
    size_t v14 = __len;
    int64_t v15 = v7 | 0x8000000000000000;
    std::string __dst = v4;
    goto LABEL_12;
  }
  HIBYTE(v15) = __len;
  unsigned int v4 = (void **)&__dst;
  if (__len) {
LABEL_12:
  }
    memmove(v4, __src, __len);
  *((unsigned char *)v4 + __len) = 0;
  if (v15 >= 0) {
    p_dst = (const char *)&__dst;
  }
  else {
    p_dst = (const char *)__dst;
  }
LABEL_16:
  unsigned int v8 = operator new(0x10uLL);
  __int32 v9 = strdup(p_dst);
  uint64_t v10 = 0;
  void *v8 = v9;
  v8[1] = 0;
  atomic_compare_exchange_strong(&qword_1EB216340, (unint64_t *)&v10, (unint64_t)v8);
  while (v10)
  {
    size_t v11 = (atomic_ullong *)(v10 + 8);
    uint64_t v10 = 0;
    atomic_compare_exchange_strong(v11, (unint64_t *)&v10, (unint64_t)v8);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst);
  }
  RegisterHandlers();
  return 0;
}

void llvm::sys::DontRemoveFileOnSignal(const void *a1, size_t a2)
{
  if (a1)
  {
    if (a2 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_32:
    }
      abort();
    if (a2 >= 0x17)
    {
      uint64_t v5 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a2 | 7) != 0x17) {
        uint64_t v5 = a2 | 7;
      }
      uint64_t v6 = v5 + 1;
      p_dst = (const void **)operator new(v5 + 1);
      size_t v14 = a2;
      unint64_t v15 = v6 | 0x8000000000000000;
      std::string __dst = p_dst;
    }
    else
    {
      HIBYTE(v15) = a2;
      p_dst = (const void **)&__dst;
      if (!a2)
      {
LABEL_12:
        *((unsigned char *)p_dst + a2) = 0;
        if (atomic_load_explicit(&qword_1EB2163A8, memory_order_acquire)) {
          goto LABEL_14;
        }
        goto LABEL_13;
      }
    }
    memmove(p_dst, a1, a2);
    goto LABEL_12;
  }
  std::string __dst = 0;
  size_t v14 = 0;
  unint64_t v15 = 0;
  if (atomic_load_explicit(&qword_1EB2163A8, memory_order_acquire)) {
    goto LABEL_14;
  }
LABEL_13:
  llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EB2163A8, (void *(*)(void))llvm::object_creator<llvm::sys::SmartMutex<true>>::call, (void (*)(void *))llvm::object_deleter<llvm::sys::SmartMutex<true>>::call);
LABEL_14:
  size_t v7 = (std::recursive_mutex *)qword_1EB2163A8;
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1EB2163A8);
  for (uint32_t i = (unint64_t *)atomic_load((unint64_t *)&qword_1EB216340);
        i;
        uint32_t i = (unint64_t *)atomic_load(i + 1))
  {
    __int32 v9 = (const char *)atomic_load(i);
    if (v9)
    {
      size_t v10 = strlen(v9);
      if (SHIBYTE(v15) < 0)
      {
        if (v10 == v14)
        {
          if (v10 == -1) {
            goto LABEL_32;
          }
          if (!memcmp(__dst, v9, v10))
          {
LABEL_27:
            size_t v11 = (void *)atomic_exchange((atomic_ullong *volatile)i, 0);
            if (v11) {
              free(v11);
            }
          }
        }
      }
      else if (v10 == HIBYTE(v15))
      {
        if (v10 == -1) {
          goto LABEL_32;
        }
        if (!memcmp(&__dst, v9, v10)) {
          goto LABEL_27;
        }
      }
    }
  }
  std::recursive_mutex::unlock(v7);
  if (SHIBYTE(v15) < 0)
  {
    unsigned int v12 = __dst;
    operator delete(v12);
  }
}

void llvm::sys::AddSignalHandler(llvm::sys *this, void (*a2)(void *), void *a3)
{
  int v3 = 0;
  unsigned int v4 = &qword_1EB2163C0;
  uint64_t v5 = dword_1EB2163D0;
  atomic_compare_exchange_strong(dword_1EB2163D0, (unsigned int *)&v3, 1u);
  if (v3)
  {
    int v6 = 0;
    unsigned int v4 = &qword_1EB2163D8;
    uint64_t v5 = dword_1EB2163E8;
    atomic_compare_exchange_strong(dword_1EB2163E8, (unsigned int *)&v6, 1u);
    if (v6)
    {
      int v7 = 0;
      unsigned int v4 = &qword_1EB2163F0;
      uint64_t v5 = dword_1EB216400;
      atomic_compare_exchange_strong(dword_1EB216400, (unsigned int *)&v7, 1u);
      if (v7)
      {
        int v8 = 0;
        unsigned int v4 = &qword_1EB216408;
        uint64_t v5 = dword_1EB216418;
        atomic_compare_exchange_strong(dword_1EB216418, (unsigned int *)&v8, 1u);
        if (v8)
        {
          int v9 = 0;
          unsigned int v4 = &qword_1EB216420;
          uint64_t v5 = dword_1EB216430;
          atomic_compare_exchange_strong(dword_1EB216430, (unsigned int *)&v9, 1u);
          if (v9)
          {
            int v10 = 0;
            unsigned int v4 = &qword_1EB216438;
            uint64_t v5 = dword_1EB216448;
            atomic_compare_exchange_strong(dword_1EB216448, (unsigned int *)&v10, 1u);
            if (v10)
            {
              int v11 = 0;
              unsigned int v4 = &qword_1EB216450;
              uint64_t v5 = dword_1EB216460;
              atomic_compare_exchange_strong(dword_1EB216460, (unsigned int *)&v11, 1u);
              if (v11)
              {
                int v12 = 0;
                unsigned int v4 = &qword_1EB216468;
                uint64_t v5 = dword_1EB216478;
                atomic_compare_exchange_strong(dword_1EB216478, (unsigned int *)&v12, 1u);
                if (v12) {
                  llvm::report_fatal_error((llvm *)"too many signal callbacks already registered", (const char *)1);
                }
              }
            }
          }
        }
      }
    }
  }
  *unsigned int v4 = (uint64_t (*)(void))this;
  v4[1] = (uint64_t (*)(void))a2;
  atomic_store(2u, (unsigned int *)v5);

  RegisterHandlers();
}

uint64_t llvm::sys::PrintStackTrace(llvm::sys *this, llvm::raw_ostream *a2)
{
  int v2 = (int)a2;
  uint64_t result = backtrace((void **)&qword_1EB216630, 256);
  if (result)
  {
    int v5 = result;
    if (!v2) {
      int v2 = result;
    }
    printMarkupStackTrace((const void *)qword_1EB216318, qword_1EB216320);
    uint64_t result = printSymbolizedStackTrace(qword_1EB216318, qword_1EB216320, &qword_1EB216630, v2, this);
    if ((result & 1) == 0)
    {
      int v6 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v6 > 0x90uLL)
      {
        *((void *)this + 4) += 145;
        if (v5 < 1) {
          return result;
        }
      }
      else
      {
        if (v5 < 1) {
          return result;
        }
      }
      int v7 = 0;
      uint64_t v8 = v5;
      int v9 = (const void **)&qword_1EB216630;
      uint64_t v10 = v5;
      do
      {
        while (1)
        {
          dladdr(*v9, &v31);
          dli_fname = v31.dli_fname;
          int v13 = strrchr((char *)v31.dli_fname, 47);
          if (v13) {
            break;
          }
          int v14 = strlen(dli_fname);
          if (v7 <= v14) {
            int v7 = v14;
          }
          ++v9;
          if (!--v10) {
            goto LABEL_19;
          }
        }
        int v11 = strlen(v13) - 1;
        if (v7 <= v11) {
          int v7 = v11;
        }
        ++v9;
        --v10;
      }
      while (v10);
      do
      {
        while (1)
        {
LABEL_19:
          dladdr(*((const void **)&_MergedGlobals_56 + v10 + 100), &v31);
          uint64_t v27 = &unk_1EC9A1930;
          unsigned int v28 = "%-2d";
          LODWORD(v29) = v10;
          llvm::raw_ostream::operator<<(this, (uint64_t)&v27);
          unint64_t v15 = v31.dli_fname;
          unsigned int v16 = strrchr((char *)v31.dli_fname, 47);
          uint64_t v27 = &unk_1EC9A1950;
          unsigned int v28 = " %-*s";
          LODWORD(v29) = v7;
          if (v16) {
            unsigned int v30 = v16 + 1;
          }
          else {
            unsigned int v30 = v15;
          }
          llvm::raw_ostream::operator<<(this, (uint64_t)&v27);
          uint64_t v17 = (const char *)*((void *)&_MergedGlobals_56 + v10 + 100);
          uint64_t v27 = &unk_1EC9A1990;
          unsigned int v28 = " %#0*lx";
          LODWORD(v29) = 18;
          unsigned int v30 = v17;
          uint64_t result = (uint64_t)llvm::raw_ostream::operator<<(this, (uint64_t)&v27);
          if (v31.dli_sname)
          {
            unsigned int v18 = (unsigned char *)*((void *)this + 4);
            if ((unint64_t)v18 >= *((void *)this + 3))
            {
              llvm::raw_ostream::write(this, 32);
            }
            else
            {
              *((void *)this + 4) = v18 + 1;
              *unsigned int v18 = 32;
            }
            strlen(v31.dli_sname);
            std::string v19 = llvm::itaniumDemangle();
            if (v19)
            {
              unsigned int v20 = v19;
              size_t v21 = strlen(v19);
              unsigned int v22 = (void *)*((void *)this + 4);
              if (v21 <= *((void *)this + 3) - (void)v22)
              {
                if (v21)
                {
                  memcpy(v22, v20, v21);
                  *((void *)this + 4) += v21;
                }
              }
              else
              {
                llvm::raw_ostream::write(this, v20, v21);
              }
              free(v20);
            }
            else if (v31.dli_sname)
            {
              size_t v23 = strlen(v31.dli_sname);
              unsigned int v24 = (void *)*((void *)this + 4);
              if (v23 <= *((void *)this + 3) - (void)v24)
              {
                if (v23)
                {
                  memcpy(v24, v31.dli_sname, v23);
                  *((void *)this + 4) += v23;
                }
              }
              else
              {
                llvm::raw_ostream::write(this, v31.dli_sname, v23);
              }
            }
            unint64_t v25 = *((void *)&_MergedGlobals_56 + v10 + 100) - (unint64_t)v31.dli_saddr;
            uint64_t v27 = &unk_1EC9A19B0;
            unsigned int v28 = " + %tu";
            unint64_t v29 = v25;
            uint64_t result = (uint64_t)llvm::raw_ostream::operator<<(this, (uint64_t)&v27);
          }
          unsigned int v26 = (unsigned char *)*((void *)this + 4);
          if ((unint64_t)v26 >= *((void *)this + 3)) {
            break;
          }
          *((void *)this + 4) = v26 + 1;
          *unsigned int v26 = 10;
          if (v8 == ++v10) {
            return result;
          }
        }
        uint64_t result = (uint64_t)llvm::raw_ostream::write(this, 10);
        ++v10;
      }
      while (v8 != v10);
    }
  }
  return result;
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<int>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<int,void>::format((unsigned int *)(a1 + 8), a2, a3, a4);
}

uint64_t SignalHandler(__int32 a1)
{
  uint64_t v2 = atomic_load((unsigned int *)_MergedGlobals_56);
  if (v2)
  {
    int v3 = (const sigaction *)&unk_1EB216480;
    do
    {
      sigaction((int)v3[1].__sigaction_u.__sa_handler, v3, 0);
      atomic_fetch_add(_MergedGlobals_56, 0xFFFFFFFF);
      int v3 = (const sigaction *)((char *)v3 + 24);
      --v2;
    }
    while (v2);
  }
  sigset_t v11 = -1;
  unsigned int v4 = (__int32 *)sigprocmask(2, &v11, 0);
  unint64_t v5 = atomic_exchange(&qword_1EB216340, 0);
  if (v5)
  {
    unint64_t v6 = v5;
    do
    {
      int v7 = (const char *)atomic_exchange((atomic_ullong *volatile)v6, 0);
      if (v7)
      {
        unsigned int v4 = (__int32 *)stat(v7, &v12);
        if (!v4 && (v12.st_mode & 0xF000) == 0x8000)
        {
          unsigned int v4 = (__int32 *)unlink(v7);
          atomic_exchange((atomic_ullong *volatile)v6, (unint64_t)v7);
        }
      }
      unint64_t v6 = atomic_load((unint64_t *)(v6 + 8));
    }
    while (v6);
  }
  atomic_exchange(&qword_1EB216340, v5);
  if (a1 == 13)
  {
    uint64_t v8 = (uint64_t (*)(__int32 *))atomic_exchange(&qword_1EB216338, 0);
    if (v8) {
      return v8(v4);
    }
  }
  unsigned int v4 = wmemchr(IntSigs, a1, 4uLL);
  int v9 = "N4llvm6detail23provider_format_adapterIiEE";
  if (v4) {
    int v9 = (const char *)v4;
  }
  if (v9 - (const char *)IntSigs == 16)
  {
    if (a1 != 13) {
      return llvm::sys::RunSignalHandlers((llvm::sys *)v4);
    }
    return raise(a1);
  }
  uint64_t v8 = (uint64_t (*)(__int32 *))atomic_exchange(&qword_1EB216328, 0);
  if (v8) {
    return v8(v4);
  }
  return raise(a1);
}

uint64_t anonymous namespace'::CreateDisableSymbolication::call(_anonymous_namespace_::CreateDisableSymbolication *this)
{
  unint64_t v1 = operator new(0xC0uLL);
  *(void *)&long long v5 = "Disable symbolizing crash backtraces.";
  *((void *)&v5 + 1) = 37;
  unsigned int v4 = &DisableSymbolicationFlag;
  int v3 = 1;
  return llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::opt<char [6],llvm::cl::desc,llvm::cl::LocationClass<BOOL>,llvm::cl::OptionHidden>((uint64_t)v1, (int8x16_t *)"disable-symbolication", &v5, &v4, &v3);
}

uint64_t llvm::object_deleter<llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>>::call(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t anonymous namespace'::CreateCrashDiagnosticsDir::call(_anonymous_namespace_::CreateCrashDiagnosticsDir *this)
{
  unint64_t v1 = operator new(0xD8uLL);
  *(void *)&long long v6 = "directory";
  *((void *)&v6 + 1) = 9;
  *(void *)&long long v5 = "Directory for crash diagnostic files.";
  *((void *)&v5 + 1) = 37;
  if (!atomic_load_explicit(CrashDiagnosticsDirectory, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)CrashDiagnosticsDirectory, (void *(*)(void))llvm::object_creator<std::string>::call, (void (*)(void *))llvm::object_deleter<std::string>::call);
  }
  unsigned int v4 = (const std::string *)CrashDiagnosticsDirectory[0];
  int v3 = 1;
  return llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::opt<char [22],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::LocationClass<std::string>,llvm::cl::OptionHidden>((uint64_t)v1, (int8x16_t *)"crash-diagnostics-dir", &v6, &v5, &v4, &v3);
}

uint64_t llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>::opt<char [22],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::LocationClass<std::string>,llvm::cl::OptionHidden>(uint64_t a1, int8x16_t *a2, _OWORD *a3, _OWORD *a4, const std::string **a5, _WORD *a6)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  stat v12 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AC0;
  *(void *)a1 = &unk_1EC9A3E98;
  *(void *)(a1 + 176) = &unk_1EC9A4410;
  *(void *)(a1 + 184) = &unk_1EC9CE628;
  *(void *)(a1 + 208) = a1 + 184;
  llvm::cl::apply<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>,char [22],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::LocationClass<std::string>,llvm::cl::OptionHidden>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

uint64_t llvm::cl::apply<llvm::cl::opt<std::string,true,llvm::cl::parser<std::string>>,char [22],llvm::cl::value_desc,llvm::cl::desc,llvm::cl::LocationClass<std::string>,llvm::cl::OptionHidden>(uint64_t a1, int8x16_t *__s, _OWORD *a3, _OWORD *a4, const std::string **a5, _WORD *a6)
{
  stat v12 = (const unsigned __int8 *)strlen(__s->i8);
  llvm::cl::Option::setArgStr(a1, __s, v12);
  *(_OWORD *)(a1 + 48) = *a3;
  *(_OWORD *)(a1 + 32) = *a4;
  if (*(void *)(a1 + 128))
  {
    uint64_t v17 = "cl::location(x) specified more than once!";
    __int16 v18 = 259;
    int v14 = (llvm::raw_ostream *)llvm::errs(v13);
    uint64_t result = llvm::cl::Option::error((void *)a1, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    unsigned int v16 = *a5;
    *(void *)(a1 + 128) = *a5;
    *(unsigned char *)(a1 + 168) = 1;
    uint64_t result = (uint64_t)std::string::operator=((std::string *)(a1 + 144), v16);
  }
  *(_WORD *)(a1 + 10) = (32 * (*a6 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void *llvm::object_creator<anonymous namespace'::FilesToRemoveCleanup>::call()
{
  return operator new(1uLL);
}

void llvm::object_deleter<anonymous namespace'::FilesToRemoveCleanup>::call(void *__p)
{
  if (__p)
  {
    uint64_t v2 = (atomic_ullong *)atomic_exchange(&qword_1EB216340, 0);
    if (v2)
    {
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void anonymous namespace'::FileToRemoveList::~FileToRemoveList(atomic_ullong *this)
{
  uint64_t v2 = (_anonymous_namespace_::FileToRemoveList *)atomic_exchange(this + 1, 0);
  if (v2)
  {
    operator delete(v3);
  }
  unsigned int v4 = (void *)atomic_exchange(this, 0);
  if (v4) {
    free(v4);
  }
}

uint64_t llvm::format_object<int,char const*>::snprint(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t llvm::format_object<int,unsigned long>::snprint(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t llvm::format_object<long>::snprint(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16));
}

uint64_t llvm::ThreadPoolStrategy::compute_thread_count(llvm::ThreadPoolStrategy *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 4))
  {
    unsigned int v2 = std::thread::hardware_concurrency();
    if (v2 <= 1) {
      int v3 = 1;
    }
    else {
      int v3 = v2;
    }
    if (v3 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = v3;
    }
    unsigned int v5 = *(_DWORD *)this;
    if (*(_DWORD *)this)
    {
LABEL_9:
      if (v5 >= result) {
        unsigned int v6 = result;
      }
      else {
        unsigned int v6 = v5;
      }
      if (*((unsigned char *)this + 5)) {
        return v6;
      }
      else {
        return v5;
      }
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB216E38, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB216E38))
    {
      int v9 = 0;
      size_t v8 = 4;
      sysctlbyname("hw.physicalcpu", &v9, &v8, 0, 0);
      int v7 = v9;
      if (!v9)
      {
        *(void *)uint64_t v10 = 0x1900000006;
        sysctl(v10, 2u, &v9, &v8, 0, 0);
        int v7 = v9;
        if (!v9) {
          int v7 = -1;
        }
      }
      _MergedGlobals_57 = v7;
      __cxa_guard_release(&qword_1EB216E38);
    }
    if (_MergedGlobals_57 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = _MergedGlobals_57;
    }
    unsigned int v5 = *(_DWORD *)this;
    if (*(_DWORD *)this) {
      goto LABEL_9;
    }
  }
  return result;
}

pthread_t llvm::llvm_execute_on_thread_impl(void *(__cdecl *a1)(void *), void *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = (llvm::sys *)pthread_attr_init(&v13);
  if (v6) {
    ReportErrnumFatal("pthread_attr_init failed", v6);
  }
  if ((a3 & 0xFF00000000) != 0)
  {
    int v7 = (llvm::sys *)pthread_attr_setstacksize(&v13, a3);
    if (v7) {
      ReportErrnumFatal("pthread_attr_setstacksize failed", v7);
    }
  }
  pthread_t v12 = 0;
  size_t v8 = (llvm::sys *)pthread_create(&v12, &v13, a1, a2);
  if (v8) {
    ReportErrnumFatal("pthread_create failed", v8);
  }
  pthread_t v9 = v12;
  uint64_t v10 = (llvm::sys *)pthread_attr_destroy(&v13);
  if (v10) {
    ReportErrnumFatal("pthread_attr_destroy failed", v10);
  }
  return v9;
}

void ReportErrnumFatal(char *__s, llvm::sys *a2)
{
  memset(v5, 0, sizeof(v5));
  std::string::basic_string[abi:nn180100]<0>(&v3, __s);
  MakeErrMsg((uint64_t)v5, (const void **)&v3.__r_.__value_.__l.__data_, a2);
  std::string::~string(&v3);
  __int16 v4 = 260;
  v3.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
  llvm::report_fatal_error((llvm::Twine *)&v3, 1);
}

llvm::sys *llvm::llvm_thread_join_impl(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result = (llvm::sys *)pthread_join(this, 0);
  if (result) {
    ReportErrnumFatal("pthread_join failed", result);
  }
  return result;
}

uint64_t llvm::get_threadid(llvm *this)
{
  mach_port_name_t v1 = MEMORY[0x1852FE480](this);
  mach_port_deallocate(*MEMORY[0x1E4F14960], v1);
  return v1;
}

void llvm::set_thread_name(llvm *this, const llvm::Twine *a2)
{
  v8[8] = *MEMORY[0x1E4F143B8];
  unsigned int v6 = v8;
  long long v7 = xmmword_181101A40;
  unsigned int v2 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)this, &v6);
  unint64_t v4 = v3 - 63;
  if (v3 < v3 - 63) {
    unint64_t v4 = v3;
  }
  unsigned int v5 = &v2[v4];
  if (v3 > 0x3F) {
    unsigned int v2 = v5;
  }
  pthread_setname_np(v2);
  if (v6 != v8) {
    free(v6);
  }
}

llvm::sys::Watchdog *llvm::sys::Watchdog::Watchdog(llvm::sys::Watchdog *this, unsigned int a2)
{
  return this;
}

void llvm::sys::Watchdog::~Watchdog(llvm::sys::Watchdog *this)
{
}

const char *llvm::itanium_demangle::parse_discriminator(const char *this, const char *a2, const char *a3)
{
  if (this != a2)
  {
    uint64_t v3 = *(unsigned __int8 *)this;
    if (v3 == 95)
    {
      if (this + 1 != a2 && (this[1] & 0x80000000) == 0)
      {
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *((unsigned __int8 *)this + 1) + 60) & 0x400) != 0)
        {
          this += 2;
        }
        else
        {
          unint64_t v4 = this + 2;
          if (this[1] == 95 && v4 != a2)
          {
            while (1)
            {
              uint64_t v6 = *(unsigned __int8 *)v4;
              if (*v4 < 0 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x400) == 0) {
                break;
              }
              if (++v4 == a2) {
                return this;
              }
            }
            if (v6 == 95) {
              return v4 + 1;
            }
          }
        }
      }
    }
    else if ((v3 & 0x80) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x400) != 0)
    {
      long long v7 = this + 1;
      while (v7 != a2)
      {
        int v8 = *v7;
        if ((v8 & 0x80000000) == 0)
        {
          ++v7;
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x400) != 0) {
            continue;
          }
        }
        return this;
      }
      return a2;
    }
  }
  return this;
}

char *llvm::itaniumDemangle()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!v1) {
    return 0;
  }
  v15[0] = v0;
  v15[1] = v0 + v1;
  unsigned int v16 = v19;
  uint64_t v17 = v19;
  __int16 v18 = v20;
  memset(v19, 0, sizeof(v19));
  v20[0] = v21;
  v20[1] = v21;
  memset(v21, 0, sizeof(v21));
  memset(v23, 0, sizeof(v23));
  v22[0] = v23;
  v22[1] = v23;
  v20[2] = v22;
  stat v22[2] = v24;
  v24[0] = v25;
  v24[1] = v25;
  _OWORD v24[2] = v26;
  memset(v25, 0, sizeof(v25));
  memset(v27, 0, sizeof(v27));
  v26[0] = v27;
  v26[1] = v27;
  v26[2] = &v28;
  __int16 v28 = 1;
  char v29 = 0;
  uint64_t v30 = -1;
  int v32 = 0;
  uint64_t v31 = 0;
  v33[0] = 0u;
  uint64_t v34 = v33;
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = -1;
    int v14 = 1;
    (*(void (**)(char *, void **))(*(void *)v2 + 32))(v2, &v10);
    if ((*(_WORD *)(v3 + 9) & 0xC0) != 0x40) {
      (*(void (**)(char *, void **))(*(void *)v3 + 40))(v3, &v10);
    }
    unint64_t v4 = v10;
    uint64_t v5 = v11;
    if (v11 + 1 > v12)
    {
      if (2 * v12 <= v11 + 993) {
        size_t v6 = v11 + 993;
      }
      else {
        size_t v6 = 2 * v12;
      }
      unint64_t v12 = v6;
      unint64_t v4 = realloc(v10, v6);
      uint64_t v10 = v4;
      if (!v4) {
        abort();
      }
      uint64_t v5 = v11;
    }
    *((unsigned char *)v4 + v5) = 0;
    uint64_t v3 = (char *)v10;
  }
  long long v7 = (void **)v34;
  if (v34)
  {
    do
    {
      while (1)
      {
        int v8 = (void **)*v7;
        uint64_t v34 = *v7;
        if (v7 == (void **)v33) {
          break;
        }
        free(v7);
        long long v7 = (void **)v34;
        if (!v34) {
          goto LABEL_17;
        }
      }
      long long v7 = v8;
    }
    while (v8);
  }
LABEL_17:
  v33[0] = 0uLL;
  uint64_t v34 = v33;
  if (v26[0] != v27) {
    free(v26[0]);
  }
  if (v24[0] != v25) {
    free(v24[0]);
  }
  if (v22[0] != v23) {
    free(v22[0]);
  }
  if (v20[0] != v21) {
    free(v20[0]);
  }
  if (v16 != v19) {
    free(v16);
  }
  return v3;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parse(uint64_t a1, size_t a2)
{
  uint64_t v3 = *(unsigned __int8 **)a1;
  unint64_t v4 = *(void *)(a1 + 8) - *(void *)a1;
  if (v4 < 2) {
    goto LABEL_15;
  }
  if (*(_WORD *)v3 == 23135)
  {
    *(void *)a1 = v3 + 2;
    if (!result) {
      return result;
    }
  }
  else
  {
    if (v4 < 3) {
      goto LABEL_15;
    }
    if (*(_WORD *)v3 != 24415 || v3[2] != 90)
    {
      if (v4 >= 4)
      {
        if (*(_DWORD *)v3 == 1516199775)
        {
          uint64_t v17 = 4;
        }
        else
        {
          if (v4 < 5) {
            goto LABEL_15;
          }
          if (*(_DWORD *)v3 != 1600085855 || v3[4] != 90) {
            goto LABEL_15;
          }
          uint64_t v17 = 5;
        }
        *(void *)a1 = &v3[v17];
        unsigned int v26 = result;
        if (!result) {
          return result;
        }
        std::string v19 = *(unsigned __int8 **)a1;
        __int16 v18 = *(char **)(a1 + 8);
        if ((unint64_t)&v18[-*(void *)a1] < 0xD) {
          return 0;
        }
        if (*(void *)v19 != 0x695F6B636F6C625FLL || *(void *)(v19 + 5) != 0x656B6F766E695F6BLL) {
          return 0;
        }
        size_t v21 = (char *)(v19 + 13);
        *(void *)a1 = v19 + 13;
        if (v19 + 13 != (unsigned __int8 *)v18)
        {
          int v22 = *v21;
          if (v22 == 95)
          {
            size_t v21 = (char *)(v19 + 14);
            *(void *)a1 = v19 + 14;
          }
          if (v18 == v21)
          {
            BOOL v24 = 1;
            size_t v21 = v18;
          }
          else if ((*v21 & 0x80000000) == 0 {
                 && (uint64_t v23 = MEMORY[0x1E4F14390],
          }
                     (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v21 + 60) & 0x400) != 0))
          {
            unint64_t v25 = v21;
            while ((*v25 & 0x80000000) == 0 && (*(_DWORD *)(v23 + 4 * *v25 + 60) & 0x400) != 0)
            {
              *(void *)a1 = ++v25;
              if (v25 == v18)
              {
                unint64_t v25 = v18;
                break;
              }
            }
            BOOL v24 = v25 == v21;
            size_t v21 = v25;
          }
          else
          {
            BOOL v24 = 1;
          }
          if (v22 == 95 && v24) {
            return 0;
          }
          if (v18 != v21)
          {
            if (*v21 != 46) {
              return 0;
            }
            *(void *)a1 = v18;
          }
        }
      }
LABEL_15:
      if (*(void *)(a1 + 8) != *(void *)a1) {
        return 0;
      }
      return result;
    }
    *(void *)a1 = v3 + 3;
    if (!result) {
      return result;
    }
  }
  int v8 = result;
  uint64_t v10 = *(unsigned __int8 **)a1;
  pthread_t v9 = *(unsigned __int8 **)(a1 + 8);
  uint64_t v11 = &v9[-*(void *)a1];
  if (v9 == *(unsigned __int8 **)a1)
  {
    pthread_t v9 = *(unsigned __int8 **)a1;
  }
  else if (*v10 == 46)
  {
    unint64_t v12 = *(void **)(a1 + 4904);
    uint64_t v13 = v12[1];
    if ((unint64_t)(v13 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
    {
      int v14 = malloc(0x1000uLL);
      if (!v14) {
        std::terminate();
      }
      uint64_t v13 = 0;
      *int v14 = v12;
      v14[1] = 0;
      unint64_t v12 = v14;
      *(void *)(a1 + 4904) = v14;
    }
    v12[1] = v13 + 48;
    uint64_t v15 = (char *)v12 + v13;
    unsigned int v16 = v15 + 16;
    v15[24] = 1;
    *(_WORD *)(v15 + 25) = *(_WORD *)(v15 + 25) & 0xF000 | 0x540;
    *((void *)v15 + 2) = &unk_1EC9A3730;
    *((void *)v15 + 4) = v8;
    *((void *)v15 + 5) = v10;
    *((void *)v15 + 6) = v11;
    pthread_t v9 = *(unsigned __int8 **)(a1 + 8);
    *(void *)a1 = v9;
    uint64_t v10 = v9;
    int v8 = v16;
  }
  if (v9 == v10) {
    return v8;
  }
  else {
    return 0;
  }
}

void *llvm::itanium_demangle::Node::printAsOperand(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a4 + a3 <= (*(unsigned __int16 *)(a1 + 9) << 26 >> 26))
  {
    ++*(_DWORD *)(a2 + 32);
    int v8 = *(void **)a2;
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = v9 + 1;
    unint64_t v11 = *(void *)(a2 + 16);
    if (v9 + 1 > v11)
    {
      unint64_t v12 = v9 + 993;
      if (2 * v11 <= v12) {
        size_t v13 = v12;
      }
      else {
        size_t v13 = 2 * v11;
      }
      *(void *)(a2 + 16) = v13;
      int v8 = realloc(v8, v13);
      *(void *)a2 = v8;
      if (!v8) {
        goto LABEL_22;
      }
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v10 = v9 + 1;
    }
    *(void *)(a2 + 8) = v10;
    *((unsigned char *)v8 + v9) = 40;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
    if ((*(_WORD *)(a1 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2);
    }
    --*(_DWORD *)(a2 + 32);
    uint64_t result = *(void **)a2;
    uint64_t v14 = *(void *)(a2 + 8);
    uint64_t v15 = v14 + 1;
    unint64_t v16 = *(void *)(a2 + 16);
    if (v14 + 1 <= v16) {
      goto LABEL_20;
    }
    unint64_t v17 = v14 + 993;
    if (2 * v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = 2 * v16;
    }
    *(void *)(a2 + 16) = v18;
    uint64_t result = realloc(result, v18);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = v14 + 1;
LABEL_20:
      *(void *)(a2 + 8) = v15;
      *((unsigned char *)result + v14) = 41;
      return result;
    }
LABEL_22:
    abort();
  }
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
  if ((*(_WORD *)(a1 + 9) & 0xC0) != 0x40)
  {
    long long v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40);
    return (void *)v7(a1, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::consumeIf(const void **a1, const void *a2, size_t a3)
{
  uint64_t v3 = (char *)*a1;
  if (a3 > (unsigned char *)a1[1] - (unsigned char *)*a1) {
    return 0;
  }
  if (memcmp(*a1, a2, a3)) {
    return 0;
  }
  *a1 = &v3[a3];
  return 1;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseEncoding(unsigned __int8 **a1)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 - *a1;
  if (v4 == *a1) {
    goto LABEL_8;
  }
  int v6 = *v3;
  if (v6 == 71)
  {
    if (v5 < 2) {
      goto LABEL_136;
    }
    int v22 = (char)v3[1];
    if (v22 == 73)
    {
      *a1 = v3 + 2;
      uint64_t v86 = 0;
      unint64_t v12 = 0;
      BOOL v24 = v86;
      if (!v86) {
        goto LABEL_137;
      }
      __int16 v43 = a1[613];
      uint64_t v44 = *((void *)v43 + 1);
      if ((unint64_t)(v44 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v45 = (unsigned __int8 *)malloc(0x1000uLL);
        if (!v45) {
          goto LABEL_141;
        }
        uint64_t v44 = 0;
        *(void *)uint64_t v45 = v43;
        *((void *)v45 + 1) = 0;
        __int16 v43 = v45;
        a1[613] = v45;
      }
      *((void *)v43 + 1) = v44 + 48;
      __int16 v28 = &v43[v44];
      unint64_t v12 = (char *)(v28 + 16);
      v28[24] = 21;
      *(_WORD *)(v28 + 25) = *(_WORD *)(v28 + 25) & 0xF000 | 0x540;
      *((void *)v28 + 2) = &unk_1EC9A1F20;
      char v29 = "initializer for module ";
      uint64_t v30 = 23;
      goto LABEL_60;
    }
    if (v22 != 82)
    {
      if (v22 != 86) {
        goto LABEL_136;
      }
      *a1 = v3 + 2;
      if (!v23) {
        goto LABEL_136;
      }
      BOOL v24 = v23;
      unint64_t v25 = a1[613];
      uint64_t v26 = *((void *)v25 + 1);
      if ((unint64_t)(v26 - 4032) > 0xFFFFFFFFFFFFF00FLL) {
        goto LABEL_27;
      }
      uint64_t v27 = (unsigned __int8 *)malloc(0x1000uLL);
      if (v27)
      {
        uint64_t v26 = 0;
        *(void *)uint64_t v27 = v25;
        *((void *)v27 + 1) = 0;
        unint64_t v25 = v27;
        a1[613] = v27;
LABEL_27:
        *((void *)v25 + 1) = v26 + 48;
        __int16 v28 = &v25[v26];
        unint64_t v12 = (char *)(v28 + 16);
        v28[24] = 21;
        *(_WORD *)(v28 + 25) = *(_WORD *)(v28 + 25) & 0xF000 | 0x540;
        *((void *)v28 + 2) = &unk_1EC9A1F20;
        char v29 = "guard variable for ";
        uint64_t v30 = 19;
LABEL_60:
        *((void *)v28 + 4) = v29;
        *((void *)v28 + 5) = v30;
        *((void *)v28 + 6) = v24;
        goto LABEL_137;
      }
LABEL_141:
      std::terminate();
    }
    *a1 = v3 + 2;
    if (!v86) {
      goto LABEL_136;
    }
    unint64_t v46 = *a1;
    size_t v47 = a1[1];
    if (v47 == *a1 || (char)*v46 < 48 || (unsigned int v48 = *v46, v48 >= 0x3A) && v48 - 65 > 0x19)
    {
      int v49 = 1;
      if (v46 == v47) {
        goto LABEL_76;
      }
    }
    else
    {
      while ((char)*v46 >= 48)
      {
        unsigned int v50 = *v46;
        BOOL v51 = v50 >= 0x3A && v50 - 65 > 0x19;
        if (v51) {
          break;
        }
        *a1 = ++v46;
        if (v46 == v47) {
          goto LABEL_136;
        }
      }
      int v49 = 0;
      if (v46 == v47) {
        goto LABEL_76;
      }
    }
    if (*v46 == 95)
    {
      *a1 = v46 + 1;
LABEL_77:
      goto LABEL_118;
    }
LABEL_76:
    if (!v49) {
      goto LABEL_136;
    }
    goto LABEL_77;
  }
  if (v6 == 84)
  {
    if (v5 >= 2)
    {
      switch(v3[1])
      {
        case 'A':
          *a1 = v3 + 2;
          uint64_t v86 = v7;
          if (!v7) {
            goto LABEL_136;
          }
          break;
        case 'C':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          if (!v66) {
            goto LABEL_136;
          }
          uint64_t v67 = *a1;
          if (*a1 == a1[1]) {
            goto LABEL_136;
          }
          if (*v67 != 95) {
            goto LABEL_136;
          }
          *a1 = v67 + 1;
          if (!v83.n128_u64[0]) {
            goto LABEL_136;
          }
          break;
        case 'H':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'I':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'S':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'T':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'V':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'W':
          *a1 = v3 + 2;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        case 'c':
          *a1 = v3 + 2;
            goto LABEL_136;
            goto LABEL_136;
          if (!v86) {
            goto LABEL_136;
          }
          break;
        default:
          goto LABEL_47;
      }
      goto LABEL_118;
    }
LABEL_47:
    char v41 = v3 + 1;
    *a1 = v41;
    if (v4 == v41)
    {
      BOOL v42 = 0;
        goto LABEL_136;
    }
    else
    {
      BOOL v42 = *v41 == 118;
        goto LABEL_136;
    }
    if (v86)
    {
      if (v42) {
      else
      }
      goto LABEL_118;
    }
LABEL_136:
    unint64_t v12 = 0;
    goto LABEL_137;
  }
LABEL_8:
  uint64_t v9 = a1[90];
  uint64_t v10 = a1[91];
  LOWORD(v86) = 0;
  HIDWORD(v86) = 0;
  char v87 = 0;
  unint64_t v88 = (v10 - v9) >> 3;
  char v85 = v12;
  if (v12)
  {
    size_t v13 = a1[90];
    unint64_t v14 = (a1[91] - v13) >> 3;
    if (v14 <= v88)
    {
      unint64_t v16 = &v13[8 * v88];
    }
    else
    {
      uint64_t v15 = a1[83];
      if (v15 == a1[84]) {
        goto LABEL_136;
      }
      if (!*(void *)v15) {
        goto LABEL_136;
      }
      unint64_t v16 = &v13[8 * v88];
      uint64_t v17 = *(void *)v16;
      unint64_t v18 = *(void *)(*(void *)v16 + 16);
      uint64_t v19 = **(void **)v15;
      if (v18 >= (*(void *)(*(void *)v15 + 8) - v19) >> 3) {
        goto LABEL_136;
      }
      unint64_t v20 = v88 + 1;
      while (1)
      {
        *(void *)(v17 + 24) = *(void *)(v19 + 8 * v18);
        if (v14 == v20) {
          break;
        }
        unint64_t v21 = v20;
        if (*(void *)v15)
        {
          uint64_t v17 = *(void *)&v13[8 * v20];
          unint64_t v18 = *(void *)(v17 + 16);
          uint64_t v19 = **(void **)v15;
          ++v20;
          if (v18 < (*(void *)(*(void *)v15 + 8) - v19) >> 3) {
            continue;
          }
        }
        if (v21 >= v14) {
          goto LABEL_30;
        }
        goto LABEL_136;
      }
    }
    a1[91] = v16;
LABEL_30:
    int v32 = *a1;
    uint64_t v31 = a1[1];
    unint64_t v33 = v31 - *a1;
    if (v31 != *a1)
    {
      unsigned int v34 = *v32 - 46;
      BOOL v51 = v34 > 0x31;
      uint64_t v35 = (1 << v34) & 0x2000000800001;
      if (v51 || v35 == 0)
      {
        uint64_t v84 = 0;
        if (v33 >= 0xD
          && (*(void *)v32 == 0x6C62616E65396155 ? (BOOL v37 = *(void *)(v32 + 5) == 0x4966695F656C6261) : (BOOL v37 = 0),
              v37))
        {
          unint64_t v68 = v32 + 13;
          *a1 = v68;
          uint64_t v69 = (a1[3] - a1[2]) >> 3;
          pid_t v70 = a1 + 5;
          while (v68 == v31 || *v68 != 69)
          {
            if (!v73) {
              goto LABEL_136;
            }
            uint64_t v74 = v73;
            int v72 = a1[3];
            if (v72 == a1[4])
            {
              size_t v75 = a1[2];
              int64_t v76 = v72 - v75;
              if (v75 == (unsigned __int8 *)v70)
              {
                uint64_t v77 = (unsigned __int8 *)malloc(2 * (v72 - v75));
                if (!v77) {
LABEL_140:
                }
                  abort();
                size_t v71 = v77;
                if (v72 != (unsigned __int8 *)v70) {
                  memcpy(v77, a1 + 5, v76);
                }
                a1[2] = v71;
              }
              else
              {
                size_t v71 = (unsigned __int8 *)realloc(v75, 2 * (v72 - v75));
                a1[2] = v71;
                if (!v71) {
                  goto LABEL_140;
                }
              }
              int v72 = &v71[8 * (v76 >> 3)];
              a1[4] = &v71[8 * (v76 >> 2)];
            }
            a1[3] = v72 + 8;
            *(void *)int v72 = v74;
            unint64_t v68 = *a1;
            uint64_t v31 = a1[1];
          }
          *a1 = v68 + 1;
          v83.n128_u64[1] = v79;
          uint64_t v84 = v80;
          int v82 = 0;
          if (!(_BYTE)v86)
          {
LABEL_42:
            if (BYTE1(v86))
            {
              if (!v82) {
                goto LABEL_136;
              }
            }
          }
        }
        else
        {
          int v82 = 0;
          if (!(_BYTE)v86) {
            goto LABEL_42;
          }
        }
        __n128 v83 = 0uLL;
        sigaction v39 = *a1;
        uint64_t v38 = a1[1];
        if (*a1 == v38 || *v39 != 118)
        {
          uint64_t v52 = (a1[3] - a1[2]) >> 3;
          size_t v53 = a1 + 5;
          while (1)
          {
            if (!v54) {
              goto LABEL_136;
            }
            char v55 = v54;
            char v56 = a1[3];
            if (v56 == a1[4])
            {
              uint64_t v57 = a1[2];
              int64_t v58 = v56 - v57;
              if (v57 == (unsigned __int8 *)v53)
              {
                uint64_t v60 = (unsigned __int8 *)malloc(2 * (v56 - v57));
                if (!v60) {
                  goto LABEL_140;
                }
                std::string::size_type v59 = v60;
                if (v56 != (unsigned __int8 *)v53) {
                  memcpy(v60, a1 + 5, v58);
                }
                a1[2] = v59;
              }
              else
              {
                std::string::size_type v59 = (unsigned __int8 *)realloc(v57, 2 * (v56 - v57));
                a1[2] = v59;
                if (!v59) {
                  goto LABEL_140;
                }
              }
              char v56 = &v59[8 * (v58 >> 3)];
              a1[4] = &v59[8 * (v58 >> 2)];
            }
            a1[3] = v56 + 8;
            *(void *)char v56 = v55;
            if (a1[1] != *a1)
            {
              unsigned int v61 = **a1 - 46;
              BOOL v51 = v61 > 0x31;
              uint64_t v62 = (1 << v61) & 0x2000800800001;
              if (v51 || v62 == 0) {
                continue;
              }
            }
            v83.n128_u64[1] = v11;
            uint64_t v40 = *a1;
            uint64_t v38 = a1[1];
            goto LABEL_96;
          }
        }
        uint64_t v40 = v39 + 1;
        *a1 = v40;
LABEL_96:
        uint64_t v81 = 0;
        if (v40 != v38 && *v40 == 81)
        {
          *a1 = v40 + 1;
          char v64 = *((unsigned char *)a1 + 778);
          *((unsigned char *)a1 + 778) = 1;
          *((unsigned char *)a1 + 778) = v64;
          uint64_t v81 = v65;
          if (!v65) {
            goto LABEL_136;
          }
        }
LABEL_118:
        unint64_t v12 = v8;
      }
    }
  }
LABEL_137:
  return v12;
}

unsigned __int8 *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseNumber(unsigned __int8 **a1, char a2)
{
  uint64_t result = *a1;
  if ((a2 & 1) == 0)
  {
    unint64_t v4 = a1[1];
    goto LABEL_7;
  }
  unint64_t v4 = a1[1];
  if (result == v4) {
    return 0;
  }
  if (*result != 110)
  {
LABEL_7:
    unint64_t v5 = result;
    if (v4 != result) {
      goto LABEL_8;
    }
    return 0;
  }
  unint64_t v5 = result + 1;
  *a1 = result + 1;
  if (v4 == result + 1) {
    return 0;
  }
LABEL_8:
  if ((char)*v5 < 0) {
    return 0;
  }
  uint64_t v6 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v5 + 60) & 0x400) == 0) {
    return 0;
  }
  do
  {
    if ((char)*v5 < 0) {
      break;
    }
    if ((*(_DWORD *)(v6 + 4 * *v5 + 60) & 0x400) == 0) {
      break;
    }
    *a1 = ++v5;
  }
  while (v5 != v4);
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[34],llvm::itanium_demangle::Node *&>(uint64_t a1, char *__s, uint64_t *a3)
{
  unint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    unint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 48;
  uint64_t v9 = (char *)v5 + v6;
  size_t v10 = strlen(__s);
  uint64_t v11 = *a3;
  v9[24] = 21;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A1F20;
  *((void *)v9 + 4) = __s;
  *((void *)v9 + 5) = v10;
  *((void *)v9 + 6) = v11;
  return v9 + 16;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseType(uint64_t a1, size_t a2)
{
  uint64_t v133 = 0;
  uint64_t v3 = *(unsigned __int8 **)a1;
  unint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v5 = (unint64_t)&v4[-*(void *)a1];
  if (v4 != *(unsigned __int8 **)a1)
  {
    int v6 = *v3;
    switch(*v3)
    {
      case 'A':
        if (v6 != 65) {
          goto LABEL_190;
        }
        *(void *)a1 = v3 + 1;
        unint64_t v135 = 0;
        if (v4 == v3 + 1)
        {
          if ((*(unsigned char *)(MEMORY[0x1E4F14390] + 61) & 4) == 0) {
            goto LABEL_179;
          }
        }
        else
        {
          uint64_t v13 = (char)v3[1];
          if (v13 < 0) {
            goto LABEL_179;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v13 + 60) & 0x400) == 0)
          {
            if (v13 == 95)
            {
              unint64_t v14 = v3 + 2;
LABEL_186:
              *(void *)a1 = v14;
              goto LABEL_187;
            }
LABEL_179:
            if (!v108) {
              goto LABEL_190;
            }
            uint64_t v109 = *(unsigned __int8 **)a1;
            if (*(void *)a1 == *(void *)(a1 + 8) || *v109 != 95) {
              goto LABEL_190;
            }
            *(void *)a1 = v109 + 1;
            unint64_t v135 = v108;
LABEL_187:
            if (v134.n128_u64[0])
            {
              uint64_t v133 = v12;
              if (!v12) {
                return (char *)v12;
              }
              goto LABEL_65;
            }
LABEL_190:
            uint64_t v12 = 0;
            uint64_t v133 = 0;
            return (char *)v12;
          }
        }
        v134.n128_u64[1] = v110;
        unint64_t v135 = v111;
        unint64_t v112 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8) || *v112 != 95) {
          goto LABEL_190;
        }
        unint64_t v14 = v112 + 1;
        goto LABEL_186;
      case 'C':
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          return 0;
        }
        goto LABEL_50;
      case 'D':
        if (v5 < 2) {
          return 0;
        }
        uint64_t v12 = 0;
        int v16 = v3[1];
        switch(v3[1])
        {
          case 'B':
          case 'U':
            char v17 = v16 == 66;
            unint64_t v18 = (unint64_t)(v3 + 2);
            *(void *)a1 = v18;
            if (v4 == (unsigned __int8 *)v18)
            {
              unint64_t v18 = 0;
            }
            else
            {
              LODWORD(v18) = *(char *)v18;
              if ((v18 & 0x80000000) != 0) {
                goto LABEL_252;
              }
              unint64_t v18 = v18;
            }
            if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x400) != 0)
            {
              v134.n128_u64[1] = v130;
              v134.n128_u64[0] = v131;
              goto LABEL_255;
            }
LABEL_252:
            v134.n128_u64[0] = v129;
            if (!v129) {
              return 0;
            }
LABEL_255:
            uint64_t v132 = *(unsigned __int8 **)a1;
            if (*(void *)a1 == *(void *)(a1 + 8) || *v132 != 95) {
              return 0;
            }
            *(void *)a1 = v132 + 1;
          case 'F':
            *(void *)a1 = v3 + 2;
            v134.n128_u64[1] = v120;
            v134.n128_u64[0] = v122;
            long long v123 = (_WORD *)(*(uint64_t (**)(unint64_t, __n128))(*(void *)v122 + 48))(v122, v121);
            if (v124 == 2)
            {
              long long v125 = *(unsigned __int8 **)a1;
              int32x4_t v126 = *(unsigned __int8 **)(a1 + 8);
              if (*v123 == 13873)
              {
                if (v125 == v126) {
                  return 0;
                }
                if (*v125 == 98)
                {
                  *(void *)a1 = v125 + 1;
                }
              }
            }
            else
            {
              long long v125 = *(unsigned __int8 **)a1;
              int32x4_t v126 = *(unsigned __int8 **)(a1 + 8);
            }
            if (v125 == v126 || *v125 != 95) {
              return 0;
            }
            *(void *)a1 = v125 + 1;
            break;
          case 'K':
          case 'k':
            v116 = " decltype(auto)";
            BOOL v117 = v16 == 107;
            if (v16 == 107) {
              v116 = " auto";
            }
            unint64_t v118 = 15;
            if (v117) {
              unint64_t v118 = 5;
            }
            v134.n128_u64[0] = (unint64_t)v116;
            v134.n128_u64[1] = v118;
            *(void *)a1 = v3 + 2;
            if (!v135) {
              return 0;
            }
            return (char *)v119;
          case 'O':
          case 'o':
          case 'w':
          case 'x':
            goto LABEL_176;
          case 'T':
          case 't':
            uint64_t v133 = v12;
            if (!v12) {
              return (char *)v12;
            }
            goto LABEL_65;
          case 'a':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "auto";
            goto LABEL_231;
          case 'c':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "decltype(auto)";
            goto LABEL_236;
          case 'd':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "decimal64";
            goto LABEL_227;
          case 'e':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "decimal128";
          case 'f':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "decimal32";
LABEL_227:
          case 'h':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "half";
LABEL_231:
          case 'i':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "char32_t";
            goto LABEL_242;
          case 'n':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "std::nullptr_t";
LABEL_236:
          case 'p':
            *(void *)a1 = v3 + 2;
            if (!v134.n128_u64[0]) {
              return 0;
            }
            goto LABEL_50;
          case 's':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "char16_t";
LABEL_242:
          case 'u':
            *(void *)a1 = v3 + 2;
            uint64_t v127 = "char8_t";
          case 'v':
            uint64_t v12 = v128;
            uint64_t v133 = v128;
            if (!v128) {
              return (char *)v12;
            }
            goto LABEL_65;
          default:
            return (char *)v12;
        }
        return (char *)v12;
      case 'F':
        goto LABEL_176;
      case 'G':
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          return 0;
        }
        goto LABEL_50;
      case 'K':
      case 'V':
      case 'r':
        if (v6 == 114)
        {
          if (v5 < 2)
          {
            unsigned int v7 = 1;
            unint64_t v8 = 1;
            goto LABEL_15;
          }
          if (v3[1] == 86) {
            unsigned int v7 = 2;
          }
          else {
            unsigned int v7 = 1;
          }
          unint64_t v8 = v7;
          if (v5 <= v7)
          {
LABEL_15:
            if (v5 > v8
              && ((int v9 = v3[v8], v9 == 70)
               || ((unint64_t v10 = v7 + 1, v9 == 68) ? (v11 = v5 > v10) : (v11 = 0),
                   v11 && (unsigned int v106 = v3[v10] - 79, v106 <= 0x29) && ((1 << v106) & 0x30100000001) != 0)))
            {
LABEL_176:
              uint64_t v12 = v107;
              uint64_t v133 = v107;
              if (!v107) {
                return (char *)v12;
              }
            }
            else
            {
LABEL_21:
              uint64_t v133 = v12;
              if (!v12) {
                return (char *)v12;
              }
            }
            goto LABEL_65;
          }
        }
        else
        {
          unsigned int v7 = v6 == 86;
          unint64_t v8 = v6 == 86;
          if (v5 <= v7) {
            goto LABEL_15;
          }
        }
        if (v3[v8] == 75) {
          unint64_t v8 = v7 + 1;
        }
        else {
          unint64_t v8 = v7;
        }
        unsigned int v7 = v8;
        goto LABEL_15;
      case 'M':
        if (v6 != 77) {
          goto LABEL_190;
        }
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          goto LABEL_190;
        }
        if (!v135) {
          goto LABEL_190;
        }
        uint64_t v133 = v12;
        if (!v12) {
          return (char *)v12;
        }
        goto LABEL_65;
      case 'O':
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          return 0;
        }
        uint64_t v19 = a1;
        int v20 = 1;
        goto LABEL_49;
      case 'P':
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          return 0;
        }
        goto LABEL_50;
      case 'R':
        *(void *)a1 = v3 + 1;
        if (!v134.n128_u64[0]) {
          return 0;
        }
        uint64_t v19 = a1;
        int v20 = 0;
LABEL_49:
        goto LABEL_50;
      case 'S':
        if (v5 >= 2 && v3[1] == 116) {
          break;
        }
        LOBYTE(v135) = 0;
        uint64_t v133 = (uint64_t)v21;
        if (!v21) {
          return 0;
        }
        uint64_t v12 = (uint64_t)v21;
        if (*(void *)(a1 + 8) == *(void *)a1)
        {
          int v22 = v135;
        }
        else
        {
          int v22 = v135;
          if (**(unsigned char **)a1 == 73)
          {
            if ((_BYTE)v135)
            {
              if (!*(unsigned char *)(a1 + 776)) {
                return (char *)v12;
              }
            }
            else
            {
              llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 296), &v133);
            }
LABEL_205:
            v134.n128_u64[0] = v115;
            if (v115)
            {
              goto LABEL_50;
            }
            return 0;
          }
        }
        if (v22) {
          return (char *)v12;
        }
LABEL_65:
        uint64_t v26 = *(uint64_t **)(a1 + 304);
        if (v26 != *(uint64_t **)(a1 + 312))
        {
LABEL_74:
          *(void *)(a1 + 304) = v26 + 1;
          *uint64_t v26 = v12;
          return (char *)v133;
        }
        uint64_t v27 = *(uint64_t **)(a1 + 296);
        uint64_t v28 = (char *)v26 - (char *)v27;
        if (v27 == (uint64_t *)(a1 + 320))
        {
          uint64_t v31 = (char *)malloc(2 * ((char *)v26 - (char *)v27));
          if (v31)
          {
            uint64_t v30 = v31;
            if (v26 != v27) {
              memmove(v31, v27, (char *)v26 - (char *)v27);
            }
            *(void *)(a1 + 296) = v30;
            goto LABEL_73;
          }
        }
        else
        {
          char v29 = (char *)realloc(*(void **)(a1 + 296), 2 * ((char *)v26 - (char *)v27));
          *(void *)(a1 + 296) = v29;
          if (v29)
          {
            uint64_t v30 = v29;
            uint64_t v12 = v133;
LABEL_73:
            uint64_t v26 = (uint64_t *)&v30[8 * (v28 >> 3)];
            *(void *)(a1 + 312) = &v30[8 * (v28 >> 2)];
            goto LABEL_74;
          }
        }
        abort();
      case 'T':
        if (v5 >= 2)
        {
          unsigned int v23 = v3[1] - 101;
          BOOL v11 = v23 > 0x10;
          int v24 = (1 << v23) & 0x14001;
          if (!v11 && v24 != 0) {
            break;
          }
        }
        uint64_t v133 = v12;
        if (!v12) {
          return (char *)v12;
        }
        if (*(unsigned char *)(a1 + 776) && *(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 73) {
          goto LABEL_205;
        }
        goto LABEL_65;
      case 'U':
        goto LABEL_21;
      case 'a':
        *(void *)a1 = v3 + 1;
        int v32 = *(void **)(a1 + 4904);
        uint64_t v33 = v32[1];
        if ((unint64_t)(v33 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_78;
        }
        unsigned int v34 = malloc(0x1000uLL);
        if (!v34) {
          goto LABEL_263;
        }
        uint64_t v33 = 0;
        *unsigned int v34 = v32;
        v34[1] = 0;
        int v32 = v34;
        *(void *)(a1 + 4904) = v34;
LABEL_78:
        v32[1] = v33 + 32;
        uint64_t v35 = (char *)v32 + v33;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "signed char";
        uint64_t v37 = 11;
        goto LABEL_150;
      case 'b':
        *(void *)a1 = v3 + 1;
        uint64_t v38 = *(void **)(a1 + 4904);
        uint64_t v39 = v38[1];
        if ((unint64_t)(v39 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_82;
        }
        uint64_t v40 = malloc(0x1000uLL);
        if (!v40) {
          goto LABEL_263;
        }
        uint64_t v39 = 0;
        *uint64_t v40 = v38;
        v40[1] = 0;
        uint64_t v38 = v40;
        *(void *)(a1 + 4904) = v40;
LABEL_82:
        v38[1] = v39 + 32;
        uint64_t v35 = (char *)v38 + v39;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "BOOL";
        goto LABEL_149;
      case 'c':
        *(void *)a1 = v3 + 1;
        char v41 = *(void **)(a1 + 4904);
        uint64_t v42 = v41[1];
        if ((unint64_t)(v42 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_86;
        }
        __int16 v43 = malloc(0x1000uLL);
        if (!v43) {
          goto LABEL_263;
        }
        uint64_t v42 = 0;
        *__int16 v43 = v41;
        v43[1] = 0;
        char v41 = v43;
        *(void *)(a1 + 4904) = v43;
LABEL_86:
        v41[1] = v42 + 32;
        uint64_t v35 = (char *)v41 + v42;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "char";
        goto LABEL_149;
      case 'd':
        *(void *)a1 = v3 + 1;
        uint64_t v44 = *(void **)(a1 + 4904);
        uint64_t v45 = v44[1];
        if ((unint64_t)(v45 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_90;
        }
        unint64_t v46 = malloc(0x1000uLL);
        if (!v46) {
          goto LABEL_263;
        }
        uint64_t v45 = 0;
        *unint64_t v46 = v44;
        v46[1] = 0;
        uint64_t v44 = v46;
        *(void *)(a1 + 4904) = v46;
LABEL_90:
        v44[1] = v45 + 32;
        uint64_t v35 = (char *)v44 + v45;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "double";
        uint64_t v37 = 6;
        goto LABEL_150;
      case 'e':
        *(void *)a1 = v3 + 1;
        size_t v47 = *(void **)(a1 + 4904);
        uint64_t v48 = v47[1];
        if ((unint64_t)(v48 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_94;
        }
        int v49 = malloc(0x1000uLL);
        if (!v49) {
          goto LABEL_263;
        }
        uint64_t v48 = 0;
        *int v49 = v47;
        v49[1] = 0;
        size_t v47 = v49;
        *(void *)(a1 + 4904) = v49;
LABEL_94:
        v47[1] = v48 + 32;
        uint64_t v35 = (char *)v47 + v48;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "long double";
        uint64_t v37 = 11;
        goto LABEL_150;
      case 'f':
        *(void *)a1 = v3 + 1;
        unsigned int v50 = *(void **)(a1 + 4904);
        uint64_t v51 = v50[1];
        if ((unint64_t)(v51 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_98;
        }
        uint64_t v52 = malloc(0x1000uLL);
        if (!v52) {
          goto LABEL_263;
        }
        uint64_t v51 = 0;
        *uint64_t v52 = v50;
        v52[1] = 0;
        unsigned int v50 = v52;
        *(void *)(a1 + 4904) = v52;
LABEL_98:
        v50[1] = v51 + 32;
        uint64_t v35 = (char *)v50 + v51;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "float";
        uint64_t v37 = 5;
        goto LABEL_150;
      case 'g':
        *(void *)a1 = v3 + 1;
        size_t v53 = *(void **)(a1 + 4904);
        uint64_t v54 = v53[1];
        if ((unint64_t)(v54 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_102;
        }
        char v55 = malloc(0x1000uLL);
        if (!v55) {
          goto LABEL_263;
        }
        uint64_t v54 = 0;
        *char v55 = v53;
        v55[1] = 0;
        size_t v53 = v55;
        *(void *)(a1 + 4904) = v55;
LABEL_102:
        v53[1] = v54 + 32;
        uint64_t v35 = (char *)v53 + v54;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "__float128";
        uint64_t v37 = 10;
        goto LABEL_150;
      case 'h':
        *(void *)a1 = v3 + 1;
        char v56 = *(void **)(a1 + 4904);
        uint64_t v57 = v56[1];
        if ((unint64_t)(v57 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_106;
        }
        int64_t v58 = malloc(0x1000uLL);
        if (!v58) {
          goto LABEL_263;
        }
        uint64_t v57 = 0;
        *int64_t v58 = v56;
        v58[1] = 0;
        char v56 = v58;
        *(void *)(a1 + 4904) = v58;
LABEL_106:
        v56[1] = v57 + 32;
        uint64_t v35 = (char *)v56 + v57;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned char";
        uint64_t v37 = 13;
        goto LABEL_150;
      case 'i':
        *(void *)a1 = v3 + 1;
        std::string::size_type v59 = *(void **)(a1 + 4904);
        uint64_t v60 = v59[1];
        if ((unint64_t)(v60 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_110;
        }
        unsigned int v61 = malloc(0x1000uLL);
        if (!v61) {
          goto LABEL_263;
        }
        uint64_t v60 = 0;
        *unsigned int v61 = v59;
        v61[1] = 0;
        std::string::size_type v59 = v61;
        *(void *)(a1 + 4904) = v61;
LABEL_110:
        v59[1] = v60 + 32;
        uint64_t v35 = (char *)v59 + v60;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "int";
        uint64_t v37 = 3;
        goto LABEL_150;
      case 'j':
        *(void *)a1 = v3 + 1;
        uint64_t v62 = *(void **)(a1 + 4904);
        uint64_t v63 = v62[1];
        if ((unint64_t)(v63 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_114;
        }
        char v64 = malloc(0x1000uLL);
        if (!v64) {
          goto LABEL_263;
        }
        uint64_t v63 = 0;
        *char v64 = v62;
        v64[1] = 0;
        uint64_t v62 = v64;
        *(void *)(a1 + 4904) = v64;
LABEL_114:
        v62[1] = v63 + 32;
        uint64_t v35 = (char *)v62 + v63;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned int";
        uint64_t v37 = 12;
        goto LABEL_150;
      case 'l':
        *(void *)a1 = v3 + 1;
        uint64_t v65 = *(void **)(a1 + 4904);
        uint64_t v66 = v65[1];
        if ((unint64_t)(v66 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_118;
        }
        uint64_t v67 = malloc(0x1000uLL);
        if (!v67) {
          goto LABEL_263;
        }
        uint64_t v66 = 0;
        void *v67 = v65;
        v67[1] = 0;
        uint64_t v65 = v67;
        *(void *)(a1 + 4904) = v67;
LABEL_118:
        v65[1] = v66 + 32;
        uint64_t v35 = (char *)v65 + v66;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "long";
        goto LABEL_149;
      case 'm':
        *(void *)a1 = v3 + 1;
        unint64_t v68 = *(void **)(a1 + 4904);
        uint64_t v69 = v68[1];
        if ((unint64_t)(v69 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_122;
        }
        pid_t v70 = malloc(0x1000uLL);
        if (!v70) {
          goto LABEL_263;
        }
        uint64_t v69 = 0;
        *pid_t v70 = v68;
        v70[1] = 0;
        unint64_t v68 = v70;
        *(void *)(a1 + 4904) = v70;
LABEL_122:
        v68[1] = v69 + 32;
        uint64_t v35 = (char *)v68 + v69;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned long";
        uint64_t v37 = 13;
        goto LABEL_150;
      case 'n':
        *(void *)a1 = v3 + 1;
        size_t v71 = *(void **)(a1 + 4904);
        uint64_t v72 = v71[1];
        if ((unint64_t)(v72 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_126;
        }
        uint64_t v73 = malloc(0x1000uLL);
        if (!v73) {
          goto LABEL_263;
        }
        uint64_t v72 = 0;
        *uint64_t v73 = v71;
        v73[1] = 0;
        size_t v71 = v73;
        *(void *)(a1 + 4904) = v73;
LABEL_126:
        v71[1] = v72 + 32;
        uint64_t v74 = (char *)v71 + v72;
        uint64_t v12 = (uint64_t)(v74 + 16);
        v74[24] = 8;
        *(_WORD *)(v74 + 25) = *(_WORD *)(v74 + 25) & 0xF000 | 0x540;
        *((void *)v74 + 2) = &unk_1EC9A3628;
        *((void *)v74 + 4) = "__int128";
        *((void *)v74 + 5) = 8;
        return (char *)v12;
      case 'o':
        *(void *)a1 = v3 + 1;
        size_t v75 = *(void **)(a1 + 4904);
        uint64_t v76 = v75[1];
        if ((unint64_t)(v76 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_130;
        }
        uint64_t v77 = malloc(0x1000uLL);
        if (!v77) {
          goto LABEL_263;
        }
        uint64_t v76 = 0;
        *uint64_t v77 = v75;
        v77[1] = 0;
        size_t v75 = v77;
        *(void *)(a1 + 4904) = v77;
LABEL_130:
        v75[1] = v76 + 32;
        uint64_t v35 = (char *)v75 + v76;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned __int128";
        uint64_t v37 = 17;
        goto LABEL_150;
      case 's':
        *(void *)a1 = v3 + 1;
        int v78 = *(void **)(a1 + 4904);
        uint64_t v79 = v78[1];
        if ((unint64_t)(v79 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_134;
        }
        uint64_t v80 = malloc(0x1000uLL);
        if (!v80) {
          goto LABEL_263;
        }
        uint64_t v79 = 0;
        *uint64_t v80 = v78;
        v80[1] = 0;
        int v78 = v80;
        *(void *)(a1 + 4904) = v80;
LABEL_134:
        v78[1] = v79 + 32;
        uint64_t v35 = (char *)v78 + v79;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "short";
        uint64_t v37 = 5;
        goto LABEL_150;
      case 't':
        *(void *)a1 = v3 + 1;
        uint64_t v81 = *(void **)(a1 + 4904);
        uint64_t v82 = v81[1];
        if ((unint64_t)(v82 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_138;
        }
        __n128 v83 = malloc(0x1000uLL);
        if (!v83) {
          goto LABEL_263;
        }
        uint64_t v82 = 0;
        *__n128 v83 = v81;
        v83[1] = 0;
        uint64_t v81 = v83;
        *(void *)(a1 + 4904) = v83;
LABEL_138:
        v81[1] = v82 + 32;
        uint64_t v35 = (char *)v81 + v82;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned short";
        uint64_t v37 = 14;
        goto LABEL_150;
      case 'u':
        *(void *)a1 = v3 + 1;
        if (v4 == v3 + 1 || v3[1] - 58 < 0xFFFFFFF6) {
          return 0;
        }
        unint64_t v84 = 0;
        char v85 = v3 + 2;
        unint64_t v86 = (unint64_t)(v3 + 1);
        while (1)
        {
          *(void *)a1 = v85;
          unint64_t v84 = (char)*(v85 - 1) + 10 * v84 - 48;
          if (v85 == v4) {
            break;
          }
          char v87 = v85 + 1;
          unsigned int v88 = *v85 - 48;
          ++v86;
          ++v85;
          if (v88 >= 0xA)
          {
            long long v89 = v87 - 1;
            goto LABEL_195;
          }
        }
        unint64_t v86 = (unint64_t)v4;
        long long v89 = v4;
LABEL_195:
        if ((unint64_t)&v4[-v86] < v84) {
          return 0;
        }
        unint64_t v113 = &v89[v84];
        *(void *)a1 = v113;
        v134.n128_u64[0] = v86;
        v134.n128_u64[1] = v84;
        if (!v84) {
          return 0;
        }
        if (v113 == v4 || *v113 != 73)
        {
        }
        else
        {
          *(void *)a1 = v113 + 1;
          if (!v135) {
            return 0;
          }
          char v114 = *(unsigned __int8 **)a1;
          if (*(void *)a1 == *(void *)(a1 + 8) || *v114 != 69) {
            return 0;
          }
          *(void *)a1 = v114 + 1;
        }
LABEL_50:
        uint64_t v12 = (uint64_t)v15;
        uint64_t v133 = (uint64_t)v15;
        goto LABEL_65;
      case 'v':
        *(void *)a1 = v3 + 1;
        char v90 = *(void **)(a1 + 4904);
        uint64_t v91 = v90[1];
        if ((unint64_t)(v91 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_148;
        }
        uint64_t v92 = malloc(0x1000uLL);
        if (!v92) {
          goto LABEL_263;
        }
        uint64_t v91 = 0;
        void *v92 = v90;
        v92[1] = 0;
        char v90 = v92;
        *(void *)(a1 + 4904) = v92;
LABEL_148:
        v90[1] = v91 + 32;
        uint64_t v35 = (char *)v90 + v91;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "void";
LABEL_149:
        uint64_t v37 = 4;
        goto LABEL_150;
      case 'w':
        *(void *)a1 = v3 + 1;
        int v94 = *(void **)(a1 + 4904);
        uint64_t v95 = v94[1];
        if ((unint64_t)(v95 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_155;
        }
        long long v96 = malloc(0x1000uLL);
        if (!v96) {
          goto LABEL_263;
        }
        uint64_t v95 = 0;
        *long long v96 = v94;
        v96[1] = 0;
        int v94 = v96;
        *(void *)(a1 + 4904) = v96;
LABEL_155:
        v94[1] = v95 + 32;
        uint64_t v35 = (char *)v94 + v95;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "wchar_t";
        uint64_t v37 = 7;
        goto LABEL_150;
      case 'x':
        *(void *)a1 = v3 + 1;
        uint64_t v97 = *(void **)(a1 + 4904);
        uint64_t v98 = v97[1];
        if ((unint64_t)(v98 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_159;
        }
        std::string v99 = malloc(0x1000uLL);
        if (!v99) {
          goto LABEL_263;
        }
        uint64_t v98 = 0;
        *std::string v99 = v97;
        v99[1] = 0;
        uint64_t v97 = v99;
        *(void *)(a1 + 4904) = v99;
LABEL_159:
        v97[1] = v98 + 32;
        uint64_t v35 = (char *)v97 + v98;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "long long";
        uint64_t v37 = 9;
        goto LABEL_150;
      case 'y':
        *(void *)a1 = v3 + 1;
        uint64_t v100 = *(void **)(a1 + 4904);
        uint64_t v101 = v100[1];
        if ((unint64_t)(v101 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_163;
        }
        char v102 = malloc(0x1000uLL);
        if (!v102) {
          goto LABEL_263;
        }
        uint64_t v101 = 0;
        *char v102 = v100;
        v102[1] = 0;
        uint64_t v100 = v102;
        *(void *)(a1 + 4904) = v102;
LABEL_163:
        v100[1] = v101 + 32;
        uint64_t v35 = (char *)v100 + v101;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "unsigned long long";
        uint64_t v37 = 18;
        goto LABEL_150;
      case 'z':
        *(void *)a1 = v3 + 1;
        uint64_t v103 = *(void **)(a1 + 4904);
        uint64_t v104 = v103[1];
        if ((unint64_t)(v104 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_167;
        }
        char v105 = malloc(0x1000uLL);
        if (!v105) {
LABEL_263:
        }
          std::terminate();
        uint64_t v104 = 0;
        *char v105 = v103;
        v105[1] = 0;
        uint64_t v103 = v105;
        *(void *)(a1 + 4904) = v105;
LABEL_167:
        v103[1] = v104 + 32;
        uint64_t v35 = (char *)v103 + v104;
        uint64_t v12 = (uint64_t)(v35 + 16);
        v35[24] = 8;
        *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
        *((void *)v35 + 2) = &unk_1EC9A3628;
        intptr_t v36 = "...";
        uint64_t v37 = 3;
LABEL_150:
        *((void *)v35 + 4) = v36;
        *((void *)v35 + 5) = v37;
        return (char *)v12;
      default:
        break;
    }
  }
  uint64_t v133 = v12;
  if (v12) {
    goto LABEL_65;
  }
  return (char *)v12;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::SaveTemplateParams::SaveTemplateParams(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v4 = a1 + 32;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 32;
  *(_OWORD *)(a1 + 88) = 0u;
  unint64_t v5 = (char *)(a1 + 88);
  *(void *)(a1 + 64) = a1 + 88;
  int v6 = (void **)(a1 + 64);
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = a1 + 64;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v7 = a1 + 152;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = a1 + 152;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  unint64_t v8 = *(unsigned char **)(a2 + 664);
  uint64_t v9 = a2 + 688;
  if (v8 == (unsigned char *)(a2 + 688))
  {
    uint64_t v15 = *(unsigned char **)(a2 + 672);
    if (v15 == v8)
    {
      int v16 = v8;
    }
    else
    {
      memmove((void *)(a1 + 32), v8, v15 - v8);
      int v16 = *(unsigned char **)(a2 + 672);
      unint64_t v8 = *(unsigned char **)(a2 + 664);
    }
    *(void *)(a1 + 16) = v4 + v16 - v8;
    *(void *)(a2 + 672) = v8;
    unint64_t v10 = *(unsigned char **)(a2 + 576);
    uint64_t v11 = a2 + 600;
    uint64_t v12 = (char *)*v6;
    if (v10 != (unsigned char *)(a2 + 600)) {
      goto LABEL_3;
    }
  }
  else
  {
    *(void *)(a1 + 8) = v8;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 672);
    *(void *)(a2 + 664) = v9;
    *(void *)(a2 + 672) = v9;
    *(void *)(a2 + 680) = a2 + 720;
    unint64_t v10 = *(unsigned char **)(a2 + 576);
    uint64_t v11 = a2 + 600;
    uint64_t v12 = (char *)*v6;
    if (v10 != (unsigned char *)(a2 + 600))
    {
LABEL_3:
      void *v6 = v10;
      if (v12 == v5)
      {
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 584);
        *(void *)(a2 + 576) = v11;
        *(void *)(a2 + 584) = v11;
        *(void *)(a2 + 592) = a2 + 664;
      }
      else
      {
        *(void *)(a2 + 576) = v12;
        uint64_t v13 = *(void *)(a1 + 72);
        *(void *)(a1 + 72) = *(void *)(a2 + 584);
        *(void *)(a2 + 584) = v13;
        uint64_t v14 = *(void *)(a1 + 80);
        *(void *)(a1 + 80) = *(void *)(a2 + 592);
        *(void *)(a2 + 592) = v14;
        *(void *)(a2 + 584) = *(void *)(a2 + 576);
      }
      goto LABEL_16;
    }
  }
  if (v12 != v5)
  {
    free(v12);
    *(void *)(a1 + 64) = v5;
    *(void *)(a1 + 72) = v5;
    *(void *)(a1 + 80) = v7;
    unint64_t v10 = *(unsigned char **)(a2 + 576);
  }
  char v17 = *(unsigned char **)(a2 + 584);
  if (v17 == v10)
  {
    unint64_t v18 = v10;
  }
  else
  {
    memmove(v5, v10, v17 - v10);
    unint64_t v18 = *(unsigned char **)(a2 + 584);
    unint64_t v10 = *(unsigned char **)(a2 + 576);
  }
  *(void *)(a1 + 72) = &v5[v18 - v10];
  *(void *)(a2 + 584) = v10;
LABEL_16:
  uint64_t v19 = *(void **)a1;
  v19[84] = *(void *)(*(void *)a1 + 664);
  v19[73] = v19[72];
  return a1;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseName(uint64_t a1, size_t a2)
{
  unint64_t v5 = *(const char **)a1;
  uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  if (v4 == *(unsigned __int8 **)a1)
  {
LABEL_13:
    LOBYTE(v53[0]) = 0;
    if (!v9) {
      return v9;
    }
    if (*(void *)(a1 + 8) == *(void *)a1 || **(unsigned char **)a1 != 73)
    {
      if (!LOBYTE(v53[0])) {
        return v9;
      }
      return 0;
    }
    if (!LOBYTE(v53[0]))
    {
      unint64_t v10 = *(char **)(a1 + 304);
      if (v10 == *(char **)(a1 + 312))
      {
        uint64_t v11 = *(unsigned char **)(a1 + 296);
        int64_t v12 = v10 - v11;
        if (v11 == (unsigned char *)(a1 + 320))
        {
          uint64_t v44 = (char *)malloc(2 * (v10 - v11));
          if (!v44) {
            goto LABEL_123;
          }
          uint64_t v13 = v44;
          if (v10 != (char *)(a1 + 320)) {
            memcpy(v44, (const void *)(a1 + 320), v12);
          }
          *(void *)(a1 + 296) = v13;
        }
        else
        {
          uint64_t v13 = (char *)realloc(v11, 2 * (v10 - v11));
          *(void *)(a1 + 296) = v13;
          if (!v13) {
LABEL_123:
          }
            abort();
        }
        unint64_t v10 = &v13[8 * (v12 >> 3)];
        *(void *)(a1 + 312) = &v13[8 * (v12 >> 2)];
      }
      *(void *)(a1 + 304) = v10 + 8;
      *(void *)unint64_t v10 = v9;
    }
    if (!v45) {
      return 0;
    }
    uint64_t v46 = v45;
    if (a2) {
      *(unsigned char *)(a2 + 1) = 1;
    }
    size_t v47 = *(void **)(a1 + 4904);
    uint64_t v48 = v47[1];
    if ((unint64_t)(v48 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      int v49 = malloc(0x1000uLL);
      if (!v49) {
LABEL_124:
      }
        std::terminate();
      uint64_t v48 = 0;
      *int v49 = v47;
      v49[1] = 0;
      size_t v47 = v49;
      *(void *)(a1 + 4904) = v49;
    }
    v47[1] = v48 + 32;
    unsigned int v50 = (char *)v47 + v48;
    v50[24] = 45;
    *(_WORD *)(v50 + 25) = *(_WORD *)(v50 + 25) & 0xF000 | 0x540;
    *((void *)v50 + 2) = &unk_1EC9A2DE8;
    *((void *)v50 + 4) = v9;
    *((void *)v50 + 5) = v46;
    return v50 + 16;
  }
  int v6 = *(unsigned __int8 *)v5;
  if (v6 == 90)
  {
    *(void *)a1 = v5 + 1;
    if (!v54[0]) {
      return 0;
    }
    int v16 = *(const char **)a1;
    uint64_t v15 = *(const char **)(a1 + 8);
    if (*(const char **)a1 == v15 || *v16 != 69) {
      return 0;
    }
    *(void *)a1 = v16 + 1;
    if (v16 + 1 != v15 && v16[1] == 115)
    {
      *(void *)a1 = v16 + 2;
      *(void *)a1 = llvm::itanium_demangle::parse_discriminator(v16 + 2, v15, v14);
    }
    char v41 = *(const char **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *v41 != 100)
    {
      if (!v52)
      {
LABEL_106:
        uint64_t v9 = 0;
        goto LABEL_107;
      }
      *(void *)a1 = llvm::itanium_demangle::parse_discriminator(*(const char **)a1, *(const char **)(a1 + 8), v43);
    }
    else
    {
      *(void *)a1 = v41 + 1;
      uint64_t v42 = *(const char **)a1;
      if (*(void *)a1 == *(void *)(a1 + 8)) {
        goto LABEL_106;
      }
      if (*v42 != 95) {
        goto LABEL_106;
      }
      *(void *)a1 = v42 + 1;
      if (!v52) {
        goto LABEL_106;
      }
    }
LABEL_107:
    return v9;
  }
  if (v6 != 78) {
    goto LABEL_13;
  }
  uint64_t v7 = (unsigned __int8 *)(v5 + 1);
  *(void *)a1 = v5 + 1;
  if (v5 + 1 == (const char *)v4)
  {
    int v8 = 0;
    uint64_t v7 = v4;
    if (!a2) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  if (*v7 != 114)
  {
    int v8 = 0;
    if (v7 != v4) {
      goto LABEL_7;
    }
LABEL_32:
    uint64_t v7 = v4;
    goto LABEL_33;
  }
  uint64_t v7 = (unsigned __int8 *)(v5 + 2);
  *(void *)a1 = v5 + 2;
  int v8 = 4;
  if (v7 == v4) {
    goto LABEL_32;
  }
LABEL_7:
  if (*v7 == 86)
  {
    *(void *)a1 = ++v7;
    v8 |= 2u;
  }
  if (v7 == v4)
  {
    uint64_t v7 = v4;
    if (!a2) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  if (*v7 == 75)
  {
    *(void *)a1 = ++v7;
    v8 |= 1u;
    if (!a2) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
LABEL_33:
  if (a2) {
LABEL_34:
  }
    *(_DWORD *)(a2 + 4) = v8;
LABEL_35:
  if (v7 == v4) {
    goto LABEL_40;
  }
  int v17 = *v7;
  if (v17 == 82)
  {
    *(void *)a1 = ++v7;
    if (a2)
    {
      char v18 = 1;
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  if (v17 != 79)
  {
LABEL_40:
    if (a2)
    {
      char v18 = 0;
      goto LABEL_44;
    }
  }
  else
  {
    *(void *)a1 = ++v7;
    if (a2)
    {
      char v18 = 2;
LABEL_44:
      *(unsigned char *)(a2 + 8) = v18;
    }
  }
LABEL_45:
  uint64_t v9 = 0;
  uint64_t v19 = (char *)(a1 + 320);
  while (v7 == v4 || *v7 != 69)
  {
    if (a2) {
      *(unsigned char *)(a2 + 1) = 0;
    }
    uint64_t v20 = 0;
    unint64_t v21 = v4 - v7;
    if (v21)
    {
      switch(*v7)
      {
        case 'D':
          if (v21 < 2 || (v7[1] | 0x20) != 0x74)
          {
            uint64_t v20 = 0;
            goto LABEL_78;
          }
          if (v9) {
            return 0;
          }
          goto LABEL_79;
        case 'I':
          if (!v9) {
            return v9;
          }
          if (!v23 || v9[8] == 45) {
            return 0;
          }
          uint64_t v24 = v23;
          if (a2) {
            *(unsigned char *)(a2 + 1) = 1;
          }
          unint64_t v25 = *(void **)(a1 + 4904);
          uint64_t v26 = v25[1];
          if ((unint64_t)(v26 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
            goto LABEL_64;
          }
          uint64_t v27 = malloc(0x1000uLL);
          if (!v27) {
            goto LABEL_124;
          }
          uint64_t v26 = 0;
          *uint64_t v27 = v25;
          v27[1] = 0;
          unint64_t v25 = v27;
          *(void *)(a1 + 4904) = v27;
LABEL_64:
          v25[1] = v26 + 32;
          uint64_t v28 = (char *)v25 + v26;
          v28[24] = 45;
          *(_WORD *)(v28 + 25) = *(_WORD *)(v28 + 25) & 0xF000 | 0x540;
          *((void *)v28 + 2) = &unk_1EC9A2DE8;
          *((void *)v28 + 4) = v9;
          *((void *)v28 + 5) = v24;
          uint64_t v9 = v28 + 16;
          goto LABEL_80;
        case 'S':
          if (v21 >= 2 && v7[1] == 116)
          {
            *(void *)a1 = v7 + 2;
            char v29 = *(void **)(a1 + 4904);
            uint64_t v30 = v29[1];
            if ((unint64_t)(v30 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
            {
              uint64_t v31 = malloc(0x1000uLL);
              if (!v31) {
                goto LABEL_124;
              }
              uint64_t v30 = 0;
              *uint64_t v31 = v29;
              v31[1] = 0;
              char v29 = v31;
              *(void *)(a1 + 4904) = v31;
            }
            v29[1] = v30 + 32;
            int v32 = (char *)v29 + v30;
            uint64_t v20 = (uint64_t)(v32 + 16);
            v32[24] = 8;
            *(_WORD *)(v32 + 25) = *(_WORD *)(v32 + 25) & 0xF000 | 0x540;
            *((void *)v32 + 2) = &unk_1EC9A3628;
            *((void *)v32 + 4) = "std";
            *((void *)v32 + 5) = 3;
          }
          else
          {
            if (!v33) {
              return 0;
            }
            uint64_t v20 = (uint64_t)v33;
            if (v33[8] == 27) {
              goto LABEL_78;
            }
          }
          if (v9) {
            return 0;
          }
          uint64_t v7 = *(unsigned __int8 **)a1;
          uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
          uint64_t v9 = (char *)v20;
          break;
        case 'T':
          if (v9) {
            return 0;
          }
          goto LABEL_79;
        default:
          goto LABEL_78;
      }
    }
    else
    {
LABEL_78:
LABEL_79:
      uint64_t v9 = (char *)v22;
      if (!v22) {
        return v9;
      }
LABEL_80:
      unsigned int v34 = *(char **)(a1 + 304);
      if (v34 == *(char **)(a1 + 312))
      {
        uint64_t v35 = *(char **)(a1 + 296);
        int64_t v36 = v34 - v35;
        if (v35 == v19)
        {
          uint64_t v38 = (char *)malloc(2 * (v34 - v35));
          if (!v38) {
            goto LABEL_123;
          }
          uint64_t v37 = v38;
          if (v34 != v19) {
            memcpy(v38, (const void *)(a1 + 320), v36);
          }
          *(void *)(a1 + 296) = v37;
        }
        else
        {
          uint64_t v37 = (char *)realloc(v35, 2 * (v34 - v35));
          *(void *)(a1 + 296) = v37;
          if (!v37) {
            goto LABEL_123;
          }
        }
        unsigned int v34 = &v37[8 * (v36 >> 3)];
        *(void *)(a1 + 312) = &v37[8 * (v36 >> 2)];
      }
      *(void *)(a1 + 304) = v34 + 8;
      *(void *)unsigned int v34 = v9;
      uint64_t v7 = *(unsigned __int8 **)a1;
      uint64_t v39 = *(unsigned __int8 **)(a1 + 8);
      uint64_t v4 = *(unsigned __int8 **)a1;
      if (*(unsigned __int8 **)a1 != v39)
      {
        uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
        if (*v7 == 77)
        {
          *(void *)a1 = ++v7;
          uint64_t v4 = v39;
        }
      }
    }
  }
  *(void *)a1 = v7 + 1;
  if (v9)
  {
    uint64_t v40 = *(void *)(a1 + 304);
    if (*(void *)(a1 + 296) != v40)
    {
      *(void *)(a1 + 304) = v40 - 8;
      return v9;
    }
    return 0;
  }
  return v9;
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseTemplateArg(void *a1)
{
  size_t v2 = (char *)*a1;
  uint64_t v3 = (unsigned __int8 *)a1[1];
  unint64_t v4 = (unint64_t)&v3[-*a1];
  if (v3 == (unsigned __int8 *)*a1)
  {
    unsigned int v5 = 2147483611;
  }
  else
  {
    HIDWORD(v6) = *v2;
    LODWORD(v6) = *v2 - 74;
    unsigned int v5 = v6 >> 1;
    if (v5 > 7)
    {
LABEL_52:
      return;
    }
  }
  switch(v5)
  {
    case 0u:
      uint64_t v7 = v2 + 1;
      *a1 = v7;
      uint64_t v8 = (uint64_t)(a1[3] - a1[2]) >> 3;
      uint64_t v9 = (char *)(a1 + 5);
      break;
    case 1u:
      if (v4 >= 2 && v2[1] == 90)
      {
        *a1 = v2 + 2;
        {
          int v17 = (char *)*a1;
          if (*a1 != a1[1] && *v17 == 69) {
LABEL_32:
          }
            *a1 = v17 + 1;
        }
      }
      else
      {
      }
      return;
    case 5u:
      if (v3 == (unsigned __int8 *)v2 || *v2 != 84) {
        goto LABEL_52;
      }
      int v18 = v4 < 2 ? 0 : v2[1];
      uint64_t v27 = memchr("yptnk", v18, 5uLL);
      if (!v27 || v27 - "yptnk" == -1) {
        goto LABEL_52;
      }
      if (!v28) {
        return;
      }
      uint64_t v19 = v28;
      if (!v29) {
        return;
      }
      uint64_t v21 = v29;
      uint64_t v30 = (void *)a1[613];
      uint64_t v31 = v30[1];
      if ((unint64_t)(v31 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
        goto LABEL_51;
      }
      int v32 = malloc(0x1000uLL);
      if (!v32) {
        goto LABEL_56;
      }
      uint64_t v31 = 0;
      *int v32 = v30;
      v32[1] = 0;
      uint64_t v30 = v32;
      a1[613] = v32;
LABEL_51:
      v30[1] = v31 + 32;
      unint64_t v25 = (char *)v30 + v31;
      v25[24] = 34;
      *(_WORD *)(v25 + 25) = *(_WORD *)(v25 + 25) & 0xF000 | 0x540;
      uint64_t v26 = &unk_1EC9A3208;
      goto LABEL_42;
    case 7u:
      *a1 = v2 + 1;
      {
        int v17 = (char *)*a1;
        if (*a1 != a1[1] && *v17 == 69) {
          goto LABEL_32;
        }
      }
      return;
    default:
      goto LABEL_52;
  }
  while (v7 == (char *)v3 || *v7 != 69)
  {
    if (!v12) {
      return;
    }
    uint64_t v13 = v12;
    uint64_t v11 = (char *)a1[3];
    if (v11 == (char *)a1[4])
    {
      uint64_t v14 = (char *)a1[2];
      int64_t v15 = v11 - v14;
      if (v14 == v9)
      {
        int v16 = (char *)malloc(2 * (v11 - v14));
        if (!v16) {
LABEL_55:
        }
          abort();
        unint64_t v10 = v16;
        if (v11 != v9) {
          memcpy(v16, a1 + 5, v15);
        }
        a1[2] = v10;
      }
      else
      {
        unint64_t v10 = (char *)realloc(v14, 2 * (v11 - v14));
        a1[2] = v10;
        if (!v10) {
          goto LABEL_55;
        }
      }
      uint64_t v11 = &v10[8 * (v15 >> 3)];
      a1[4] = &v10[8 * (v15 >> 2)];
    }
    a1[3] = v11 + 8;
    *(void *)uint64_t v11 = v13;
    uint64_t v7 = (char *)*a1;
    uint64_t v3 = (unsigned __int8 *)a1[1];
  }
  *a1 = v7 + 1;
  uint64_t v21 = v20;
  uint64_t v22 = (void *)a1[613];
  uint64_t v23 = v22[1];
  if ((unint64_t)(v23 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v24 = malloc(0x1000uLL);
    if (!v24) {
LABEL_56:
    }
      std::terminate();
    uint64_t v23 = 0;
    *uint64_t v24 = v22;
    v24[1] = 0;
    uint64_t v22 = v24;
    a1[613] = v24;
  }
  v22[1] = v23 + 32;
  unint64_t v25 = (char *)v22 + v23;
  v25[24] = 41;
  *(_WORD *)(v25 + 25) = *(_WORD *)(v25 + 25) & 0xF000 | 0x540;
  uint64_t v26 = &unk_1EC9A2E98;
LABEL_42:
  *((void *)v25 + 2) = v26;
  *((void *)v25 + 4) = v19;
  *((void *)v25 + 5) = v21;
}

void *llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back(void *result, uint64_t *__size)
{
  uint64_t v3 = result;
  unint64_t v4 = (void *)result[1];
  if (v4 == (void *)result[2])
  {
    unsigned int v5 = (void *)*result;
    int64_t v6 = (int64_t)v4 - *result;
    if ((void *)*result == result + 3)
    {
      uint64_t result = malloc(2 * v6);
      if (!result) {
        goto LABEL_11;
      }
      uint64_t v7 = result;
      if (v4 != v5) {
        uint64_t result = memmove(result, v5, v6);
      }
      void *v3 = v7;
    }
    else
    {
      uint64_t result = realloc((void *)*result, 2 * v6);
      uint64_t v7 = result;
      void *v3 = result;
      if (!result) {
LABEL_11:
      }
        abort();
    }
    unint64_t v4 = &v7[v6 >> 3];
    v3[1] = v4;
    void v3[2] = &v7[v6 >> 2];
  }
  uint64_t v8 = *__size;
  v3[1] = v4 + 1;
  *unint64_t v4 = v8;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::EnableIfAttr,llvm::itanium_demangle::NodeArray>(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  v7[24] = 10;
  __int16 v8 = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2028;
  __n128 result = *a2;
  *(_WORD *)(v7 + 25) = v8;
  *((__n128 *)v7 + 2) = result;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::popTrailingNodeArray(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  unsigned int v5 = (unsigned char *)a1[3];
  int64_t v6 = (unsigned char *)(v4 + 8 * a2);
  unint64_t v7 = (v5 - v6 + 15) & 0xFFFFFFF0;
  __int16 v8 = (void *)a1[613];
  uint64_t v9 = v8[1];
  if (v7 + v9 >= 0xFF0)
  {
    if (v7 >= 0xFF1)
    {
      unint64_t v10 = malloc(v7 + 16);
      if (v10)
      {
        *unint64_t v10 = *v8;
        v10[1] = 0;
        void *v8 = v10;
        uint64_t v11 = (char *)(v10 + 2);
        if (v5 == v6) {
          goto LABEL_10;
        }
        goto LABEL_9;
      }
LABEL_11:
      std::terminate();
    }
    uint64_t v12 = malloc(0x1000uLL);
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v9 = 0;
    *uint64_t v12 = v8;
    v12[1] = 0;
    __int16 v8 = v12;
    a1[613] = v12;
  }
  v8[1] = v9 + v7;
  uint64_t v11 = (char *)v8 + v9 + 16;
  if (v5 != v6)
  {
LABEL_9:
    memmove(v11, v6, v5 - v6);
    uint64_t v4 = a1[2];
  }
LABEL_10:
  a1[3] = v4 + 8 * a2;
  return v11;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::FunctionEncoding,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Qualifiers &,llvm::itanium_demangle::FunctionRefQual &>(uint64_t a1, uint64_t *a2, uint64_t *a3, __n128 *a4, uint64_t *a5, uint64_t *a6, int a7, char a8)
{
  int64_t v15 = *(void **)(a1 + 4904);
  uint64_t v16 = v15[1];
  if ((unint64_t)(v16 - 4000) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int v18 = malloc(0x1000uLL);
    if (!v18) {
      std::terminate();
    }
    uint64_t v16 = 0;
    *int v18 = v15;
    v18[1] = 0;
    int64_t v15 = v18;
    *(void *)(a1 + 4904) = v18;
  }
  v15[1] = v16 + 80;
  uint64_t v19 = (char *)v15 + v16;
  uint64_t v20 = *a2;
  uint64_t v21 = *a3;
  uint64_t v22 = *a5;
  uint64_t v23 = *a6;
  unsigned char v19[24] = 19;
  __int16 v24 = *(_WORD *)(v19 + 25) & 0xF000 | 0x100;
  *((void *)v19 + 2) = &unk_1EC9A2A78;
  __n128 result = *a4;
  *(_WORD *)(v19 + 25) = v24;
  *((void *)v19 + 4) = v20;
  *((void *)v19 + 5) = v21;
  *((__n128 *)v19 + 3) = result;
  *((void *)v19 + 8) = v22;
  *((void *)v19 + 9) = v23;
  *((_DWORD *)v19 + 20) = a7;
  v19[84] = a8;
  return result;
}

void *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::SaveTemplateParams::~SaveTemplateParams(void *a1)
{
  uint64_t v3 = (void *)*a1;
  size_t v2 = (void *)a1[1];
  uint64_t v4 = a1 + 4;
  unsigned int v5 = *(void **)(*a1 + 664);
  int64_t v6 = v3 + 86;
  if (v2 == v4)
  {
    if (v5 != v6)
    {
      free(v5);
      v3[83] = v6;
      v3[84] = v6;
      v3[85] = v3 + 90;
      size_t v2 = (void *)a1[1];
    }
    uint64_t v9 = (unsigned char *)a1[2];
    if (v9 == (unsigned char *)v2)
    {
      unint64_t v10 = v2;
    }
    else
    {
      memmove(v3 + 86, v2, v9 - (unsigned char *)v2);
      size_t v2 = (void *)a1[1];
      unint64_t v10 = (unsigned char *)a1[2];
    }
    v3[84] = (char *)v6 + v10 - (unsigned char *)v2;
    a1[2] = v2;
  }
  else
  {
    v3[83] = v2;
    if (v5 == v6)
    {
      *((_OWORD *)v3 + 42) = *((_OWORD *)a1 + 1);
      a1[1] = v4;
      a1[2] = v4;
      a1[3] = a1 + 8;
    }
    else
    {
      a1[1] = v5;
      uint64_t v7 = v3[84];
      v3[84] = a1[2];
      a1[2] = v7;
      uint64_t v8 = v3[85];
      v3[85] = a1[3];
      a1[2] = a1[1];
      a1[3] = v8;
    }
  }
  uint64_t v11 = (void *)*a1;
  uint64_t v12 = (char *)a1[8];
  uint64_t v13 = (char *)(a1 + 11);
  uint64_t v14 = *(char **)(*a1 + 576);
  int64_t v15 = (char *)(*a1 + 600);
  if (v12 == (char *)(a1 + 11))
  {
    if (v14 != v15)
    {
      free(v14);
      v11[72] = v15;
      v11[73] = v15;
      v11[74] = v11 + 83;
      uint64_t v12 = (char *)a1[8];
    }
    int v18 = (char *)a1[9];
    if (v18 == v12)
    {
      uint64_t v19 = v12;
    }
    else
    {
      memmove(v15, v12, v18 - v12);
      uint64_t v12 = (char *)a1[8];
      uint64_t v19 = (char *)a1[9];
    }
    v11[73] = &v15[v19 - v12];
    a1[9] = v12;
    if (v12 == v13) {
      goto LABEL_23;
    }
LABEL_22:
    free(v12);
    goto LABEL_23;
  }
  v11[72] = v12;
  if (v14 == v15)
  {
    *(_OWORD *)(v11 + 73) = *(_OWORD *)(a1 + 9);
    a1[8] = v13;
    a1[9] = v13;
    a1[10] = a1 + 19;
    goto LABEL_23;
  }
  a1[8] = v14;
  uint64_t v16 = v11[73];
  v11[73] = a1[9];
  a1[9] = v16;
  uint64_t v17 = v11[74];
  v11[74] = a1[10];
  uint64_t v12 = (char *)a1[8];
  a1[9] = v12;
  a1[10] = v17;
  if (v12 != v13) {
    goto LABEL_22;
  }
LABEL_23:
  uint64_t v20 = (void *)a1[1];
  if (v20 != v4) {
    free(v20);
  }
  return a1;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[31],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "template parameter object for ";
  *((void *)v7 + 5) = 30;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[12],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "vtable for ";
  *((void *)v7 + 5) = 11;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[9],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "VTT for ";
  *((void *)v7 + 5) = 8;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[14],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "typeinfo for ";
  *((void *)v7 + 5) = 13;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[19],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "typeinfo name for ";
  *((void *)v7 + 5) = 18;
  *((void *)v7 + 6) = v9;
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseCallOffset(unsigned __int8 **a1)
{
  size_t v1 = *a1;
  size_t v2 = a1[1];
  if (*a1 == v2) {
    return 1;
  }
  int v3 = *v1;
  if (v3 == 118)
  {
    uint64_t v8 = v1 + 1;
    *a1 = v1 + 1;
    if (v1 + 1 != v2)
    {
      uint64_t v9 = v1 + 1;
      if (*v8 == 110)
      {
        uint64_t v9 = v1 + 2;
        *a1 = v1 + 2;
      }
      if (v2 != v9 && ((char)*v9 & 0x80000000) == 0)
      {
        uint64_t v10 = MEMORY[0x1E4F14390];
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v9 + 60) & 0x400) != 0)
        {
          while (((char)*v9 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 4 * *v9 + 60) & 0x400) != 0)
          {
            *a1 = ++v9;
            if (v9 == v2)
            {
              uint64_t v9 = v2;
              break;
            }
          }
          uint64_t v7 = 1;
          if (v9 == v8 || v9 == v2) {
            return v7;
          }
          if (*v9 == 95)
          {
            uint64_t v11 = v9 + 1;
            *a1 = v9 + 1;
            if (v9 + 1 != v2)
            {
              unsigned int v5 = v9 + 1;
              if (*v11 == 110)
              {
                unsigned int v5 = v9 + 2;
                *a1 = v9 + 2;
              }
              if (v2 != v5 && ((char)*v5 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 4 * *v5 + 60) & 0x400) != 0)
              {
                while (((char)*v5 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 4 * *v5 + 60) & 0x400) != 0)
                {
                  *a1 = ++v5;
                  if (v5 == v2)
                  {
                    unsigned int v5 = v2;
                    break;
                  }
                }
                uint64_t v7 = 1;
                if (v5 == v11 || v5 == v2) {
                  return v7;
                }
                if (*v5 == 95) {
                  goto LABEL_17;
                }
              }
            }
          }
        }
      }
    }
    return 1;
  }
  if (v3 != 104) {
    return 1;
  }
  uint64_t v4 = v1 + 1;
  *a1 = v1 + 1;
  if (v1 + 1 == v2) {
    return 1;
  }
  unsigned int v5 = v1 + 1;
  if (*v4 == 110)
  {
    unsigned int v5 = v1 + 2;
    *a1 = v1 + 2;
  }
  if (v2 == v5) {
    return 1;
  }
  if ((char)*v5 < 0) {
    return 1;
  }
  uint64_t v6 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v5 + 60) & 0x400) == 0) {
    return 1;
  }
  while (((char)*v5 & 0x80000000) == 0 && (*(_DWORD *)(v6 + 4 * *v5 + 60) & 0x400) != 0)
  {
    *a1 = ++v5;
    if (v5 == v2)
    {
      unsigned int v5 = v2;
      break;
    }
  }
  uint64_t v7 = 1;
  if (v5 == v4 || v5 == v2) {
    return v7;
  }
  if (*v5 != 95) {
    return 1;
  }
LABEL_17:
  uint64_t v7 = 0;
  *a1 = v5 + 1;
  return v7;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[27],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "covariant return thunk to ";
  *((void *)v7 + 5) = 26;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::CtorVtableSpecialName,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    unsigned int v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  uint64_t v9 = (char *)v5 + v6;
  __n128 result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  v9[24] = 22;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A2EF0;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[41],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "thread-local initialization routine for ";
  *((void *)v7 + 5) = 40;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[18],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "virtual thunk to ";
  *((void *)v7 + 5) = 17;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[22],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "non-virtual thunk to ";
  *((void *)v7 + 5) = 21;
  *((void *)v7 + 6) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SpecialName,char const(&)[25],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 21;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F20;
  *((void *)v7 + 4) = "reference temporary for ";
  *((void *)v7 + 5) = 24;
  *((void *)v7 + 6) = v9;
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseModuleNameOpt(uint64_t a1, uint64_t *a2)
{
  size_t v2 = *(unsigned __int8 **)a1;
  int v3 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 != v3)
  {
    uint64_t v6 = (char *)(a1 + 320);
    while (*v2 == 87)
    {
      *(void *)a1 = v2 + 1;
      if (v2 + 1 == v3 || v2[1] != 80)
      {
        char v11 = 0;
        if (!v12) {
          return 1;
        }
      }
      else
      {
        *(void *)a1 = v2 + 2;
        char v11 = 1;
        if (!v12) {
          return 1;
        }
      }
      uint64_t v13 = v12;
      uint64_t v14 = *(void **)(a1 + 4904);
      uint64_t v15 = v14[1];
      if ((unint64_t)(v15 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v16 = malloc(0x1000uLL);
        if (!v16) {
          std::terminate();
        }
        uint64_t v15 = 0;
        *uint64_t v16 = v14;
        v16[1] = 0;
        uint64_t v14 = v16;
        *(void *)(a1 + 4904) = v16;
      }
      v14[1] = v15 + 48;
      uint64_t v7 = (char *)v14 + v15;
      uint64_t v8 = v7 + 16;
      uint64_t v9 = *a2;
      v7[24] = 27;
      *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
      *((void *)v7 + 2) = &unk_1EC9A1CB8;
      *((void *)v7 + 4) = v9;
      *((void *)v7 + 5) = v13;
      v7[48] = v11;
      *a2 = (uint64_t)(v7 + 16);
      uint64_t v10 = *(char **)(a1 + 304);
      if (v10 == *(char **)(a1 + 312))
      {
        uint64_t v17 = *(char **)(a1 + 296);
        int64_t v18 = v10 - v17;
        if (v17 == v6)
        {
          uint64_t v20 = (char *)malloc(2 * (v10 - v17));
          if (!v20) {
LABEL_25:
          }
            abort();
          uint64_t v19 = v20;
          if (v10 != v6) {
            memcpy(v20, v6, v18);
          }
          *(void *)(a1 + 296) = v19;
        }
        else
        {
          uint64_t v19 = (char *)realloc(v17, 2 * (v10 - v17));
          *(void *)(a1 + 296) = v19;
          if (!v19) {
            goto LABEL_25;
          }
        }
        uint64_t v21 = &v19[8 * (v18 >> 3)];
        *(void *)(a1 + 304) = v21 + 8;
        *(void *)(a1 + 312) = &v19[8 * (v18 >> 2)];
        *(void *)uint64_t v21 = v8;
        size_t v2 = *(unsigned __int8 **)a1;
        int v3 = *(unsigned __int8 **)(a1 + 8);
        if (*(unsigned __int8 **)a1 == v3) {
          return 0;
        }
      }
      else
      {
        *(void *)(a1 + 304) = v10 + 8;
        *(void *)uint64_t v10 = v8;
        size_t v2 = *(unsigned __int8 **)a1;
        int v3 = *(unsigned __int8 **)(a1 + 8);
        if (*(unsigned __int8 **)a1 == v3) {
          return 0;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::itanium_demangle::Node::hasRHSComponentSlow()
{
  return 0;
}

uint64_t llvm::itanium_demangle::Node::hasArraySlow()
{
  return 0;
}

uint64_t llvm::itanium_demangle::Node::hasFunctionSlow()
{
  return 0;
}

uint64_t llvm::itanium_demangle::SpecialName::printLeft(void *a1, char **a2)
{
  size_t v4 = a1[3];
  if (v4)
  {
    unsigned int v5 = (const void *)a1[2];
    uint64_t v6 = *a2;
    uint64_t v7 = a2[1];
    uint64_t v8 = &v7[v4];
    size_t v9 = (size_t)a2[2];
    if ((unint64_t)&v7[v4] > v9)
    {
      unint64_t v10 = 2 * v9;
      if (v10 <= (unint64_t)(v8 + 992)) {
        size_t v11 = (size_t)(v8 + 992);
      }
      else {
        size_t v11 = v10;
      }
      a2[2] = (char *)v11;
      uint64_t v6 = (char *)realloc(v6, v11);
      *a2 = v6;
      if (!v6) {
        abort();
      }
      uint64_t v7 = a2[1];
    }
    memcpy(&v7[(void)v6], v5, v4);
    a2[1] += v4;
  }
  uint64_t v12 = a1[4];
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v12 + 32))(v12, a2);
  if ((*(_WORD *)(v12 + 9) & 0xC0) != 0x40)
  {
    uint64_t v14 = *(uint64_t (**)(uint64_t, char **))(*(void *)v12 + 40);
    return v14(v12, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::Node::getBaseName(llvm::itanium_demangle::Node *this)
{
  return 0;
}

uint64_t llvm::itanium_demangle::CtorVtableSpecialName::printLeft(uint64_t a1, char **a2)
{
  size_t v4 = *a2;
  unsigned int v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 24) > v6)
  {
    size_t v7 = (size_t)(v5 + 1016);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    size_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_19;
    }
    unsigned int v5 = a2[1];
  }
  qmemcpy(&v5[(void)v4], "construction vtable for ", 24);
  a2[1] += 24;
  uint64_t v10 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v10 + 40))(v10, a2);
  }
  size_t v11 = *a2;
  uint64_t v12 = a2[1];
  unint64_t v13 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 4) > v13)
  {
    size_t v14 = (size_t)(v12 + 996);
    unint64_t v15 = 2 * v13;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    a2[2] = (char *)v16;
    size_t v11 = (char *)realloc(v11, v16);
    *a2 = v11;
    if (v11)
    {
      uint64_t v12 = a2[1];
      goto LABEL_15;
    }
LABEL_19:
    abort();
  }
LABEL_15:
  *(_DWORD *)&v12[(void)v11] = 762210605;
  a2[1] += 4;
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v17 + 32))(v17, a2);
  if ((*(_WORD *)(v17 + 9) & 0xC0) != 0x40)
  {
    uint64_t v19 = *(uint64_t (**)(uint64_t, char **))(*(void *)v17 + 40);
    return v19(v17, a2);
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseSourceName(unsigned __int8 **a1)
{
  size_t v2 = *a1;
  size_t v1 = a1[1];
  if (v1 != *a1 && *v2 - 58 >= 0xFFFFFFF6)
  {
    unint64_t v4 = 0;
    unsigned int v5 = (const char *)(v2 + 1);
    unint64_t v6 = v2 + 1;
    do
    {
      unint64_t v7 = v4;
      unint64_t v8 = v6;
      size_t v9 = v5;
      *a1 = v6;
      uint64_t v10 = (char)*(v6 - 1);
      unint64_t v4 = v10 + 10 * v4 - 48;
      if (v6 == v1) {
        break;
      }
      ++v6;
      ++v5;
    }
    while (*v8 - 48 <= 9);
    if (v4 - 1 < v1 - (unsigned __int8 *)v9)
    {
      *a1 = &v8[10 * v7 - 48 + v10];
      if (v4 >= 0xA
        && ((uint64_t v11 = *(void *)v8, v12 = *((unsigned __int16 *)v8 + 4), v11 == 0x5F4C41424F4C475FLL)
          ? (BOOL v13 = v12 == 20063)
          : (BOOL v13 = 0),
            v13))
      {
        size_t v14 = a1[613];
        uint64_t v15 = *((void *)v14 + 1);
        if ((unint64_t)(v15 - 4048) > 0xFFFFFFFFFFFFF00FLL)
        {
          size_t v9 = "(anonymous namespace)";
          unint64_t v4 = 21;
          goto LABEL_16;
        }
        size_t v16 = (unsigned __int8 *)malloc(0x1000uLL);
        if (v16)
        {
          uint64_t v15 = 0;
          *(void *)size_t v16 = v14;
          *((void *)v16 + 1) = 0;
          unint64_t v4 = 21;
          size_t v14 = v16;
          size_t v9 = "(anonymous namespace)";
          goto LABEL_15;
        }
      }
      else
      {
        size_t v14 = a1[613];
        uint64_t v15 = *((void *)v14 + 1);
        if ((unint64_t)(v15 - 4048) > 0xFFFFFFFFFFFFF00FLL)
        {
LABEL_16:
          *((void *)v14 + 1) = v15 + 32;
          uint64_t v17 = &v14[v15];
          uint64_t result = (char *)(v17 + 16);
          v17[24] = 8;
          *(_WORD *)(v17 + 25) = *(_WORD *)(v17 + 25) & 0xF000 | 0x540;
          *((void *)v17 + 2) = &unk_1EC9A3628;
          *((void *)v17 + 4) = v9;
          *((void *)v17 + 5) = v4;
          return result;
        }
        size_t v16 = (unsigned __int8 *)malloc(0x1000uLL);
        if (v16)
        {
          uint64_t v15 = 0;
          *(void *)size_t v16 = v14;
          *((void *)v16 + 1) = 0;
          size_t v14 = v16;
LABEL_15:
          a1[613] = v16;
          goto LABEL_16;
        }
      }
      std::terminate();
    }
  }
  return 0;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::NameType,std::string_view &>(uint64_t a1, __n128 *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  unint64_t v7 = (char *)v3 + v4;
  v7[24] = 8;
  __int16 v8 = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A3628;
  __n128 result = *a2;
  *(_WORD *)(v7 + 25) = v8;
  *((__n128 *)v7 + 2) = result;
  return result;
}

void *llvm::itanium_demangle::NameType::printLeft(void *result, char **a2)
{
  size_t v2 = result[3];
  if (v2)
  {
    uint64_t v4 = (const void *)result[2];
    unsigned int v5 = *a2;
    unint64_t v6 = a2[1];
    unint64_t v7 = &v6[v2];
    size_t v8 = (size_t)a2[2];
    if ((unint64_t)&v6[v2] > v8)
    {
      unint64_t v9 = 2 * v8;
      if (v9 <= (unint64_t)(v7 + 992)) {
        size_t v10 = (size_t)(v7 + 992);
      }
      else {
        size_t v10 = v9;
      }
      a2[2] = (char *)v10;
      unsigned int v5 = (char *)realloc(v5, v10);
      *a2 = v5;
      if (!v5) {
        abort();
      }
      unint64_t v6 = a2[1];
    }
    __n128 result = memcpy(&v6[(void)v5], v4, v2);
    a2[1] += v2;
  }
  return result;
}

uint64_t llvm::itanium_demangle::NameType::getBaseName(llvm::itanium_demangle::NameType *this)
{
  return *((void *)this + 2);
}

uint64_t llvm::itanium_demangle::ModuleName::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    (*(void (**)(void, uint64_t))(*(void *)v4 + 32))(*(void *)(a1 + 16), a2);
    if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
    }
    if (*(void *)(a1 + 16))
    {
      if (*(unsigned char *)(a1 + 32)) {
        char v5 = 58;
      }
      else {
        char v5 = 46;
      }
      unint64_t v6 = *(void **)a2;
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v8 = v7 + 1;
      unint64_t v9 = *(void *)(a2 + 16);
      if (v7 + 1 <= v9) {
        goto LABEL_17;
      }
LABEL_12:
      unint64_t v10 = v7 + 993;
      if (2 * v9 <= v10) {
        size_t v11 = v10;
      }
      else {
        size_t v11 = 2 * v9;
      }
      *(void *)(a2 + 16) = v11;
      unint64_t v6 = realloc(v6, v11);
      *(void *)a2 = v6;
      if (!v6) {
        abort();
      }
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v8 = v7 + 1;
      goto LABEL_17;
    }
  }
  if (!*(unsigned char *)(a1 + 32)) {
    goto LABEL_18;
  }
  char v5 = 58;
  unint64_t v6 = *(void **)a2;
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v8 = v7 + 1;
  unint64_t v9 = *(void *)(a2 + 16);
  if (v7 + 1 > v9) {
    goto LABEL_12;
  }
LABEL_17:
  *(void *)(a2 + 8) = v8;
  *((unsigned char *)v6 + v7) = v5;
LABEL_18:
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 32))(v12, a2);
  if ((*(_WORD *)(v12 + 9) & 0xC0) != 0x40)
  {
    size_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 40);
    return v14(v12, a2);
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseUnscopedName(void *a1, unsigned char *a2, unsigned char *a3)
{
  unint64_t v6 = (_WORD *)*a1;
  uint64_t v7 = (_WORD *)a1[1];
  if ((unint64_t)v7 - *a1 >= 2 && *v6 == 29779)
  {
    *a1 = v6 + 1;
    size_t v11 = (void *)a1[613];
    uint64_t v12 = v11[1];
    if ((unint64_t)(v12 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      BOOL v13 = malloc(0x1000uLL);
      if (!v13) {
        std::terminate();
      }
      uint64_t v12 = 0;
      *BOOL v13 = v11;
      v13[1] = 0;
      size_t v11 = v13;
      a1[613] = v13;
    }
    v11[1] = v12 + 32;
    size_t v14 = (char *)v11 + v12;
    uint64_t v8 = (uint64_t)(v14 + 16);
    v14[24] = 8;
    *(_WORD *)(v14 + 25) = *(_WORD *)(v14 + 25) & 0xF000 | 0x540;
    *((void *)v14 + 2) = &unk_1EC9A3628;
    *((void *)v14 + 4) = "std";
    *((void *)v14 + 5) = 3;
    unint64_t v6 = (_WORD *)*a1;
    if (a1[1] == *a1) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v8 = 0;
    if (v7 == v6)
    {
LABEL_15:
      uint64_t v10 = 0;
      goto LABEL_16;
    }
  }
  if (*(unsigned char *)v6 != 83) {
    goto LABEL_15;
  }
  if (!result) {
    return result;
  }
  uint64_t v10 = (uint64_t)result;
  if (result[8] != 27)
  {
    uint64_t result = 0;
    if (a3)
    {
      if (!v8)
      {
        *a3 = 1;
        return (char *)v10;
      }
    }
    return result;
  }
LABEL_16:
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseTemplateArgs(uint64_t a1, int a2)
{
  size_t v2 = *(unsigned char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v2 != 73) {
    return;
  }
  uint64_t v4 = v2 + 1;
  *(void *)a1 = v4;
  if (a2)
  {
    char v5 = *(void **)(a1 + 664);
    *(void *)(a1 + 672) = v5;
    if (v5 == *(void **)(a1 + 680))
    {
      if (v5 == (void *)(a1 + 688))
      {
        char v5 = malloc(0);
        if (!v5) {
          goto LABEL_85;
        }
        *(void *)(a1 + 664) = v5;
      }
      else
      {
        char v5 = realloc(v5, 0);
        *(void *)(a1 + 664) = v5;
        if (!v5) {
LABEL_85:
        }
          abort();
      }
      *(void *)(a1 + 680) = v5;
    }
    uint64_t v19 = (void **)(a1 + 576);
    *(void *)(a1 + 672) = v5 + 1;
    *char v5 = a1 + 576;
    *(void *)(a1 + 584) = *(void *)(a1 + 576);
    uint64_t v59 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    uint64_t v20 = (char *)(a1 + 40);
    uint64_t v9 = a1 + 4904;
    uint64_t v21 = (void *)(a1 + 600);
    uint64_t v4 = *(unsigned char **)a1;
    uint64_t v22 = *(unsigned char **)(a1 + 8);
    while (1)
    {
      if (v4 != v22 && *v4 == 69)
      {
        uint64_t v18 = 0;
        uint64_t v7 = v59;
        goto LABEL_80;
      }
      if (!v23) {
        return;
      }
      uint64_t v24 = v23;
      unint64_t v25 = *(char **)(a1 + 24);
      if (v25 == *(char **)(a1 + 32))
      {
        char v41 = *(char **)(a1 + 16);
        int64_t v42 = v25 - v41;
        if (v41 == v20)
        {
          uint64_t v44 = (char *)malloc(2 * (v25 - v41));
          if (!v44) {
            goto LABEL_85;
          }
          __int16 v43 = v44;
          if (v25 != v20) {
            memcpy(v44, (const void *)(a1 + 40), v42);
          }
          *(void *)(a1 + 16) = v43;
        }
        else
        {
          __int16 v43 = (char *)realloc(v41, 2 * (v25 - v41));
          *(void *)(a1 + 16) = v43;
          if (!v43) {
            goto LABEL_85;
          }
        }
        uint64_t v45 = (uint64_t *)&v43[8 * (v42 >> 3)];
        *(void *)(a1 + 24) = v45 + 1;
        *(void *)(a1 + 32) = &v43[8 * (v42 >> 2)];
        uint64_t *v45 = v24;
        int v26 = *(unsigned __int8 *)(v24 + 8);
        if (v26 == 34) {
          goto LABEL_65;
        }
LABEL_36:
        if (v26 == 41)
        {
          uint64_t v27 = *(void *)(v24 + 16);
          uint64_t v28 = *(void *)(v24 + 24);
          uint64_t v29 = *(void **)v9;
          uint64_t v30 = *(void *)(*(void *)v9 + 8);
          if ((unint64_t)(v30 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
          {
            uint64_t v31 = malloc(0x1000uLL);
            if (!v31) {
              goto LABEL_86;
            }
            uint64_t v30 = 0;
            *uint64_t v31 = v29;
            v31[1] = 0;
            uint64_t v29 = v31;
            *(void *)uint64_t v9 = v31;
          }
          v29[1] = v30 + 32;
          int v32 = (char *)v29 + v30;
          uint64_t v24 = (uint64_t)v29 + v30 + 16;
          v32[24] = 40;
          __int16 v33 = *(_WORD *)(v32 + 25) & 0xF000;
          *((void *)v32 + 2) = &unk_1EC9A23F0;
          *((void *)v32 + 4) = v27;
          *((void *)v32 + 5) = v28;
          __int16 v34 = v33 | 0xA80;
          *(_WORD *)(v32 + 25) = v33 | 0xA80;
          uint64_t v35 = 8 * v28;
          if (v28)
          {
            uint64_t v36 = 8 * v28;
            uint64_t v37 = v27;
            while ((*(_WORD *)(*(void *)v37 + 9) & 0x300) == 0x100)
            {
              v37 += 8;
              v36 -= 8;
              if (!v36) {
                goto LABEL_44;
              }
            }
          }
          else
          {
LABEL_44:
            __int16 v34 = v33 | 0x980;
            *(_WORD *)(v24 + 9) = v33 | 0x980;
          }
          if (v28)
          {
            uint64_t v38 = 8 * v28;
            uint64_t v39 = v27;
            while ((*(_WORD *)(*(void *)v39 + 9) & 0xC00) == 0x400)
            {
              v39 += 8;
              v38 -= 8;
              if (!v38) {
                goto LABEL_49;
              }
            }
          }
          else
          {
LABEL_49:
            __int16 v34 = v34 & 0xF3FF | 0x400;
            *(_WORD *)(v24 + 9) = v34;
          }
          if (v28)
          {
            while ((*(_WORD *)(*(void *)v27 + 9) & 0xC0) == 0x40)
            {
              v27 += 8;
              v35 -= 8;
              if (!v35) {
                goto LABEL_53;
              }
            }
          }
          else
          {
LABEL_53:
            *(_WORD *)(v24 + 9) = v34 & 0xFF3F | 0x40;
          }
        }
        uint64_t v40 = *(uint64_t **)(a1 + 584);
        if (v40 != *(uint64_t **)(a1 + 592)) {
          goto LABEL_55;
        }
LABEL_66:
        int64_t v46 = (char *)v40 - (unsigned char *)*v19;
        if (*v19 == v21)
        {
          uint64_t v48 = (char *)malloc(2 * v46);
          if (!v48) {
            goto LABEL_85;
          }
          size_t v47 = v48;
          if (v40 != v21) {
            memcpy(v48, (const void *)(a1 + 600), v46);
          }
          *uint64_t v19 = v47;
        }
        else
        {
          size_t v47 = (char *)realloc(*v19, 2 * v46);
          *uint64_t v19 = v47;
          if (!v47) {
            goto LABEL_85;
          }
        }
        int v49 = (uint64_t *)&v47[8 * (v46 >> 3)];
        *(void *)(a1 + 592) = &v47[8 * (v46 >> 2)];
        *(void *)(a1 + 584) = v49 + 1;
        *int v49 = v24;
        uint64_t v4 = *(unsigned char **)a1;
        uint64_t v22 = *(unsigned char **)(a1 + 8);
        if (*(unsigned char **)a1 != v22) {
          goto LABEL_30;
        }
      }
      else
      {
        *(void *)(a1 + 24) = v25 + 8;
        *(void *)unint64_t v25 = v23;
        int v26 = *(unsigned __int8 *)(v23 + 8);
        if (v26 != 34) {
          goto LABEL_36;
        }
LABEL_65:
        uint64_t v24 = *(void *)(v24 + 24);
        uint64_t v40 = *(uint64_t **)(a1 + 584);
        if (v40 == *(uint64_t **)(a1 + 592)) {
          goto LABEL_66;
        }
LABEL_55:
        *(void *)(a1 + 584) = v40 + 1;
        *uint64_t v40 = v24;
        uint64_t v4 = *(unsigned char **)a1;
        uint64_t v22 = *(unsigned char **)(a1 + 8);
        if (*(unsigned char **)a1 != v22)
        {
LABEL_30:
          if (*v4 == 81)
          {
            uint64_t v7 = v59;
            goto LABEL_77;
          }
        }
      }
    }
  }
  unint64_t v6 = *(unsigned char **)(a1 + 8);
  uint64_t v7 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  uint64_t v8 = (char *)(a1 + 40);
  uint64_t v9 = a1 + 4904;
  do
  {
    do
    {
      while (1)
      {
        if (v4 != v6 && *v4 == 69)
        {
          uint64_t v18 = 0;
          goto LABEL_80;
        }
        if (!v10) {
          return;
        }
        uint64_t v11 = v10;
        uint64_t v12 = *(char **)(a1 + 24);
        if (v12 == *(char **)(a1 + 32)) {
          break;
        }
        *(void *)(a1 + 24) = v12 + 8;
        *(void *)uint64_t v12 = v10;
        uint64_t v4 = *(unsigned char **)a1;
        unint64_t v6 = *(unsigned char **)(a1 + 8);
        if (*(unsigned char **)a1 != v6) {
          goto LABEL_9;
        }
      }
      BOOL v13 = *(char **)(a1 + 16);
      int64_t v14 = v12 - v13;
      if (v13 == v8)
      {
        size_t v16 = (char *)malloc(2 * (v12 - v13));
        if (!v16) {
          goto LABEL_85;
        }
        uint64_t v15 = v16;
        if (v12 != v8) {
          memcpy(v16, (const void *)(a1 + 40), v14);
        }
        *(void *)(a1 + 16) = v15;
      }
      else
      {
        uint64_t v15 = (char *)realloc(v13, 2 * (v12 - v13));
        *(void *)(a1 + 16) = v15;
        if (!v15) {
          goto LABEL_85;
        }
      }
      uint64_t v17 = &v15[8 * (v14 >> 3)];
      *(void *)(a1 + 24) = v17 + 8;
      *(void *)(a1 + 32) = &v15[8 * (v14 >> 2)];
      *(void *)uint64_t v17 = v11;
      uint64_t v4 = *(unsigned char **)a1;
      unint64_t v6 = *(unsigned char **)(a1 + 8);
    }
    while (*(unsigned char **)a1 == v6);
LABEL_9:
    ;
  }
  while (*v4 != 81);
LABEL_77:
  *(void *)a1 = v4 + 1;
  char v50 = *(unsigned char *)(a1 + 778);
  *(unsigned char *)(a1 + 778) = 1;
  *(unsigned char *)(a1 + 778) = v50;
  if (!v51) {
    return;
  }
  uint64_t v4 = *(unsigned char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8)) {
    return;
  }
  uint64_t v18 = v51;
  if (*v4 != 69) {
    return;
  }
LABEL_80:
  *(void *)a1 = v4 + 1;
  uint64_t v54 = v53;
  char v55 = *(void **)(a1 + 4904);
  uint64_t v56 = v55[1];
  if ((unint64_t)(v56 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v57 = malloc(0x1000uLL);
    if (!v57) {
LABEL_86:
    }
      std::terminate();
    uint64_t v56 = 0;
    void *v57 = v55;
    v57[1] = 0;
    char v55 = v57;
    *(void *)uint64_t v9 = v57;
  }
  v55[1] = v56 + 48;
  int64_t v58 = (char *)v55 + v56;
  v58[24] = 43;
  *(_WORD *)(v58 + 25) = *(_WORD *)(v58 + 25) & 0xF000 | 0x540;
  *((void *)v58 + 2) = &unk_1EC9A2238;
  *((void *)v58 + 4) = v52;
  *((void *)v58 + 5) = v54;
  *((void *)v58 + 6) = v18;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::NameWithTemplateArgs,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  char v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    char v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  uint64_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  v9[24] = 45;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A2DE8;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseTemplateParam(uint64_t a1, size_t __size)
{
  int v3 = *(unsigned char **)a1;
  size_t v2 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v2) {
    return 0;
  }
  if (*v3 != 84) {
    return 0;
  }
  char v5 = v3 + 1;
  *(void *)a1 = v3 + 1;
  if (v3 + 1 == v2) {
    return 0;
  }
  if (*v5 != 76)
  {
    unint64_t v10 = 0;
    if (v5 != v2) {
      goto LABEL_15;
    }
    return 0;
  }
  *(void *)a1 = v3 + 2;
  if (v2 == v3 + 2 || v3[2] - 58 < 0xFFFFFFF6) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = v3 + 4;
  do
  {
    char v5 = v7;
    uint64_t v8 = v7 - 1;
    *(void *)a1 = v7 - 1;
    uint64_t v6 = (char)*(v7 - 2) + 10 * v6 - 48;
    if (v7 - 1 == v2) {
      break;
    }
    unsigned int v9 = *(v7++ - 1) - 48;
  }
  while (v9 <= 9);
  if (v8 == v2) {
    return 0;
  }
  if (*(v5 - 1) != 95) {
    return 0;
  }
  unint64_t v10 = v6 + 1;
  *(void *)a1 = v5;
  if (v5 == v2) {
    return 0;
  }
LABEL_15:
  int v11 = *v5;
  if (v11 == 95)
  {
    unint64_t v12 = 0;
    *(void *)a1 = v5 + 1;
    if (*(unsigned char *)(a1 + 778))
    {
LABEL_17:
      BOOL v13 = *(void **)(a1 + 4904);
      uint64_t v14 = v13[1];
      if ((unint64_t)(v14 - 4048) > 0xFFFFFFFFFFFFF00FLL)
      {
LABEL_20:
        v13[1] = v14 + 32;
        size_t v16 = (char *)v13 + v14;
        uint64_t v17 = v16 + 16;
        v16[24] = 8;
        *(_WORD *)(v16 + 25) = *(_WORD *)(v16 + 25) & 0xF000 | 0x540;
        *((void *)v16 + 2) = &unk_1EC9A3628;
        *((void *)v16 + 4) = v3;
        *((void *)v16 + 5) = v5 - v3;
        return v17;
      }
      uint64_t v15 = malloc(0x1000uLL);
      if (v15)
      {
        uint64_t v14 = 0;
        *uint64_t v15 = v13;
        v15[1] = 0;
        BOOL v13 = v15;
        *(void *)(a1 + 4904) = v15;
        goto LABEL_20;
      }
LABEL_53:
      std::terminate();
    }
  }
  else
  {
    if ((v11 - 58) < 0xFFFFFFF6) {
      return 0;
    }
    uint64_t v19 = 0;
    uint64_t v20 = v5 + 1;
    do
    {
      *(void *)a1 = v20;
      if (v20 == v2) {
        return 0;
      }
      uint64_t v19 = (char)*(v20 - 1) + 10 * v19 - 48;
      int v22 = *v20++;
      int v21 = v22;
    }
    while ((v22 - 48) <= 9);
    if (v21 != 95) {
      return 0;
    }
    unint64_t v12 = v19 + 1;
    char v5 = v20 - 1;
    *(void *)a1 = v20;
    if (*(unsigned char *)(a1 + 778)) {
      goto LABEL_17;
    }
  }
  if (*(unsigned char *)(a1 + 777) && !v10)
  {
    uint64_t v23 = *(void **)(a1 + 4904);
    uint64_t v24 = v23[1];
    if ((unint64_t)(v24 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
    {
      unint64_t v25 = malloc(0x1000uLL);
      if (!v25) {
        goto LABEL_53;
      }
      uint64_t v24 = 0;
      void *v25 = v23;
      v25[1] = 0;
      uint64_t v23 = v25;
      *(void *)(a1 + 4904) = v25;
    }
    v23[1] = v24 + 48;
    int v26 = (char *)v23 + v24;
    uint64_t v17 = v26 + 16;
    v26[24] = 44;
    *(_WORD *)(v26 + 25) = *(_WORD *)(v26 + 25) & 0xF000 | 0xA80;
    *((void *)v26 + 2) = &unk_1EC9A3158;
    *((void *)v26 + 4) = v12;
    *((void *)v26 + 5) = 0;
    v26[48] = 0;
    uint64_t v27 = *(char **)(a1 + 728);
    if (v27 == *(char **)(a1 + 736))
    {
      uint64_t v28 = *(char **)(a1 + 720);
      uint64_t v29 = v27 - v28;
      if (v28 == (char *)(a1 + 744))
      {
        uint64_t v36 = (char *)malloc(2 * (v27 - v28));
        if (!v36) {
          goto LABEL_54;
        }
        uint64_t v30 = v36;
        if (v27 != v28) {
          memmove(v36, v28, v27 - v28);
        }
        *(void *)(a1 + 720) = v30;
      }
      else
      {
        uint64_t v30 = (char *)realloc(*(void **)(a1 + 720), 2 * (v27 - v28));
        *(void *)(a1 + 720) = v30;
        if (!v30) {
LABEL_54:
        }
          abort();
      }
      uint64_t v27 = &v30[8 * (v29 >> 3)];
      *(void *)(a1 + 736) = &v30[8 * (v29 >> 2)];
    }
    *(void *)(a1 + 728) = v27 + 8;
    *(void *)uint64_t v27 = v17;
    return v17;
  }
  uint64_t v31 = *(void *)(a1 + 664);
  unint64_t v32 = (*(void *)(a1 + 672) - v31) >> 3;
  if (v10 < v32)
  {
    __int16 v33 = *(void **)(v31 + 8 * v10);
    if (v33)
    {
      uint64_t v35 = v33;
      uint64_t v34 = *v33;
      if (v12 < (v35[1] - v34) >> 3) {
        return *(char **)(v34 + 8 * v12);
      }
    }
  }
  uint64_t v17 = 0;
  if (v10 <= v32 && *(void *)(a1 + 784) == v10)
  {
    if (v10 == v32)
    {
      uint64_t v37 = 0;
      llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 664), &v37);
    }
  }
  return v17;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseDecltype(uint64_t a1)
{
  size_t v1 = *(unsigned char **)a1;
  size_t v2 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 == v2) {
    return 0;
  }
  if (*v1 != 68) {
    return 0;
  }
  *(void *)a1 = v1 + 1;
  if (v1 + 1 == v2 || (v1[1] | 0x20) != 0x74) {
    return 0;
  }
  *(void *)a1 = v1 + 2;
  if (!result) {
    return result;
  }
  char v5 = *(unsigned char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v5 != 69) {
    return 0;
  }
  uint64_t v6 = result;
  *(void *)a1 = v5 + 1;
  uint64_t v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4016) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unsigned int v9 = malloc(0x1000uLL);
    if (!v9) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *unsigned int v9 = v7;
    v9[1] = 0;
    uint64_t v7 = v9;
    *(void *)(a1 + 4904) = v9;
  }
  v7[1] = v8 + 64;
  unint64_t v10 = (char *)v7 + v8;
  uint64_t result = (uint64_t)(v10 + 16);
  v10[24] = 60;
  *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x540;
  *((void *)v10 + 2) = &unk_1EC9A2290;
  *((void *)v10 + 4) = "decltype";
  *((void *)v10 + 5) = 8;
  *((void *)v10 + 7) = 0;
  *((void *)v10 + 8) = 0;
  *((void *)v10 + 6) = v6;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseSubstitution(uint64_t a1)
{
  size_t v2 = *(unsigned char **)a1;
  size_t v1 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 == v1) {
    return 0;
  }
  if (*v2 != 83) {
    return 0;
  }
  uint64_t v4 = v2 + 1;
  *(void *)a1 = v2 + 1;
  if (v1 == v2 + 1) {
    return 0;
  }
  unsigned int v5 = *v4;
  if ((char)*v4 < 97)
  {
    if (v5 == 95)
    {
      *(void *)a1 = v2 + 2;
      uint64_t v8 = *(void *)(a1 + 296);
      if (v8 != *(void *)(a1 + 304)) {
        return *(char **)v8;
      }
      return 0;
    }
    if ((char)v5 < 48) {
      return 0;
    }
LABEL_13:
    if (v5 < 0x3A || v5 - 65 <= 0x19)
    {
      uint64_t v10 = 0;
      while ((char)*v4 >= 48)
      {
        if (*v4 < 0x3Au)
        {
          uint64_t v11 = -48;
        }
        else
        {
          if (*v4 - 65 > 0x19) {
            break;
          }
          uint64_t v11 = -55;
        }
        uint64_t v10 = *v4++ + 36 * v10 + v11;
        *(void *)a1 = v4;
        if (v4 == v1) {
          return 0;
        }
      }
      if (v4 != v1 && *v4 == 95)
      {
        *(void *)a1 = v4 + 1;
        uint64_t v12 = *(void *)(a1 + 296);
        if (v10 + 1 < (unint64_t)((*(void *)(a1 + 304) - v12) >> 3)) {
          return *(char **)(v12 + 8 * (v10 + 1));
        }
      }
    }
    return 0;
  }
  if (v5 > 0x7A) {
    goto LABEL_13;
  }
  int v6 = 0;
  switch(*v4)
  {
    case 'a':
      goto LABEL_33;
    case 'b':
      int v6 = 1;
      goto LABEL_33;
    case 'd':
      int v6 = 5;
      goto LABEL_33;
    case 'i':
      int v6 = 3;
      goto LABEL_33;
    case 'o':
      int v6 = 4;
      goto LABEL_33;
    case 's':
      int v6 = 2;
LABEL_33:
      *(void *)a1 = v2 + 2;
      BOOL v13 = *(char **)(a1 + 4904);
      uint64_t v14 = *((void *)v13 + 1);
      if ((unint64_t)(v14 - 4064) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v15 = (char *)malloc(0x1000uLL);
        if (!v15) {
          std::terminate();
        }
        uint64_t v14 = 0;
        *(void *)uint64_t v15 = v13;
        *((void *)v15 + 1) = 0;
        BOOL v13 = v15;
        *(void *)(a1 + 4904) = v15;
      }
      uint64_t v16 = v14 + 16;
      *((void *)v13 + 1) = v16;
      uint64_t v17 = &v13[v16];
      v17[8] = 48;
      *(_WORD *)(v17 + 9) = *(_WORD *)&v13[v16 + 9] & 0xF000 | 0x540;
      *((_DWORD *)v17 + 3) = v6;
      *(void *)uint64_t v17 = &unk_1EC9A2CE0;
      if (v18 == v17)
      {
        uint64_t result = v17;
      }
      else
      {
        uint64_t v19 = v18;
        uint64_t v20 = *(char **)(a1 + 304);
        if (v20 == *(char **)(a1 + 312))
        {
          int v21 = *(char **)(a1 + 296);
          uint64_t v22 = v20 - v21;
          if (v21 == (char *)(a1 + 320))
          {
            uint64_t v24 = (char *)malloc(2 * (v20 - v21));
            if (!v24) {
              goto LABEL_49;
            }
            uint64_t v23 = v24;
            if (v20 != v21) {
              memmove(v24, v21, v20 - v21);
            }
            *(void *)(a1 + 296) = v23;
          }
          else
          {
            uint64_t v23 = (char *)realloc(*(void **)(a1 + 296), 2 * (v20 - v21));
            *(void *)(a1 + 296) = v23;
            if (!v23) {
LABEL_49:
            }
              abort();
          }
          uint64_t v20 = &v23[8 * (v22 >> 3)];
          *(void *)(a1 + 312) = &v23[8 * (v22 >> 2)];
        }
        *(void *)(a1 + 304) = v20 + 8;
        *(void *)uint64_t v20 = v19;
        uint64_t result = v19;
      }
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseUnqualifiedName(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a3;
  uint64_t v60 = a4;
  uint64_t v61 = a3;
  uint64_t v8 = *(unsigned __int8 **)a1;
  unsigned int v9 = *(unsigned __int8 **)(a1 + 8);
  if (!v4) {
    goto LABEL_8;
  }
  if (v8 == v9)
  {
    char v13 = 1;
    unsigned int v9 = *(unsigned __int8 **)a1;
    char v10 = 1;
    goto LABEL_23;
  }
  if (*v8 == 70)
  {
    char v10 = 0;
    *(void *)a1 = ++v8;
    if (v8 == v9) {
      goto LABEL_16;
    }
  }
  else
  {
LABEL_8:
    char v10 = 1;
    if (v8 == v9)
    {
LABEL_16:
      char v13 = 1;
      uint64_t v8 = v9;
      goto LABEL_23;
    }
  }
  if (*v8 == 76) {
    *(void *)a1 = ++v8;
  }
  if (v9 == v8) {
    goto LABEL_16;
  }
  if ((char)*v8 >= 49)
  {
    unsigned int v11 = *v8;
    if (v11 <= 0x39)
    {
      if (!v12) {
        goto LABEL_79;
      }
      goto LABEL_38;
    }
    if (v11 == 85)
    {
      if (!v12) {
        goto LABEL_79;
      }
      goto LABEL_38;
    }
  }
  char v13 = 0;
  if ((unint64_t)(v9 - v8) >= 2 && *(_WORD *)v8 == 17220)
  {
    *(void *)a1 = v8 + 2;
    uint64_t v28 = *(void *)(a1 + 16);
    uint64_t v27 = *(void *)(a1 + 24);
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = (v27 - v28) >> 3;
      unint64_t v32 = (char *)(a1 + 40);
      while (1)
      {
        __int16 v33 = *(char **)(a1 + 24);
        if (v33 == *(char **)(a1 + 32))
        {
          uint64_t v34 = *(char **)(a1 + 16);
          int64_t v35 = v33 - v34;
          if (v34 == v32)
          {
            uint64_t v37 = (char *)malloc(2 * (v33 - v34));
            if (!v37) {
LABEL_96:
            }
              abort();
            uint64_t v36 = v37;
            if (v33 != v32) {
              memcpy(v37, (const void *)(a1 + 40), v35);
            }
            *(void *)(a1 + 16) = v36;
          }
          else
          {
            uint64_t v36 = (char *)realloc(v34, 2 * (v33 - v34));
            *(void *)(a1 + 16) = v36;
            if (!v36) {
              goto LABEL_96;
            }
          }
          __int16 v33 = &v36[8 * (v35 >> 3)];
          *(void *)(a1 + 32) = &v36[8 * (v35 >> 2)];
        }
        *(void *)(a1 + 24) = v33 + 8;
        *(void *)__int16 v33 = v30;
        uint64_t v38 = *(unsigned __int8 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *v38 == 69) {
          break;
        }
        if (!v30) {
          return 0;
        }
      }
      *(void *)a1 = v38 + 1;
      uint64_t v41 = v40;
      int64_t v42 = *(void **)(a1 + 4904);
      uint64_t v43 = v42[1];
      if ((unint64_t)(v43 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v44 = malloc(0x1000uLL);
        if (!v44) {
          goto LABEL_97;
        }
        uint64_t v43 = 0;
        *uint64_t v44 = v42;
        v44[1] = 0;
        int64_t v42 = v44;
        *(void *)(a1 + 4904) = v44;
      }
      v42[1] = v43 + 32;
      uint64_t v45 = (char *)v42 + v43;
      uint64_t v12 = v45 + 16;
      v45[24] = 53;
      *(_WORD *)(v45 + 25) = *(_WORD *)(v45 + 25) & 0xF000 | 0x540;
      *((void *)v45 + 2) = &unk_1EC9A2F48;
      *((void *)v45 + 4) = v39;
      *((void *)v45 + 5) = v41;
      if (v45 == (char *)-16) {
        goto LABEL_79;
      }
      goto LABEL_38;
    }
    return 0;
  }
LABEL_23:
  if ((v13 & 1) != 0 || *v8 - 67 > 1)
  {
    if (!v12) {
      goto LABEL_79;
    }
    goto LABEL_38;
  }
  uint64_t v7 = 0;
  if (!v4 || v60) {
    return (uint64_t)v7;
  }
  if (*(unsigned char *)(v4 + 8) == 48)
  {
    uint64_t v14 = *(void **)(a1 + 4904);
    uint64_t v15 = v14[1];
    if ((unint64_t)(v15 - 4064) <= 0xFFFFFFFFFFFFF00FLL)
    {
      uint64_t v16 = malloc(0x1000uLL);
      if (!v16) {
        goto LABEL_97;
      }
      uint64_t v15 = 0;
      *uint64_t v16 = v14;
      v16[1] = 0;
      uint64_t v14 = v16;
      *(void *)(a1 + 4904) = v16;
    }
    uint64_t v17 = v15 + 16;
    v14[1] = v17;
    int v18 = *(_DWORD *)(v4 + 12);
    uint64_t v4 = (uint64_t)v14 + v17;
    *(unsigned char *)(v4 + 8) = 47;
    *(_WORD *)(v4 + 9) = *(_WORD *)((unsigned char *)v14 + v17 + 9) & 0xF000 | 0x540;
    *(void *)uint64_t v4 = &unk_1EC9A3310;
    *(_DWORD *)(v4 + 12) = v18;
    uint64_t v61 = (uint64_t)v14 + v17;
    uint64_t v8 = *(unsigned __int8 **)a1;
    unsigned int v9 = *(unsigned __int8 **)(a1 + 8);
  }
  if (v8 == v9) {
    return 0;
  }
  int v19 = *v8;
  if (v19 == 67)
  {
    uint64_t v20 = v8 + 1;
    *(void *)a1 = v8 + 1;
    if (v8 + 1 == v9)
    {
      int v21 = 0;
      uint64_t v20 = v9;
    }
    else if (*v20 == 73)
    {
      uint64_t v20 = v8 + 2;
      *(void *)a1 = v8 + 2;
      int v21 = 1;
    }
    else
    {
      int v21 = 0;
    }
    if (v9 == v20) {
      return 0;
    }
    int v47 = *v20;
    if ((v47 - 49) > 4) {
      return 0;
    }
    *(void *)a1 = v20 + 1;
    if (a2) {
      *a2 = 1;
    }
    if (v21
    {
      return 0;
    }
    if (!v12) {
      goto LABEL_79;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if ((unint64_t)(v9 - v8) < 2) {
      return (uint64_t)v7;
    }
    if (v19 != 68) {
      return (uint64_t)v7;
    }
    uint64_t v7 = 0;
    unsigned int v46 = v8[1];
    if (v46 > 0x35 || ((1 << v46) & 0x37000000000000) == 0) {
      return (uint64_t)v7;
    }
    *(void *)a1 = v8 + 2;
    if (a2) {
      *a2 = 1;
    }
    if (!v12) {
      goto LABEL_79;
    }
  }
LABEL_38:
  uint64_t v22 = v60;
  if (v60)
  {
    uint64_t v23 = *(void **)(a1 + 4904);
    uint64_t v24 = v23[1];
    if ((unint64_t)(v24 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      unint64_t v25 = malloc(0x1000uLL);
      if (!v25) {
        goto LABEL_97;
      }
      uint64_t v24 = 0;
      void *v25 = v23;
      v25[1] = 0;
      uint64_t v23 = v25;
      *(void *)(a1 + 4904) = v25;
    }
    v23[1] = v24 + 32;
    int v26 = (char *)v23 + v24;
    v26[24] = 28;
    *(_WORD *)(v26 + 25) = *(_WORD *)(v26 + 25) & 0xF000 | 0x540;
    *((void *)v26 + 2) = &unk_1EC9A2130;
    *((void *)v26 + 4) = v22;
    *((void *)v26 + 5) = v12;
    uint64_t v12 = v26 + 16;
    goto LABEL_80;
  }
LABEL_79:
  if (!v12) {
    return 0;
  }
LABEL_80:
  uint64_t v7 = v48;
  if (v48) {
    char v49 = v10;
  }
  else {
    char v49 = 1;
  }
  if ((v49 & 1) == 0)
  {
    uint64_t v56 = *(void **)(a1 + 4904);
    uint64_t v57 = v56[1];
    if ((unint64_t)(v57 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      int64_t v58 = malloc(0x1000uLL);
      if (!v58) {
        goto LABEL_97;
      }
      uint64_t v57 = 0;
      *int64_t v58 = v56;
      v58[1] = 0;
      uint64_t v56 = v58;
      *(void *)(a1 + 4904) = v58;
    }
    v56[1] = v57 + 32;
    uint64_t v53 = (char *)v56 + v57;
    uint64_t v54 = (uint64_t)v56 + v57 + 16;
    v53[24] = 25;
    *(_WORD *)(v53 + 25) = *(_WORD *)(v53 + 25) & 0xF000 | 0x540;
    char v55 = &unk_1EC9A2D90;
    goto LABEL_94;
  }
  if (v4 && v48)
  {
    char v50 = *(void **)(a1 + 4904);
    uint64_t v51 = v50[1];
    if ((unint64_t)(v51 - 4048) > 0xFFFFFFFFFFFFF00FLL)
    {
LABEL_89:
      v50[1] = v51 + 32;
      uint64_t v53 = (char *)v50 + v51;
      uint64_t v54 = (uint64_t)v50 + v51 + 16;
      v53[24] = 24;
      *(_WORD *)(v53 + 25) = *(_WORD *)(v53 + 25) & 0xF000 | 0x540;
      char v55 = &unk_1EC9A1D10;
LABEL_94:
      *((void *)v53 + 2) = v55;
      *((void *)v53 + 4) = v4;
      *(void *)(v54 + 24) = v7;
      return v54;
    }
    uint64_t v52 = malloc(0x1000uLL);
    if (v52)
    {
      uint64_t v51 = 0;
      *uint64_t v52 = v50;
      v52[1] = 0;
      char v50 = v52;
      *(void *)(a1 + 4904) = v52;
      goto LABEL_89;
    }
LABEL_97:
    std::terminate();
  }
  return (uint64_t)v7;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::NameType,char const(&)[5]>(uint64_t a1, char *__s)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  size_t v8 = strlen(__s);
  v7[24] = 8;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A3628;
  *((void *)v7 + 4) = __s;
  *((void *)v7 + 5) = v8;
  return v7 + 16;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::hasRHSComponentSlow(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  *(unsigned char *)(a1 + 32) = 1;
  uint64_t v3 = *(void *)(a1 + 24);
  unsigned int v4 = *(unsigned __int8 *)(v3 + 9);
  if ((v4 & 0xC0) == 0x80) {
    uint64_t result = (**(uint64_t (***)(uint64_t))v3)(v3);
  }
  else {
    uint64_t result = v4 < 0x40;
  }
  *(unsigned char *)(a1 + 32) = 0;
  return result;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::hasArraySlow(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  *(unsigned char *)(a1 + 32) = 1;
  uint64_t v3 = *(unsigned char **)(a1 + 24);
  int v4 = v3[10] & 3;
  if (v4 == 2) {
    uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)v3 + 8))(v3);
  }
  else {
    uint64_t result = v4 == 0;
  }
  *(unsigned char *)(a1 + 32) = 0;
  return result;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::hasFunctionSlow(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  *(unsigned char *)(a1 + 32) = 1;
  uint64_t v3 = *(void *)(a1 + 24);
  int v4 = (*(unsigned __int16 *)(v3 + 9) >> 10) & 3;
  if (v4 == 2) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  else {
    uint64_t result = v4 == 0;
  }
  *(unsigned char *)(a1 + 32) = 0;
  return result;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::getSyntaxNode(uint64_t result)
{
  uint64_t v1 = result;
  if (!*(unsigned char *)(result + 32))
  {
    *(unsigned char *)(result + 32) = 1;
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(result + 24) + 24))(*(void *)(result + 24));
    *(unsigned char *)(v1 + 32) = 0;
  }
  return result;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::printLeft(uint64_t result)
{
  if (!*(unsigned char *)(result + 32))
  {
    uint64_t v1 = result;
    *(unsigned char *)(result + 32) = 1;
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(result + 24) + 32))(*(void *)(result + 24));
    *(unsigned char *)(v1 + 32) = 0;
  }
  return result;
}

uint64_t llvm::itanium_demangle::ForwardTemplateReference::printRight(uint64_t result)
{
  if (!*(unsigned char *)(result + 32))
  {
    uint64_t v1 = result;
    *(unsigned char *)(result + 32) = 1;
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(result + 24) + 40))(*(void *)(result + 24));
    *(unsigned char *)(v1 + 32) = 0;
  }
  return result;
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseExpr(uint64_t a1, size_t a2)
{
  size_t v2 = *(unsigned __int16 **)a1;
  uint64_t v3 = *(unsigned __int16 **)(a1 + 8);
  unint64_t v4 = (unint64_t)v3 - *(void *)a1;
  if (v4 < 2) {
    return;
  }
  int v6 = *v2;
  BOOL v7 = v6 != 29543;
  if (v6 == 29543)
  {
    *(void *)a1 = ++v2;
    unint64_t v4 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) < 2) {
      return;
    }
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
  }
  unint64_t v9 = 0;
  char v10 = (unsigned __int8 *)v2 + 1;
  int v11 = *(unsigned __int8 *)v2;
  uint64_t v12 = 61;
  do
  {
    unint64_t v13 = (v9 + v12) >> 1;
        + 16 * v13;
    if (*v14 < (char)v11)
    {
      unint64_t v9 = v13 + 1;
    }
    else if (*v14 == v11)
    {
      if (v14[1] >= (char)*v10) {
        uint64_t v12 = (v9 + v12) >> 1;
      }
      else {
        unint64_t v9 = v13 + 1;
      }
    }
    else
    {
      uint64_t v12 = (v9 + v12) >> 1;
    }
  }
  while (v12 != v9);
      + 16 * v9;
  if (*v15 == v11 && v15[1] == *v10)
  {
    uint64_t v16 = v2 + 1;
    *(void *)a1 = v2 + 1;
    unsigned int v17 = v15[2];
    int v18 = (const char *)*((void *)v15 + 1);
    size_t v19 = strlen(v18);
    unint64_t v20 = v19;
    if (v17 > 0xA)
    {
      int v21 = (unsigned __int8 *)*((void *)v15 + 1);
    }
    else
    {
      int v21 = (unsigned __int8 *)(v18 + 8);
      if (v19 == 8)
      {
        unint64_t v20 = 0;
      }
      else
      {
        int v22 = *v21;
        if (v22 == 32) {
          unint64_t v20 = v19 - 9;
        }
        else {
          unint64_t v20 = v19 - 8;
        }
        if (v22 == 32) {
          int v21 = (unsigned __int8 *)(v18 + 9);
        }
      }
    }
    v160.n128_u64[0] = (unint64_t)v21;
    v160.n128_u64[1] = v20;
    switch(v17)
    {
      case 1u:
        if (v16 == v3 || *(unsigned char *)v16 != 95)
        {
          if (v162.n128_u64[0]) {
        }
          }
        else
        {
          *(void *)a1 = (char *)v2 + 3;
          char v51 = v15[3];
          v162.n128_u64[0] = (unint64_t)v21;
          v162.n128_u64[1] = v20;
          if ((void)v159) {
        }
          }
        return;
      case 2u:
        int v52 = (char)v15[3];
        v162.n128_u64[0] = (unint64_t)v21;
        v162.n128_u64[1] = v20;
        if ((void)v159)
        {
          if (v161) {
        }
          }
        return;
      case 3u:
        if (v162.n128_u64[0])
        {
          if ((void)v159) {
        }
          }
        return;
      case 4u:
        if (v162.n128_u64[0])
        {
          if ((void)v159) {
        }
          }
        return;
      case 5u:
        uint64_t v53 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        uint64_t v54 = (char *)(a1 + 40);
        while (2)
        {
          if (v16 != v3 && *(unsigned char *)v16 == 95)
          {
            *(void *)a1 = (char *)v16 + 1;
            v162.n128_u64[1] = v104;
            if (!v161) {
              return;
            }
            uint64_t v107 = *(void *)(a1 + 16);
            uint64_t v106 = *(void *)(a1 + 24);
            if (v105)
            {
              while (1)
              {
                char v108 = *(unsigned __int16 **)a1;
                if (*(void *)a1 != *(void *)(a1 + 8) && *(unsigned char *)v108 == 69) {
                  break;
                }
                if (!v112) {
                  return;
                }
                uint64_t v113 = v112;
                char v111 = *(char **)(a1 + 24);
                if (v111 == *(char **)(a1 + 32))
                {
                  char v114 = *(char **)(a1 + 16);
                  int64_t v115 = v111 - v114;
                  if (v114 == v54)
                  {
                    v116 = (char *)malloc(2 * (v111 - v114));
                    if (!v116) {
                      goto LABEL_292;
                    }
                    unint64_t v110 = v116;
                    if (v111 != v54) {
                      memcpy(v116, (const void *)(a1 + 40), v115);
                    }
                    *(void *)(a1 + 16) = v110;
                  }
                  else
                  {
                    unint64_t v110 = (char *)realloc(v114, 2 * (v111 - v114));
                    *(void *)(a1 + 16) = v110;
                    if (!v110) {
                      goto LABEL_292;
                    }
                  }
                  char v111 = &v110[8 * (v115 >> 3)];
                  *(void *)(a1 + 32) = &v110[8 * (v115 >> 2)];
                }
                *(void *)(a1 + 24) = v111 + 8;
                *(void *)char v111 = v113;
              }
            }
            else
            {
              char v108 = *(unsigned __int16 **)a1;
              if (*(void *)a1 == *(void *)(a1 + 8) || *(unsigned char *)v108 != 69) {
                return;
              }
            }
            *(void *)a1 = (char *)v108 + 1;
            *((void *)&v159 + 1) = v109;
            return;
          }
          if (!v57) {
            return;
          }
          uint64_t v58 = v57;
          uint64_t v56 = *(char **)(a1 + 24);
          if (v56 != *(char **)(a1 + 32)) {
            goto LABEL_117;
          }
          uint64_t v59 = *(char **)(a1 + 16);
          int64_t v60 = v56 - v59;
          if (v59 == v54)
          {
            uint64_t v61 = (char *)malloc(2 * (v56 - v59));
            if (v61)
            {
              char v55 = v61;
              if (v56 != v54) {
                memcpy(v61, (const void *)(a1 + 40), v60);
              }
              *(void *)(a1 + 16) = v55;
              goto LABEL_116;
            }
          }
          else
          {
            char v55 = (char *)realloc(v59, 2 * (v56 - v59));
            *(void *)(a1 + 16) = v55;
            if (v55)
            {
LABEL_116:
              uint64_t v56 = &v55[8 * (v60 >> 3)];
              *(void *)(a1 + 32) = &v55[8 * (v60 >> 2)];
LABEL_117:
              *(void *)(a1 + 24) = v56 + 8;
              *(void *)uint64_t v56 = v58;
              uint64_t v16 = *(unsigned __int16 **)a1;
              uint64_t v3 = *(unsigned __int16 **)(a1 + 8);
              continue;
            }
          }
          goto LABEL_292;
        }
      case 6u:
        if (!v62) {
          return;
        }
        uint64_t v63 = v62;
        unsigned int v64 = v15[3];
        uint64_t v65 = *(void **)(a1 + 4904);
        uint64_t v66 = v65[1];
        if ((unint64_t)(v66 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_131;
        }
        uint64_t v67 = malloc(0x1000uLL);
        if (!v67) {
          goto LABEL_293;
        }
        uint64_t v66 = 0;
        void *v67 = v65;
        v67[1] = 0;
        uint64_t v65 = v67;
        *(void *)(a1 + 4904) = v67;
LABEL_131:
        v65[1] = v66 + 32;
        unint64_t v68 = (char *)v65 + v66;
        v68[24] = 65;
        *(_WORD *)(v68 + 25) = *(_WORD *)(v68 + 25) & 0xF000 | (v64 >> 1) | 0x540;
        *((void *)v68 + 2) = &unk_1EC9A1BB0;
        *((void *)v68 + 4) = v63;
        v68[40] = v8;
        v68[41] = v64 & 1;
        return;
      case 7u:
        if (!(void)v159) {
          return;
        }
        uint64_t v69 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        pid_t v70 = (char *)(a1 + 40);
        while (2)
        {
          uint64_t v73 = *(unsigned __int16 **)a1;
          if (*(void *)a1 != *(void *)(a1 + 8) && *(unsigned char *)v73 == 69)
          {
            *(void *)a1 = (char *)v73 + 1;
            v162.n128_u64[1] = v123;
            return;
          }
          if (!v74) {
            return;
          }
          uint64_t v75 = v74;
          uint64_t v72 = *(char **)(a1 + 24);
          if (v72 != *(char **)(a1 + 32)) {
            goto LABEL_136;
          }
          uint64_t v76 = *(char **)(a1 + 16);
          int64_t v77 = v72 - v76;
          if (v76 == v70)
          {
            int v78 = (char *)malloc(2 * (v72 - v76));
            if (v78)
            {
              size_t v71 = v78;
              if (v72 != v70) {
                memcpy(v78, (const void *)(a1 + 40), v77);
              }
              *(void *)(a1 + 16) = v71;
              goto LABEL_135;
            }
          }
          else
          {
            size_t v71 = (char *)realloc(v76, 2 * (v72 - v76));
            *(void *)(a1 + 16) = v71;
            if (v71)
            {
LABEL_135:
              uint64_t v72 = &v71[8 * (v77 >> 3)];
              *(void *)(a1 + 32) = &v71[8 * (v77 >> 2)];
LABEL_136:
              *(void *)(a1 + 24) = v72 + 8;
              *(void *)uint64_t v72 = v75;
              continue;
            }
          }
          goto LABEL_292;
        }
      case 8u:
        char v79 = *(unsigned char *)(a1 + 776);
        *(unsigned char *)(a1 + 776) = 0;
        *(void *)&long long v159 = v80;
        *(unsigned char *)(a1 + 776) = v79;
        if (!v80) {
          return;
        }
        uint64_t v81 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        uint64_t v82 = *(unsigned __int16 **)a1;
        __n128 v83 = *(unsigned __int16 **)(a1 + 8);
        if (*(unsigned __int16 **)a1 == v83) {
          goto LABEL_230;
        }
        int v84 = *(unsigned __int8 *)v82;
        if (v84 == 95)
        {
          uint64_t v82 = (unsigned __int16 *)((char *)v82 + 1);
          *(void *)a1 = v82;
          char v85 = (char *)(a1 + 40);
          while (v82 == v83 || *(unsigned char *)v82 != 69)
          {
            if (!v90) {
              return;
            }
            uint64_t v91 = v90;
            long long v89 = *(char **)(a1 + 24);
            if (v89 == *(char **)(a1 + 32))
            {
              uint64_t v92 = *(char **)(a1 + 16);
              int64_t v93 = v89 - v92;
              if (v92 == v85)
              {
                int v94 = (char *)malloc(2 * (v89 - v92));
                if (!v94) {
                  goto LABEL_292;
                }
                unsigned int v88 = v94;
                if (v89 != v85) {
                  memcpy(v94, (const void *)(a1 + 40), v93);
                }
                *(void *)(a1 + 16) = v88;
              }
              else
              {
                unsigned int v88 = (char *)realloc(v92, 2 * (v89 - v92));
                *(void *)(a1 + 16) = v88;
                if (!v88) {
                  goto LABEL_292;
                }
              }
              long long v89 = &v88[8 * (v93 >> 3)];
              *(void *)(a1 + 32) = &v88[8 * (v93 >> 2)];
            }
            *(void *)(a1 + 24) = v89 + 8;
            *(void *)long long v89 = v91;
            uint64_t v82 = *(unsigned __int16 **)a1;
            __n128 v83 = *(unsigned __int16 **)(a1 + 8);
          }
LABEL_228:
          *(void *)a1 = (char *)v82 + 1;
          v162.n128_u64[1] = v126;
          if (v84 == 95) {
            goto LABEL_251;
          }
          goto LABEL_250;
        }
        if (v84 == 69) {
          goto LABEL_228;
        }
LABEL_230:
        if (!v127) {
          return;
        }
        uint64_t v128 = v127;
        unint64_t v129 = *(char **)(a1 + 24);
        if (v129 != *(char **)(a1 + 32)) {
          goto LABEL_249;
        }
        unint64_t v130 = *(unsigned char **)(a1 + 16);
        int64_t v131 = v129 - v130;
        if (v130 == (unsigned char *)(a1 + 40))
        {
          unint64_t v135 = (char *)malloc(2 * (v129 - v130));
          if (!v135) {
            goto LABEL_292;
          }
          uint64_t v132 = v135;
          if (v129 != (char *)(a1 + 40)) {
            memcpy(v135, (const void *)(a1 + 40), v131);
          }
          *(void *)(a1 + 16) = v132;
        }
        else
        {
          uint64_t v132 = (char *)realloc(v130, 2 * (v129 - v130));
          *(void *)(a1 + 16) = v132;
          if (!v132) {
LABEL_292:
          }
            abort();
        }
        unint64_t v129 = &v132[8 * (v131 >> 3)];
        *(void *)(a1 + 32) = &v132[8 * (v131 >> 2)];
LABEL_249:
        *(void *)(a1 + 24) = v129 + 8;
        *(void *)unint64_t v129 = v128;
        v162.n128_u64[1] = v126;
LABEL_250:
        if (v126 != 1) {
          return;
        }
LABEL_251:
        return;
      case 9u:
        if (v162.n128_u64[0])
        {
          if ((void)v159)
          {
            if (v161) {
          }
            }
        }
        return;
      case 0xAu:
        return;
      case 0xBu:
        if (v162.n128_u64[0])
        {
          if ((void)v159) {
        }
          }
        return;
      case 0xCu:
        unsigned int v86 = v15[3];
        if (v86) {
        else
        }
        uint64_t v96 = v87;
        if (!v87) {
          return;
        }
        uint64_t v97 = *(void **)(a1 + 4904);
        uint64_t v98 = v97[1];
        if ((unint64_t)(v98 - 4016) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_185;
        }
        std::string v99 = malloc(0x1000uLL);
        if (!v99) {
          goto LABEL_293;
        }
        uint64_t v98 = 0;
        *std::string v99 = v97;
        v99[1] = 0;
        uint64_t v97 = v99;
        *(void *)(a1 + 4904) = v99;
LABEL_185:
        v97[1] = v98 + 64;
        uint64_t v100 = (char *)v97 + v98;
        v100[24] = 60;
        *(_WORD *)(v100 + 25) = *(_WORD *)(v100 + 25) & 0xF000 | (v86 >> 1) | 0x540;
        *((void *)v100 + 2) = &unk_1EC9A2290;
        *((void *)v100 + 4) = v21;
        *((void *)v100 + 5) = v20;
        *((void *)v100 + 7) = 0;
        *((void *)v100 + 8) = 0;
        *((void *)v100 + 6) = v96;
        return;
      default:
        unsigned int v35 = v15[3];
        if (!v36) {
          return;
        }
        uint64_t v37 = v36;
        uint64_t v38 = *(void **)(a1 + 4904);
        uint64_t v39 = v38[1];
        if ((unint64_t)(v39 - 4032) > 0xFFFFFFFFFFFFF00FLL) {
          goto LABEL_74;
        }
        uint64_t v40 = malloc(0x1000uLL);
        if (!v40) {
          goto LABEL_293;
        }
        uint64_t v39 = 0;
        *uint64_t v40 = v38;
        v40[1] = 0;
        uint64_t v38 = v40;
        *(void *)(a1 + 4904) = v40;
LABEL_74:
        v38[1] = v39 + 48;
        uint64_t v41 = (char *)v38 + v39;
        v41[24] = 66;
        *(_WORD *)(v41 + 25) = *(_WORD *)(v41 + 25) & 0xF000 | (v35 >> 1) | 0x540;
        *((void *)v41 + 2) = &unk_1EC9A1D68;
        *((void *)v41 + 4) = v21;
        *((void *)v41 + 5) = v20;
        *((void *)v41 + 6) = v37;
        return;
    }
  }
  switch(v11)
  {
    case 'f':
      int v23 = *v10;
      if (v23 != 112)
      {
        if (v23 != 76) {
          goto LABEL_80;
        }
        if (v4 < 3)
        {
          uint64_t v24 = 0;
        }
        else
        {
          if ((char)v2[1] < 0) {
            goto LABEL_80;
          }
          uint64_t v24 = *((unsigned __int8 *)v2 + 2);
        }
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x400) == 0)
        {
LABEL_80:
          if (v2 != v3)
          {
            *(void *)a1 = v10;
            if (v3 != (unsigned __int16 *)v10)
            {
              unsigned int v42 = (char)*v10 - 76;
              if (v42 <= 0x26 && ((0x4100000041uLL >> v42) & 1) != 0)
              {
                *(void *)a1 = v2 + 1;
                if ((unint64_t)((char *)v3 - (char *)(v2 + 1)) >= 2)
                {
                  unint64_t v43 = 0;
                  unint64_t v44 = (0x3FFFFFFFBFuLL >> v42) & 1;
                  unint64_t v45 = 0x3EFFFFFFFFuLL >> v42;
                  int v46 = *((unsigned __int8 *)v2 + 2);
                  uint64_t v47 = 61;
                  do
                  {
                    unint64_t v48 = (v43 + v47) >> 1;
                        + 16 * v48;
                    if (*v49 < (char)v46)
                    {
                      unint64_t v43 = v48 + 1;
                    }
                    else if (*v49 == v46)
                    {
                      if (v49[1] >= *((char *)v2 + 3)) {
                        uint64_t v47 = (v43 + v47) >> 1;
                      }
                      else {
                        unint64_t v43 = v48 + 1;
                      }
                    }
                    else
                    {
                      uint64_t v47 = (v43 + v47) >> 1;
                    }
                  }
                  while (v47 != v43);
                       + 16 * v43;
                  if (*v118 == v46 && v118[1] == *((unsigned __int8 *)v2 + 3))
                  {
                    *(void *)a1 = v2 + 2;
                    int v119 = v118[2];
                    if (v119 == 2
                      || v119 == 4 && *(unsigned char *)(strlen(*((const char **)v118 + 1)) + *((void *)v118 + 1) - 1) == 42)
                    {
                      if (v120)
                      {
                        uint64_t v121 = v120;
                        if (v45)
                        {
                          if (!v144) {
                            return;
                          }
                          if (v44) {
                            uint64_t v122 = v121;
                          }
                          else {
                            uint64_t v122 = v144;
                          }
                          if (v44) {
                            uint64_t v121 = v144;
                          }
                        }
                        else
                        {
                          uint64_t v122 = 0;
                        }
                        uint64_t v145 = (const char *)*((void *)v118 + 1);
                        size_t v146 = strlen(v145);
                        uint64_t v147 = v145 + 8;
                        if (v146 == 8)
                        {
                          size_t v150 = 0;
                        }
                        else
                        {
                          int v148 = *(unsigned __int8 *)v147;
                          uint64_t v149 = v145 + 9;
                          if (v148 == 32) {
                            size_t v150 = v146 - 9;
                          }
                          else {
                            size_t v150 = v146 - 8;
                          }
                          if (v148 == 32) {
                            uint64_t v147 = v149;
                          }
                        }
                        uint64_t v151 = *(void **)(a1 + 4904);
                        uint64_t v152 = v151[1];
                        if ((unint64_t)(v152 - 4016) <= 0xFFFFFFFFFFFFF00FLL)
                        {
                          int v153 = malloc(0x1000uLL);
                          if (!v153) {
LABEL_293:
                          }
                            std::terminate();
                          uint64_t v152 = 0;
                          *int v153 = v151;
                          v153[1] = 0;
                          uint64_t v151 = v153;
                          *(void *)(a1 + 4904) = v153;
                        }
                        v151[1] = v152 + 64;
                        char v154 = (char *)v151 + v152;
                        v154[24] = 71;
                        *(_WORD *)(v154 + 25) = *(_WORD *)(v154 + 25) & 0xF000 | 0x540;
                        *((void *)v154 + 2) = &unk_1EC9A35D0;
                        *((void *)v154 + 4) = v121;
                        *((void *)v154 + 5) = v122;
                        *((void *)v154 + 6) = v147;
                        *((void *)v154 + 7) = v150;
                        v154[64] = v44;
                      }
                    }
                  }
                }
              }
            }
          }
          return;
        }
      }
      return;
    case 'T':
      return;
    case 'L':
      return;
  }
  if (*v2 == 27753)
  {
    unint64_t v25 = v2 + 1;
    *(void *)a1 = v2 + 1;
    uint64_t v26 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    uint64_t v27 = (char *)(a1 + 40);
    while (v25 == v3 || *(unsigned char *)v25 != 69)
    {
      if (!v30) {
        return;
      }
      uint64_t v31 = v30;
      uint64_t v29 = *(char **)(a1 + 24);
      if (v29 == *(char **)(a1 + 32))
      {
        unint64_t v32 = *(char **)(a1 + 16);
        int64_t v33 = v29 - v32;
        if (v32 == v27)
        {
          uint64_t v34 = (char *)malloc(2 * (v29 - v32));
          if (!v34) {
            goto LABEL_292;
          }
          uint64_t v28 = v34;
          if (v29 != v27) {
            memcpy(v34, (const void *)(a1 + 40), v33);
          }
          *(void *)(a1 + 16) = v28;
        }
        else
        {
          uint64_t v28 = (char *)realloc(v32, 2 * (v29 - v32));
          *(void *)(a1 + 16) = v28;
          if (!v28) {
            goto LABEL_292;
          }
        }
        uint64_t v29 = &v28[8 * (v33 >> 3)];
        *(void *)(a1 + 32) = &v28[8 * (v33 >> 2)];
      }
      *(void *)(a1 + 24) = v29 + 8;
      *(void *)uint64_t v29 = v31;
      unint64_t v25 = *(unsigned __int16 **)a1;
      uint64_t v3 = *(unsigned __int16 **)(a1 + 8);
    }
    *(void *)a1 = (char *)v25 + 1;
    v162.n128_u64[1] = v50;
    return;
  }
  if ((unint64_t)((char *)v3 - (char *)v2) >= 2)
  {
    if (*v2 == 25453)
    {
      *(void *)a1 = v2 + 1;
      return;
    }
    if (*v2 == 30830)
    {
      *(void *)a1 = v2 + 1;
      if (v162.n128_u64[0]) {
      return;
      }
    }
  }
  if (v3 != v2 && (unint64_t)((char *)v3 - (char *)v2) >= 2 && v11 == 114 && (*v10 | 0x20) == 0x71)
  {
    return;
  }
  {
    return;
  }
  {
    if (v162.n128_u64[0]) {
    return;
    }
  }
  {
    if (*(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 84)
    {
      if (v162.n128_u64[0]) {
      return;
      }
    }
    v162.n128_u64[0] = v117;
    if (!v117) {
      return;
    }
LABEL_240:
    return;
  }
  {
    {
      if (v160.n128_u64[0])
      {
        uint64_t v124 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        long long v125 = *(unsigned __int16 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8)) {
          goto LABEL_224;
        }
LABEL_223:
        if (*(unsigned char *)v125 == 69)
        {
          *(void *)a1 = (char *)v125 + 1;
          v162.n128_u64[1] = v143;
        }
        else
        {
LABEL_224:
          while (1)
          {
            v162.n128_u64[0] = 0;
            if (!v162.n128_u64[0]) {
              break;
            }
            llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 16), (uint64_t *)&v162);
            long long v125 = *(unsigned __int16 **)a1;
            if (*(void *)a1 != *(void *)(a1 + 8)) {
              goto LABEL_223;
            }
          }
        }
      }
      return;
    }
    {
      return;
    }
    {
      if (v162.n128_u64[0]) {
      return;
      }
    }
    int32x4_t v136 = *(unsigned __int16 **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *(unsigned char *)v136 != 117)
    {
      return;
    }
    *(void *)a1 = (char *)v136 + 1;
    v160.n128_u64[0] = (unint64_t)v137;
    if (!v137) {
      return;
    }
    *(void *)&long long v159 = 0;
    int8x8_t v138 = (void *)(*(uint64_t (**)(char *))(*(void *)v137 + 48))(v137);
    if (v139 == 8 && *v138 == 0x666F646975755F5FLL)
    {
      uint64_t v156 = *(unsigned __int16 **)a1;
      if (*(void *)a1 != *(void *)(a1 + 8))
      {
        int v157 = *(unsigned __int8 *)v156;
        if (v157 == 122)
        {
          *(void *)a1 = (char *)v156 + 1;
          goto LABEL_290;
        }
        if (v157 == 116)
        {
          *(void *)a1 = (char *)v156 + 1;
LABEL_290:
          *(void *)&long long v159 = v158;
          if (!v158) {
            return;
          }
          uint64_t v140 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
          llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 16), (uint64_t *)&v159);
          goto LABEL_284;
        }
      }
    }
    uint64_t v140 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
    int v141 = *(unsigned __int16 **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8)) {
      goto LABEL_259;
    }
LABEL_258:
    if (*(unsigned char *)v141 != 69)
    {
LABEL_259:
      while (1)
      {
        v162.n128_u64[0] = 0;
        v162.n128_u64[0] = v142;
        if (!v142) {
          return;
        }
        llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 16), (uint64_t *)&v162);
        int v141 = *(unsigned __int16 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8)) {
          goto LABEL_258;
        }
      }
    }
    *(void *)a1 = (char *)v141 + 1;
LABEL_284:
    v162.n128_u64[1] = v155;
    return;
  }
  uint64_t v101 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  char v102 = *(unsigned __int16 **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8)) {
    goto LABEL_189;
  }
LABEL_188:
  if (*(unsigned char *)v102 == 69)
  {
    *(void *)a1 = (char *)v102 + 1;
    v162.n128_u64[1] = v133;
    v162.n128_u64[0] = v134;
    goto LABEL_240;
  }
LABEL_189:
  while (1)
  {
    v162.n128_u64[0] = 0;
    v162.n128_u64[0] = v103;
    if (!v103) {
      break;
    }
    llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,32ul>::push_back((void *)(a1 + 16), (uint64_t *)&v162);
    char v102 = *(unsigned __int16 **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8)) {
      goto LABEL_188;
    }
  }
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PostfixExpr,llvm::itanium_demangle::Node *&,std::string_view &,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, __n128 *a3, char a4)
{
  BOOL v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    char v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *char v10 = v7;
    v10[1] = 0;
    BOOL v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 48;
  int v11 = (char *)v7 + v8;
  uint64_t v12 = *a2;
  v11[24] = 56;
  __int16 v13 = *(_WORD *)(v11 + 25) & 0xF000 | a4 & 0x3F | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A1EC8;
  __n128 result = *a3;
  *(_WORD *)(v11 + 25) = v13;
  *((void *)v11 + 4) = v12;
  *(__n128 *)(v11 + 40) = result;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ArraySubscriptExpr,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4)
{
  BOOL v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    char v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *char v10 = v7;
    v10[1] = 0;
    BOOL v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 32;
  int v11 = (char *)v7 + v8;
  __n128 result = v11 + 16;
  uint64_t v13 = *a2;
  uint64_t v14 = *a3;
  v11[24] = 55;
  *(_WORD *)(v11 + 25) = *(_WORD *)(v11 + 25) & 0xF000 | a4 & 0x3F | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A2B80;
  *((void *)v11 + 4) = v13;
  *((void *)v11 + 5) = v14;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::MemberExpr,llvm::itanium_demangle::Node *&,std::string_view &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, __n128 *a3, uint64_t *a4, char a5)
{
  unint64_t v9 = *(void **)(a1 + 4904);
  uint64_t v10 = v9[1];
  if ((unint64_t)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v12 = malloc(0x1000uLL);
    if (!v12) {
      std::terminate();
    }
    uint64_t v10 = 0;
    *uint64_t v12 = v9;
    v12[1] = 0;
    unint64_t v9 = v12;
    *(void *)(a1 + 4904) = v12;
  }
  v9[1] = v10 + 48;
  uint64_t v13 = (char *)v9 + v10;
  uint64_t v14 = *a2;
  uint64_t v15 = *a4;
  v13[24] = 58;
  __int16 v16 = *(_WORD *)(v13 + 25) & 0xF000 | a5 & 0x3F | 0x540;
  *((void *)v13 + 2) = &unk_1EC9A1C60;
  __n128 result = *a3;
  *(_WORD *)(v13 + 25) = v16;
  *((void *)v13 + 4) = v14;
  *(__n128 *)(v13 + 40) = result;
  *((void *)v13 + 7) = v15;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::NewExpr,llvm::itanium_demangle::NodeArray &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray &,BOOL &,BOOL,llvm::itanium_demangle::Node::Prec>(uint64_t a1, __n128 *a2, uint64_t *a3, long long *a4, char a5, char a6, char a7)
{
  uint64_t v13 = *(void **)(a1 + 4904);
  uint64_t v14 = v13[1];
  if ((unint64_t)(v14 - 4016) <= 0xFFFFFFFFFFFFF00FLL)
  {
    __int16 v16 = malloc(0x1000uLL);
    if (!v16) {
      std::terminate();
    }
    uint64_t v14 = 0;
    *__int16 v16 = v13;
    v16[1] = 0;
    uint64_t v13 = v16;
    *(void *)(a1 + 4904) = v16;
  }
  v13[1] = v14 + 64;
  unsigned int v17 = (char *)v13 + v14;
  uint64_t v18 = *a3;
  v17[24] = 64;
  __int16 v19 = *(_WORD *)(v17 + 25) & 0xF000 | a7 & 0x3F;
  *((void *)v17 + 2) = &unk_1EC9A3418;
  __n128 result = *a2;
  long long v21 = *a4;
  *(_WORD *)(v17 + 25) = v19 | 0x540;
  *((__n128 *)v17 + 2) = result;
  *((void *)v17 + 6) = v18;
  *(_OWORD *)(v17 + 56) = v21;
  v17[72] = a5 != 0;
  v17[73] = a6 != 0;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::CallExpr,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, __n128 *a3, char a4)
{
  BOOL v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *uint64_t v10 = v7;
    v10[1] = 0;
    BOOL v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 48;
  int v11 = (char *)v7 + v8;
  uint64_t v12 = *a2;
  v11[24] = 63;
  __int16 v13 = *(_WORD *)(v11 + 25) & 0xF000 | a4 & 0x3F | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A34C8;
  __n128 result = *a3;
  *(_WORD *)(v11 + 25) = v13;
  *((void *)v11 + 4) = v12;
  *(__n128 *)(v11 + 40) = result;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ConversionExpr,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray &,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, __n128 *a3, char a4)
{
  BOOL v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *uint64_t v10 = v7;
    v10[1] = 0;
    BOOL v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 48;
  int v11 = (char *)v7 + v8;
  uint64_t v12 = *a2;
  v11[24] = 68;
  __int16 v13 = *(_WORD *)(v11 + 25) & 0xF000 | a4 & 0x3F | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A25A8;
  __n128 result = *a3;
  *(_WORD *)(v11 + 25) = v13;
  *((void *)v11 + 4) = v12;
  *(__n128 *)(v11 + 40) = result;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ConditionalExpr,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, char a5)
{
  unint64_t v9 = *(void **)(a1 + 4904);
  uint64_t v10 = v9[1];
  if ((unint64_t)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v12 = malloc(0x1000uLL);
    if (!v12) {
      std::terminate();
    }
    uint64_t v10 = 0;
    *uint64_t v12 = v9;
    v12[1] = 0;
    unint64_t v9 = v12;
    *(void *)(a1 + 4904) = v12;
  }
  v9[1] = v10 + 48;
  __int16 v13 = (char *)v9 + v10;
  __n128 result = v13 + 16;
  uint64_t v15 = *a2;
  uint64_t v16 = *a3;
  uint64_t v17 = *a4;
  v13[24] = 57;
  *(_WORD *)(v13 + 25) = *(_WORD *)(v13 + 25) & 0xF000 | a5 & 0x3F | 0x540;
  *((void *)v13 + 2) = &unk_1EC9A2708;
  *((void *)v13 + 4) = v15;
  *((void *)v13 + 5) = v16;
  *((void *)v13 + 6) = v17;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::CastExpr,std::string_view &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec>(uint64_t a1, __n128 *a2, uint64_t *a3, uint64_t *a4, char a5)
{
  unint64_t v9 = *(void **)(a1 + 4904);
  uint64_t v10 = v9[1];
  if ((unint64_t)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v12 = malloc(0x1000uLL);
    if (!v12) {
      std::terminate();
    }
    uint64_t v10 = 0;
    *uint64_t v12 = v9;
    v12[1] = 0;
    unint64_t v9 = v12;
    *(void *)(a1 + 4904) = v12;
  }
  v9[1] = v10 + 48;
  __int16 v13 = (char *)v9 + v10;
  uint64_t v14 = *a3;
  uint64_t v15 = *a4;
  v13[24] = 61;
  __int16 v16 = *(_WORD *)(v13 + 25) & 0xF000 | a5 & 0x3F | 0x540;
  *((void *)v13 + 2) = &unk_1EC9A3520;
  __n128 result = *a2;
  *(_WORD *)(v13 + 25) = v16;
  *((__n128 *)v13 + 2) = result;
  *((void *)v13 + 6) = v14;
  *((void *)v13 + 7) = v15;
  return result;
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseExprPrimary(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)a1;
  size_t v2 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 != v2 && *v1 == 76)
  {
    uint64_t v3 = (void *)a1;
    unint64_t v4 = v1 + 1;
    *(void *)a1 = v1 + 1;
    unint64_t v5 = v2 - (v1 + 1);
    if (v2 == v1 + 1)
    {
LABEL_10:
      if (v34)
      {
        uint64_t v8 = (unsigned char *)*v3;
        BOOL v7 = (unsigned char *)v3[1];
        if ((unsigned char *)*v3 != v7)
        {
          unint64_t v9 = (unsigned char *)*v3;
          if (*v8 == 110)
          {
            unint64_t v9 = v8 + 1;
            void *v3 = v8 + 1;
          }
          if (v7 != v9 && ((char)*v9 & 0x80000000) == 0)
          {
            uint64_t v10 = MEMORY[0x1E4F14390];
            if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v9 + 60) & 0x400) != 0)
            {
              while (((char)*v9 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 4 * *v9 + 60) & 0x400) != 0)
              {
                void *v3 = ++v9;
                if (v9 == v7)
                {
                  unint64_t v9 = v7;
                  break;
                }
              }
              v33.n128_u64[0] = (unint64_t)v8;
              v33.n128_u64[1] = v9 - v8;
              if (v9 != v8 && v9 != v7 && *v9 == 69)
              {
                void *v3 = v9 + 1;
              }
            }
          }
        }
      }
    }
    else
    {
      switch(*(unsigned char *)v4)
      {
        case 'A':
          if (v33.n128_u64[0])
          {
            int v6 = (unsigned char *)*v3;
            if (*v3 != v3[1] && *v6 == 69)
            {
              void *v3 = v6 + 1;
            }
          }
          return;
        case 'D':
          if (v5 >= 2 && *v4 == 28228)
          {
            uint64_t v17 = v1 + 3;
            *(void *)a1 = v1 + 3;
            if (v1 + 3 != v2)
            {
              if (*v17 == 48)
              {
                uint64_t v17 = v1 + 4;
                *(void *)a1 = v1 + 4;
              }
              if (v17 != v2 && *v17 == 69)
              {
                *(void *)a1 = v17 + 1;
              }
            }
          }
          return;
        case 'T':
          return;
        case 'U':
          if (v5 >= 2 && v1[2] == 108)
          {
            if (v33.n128_u64[0])
            {
              __int16 v19 = (unsigned char *)*v3;
              if (*v3 != v3[1] && *v19 == 69)
              {
                void *v3 = v19 + 1;
              }
            }
          }
          return;
        case '_':
          if (v5 >= 2 && *v4 == 23135)
          {
            *(void *)a1 = v1 + 3;
            {
              uint64_t v18 = (unsigned char *)*v3;
              if (*v3 != v3[1] && *v18 == 69) {
                void *v3 = v18 + 1;
              }
            }
          }
          return;
        case 'a':
          *(void *)a1 = v1 + 2;
          int v11 = "signed char";
          uint64_t v12 = 11;
          goto LABEL_27;
        case 'b':
          if (v5 >= 3 && (*v4 == 12386 ? (BOOL v20 = v1[3] == 69) : (BOOL v20 = 0), v20))
          {
            *(void *)a1 = v1 + 4;
            int v21 = 0;
          }
          else
          {
            a1 = (uint64_t)v3;
            int v21 = 1;
          }
          break;
        case 'c':
          *(void *)a1 = v1 + 2;
          int v11 = "char";
          uint64_t v12 = 4;
          goto LABEL_27;
        case 'd':
          *(void *)a1 = v1 + 2;
          if ((unint64_t)(v2 - (v1 + 2)) < 0x11) {
            return;
          }
          if ((char)v1[2] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[2] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[3] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[3] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[4] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[4] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[5] < 0) {
            return;
          }
          unint64_t v32 = v1 + 2;
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[5] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[6] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[6] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[7] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[7] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[8] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[8] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[9] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[9] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[10] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[10] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[11] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[11] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[12] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[12] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[13] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[13] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[14] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[14] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[15] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[15] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[16] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[16] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[17] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[17] + 60) & 0x10000) == 0) {
            return;
          }
          *(void *)a1 = v1 + 18;
          if (v1 + 18 == v2 || v1[18] != 69) {
            return;
          }
          *(void *)a1 = v1 + 19;
          uint64_t v26 = *(void **)(a1 + 4904);
          uint64_t v27 = v26[1];
          if ((unint64_t)(v27 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
            goto LABEL_219;
          }
          uint64_t v28 = malloc(0x1000uLL);
          if (!v28) {
            goto LABEL_233;
          }
          uint64_t v27 = 0;
          void *v28 = v26;
          v28[1] = 0;
          uint64_t v26 = v28;
          v3[613] = v28;
LABEL_219:
          v26[1] = v27 + 32;
          uint64_t v29 = (char *)v26 + v27;
          v29[24] = 79;
          *(_WORD *)(v29 + 25) = *(_WORD *)((unsigned char *)v26 + v27 + 25) & 0xF000 | 0x540;
          *((void *)v29 + 2) = &unk_1EC9A2970;
          *((void *)v29 + 4) = v32;
          *((void *)v29 + 5) = 16;
          return;
        case 'e':
          *(void *)a1 = v1 + 2;
          if ((unint64_t)(v2 - (v1 + 2)) < 0x21) {
            return;
          }
          if ((char)v1[2] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[2] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[3] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[3] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[4] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[4] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[5] < 0) {
            return;
          }
          uint64_t v31 = v1 + 2;
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[5] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[6] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[6] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[7] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[7] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[8] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[8] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[9] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[9] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[10] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[10] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[11] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[11] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[12] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[12] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[13] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[13] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[14] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[14] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[15] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[15] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[16] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[16] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[17] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[17] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[18] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[18] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[19] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[19] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[20] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[20] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[21] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[21] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[22] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[22] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[23] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[23] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[24] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[24] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[25] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[25] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[26] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[26] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[27] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[27] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[28] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[28] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[29] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[29] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[30] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[30] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[31] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[31] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[32] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[32] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[33] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[33] + 60) & 0x10000) == 0) {
            return;
          }
          *(void *)a1 = v1 + 34;
          if (v1 + 34 == v2 || v1[34] != 69) {
            return;
          }
          *(void *)a1 = v1 + 35;
          int v22 = *(void **)(a1 + 4904);
          uint64_t v23 = v22[1];
          if ((unint64_t)(v23 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
            goto LABEL_180;
          }
          uint64_t v24 = malloc(0x1000uLL);
          if (!v24) {
            goto LABEL_233;
          }
          uint64_t v23 = 0;
          *uint64_t v24 = v22;
          v24[1] = 0;
          int v22 = v24;
          v3[613] = v24;
LABEL_180:
          v22[1] = v23 + 32;
          unint64_t v25 = (char *)v22 + v23;
          v25[24] = 80;
          *(_WORD *)(v25 + 25) = *(_WORD *)((unsigned char *)v22 + v23 + 25) & 0xF000 | 0x540;
          *((void *)v25 + 2) = &unk_1EC9A29C8;
          *((void *)v25 + 4) = v31;
          *((void *)v25 + 5) = 32;
          return;
        case 'f':
          *(void *)a1 = v1 + 2;
          if ((unint64_t)(v2 - (v1 + 2)) < 9) {
            return;
          }
          if ((char)v1[2] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[2] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[3] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[3] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[4] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[4] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[5] < 0) {
            return;
          }
          uint64_t v30 = v1 + 2;
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[5] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[6] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[6] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[7] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[7] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[8] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[8] + 60) & 0x10000) == 0) {
            return;
          }
          if ((char)v1[9] < 0) {
            return;
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v1[9] + 60) & 0x10000) == 0) {
            return;
          }
          *(void *)a1 = v1 + 10;
          if (v1 + 10 == v2 || v1[10] != 69) {
            return;
          }
          *(void *)a1 = v1 + 11;
          __int16 v13 = *(void **)(a1 + 4904);
          uint64_t v14 = v13[1];
          if ((unint64_t)(v14 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
            goto LABEL_52;
          }
          uint64_t v15 = malloc(0x1000uLL);
          if (!v15) {
LABEL_233:
          }
            std::terminate();
          uint64_t v14 = 0;
          *uint64_t v15 = v13;
          v15[1] = 0;
          __int16 v13 = v15;
          v3[613] = v15;
LABEL_52:
          v13[1] = v14 + 32;
          __int16 v16 = (char *)v13 + v14;
          v16[24] = 78;
          *(_WORD *)(v16 + 25) = *(_WORD *)((unsigned char *)v13 + v14 + 25) & 0xF000 | 0x540;
          *((void *)v16 + 2) = &unk_1EC9A2A20;
          *((void *)v16 + 4) = v30;
          *((void *)v16 + 5) = 8;
          return;
        case 'h':
          *(void *)a1 = v1 + 2;
          int v11 = "unsigned char";
          uint64_t v12 = 13;
          goto LABEL_27;
        case 'i':
          *(void *)a1 = v1 + 2;
          int v11 = "";
          uint64_t v12 = 0;
          goto LABEL_27;
        case 'j':
          *(void *)a1 = v1 + 2;
          int v11 = "u";
          goto LABEL_103;
        case 'l':
          *(void *)a1 = v1 + 2;
          int v11 = "l";
LABEL_103:
          uint64_t v12 = 1;
          goto LABEL_27;
        case 'm':
          *(void *)a1 = v1 + 2;
          int v11 = "ul";
          goto LABEL_107;
        case 'n':
          *(void *)a1 = v1 + 2;
          int v11 = "__int128";
          uint64_t v12 = 8;
          goto LABEL_27;
        case 'o':
          *(void *)a1 = v1 + 2;
          int v11 = "unsigned __int128";
          uint64_t v12 = 17;
          goto LABEL_27;
        case 's':
          *(void *)a1 = v1 + 2;
          int v11 = "short";
          uint64_t v12 = 5;
          goto LABEL_27;
        case 't':
          *(void *)a1 = v1 + 2;
          int v11 = "unsigned short";
          uint64_t v12 = 14;
          goto LABEL_27;
        case 'w':
          *(void *)a1 = v1 + 2;
          int v11 = "wchar_t";
          uint64_t v12 = 7;
          goto LABEL_27;
        case 'x':
          *(void *)a1 = v1 + 2;
          int v11 = "ll";
LABEL_107:
          uint64_t v12 = 2;
          goto LABEL_27;
        case 'y':
          *(void *)a1 = v1 + 2;
          int v11 = "ull";
          uint64_t v12 = 3;
LABEL_27:
          return;
        default:
          goto LABEL_10;
      }
    }
  }
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseFunctionParam(uint64_t *a1)
{
  uint64_t v3 = *a1;
  size_t v2 = (char *)a1[1];
  unint64_t v4 = (unint64_t)&v2[-*a1];
  if (v4 >= 3)
  {
    if (*(_WORD *)v3 == 28774 && *(unsigned char *)(v3 + 2) == 84)
    {
      *a1 = v3 + 3;
      __int16 v16 = (void *)a1[613];
      uint64_t v17 = v16[1];
      if ((unint64_t)(v17 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v18 = malloc(0x1000uLL);
        if (!v18) {
          goto LABEL_73;
        }
        uint64_t v17 = 0;
        *uint64_t v18 = v16;
        v18[1] = 0;
        __int16 v16 = v18;
        a1[613] = (uint64_t)v18;
      }
      v16[1] = v17 + 32;
      __int16 v19 = (char *)v16 + v17;
      unsigned char v19[24] = 8;
      *(_WORD *)(v19 + 25) = *(_WORD *)(v19 + 25) & 0xF000 | 0x540;
      *((void *)v19 + 2) = &unk_1EC9A3628;
      *((void *)v19 + 4) = "this";
      *((void *)v19 + 5) = 4;
      return;
    }
  }
  else if (v4 != 2)
  {
    return;
  }
  if (*(_WORD *)v3 != 28774)
  {
    if (*(_WORD *)v3 == 19558)
    {
      int v6 = (unsigned __int8 *)(v3 + 2);
      *a1 = (uint64_t)v6;
      if (v2 != (char *)v6 && ((char)*v6 & 0x80000000) == 0)
      {
        uint64_t v7 = MEMORY[0x1E4F14390];
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v6 + 60) & 0x400) != 0)
        {
          uint64_t v8 = v6;
          while (((char)*v8 & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * *v8 + 60) & 0x400) != 0)
          {
            *a1 = (uint64_t)++v8;
            if (v8 == (unsigned __int8 *)v2)
            {
              uint64_t v8 = (unsigned __int8 *)v2;
              break;
            }
          }
          if (v8 != v6 && v8 != (unsigned __int8 *)v2 && *v8 == 112)
          {
            unint64_t v9 = (char *)(v8 + 1);
            *a1 = (uint64_t)(v8 + 1);
            if (v8 + 1 != (unsigned __int8 *)v2)
            {
              if (*v9 == 114)
              {
                unint64_t v9 = (char *)(v8 + 2);
                *a1 = (uint64_t)(v8 + 2);
              }
              if (v9 != v2)
              {
                if (*v9 == 86) {
                  *a1 = (uint64_t)++v9;
                }
                if (v9 != v2)
                {
                  if (*v9 == 75) {
                    *a1 = (uint64_t)++v9;
                  }
                  if (v2 != v9)
                  {
                    if ((*v9 & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * *v9 + 60) & 0x400) != 0)
                    {
                      unint64_t v25 = v9;
                      while ((*v25 & 0x80000000) == 0
                           && (*(_DWORD *)(v7 + 4 * *v25 + 60) & 0x400) != 0)
                      {
                        *a1 = (uint64_t)++v25;
                        if (v25 == v2)
                        {
                          unint64_t v25 = v2;
                          break;
                        }
                      }
                      unint64_t v10 = (unint64_t)v9;
                      unint64_t v11 = v25 - v9;
                      unint64_t v9 = v25;
                    }
                    else
                    {
                      unint64_t v10 = 0;
                      unint64_t v11 = 0;
                    }
                    v26.n128_u64[0] = v10;
                    v26.n128_u64[1] = v11;
                    if (v9 != v2 && *v9 == 95)
                    {
                      *a1 = (uint64_t)(v9 + 1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return;
  }
  uint64_t v12 = (char *)(v3 + 2);
  *a1 = v3 + 2;
  if ((char *)(v3 + 2) != v2)
  {
    if (*v12 == 114)
    {
      uint64_t v12 = (char *)(v3 + 3);
      *a1 = v3 + 3;
    }
    if (v12 != v2)
    {
      if (*v12 == 86) {
        *a1 = (uint64_t)++v12;
      }
      if (v12 != v2)
      {
        if (*v12 == 75) {
          *a1 = (uint64_t)++v12;
        }
        if (v2 != v12)
        {
          if ((*v12 & 0x80000000) == 0
            && (uint64_t v13 = MEMORY[0x1E4F14390],
                (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v12 + 60) & 0x400) != 0))
          {
            BOOL v20 = v12;
            while ((*v20 & 0x80000000) == 0 && (*(_DWORD *)(v13 + 4 * *v20 + 60) & 0x400) != 0)
            {
              *a1 = (uint64_t)++v20;
              if (v20 == v2)
              {
                BOOL v20 = v2;
                break;
              }
            }
            uint64_t v14 = v12;
            int64_t v15 = v20 - v12;
            uint64_t v12 = v20;
          }
          else
          {
            uint64_t v14 = 0;
            int64_t v15 = 0;
          }
          if (v12 != v2 && *v12 == 95)
          {
            *a1 = (uint64_t)(v12 + 1);
            int v21 = (void *)a1[613];
            uint64_t v22 = v21[1];
            if ((unint64_t)(v22 - 4048) > 0xFFFFFFFFFFFFF00FLL)
            {
LABEL_62:
              v21[1] = v22 + 32;
              uint64_t v24 = (char *)v21 + v22;
              unsigned char v24[24] = 67;
              *(_WORD *)(v24 + 25) = *(_WORD *)(v24 + 25) & 0xF000 | 0x540;
              *((void *)v24 + 2) = &unk_1EC9A22E8;
              *((void *)v24 + 4) = v14;
              *((void *)v24 + 5) = v15;
              return;
            }
            uint64_t v23 = malloc(0x1000uLL);
            if (v23)
            {
              uint64_t v22 = 0;
              *uint64_t v23 = v21;
              v23[1] = 0;
              int v21 = v23;
              a1[613] = (uint64_t)v23;
              goto LABEL_62;
            }
LABEL_73:
            std::terminate();
          }
        }
      }
    }
  }
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseBracedExpr(uint64_t a1)
{
  size_t v2 = *(unsigned __int8 **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL || *v2 != 100) {
    goto LABEL_13;
  }
  int v3 = (char)v2[1];
  if (v3 == 88)
  {
    *(void *)a1 = v2 + 2;
    if (result)
    {
      unint64_t v11 = result;
      if (result)
      {
        uint64_t v12 = result;
        if (result)
        {
          uint64_t v13 = result;
          uint64_t v14 = *(void **)(a1 + 4904);
          uint64_t v15 = v14[1];
          if ((unint64_t)(v15 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
          {
            __int16 v16 = malloc(0x1000uLL);
            if (!v16) {
              goto LABEL_29;
            }
            uint64_t v15 = 0;
            *__int16 v16 = v14;
            v16[1] = 0;
            uint64_t v14 = v16;
            *(void *)(a1 + 4904) = v16;
          }
          v14[1] = v15 + 48;
          uint64_t v17 = (char *)v14 + v15;
          __n128 result = v17 + 16;
          v17[24] = 82;
          *(_WORD *)(v17 + 25) = *(_WORD *)(v17 + 25) & 0xF000 | 0x540;
          *((void *)v17 + 2) = &unk_1EC9A2658;
          *((void *)v17 + 4) = v11;
          *((void *)v17 + 5) = v12;
          *((void *)v17 + 6) = v13;
          return result;
        }
      }
    }
    return result;
  }
  if (v3 != 120)
  {
    if (v3 == 105)
    {
      *(void *)a1 = v2 + 2;
      if (result)
      {
        unint64_t v5 = result;
        if (result)
        {
          int v6 = result;
          uint64_t v7 = *(void **)(a1 + 4904);
          uint64_t v8 = v7[1];
          if ((unint64_t)(v8 - 4032) > 0xFFFFFFFFFFFFF00FLL)
          {
LABEL_11:
            v7[1] = v8 + 48;
            unint64_t v10 = (char *)v7 + v8;
            __n128 result = v10 + 16;
            v10[24] = 81;
            *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x540;
            *((void *)v10 + 2) = &unk_1EC9A1B58;
            *((void *)v10 + 4) = v5;
            *((void *)v10 + 5) = v6;
            v10[48] = 0;
            return result;
          }
          unint64_t v9 = malloc(0x1000uLL);
          if (v9)
          {
            uint64_t v8 = 0;
            *unint64_t v9 = v7;
            v9[1] = 0;
            uint64_t v7 = v9;
            *(void *)(a1 + 4904) = v9;
            goto LABEL_11;
          }
LABEL_29:
          std::terminate();
        }
      }
      return result;
    }
LABEL_13:
  }
  *(void *)a1 = v2 + 2;
  if (result)
  {
    uint64_t v18 = result;
    if (result)
    {
      __int16 v19 = result;
      BOOL v20 = *(void **)(a1 + 4904);
      uint64_t v21 = v20[1];
      if ((unint64_t)(v21 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v22 = malloc(0x1000uLL);
        if (!v22) {
          goto LABEL_29;
        }
        uint64_t v21 = 0;
        *uint64_t v22 = v20;
        v22[1] = 0;
        BOOL v20 = v22;
        *(void *)(a1 + 4904) = v22;
      }
      v20[1] = v21 + 48;
      uint64_t v23 = (char *)v20 + v21;
      __n128 result = v23 + 16;
      v23[24] = 81;
      *(_WORD *)(v23 + 25) = *(_WORD *)(v23 + 25) & 0xF000 | 0x540;
      *((void *)v23 + 2) = &unk_1EC9A1B58;
      *((void *)v23 + 4) = v18;
      *((void *)v23 + 5) = v19;
      v23[48] = 1;
    }
  }
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::InitListExpr,decltype(nullptr),llvm::itanium_demangle::NodeArray>(uint64_t a1, __n128 *a2)
{
  int v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    int v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  v7[24] = 70;
  __int16 v8 = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A20D8;
  __n128 result = *a2;
  *(_WORD *)(v7 + 25) = v8;
  *((void *)v7 + 4) = 0;
  *(__n128 *)(v7 + 40) = result;
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parsePointerToMemberConversionExpr(char **a1)
{
  if (result)
  {
    uint64_t v3 = result;
    if (result)
    {
      uint64_t v4 = result;
      unint64_t v5 = *a1;
      int v6 = a1[1];
      if (*a1 == v6) {
        return 0;
      }
      uint64_t v7 = *a1;
      if (*v5 == 110)
      {
        uint64_t v7 = v5 + 1;
        *a1 = v5 + 1;
      }
      if (v6 == v7) {
        return 0;
      }
      if ((*v7 & 0x80000000) == 0
        && (uint64_t v8 = MEMORY[0x1E4F14390], (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v7 + 60) & 0x400) != 0))
      {
        while ((*v7 & 0x80000000) == 0 && (*(_DWORD *)(v8 + 4 * *v7 + 60) & 0x400) != 0)
        {
          *a1 = ++v7;
          if (v7 == v6)
          {
            uint64_t v7 = v6;
            break;
          }
        }
        unint64_t v9 = v5;
        int64_t v10 = v7 - v5;
        unint64_t v11 = v7;
        if (v7 == v6) {
          return 0;
        }
      }
      else
      {
        unint64_t v9 = 0;
        int64_t v10 = 0;
        unint64_t v11 = v7;
        if (v7 == v6) {
          return 0;
        }
      }
      if (*v11 != 69) {
        return 0;
      }
      *a1 = v11 + 1;
      uint64_t v12 = a1[613];
      uint64_t v13 = *((void *)v12 + 1);
      if ((unint64_t)(v13 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v14 = (char *)malloc(0x1000uLL);
        if (!v14) {
          std::terminate();
        }
        uint64_t v13 = 0;
        *(void *)uint64_t v14 = v12;
        *((void *)v14 + 1) = 0;
        uint64_t v12 = v14;
        a1[613] = v14;
      }
      *((void *)v12 + 1) = v13 + 48;
      uint64_t v15 = &v12[v13];
      uint64_t result = (uint64_t)(v15 + 16);
      v15[24] = 69;
      *(_WORD *)(v15 + 25) = *(_WORD *)(v15 + 25) & 0xF000 | 0x542;
      *((void *)v15 + 2) = &unk_1EC9A3368;
      *((void *)v15 + 4) = v3;
      *((void *)v15 + 5) = v4;
      *((void *)v15 + 6) = v9;
      *((void *)v15 + 7) = v10;
    }
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::EnclosingExpr,char const(&)[10],llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec>(uint64_t a1, uint64_t *a2, char a3)
{
  unint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4016) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    unint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 64;
  unint64_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  v9[24] = 60;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | a3 & 0x3F | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A2290;
  *((void *)v9 + 4) = "noexcept ";
  *((void *)v9 + 5) = 9;
  *((void *)v9 + 7) = 0;
  *((void *)v9 + 8) = 0;
  *((void *)v9 + 6) = v11;
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseRequiresExpr(void *a1)
{
  uint64_t v1 = (_WORD *)*a1;
  size_t v2 = (unsigned char *)a1[1];
  if ((unint64_t)&v2[-*a1] < 2) {
    return 0;
  }
  if (*v1 == 20850)
  {
    unint64_t v5 = v1 + 1;
    *a1 = v5;
    uint64_t v6 = (uint64_t)(a1[3] - a1[2]) >> 3;
    uint64_t v7 = (char *)(a1 + 5);
    while (v5 == v2 || *v5 != 95)
    {
      if (!result) {
        return result;
      }
      uint64_t v10 = result;
      unint64_t v9 = (char *)a1[3];
      if (v9 == (char *)a1[4])
      {
        uint64_t v11 = (char *)a1[2];
        int64_t v12 = v9 - v11;
        if (v11 == v7)
        {
          uint64_t v13 = (char *)malloc(2 * (v9 - v11));
          if (!v13) {
LABEL_68:
          }
            abort();
          uint64_t v8 = v13;
          if (v9 != v7) {
            memcpy(v13, a1 + 5, v12);
          }
          a1[2] = v8;
        }
        else
        {
          uint64_t v8 = (char *)realloc(v11, 2 * (v9 - v11));
          a1[2] = v8;
          if (!v8) {
            goto LABEL_68;
          }
        }
        unint64_t v9 = &v8[8 * (v12 >> 3)];
        a1[4] = &v8[8 * (v12 >> 2)];
      }
      a1[3] = v9 + 8;
      *(void *)unint64_t v9 = v10;
      unint64_t v5 = (unsigned char *)*a1;
      size_t v2 = (unsigned char *)a1[1];
    }
    *a1 = v5 + 1;
    __int16 v16 = (unsigned char *)*a1;
    if (*a1 == a1[1]) {
      return 0;
    }
  }
  else
  {
    if (*v1 != 29042) {
      return 0;
    }
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    __int16 v16 = v1 + 1;
    *a1 = v16;
    if (v16 == v2) {
      return 0;
    }
  }
  int v52 = v15;
  uint64_t v53 = v14;
  uint64_t v54 = (uint64_t)(a1[3] - a1[2]) >> 3;
  uint64_t v17 = (char *)(a1 + 5);
  while (1)
  {
    int v18 = *v16;
    if (v18 == 81)
    {
      *a1 = v16 + 1;
      if (!result) {
        return result;
      }
      uint64_t v24 = result;
      unint64_t v25 = (void *)a1[613];
      uint64_t v26 = v25[1];
      if ((unint64_t)(v26 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v27 = malloc(0x1000uLL);
        if (!v27) {
          goto LABEL_69;
        }
        uint64_t v26 = 0;
        *uint64_t v27 = v25;
        v27[1] = 0;
        unint64_t v25 = v27;
        a1[613] = v27;
      }
      v25[1] = v26 + 32;
      uint64_t v28 = (char *)v25 + v26;
      uint64_t v29 = v28 + 16;
      v28[24] = 86;
      *(_WORD *)(v28 + 25) = *(_WORD *)(v28 + 25) & 0xF000 | 0x540;
      *((void *)v28 + 2) = &unk_1EC9A2AD0;
      *((void *)v28 + 4) = v24;
      uint64_t v30 = (char *)a1[3];
      if (v30 != (char *)a1[4]) {
        goto LABEL_60;
      }
      goto LABEL_52;
    }
    if (v18 == 84)
    {
      *a1 = v16 + 1;
      if (!result) {
        return result;
      }
      uint64_t v31 = result;
      unint64_t v32 = (void *)a1[613];
      uint64_t v33 = v32[1];
      if ((unint64_t)(v33 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v34 = malloc(0x1000uLL);
        if (!v34) {
          goto LABEL_69;
        }
        uint64_t v33 = 0;
        *uint64_t v34 = v32;
        v34[1] = 0;
        unint64_t v32 = v34;
        a1[613] = v34;
      }
      v32[1] = v33 + 32;
      unsigned int v35 = (char *)v32 + v33;
      uint64_t v29 = v35 + 16;
      v35[24] = 85;
      *(_WORD *)(v35 + 25) = *(_WORD *)(v35 + 25) & 0xF000 | 0x540;
      *((void *)v35 + 2) = &unk_1EC9A28C0;
      *((void *)v35 + 4) = v31;
      uint64_t v30 = (char *)a1[3];
      if (v30 != (char *)a1[4]) {
        goto LABEL_60;
      }
      goto LABEL_52;
    }
    if (v18 != 88) {
      return 0;
    }
    *a1 = v16 + 1;
    if (!result) {
      return result;
    }
    uint64_t v19 = result;
    BOOL v20 = (unsigned char *)*a1;
    uint64_t v21 = (unsigned char *)a1[1];
    if ((unsigned char *)*a1 == v21 || *v20 != 78)
    {
      char v22 = 0;
      if (v20 == v21)
      {
LABEL_30:
        uint64_t v23 = 0;
        goto LABEL_46;
      }
    }
    else
    {
      *a1 = ++v20;
      char v22 = 1;
      if (v20 == v21) {
        goto LABEL_30;
      }
    }
    if (*v20 == 82)
    {
      *a1 = v20 + 1;
      uint64_t v23 = result;
      if (!result) {
        return result;
      }
LABEL_46:
      uint64_t v36 = (void *)a1[613];
      uint64_t v37 = v36[1];
      if ((unint64_t)(v37 - 4032) > 0xFFFFFFFFFFFFF00FLL) {
        goto LABEL_51;
      }
      goto LABEL_49;
    }
    uint64_t v23 = 0;
    uint64_t v36 = (void *)a1[613];
    uint64_t v37 = v36[1];
    if ((unint64_t)(v37 - 4032) > 0xFFFFFFFFFFFFF00FLL) {
      goto LABEL_51;
    }
LABEL_49:
    uint64_t v38 = malloc(0x1000uLL);
    if (!v38) {
      goto LABEL_69;
    }
    uint64_t v37 = 0;
    *uint64_t v38 = v36;
    v38[1] = 0;
    uint64_t v36 = v38;
    a1[613] = v38;
LABEL_51:
    v36[1] = v37 + 48;
    uint64_t v39 = (char *)v36 + v37;
    uint64_t v29 = v39 + 16;
    v39[24] = 84;
    *(_WORD *)(v39 + 25) = *(_WORD *)(v39 + 25) & 0xF000 | 0x540;
    *((void *)v39 + 2) = &unk_1EC9A2760;
    *((void *)v39 + 4) = v19;
    v39[40] = v22;
    *((void *)v39 + 6) = v23;
    uint64_t v30 = (char *)a1[3];
    if (v30 != (char *)a1[4]) {
      goto LABEL_60;
    }
LABEL_52:
    uint64_t v40 = (char *)a1[2];
    int64_t v41 = v30 - v40;
    if (v40 == v17)
    {
      unint64_t v43 = (char *)malloc(2 * (v30 - v40));
      if (!v43) {
        goto LABEL_68;
      }
      unsigned int v42 = v43;
      if (v30 != v17) {
        memcpy(v43, a1 + 5, v41);
      }
      a1[2] = v42;
    }
    else
    {
      unsigned int v42 = (char *)realloc(v40, 2 * (v30 - v40));
      a1[2] = v42;
      if (!v42) {
        goto LABEL_68;
      }
    }
    uint64_t v30 = &v42[8 * (v41 >> 3)];
    a1[4] = &v42[8 * (v41 >> 2)];
LABEL_60:
    a1[3] = v30 + 8;
    *(void *)uint64_t v30 = v29;
    __int16 v16 = (unsigned char *)*a1;
    unint64_t v44 = (unsigned char *)a1[1];
    if ((unsigned char *)*a1 == v44) {
      return 0;
    }
    if (*v16 == 69) {
      break;
    }
    uint64_t result = 0;
    if (v16 == v44) {
      return result;
    }
  }
  *a1 = v16 + 1;
  uint64_t v47 = v46;
  unint64_t v48 = (void *)a1[613];
  uint64_t v49 = v48[1];
  if ((unint64_t)(v49 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v50 = malloc(0x1000uLL);
    if (!v50) {
LABEL_69:
    }
      std::terminate();
    uint64_t v49 = 0;
    void *v50 = v48;
    v50[1] = 0;
    unint64_t v48 = v50;
    a1[613] = v50;
  }
  v48[1] = v49 + 48;
  char v51 = (char *)v48 + v49;
  uint64_t result = (uint64_t)(v51 + 16);
  v51[24] = 83;
  *(_WORD *)(v51 + 25) = *(_WORD *)(v51 + 25) & 0xF000 | 0x540;
  *((void *)v51 + 2) = &unk_1EC9A21E0;
  *((void *)v51 + 4) = v52;
  *((void *)v51 + 5) = v53;
  *((void *)v51 + 6) = v45;
  *((void *)v51 + 7) = v47;
  return result;
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseSubobjectExpr(void *a1)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  if (!result) {
    return result;
  }
  unint64_t v5 = (char *)*a1;
  uint64_t v4 = (char *)a1[1];
  if ((char *)*a1 == v4) {
    return 0;
  }
  uint64_t v6 = (char *)*a1;
  if (*v5 == 110)
  {
    uint64_t v6 = v5 + 1;
    *a1 = v5 + 1;
  }
  if (v4 == v6) {
    return 0;
  }
  if (*v6 < 0
    || (uint64_t v7 = MEMORY[0x1E4F14390], (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v6 + 60) & 0x400) == 0))
  {
    uint64_t v8 = 0;
    int64_t v9 = 0;
    uint64_t v10 = v6;
    if (v6 == v4) {
      return 0;
    }
    goto LABEL_18;
  }
  while ((*v6 & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * *v6 + 60) & 0x400) != 0)
  {
    *a1 = ++v6;
    if (v6 == v4)
    {
      uint64_t v6 = v4;
      break;
    }
  }
  uint64_t v8 = v5;
  int64_t v9 = v6 - v5;
  uint64_t v10 = v6;
  if (v6 == v4) {
    return 0;
  }
LABEL_18:
  uint64_t v37 = v9;
  uint64_t v38 = v8;
  uint64_t v39 = result;
  uint64_t v40 = (uint64_t)(a1[3] - a1[2]) >> 3;
  uint64_t v11 = (char *)(a1 + 5);
  uint64_t v12 = MEMORY[0x1E4F14390];
  while (1)
  {
    int v13 = *v10;
    if (v13 != 95) {
      break;
    }
    uint64_t v14 = (unsigned __int8 *)(v10 + 1);
    *a1 = v10 + 1;
    if (v4 == v10 + 1 || (char)*v14 < 0 || (*(_DWORD *)(v12 + 4 * *v14 + 60) & 0x400) == 0)
    {
      uint64_t v14 = 0;
      int64_t v15 = 0;
      __int16 v16 = (void *)a1[613];
      uint64_t v17 = v16[1];
      if ((unint64_t)(v17 - 4048) <= 0xFFFFFFFFFFFFF00FLL) {
        goto LABEL_25;
      }
    }
    else
    {
      unint64_t v25 = (unsigned __int8 *)(v10 + 1);
      while (((char)*v25 & 0x80000000) == 0 && (*(_DWORD *)(v12 + 4 * *v25 + 60) & 0x400) != 0)
      {
        *a1 = ++v25;
        if (v25 == (unsigned __int8 *)v4)
        {
          unint64_t v25 = (unsigned __int8 *)v4;
          break;
        }
      }
      int64_t v15 = v25 - v14;
      __int16 v16 = (void *)a1[613];
      uint64_t v17 = v16[1];
      if ((unint64_t)(v17 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
LABEL_25:
        int v18 = malloc(0x1000uLL);
        if (!v18) {
          goto LABEL_61;
        }
        uint64_t v17 = 0;
        *int v18 = v16;
        v18[1] = 0;
        __int16 v16 = v18;
        a1[613] = v18;
      }
    }
    v16[1] = v17 + 32;
    uint64_t v19 = (char *)v16 + v17;
    BOOL v20 = v19 + 16;
    unsigned char v19[24] = 8;
    *(_WORD *)(v19 + 25) = *(_WORD *)(v19 + 25) & 0xF000 | 0x540;
    *((void *)v19 + 2) = &unk_1EC9A3628;
    *((void *)v19 + 4) = v14;
    *((void *)v19 + 5) = v15;
    uint64_t v21 = (char *)a1[3];
    if (v21 == (char *)a1[4])
    {
      char v22 = (char *)a1[2];
      int64_t v23 = v21 - v22;
      if (v22 == v11)
      {
        uint64_t v26 = (char *)malloc(2 * (v21 - v22));
        if (!v26) {
LABEL_62:
        }
          abort();
        uint64_t v24 = v26;
        if (v21 != v11) {
          memcpy(v26, a1 + 5, v23);
        }
        a1[2] = v24;
      }
      else
      {
        uint64_t v24 = (char *)realloc(v22, 2 * (v21 - v22));
        a1[2] = v24;
        if (!v24) {
          goto LABEL_62;
        }
      }
      uint64_t v27 = &v24[8 * (v23 >> 3)];
      a1[3] = v27 + 8;
      a1[4] = &v24[8 * (v23 >> 2)];
      *(void *)uint64_t v27 = v20;
      uint64_t v10 = (char *)*a1;
      uint64_t v4 = (char *)a1[1];
      if ((char *)*a1 == v4) {
        return 0;
      }
    }
    else
    {
      a1[3] = v21 + 8;
      *(void *)uint64_t v21 = v20;
      uint64_t v10 = (char *)*a1;
      uint64_t v4 = (char *)a1[1];
      if ((char *)*a1 == v4) {
        return 0;
      }
    }
  }
  BOOL v28 = v10 != v4 && v13 == 112;
  char v29 = v28;
  if (v28) {
    *a1 = ++v10;
  }
  if (v10 == v4 || *v10 != 69) {
    return 0;
  }
  *a1 = v10 + 1;
  uint64_t v32 = v31;
  uint64_t v33 = (void *)a1[613];
  uint64_t v34 = v33[1];
  if ((unint64_t)(v34 - 4000) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unsigned int v35 = malloc(0x1000uLL);
    if (!v35) {
LABEL_61:
    }
      std::terminate();
    uint64_t v34 = 0;
    void *v35 = v33;
    v35[1] = 0;
    uint64_t v33 = v35;
    a1[613] = v35;
  }
  v33[1] = v34 + 80;
  uint64_t v36 = (char *)v33 + v34;
  uint64_t result = (uint64_t)(v36 + 16);
  v36[24] = 59;
  *(_WORD *)(v36 + 25) = *(_WORD *)(v36 + 25) & 0xF000 | 0x540;
  *((void *)v36 + 2) = &unk_1EC9A2550;
  *((void *)v36 + 4) = v3;
  *((void *)v36 + 5) = v39;
  *((void *)v36 + 6) = v38;
  *((void *)v36 + 7) = v37;
  *((void *)v36 + 8) = v30;
  *((void *)v36 + 9) = v32;
  v36[80] = v29;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ParameterPackExpansion,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 42;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A3100;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::SizeofParamPackExpr,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 62;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2C88;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::EnclosingExpr,char const(&)[11],llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4016) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 64;
  uint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 60;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2290;
  *((void *)v7 + 4) = "sizeof... ";
  *((void *)v7 + 5) = 10;
  *((void *)v7 + 7) = 0;
  *((void *)v7 + 8) = 0;
  *((void *)v7 + 6) = v9;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::NodeArrayNode,llvm::itanium_demangle::NodeArray>(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  v7[24] = 0;
  __int16 v8 = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2340;
  __n128 result = *a2;
  *(_WORD *)(v7 + 25) = v8;
  *((__n128 *)v7 + 2) = result;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::InitListExpr,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray>(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  unint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    __int16 v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    unint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 48;
  uint64_t v9 = (char *)v5 + v6;
  uint64_t v10 = *a2;
  v9[24] = 70;
  __int16 v11 = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A20D8;
  __n128 result = *a3;
  *(_WORD *)(v9 + 25) = v11;
  *((void *)v9 + 4) = v10;
  *(__n128 *)(v9 + 40) = result;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ThrowExpr,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 72;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A37E0;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseUnresolvedName(uint64_t a1, size_t a2)
{
  int v2 = a2;
  uint64_t v4 = *(unsigned __int8 **)a1;
  unint64_t v5 = *(char **)(a1 + 8);
  unint64_t v6 = (unint64_t)&v5[-*(void *)a1];
  if (v6 >= 3)
  {
    if (*(_WORD *)v4 == 29299 && v4[2] == 78)
    {
      *(void *)a1 = v4 + 3;
      if (!v19) {
        return 0;
      }
      uint64_t v17 = v19;
      if (*(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 73)
      {
        if (v20)
        {
          uint64_t v21 = v20;
          char v22 = *(void **)(a1 + 4904);
          uint64_t v23 = v22[1];
          if ((unint64_t)(v23 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
          {
            uint64_t v24 = malloc(0x1000uLL);
            if (!v24) {
              goto LABEL_74;
            }
            uint64_t v23 = 0;
            *uint64_t v24 = v22;
            v24[1] = 0;
            char v22 = v24;
            *(void *)(a1 + 4904) = v24;
          }
          v22[1] = v23 + 32;
          unint64_t v25 = (char *)v22 + v23;
          v25[24] = 45;
          *(_WORD *)(v25 + 25) = *(_WORD *)(v25 + 25) & 0xF000 | 0x540;
          *((void *)v25 + 2) = &unk_1EC9A2DE8;
          *((void *)v25 + 4) = v17;
          *((void *)v25 + 5) = v21;
          uint64_t v17 = v25 + 16;
          goto LABEL_33;
        }
        return 0;
      }
LABEL_33:
      while (1)
      {
        uint64_t v27 = *(unsigned __int8 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *v27 == 69) {
          break;
        }
        if (!v28) {
          return 0;
        }
        char v29 = v28;
        uint64_t v30 = *(void **)(a1 + 4904);
        uint64_t v31 = v30[1];
        if ((unint64_t)(v31 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
        {
          uint64_t v32 = malloc(0x1000uLL);
          if (!v32) {
            goto LABEL_74;
          }
          uint64_t v31 = 0;
          *uint64_t v32 = v30;
          v32[1] = 0;
          uint64_t v30 = v32;
          *(void *)(a1 + 4904) = v32;
        }
        v30[1] = v31 + 32;
        uint64_t v26 = (char *)v30 + v31;
        v26[24] = 23;
        *(_WORD *)(v26 + 25) = *(_WORD *)(v26 + 25) & 0xF000 | 0x540;
        *((void *)v26 + 2) = &unk_1EC9A2448;
        *((void *)v26 + 4) = v17;
        *((void *)v26 + 5) = v29;
        uint64_t v17 = v26 + 16;
      }
LABEL_66:
      *(void *)a1 = v27 + 1;
LABEL_67:
      if (v45)
      {
        uint64_t v46 = v45;
        uint64_t v47 = *(void **)(a1 + 4904);
        uint64_t v48 = v47[1];
        if ((unint64_t)(v48 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
        {
          uint64_t v49 = malloc(0x1000uLL);
          if (!v49) {
            goto LABEL_74;
          }
          uint64_t v48 = 0;
          *uint64_t v49 = v47;
          v49[1] = 0;
          uint64_t v47 = v49;
          *(void *)(a1 + 4904) = v49;
        }
        v47[1] = v48 + 32;
        unint64_t v50 = (char *)v47 + v48;
        __int16 v8 = v50 + 16;
        v50[24] = 23;
        *(_WORD *)(v50 + 25) = *(_WORD *)(v50 + 25) & 0xF000 | 0x540;
        *((void *)v50 + 2) = &unk_1EC9A2448;
        *((void *)v50 + 4) = v17;
        *((void *)v50 + 5) = v46;
        return v8;
      }
      return 0;
    }
  }
  else if (v6 != 2)
  {
    goto LABEL_9;
  }
  if (*(_WORD *)v4 == 29299)
  {
    int v13 = (char *)(v4 + 2);
    *(void *)a1 = v13;
    if (v5 == v13)
    {
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60) & 0x400) == 0)
      {
LABEL_18:
        uint64_t v53 = v15;
        if (!v15) {
          return 0;
        }
        uint64_t v17 = v15;
        if (*(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 73)
        {
          uint64_t v52 = v18;
          if (!v18) {
            return 0;
          }
        }
        goto LABEL_67;
      }
    }
    else
    {
      int v14 = *v13;
      if (v14 < 0 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v14 + 60) & 0x400) == 0) {
        goto LABEL_18;
      }
    }
    if (!v33) {
      return 0;
    }
    uint64_t v34 = v33;
    if (v2)
    {
      uint64_t v17 = 0;
      while (1)
      {
        unsigned int v35 = *(void **)(a1 + 4904);
        uint64_t v36 = v35[1];
        if (v17)
        {
          if ((unint64_t)(v36 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
          {
            uint64_t v37 = malloc(0x1000uLL);
            if (!v37) {
              goto LABEL_74;
            }
            uint64_t v36 = 0;
            void *v37 = v35;
            v37[1] = 0;
            unsigned int v35 = v37;
            *(void *)(a1 + 4904) = v37;
          }
          v35[1] = v36 + 32;
          uint64_t v38 = (char *)v35 + v36;
          v38[24] = 23;
          *(_WORD *)(v38 + 25) = *(_WORD *)(v38 + 25) & 0xF000 | 0x540;
          *((void *)v38 + 2) = &unk_1EC9A2448;
          *((void *)v38 + 4) = v17;
          uint64_t v17 = v38 + 16;
          *((void *)v38 + 5) = v34;
          uint64_t v27 = *(unsigned __int8 **)a1;
          if (*(void *)a1 == *(void *)(a1 + 8)) {
            goto LABEL_43;
          }
        }
        else
        {
          if ((unint64_t)(v36 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
          {
            uint64_t v39 = malloc(0x1000uLL);
            if (!v39) {
              goto LABEL_74;
            }
            uint64_t v36 = 0;
            *uint64_t v39 = v35;
            v39[1] = 0;
            unsigned int v35 = v39;
            *(void *)(a1 + 4904) = v39;
          }
          v35[1] = v36 + 32;
          uint64_t v40 = (char *)v35 + v36;
          uint64_t v17 = v40 + 16;
          v40[24] = 46;
          *(_WORD *)(v40 + 25) = *(_WORD *)(v40 + 25) & 0xF000 | 0x540;
          *((void *)v40 + 2) = &unk_1EC9A2BD8;
          *((void *)v40 + 4) = v34;
          uint64_t v27 = *(unsigned __int8 **)a1;
          if (*(void *)a1 == *(void *)(a1 + 8)) {
            goto LABEL_43;
          }
        }
        if (*v27 == 69) {
          goto LABEL_66;
        }
LABEL_43:
        __int16 v8 = 0;
        if (!v34) {
          return v8;
        }
      }
    }
    uint64_t v17 = 0;
    while (1)
    {
      if (v17)
      {
        int64_t v41 = *(void **)(a1 + 4904);
        uint64_t v42 = v41[1];
        if ((unint64_t)(v42 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
        {
          unint64_t v43 = malloc(0x1000uLL);
          if (!v43) {
            goto LABEL_74;
          }
          uint64_t v42 = 0;
          *unint64_t v43 = v41;
          v43[1] = 0;
          int64_t v41 = v43;
          *(void *)(a1 + 4904) = v43;
        }
        v41[1] = v42 + 32;
        unint64_t v44 = (char *)v41 + v42;
        v44[24] = 23;
        *(_WORD *)(v44 + 25) = *(_WORD *)(v44 + 25) & 0xF000 | 0x540;
        *((void *)v44 + 2) = &unk_1EC9A2448;
        *((void *)v44 + 4) = v17;
        *((void *)v44 + 5) = v34;
        uint64_t v17 = v44 + 16;
        uint64_t v27 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8)) {
          goto LABEL_57;
        }
      }
      else
      {
        uint64_t v17 = v34;
        uint64_t v27 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8)) {
          goto LABEL_57;
        }
      }
      if (*v27 == 69) {
        goto LABEL_66;
      }
LABEL_57:
      __int16 v8 = 0;
      if (!v34) {
        return v8;
      }
    }
  }
LABEL_9:
  if (v8 && v2)
  {
    uint64_t v9 = *(void **)(a1 + 4904);
    uint64_t v10 = v9[1];
    if ((unint64_t)(v10 - 4048) > 0xFFFFFFFFFFFFF00FLL)
    {
LABEL_14:
      v9[1] = v10 + 32;
      uint64_t v12 = (char *)v9 + v10;
      v12[24] = 46;
      *(_WORD *)(v12 + 25) = *(_WORD *)(v12 + 25) & 0xF000 | 0x540;
      *((void *)v12 + 2) = &unk_1EC9A2BD8;
      *((void *)v12 + 4) = v8;
      return v12 + 16;
    }
    __int16 v11 = malloc(0x1000uLL);
    if (v11)
    {
      uint64_t v10 = 0;
      *__int16 v11 = v9;
      v11[1] = 0;
      uint64_t v9 = v11;
      *(void *)(a1 + 4904) = v11;
      goto LABEL_14;
    }
LABEL_74:
    std::terminate();
  }
  return v8;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::BinaryExpr,llvm::itanium_demangle::Node *&,std::string_view &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec &>(uint64_t a1, uint64_t *a2, __n128 *a3, uint64_t *a4, char a5)
{
  uint64_t v9 = *(void **)(a1 + 4904);
  uint64_t v10 = v9[1];
  if ((unint64_t)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v12 = malloc(0x1000uLL);
    if (!v12) {
      std::terminate();
    }
    uint64_t v10 = 0;
    *uint64_t v12 = v9;
    v12[1] = 0;
    uint64_t v9 = v12;
    *(void *)(a1 + 4904) = v12;
  }
  v9[1] = v10 + 48;
  int v13 = (char *)v9 + v10;
  uint64_t v14 = *a2;
  uint64_t v15 = *a4;
  v13[24] = 54;
  __int16 v16 = *(_WORD *)(v13 + 25) & 0xF000 | a5 & 0x3F | 0x540;
  *((void *)v13 + 2) = &unk_1EC9A1AA8;
  __n128 result = *a3;
  *(_WORD *)(v13 + 25) = v16;
  *((void *)v13 + 4) = v14;
  *(__n128 *)(v13 + 40) = result;
  *((void *)v13 + 7) = v15;
  return result;
}

char *llvm::itanium_demangle::BinaryExpr::printLeft(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 32)) {
    goto LABEL_2;
  }
  uint64_t v36 = *(unsigned char **)(a1 + 24);
  uint64_t v37 = *(void *)(a1 + 32);
  if (v37 != 2)
  {
    if (v37 == 1 && *v36 == 62) {
      goto LABEL_44;
    }
LABEL_2:
    int v4 = 0;
    goto LABEL_3;
  }
  if (memcmp(v36, ">>", 2uLL)) {
    goto LABEL_2;
  }
LABEL_44:
  *(_DWORD *)(a2 + 32) = 1;
  uint64_t v38 = *(char **)a2;
  uint64_t v39 = *(void *)(a2 + 8);
  uint64_t v40 = v39 + 1;
  unint64_t v41 = *(void *)(a2 + 16);
  if (v39 + 1 > v41)
  {
    unint64_t v42 = v39 + 993;
    if (2 * v41 <= v42) {
      size_t v43 = v42;
    }
    else {
      size_t v43 = 2 * v41;
    }
    *(void *)(a2 + 16) = v43;
    uint64_t v38 = (char *)realloc(v38, v43);
    *(void *)a2 = v38;
    if (!v38) {
      goto LABEL_51;
    }
    uint64_t v39 = *(void *)(a2 + 8);
    uint64_t v40 = v39 + 1;
  }
  *(void *)(a2 + 8) = v40;
  v38[v39] = 40;
  int v4 = 1;
LABEL_3:
  int v5 = *(unsigned __int16 *)(a1 + 9);
  __int16 v6 = (_WORD)v5 << 10;
  int v7 = (unsigned __int16)((_WORD)v5 << 10);
  int v8 = v5 << 26 >> 26;
  if (v7 == 17408) {
    int v9 = 15;
  }
  else {
    int v9 = v8;
  }
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), a2, v9, v7 != 17408);
  if (*(void *)(a1 + 32) == 1)
  {
    uint64_t v10 = *(unsigned char **)(a1 + 24);
    if (*v10 == 44)
    {
      size_t v11 = 1;
      uint64_t v12 = *(char **)a2;
      uint64_t v13 = *(void *)(a2 + 8);
      uint64_t v14 = v13 + 1;
      unint64_t v15 = *(void *)(a2 + 16);
      if (v13 + 1 <= v15) {
        goto LABEL_23;
      }
      goto LABEL_18;
    }
  }
  __int16 v16 = *(char **)a2;
  uint64_t v17 = *(void *)(a2 + 8);
  unint64_t v18 = *(void *)(a2 + 16);
  if (v17 + 1 > v18)
  {
    size_t v19 = v17 + 993;
    unint64_t v20 = 2 * v18;
    if (v20 <= v19) {
      size_t v21 = v19;
    }
    else {
      size_t v21 = v20;
    }
    *(void *)(a2 + 16) = v21;
    __int16 v16 = (char *)realloc(v16, v21);
    *(void *)a2 = v16;
    if (!v16) {
      goto LABEL_51;
    }
    uint64_t v17 = *(void *)(a2 + 8);
  }
  v16[v17] = 32;
  uint64_t v22 = *(void *)(a2 + 8) + 1;
  *(void *)(a2 + 8) = v22;
  size_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v10 = *(unsigned char **)(a1 + 24);
    uint64_t v12 = *(char **)a2;
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = v13 + v11;
    unint64_t v15 = *(void *)(a2 + 16);
    if (v13 + v11 <= v15)
    {
LABEL_23:
      memcpy(&v12[v13], v10, v11);
      uint64_t v22 = *(void *)(a2 + 8) + v11;
      *(void *)(a2 + 8) = v22;
      goto LABEL_24;
    }
LABEL_18:
    unint64_t v23 = 2 * v15;
    if (v23 <= v14 + 992) {
      size_t v24 = v14 + 992;
    }
    else {
      size_t v24 = v23;
    }
    *(void *)(a2 + 16) = v24;
    uint64_t v12 = (char *)realloc(v12, v24);
    *(void *)a2 = v12;
    if (!v12) {
      goto LABEL_51;
    }
    uint64_t v13 = *(void *)(a2 + 8);
    goto LABEL_23;
  }
LABEL_24:
  unint64_t v25 = *(void *)(a2 + 16);
  uint64_t v26 = *(char **)a2;
  if (v22 + 1 > v25)
  {
    size_t v27 = v22 + 993;
    unint64_t v28 = 2 * v25;
    if (v28 <= v27) {
      size_t v29 = v27;
    }
    else {
      size_t v29 = v28;
    }
    *(void *)(a2 + 16) = v29;
    uint64_t v26 = (char *)realloc(v26, v29);
    *(void *)a2 = v26;
    if (!v26) {
      goto LABEL_51;
    }
    uint64_t v22 = *(void *)(a2 + 8);
  }
  v26[v22] = 32;
  ++*(void *)(a2 + 8);
  __n128 result = (char *)llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 40), a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, v6 == 17408);
  if (!v4) {
    return result;
  }
  --*(_DWORD *)(a2 + 32);
  __n128 result = *(char **)a2;
  uint64_t v31 = *(void *)(a2 + 8);
  uint64_t v32 = v31 + 1;
  unint64_t v33 = *(void *)(a2 + 16);
  if (v31 + 1 > v33)
  {
    unint64_t v34 = v31 + 993;
    if (2 * v33 <= v34) {
      size_t v35 = v34;
    }
    else {
      size_t v35 = 2 * v33;
    }
    *(void *)(a2 + 16) = v35;
    __n128 result = (char *)realloc(result, v35);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v31 = *(void *)(a2 + 8);
      uint64_t v32 = v31 + 1;
      goto LABEL_37;
    }
LABEL_51:
    abort();
  }
LABEL_37:
  *(void *)(a2 + 8) = v32;
  result[v31] = 41;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PrefixExpr,std::string_view &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node::Prec &>(uint64_t a1, __n128 *a2, uint64_t *a3, char a4)
{
  int v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *uint64_t v10 = v7;
    v10[1] = 0;
    int v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 48;
  size_t v11 = (char *)v7 + v8;
  uint64_t v12 = *a3;
  v11[24] = 66;
  __int16 v13 = *(_WORD *)(v11 + 25) & 0xF000 | a4 & 0x3F | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A1D68;
  __n128 result = *a2;
  *(_WORD *)(v11 + 25) = v13;
  *((__n128 *)v11 + 2) = result;
  *((void *)v11 + 6) = v12;
  return result;
}

void *llvm::itanium_demangle::PrefixExpr::printLeft(uint64_t a1, char **a2)
{
  size_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    int v5 = *(const void **)(a1 + 16);
    __int16 v6 = *a2;
    int v7 = a2[1];
    uint64_t v8 = &v7[v4];
    size_t v9 = (size_t)a2[2];
    if ((unint64_t)&v7[v4] > v9)
    {
      unint64_t v10 = 2 * v9;
      if (v10 <= (unint64_t)(v8 + 992)) {
        size_t v11 = (size_t)(v8 + 992);
      }
      else {
        size_t v11 = v10;
      }
      a2[2] = (char *)v11;
      __int16 v6 = (char *)realloc(v6, v11);
      *a2 = v6;
      if (!v6) {
        abort();
      }
      int v7 = a2[1];
    }
    memcpy(&v7[(void)v6], v5, v4);
    a2[1] += v4;
  }
  uint64_t v12 = *(void *)(a1 + 32);
  int v13 = *(unsigned __int16 *)(a1 + 9) << 26 >> 26;

  return llvm::itanium_demangle::Node::printAsOperand(v12, (uint64_t)a2, v13, 0);
}

void *llvm::itanium_demangle::PostfixExpr::printLeft(uint64_t a1, char **a2)
{
  __n128 result = llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), (uint64_t)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 1);
  size_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    __int16 v6 = *(const void **)(a1 + 24);
    int v7 = *a2;
    uint64_t v8 = a2[1];
    size_t v9 = &v8[v5];
    size_t v10 = (size_t)a2[2];
    if ((unint64_t)&v8[v5] > v10)
    {
      unint64_t v11 = 2 * v10;
      if (v11 <= (unint64_t)(v9 + 992)) {
        size_t v12 = (size_t)(v9 + 992);
      }
      else {
        size_t v12 = v11;
      }
      a2[2] = (char *)v12;
      int v7 = (char *)realloc(v7, v12);
      *a2 = v7;
      if (!v7) {
        abort();
      }
      uint64_t v8 = a2[1];
    }
    __n128 result = memcpy(&v8[(void)v7], v6, v5);
    a2[1] += v5;
  }
  return result;
}

void *llvm::itanium_demangle::ArraySubscriptExpr::printLeft(uint64_t a1, uint64_t a2)
{
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
  ++*(_DWORD *)(a2 + 32);
  size_t v4 = *(void **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    size_t v4 = realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_14;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  *((unsigned char *)v4 + v5) = 91;
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 24), a2, 19, 0);
  --*(_DWORD *)(a2 + 32);
  __n128 result = *(void **)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = v11 + 1;
  unint64_t v13 = *(void *)(a2 + 16);
  if (v11 + 1 > v13)
  {
    unint64_t v14 = v11 + 993;
    if (2 * v13 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = 2 * v13;
    }
    *(void *)(a2 + 16) = v15;
    __n128 result = realloc(result, v15);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v11 = *(void *)(a2 + 8);
      uint64_t v12 = v11 + 1;
      goto LABEL_13;
    }
LABEL_14:
    abort();
  }
LABEL_13:
  *(void *)(a2 + 8) = v12;
  *((unsigned char *)result + v11) = 93;
  return result;
}

void *llvm::itanium_demangle::MemberExpr::printLeft(uint64_t a1, char **a2)
{
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), (uint64_t)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 1);
  size_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(const void **)(a1 + 24);
    uint64_t v6 = *a2;
    unint64_t v7 = a2[1];
    unint64_t v8 = &v7[v4];
    size_t v9 = (size_t)a2[2];
    if ((unint64_t)&v7[v4] > v9)
    {
      unint64_t v10 = 2 * v9;
      if (v10 <= (unint64_t)(v8 + 992)) {
        size_t v11 = (size_t)(v8 + 992);
      }
      else {
        size_t v11 = v10;
      }
      a2[2] = (char *)v11;
      uint64_t v6 = (char *)realloc(v6, v11);
      *a2 = v6;
      if (!v6) {
        abort();
      }
      unint64_t v7 = a2[1];
    }
    memcpy(&v7[(void)v6], v5, v4);
    a2[1] += v4;
  }
  uint64_t v12 = *(void *)(a1 + 40);
  int v13 = *(unsigned __int16 *)(a1 + 9) << 26 >> 26;

  return llvm::itanium_demangle::Node::printAsOperand(v12, (uint64_t)a2, v13, 0);
}

char *llvm::itanium_demangle::NewExpr::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(unsigned char *)(a1 + 56))
  {
    unint64_t v5 = *(void *)(a2 + 16);
    uint64_t v6 = *(char **)a2;
    if (v4 + 2 > v5)
    {
      size_t v7 = v4 + 994;
      unint64_t v8 = 2 * v5;
      if (v8 <= v7) {
        size_t v9 = v7;
      }
      else {
        size_t v9 = v8;
      }
      *(void *)(a2 + 16) = v9;
      uint64_t v6 = (char *)realloc(v6, v9);
      *(void *)a2 = v6;
      if (!v6) {
        goto LABEL_88;
      }
      uint64_t v4 = *(void *)(a2 + 8);
    }
    *(_WORD *)&v6[v4] = 14906;
    uint64_t v4 = *(void *)(a2 + 8) + 2;
    *(void *)(a2 + 8) = v4;
  }
  unint64_t v10 = *(void *)(a2 + 16);
  size_t v11 = *(char **)a2;
  if (v4 + 3 > v10)
  {
    size_t v12 = v4 + 995;
    unint64_t v13 = 2 * v10;
    if (v13 <= v12) {
      size_t v14 = v12;
    }
    else {
      size_t v14 = v13;
    }
    *(void *)(a2 + 16) = v14;
    size_t v11 = (char *)realloc(v11, v14);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_88;
    }
    uint64_t v4 = *(void *)(a2 + 8);
  }
  size_t v15 = &v11[v4];
  void v15[2] = 119;
  *(_WORD *)size_t v15 = 25966;
  uint64_t v16 = *(void *)(a2 + 8);
  uint64_t v17 = v16 + 3;
  *(void *)(a2 + 8) = v16 + 3;
  if (*(unsigned char *)(a1 + 57))
  {
    unint64_t v18 = *(void *)(a2 + 16);
    size_t v19 = *(char **)a2;
    if (v16 + 5 > v18)
    {
      if (2 * v18 <= v16 + 997) {
        size_t v20 = v16 + 997;
      }
      else {
        size_t v20 = 2 * v18;
      }
      *(void *)(a2 + 16) = v20;
      size_t v19 = (char *)realloc(v19, v20);
      *(void *)a2 = v19;
      if (!v19) {
        goto LABEL_88;
      }
      uint64_t v17 = *(void *)(a2 + 8);
    }
    *(_WORD *)&v19[v17] = 23899;
    uint64_t v17 = *(void *)(a2 + 8) + 2;
    *(void *)(a2 + 8) = v17;
  }
  if (*(void *)(a1 + 24))
  {
    ++*(_DWORD *)(a2 + 32);
    uint64_t v21 = v17 + 1;
    unint64_t v22 = *(void *)(a2 + 16);
    unint64_t v23 = *(char **)a2;
    if (v17 + 1 > v22)
    {
      unint64_t v24 = v17 + 993;
      if (2 * v22 <= v24) {
        size_t v25 = v24;
      }
      else {
        size_t v25 = 2 * v22;
      }
      *(void *)(a2 + 16) = v25;
      unint64_t v23 = (char *)realloc(v23, v25);
      *(void *)a2 = v23;
      if (!v23) {
        goto LABEL_88;
      }
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v21 = v17 + 1;
    }
    *(void *)(a2 + 8) = v21;
    v23[v17] = 40;
    uint64_t v26 = *(void *)(a2 + 8);
    if (*(void *)(a1 + 24))
    {
      uint64_t v27 = 0;
      char v28 = 1;
      while (1)
      {
        uint64_t v29 = v26;
        if ((v28 & 1) == 0)
        {
          unint64_t v30 = *(void *)(a2 + 16);
          uint64_t v31 = *(char **)a2;
          if (v26 + 2 <= v30)
          {
            uint64_t v34 = v26;
          }
          else
          {
            unint64_t v32 = 2 * v30;
            if (v32 <= v26 + 994) {
              size_t v33 = v26 + 994;
            }
            else {
              size_t v33 = v32;
            }
            *(void *)(a2 + 16) = v33;
            uint64_t v31 = (char *)realloc(v31, v33);
            *(void *)a2 = v31;
            if (!v31) {
              goto LABEL_88;
            }
            uint64_t v34 = *(void *)(a2 + 8);
          }
          *(_WORD *)&v31[v34] = 8236;
          uint64_t v29 = *(void *)(a2 + 8) + 2;
          *(void *)(a2 + 8) = v29;
        }
        llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 16) + 8 * v27), a2, 18, 0);
        if (v29 == *(void *)(a2 + 8))
        {
          *(void *)(a2 + 8) = v26;
          if (++v27 == *(void *)(a1 + 24)) {
            break;
          }
        }
        else
        {
          char v28 = 0;
          uint64_t v26 = *(void *)(a2 + 8);
          if (++v27 == *(void *)(a1 + 24)) {
            break;
          }
        }
      }
    }
    --*(_DWORD *)(a2 + 32);
    uint64_t v35 = v26 + 1;
    unint64_t v36 = *(void *)(a2 + 16);
    uint64_t v37 = *(char **)a2;
    if (v26 + 1 > v36)
    {
      unint64_t v38 = 2 * v36;
      if (v38 <= v26 + 993) {
        size_t v39 = v26 + 993;
      }
      else {
        size_t v39 = v38;
      }
      *(void *)(a2 + 16) = v39;
      uint64_t v37 = (char *)realloc(v37, v39);
      *(void *)a2 = v37;
      if (!v37) {
        goto LABEL_88;
      }
      uint64_t v26 = *(void *)(a2 + 8);
      uint64_t v35 = v26 + 1;
    }
    *(void *)(a2 + 8) = v35;
    v37[v26] = 41;
    uint64_t v17 = *(void *)(a2 + 8);
  }
  unint64_t v40 = *(void *)(a2 + 16);
  unint64_t v41 = *(char **)a2;
  if (v17 + 1 > v40)
  {
    size_t v42 = v17 + 993;
    unint64_t v43 = 2 * v40;
    if (v43 <= v42) {
      size_t v44 = v42;
    }
    else {
      size_t v44 = v43;
    }
    *(void *)(a2 + 16) = v44;
    unint64_t v41 = (char *)realloc(v41, v44);
    *(void *)a2 = v41;
    if (!v41) {
      goto LABEL_88;
    }
    uint64_t v17 = *(void *)(a2 + 8);
  }
  v41[v17] = 32;
  ++*(void *)(a2 + 8);
  uint64_t v45 = *(void *)(a1 + 32);
  __n128 result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v45 + 32))(v45, a2);
  if ((*(_WORD *)(v45 + 9) & 0xC0) != 0x40) {
    __n128 result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v45 + 40))(v45, a2);
  }
  if (*(void *)(a1 + 48))
  {
    ++*(_DWORD *)(a2 + 32);
    uint64_t v47 = *(char **)a2;
    uint64_t v48 = *(void *)(a2 + 8);
    uint64_t v49 = v48 + 1;
    unint64_t v50 = *(void *)(a2 + 16);
    if (v48 + 1 > v50)
    {
      unint64_t v51 = v48 + 993;
      if (2 * v50 <= v51) {
        size_t v52 = v51;
      }
      else {
        size_t v52 = 2 * v50;
      }
      *(void *)(a2 + 16) = v52;
      uint64_t v47 = (char *)realloc(v47, v52);
      *(void *)a2 = v47;
      if (!v47) {
        goto LABEL_88;
      }
      uint64_t v48 = *(void *)(a2 + 8);
      uint64_t v49 = v48 + 1;
    }
    *(void *)(a2 + 8) = v49;
    v47[v48] = 40;
    uint64_t v53 = *(void *)(a2 + 8);
    if (*(void *)(a1 + 48))
    {
      uint64_t v54 = 0;
      char v55 = 1;
      while (1)
      {
        uint64_t v56 = v53;
        if ((v55 & 1) == 0)
        {
          unint64_t v57 = *(void *)(a2 + 16);
          uint64_t v58 = *(char **)a2;
          if (v53 + 2 <= v57)
          {
            uint64_t v61 = v53;
          }
          else
          {
            unint64_t v59 = 2 * v57;
            if (v59 <= v53 + 994) {
              size_t v60 = v53 + 994;
            }
            else {
              size_t v60 = v59;
            }
            *(void *)(a2 + 16) = v60;
            uint64_t v58 = (char *)realloc(v58, v60);
            *(void *)a2 = v58;
            if (!v58) {
              goto LABEL_88;
            }
            uint64_t v61 = *(void *)(a2 + 8);
          }
          *(_WORD *)&v58[v61] = 8236;
          uint64_t v56 = *(void *)(a2 + 8) + 2;
          *(void *)(a2 + 8) = v56;
        }
        llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 40) + 8 * v54), a2, 18, 0);
        if (v56 == *(void *)(a2 + 8))
        {
          *(void *)(a2 + 8) = v53;
          if (++v54 == *(void *)(a1 + 48)) {
            break;
          }
        }
        else
        {
          char v55 = 0;
          uint64_t v53 = *(void *)(a2 + 8);
          if (++v54 == *(void *)(a1 + 48)) {
            break;
          }
        }
      }
    }
    --*(_DWORD *)(a2 + 32);
    uint64_t v62 = v53 + 1;
    unint64_t v63 = *(void *)(a2 + 16);
    __n128 result = *(char **)a2;
    if (v53 + 1 <= v63) {
      goto LABEL_86;
    }
    unint64_t v64 = 2 * v63;
    if (v64 <= v53 + 993) {
      size_t v65 = v53 + 993;
    }
    else {
      size_t v65 = v64;
    }
    *(void *)(a2 + 16) = v65;
    __n128 result = (char *)realloc(result, v65);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v53 = *(void *)(a2 + 8);
      uint64_t v62 = v53 + 1;
LABEL_86:
      *(void *)(a2 + 8) = v62;
      result[v53] = 41;
      return result;
    }
LABEL_88:
    abort();
  }
  return result;
}

uint64_t llvm::itanium_demangle::DeleteExpr::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = (uint64_t)a2[1];
  if (*(unsigned char *)(a1 + 24))
  {
    unint64_t v5 = (unint64_t)a2[2];
    uint64_t v6 = *a2;
    if (v4 + 2 > v5)
    {
      size_t v7 = v4 + 994;
      unint64_t v8 = 2 * v5;
      if (v8 <= v7) {
        size_t v9 = v7;
      }
      else {
        size_t v9 = v8;
      }
      a2[2] = (char *)v9;
      uint64_t v6 = (char *)realloc(v6, v9);
      *a2 = v6;
      if (!v6) {
        goto LABEL_33;
      }
      uint64_t v4 = (uint64_t)a2[1];
    }
    *(_WORD *)&v6[v4] = 14906;
    uint64_t v4 = (uint64_t)(a2[1] + 2);
    a2[1] = (char *)v4;
  }
  unint64_t v10 = (unint64_t)a2[2];
  size_t v11 = *a2;
  if (v4 + 6 > v10)
  {
    size_t v12 = v4 + 998;
    unint64_t v13 = 2 * v10;
    if (v13 <= v12) {
      size_t v14 = v12;
    }
    else {
      size_t v14 = v13;
    }
    a2[2] = (char *)v14;
    size_t v11 = (char *)realloc(v11, v14);
    *a2 = v11;
    if (!v11) {
      goto LABEL_33;
    }
    uint64_t v4 = (uint64_t)a2[1];
  }
  size_t v15 = &v11[v4];
  *((_WORD *)v15 + 2) = 25972;
  *(_DWORD *)size_t v15 = 1701602660;
  uint64_t v16 = a2[1];
  uint64_t v17 = (uint64_t)(v16 + 6);
  a2[1] = v16 + 6;
  if (*(unsigned char *)(a1 + 25))
  {
    unint64_t v18 = (unint64_t)a2[2];
    size_t v19 = *a2;
    if ((unint64_t)(v16 + 8) > v18)
    {
      if (2 * v18 <= (unint64_t)(v16 + 1000)) {
        size_t v20 = (size_t)(v16 + 1000);
      }
      else {
        size_t v20 = 2 * v18;
      }
      a2[2] = (char *)v20;
      size_t v19 = (char *)realloc(v19, v20);
      *a2 = v19;
      if (!v19) {
        goto LABEL_33;
      }
      uint64_t v17 = (uint64_t)a2[1];
    }
    *(_WORD *)&v19[v17] = 23899;
    uint64_t v17 = (uint64_t)(a2[1] + 2);
    a2[1] = (char *)v17;
  }
  uint64_t v21 = v17 + 1;
  unint64_t v22 = (unint64_t)a2[2];
  unint64_t v23 = *a2;
  if (v17 + 1 <= v22) {
    goto LABEL_29;
  }
  unint64_t v24 = v17 + 993;
  if (2 * v22 <= v24) {
    size_t v25 = v24;
  }
  else {
    size_t v25 = 2 * v22;
  }
  a2[2] = (char *)v25;
  unint64_t v23 = (char *)realloc(v23, v25);
  *a2 = v23;
  if (!v23) {
LABEL_33:
  }
    abort();
  uint64_t v17 = (uint64_t)a2[1];
  uint64_t v21 = v17 + 1;
LABEL_29:
  a2[1] = (char *)v21;
  v23[v17] = 32;
  uint64_t v26 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v26 + 32))(v26, a2);
  if ((*(_WORD *)(v26 + 9) & 0xC0) != 0x40)
  {
    char v28 = *(uint64_t (**)(uint64_t, char **))(*(void *)v26 + 40);
    return v28(v26, a2);
  }
  return result;
}

char *llvm::itanium_demangle::CallExpr::printLeft(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
  }
  ++*(_DWORD *)(a2 + 32);
  unint64_t v5 = *(char **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = v6 + 1;
  unint64_t v8 = *(void *)(a2 + 16);
  if (v6 + 1 > v8)
  {
    unint64_t v9 = v6 + 993;
    if (2 * v8 <= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = 2 * v8;
    }
    *(void *)(a2 + 16) = v10;
    unint64_t v5 = (char *)realloc(v5, v10);
    *(void *)a2 = v5;
    if (!v5) {
      goto LABEL_30;
    }
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = v6 + 1;
  }
  *(void *)(a2 + 8) = v7;
  v5[v6] = 40;
  uint64_t v11 = *(void *)(a2 + 8);
  if (a1[4])
  {
    uint64_t v12 = 0;
    char v13 = 1;
    while (1)
    {
      uint64_t v14 = v11;
      if ((v13 & 1) == 0)
      {
        unint64_t v15 = *(void *)(a2 + 16);
        uint64_t v16 = *(char **)a2;
        if (v11 + 2 <= v15)
        {
          uint64_t v19 = v11;
        }
        else
        {
          unint64_t v17 = 2 * v15;
          if (v17 <= v11 + 994) {
            size_t v18 = v11 + 994;
          }
          else {
            size_t v18 = v17;
          }
          *(void *)(a2 + 16) = v18;
          uint64_t v16 = (char *)realloc(v16, v18);
          *(void *)a2 = v16;
          if (!v16) {
            goto LABEL_30;
          }
          uint64_t v19 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v16[v19] = 8236;
        uint64_t v14 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v14;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[3] + 8 * v12), a2, 18, 0);
      if (v14 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v11;
        if (++v12 == a1[4]) {
          break;
        }
      }
      else
      {
        char v13 = 0;
        uint64_t v11 = *(void *)(a2 + 8);
        if (++v12 == a1[4]) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v20 = v11 + 1;
  unint64_t v21 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v11 + 1 > v21)
  {
    unint64_t v23 = 2 * v21;
    if (v23 <= v11 + 993) {
      size_t v24 = v11 + 993;
    }
    else {
      size_t v24 = v23;
    }
    *(void *)(a2 + 16) = v24;
    uint64_t result = (char *)realloc(result, v24);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v11 = *(void *)(a2 + 8);
      uint64_t v20 = v11 + 1;
      goto LABEL_29;
    }
LABEL_30:
    abort();
  }
LABEL_29:
  *(void *)(a2 + 8) = v20;
  result[v11] = 41;
  return result;
}

char *llvm::itanium_demangle::ConversionExpr::printLeft(void *a1, uint64_t a2)
{
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_42;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  v4[v5] = 40;
  uint64_t v10 = a1[2];
  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a2);
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v11 = *(char **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  uint64_t v13 = v12 + 1;
  unint64_t v14 = *(void *)(a2 + 16);
  if (v12 + 1 > v14)
  {
    unint64_t v15 = v12 + 993;
    if (2 * v14 <= v15) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = 2 * v14;
    }
    *(void *)(a2 + 16) = v16;
    uint64_t v11 = (char *)realloc(v11, v16);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_42;
    }
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v13 = v12 + 1;
  }
  *(void *)(a2 + 8) = v13;
  v11[v12] = 41;
  ++*(_DWORD *)(a2 + 32);
  unint64_t v17 = *(char **)a2;
  uint64_t v18 = *(void *)(a2 + 8);
  uint64_t v19 = v18 + 1;
  unint64_t v20 = *(void *)(a2 + 16);
  if (v18 + 1 > v20)
  {
    unint64_t v21 = v18 + 993;
    if (2 * v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = 2 * v20;
    }
    *(void *)(a2 + 16) = v22;
    unint64_t v17 = (char *)realloc(v17, v22);
    *(void *)a2 = v17;
    if (!v17) {
      goto LABEL_42;
    }
    uint64_t v18 = *(void *)(a2 + 8);
    uint64_t v19 = v18 + 1;
  }
  *(void *)(a2 + 8) = v19;
  v17[v18] = 40;
  uint64_t v23 = *(void *)(a2 + 8);
  if (a1[4])
  {
    uint64_t v24 = 0;
    char v25 = 1;
    while (1)
    {
      uint64_t v26 = v23;
      if ((v25 & 1) == 0)
      {
        unint64_t v27 = *(void *)(a2 + 16);
        char v28 = *(char **)a2;
        if (v23 + 2 <= v27)
        {
          uint64_t v31 = v23;
        }
        else
        {
          unint64_t v29 = 2 * v27;
          if (v29 <= v23 + 994) {
            size_t v30 = v23 + 994;
          }
          else {
            size_t v30 = v29;
          }
          *(void *)(a2 + 16) = v30;
          char v28 = (char *)realloc(v28, v30);
          *(void *)a2 = v28;
          if (!v28) {
            goto LABEL_42;
          }
          uint64_t v31 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v28[v31] = 8236;
        uint64_t v26 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v26;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[3] + 8 * v24), a2, 18, 0);
      if (v26 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v23;
        if (++v24 == a1[4]) {
          break;
        }
      }
      else
      {
        char v25 = 0;
        uint64_t v23 = *(void *)(a2 + 8);
        if (++v24 == a1[4]) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v32 = v23 + 1;
  unint64_t v33 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v23 + 1 > v33)
  {
    unint64_t v35 = 2 * v33;
    if (v35 <= v23 + 993) {
      size_t v36 = v23 + 993;
    }
    else {
      size_t v36 = v35;
    }
    *(void *)(a2 + 16) = v36;
    uint64_t result = (char *)realloc(result, v36);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v23 = *(void *)(a2 + 8);
      uint64_t v32 = v23 + 1;
      goto LABEL_41;
    }
LABEL_42:
    abort();
  }
LABEL_41:
  *(void *)(a2 + 8) = v32;
  result[v23] = 41;
  return result;
}

void *llvm::itanium_demangle::ConditionalExpr::printLeft(uint64_t a1, char **a2)
{
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), (uint64_t)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 3) > v6)
  {
    size_t v7 = (size_t)(v5 + 995);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  int v10[2] = 32;
  *(_WORD *)uint64_t v10 = 16160;
  a2[1] += 3;
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 24), (uint64_t)a2, 19, 0);
  uint64_t v11 = *a2;
  uint64_t v12 = a2[1];
  unint64_t v13 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 3) <= v13) {
    goto LABEL_13;
  }
  size_t v14 = (size_t)(v12 + 995);
  unint64_t v15 = 2 * v13;
  if (v15 <= v14) {
    size_t v16 = v14;
  }
  else {
    size_t v16 = v15;
  }
  a2[2] = (char *)v16;
  uint64_t v11 = (char *)realloc(v11, v16);
  *a2 = v11;
  if (!v11) {
LABEL_16:
  }
    abort();
  uint64_t v12 = a2[1];
LABEL_13:
  unint64_t v17 = &v12[(void)v11];
  v17[2] = 32;
  *(_WORD *)unint64_t v17 = 14880;
  a2[1] += 3;
  uint64_t v18 = *(void *)(a1 + 32);

  return llvm::itanium_demangle::Node::printAsOperand(v18, (uint64_t)a2, 17, 1);
}

char *llvm::itanium_demangle::CastExpr::printLeft(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(void *)(a1 + 24);
  size_t v5 = *(void *)(a2 + 8);
  if (v4)
  {
    unint64_t v6 = *(const void **)(a1 + 16);
    size_t v7 = v5 + v4;
    size_t v8 = *(void *)(a2 + 16);
    size_t v9 = *(char **)a2;
    if (v5 + v4 > v8)
    {
      if (2 * v8 <= v7 + 992) {
        size_t v10 = v7 + 992;
      }
      else {
        size_t v10 = 2 * v8;
      }
      *(void *)(a2 + 16) = v10;
      size_t v9 = (char *)realloc(v9, v10);
      *(void *)a2 = v9;
      if (!v9) {
        goto LABEL_34;
      }
      size_t v5 = *(void *)(a2 + 8);
    }
    memcpy(&v9[v5], v6, v4);
    size_t v5 = *(void *)(a2 + 8) + v4;
    *(void *)(a2 + 8) = v5;
  }
  int v11 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  unint64_t v12 = *(void *)(a2 + 16);
  unint64_t v13 = *(char **)a2;
  if (v5 + 1 > v12)
  {
    size_t v14 = v5 + 993;
    unint64_t v15 = 2 * v12;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    *(void *)(a2 + 16) = v16;
    unint64_t v13 = (char *)realloc(v13, v16);
    *(void *)a2 = v13;
    if (!v13) {
      goto LABEL_34;
    }
    size_t v5 = *(void *)(a2 + 8);
  }
  v13[v5] = 60;
  ++*(void *)(a2 + 8);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), a2);
  unint64_t v17 = *(char **)a2;
  uint64_t v18 = *(void *)(a2 + 8);
  unint64_t v19 = *(void *)(a2 + 16);
  if (v18 + 1 > v19)
  {
    size_t v20 = v18 + 993;
    unint64_t v21 = 2 * v19;
    if (v21 <= v20) {
      size_t v22 = v20;
    }
    else {
      size_t v22 = v21;
    }
    *(void *)(a2 + 16) = v22;
    unint64_t v17 = (char *)realloc(v17, v22);
    *(void *)a2 = v17;
    if (!v17) {
      goto LABEL_34;
    }
    uint64_t v18 = *(void *)(a2 + 8);
  }
  v17[v18] = 62;
  uint64_t v23 = *(char **)a2;
  uint64_t v24 = *(void *)(a2 + 8);
  uint64_t v25 = v24 + 1;
  *(void *)(a2 + 8) = v24 + 1;
  *(_DWORD *)(a2 + 32) = v11 + 1;
  uint64_t v26 = v24 + 2;
  unint64_t v27 = *(void *)(a2 + 16);
  if (v24 + 2 > v27)
  {
    if (2 * v27 <= v24 + 994) {
      size_t v28 = v24 + 994;
    }
    else {
      size_t v28 = 2 * v27;
    }
    *(void *)(a2 + 16) = v28;
    uint64_t v23 = (char *)realloc(v23, v28);
    *(void *)a2 = v23;
    if (!v23) {
      goto LABEL_34;
    }
    uint64_t v25 = *(void *)(a2 + 8);
    uint64_t v26 = v25 + 1;
  }
  *(void *)(a2 + 8) = v26;
  v23[v25] = 40;
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 40), a2, 19, 0);
  --*(_DWORD *)(a2 + 32);
  uint64_t result = *(char **)a2;
  uint64_t v30 = *(void *)(a2 + 8);
  uint64_t v31 = v30 + 1;
  unint64_t v32 = *(void *)(a2 + 16);
  if (v30 + 1 > v32)
  {
    unint64_t v33 = v30 + 993;
    if (2 * v32 <= v33) {
      size_t v34 = v33;
    }
    else {
      size_t v34 = 2 * v32;
    }
    *(void *)(a2 + 16) = v34;
    uint64_t result = (char *)realloc(result, v34);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v30 = *(void *)(a2 + 8);
      uint64_t v31 = v30 + 1;
      goto LABEL_33;
    }
LABEL_34:
    abort();
  }
LABEL_33:
  *(void *)(a2 + 8) = v31;
  result[v30] = 41;
  return result;
}

char *llvm::itanium_demangle::EnclosingExpr::printLeft(void *a1, char **a2)
{
  size_t v4 = a1[3];
  size_t v5 = (size_t)a2[1];
  if (v4)
  {
    unint64_t v6 = (const void *)a1[2];
    size_t v7 = v5 + v4;
    size_t v8 = (size_t)a2[2];
    size_t v9 = *a2;
    if (v5 + v4 > v8)
    {
      if (2 * v8 <= v7 + 992) {
        size_t v10 = v7 + 992;
      }
      else {
        size_t v10 = 2 * v8;
      }
      a2[2] = (char *)v10;
      size_t v9 = (char *)realloc(v9, v10);
      *a2 = v9;
      if (!v9) {
        goto LABEL_32;
      }
      size_t v5 = (size_t)a2[1];
    }
    memcpy(&v9[v5], v6, v4);
    size_t v5 = (size_t)&a2[1][v4];
    a2[1] = (char *)v5;
  }
  ++*((_DWORD *)a2 + 8);
  size_t v11 = v5 + 1;
  unint64_t v12 = (unint64_t)a2[2];
  unint64_t v13 = *a2;
  if (v5 + 1 > v12)
  {
    unint64_t v14 = v5 + 993;
    if (2 * v12 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = 2 * v12;
    }
    a2[2] = (char *)v15;
    unint64_t v13 = (char *)realloc(v13, v15);
    *a2 = v13;
    if (!v13) {
      goto LABEL_32;
    }
    size_t v5 = (size_t)a2[1];
    size_t v11 = v5 + 1;
  }
  a2[1] = (char *)v11;
  v13[v5] = 40;
  uint64_t v16 = a1[4];
  (*(void (**)(uint64_t, char **))(*(void *)v16 + 32))(v16, a2);
  if ((*(_WORD *)(v16 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v16 + 40))(v16, a2);
  }
  --*((_DWORD *)a2 + 8);
  uint64_t result = *a2;
  uint64_t v18 = a2[1];
  unint64_t v19 = v18 + 1;
  unint64_t v20 = (unint64_t)a2[2];
  if ((unint64_t)(v18 + 1) > v20)
  {
    unint64_t v21 = (unint64_t)(v18 + 993);
    if (2 * v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = 2 * v20;
    }
    a2[2] = (char *)v22;
    uint64_t result = (char *)realloc(result, v22);
    *a2 = result;
    if (!result) {
      goto LABEL_32;
    }
    uint64_t v18 = a2[1];
    unint64_t v19 = v18 + 1;
  }
  a2[1] = v19;
  v18[(void)result] = 41;
  size_t v23 = a1[6];
  if (!v23) {
    return result;
  }
  uint64_t v24 = (const void *)a1[5];
  uint64_t v25 = *a2;
  uint64_t v26 = a2[1];
  unint64_t v27 = &v26[v23];
  size_t v28 = (size_t)a2[2];
  if ((unint64_t)&v26[v23] > v28)
  {
    unint64_t v29 = 2 * v28;
    if (v29 <= (unint64_t)(v27 + 992)) {
      size_t v30 = (size_t)(v27 + 992);
    }
    else {
      size_t v30 = v29;
    }
    a2[2] = (char *)v30;
    uint64_t v25 = (char *)realloc(v25, v30);
    *a2 = v25;
    if (v25)
    {
      uint64_t v26 = a2[1];
      goto LABEL_30;
    }
LABEL_32:
    abort();
  }
LABEL_30:
  uint64_t result = (char *)memcpy(&v26[(void)v25], v24, v23);
  a2[1] += v23;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseIntegerLiteral(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v4 = *(unsigned char **)a1;
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 == v3) {
    return 0;
  }
  size_t v8 = *(unsigned char **)a1;
  if (*v4 == 110)
  {
    size_t v8 = v4 + 1;
    *(void *)a1 = v4 + 1;
  }
  if (v3 == v8 || (char)*v8 < 0) {
    return 0;
  }
  uint64_t v9 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v8 + 60) & 0x400) == 0) {
    return 0;
  }
  while (((char)*v8 & 0x80000000) == 0 && (*(_DWORD *)(v9 + 4 * *v8 + 60) & 0x400) != 0)
  {
    *(void *)a1 = ++v8;
    if (v8 == v3)
    {
      size_t v8 = v3;
      break;
    }
  }
  uint64_t result = 0;
  uint64_t v11 = v8 - v4;
  if (v8 != v4 && v8 != v3)
  {
    if (*v8 == 69)
    {
      *(void *)a1 = v8 + 1;
      unint64_t v12 = *(void **)(a1 + 4904);
      uint64_t v13 = v12[1];
      if ((unint64_t)(v13 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
      {
        unint64_t v14 = malloc(0x1000uLL);
        if (!v14) {
          std::terminate();
        }
        uint64_t v13 = 0;
        *unint64_t v14 = v12;
        v14[1] = 0;
        unint64_t v12 = v14;
        *(void *)(a1 + 4904) = v14;
      }
      v12[1] = v13 + 48;
      size_t v15 = (char *)v12 + v13;
      uint64_t result = v15 + 16;
      v15[24] = 77;
      *(_WORD *)(v15 + 25) = *(_WORD *)(v15 + 25) & 0xF000 | 0x540;
      *((void *)v15 + 2) = &unk_1EC9A2600;
      *((void *)v15 + 4) = a2;
      *((void *)v15 + 5) = a3;
      *((void *)v15 + 6) = v4;
      *((void *)v15 + 7) = v11;
      return result;
    }
    return 0;
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::BoolExpr,int>(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4064) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  uint64_t v7 = v4 + 16;
  v3[1] = v7;
  uint64_t result = (char *)v3 + v7;
  result[8] = 73;
  *(_WORD *)(result + 9) = *(_WORD *)(result + 9) & 0xF000 | 0x540;
  *(void *)uint64_t result = &unk_1EC9A3470;
  result[11] = a2 != 0;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::StringLiteral,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 74;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A24F8;
  *((void *)v7 + 4) = v9;
  return result;
}

unsigned __int8 *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseUnnamedTypeName(unsigned __int8 **a1, size_t __size)
{
  if (__size) {
    a1[84] = a1[83];
  }
  uint64_t v4 = *a1;
  uint64_t v3 = (char *)a1[1];
  if ((unint64_t)(v3 - (char *)*a1) < 2) {
    return 0;
  }
  if (*(_WORD *)v4 == 29781)
  {
    uint64_t v13 = (char *)(v4 + 2);
    *a1 = (unsigned __int8 *)v13;
    if (v3 != v13)
    {
      if ((*v13 & 0x80000000) == 0
        && (uint64_t v14 = MEMORY[0x1E4F14390], (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v13 + 60) & 0x400) != 0))
      {
        size_t v23 = v13;
        while ((*v23 & 0x80000000) == 0 && (*(_DWORD *)(v14 + 4 * *v23 + 60) & 0x400) != 0)
        {
          *a1 = (unsigned __int8 *)++v23;
          if (v23 == v3)
          {
            size_t v23 = v3;
            break;
          }
        }
        size_t v15 = v13;
        int64_t v16 = v23 - v13;
        uint64_t v13 = v23;
        if (v23 == v3) {
          return 0;
        }
      }
      else
      {
        size_t v15 = 0;
        int64_t v16 = 0;
        if (v13 == v3) {
          return 0;
        }
      }
      if (*v13 == 95)
      {
        *a1 = (unsigned __int8 *)(v13 + 1);
        uint64_t v24 = a1[613];
        uint64_t v25 = *((void *)v24 + 1);
        if ((unint64_t)(v25 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
        {
          uint64_t v26 = (unsigned __int8 *)malloc(0x1000uLL);
          if (!v26) {
            goto LABEL_114;
          }
          uint64_t v25 = 0;
          *(void *)uint64_t v26 = v24;
          *((void *)v26 + 1) = 0;
          uint64_t v24 = v26;
          a1[613] = v26;
        }
        *((void *)v24 + 1) = v25 + 32;
        unint64_t v27 = &v24[v25];
        size_t v5 = v27 + 16;
        v27[24] = 51;
        *(_WORD *)(v27 + 25) = *(_WORD *)(v27 + 25) & 0xF000 | 0x540;
        *((void *)v27 + 2) = &unk_1EC9A2918;
        *((void *)v27 + 4) = v15;
        *((void *)v27 + 5) = v16;
        return v5;
      }
    }
    return 0;
  }
  if (*(_WORD *)v4 != 27733)
  {
    if (*(_WORD *)v4 != 25173) {
      return 0;
    }
    uint64_t v7 = (char *)(v4 + 2);
    *a1 = (unsigned __int8 *)v7;
    if (v3 == v7) {
      return 0;
    }
    if ((*v7 & 0x80000000) == 0)
    {
      uint64_t v8 = MEMORY[0x1E4F14390];
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v7 + 60) & 0x400) != 0)
      {
        while ((*v7 & 0x80000000) == 0 && (*(_DWORD *)(v8 + 4 * *v7 + 60) & 0x400) != 0)
        {
          size_t v5 = 0;
          *a1 = (unsigned __int8 *)++v7;
          if (v7 == v3) {
            return v5;
          }
        }
      }
    }
    if (v7 == v3 || *v7 != 95) {
      return 0;
    }
    *a1 = (unsigned __int8 *)(v7 + 1);
    uint64_t v9 = a1[613];
    uint64_t v10 = *((void *)v9 + 1);
    if ((unint64_t)(v10 - 4048) > 0xFFFFFFFFFFFFF00FLL)
    {
LABEL_17:
      *((void *)v9 + 1) = v10 + 32;
      unint64_t v12 = &v9[v10];
      size_t v5 = v12 + 16;
      v12[24] = 8;
      *(_WORD *)(v12 + 25) = *(_WORD *)(v12 + 25) & 0xF000 | 0x540;
      *((void *)v12 + 2) = &unk_1EC9A3628;
      *((void *)v12 + 4) = "'block-literal'";
      *((void *)v12 + 5) = 15;
      return v5;
    }
    uint64_t v11 = (unsigned __int8 *)malloc(0x1000uLL);
    if (v11)
    {
      uint64_t v10 = 0;
      *(void *)uint64_t v11 = v9;
      *((void *)v11 + 1) = 0;
      uint64_t v9 = v11;
      a1[613] = v11;
      goto LABEL_17;
    }
LABEL_114:
    std::terminate();
  }
  *a1 = v4 + 2;
  unint64_t v17 = a1[84];
  uint64_t v18 = a1[83];
  uint64_t v19 = v17 - v18;
  uint64_t v20 = (v17 - v18) >> 3;
  unint64_t v21 = a1[98];
  a1[98] = (unsigned __int8 *)v20;
  uint64_t v75 = a1;
  uint64_t v76 = v20;
  v77[0] = v78;
  v77[1] = v78;
  uint64_t v69 = v21;
  v77[2] = &v79;
  memset(v78, 0, sizeof(v78));
  if (v17 == a1[85])
  {
    if (v18 == (unsigned __int8 *)(a1 + 86))
    {
      size_t v28 = (unsigned __int8 *)malloc(2 * v19);
      if (!v28) {
        goto LABEL_113;
      }
      size_t v22 = v28;
      if (v17 != v18) {
        memmove(v28, v18, v17 - v18);
      }
      a1[83] = v22;
    }
    else
    {
      size_t v22 = (unsigned __int8 *)realloc(v18, 2 * v19);
      a1[83] = v22;
      if (!v22) {
LABEL_113:
      }
        abort();
    }
    unint64_t v17 = &v22[8 * v20];
    a1[85] = &v22[8 * (v19 >> 2)];
  }
  a1[84] = v17 + 8;
  *(void *)unint64_t v17 = v77;
  unint64_t v29 = a1[2];
  size_t v30 = a1[3];
  uint64_t v31 = *a1;
  unint64_t v32 = a1[1] - *a1;
  if (v32)
  {
    unint64_t v33 = a1 + 5;
    do
    {
      if (*v31 != 84) {
        break;
      }
      int v36 = v32 < 2 ? 0 : (char)v31[1];
      uint64_t v37 = memchr("yptnk", v36, 5uLL);
      if (!v37 || v37 - "yptnk" == -1) {
        break;
      }
      if (!v38) {
        goto LABEL_99;
      }
      size_t v39 = v38;
      unint64_t v35 = a1[3];
      if (v35 == a1[4])
      {
        unint64_t v40 = a1[2];
        int64_t v41 = v35 - v40;
        if (v40 == (unsigned __int8 *)v33)
        {
          size_t v42 = (unsigned __int8 *)malloc(2 * (v35 - v40));
          if (!v42) {
            goto LABEL_113;
          }
          size_t v34 = v42;
          if (v35 != (unsigned __int8 *)v33) {
            memcpy(v42, a1 + 5, v41);
          }
          a1[2] = v34;
        }
        else
        {
          size_t v34 = (unsigned __int8 *)realloc(v40, 2 * (v35 - v40));
          a1[2] = v34;
          if (!v34) {
            goto LABEL_113;
          }
        }
        unint64_t v35 = &v34[8 * (v41 >> 3)];
        a1[4] = &v34[8 * (v41 >> 2)];
      }
      a1[3] = v35 + 8;
      *(void *)unint64_t v35 = v39;
      uint64_t v31 = *a1;
      unint64_t v32 = a1[1] - *a1;
    }
    while (v32);
  }
  v74.n128_u64[1] = v43;
  if (!v43) {
    a1[84] -= 8;
  }
  uint64_t v73 = 0;
  size_t v44 = *a1;
  uint64_t v45 = a1[1];
  if (*a1 == v45) {
    goto LABEL_74;
  }
  if (*v44 == 81)
  {
    *a1 = v44 + 1;
    char v46 = *((unsigned char *)a1 + 778);
    *((unsigned char *)a1 + 778) = 1;
    *((unsigned char *)a1 + 778) = v46;
    uint64_t v73 = v47;
    if (!v47) {
      goto LABEL_99;
    }
    size_t v44 = *a1;
    uint64_t v45 = a1[1];
  }
  if (v45 == v44 || *v44 != 118)
  {
LABEL_74:
    uint64_t v48 = a1 + 5;
    while (1)
    {
      if (!v50) {
        goto LABEL_99;
      }
      uint64_t v51 = v50;
      size_t v52 = a1[3];
      if (v52 == a1[4])
      {
        uint64_t v53 = a1[2];
        int64_t v54 = v52 - v53;
        if (v53 == (unsigned __int8 *)v48)
        {
          uint64_t v56 = (unsigned __int8 *)malloc(2 * (v52 - v53));
          if (!v56) {
            goto LABEL_113;
          }
          char v55 = v56;
          if (v52 != (unsigned __int8 *)v48) {
            memcpy(v56, a1 + 5, v54);
          }
          a1[2] = v55;
        }
        else
        {
          char v55 = (unsigned __int8 *)realloc(v53, 2 * (v52 - v53));
          a1[2] = v55;
          if (!v55) {
            goto LABEL_113;
          }
        }
        size_t v52 = &v55[8 * (v54 >> 3)];
        a1[4] = &v55[8 * (v54 >> 2)];
      }
      a1[3] = v52 + 8;
      *(void *)size_t v52 = v51;
      if (a1[1] == *a1)
      {
        int v49 = 0;
      }
      else
      {
        int v49 = **a1;
        if (v49 == 69) {
          goto LABEL_89;
        }
      }
      if (v49 == 81) {
        goto LABEL_89;
      }
    }
  }
  *a1 = v44 + 1;
LABEL_89:
  *((void *)&v72 + 1) = v57;
  uint64_t v71 = 0;
  unint64_t v59 = (char *)*a1;
  uint64_t v58 = (char *)a1[1];
  if (*a1 != (unsigned __int8 *)v58)
  {
    size_t v60 = v69;
    if (*v59 == 81)
    {
      *a1 = (unsigned __int8 *)(v59 + 1);
      char v61 = *((unsigned char *)a1 + 778);
      *((unsigned char *)a1 + 778) = 1;
      *((unsigned char *)a1 + 778) = v61;
      uint64_t v71 = v62;
      if (!v62) {
        goto LABEL_109;
      }
      unint64_t v59 = (char *)*a1;
      uint64_t v58 = (char *)a1[1];
    }
    if (v59 != v58 && *v59 == 69)
    {
      unint64_t v63 = v59 + 1;
      *a1 = (unsigned __int8 *)v63;
      if (v58 != v63)
      {
        if ((*v63 & 0x80000000) == 0
          && (uint64_t v64 = MEMORY[0x1E4F14390],
              (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v63 + 60) & 0x400) != 0))
        {
          uint64_t v67 = v63;
          while ((*v67 & 0x80000000) == 0 && (*(_DWORD *)(v64 + 4 * *v67 + 60) & 0x400) != 0)
          {
            *a1 = (unsigned __int8 *)++v67;
            if (v67 == v58)
            {
              uint64_t v67 = v58;
              break;
            }
          }
          size_t v65 = v63;
          int64_t v66 = v67 - v63;
          unint64_t v63 = v67;
        }
        else
        {
          size_t v65 = 0;
          int64_t v66 = 0;
        }
        *(void *)&long long v70 = v65;
        *((void *)&v70 + 1) = v66;
        if (v63 != v58 && *v63 == 95)
        {
          *a1 = (unsigned __int8 *)(v63 + 1);
          size_t v5 = v68;
          goto LABEL_110;
        }
      }
    }
LABEL_109:
    size_t v5 = 0;
    goto LABEL_110;
  }
LABEL_99:
  size_t v5 = 0;
  size_t v60 = v69;
LABEL_110:
  v75[84] = &v75[83][8 * v76];
  if (v77[0] != v78) {
    free(v77[0]);
  }
  a1[98] = v60;
  return v5;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::LambdaExpr,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 75;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1C08;
  *((void *)v7 + 4) = v9;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::EnumLiteral,llvm::itanium_demangle::Node *&,std::string_view &>(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  size_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    size_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 48;
  uint64_t v9 = (char *)v5 + v6;
  uint64_t v10 = *a2;
  v9[24] = 76;
  __int16 v11 = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A1E18;
  __n128 result = *a3;
  *(_WORD *)(v9 + 25) = v11;
  *((void *)v9 + 4) = v10;
  *(__n128 *)(v9 + 40) = result;
  return result;
}

void *llvm::itanium_demangle::IntegerLiteral::printLeft(void *result, char **a2)
{
  uint64_t v3 = result;
  if (result[3] >= 4uLL)
  {
    ++*((_DWORD *)a2 + 8);
    uint64_t v4 = *a2;
    size_t v5 = a2[1];
    uint64_t v6 = v5 + 1;
    unint64_t v7 = (unint64_t)a2[2];
    if ((unint64_t)(v5 + 1) > v7)
    {
      unint64_t v8 = (unint64_t)(v5 + 993);
      if (2 * v7 <= v8) {
        size_t v9 = v8;
      }
      else {
        size_t v9 = 2 * v7;
      }
      a2[2] = (char *)v9;
      uint64_t v4 = (char *)realloc(v4, v9);
      *a2 = v4;
      if (!v4) {
        goto LABEL_57;
      }
      size_t v5 = a2[1];
      uint64_t v6 = v5 + 1;
    }
    a2[1] = v6;
    v5[(void)v4] = 40;
    size_t v10 = v3[3];
    size_t v11 = (size_t)a2[1];
    if (v10)
    {
      unint64_t v12 = (const void *)v3[2];
      size_t v13 = v11 + v10;
      size_t v14 = (size_t)a2[2];
      size_t v15 = *a2;
      if (v11 + v10 > v14)
      {
        if (2 * v14 <= v13 + 992) {
          size_t v16 = v13 + 992;
        }
        else {
          size_t v16 = 2 * v14;
        }
        a2[2] = (char *)v16;
        size_t v15 = (char *)realloc(v15, v16);
        *a2 = v15;
        if (!v15) {
          goto LABEL_57;
        }
        size_t v11 = (size_t)a2[1];
      }
      memcpy(&v15[v11], v12, v10);
      size_t v11 = (size_t)&a2[1][v10];
      a2[1] = (char *)v11;
    }
    --*((_DWORD *)a2 + 8);
    size_t v17 = v11 + 1;
    unint64_t v18 = (unint64_t)a2[2];
    __n128 result = *a2;
    if (v11 + 1 > v18)
    {
      unint64_t v19 = v11 + 993;
      if (2 * v18 <= v19) {
        size_t v20 = v19;
      }
      else {
        size_t v20 = 2 * v18;
      }
      a2[2] = (char *)v20;
      __n128 result = realloc(result, v20);
      *a2 = (char *)result;
      if (!result) {
        goto LABEL_57;
      }
      size_t v11 = (size_t)a2[1];
      size_t v17 = v11 + 1;
    }
    a2[1] = (char *)v17;
    *((unsigned char *)result + v11) = 41;
  }
  unint64_t v21 = (unsigned char *)v3[4];
  if (*v21 == 110)
  {
    size_t v23 = (uint64_t *)(a2 + 1);
    uint64_t v22 = (uint64_t)a2[1];
    uint64_t v24 = v22 + 1;
    unint64_t v25 = (unint64_t)a2[2];
    __n128 result = *a2;
    if (v22 + 1 > v25)
    {
      unint64_t v26 = v22 + 993;
      if (2 * v25 <= v26) {
        size_t v27 = v26;
      }
      else {
        size_t v27 = 2 * v25;
      }
      a2[2] = (char *)v27;
      __n128 result = realloc(result, v27);
      *a2 = (char *)result;
      if (!result) {
        goto LABEL_57;
      }
      uint64_t v22 = *v23;
      uint64_t v24 = *v23 + 1;
    }
    *size_t v23 = v24;
    *((unsigned char *)result + v22) = 45;
    uint64_t v28 = v3[5];
    size_t v29 = v28 - 1;
    if (v28 != 1)
    {
      uint64_t v30 = v3[4];
      uint64_t v31 = *a2;
      uint64_t v32 = (uint64_t)a2[1];
      size_t v33 = v32 + v29;
      size_t v34 = (size_t)a2[2];
      if (v32 + v29 > v34)
      {
        unint64_t v35 = 2 * v34;
        if (v35 <= v33 + 992) {
          size_t v36 = v33 + 992;
        }
        else {
          size_t v36 = v35;
        }
        a2[2] = (char *)v36;
        uint64_t v31 = (char *)realloc(v31, v36);
        *a2 = v31;
        if (!v31) {
          goto LABEL_57;
        }
        uint64_t v32 = *v23;
      }
      uint64_t v37 = (const void *)(v30 + 1);
      unint64_t v38 = &v31[v32];
LABEL_46:
      __n128 result = memcpy(v38, v37, v29);
      *v23 += v29;
    }
  }
  else
  {
    size_t v29 = v3[5];
    if (v29)
    {
      size_t v23 = (uint64_t *)(a2 + 1);
      uint64_t v39 = (uint64_t)a2[1];
      size_t v40 = v39 + v29;
      size_t v41 = (size_t)a2[2];
      size_t v42 = *a2;
      if (v39 + v29 > v41)
      {
        if (2 * v41 <= v40 + 992) {
          size_t v43 = v40 + 992;
        }
        else {
          size_t v43 = 2 * v41;
        }
        a2[2] = (char *)v43;
        size_t v42 = (char *)realloc(v42, v43);
        *a2 = v42;
        if (!v42) {
          goto LABEL_57;
        }
        uint64_t v39 = *v23;
      }
      unint64_t v38 = &v42[v39];
      uint64_t v37 = v21;
      goto LABEL_46;
    }
  }
  size_t v44 = v3[3];
  if (v44 <= 3 && v44)
  {
    uint64_t v45 = (const void *)v3[2];
    char v46 = *a2;
    uint64_t v47 = a2[1];
    uint64_t v48 = &v47[v44];
    size_t v49 = (size_t)a2[2];
    if ((unint64_t)&v47[v44] <= v49)
    {
LABEL_55:
      __n128 result = memcpy(&v47[(void)v46], v45, v44);
      a2[1] += v44;
      return result;
    }
    unint64_t v50 = 2 * v49;
    if (v50 <= (unint64_t)(v48 + 992)) {
      size_t v51 = (size_t)(v48 + 992);
    }
    else {
      size_t v51 = v50;
    }
    a2[2] = (char *)v51;
    char v46 = (char *)realloc(v46, v51);
    *a2 = v46;
    if (v46)
    {
      uint64_t v47 = a2[1];
      goto LABEL_55;
    }
LABEL_57:
    abort();
  }
  return result;
}

void *llvm::itanium_demangle::BoolExpr::printLeft(uint64_t a1, char **a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 11);
  if (*(unsigned char *)(a1 + 11)) {
    size_t v4 = 4;
  }
  else {
    size_t v4 = 5;
  }
  size_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = &v6[v4];
  size_t v8 = (size_t)a2[2];
  if ((unint64_t)&v6[v4] > v8)
  {
    unint64_t v9 = 2 * v8;
    if (v9 <= (unint64_t)(v7 + 992)) {
      size_t v10 = (size_t)(v7 + 992);
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    size_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  if (v3) {
    size_t v11 = "true";
  }
  else {
    size_t v11 = "false";
  }
  __n128 result = memcpy(&v6[(void)v5], v11, v4);
  a2[1] += v4;
  return result;
}

void *llvm::itanium_demangle::FloatLiteralImpl<float>::printLeft(void *result, char **a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (*((void *)result + 3) < 8uLL) {
    return result;
  }
  int v3 = (char *)*((void *)result + 2);
  uint64_t v4 = *v3;
  if ((*v3 & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x400) != 0)
  {
    char v5 = v4 - 48;
    uint64_t v6 = v3[1];
    if (v3[1] < 0) {
      goto LABEL_8;
    }
  }
  else
  {
    char v5 = v4 - 87;
    uint64_t v6 = v3[1];
    if (v3[1] < 0)
    {
LABEL_8:
      LOBYTE(v31) = v6 - 87 + 16 * v5;
      uint64_t v7 = v3[2];
      if (v3[2] < 0) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x400) == 0) {
    goto LABEL_8;
  }
  LOBYTE(v31) = v6 - 48 + 16 * v5;
  uint64_t v7 = v3[2];
  if (v3[2] < 0) {
    goto LABEL_12;
  }
LABEL_11:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x400) != 0)
  {
    char v8 = v7 - 48;
    uint64_t v9 = v3[3];
    if (v3[3] < 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_12:
  char v8 = v7 - 87;
  uint64_t v9 = v3[3];
  if (v3[3] < 0)
  {
LABEL_16:
    BYTE1(v31) = v9 - 87 + 16 * v8;
    uint64_t v10 = v3[4];
    if (v3[4] < 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_15:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x400) == 0) {
    goto LABEL_16;
  }
  BYTE1(v31) = v9 - 48 + 16 * v8;
  uint64_t v10 = v3[4];
  if (v3[4] < 0) {
    goto LABEL_20;
  }
LABEL_19:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v10 + 60) & 0x400) != 0)
  {
    char v11 = v10 - 48;
    uint64_t v12 = v3[5];
    if (v3[5] < 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
LABEL_20:
  char v11 = v10 - 87;
  uint64_t v12 = v3[5];
  if (v3[5] < 0) {
    goto LABEL_24;
  }
LABEL_23:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x400) != 0)
  {
    char v13 = -48;
    goto LABEL_26;
  }
LABEL_24:
  char v13 = -87;
LABEL_26:
  BYTE2(v31) = v12 + v13 + 16 * v11;
  uint64_t v14 = v3[6];
  if ((v3[6] & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v14 + 60) & 0x400) != 0)
  {
    size_t v15 = (char *)&v31 + 3;
    char v16 = v14 - 48;
    int v19 = v3[7];
    uint64_t v18 = v3[7];
    if (v19 < 0) {
      goto LABEL_32;
    }
  }
  else
  {
    size_t v15 = (char *)&v31 + 3;
    char v16 = v14 - 87;
    int v17 = v3[7];
    uint64_t v18 = v3[7];
    if (v17 < 0) {
      goto LABEL_32;
    }
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x400) != 0)
  {
    char v20 = -48;
    goto LABEL_34;
  }
LABEL_32:
  char v20 = -87;
LABEL_34:
  HIBYTE(v31) = v18 + v20 + 16 * v16;
  unint64_t v21 = (char *)&v31 + 1;
  do
  {
    char v22 = *(v21 - 1);
    *(v21 - 1) = *v15;
    *v15-- = v22;
  }
  while (v21++ < v15);
  *(void *)std::string __str = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  __n128 result = (void *)snprintf(__str, 0x18uLL, "%af", v31);
  if (result)
  {
    size_t v24 = (int)result;
    unint64_t v25 = *a2;
    unint64_t v26 = a2[1];
    size_t v27 = &v26[v24];
    size_t v28 = (size_t)a2[2];
    if ((unint64_t)&v26[v24] > v28)
    {
      unint64_t v29 = 2 * v28;
      if (v29 <= (unint64_t)(v27 + 992)) {
        size_t v30 = (size_t)(v27 + 992);
      }
      else {
        size_t v30 = v29;
      }
      a2[2] = (char *)v30;
      unint64_t v25 = (char *)realloc(v25, v30);
      *a2 = v25;
      if (!v25) {
        abort();
      }
      unint64_t v26 = a2[1];
    }
    __n128 result = memcpy(&v26[(void)v25], __str, v24);
    a2[1] += v24;
  }
  return result;
}

void *llvm::itanium_demangle::FloatLiteralImpl<double>::printLeft(void *result, char **a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (*((void *)result + 3) < 0x10uLL) {
    return result;
  }
  int v3 = (char *)*((void *)result + 2);
  uint64_t v4 = *v3;
  if ((*v3 & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x400) != 0)
  {
    char v5 = v4 - 48;
    uint64_t v6 = v3[1];
    if (v3[1] < 0) {
      goto LABEL_8;
    }
  }
  else
  {
    char v5 = v4 - 87;
    uint64_t v6 = v3[1];
    if (v3[1] < 0)
    {
LABEL_8:
      LOBYTE(v43) = v6 - 87 + 16 * v5;
      uint64_t v7 = v3[2];
      if (v3[2] < 0) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x400) == 0) {
    goto LABEL_8;
  }
  LOBYTE(v43) = v6 - 48 + 16 * v5;
  uint64_t v7 = v3[2];
  if (v3[2] < 0) {
    goto LABEL_12;
  }
LABEL_11:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x400) != 0)
  {
    char v8 = v7 - 48;
    uint64_t v9 = v3[3];
    if (v3[3] < 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_12:
  char v8 = v7 - 87;
  uint64_t v9 = v3[3];
  if (v3[3] < 0)
  {
LABEL_16:
    BYTE1(v43) = v9 - 87 + 16 * v8;
    uint64_t v10 = v3[4];
    if (v3[4] < 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_15:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x400) == 0) {
    goto LABEL_16;
  }
  BYTE1(v43) = v9 - 48 + 16 * v8;
  uint64_t v10 = v3[4];
  if (v3[4] < 0) {
    goto LABEL_20;
  }
LABEL_19:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v10 + 60) & 0x400) != 0)
  {
    char v11 = v10 - 48;
    uint64_t v12 = v3[5];
    if (v3[5] < 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
LABEL_20:
  char v11 = v10 - 87;
  uint64_t v12 = v3[5];
  if (v3[5] < 0)
  {
LABEL_24:
    BYTE2(v43) = v12 - 87 + 16 * v11;
    uint64_t v13 = v3[6];
    if (v3[6] < 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
LABEL_23:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x400) == 0) {
    goto LABEL_24;
  }
  BYTE2(v43) = v12 - 48 + 16 * v11;
  uint64_t v13 = v3[6];
  if (v3[6] < 0) {
    goto LABEL_28;
  }
LABEL_27:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v13 + 60) & 0x400) != 0)
  {
    char v14 = v13 - 48;
    uint64_t v15 = v3[7];
    if (v3[7] < 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_28:
  char v14 = v13 - 87;
  uint64_t v15 = v3[7];
  if (v3[7] < 0)
  {
LABEL_32:
    BYTE3(v43) = v15 - 87 + 16 * v14;
    uint64_t v16 = v3[8];
    if (v3[8] < 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_31:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x400) == 0) {
    goto LABEL_32;
  }
  BYTE3(v43) = v15 - 48 + 16 * v14;
  uint64_t v16 = v3[8];
  if (v3[8] < 0) {
    goto LABEL_36;
  }
LABEL_35:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x400) != 0)
  {
    char v17 = v16 - 48;
    uint64_t v18 = v3[9];
    if (v3[9] < 0) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
LABEL_36:
  char v17 = v16 - 87;
  uint64_t v18 = v3[9];
  if (v3[9] < 0)
  {
LABEL_40:
    BYTE4(v43) = v18 - 87 + 16 * v17;
    uint64_t v19 = v3[10];
    if (v3[10] < 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
LABEL_39:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x400) == 0) {
    goto LABEL_40;
  }
  BYTE4(v43) = v18 - 48 + 16 * v17;
  uint64_t v19 = v3[10];
  if (v3[10] < 0) {
    goto LABEL_44;
  }
LABEL_43:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v19 + 60) & 0x400) != 0)
  {
    char v20 = v19 - 48;
    uint64_t v21 = v3[11];
    if (v3[11] < 0) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }
LABEL_44:
  char v20 = v19 - 87;
  uint64_t v21 = v3[11];
  if (v3[11] < 0)
  {
LABEL_48:
    BYTE5(v43) = v21 - 87 + 16 * v20;
    uint64_t v22 = v3[12];
    if (v3[12] < 0) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
LABEL_47:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x400) == 0) {
    goto LABEL_48;
  }
  BYTE5(v43) = v21 - 48 + 16 * v20;
  uint64_t v22 = v3[12];
  if (v3[12] < 0) {
    goto LABEL_52;
  }
LABEL_51:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x400) != 0)
  {
    char v23 = v22 - 48;
    uint64_t v24 = v3[13];
    if (v3[13] < 0) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
LABEL_52:
  char v23 = v22 - 87;
  uint64_t v24 = v3[13];
  if (v3[13] < 0) {
    goto LABEL_56;
  }
LABEL_55:
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x400) != 0)
  {
    char v25 = -48;
    goto LABEL_58;
  }
LABEL_56:
  char v25 = -87;
LABEL_58:
  BYTE6(v43) = v24 + v25 + 16 * v23;
  uint64_t v26 = v3[14];
  if ((v3[14] & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v26 + 60) & 0x400) != 0)
  {
    size_t v27 = (char *)&v43 + 7;
    char v28 = v26 - 48;
    int v31 = v3[15];
    uint64_t v30 = v3[15];
    if (v31 < 0) {
      goto LABEL_64;
    }
  }
  else
  {
    size_t v27 = (char *)&v43 + 7;
    char v28 = v26 - 87;
    int v29 = v3[15];
    uint64_t v30 = v3[15];
    if (v29 < 0) {
      goto LABEL_64;
    }
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v30 + 60) & 0x400) != 0)
  {
    char v32 = -48;
    goto LABEL_66;
  }
LABEL_64:
  char v32 = -87;
LABEL_66:
  HIBYTE(v43) = v30 + v32 + 16 * v28;
  uint64_t v33 = (char *)&v43 + 1;
  do
  {
    char v34 = *(v33 - 1);
    *(v33 - 1) = *v27;
    *v27-- = v34;
  }
  while (v33++ < v27);
  *(_OWORD *)std::string __str = 0u;
  long long v45 = 0u;
  __n128 result = (void *)snprintf(__str, 0x20uLL, "%a", v43);
  if (result)
  {
    size_t v36 = (int)result;
    uint64_t v37 = *a2;
    unint64_t v38 = a2[1];
    uint64_t v39 = &v38[v36];
    size_t v40 = (size_t)a2[2];
    if ((unint64_t)&v38[v36] > v40)
    {
      unint64_t v41 = 2 * v40;
      if (v41 <= (unint64_t)(v39 + 992)) {
        size_t v42 = (size_t)(v39 + 992);
      }
      else {
        size_t v42 = v41;
      }
      a2[2] = (char *)v42;
      uint64_t v37 = (char *)realloc(v37, v42);
      *a2 = v37;
      if (!v37) {
        abort();
      }
      unint64_t v38 = a2[1];
    }
    __n128 result = memcpy(&v38[(void)v37], __str, v36);
    a2[1] += v36;
  }
  return result;
}

void *llvm::itanium_demangle::FloatLiteralImpl<long double>::printLeft(void *result, char **a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*((void *)result + 3) < 0x20uLL) {
    return result;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *((void *)result + 2);
  char v5 = (char *)&v21 + 7;
  uint64_t v6 = MEMORY[0x1E4F14390];
  do
  {
    uint64_t v8 = *(unsigned __int8 *)(v4 + v3);
    if ((*(char *)(v4 + v3) & 0x80000000) == 0 && (*(_DWORD *)(v6 + 4 * v8 + 60) & 0x400) != 0)
    {
      char v9 = -48;
      uint64_t v10 = *(unsigned __int8 *)(v4 + v3 + 1);
      if (*(char *)(v4 + v3 + 1) < 0) {
        goto LABEL_3;
      }
    }
    else
    {
      char v9 = -87;
      uint64_t v10 = *(unsigned __int8 *)(v4 + v3 + 1);
      if (*(char *)(v4 + v3 + 1) < 0) {
        goto LABEL_3;
      }
    }
    if ((*(_DWORD *)(v6 + 4 * v10 + 60) & 0x400) == 0)
    {
LABEL_3:
      char v7 = -87;
      goto LABEL_4;
    }
    char v7 = -48;
LABEL_4:
    *++char v5 = v10 + v7 + 16 * (v8 + v9);
    v3 += 2;
  }
  while (v3 != 32);
  if (v5 > (char *)&v22)
  {
    char v11 = (char *)&v22 + 1;
    do
    {
      char v12 = *(v11 - 1);
      *(v11 - 1) = *v5;
      *v5-- = v12;
    }
    while (v11++ < v5);
  }
  *(_OWORD *)std::string __str = 0u;
  memset(v24, 0, sizeof(v24));
  __n128 result = (void *)snprintf(__str, 0x2AuLL, "%LaL", v22);
  if (result)
  {
    size_t v14 = (int)result;
    uint64_t v15 = *a2;
    uint64_t v16 = a2[1];
    char v17 = &v16[v14];
    size_t v18 = (size_t)a2[2];
    if ((unint64_t)&v16[v14] > v18)
    {
      unint64_t v19 = 2 * v18;
      if (v19 <= (unint64_t)(v17 + 992)) {
        size_t v20 = (size_t)(v17 + 992);
      }
      else {
        size_t v20 = v19;
      }
      a2[2] = (char *)v20;
      uint64_t v15 = (char *)realloc(v15, v20);
      *a2 = v15;
      if (!v15) {
        abort();
      }
      uint64_t v16 = a2[1];
    }
    __n128 result = memcpy(&v16[(void)v15], __str, v14);
    a2[1] += v14;
  }
  return result;
}

char *llvm::itanium_demangle::StringLiteral::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  char v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 2) > v6)
  {
    size_t v7 = (size_t)(v5 + 994);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    char v5 = a2[1];
  }
  *(_WORD *)&v5[(void)v4] = 15394;
  a2[1] += 2;
  uint64_t v10 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v10 + 40))(v10, a2);
  }
  __n128 result = *a2;
  char v12 = a2[1];
  unint64_t v13 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 2) > v13)
  {
    size_t v14 = (size_t)(v12 + 994);
    unint64_t v15 = 2 * v13;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    a2[2] = (char *)v16;
    __n128 result = (char *)realloc(result, v16);
    *a2 = result;
    if (result)
    {
      char v12 = a2[1];
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  *(_WORD *)&v12[(void)result] = 8766;
  a2[1] += 2;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseTemplateParamDecl(uint64_t a1, uint64_t a2)
{
  v61[0] = a1;
  v61[1] = (uint64_t)&v62;
  uint64_t v62 = a2;
  int v2 = *(_WORD **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL) {
    return 0;
  }
  switch(*v2)
  {
    case 0x7954:
      *(void *)a1 = v2 + 1;
      char v12 = *(void **)(a1 + 4904);
      uint64_t v13 = v12[1];
      if ((unint64_t)(v13 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        size_t v14 = malloc(0x1000uLL);
        if (!v14) {
          goto LABEL_66;
        }
        uint64_t v13 = 0;
        *size_t v14 = v12;
        v14[1] = 0;
        char v12 = v14;
        *(void *)(a1 + 4904) = v14;
      }
      v12[1] = v13 + 32;
      uint64_t v10 = (char *)v12 + v13;
      uint64_t v3 = v10 + 16;
      v10[24] = 35;
      *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x500;
      char v11 = &unk_1EC9A2FF8;
      goto LABEL_17;
    case 0x6B54:
      *(void *)a1 = v2 + 1;
      if (!v15) {
        return 0;
      }
      size_t v16 = (char *)v15;
      size_t v18 = *(void **)(a1 + 4904);
      uint64_t v19 = v18[1];
      if ((unint64_t)(v19 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        size_t v20 = malloc(0x1000uLL);
        if (!v20) {
          goto LABEL_66;
        }
        uint64_t v19 = 0;
        *size_t v20 = v18;
        v20[1] = 0;
        size_t v18 = v20;
        *(void *)(a1 + 4904) = v20;
      }
      v18[1] = v19 + 32;
      uint64_t v21 = (char *)v18 + v19;
      uint64_t v3 = v21 + 16;
      v21[24] = 36;
      *(_WORD *)(v21 + 25) = *(_WORD *)(v21 + 25) & 0xF000 | 0x500;
      long double v22 = &unk_1EC9A33C0;
LABEL_28:
      *((void *)v21 + 2) = v22;
      *((void *)v21 + 4) = v16;
      *((void *)v21 + 5) = v17;
      return v3;
    case 0x6E54:
      *(void *)a1 = v2 + 1;
      if (!v23) {
        return 0;
      }
      char v17 = (char *)v23;
      uint64_t v24 = *(void **)(a1 + 4904);
      uint64_t v25 = v24[1];
      if ((unint64_t)(v25 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v26 = malloc(0x1000uLL);
        if (!v26) {
          goto LABEL_66;
        }
        uint64_t v25 = 0;
        *uint64_t v26 = v24;
        v26[1] = 0;
        uint64_t v24 = v26;
        *(void *)(a1 + 4904) = v26;
      }
      v24[1] = v25 + 32;
      uint64_t v21 = (char *)v24 + v25;
      uint64_t v3 = v21 + 16;
      v21[24] = 37;
      *(_WORD *)(v21 + 25) = *(_WORD *)(v21 + 25) & 0xF000 | 0x500;
      long double v22 = &unk_1EC9A31B0;
      goto LABEL_28;
  }
  if (*v2 != 29780)
  {
    if (*v2 == 28756)
    {
      *(void *)a1 = v2 + 1;
      if (v5)
      {
        unint64_t v6 = (char *)v5;
        size_t v7 = *(void **)(a1 + 4904);
        uint64_t v8 = v7[1];
        if ((unint64_t)(v8 - 4048) > 0xFFFFFFFFFFFFF00FLL)
        {
LABEL_12:
          v7[1] = v8 + 32;
          uint64_t v10 = (char *)v7 + v8;
          uint64_t v3 = v10 + 16;
          v10[24] = 39;
          *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x500;
          char v11 = &unk_1EC9A2FA0;
LABEL_17:
          *((void *)v10 + 2) = v11;
          *((void *)v10 + 4) = v6;
          return v3;
        }
        size_t v9 = malloc(0x1000uLL);
        if (v9)
        {
          uint64_t v8 = 0;
          *size_t v9 = v7;
          v9[1] = 0;
          size_t v7 = v9;
          *(void *)(a1 + 4904) = v9;
          goto LABEL_12;
        }
LABEL_66:
        std::terminate();
      }
    }
    return 0;
  }
  *(void *)a1 = v2 + 1;
  uint64_t v57 = a1;
  uint64_t v29 = *(void *)(a1 + 16);
  uint64_t v28 = *(void *)(a1 + 24);
  uint64_t v30 = *(char **)(a1 + 672);
  int v31 = *(char **)(a1 + 664);
  uint64_t v32 = v30 - v31;
  uint64_t v58 = (v30 - v31) >> 3;
  v59[0] = v60;
  v59[1] = v60;
  v59[2] = v61;
  memset(v60, 0, sizeof(v60));
  if (v30 == *(char **)(a1 + 680))
  {
    if (v31 == (char *)(a1 + 688))
    {
      char v34 = (char *)malloc(2 * v32);
      if (!v34) {
        goto LABEL_65;
      }
      uint64_t v33 = v34;
      if (v30 != v31) {
        memmove(v34, v31, v30 - v31);
      }
      *(void *)(a1 + 664) = v33;
    }
    else
    {
      uint64_t v33 = (char *)realloc(v31, 2 * v32);
      *(void *)(a1 + 664) = v33;
      if (!v33) {
LABEL_65:
      }
        abort();
    }
    uint64_t v30 = &v33[8 * ((v30 - v31) >> 3)];
    *(void *)(a1 + 680) = &v33[8 * (v32 >> 2)];
  }
  uint64_t v35 = (v28 - v29) >> 3;
  *(void *)(a1 + 672) = v30 + 8;
  *(void *)uint64_t v30 = v59;
  size_t v36 = (char *)(a1 + 40);
  uint64_t v37 = *(unsigned char **)a1;
  unint64_t v38 = *(unsigned char **)(a1 + 8);
  do
  {
    if (v37 != v38 && *v37 == 69)
    {
      uint64_t v48 = 0;
      goto LABEL_59;
    }
    if (!v39) {
      goto LABEL_57;
    }
    uint64_t v40 = v39;
    unint64_t v41 = *(char **)(a1 + 24);
    if (v41 == *(char **)(a1 + 32))
    {
      size_t v42 = *(char **)(a1 + 16);
      int64_t v43 = v41 - v42;
      if (v42 == v36)
      {
        long long v45 = (char *)malloc(2 * (v41 - v42));
        if (!v45) {
          goto LABEL_65;
        }
        size_t v44 = v45;
        if (v41 != v36) {
          memcpy(v45, (const void *)(a1 + 40), v43);
        }
        *(void *)(a1 + 16) = v44;
      }
      else
      {
        size_t v44 = (char *)realloc(v42, 2 * (v41 - v42));
        *(void *)(a1 + 16) = v44;
        if (!v44) {
          goto LABEL_65;
        }
      }
      unint64_t v41 = &v44[8 * (v43 >> 3)];
      *(void *)(a1 + 32) = &v44[8 * (v43 >> 2)];
    }
    *(void *)(a1 + 24) = v41 + 8;
    *(void *)unint64_t v41 = v40;
    uint64_t v37 = *(unsigned char **)a1;
    unint64_t v38 = *(unsigned char **)(a1 + 8);
  }
  while (*(unsigned char **)a1 == v38 || *v37 != 81);
  *(void *)a1 = v37 + 1;
  char v46 = *(unsigned char *)(a1 + 778);
  *(unsigned char *)(a1 + 778) = 1;
  *(unsigned char *)(a1 + 778) = v46;
  if (v47)
  {
    uint64_t v37 = *(unsigned char **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8))
    {
      uint64_t v48 = v47;
      if (*v37 == 69)
      {
LABEL_59:
        *(void *)a1 = v37 + 1;
        uint64_t v51 = v50;
        size_t v52 = *(void **)(a1 + 4904);
        uint64_t v53 = v52[1];
        if ((unint64_t)(v53 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
        {
          int64_t v54 = malloc(0x1000uLL);
          if (!v54) {
            goto LABEL_66;
          }
          uint64_t v53 = 0;
          *int64_t v54 = v52;
          v54[1] = 0;
          size_t v52 = v54;
          *(void *)(a1 + 4904) = v54;
        }
        v52[1] = v53 + 48;
        char v55 = (char *)v52 + v53;
        uint64_t v3 = v55 + 16;
        v55[24] = 38;
        *(_WORD *)(v55 + 25) = *(_WORD *)(v55 + 25) & 0xF000 | 0x500;
        *((void *)v55 + 2) = &unk_1EC9A3260;
        *((void *)v55 + 4) = v56;
        *((void *)v55 + 5) = v49;
        *((void *)v55 + 6) = v51;
        *((void *)v55 + 7) = v48;
        goto LABEL_63;
      }
    }
  }
LABEL_57:
  uint64_t v3 = 0;
LABEL_63:
  *(void *)(v57 + 672) = *(void *)(v57 + 664) + 8 * v58;
  if (v59[0] != v60) {
    free(v59[0]);
  }
  return v3;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ClosureTypeName,llvm::itanium_demangle::NodeArray &,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::NodeArray &,llvm::itanium_demangle::Node *&,std::string_view &>(uint64_t a1, __n128 *a2, uint64_t *a3, long long *a4, uint64_t *a5, long long *a6)
{
  char v11 = *(void **)(a1 + 4904);
  uint64_t v12 = v11[1];
  if ((unint64_t)(v12 - 4000) <= 0xFFFFFFFFFFFFF00FLL)
  {
    size_t v14 = malloc(0x1000uLL);
    if (!v14) {
      std::terminate();
    }
    uint64_t v12 = 0;
    *size_t v14 = v11;
    v14[1] = 0;
    char v11 = v14;
    *(void *)(a1 + 4904) = v14;
  }
  v11[1] = v12 + 80;
  uint64_t v15 = (char *)v11 + v12;
  uint64_t v16 = *a3;
  uint64_t v17 = *a5;
  v15[24] = 52;
  __int16 v18 = *(_WORD *)(v15 + 25) & 0xF000 | 0x540;
  *((void *)v15 + 2) = &unk_1EC9A26B0;
  __n128 result = *a2;
  long long v20 = *a4;
  long long v21 = *a6;
  *(_WORD *)(v15 + 25) = v18;
  *((__n128 *)v15 + 2) = result;
  *((void *)v15 + 6) = v16;
  *(_OWORD *)(v15 + 56) = v20;
  *((void *)v15 + 9) = v17;
  *((_OWORD *)v15 + 5) = v21;
  return result;
}

char *llvm::itanium_demangle::UnnamedTypeName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 8) > v6)
  {
    size_t v7 = (size_t)(v5 + 1000);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_22;
    }
    uint64_t v5 = a2[1];
  }
  *(void *)&v5[(void)v4] = 0x64656D616E6E7527;
  uint64_t v10 = (uint64_t)(a2[1] + 8);
  a2[1] = (char *)v10;
  size_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    uint64_t v12 = *(const void **)(a1 + 16);
    size_t v13 = v10 + v11;
    size_t v14 = (size_t)a2[2];
    uint64_t v15 = *a2;
    if (v10 + v11 > v14)
    {
      if (2 * v14 <= v13 + 992) {
        size_t v16 = v13 + 992;
      }
      else {
        size_t v16 = 2 * v14;
      }
      a2[2] = (char *)v16;
      uint64_t v15 = (char *)realloc(v15, v16);
      *a2 = v15;
      if (!v15) {
        goto LABEL_22;
      }
      uint64_t v10 = (uint64_t)a2[1];
    }
    memcpy(&v15[v10], v12, v11);
    uint64_t v10 = (uint64_t)&a2[1][v11];
    a2[1] = (char *)v10;
  }
  unint64_t v17 = (unint64_t)a2[2];
  __n128 result = *a2;
  if (v10 + 1 > v17)
  {
    size_t v19 = v10 + 993;
    unint64_t v20 = 2 * v17;
    if (v20 <= v19) {
      size_t v21 = v19;
    }
    else {
      size_t v21 = v20;
    }
    a2[2] = (char *)v21;
    __n128 result = (char *)realloc(result, v21);
    *a2 = result;
    if (result)
    {
      uint64_t v10 = (uint64_t)a2[1];
      goto LABEL_21;
    }
LABEL_22:
    abort();
  }
LABEL_21:
  result[v10] = 39;
  ++a2[1];
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseTemplateParamDecl(llvm::itanium_demangle::PODSmallVector<llvm::itanium_demangle::Node *,8ul> *)::{lambda(llvm::itanium_demangle::TemplateParamKind)#1}::operator()(uint64_t *a1, size_t __size)
{
  int v2 = __size;
  uint64_t v4 = *a1;
  uint64_t v5 = *a1 + 4 * (int)__size;
  int v6 = *(_DWORD *)(v5 + 792);
  *(_DWORD *)(v5 + 792) = v6 + 1;
  size_t v7 = *(void **)(v4 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    size_t v9 = malloc(0x1000uLL);
    if (!v9) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *size_t v9 = v7;
    v9[1] = 0;
    size_t v7 = v9;
    *(void *)(v4 + 4904) = v9;
  }
  v7[1] = v8 + 32;
  uint64_t v10 = (char *)v7 + v8;
  size_t v11 = v10 + 16;
  v10[24] = 33;
  *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x540;
  *((void *)v10 + 2) = &unk_1EC9A32B8;
  *((_DWORD *)v10 + 7) = v2;
  *((_DWORD *)v10 + 8) = v6;
  uint64_t v12 = *(void *)a1[1];
  if (v12)
  {
    size_t v13 = *(char **)(v12 + 8);
    if (v13 == *(char **)(v12 + 16))
    {
      size_t v14 = *(char **)v12;
      int64_t v15 = (int64_t)&v13[-*(void *)v12];
      if (*(void *)v12 == v12 + 24)
      {
        unint64_t v17 = (char *)malloc(2 * v15);
        if (!v17) {
          goto LABEL_17;
        }
        size_t v16 = v17;
        if (v13 != v14) {
          memmove(v17, v14, v15);
        }
        *(void *)uint64_t v12 = v16;
      }
      else
      {
        size_t v16 = (char *)realloc(*(void **)v12, 2 * v15);
        *(void *)uint64_t v12 = v16;
        if (!v16) {
LABEL_17:
        }
          abort();
      }
      size_t v13 = &v16[8 * (v15 >> 3)];
      *(void *)(v12 + 16) = &v16[8 * (v15 >> 2)];
    }
    *(void *)(v12 + 8) = v13 + 8;
    *(void *)size_t v13 = v11;
  }
  return v11;
}

_DWORD *llvm::itanium_demangle::SyntheticTemplateParamName::printLeft(_DWORD *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v4 = result[3];
  switch(v4)
  {
    case 2:
      int v6 = (uint64_t *)(a2 + 8);
      uint64_t v12 = *(void *)(a2 + 8);
      unint64_t v13 = *(void *)(a2 + 16);
      __n128 result = *(_DWORD **)a2;
      if (v12 + 3 > v13)
      {
        size_t v14 = v12 + 995;
        unint64_t v15 = 2 * v13;
        if (v15 <= v14) {
          size_t v16 = v14;
        }
        else {
          size_t v16 = v15;
        }
        *(void *)(a2 + 16) = v16;
        __n128 result = realloc(result, v16);
        *(void *)a2 = result;
        if (!result) {
          goto LABEL_39;
        }
        uint64_t v12 = *v6;
      }
      unint64_t v17 = (char *)result + v12;
      v17[2] = 84;
      *(_WORD *)unint64_t v17 = 21540;
      uint64_t v18 = 3;
      goto LABEL_26;
    case 1:
      int v6 = (uint64_t *)(a2 + 8);
      uint64_t v5 = *(void *)(a2 + 8);
      unint64_t v19 = *(void *)(a2 + 16);
      __n128 result = *(_DWORD **)a2;
      if (v5 + 2 > v19)
      {
        size_t v20 = v5 + 994;
        unint64_t v21 = 2 * v19;
        if (v21 <= v20) {
          size_t v22 = v20;
        }
        else {
          size_t v22 = v21;
        }
        *(void *)(a2 + 16) = v22;
        __n128 result = realloc(result, v22);
        *(void *)a2 = result;
        if (!result) {
          goto LABEL_39;
        }
        uint64_t v5 = *v6;
      }
      __int16 v11 = 20004;
      goto LABEL_25;
    case 0:
      int v6 = (uint64_t *)(a2 + 8);
      uint64_t v5 = *(void *)(a2 + 8);
      unint64_t v7 = *(void *)(a2 + 16);
      __n128 result = *(_DWORD **)a2;
      if (v5 + 2 > v7)
      {
        size_t v8 = v5 + 994;
        unint64_t v9 = 2 * v7;
        if (v9 <= v8) {
          size_t v10 = v8;
        }
        else {
          size_t v10 = v9;
        }
        *(void *)(a2 + 16) = v10;
        __n128 result = realloc(result, v10);
        *(void *)a2 = result;
        if (!result) {
          goto LABEL_39;
        }
        uint64_t v5 = *v6;
      }
      __int16 v11 = 21540;
LABEL_25:
      *(_WORD *)((char *)result + v5) = v11;
      uint64_t v18 = 2;
LABEL_26:
      *v6 += v18;
      break;
  }
  int v23 = v3[4];
  if (v23)
  {
    uint64_t v24 = 0;
    unint64_t v25 = (v23 - 1);
    do
    {
      v34[v24-- + 20] = (v25 % 0xA) | 0x30;
      BOOL v26 = v25 >= 9;
      BOOL v27 = v25 == 9;
      v25 /= 0xAuLL;
    }
    while (!v27 && v26);
    if (v24)
    {
      uint64_t v28 = *(_DWORD **)a2;
      uint64_t v29 = *(void *)(a2 + 8);
      uint64_t v30 = v29 - v24;
      unint64_t v31 = *(void *)(a2 + 16);
      if (v29 - v24 <= v31)
      {
LABEL_37:
        __n128 result = memcpy((char *)v28 + v29, &v34[v24 + 21], -v24);
        *(void *)(a2 + 8) -= v24;
        return result;
      }
      unint64_t v32 = 2 * v31;
      if (v32 <= v30 + 992) {
        size_t v33 = v30 + 992;
      }
      else {
        size_t v33 = v32;
      }
      *(void *)(a2 + 16) = v33;
      uint64_t v28 = realloc(v28, v33);
      *(void *)a2 = v28;
      if (v28)
      {
        uint64_t v29 = *(void *)(a2 + 8);
        goto LABEL_37;
      }
LABEL_39:
      abort();
    }
  }
  return result;
}

char *llvm::itanium_demangle::TypeTemplateParamDecl::printLeft(uint64_t a1, char **a2)
{
  __n128 result = *a2;
  int v4 = a2[1];
  unint64_t v5 = (unint64_t)a2[2];
  if ((unint64_t)(v4 + 9) > v5)
  {
    size_t v6 = (size_t)(v4 + 1001);
    unint64_t v7 = 2 * v5;
    if (v7 <= v6) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v7;
    }
    a2[2] = (char *)v8;
    __n128 result = (char *)realloc(result, v8);
    *a2 = result;
    if (!result) {
      abort();
    }
    int v4 = a2[1];
  }
  unint64_t v9 = &v4[(void)result];
  *(void *)unint64_t v9 = *(void *)"typename ";
  v9[8] = 32;
  a2[1] += 9;
  return result;
}

uint64_t llvm::itanium_demangle::TypeTemplateParamDecl::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  if ((*(_WORD *)(v3 + 9) & 0xC0) != 0x40)
  {
    unint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v5(v3, a2);
  }
  return result;
}

void *llvm::itanium_demangle::ConstrainedTypeTemplateParamDecl::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  if ((*(_WORD *)(v3 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 40))(v3, a2);
  }
  uint64_t result = *(void **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 1 > v6)
  {
    size_t v7 = v5 + 993;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t result = realloc(result, v9);
    *(void *)a2 = result;
    if (!result) {
      abort();
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  *((unsigned char *)result + v5) = 32;
  ++*(void *)(a2 + 8);
  return result;
}

uint64_t llvm::itanium_demangle::ConstrainedTypeTemplateParamDecl::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  if ((*(_WORD *)(v3 + 9) & 0xC0) != 0x40)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v5(v3, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::NonTypeTemplateParamDecl::printLeft(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(void))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24));
  uint64_t result = *(void *)(a1 + 24);
  unsigned int v5 = *(unsigned __int8 *)(result + 9);
  if ((v5 & 0xC0) == 0x80)
  {
    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t *))result)(result, a2);
    if (result) {
      return result;
    }
  }
  else if (v5 < 0x40)
  {
    return result;
  }
  uint64_t result = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = a2[2];
  if (v6 + 1 > v7)
  {
    size_t v8 = v6 + 993;
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = v10;
    uint64_t result = (uint64_t)realloc((void *)result, v10);
    *a2 = result;
    if (!result) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  *(unsigned char *)(result + v6) = 32;
  ++a2[1];
  return result;
}

uint64_t llvm::itanium_demangle::NonTypeTemplateParamDecl::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
  }
  unsigned int v5 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 40);

  return v5();
}

char *llvm::itanium_demangle::TemplateTemplateParamDecl::printLeft(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  unsigned int v5 = *(char **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)(a2 + 16);
  if (v6 + 9 > v7)
  {
    size_t v8 = v6 + 1001;
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    *(void *)(a2 + 16) = v10;
    unsigned int v5 = (char *)realloc(v5, v10);
    *(void *)a2 = v5;
    if (!v5) {
      goto LABEL_28;
    }
    uint64_t v6 = *(void *)(a2 + 8);
  }
  __int16 v11 = &v5[v6];
  *(void *)__int16 v11 = *(void *)"template<";
  v11[8] = 60;
  uint64_t v12 = *(void *)(a2 + 8) + 9;
  *(void *)(a2 + 8) = v12;
  if (*(void *)(a1 + 32))
  {
    uint64_t v13 = 0;
    char v14 = 1;
    while (1)
    {
      uint64_t v15 = v12;
      if ((v14 & 1) == 0)
      {
        unint64_t v16 = *(void *)(a2 + 16);
        unint64_t v17 = *(char **)a2;
        if (v12 + 2 <= v16)
        {
          uint64_t v20 = v12;
        }
        else
        {
          unint64_t v18 = 2 * v16;
          if (v18 <= v12 + 994) {
            size_t v19 = v12 + 994;
          }
          else {
            size_t v19 = v18;
          }
          *(void *)(a2 + 16) = v19;
          unint64_t v17 = (char *)realloc(v17, v19);
          *(void *)a2 = v17;
          if (!v17) {
            goto LABEL_28;
          }
          uint64_t v20 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v17[v20] = 8236;
        uint64_t v15 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v15;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 24) + 8 * v13), a2, 18, 0);
      if (v15 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v12;
        if (++v13 == *(void *)(a1 + 32)) {
          break;
        }
      }
      else
      {
        char v14 = 0;
        uint64_t v12 = *(void *)(a2 + 8);
        if (++v13 == *(void *)(a1 + 32)) {
          break;
        }
      }
    }
  }
  unint64_t v21 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v12 + 11 > v21)
  {
    unint64_t v23 = 2 * v21;
    if (v23 <= v12 + 1003) {
      size_t v24 = v12 + 1003;
    }
    else {
      size_t v24 = v23;
    }
    *(void *)(a2 + 16) = v24;
    uint64_t result = (char *)realloc(result, v24);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v12 = *(void *)(a2 + 8);
      goto LABEL_27;
    }
LABEL_28:
    abort();
  }
LABEL_27:
  unint64_t v25 = &result[v12];
  *(void *)unint64_t v25 = *(void *)"> typename ";
  *(_DWORD *)(v25 + 7) = 543518049;
  *(void *)(a2 + 8) += 11;
  *(_DWORD *)(a2 + 32) = v4;
  return result;
}

uint64_t llvm::itanium_demangle::TemplateTemplateParamDecl::printRight(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  if (*(void *)(a1 + 40))
  {
    uint64_t v6 = *a2;
    unint64_t v7 = a2[1];
    unint64_t v8 = (unint64_t)a2[2];
    if ((unint64_t)(v7 + 10) > v8)
    {
      size_t v9 = (size_t)(v7 + 1002);
      unint64_t v10 = 2 * v8;
      if (v10 <= v9) {
        size_t v11 = v9;
      }
      else {
        size_t v11 = v10;
      }
      a2[2] = (char *)v11;
      uint64_t v6 = (char *)realloc(v6, v11);
      *a2 = v6;
      if (!v6) {
        abort();
      }
      unint64_t v7 = a2[1];
    }
    uint64_t v12 = &v7[(void)v6];
    *(void *)uint64_t v12 = *(void *)" requires ";
    *((_WORD *)v12 + 4) = 8307;
    a2[1] += 10;
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v13 + 32))(v13, a2);
    if ((*(_WORD *)(v13 + 9) & 0xC0) != 0x40)
    {
      char v14 = *(uint64_t (**)(uint64_t, char **))(*(void *)v13 + 40);
      return v14(v13, a2);
    }
  }
  return result;
}

char *llvm::itanium_demangle::TemplateParamPackDecl::printLeft(uint64_t a1, char **a2)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  uint64_t result = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = (unint64_t)a2[2];
  if ((unint64_t)(v4 + 3) > v5)
  {
    size_t v6 = (size_t)(v4 + 995);
    unint64_t v7 = 2 * v5;
    if (v7 <= v6) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v7;
    }
    a2[2] = (char *)v8;
    uint64_t result = (char *)realloc(result, v8);
    *a2 = result;
    if (!result) {
      abort();
    }
    uint64_t v4 = a2[1];
  }
  size_t v9 = &v4[(void)result];
  _OWORD v9[2] = 46;
  *(_WORD *)size_t v9 = 11822;
  a2[1] += 3;
  return result;
}

uint64_t llvm::itanium_demangle::TemplateParamPackDecl::printRight(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))();
}

char *llvm::itanium_demangle::ClosureTypeName::printLeft(void *a1, void **a2)
{
  uint64_t v4 = (char *)*a2;
  unint64_t v5 = (char *)a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 7) > v6)
  {
    size_t v7 = (size_t)(v5 + 999);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (void *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_24;
    }
    unint64_t v5 = (char *)a2[1];
  }
  unint64_t v10 = &v5[(void)v4];
  *(_DWORD *)(v10 + 3) = 1633968749;
  *(_DWORD *)unint64_t v10 = 1835101223;
  uint64_t v11 = (uint64_t)a2[1] + 7;
  a2[1] = (void *)v11;
  size_t v12 = a1[9];
  if (v12)
  {
    uint64_t v13 = (const void *)a1[8];
    size_t v14 = v11 + v12;
    size_t v15 = (size_t)a2[2];
    unint64_t v16 = (char *)*a2;
    if (v11 + v12 > v15)
    {
      if (2 * v15 <= v14 + 992) {
        size_t v17 = v14 + 992;
      }
      else {
        size_t v17 = 2 * v15;
      }
      a2[2] = (void *)v17;
      unint64_t v16 = (char *)realloc(v16, v17);
      *a2 = v16;
      if (!v16) {
        goto LABEL_24;
      }
      uint64_t v11 = (uint64_t)a2[1];
    }
    memcpy(&v16[v11], v13, v12);
    uint64_t v11 = (uint64_t)a2[1] + v12;
    a2[1] = (void *)v11;
  }
  unint64_t v18 = (unint64_t)a2[2];
  size_t v19 = *a2;
  if (v11 + 1 <= v18) {
    goto LABEL_21;
  }
  size_t v20 = v11 + 993;
  unint64_t v21 = 2 * v18;
  if (v21 <= v20) {
    size_t v22 = v20;
  }
  else {
    size_t v22 = v21;
  }
  a2[2] = (void *)v22;
  size_t v19 = realloc(v19, v22);
  *a2 = v19;
  if (!v19) {
LABEL_24:
  }
    abort();
  uint64_t v11 = (uint64_t)a2[1];
LABEL_21:
  *((unsigned char *)v19 + v11) = 39;
  a2[1] = (char *)a2[1] + 1;

  return llvm::itanium_demangle::ClosureTypeName::printDeclarator(a1, (uint64_t)a2);
}

char *llvm::itanium_demangle::ClosureTypeName::printDeclarator(void *a1, uint64_t a2)
{
  if (a1[3])
  {
    int v4 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a2 + 32) = 0;
    unint64_t v5 = *(char **)a2;
    uint64_t v6 = *(void *)(a2 + 8);
    unint64_t v7 = *(void *)(a2 + 16);
    if (v6 + 1 > v7)
    {
      size_t v8 = v6 + 993;
      unint64_t v9 = 2 * v7;
      if (v9 <= v8) {
        size_t v10 = v8;
      }
      else {
        size_t v10 = v9;
      }
      *(void *)(a2 + 16) = v10;
      unint64_t v5 = (char *)realloc(v5, v10);
      *(void *)a2 = v5;
      if (!v5) {
        goto LABEL_83;
      }
      uint64_t v6 = *(void *)(a2 + 8);
    }
    v5[v6] = 60;
    uint64_t v11 = *(void *)(a2 + 8) + 1;
    *(void *)(a2 + 8) = v11;
    if (a1[3])
    {
      uint64_t v12 = 0;
      char v13 = 1;
      while (1)
      {
        uint64_t v14 = v11;
        if ((v13 & 1) == 0)
        {
          unint64_t v15 = *(void *)(a2 + 16);
          unint64_t v16 = *(char **)a2;
          if (v11 + 2 <= v15)
          {
            uint64_t v19 = v11;
          }
          else
          {
            unint64_t v17 = 2 * v15;
            if (v17 <= v11 + 994) {
              size_t v18 = v11 + 994;
            }
            else {
              size_t v18 = v17;
            }
            *(void *)(a2 + 16) = v18;
            unint64_t v16 = (char *)realloc(v16, v18);
            *(void *)a2 = v16;
            if (!v16) {
              goto LABEL_83;
            }
            uint64_t v19 = *(void *)(a2 + 8);
          }
          *(_WORD *)&v16[v19] = 8236;
          uint64_t v14 = *(void *)(a2 + 8) + 2;
          *(void *)(a2 + 8) = v14;
        }
        llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[2] + 8 * v12), a2, 18, 0);
        if (v14 == *(void *)(a2 + 8))
        {
          *(void *)(a2 + 8) = v11;
          if (++v12 == a1[3]) {
            break;
          }
        }
        else
        {
          char v13 = 0;
          uint64_t v11 = *(void *)(a2 + 8);
          if (++v12 == a1[3]) {
            break;
          }
        }
      }
    }
    unint64_t v20 = *(void *)(a2 + 16);
    unint64_t v21 = *(char **)a2;
    if (v11 + 1 > v20)
    {
      unint64_t v22 = 2 * v20;
      if (v22 <= v11 + 993) {
        size_t v23 = v11 + 993;
      }
      else {
        size_t v23 = v22;
      }
      *(void *)(a2 + 16) = v23;
      unint64_t v21 = (char *)realloc(v21, v23);
      *(void *)a2 = v21;
      if (!v21) {
        goto LABEL_83;
      }
      uint64_t v11 = *(void *)(a2 + 8);
    }
    v21[v11] = 62;
    ++*(void *)(a2 + 8);
    *(_DWORD *)(a2 + 32) = v4;
  }
  uint64_t v24 = *(void *)(a2 + 8);
  if (a1[4])
  {
    unint64_t v25 = *(void *)(a2 + 16);
    BOOL v26 = *(char **)a2;
    if (v24 + 10 > v25)
    {
      size_t v27 = v24 + 1002;
      unint64_t v28 = 2 * v25;
      if (v28 <= v27) {
        size_t v29 = v27;
      }
      else {
        size_t v29 = v28;
      }
      *(void *)(a2 + 16) = v29;
      BOOL v26 = (char *)realloc(v26, v29);
      *(void *)a2 = v26;
      if (!v26) {
        goto LABEL_83;
      }
      uint64_t v24 = *(void *)(a2 + 8);
    }
    uint64_t v30 = &v26[v24];
    *(void *)uint64_t v30 = *(void *)" requires ";
    *((_WORD *)v30 + 4) = 8307;
    *(void *)(a2 + 8) += 10;
    uint64_t v31 = a1[4];
    (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 32))(v31, a2);
    if ((*(_WORD *)(v31 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 40))(v31, a2);
    }
    unint64_t v32 = *(char **)a2;
    uint64_t v33 = *(void *)(a2 + 8);
    unint64_t v34 = *(void *)(a2 + 16);
    if (v33 + 1 > v34)
    {
      size_t v35 = v33 + 993;
      unint64_t v36 = 2 * v34;
      if (v36 <= v35) {
        size_t v37 = v35;
      }
      else {
        size_t v37 = v36;
      }
      *(void *)(a2 + 16) = v37;
      unint64_t v32 = (char *)realloc(v32, v37);
      *(void *)a2 = v32;
      if (!v32) {
        goto LABEL_83;
      }
      uint64_t v33 = *(void *)(a2 + 8);
    }
    v32[v33] = 32;
    uint64_t v24 = *(void *)(a2 + 8) + 1;
    *(void *)(a2 + 8) = v24;
  }
  ++*(_DWORD *)(a2 + 32);
  uint64_t v38 = v24 + 1;
  unint64_t v39 = *(void *)(a2 + 16);
  uint64_t v40 = *(char **)a2;
  if (v24 + 1 > v39)
  {
    unint64_t v41 = v24 + 993;
    if (2 * v39 <= v41) {
      size_t v42 = v41;
    }
    else {
      size_t v42 = 2 * v39;
    }
    *(void *)(a2 + 16) = v42;
    uint64_t v40 = (char *)realloc(v40, v42);
    *(void *)a2 = v40;
    if (!v40) {
      goto LABEL_83;
    }
    uint64_t v24 = *(void *)(a2 + 8);
    uint64_t v38 = v24 + 1;
  }
  *(void *)(a2 + 8) = v38;
  v40[v24] = 40;
  uint64_t v43 = *(void *)(a2 + 8);
  if (a1[6])
  {
    uint64_t v44 = 0;
    char v45 = 1;
    while (1)
    {
      uint64_t v46 = v43;
      if ((v45 & 1) == 0)
      {
        unint64_t v47 = *(void *)(a2 + 16);
        uint64_t v48 = *(char **)a2;
        if (v43 + 2 <= v47)
        {
          uint64_t v51 = v43;
        }
        else
        {
          unint64_t v49 = 2 * v47;
          if (v49 <= v43 + 994) {
            size_t v50 = v43 + 994;
          }
          else {
            size_t v50 = v49;
          }
          *(void *)(a2 + 16) = v50;
          uint64_t v48 = (char *)realloc(v48, v50);
          *(void *)a2 = v48;
          if (!v48) {
            goto LABEL_83;
          }
          uint64_t v51 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v48[v51] = 8236;
        uint64_t v46 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v46;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[5] + 8 * v44), a2, 18, 0);
      if (v46 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v43;
        if (++v44 == a1[6]) {
          break;
        }
      }
      else
      {
        char v45 = 0;
        uint64_t v43 = *(void *)(a2 + 8);
        if (++v44 == a1[6]) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v52 = v43 + 1;
  unint64_t v53 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v43 + 1 > v53)
  {
    unint64_t v55 = 2 * v53;
    if (v55 <= v43 + 993) {
      size_t v56 = v43 + 993;
    }
    else {
      size_t v56 = v55;
    }
    *(void *)(a2 + 16) = v56;
    uint64_t result = (char *)realloc(result, v56);
    *(void *)a2 = result;
    if (!result) {
      goto LABEL_83;
    }
    uint64_t v43 = *(void *)(a2 + 8);
    uint64_t v52 = v43 + 1;
  }
  *(void *)(a2 + 8) = v52;
  result[v43] = 41;
  if (!a1[7]) {
    return result;
  }
  uint64_t v57 = *(char **)a2;
  uint64_t v58 = *(void *)(a2 + 8);
  unint64_t v59 = *(void *)(a2 + 16);
  if (v58 + 10 > v59)
  {
    size_t v60 = v58 + 1002;
    unint64_t v61 = 2 * v59;
    if (v61 <= v60) {
      size_t v62 = v60;
    }
    else {
      size_t v62 = v61;
    }
    *(void *)(a2 + 16) = v62;
    uint64_t v57 = (char *)realloc(v57, v62);
    *(void *)a2 = v57;
    if (v57)
    {
      uint64_t v58 = *(void *)(a2 + 8);
      goto LABEL_78;
    }
LABEL_83:
    abort();
  }
LABEL_78:
  unint64_t v63 = &v57[v58];
  *(void *)unint64_t v63 = *(void *)" requires ";
  *((_WORD *)v63 + 4) = 8307;
  *(void *)(a2 + 8) += 10;
  uint64_t v64 = a1[7];
  uint64_t result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v64 + 32))(v64, a2);
  if ((*(_WORD *)(v64 + 9) & 0xC0) != 0x40)
  {
    size_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v64 + 40);
    return (char *)v65(v64, a2);
  }
  return result;
}

char *llvm::itanium_demangle::LambdaExpr::printLeft(uint64_t a1, char **a2)
{
  int v4 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 2) > v6)
  {
    size_t v7 = (size_t)(v5 + 994);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    int v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    unint64_t v5 = a2[1];
  }
  *(_WORD *)&v5[(void)v4] = 23899;
  uint64_t v10 = (uint64_t)(a2[1] + 2);
  a2[1] = (char *)v10;
  uint64_t v11 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v11 + 8) == 52)
  {
    llvm::itanium_demangle::ClosureTypeName::printDeclarator((void *)v11, (uint64_t)a2);
    uint64_t v10 = (uint64_t)a2[1];
  }
  unint64_t v12 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v10 + 5 > v12)
  {
    size_t v14 = v10 + 997;
    unint64_t v15 = 2 * v12;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    a2[2] = (char *)v16;
    uint64_t result = (char *)realloc(result, v16);
    *a2 = result;
    if (result)
    {
      uint64_t v10 = (uint64_t)a2[1];
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  unint64_t v17 = &result[v10];
  v17[4] = 125;
  *(_DWORD *)unint64_t v17 = 774778491;
  a2[1] += 5;
  return result;
}

char *llvm::itanium_demangle::EnumLiteral::printLeft(void *a1, char **a2)
{
  ++*((_DWORD *)a2 + 8);
  int v4 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v6 = v5 + 1;
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 1) > v7)
  {
    unint64_t v8 = (unint64_t)(v5 + 993);
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    a2[2] = (char *)v9;
    int v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_40;
    }
    unint64_t v5 = a2[1];
    unint64_t v6 = v5 + 1;
  }
  a2[1] = v6;
  v5[(void)v4] = 40;
  uint64_t v10 = a1[2];
  (*(void (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v10 + 40))(v10, a2);
  }
  --*((_DWORD *)a2 + 8);
  uint64_t result = *a2;
  unint64_t v12 = a2[1];
  char v13 = v12 + 1;
  unint64_t v14 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 1) > v14)
  {
    unint64_t v15 = (unint64_t)(v12 + 993);
    if (2 * v14 <= v15) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = 2 * v14;
    }
    a2[2] = (char *)v16;
    uint64_t result = (char *)realloc(result, v16);
    *a2 = result;
    if (!result) {
      goto LABEL_40;
    }
    unint64_t v12 = a2[1];
    char v13 = v12 + 1;
  }
  a2[1] = v13;
  v12[(void)result] = 41;
  unint64_t v17 = (unsigned char *)a1[3];
  if (*v17 != 110)
  {
    size_t v24 = a1[4];
    if (!v24) {
      return result;
    }
    unint64_t v34 = *a2;
    size_t v35 = a2[1];
    unint64_t v36 = &v35[v24];
    size_t v37 = (size_t)a2[2];
    if ((unint64_t)&v35[v24] > v37)
    {
      unint64_t v38 = 2 * v37;
      if (v38 <= (unint64_t)(v36 + 992)) {
        size_t v39 = (size_t)(v36 + 992);
      }
      else {
        size_t v39 = v38;
      }
      a2[2] = (char *)v39;
      unint64_t v34 = (char *)realloc(v34, v39);
      *a2 = v34;
      if (!v34) {
        goto LABEL_40;
      }
      size_t v35 = a2[1];
    }
    uint64_t v33 = &v35[(void)v34];
    unint64_t v32 = v17;
    goto LABEL_38;
  }
  uint64_t result = *a2;
  size_t v18 = a2[1];
  uint64_t v19 = v18 + 1;
  unint64_t v20 = (unint64_t)a2[2];
  if ((unint64_t)(v18 + 1) > v20)
  {
    unint64_t v21 = (unint64_t)(v18 + 993);
    if (2 * v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = 2 * v20;
    }
    a2[2] = (char *)v22;
    uint64_t result = (char *)realloc(result, v22);
    *a2 = result;
    if (!result) {
      goto LABEL_40;
    }
    size_t v18 = a2[1];
    uint64_t v19 = v18 + 1;
  }
  a2[1] = v19;
  v18[(void)result] = 45;
  uint64_t v23 = a1[4];
  size_t v24 = v23 - 1;
  if (v23 == 1) {
    return result;
  }
  uint64_t v25 = a1[3];
  BOOL v26 = *a2;
  size_t v27 = a2[1];
  unint64_t v28 = &v27[v24];
  size_t v29 = (size_t)a2[2];
  if ((unint64_t)&v27[v24] <= v29) {
    goto LABEL_29;
  }
  unint64_t v30 = 2 * v29;
  if (v30 <= (unint64_t)(v28 + 992)) {
    size_t v31 = (size_t)(v28 + 992);
  }
  else {
    size_t v31 = v30;
  }
  a2[2] = (char *)v31;
  BOOL v26 = (char *)realloc(v26, v31);
  *a2 = v26;
  if (!v26) {
LABEL_40:
  }
    abort();
  size_t v27 = a2[1];
LABEL_29:
  unint64_t v32 = (const void *)(v25 + 1);
  uint64_t v33 = &v27[(void)v26];
LABEL_38:
  uint64_t result = (char *)memcpy(v33, v32, v24);
  a2[1] += v24;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::FunctionParam,std::string_view &>(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  unint64_t v7 = (char *)v3 + v4;
  v7[24] = 67;
  __int16 v8 = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A22E8;
  __n128 result = *a2;
  *(_WORD *)(v7 + 25) = v8;
  *((__n128 *)v7 + 2) = result;
  return result;
}

char *llvm::itanium_demangle::FunctionParam::printLeft(uint64_t a1, char **a2)
{
  __n128 result = *a2;
  unint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 2) > v6)
  {
    size_t v7 = (size_t)(v5 + 994);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    __n128 result = (char *)realloc(result, v9);
    *a2 = result;
    if (!result) {
      goto LABEL_16;
    }
    unint64_t v5 = a2[1];
  }
  *(_WORD *)&v5[(void)result] = 28774;
  uint64_t v10 = (uint64_t)(a2[1] + 2);
  a2[1] = (char *)v10;
  size_t v11 = *(void *)(a1 + 24);
  if (!v11) {
    return result;
  }
  unint64_t v12 = *(const void **)(a1 + 16);
  size_t v13 = v10 + v11;
  size_t v14 = (size_t)a2[2];
  unint64_t v15 = *a2;
  if (v10 + v11 > v14)
  {
    if (2 * v14 <= v13 + 992) {
      size_t v16 = v13 + 992;
    }
    else {
      size_t v16 = 2 * v14;
    }
    a2[2] = (char *)v16;
    unint64_t v15 = (char *)realloc(v15, v16);
    *a2 = v15;
    if (v15)
    {
      uint64_t v10 = (uint64_t)a2[1];
      goto LABEL_14;
    }
LABEL_16:
    abort();
  }
LABEL_14:
  __n128 result = (char *)memcpy(&v15[v10], v12, v11);
  a2[1] += v11;
  return result;
}

char *llvm::itanium_demangle::FoldExpr::printLeft(uint64_t a1, uint64_t a2)
{
  v59[0] = (char **)a2;
  v59[1] = (char **)a1;
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_71;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  v4[v5] = 40;
  if (!*(unsigned char *)(a1 + 48))
  {
    llvm::itanium_demangle::FoldExpr::printLeft(llvm::itanium_demangle::OutputBuffer &)const::{lambda(void)#1}::operator()(v59);
    size_t v11 = *(char **)a2;
    uint64_t v12 = *(void *)(a2 + 8);
    unint64_t v13 = *(void *)(a2 + 16);
    if (v12 + 1 <= v13) {
      goto LABEL_17;
    }
    goto LABEL_12;
  }
  uint64_t v10 = *(void *)(a1 + 24);
  if (!v10)
  {
    uint64_t v30 = *(void *)(a2 + 8);
    unint64_t v29 = *(void *)(a2 + 16);
    size_t v31 = *(char **)a2;
    if (v30 + 3 <= v29) {
      goto LABEL_39;
    }
    goto LABEL_34;
  }
  llvm::itanium_demangle::Node::printAsOperand(v10, a2, 3, 1);
  size_t v11 = *(char **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  unint64_t v13 = *(void *)(a2 + 16);
  if (v12 + 1 > v13)
  {
LABEL_12:
    size_t v14 = v12 + 993;
    unint64_t v15 = 2 * v13;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    *(void *)(a2 + 16) = v16;
    size_t v11 = (char *)realloc(v11, v16);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_71;
    }
    uint64_t v12 = *(void *)(a2 + 8);
  }
LABEL_17:
  v11[v12] = 32;
  uint64_t v17 = *(void *)(a2 + 8) + 1;
  *(void *)(a2 + 8) = v17;
  size_t v18 = *(void *)(a1 + 40);
  if (v18)
  {
    uint64_t v19 = *(const void **)(a1 + 32);
    size_t v20 = v17 + v18;
    size_t v21 = *(void *)(a2 + 16);
    size_t v22 = *(char **)a2;
    if (v17 + v18 > v21)
    {
      if (2 * v21 <= v20 + 992) {
        size_t v23 = v20 + 992;
      }
      else {
        size_t v23 = 2 * v21;
      }
      *(void *)(a2 + 16) = v23;
      size_t v22 = (char *)realloc(v22, v23);
      *(void *)a2 = v22;
      if (!v22) {
        goto LABEL_71;
      }
      uint64_t v17 = *(void *)(a2 + 8);
    }
    memcpy(&v22[v17], v19, v18);
    uint64_t v17 = *(void *)(a2 + 8) + v18;
    *(void *)(a2 + 8) = v17;
  }
  unint64_t v24 = *(void *)(a2 + 16);
  uint64_t v25 = *(char **)a2;
  if (v17 + 1 > v24)
  {
    size_t v26 = v17 + 993;
    unint64_t v27 = 2 * v24;
    if (v27 <= v26) {
      size_t v28 = v26;
    }
    else {
      size_t v28 = v27;
    }
    *(void *)(a2 + 16) = v28;
    uint64_t v25 = (char *)realloc(v25, v28);
    *(void *)a2 = v25;
    if (!v25) {
      goto LABEL_71;
    }
    uint64_t v17 = *(void *)(a2 + 8);
  }
  v25[v17] = 32;
  unint64_t v29 = *(void *)(a2 + 16);
  uint64_t v30 = *(void *)(a2 + 8) + 1;
  *(void *)(a2 + 8) = v30;
  size_t v31 = *(char **)a2;
  if (v30 + 3 > v29)
  {
LABEL_34:
    size_t v32 = v30 + 995;
    unint64_t v33 = 2 * v29;
    if (v33 <= v32) {
      size_t v34 = v32;
    }
    else {
      size_t v34 = v33;
    }
    *(void *)(a2 + 16) = v34;
    size_t v31 = (char *)realloc(v31, v34);
    *(void *)a2 = v31;
    if (!v31) {
      goto LABEL_71;
    }
    uint64_t v30 = *(void *)(a2 + 8);
  }
LABEL_39:
  size_t v35 = &v31[v30];
  v35[2] = 46;
  *(_WORD *)size_t v35 = 11822;
  uint64_t v36 = *(void *)(a2 + 8);
  uint64_t v37 = v36 + 3;
  *(void *)(a2 + 8) = v36 + 3;
  if (*(unsigned char *)(a1 + 48) || *(void *)(a1 + 24))
  {
    unint64_t v38 = *(void *)(a2 + 16);
    size_t v39 = *(char **)a2;
    if (v36 + 4 > v38)
    {
      if (2 * v38 <= v36 + 996) {
        size_t v40 = v36 + 996;
      }
      else {
        size_t v40 = 2 * v38;
      }
      *(void *)(a2 + 16) = v40;
      size_t v39 = (char *)realloc(v39, v40);
      *(void *)a2 = v39;
      if (!v39) {
        goto LABEL_71;
      }
      uint64_t v37 = *(void *)(a2 + 8);
    }
    v39[v37] = 32;
    uint64_t v41 = *(void *)(a2 + 8) + 1;
    *(void *)(a2 + 8) = v41;
    size_t v42 = *(void *)(a1 + 40);
    if (v42)
    {
      uint64_t v43 = *(const void **)(a1 + 32);
      size_t v44 = v41 + v42;
      size_t v45 = *(void *)(a2 + 16);
      uint64_t v46 = *(char **)a2;
      if (v41 + v42 > v45)
      {
        if (2 * v45 <= v44 + 992) {
          size_t v47 = v44 + 992;
        }
        else {
          size_t v47 = 2 * v45;
        }
        *(void *)(a2 + 16) = v47;
        uint64_t v46 = (char *)realloc(v46, v47);
        *(void *)a2 = v46;
        if (!v46) {
          goto LABEL_71;
        }
        uint64_t v41 = *(void *)(a2 + 8);
      }
      memcpy(&v46[v41], v43, v42);
      uint64_t v41 = *(void *)(a2 + 8) + v42;
      *(void *)(a2 + 8) = v41;
    }
    unint64_t v48 = *(void *)(a2 + 16);
    unint64_t v49 = *(char **)a2;
    if (v41 + 1 > v48)
    {
      size_t v50 = v41 + 993;
      unint64_t v51 = 2 * v48;
      if (v51 <= v50) {
        size_t v52 = v50;
      }
      else {
        size_t v52 = v51;
      }
      *(void *)(a2 + 16) = v52;
      unint64_t v49 = (char *)realloc(v49, v52);
      *(void *)a2 = v49;
      if (!v49) {
        goto LABEL_71;
      }
      uint64_t v41 = *(void *)(a2 + 8);
    }
    v49[v41] = 32;
    ++*(void *)(a2 + 8);
    if (*(unsigned char *)(a1 + 48)) {
      llvm::itanium_demangle::FoldExpr::printLeft(llvm::itanium_demangle::OutputBuffer &)const::{lambda(void)#1}::operator()(v59);
    }
    else {
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 24), a2, 3, 1);
    }
  }
  --*(_DWORD *)(a2 + 32);
  __n128 result = *(char **)a2;
  uint64_t v54 = *(void *)(a2 + 8);
  uint64_t v55 = v54 + 1;
  unint64_t v56 = *(void *)(a2 + 16);
  if (v54 + 1 > v56)
  {
    unint64_t v57 = v54 + 993;
    if (2 * v56 <= v57) {
      size_t v58 = v57;
    }
    else {
      size_t v58 = 2 * v56;
    }
    *(void *)(a2 + 16) = v58;
    __n128 result = (char *)realloc(result, v58);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v54 = *(void *)(a2 + 8);
      uint64_t v55 = v54 + 1;
      goto LABEL_70;
    }
LABEL_71:
    abort();
  }
LABEL_70:
  *(void *)(a2 + 8) = v55;
  result[v54] = 41;
  return result;
}

void *llvm::itanium_demangle::FoldExpr::printLeft(llvm::itanium_demangle::OutputBuffer &)const::{lambda(void)#1}::operator()(char ***a1)
{
  uint64_t v3 = *a1;
  int v2 = a1[1];
  *((_DWORD *)v3 + 8) = *((_DWORD *)*a1 + 8) + 1;
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v6 = v5 + 1;
  unint64_t v7 = (unint64_t)v3[2];
  if ((unint64_t)(v5 + 1) > v7)
  {
    unint64_t v8 = (unint64_t)(v5 + 993);
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    void v3[2] = (char *)v9;
    uint64_t v4 = realloc(v4, v9);
    void *v3 = (char *)v4;
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = v3[1];
    uint64_t v6 = v5 + 1;
  }
  v3[1] = v6;
  v5[(void)v4] = 40;
  uint64_t v10 = v2[2];
  char v20 = 42;
  __int16 v21 = 1344;
  uint64_t v19 = (void (**)(void **, void))&unk_1EC9A3100;
  size_t v22 = v10;
  size_t v11 = *a1;
  llvm::itanium_demangle::ParameterPackExpansion::printLeft((uint64_t)&v19, *a1);
  if ((v21 & 0xC0) != 0x40) {
    ((void (**)(void **, char **))v19)[5]((void **)&v19, v11);
  }
  uint64_t v12 = *a1;
  --*((_DWORD *)v12 + 8);
  __n128 result = *v12;
  size_t v14 = v12[1];
  unint64_t v15 = v14 + 1;
  unint64_t v16 = (unint64_t)v12[2];
  if ((unint64_t)(v14 + 1) > v16)
  {
    unint64_t v17 = (unint64_t)(v14 + 993);
    if (2 * v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = 2 * v16;
    }
    void v12[2] = (char *)v18;
    __n128 result = realloc(result, v18);
    *uint64_t v12 = (char *)result;
    if (result)
    {
      size_t v14 = v12[1];
      unint64_t v15 = v14 + 1;
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  v12[1] = v15;
  v14[(void)result] = 41;
  return result;
}

uint64_t llvm::itanium_demangle::ParameterPackExpansion::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = a2[3];
  a2[3] = (char *)-1;
  uint64_t v5 = (uint64_t)a2[1];
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32))(v6);
  if ((*(_WORD *)(v6 + 9) & 0xC0) != 0x40) {
    uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v6 + 40))(v6, a2);
  }
  unsigned int v8 = *((_DWORD *)a2 + 7);
  if (v8 == -1)
  {
    uint64_t result = (uint64_t)*a2;
    unint64_t v17 = a2[1];
    unint64_t v18 = (unint64_t)a2[2];
    if ((unint64_t)(v17 + 3) > v18)
    {
      size_t v19 = (size_t)(v17 + 995);
      unint64_t v20 = 2 * v18;
      if (v20 <= v19) {
        size_t v21 = v19;
      }
      else {
        size_t v21 = v20;
      }
      a2[2] = (char *)v21;
      uint64_t result = (uint64_t)realloc((void *)result, v21);
      *a2 = (char *)result;
      if (!result) {
LABEL_25:
      }
        abort();
      unint64_t v17 = a2[1];
    }
    size_t v22 = &v17[result];
    stat v22[2] = 46;
    *(_WORD *)size_t v22 = 11822;
    uint64_t v5 = (uint64_t)(a2[1] + 3);
    goto LABEL_23;
  }
  if (!v8)
  {
LABEL_23:
    a2[1] = (char *)v5;
    goto LABEL_24;
  }
  if (v8 >= 2)
  {
    for (int i = 1; i != v8; ++i)
    {
      uint64_t v10 = *a2;
      size_t v11 = a2[1];
      unint64_t v12 = (unint64_t)a2[2];
      if ((unint64_t)(v11 + 2) > v12)
      {
        size_t v13 = (size_t)(v11 + 994);
        unint64_t v14 = 2 * v12;
        if (v14 <= v13) {
          size_t v15 = v13;
        }
        else {
          size_t v15 = v14;
        }
        a2[2] = (char *)v15;
        uint64_t v10 = (char *)realloc(v10, v15);
        *a2 = v10;
        if (!v10) {
          goto LABEL_25;
        }
        size_t v11 = a2[1];
      }
      *(_WORD *)&v11[(void)v10] = 8236;
      a2[1] += 2;
      *((_DWORD *)a2 + 6) = i;
      uint64_t v16 = *(void *)(a1 + 16);
      uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v16 + 32))(v16, a2);
      if ((*(_WORD *)(v16 + 9) & 0xC0) != 0x40) {
        uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v16 + 40))(v16, a2);
      }
    }
  }
LABEL_24:
  a2[3] = v4;
  return result;
}

uint64_t llvm::itanium_demangle::BracedExpr::printLeft(uint64_t a1, char **a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 32);
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = v6 + 1;
  unint64_t v8 = (unint64_t)a2[2];
  if (v4)
  {
    if ((unint64_t)(v6 + 1) > v8)
    {
      unint64_t v9 = (unint64_t)(v6 + 993);
      if (2 * v8 <= v9) {
        size_t v10 = v9;
      }
      else {
        size_t v10 = 2 * v8;
      }
      a2[2] = (char *)v10;
      uint64_t v5 = (char *)realloc(v5, v10);
      *a2 = v5;
      if (!v5) {
        goto LABEL_37;
      }
      uint64_t v6 = a2[1];
      unint64_t v7 = v6 + 1;
    }
    a2[1] = v7;
    v6[(void)v5] = 91;
    uint64_t v11 = *(void *)(a1 + 16);
    (*(void (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
    if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, char **))(*(void *)v11 + 40))(v11, a2);
    }
    unint64_t v12 = *a2;
    size_t v13 = a2[1];
    unint64_t v14 = v13 + 1;
    unint64_t v15 = (unint64_t)a2[2];
    if ((unint64_t)(v13 + 1) > v15)
    {
      unint64_t v16 = (unint64_t)(v13 + 993);
      if (2 * v15 <= v16) {
        size_t v17 = v16;
      }
      else {
        size_t v17 = 2 * v15;
      }
      a2[2] = (char *)v17;
      unint64_t v12 = (char *)realloc(v12, v17);
      *a2 = v12;
      if (!v12) {
        goto LABEL_37;
      }
      size_t v13 = a2[1];
      unint64_t v14 = v13 + 1;
    }
    a2[1] = v14;
    v13[(void)v12] = 93;
  }
  else
  {
    if ((unint64_t)(v6 + 1) > v8)
    {
      unint64_t v18 = (unint64_t)(v6 + 993);
      if (2 * v8 <= v18) {
        size_t v19 = v18;
      }
      else {
        size_t v19 = 2 * v8;
      }
      a2[2] = (char *)v19;
      uint64_t v5 = (char *)realloc(v5, v19);
      *a2 = v5;
      if (!v5) {
        goto LABEL_37;
      }
      uint64_t v6 = a2[1];
      unint64_t v7 = v6 + 1;
    }
    a2[1] = v7;
    v6[(void)v5] = 46;
    uint64_t v20 = *(void *)(a1 + 16);
    (*(void (**)(uint64_t, char **))(*(void *)v20 + 32))(v20, a2);
    if ((*(_WORD *)(v20 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, char **))(*(void *)v20 + 40))(v20, a2);
    }
  }
  uint64_t v21 = *(void *)(a1 + 24);
  if (*(unsigned __int8 *)(v21 + 8) - 81 < 2) {
    goto LABEL_33;
  }
  size_t v22 = *a2;
  size_t v23 = a2[1];
  unint64_t v24 = (unint64_t)a2[2];
  if ((unint64_t)(v23 + 3) > v24)
  {
    size_t v25 = (size_t)(v23 + 995);
    unint64_t v26 = 2 * v24;
    if (v26 <= v25) {
      size_t v27 = v25;
    }
    else {
      size_t v27 = v26;
    }
    a2[2] = (char *)v27;
    size_t v22 = (char *)realloc(v22, v27);
    *a2 = v22;
    if (v22)
    {
      size_t v23 = a2[1];
      goto LABEL_32;
    }
LABEL_37:
    abort();
  }
LABEL_32:
  size_t v28 = &v23[(void)v22];
  v28[2] = 32;
  *(_WORD *)size_t v28 = 15648;
  a2[1] += 3;
  uint64_t v21 = *(void *)(a1 + 24);
LABEL_33:
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v21 + 32))(v21, a2);
  if ((*(_WORD *)(v21 + 9) & 0xC0) != 0x40)
  {
    uint64_t v30 = *(uint64_t (**)(uint64_t, char **))(*(void *)v21 + 40);
    return v30(v21, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::BracedRangeExpr::printLeft(void *a1, char **a2)
{
  int v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = v5 + 1;
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 1) > v7)
  {
    unint64_t v8 = (unint64_t)(v5 + 993);
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    a2[2] = (char *)v9;
    int v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_35;
    }
    uint64_t v5 = a2[1];
    uint64_t v6 = v5 + 1;
  }
  a2[1] = v6;
  v5[(void)v4] = 91;
  uint64_t v10 = a1[2];
  (*(void (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v10 + 40))(v10, a2);
  }
  uint64_t v11 = *a2;
  unint64_t v12 = a2[1];
  unint64_t v13 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 5) > v13)
  {
    size_t v14 = (size_t)(v12 + 997);
    unint64_t v15 = 2 * v13;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    a2[2] = (char *)v16;
    uint64_t v11 = (char *)realloc(v11, v16);
    *a2 = v11;
    if (!v11) {
      goto LABEL_35;
    }
    unint64_t v12 = a2[1];
  }
  size_t v17 = &v12[(void)v11];
  v17[4] = 32;
  *(_DWORD *)size_t v17 = 774778400;
  a2[1] += 5;
  uint64_t v18 = a1[3];
  (*(void (**)(uint64_t, char **))(*(void *)v18 + 32))(v18, a2);
  if ((*(_WORD *)(v18 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v18 + 40))(v18, a2);
  }
  size_t v19 = *a2;
  uint64_t v20 = a2[1];
  uint64_t v21 = v20 + 1;
  unint64_t v22 = (unint64_t)a2[2];
  if ((unint64_t)(v20 + 1) > v22)
  {
    unint64_t v23 = (unint64_t)(v20 + 993);
    if (2 * v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = 2 * v22;
    }
    a2[2] = (char *)v24;
    size_t v19 = (char *)realloc(v19, v24);
    *a2 = v19;
    if (!v19) {
      goto LABEL_35;
    }
    uint64_t v20 = a2[1];
    uint64_t v21 = v20 + 1;
  }
  a2[1] = v21;
  v20[(void)v19] = 93;
  uint64_t v25 = a1[4];
  if (*(unsigned __int8 *)(v25 + 8) - 81 < 2) {
    goto LABEL_31;
  }
  unint64_t v26 = *a2;
  size_t v27 = a2[1];
  unint64_t v28 = (unint64_t)a2[2];
  if ((unint64_t)(v27 + 3) > v28)
  {
    size_t v29 = (size_t)(v27 + 995);
    unint64_t v30 = 2 * v28;
    if (v30 <= v29) {
      size_t v31 = v29;
    }
    else {
      size_t v31 = v30;
    }
    a2[2] = (char *)v31;
    unint64_t v26 = (char *)realloc(v26, v31);
    *a2 = v26;
    if (v26)
    {
      size_t v27 = a2[1];
      goto LABEL_30;
    }
LABEL_35:
    abort();
  }
LABEL_30:
  size_t v32 = &v27[(void)v26];
  v32[2] = 32;
  *(_WORD *)size_t v32 = 15648;
  a2[1] += 3;
  uint64_t v25 = a1[4];
LABEL_31:
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v25 + 32))(v25, a2);
  if ((*(_WORD *)(v25 + 9) & 0xC0) != 0x40)
  {
    size_t v34 = *(uint64_t (**)(uint64_t, char **))(*(void *)v25 + 40);
    return v34(v25, a2);
  }
  return result;
}

void *llvm::itanium_demangle::InitListExpr::printLeft(void *a1, void **a2)
{
  uint64_t v4 = a1[2];
  if (v4)
  {
    (*(void (**)(void, void **))(*(void *)v4 + 32))(a1[2], a2);
    if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, void **))(*(void *)v4 + 40))(v4, a2);
    }
  }
  uint64_t v5 = (char *)*a2;
  uint64_t v6 = (char *)a2[1];
  unint64_t v7 = v6 + 1;
  unint64_t v8 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 1) > v8)
  {
    unint64_t v9 = (unint64_t)(v6 + 993);
    if (2 * v8 <= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = 2 * v8;
    }
    a2[2] = (void *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      goto LABEL_31;
    }
    uint64_t v6 = (char *)a2[1];
    unint64_t v7 = v6 + 1;
  }
  a2[1] = v7;
  v6[(void)v5] = 123;
  uint64_t v11 = (uint64_t)a2[1];
  if (a1[4])
  {
    uint64_t v12 = 0;
    char v13 = 1;
    while (1)
    {
      uint64_t v14 = v11;
      if ((v13 & 1) == 0)
      {
        unint64_t v15 = (unint64_t)a2[2];
        size_t v16 = (char *)*a2;
        if (v11 + 2 <= v15)
        {
          uint64_t v19 = v11;
        }
        else
        {
          unint64_t v17 = 2 * v15;
          if (v17 <= v11 + 994) {
            size_t v18 = v11 + 994;
          }
          else {
            size_t v18 = v17;
          }
          a2[2] = (void *)v18;
          size_t v16 = (char *)realloc(v16, v18);
          *a2 = v16;
          if (!v16) {
            goto LABEL_31;
          }
          uint64_t v19 = (uint64_t)a2[1];
        }
        *(_WORD *)&v16[v19] = 8236;
        uint64_t v14 = (uint64_t)a2[1] + 2;
        a2[1] = (void *)v14;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[3] + 8 * v12), (uint64_t)a2, 18, 0);
      if ((void *)v14 == a2[1])
      {
        a2[1] = (void *)v11;
        if (++v12 == a1[4]) {
          break;
        }
      }
      else
      {
        char v13 = 0;
        uint64_t v11 = (uint64_t)a2[1];
        if (++v12 == a1[4]) {
          break;
        }
      }
    }
  }
  uint64_t v20 = v11 + 1;
  unint64_t v21 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v11 + 1 > v21)
  {
    unint64_t v23 = 2 * v21;
    if (v23 <= v11 + 993) {
      size_t v24 = v11 + 993;
    }
    else {
      size_t v24 = v23;
    }
    a2[2] = (void *)v24;
    uint64_t result = realloc(result, v24);
    *a2 = result;
    if (result)
    {
      uint64_t v11 = (uint64_t)a2[1];
      uint64_t v20 = v11 + 1;
      goto LABEL_30;
    }
LABEL_31:
    abort();
  }
LABEL_30:
  a2[1] = (void *)v20;
  *((unsigned char *)result + v11) = 125;
  return result;
}

void *llvm::itanium_demangle::PointerToMemberConversionExpr::printLeft(uint64_t a1, uint64_t a2)
{
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_30;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  *((unsigned char *)v4 + v5) = 40;
  uint64_t v10 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a2);
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v11 = *(void **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  uint64_t v13 = v12 + 1;
  unint64_t v14 = *(void *)(a2 + 16);
  if (v12 + 1 > v14)
  {
    unint64_t v15 = v12 + 993;
    if (2 * v14 <= v15) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = 2 * v14;
    }
    *(void *)(a2 + 16) = v16;
    uint64_t v11 = realloc(v11, v16);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_30;
    }
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v13 = v12 + 1;
  }
  *(void *)(a2 + 8) = v13;
  *((unsigned char *)v11 + v12) = 41;
  ++*(_DWORD *)(a2 + 32);
  unint64_t v17 = *(void **)a2;
  uint64_t v18 = *(void *)(a2 + 8);
  uint64_t v19 = v18 + 1;
  unint64_t v20 = *(void *)(a2 + 16);
  if (v18 + 1 > v20)
  {
    unint64_t v21 = v18 + 993;
    if (2 * v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = 2 * v20;
    }
    *(void *)(a2 + 16) = v22;
    unint64_t v17 = realloc(v17, v22);
    *(void *)a2 = v17;
    if (!v17) {
      goto LABEL_30;
    }
    uint64_t v18 = *(void *)(a2 + 8);
    uint64_t v19 = v18 + 1;
  }
  *(void *)(a2 + 8) = v19;
  *((unsigned char *)v17 + v18) = 40;
  uint64_t v23 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 32))(v23, a2);
  if ((*(_WORD *)(v23 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 40))(v23, a2);
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t result = *(void **)a2;
  uint64_t v25 = *(void *)(a2 + 8);
  uint64_t v26 = v25 + 1;
  unint64_t v27 = *(void *)(a2 + 16);
  if (v25 + 1 > v27)
  {
    unint64_t v28 = v25 + 993;
    if (2 * v27 <= v28) {
      size_t v29 = v28;
    }
    else {
      size_t v29 = 2 * v27;
    }
    *(void *)(a2 + 16) = v29;
    uint64_t result = realloc(result, v29);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v25 = *(void *)(a2 + 8);
      uint64_t v26 = v25 + 1;
      goto LABEL_29;
    }
LABEL_30:
    abort();
  }
LABEL_29:
  *(void *)(a2 + 8) = v26;
  *((unsigned char *)result + v25) = 41;
  return result;
}

char *llvm::itanium_demangle::ExprRequirement::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 1) > v6)
  {
    size_t v7 = (size_t)(v5 + 993);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_50;
    }
    uint64_t v5 = a2[1];
  }
  v5[(void)v4] = 32;
  uint64_t v10 = a2[1];
  uint64_t v11 = v10 + 1;
  a2[1] = v10 + 1;
  if (*(unsigned char *)(a1 + 24) || *(void *)(a1 + 32))
  {
    ++*((_DWORD *)a2 + 8);
    uint64_t v12 = v10 + 2;
    unint64_t v13 = (unint64_t)a2[2];
    unint64_t v14 = *a2;
    if ((unint64_t)(v10 + 2) > v13)
    {
      if (2 * v13 <= (unint64_t)(v10 + 994)) {
        size_t v15 = (size_t)(v10 + 994);
      }
      else {
        size_t v15 = 2 * v13;
      }
      a2[2] = (char *)v15;
      unint64_t v14 = realloc(v14, v15);
      *a2 = (char *)v14;
      if (!v14) {
        goto LABEL_50;
      }
      uint64_t v11 = a2[1];
      uint64_t v12 = v11 + 1;
    }
    a2[1] = v12;
    v11[(void)v14] = 123;
  }
  uint64_t v16 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v16 + 32))(v16, a2);
  if ((*(_WORD *)(v16 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v16 + 40))(v16, a2);
  }
  if (*(unsigned char *)(a1 + 24) || *(void *)(a1 + 32))
  {
    --*((_DWORD *)a2 + 8);
    unint64_t v17 = *a2;
    uint64_t v18 = a2[1];
    uint64_t v19 = v18 + 1;
    unint64_t v20 = (unint64_t)a2[2];
    if ((unint64_t)(v18 + 1) > v20)
    {
      unint64_t v21 = (unint64_t)(v18 + 993);
      if (2 * v20 <= v21) {
        size_t v22 = v21;
      }
      else {
        size_t v22 = 2 * v20;
      }
      a2[2] = (char *)v22;
      unint64_t v17 = realloc(v17, v22);
      *a2 = (char *)v17;
      if (!v17) {
        goto LABEL_50;
      }
      uint64_t v18 = a2[1];
      uint64_t v19 = v18 + 1;
    }
    a2[1] = v19;
    v18[(void)v17] = 125;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v23 = *a2;
      size_t v24 = a2[1];
      unint64_t v25 = (unint64_t)a2[2];
      if ((unint64_t)(v24 + 9) > v25)
      {
        size_t v26 = (size_t)(v24 + 1001);
        unint64_t v27 = 2 * v25;
        if (v27 <= v26) {
          size_t v28 = v26;
        }
        else {
          size_t v28 = v27;
        }
        a2[2] = (char *)v28;
        uint64_t v23 = (char *)realloc(v23, v28);
        *a2 = v23;
        if (!v23) {
          goto LABEL_50;
        }
        size_t v24 = a2[1];
      }
      size_t v29 = &v24[(void)v23];
      *(void *)size_t v29 = *(void *)" noexcept";
      v29[8] = 116;
      a2[1] += 9;
    }
  }
  if (*(void *)(a1 + 32))
  {
    unint64_t v30 = *a2;
    size_t v31 = a2[1];
    unint64_t v32 = (unint64_t)a2[2];
    if ((unint64_t)(v31 + 4) > v32)
    {
      size_t v33 = (size_t)(v31 + 996);
      unint64_t v34 = 2 * v32;
      if (v34 <= v33) {
        size_t v35 = v33;
      }
      else {
        size_t v35 = v34;
      }
      a2[2] = (char *)v35;
      unint64_t v30 = (char *)realloc(v30, v35);
      *a2 = v30;
      if (!v30) {
        goto LABEL_50;
      }
      size_t v31 = a2[1];
    }
    *(_DWORD *)&v31[(void)v30] = 540945696;
    a2[1] += 4;
    uint64_t v36 = *(void *)(a1 + 32);
    (*(void (**)(uint64_t, char **))(*(void *)v36 + 32))(v36, a2);
    if ((*(_WORD *)(v36 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, char **))(*(void *)v36 + 40))(v36, a2);
    }
  }
  uint64_t result = *a2;
  unint64_t v38 = a2[1];
  size_t v39 = v38 + 1;
  unint64_t v40 = (unint64_t)a2[2];
  if ((unint64_t)(v38 + 1) > v40)
  {
    unint64_t v41 = (unint64_t)(v38 + 993);
    if (2 * v40 <= v41) {
      size_t v42 = v41;
    }
    else {
      size_t v42 = 2 * v40;
    }
    a2[2] = (char *)v42;
    uint64_t result = (char *)realloc(result, v42);
    *a2 = result;
    if (result)
    {
      unint64_t v38 = a2[1];
      size_t v39 = v38 + 1;
      goto LABEL_49;
    }
LABEL_50:
    abort();
  }
LABEL_49:
  a2[1] = v39;
  v38[(void)result] = 59;
  return result;
}

char *llvm::itanium_demangle::TypeRequirement::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 10) > v6)
  {
    size_t v7 = (size_t)(v5 + 1002);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  *(void *)uint64_t v10 = *(void *)" typename ";
  *((_WORD *)v10 + 4) = 8293;
  a2[1] += 10;
  uint64_t v11 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v11 + 40))(v11, a2);
  }
  uint64_t result = *a2;
  unint64_t v13 = a2[1];
  unint64_t v14 = v13 + 1;
  unint64_t v15 = (unint64_t)a2[2];
  if ((unint64_t)(v13 + 1) > v15)
  {
    unint64_t v16 = (unint64_t)(v13 + 993);
    if (2 * v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = 2 * v15;
    }
    a2[2] = (char *)v17;
    uint64_t result = (char *)realloc(result, v17);
    *a2 = result;
    if (result)
    {
      unint64_t v13 = a2[1];
      unint64_t v14 = v13 + 1;
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  a2[1] = v14;
  v13[(void)result] = 59;
  return result;
}

char *llvm::itanium_demangle::NestedRequirement::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 10) > v6)
  {
    size_t v7 = (size_t)(v5 + 1002);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  *(void *)uint64_t v10 = *(void *)" requires ";
  *((_WORD *)v10 + 4) = 8307;
  a2[1] += 10;
  uint64_t v11 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v11 + 40))(v11, a2);
  }
  uint64_t result = *a2;
  unint64_t v13 = a2[1];
  unint64_t v14 = v13 + 1;
  unint64_t v15 = (unint64_t)a2[2];
  if ((unint64_t)(v13 + 1) > v15)
  {
    unint64_t v16 = (unint64_t)(v13 + 993);
    if (2 * v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = 2 * v15;
    }
    a2[2] = (char *)v17;
    uint64_t result = (char *)realloc(result, v17);
    *a2 = result;
    if (result)
    {
      unint64_t v13 = a2[1];
      unint64_t v14 = v13 + 1;
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  a2[1] = v14;
  v13[(void)result] = 59;
  return result;
}

char *llvm::itanium_demangle::RequiresExpr::printLeft(void *a1, uint64_t a2)
{
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 8 > v6)
  {
    size_t v7 = v5 + 1000;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_71;
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  *(void *)&v4[v5] = 0x7365726975716572;
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v11 = v10 + 8;
  *(void *)(a2 + 8) = v10 + 8;
  if (a1[3])
  {
    uint64_t v12 = v10 + 9;
    unint64_t v13 = *(void *)(a2 + 16);
    unint64_t v14 = *(char **)a2;
    if (v10 + 9 > v13)
    {
      if (2 * v13 <= v10 + 1001) {
        size_t v15 = v10 + 1001;
      }
      else {
        size_t v15 = 2 * v13;
      }
      *(void *)(a2 + 16) = v15;
      unint64_t v14 = (char *)realloc(v14, v15);
      *(void *)a2 = v14;
      if (!v14) {
        goto LABEL_71;
      }
      uint64_t v11 = *(void *)(a2 + 8);
      uint64_t v12 = v11 + 1;
    }
    *(void *)(a2 + 8) = v12;
    v14[v11] = 32;
    ++*(_DWORD *)(a2 + 32);
    unint64_t v16 = *(char **)a2;
    uint64_t v17 = *(void *)(a2 + 8);
    uint64_t v18 = v17 + 1;
    unint64_t v19 = *(void *)(a2 + 16);
    if (v17 + 1 > v19)
    {
      unint64_t v20 = v17 + 993;
      if (2 * v19 <= v20) {
        size_t v21 = v20;
      }
      else {
        size_t v21 = 2 * v19;
      }
      *(void *)(a2 + 16) = v21;
      unint64_t v16 = (char *)realloc(v16, v21);
      *(void *)a2 = v16;
      if (!v16) {
        goto LABEL_71;
      }
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v18 = v17 + 1;
    }
    *(void *)(a2 + 8) = v18;
    v16[v17] = 40;
    uint64_t v22 = *(void *)(a2 + 8);
    if (a1[3])
    {
      uint64_t v23 = 0;
      char v24 = 1;
      while (1)
      {
        uint64_t v25 = v22;
        if ((v24 & 1) == 0)
        {
          unint64_t v26 = *(void *)(a2 + 16);
          unint64_t v27 = *(char **)a2;
          if (v22 + 2 <= v26)
          {
            uint64_t v30 = v22;
          }
          else
          {
            unint64_t v28 = 2 * v26;
            if (v28 <= v22 + 994) {
              size_t v29 = v22 + 994;
            }
            else {
              size_t v29 = v28;
            }
            *(void *)(a2 + 16) = v29;
            unint64_t v27 = (char *)realloc(v27, v29);
            *(void *)a2 = v27;
            if (!v27) {
              goto LABEL_71;
            }
            uint64_t v30 = *(void *)(a2 + 8);
          }
          *(_WORD *)&v27[v30] = 8236;
          uint64_t v25 = *(void *)(a2 + 8) + 2;
          *(void *)(a2 + 8) = v25;
        }
        llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1[2] + 8 * v23), a2, 18, 0);
        if (v25 == *(void *)(a2 + 8))
        {
          *(void *)(a2 + 8) = v22;
          if (++v23 == a1[3]) {
            break;
          }
        }
        else
        {
          char v24 = 0;
          uint64_t v22 = *(void *)(a2 + 8);
          if (++v23 == a1[3]) {
            break;
          }
        }
      }
    }
    --*(_DWORD *)(a2 + 32);
    uint64_t v31 = v22 + 1;
    unint64_t v32 = *(void *)(a2 + 16);
    size_t v33 = *(char **)a2;
    if (v22 + 1 > v32)
    {
      unint64_t v34 = 2 * v32;
      if (v34 <= v22 + 993) {
        size_t v35 = v22 + 993;
      }
      else {
        size_t v35 = v34;
      }
      *(void *)(a2 + 16) = v35;
      size_t v33 = (char *)realloc(v33, v35);
      *(void *)a2 = v33;
      if (!v33) {
        goto LABEL_71;
      }
      uint64_t v22 = *(void *)(a2 + 8);
      uint64_t v31 = v22 + 1;
    }
    *(void *)(a2 + 8) = v31;
    v33[v22] = 41;
    uint64_t v11 = *(void *)(a2 + 8);
  }
  uint64_t v36 = v11 + 1;
  unint64_t v37 = *(void *)(a2 + 16);
  unint64_t v38 = *(char **)a2;
  if (v11 + 1 > v37)
  {
    unint64_t v39 = v11 + 993;
    if (2 * v37 <= v39) {
      size_t v40 = v39;
    }
    else {
      size_t v40 = 2 * v37;
    }
    *(void *)(a2 + 16) = v40;
    unint64_t v38 = (char *)realloc(v38, v40);
    *(void *)a2 = v38;
    if (!v38) {
      goto LABEL_71;
    }
    uint64_t v11 = *(void *)(a2 + 8);
    uint64_t v36 = v11 + 1;
  }
  *(void *)(a2 + 8) = v36;
  v38[v11] = 32;
  ++*(_DWORD *)(a2 + 32);
  unint64_t v41 = *(char **)a2;
  uint64_t v42 = *(void *)(a2 + 8);
  uint64_t v43 = v42 + 1;
  unint64_t v44 = *(void *)(a2 + 16);
  if (v42 + 1 > v44)
  {
    unint64_t v45 = v42 + 993;
    if (2 * v44 <= v45) {
      size_t v46 = v45;
    }
    else {
      size_t v46 = 2 * v44;
    }
    *(void *)(a2 + 16) = v46;
    unint64_t v41 = (char *)realloc(v41, v46);
    *(void *)a2 = v41;
    if (!v41) {
      goto LABEL_71;
    }
    uint64_t v42 = *(void *)(a2 + 8);
    uint64_t v43 = v42 + 1;
  }
  *(void *)(a2 + 8) = v43;
  v41[v42] = 123;
  uint64_t v47 = a1[5];
  if (v47)
  {
    unint64_t v48 = (void *)a1[4];
    uint64_t v49 = 8 * v47;
    do
    {
      uint64_t v50 = *v48;
      (*(void (**)(void, uint64_t))(*(void *)*v48 + 32))(*v48, a2);
      if ((*(_WORD *)(v50 + 9) & 0xC0) != 0x40) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v50 + 40))(v50, a2);
      }
      ++v48;
      v49 -= 8;
    }
    while (v49);
  }
  unint64_t v51 = *(char **)a2;
  uint64_t v52 = *(void *)(a2 + 8);
  uint64_t v53 = v52 + 1;
  unint64_t v54 = *(void *)(a2 + 16);
  if (v52 + 1 > v54)
  {
    unint64_t v55 = v52 + 993;
    if (2 * v54 <= v55) {
      size_t v56 = v55;
    }
    else {
      size_t v56 = 2 * v54;
    }
    *(void *)(a2 + 16) = v56;
    unint64_t v51 = (char *)realloc(v51, v56);
    *(void *)a2 = v51;
    if (!v51) {
      goto LABEL_71;
    }
    uint64_t v52 = *(void *)(a2 + 8);
    uint64_t v53 = v52 + 1;
  }
  *(void *)(a2 + 8) = v53;
  v51[v52] = 32;
  --*(_DWORD *)(a2 + 32);
  uint64_t result = *(char **)a2;
  uint64_t v58 = *(void *)(a2 + 8);
  uint64_t v59 = v58 + 1;
  unint64_t v60 = *(void *)(a2 + 16);
  if (v58 + 1 > v60)
  {
    unint64_t v61 = v58 + 993;
    if (2 * v60 <= v61) {
      size_t v62 = v61;
    }
    else {
      size_t v62 = 2 * v60;
    }
    *(void *)(a2 + 16) = v62;
    uint64_t result = (char *)realloc(result, v62);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v58 = *(void *)(a2 + 8);
      uint64_t v59 = v58 + 1;
      goto LABEL_70;
    }
LABEL_71:
    abort();
  }
LABEL_70:
  *(void *)(a2 + 8) = v59;
  result[v58] = 125;
  return result;
}

char *llvm::itanium_demangle::SubobjectExpr::printLeft(void *a1, char **a2)
{
  uint64_t v4 = a1[3];
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 2) > v7)
  {
    size_t v8 = (size_t)(v6 + 994);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      goto LABEL_56;
    }
    unint64_t v6 = a2[1];
  }
  *(_WORD *)&v6[(void)v5] = 15406;
  a2[1] += 2;
  uint64_t v11 = a1[2];
  (*(void (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v11 + 40))(v11, a2);
  }
  uint64_t v12 = *a2;
  unint64_t v13 = a2[1];
  unint64_t v14 = (unint64_t)a2[2];
  if ((unint64_t)(v13 + 11) > v14)
  {
    size_t v15 = (size_t)(v13 + 1003);
    unint64_t v16 = 2 * v14;
    if (v16 <= v15) {
      size_t v17 = v15;
    }
    else {
      size_t v17 = v16;
    }
    a2[2] = (char *)v17;
    uint64_t v12 = (char *)realloc(v12, v17);
    *a2 = v12;
    if (!v12) {
      goto LABEL_56;
    }
    unint64_t v13 = a2[1];
  }
  uint64_t v18 = &v13[(void)v12];
  *(void *)uint64_t v18 = *(void *)" at offset ";
  *(_DWORD *)(v18 + 7) = 544499059;
  unint64_t v19 = a2[1];
  unint64_t v20 = v19 + 11;
  a2[1] = v19 + 11;
  size_t v21 = a1[5];
  if (!v21)
  {
    unint64_t v36 = (unint64_t)a2[2];
    unint64_t v37 = *a2;
    if ((unint64_t)(v19 + 12) > v36)
    {
      if (2 * v36 <= (unint64_t)(v19 + 1004)) {
        size_t v38 = (size_t)(v19 + 1004);
      }
      else {
        size_t v38 = 2 * v36;
      }
      a2[2] = (char *)v38;
      unint64_t v37 = (char *)realloc(v37, v38);
      *a2 = v37;
      if (!v37) {
        goto LABEL_56;
      }
      unint64_t v20 = a2[1];
    }
    v20[(void)v37] = 48;
    size_t v21 = 1;
    goto LABEL_48;
  }
  uint64_t v22 = (unsigned char *)a1[4];
  unint64_t v23 = (unint64_t)a2[2];
  char v24 = *a2;
  if (*v22 != 110)
  {
    unint64_t v39 = &v20[v21];
    if ((unint64_t)&v20[v21] > v23)
    {
      if (2 * v23 <= (unint64_t)(v39 + 992)) {
        size_t v40 = (size_t)(v39 + 992);
      }
      else {
        size_t v40 = 2 * v23;
      }
      a2[2] = (char *)v40;
      char v24 = (char *)realloc(v24, v40);
      *a2 = v24;
      if (!v24) {
        goto LABEL_56;
      }
      unint64_t v20 = a2[1];
    }
    size_t v35 = &v20[(void)v24];
    unint64_t v34 = v22;
    goto LABEL_47;
  }
  if ((unint64_t)(v19 + 12) > v23)
  {
    if (2 * v23 <= (unint64_t)(v19 + 1004)) {
      size_t v25 = (size_t)(v19 + 1004);
    }
    else {
      size_t v25 = 2 * v23;
    }
    a2[2] = (char *)v25;
    char v24 = (char *)realloc(v24, v25);
    *a2 = v24;
    if (!v24) {
      goto LABEL_56;
    }
    unint64_t v20 = a2[1];
  }
  v20[(void)v24] = 45;
  unint64_t v26 = a2[1];
  size_t v27 = (size_t)(v26 + 1);
  a2[1] = v26 + 1;
  uint64_t v28 = a1[5];
  size_t v21 = v28 - 1;
  if (v28 != 1)
  {
    uint64_t v29 = a1[4];
    unint64_t v30 = (unint64_t)&v26[v28];
    unint64_t v31 = (unint64_t)a2[2];
    unint64_t v32 = *a2;
    if (v30 > v31)
    {
      if (2 * v31 <= v30 + 992) {
        size_t v33 = v30 + 992;
      }
      else {
        size_t v33 = 2 * v31;
      }
      a2[2] = (char *)v33;
      unint64_t v32 = (char *)realloc(v32, v33);
      *a2 = v32;
      if (!v32) {
        goto LABEL_56;
      }
      size_t v27 = (size_t)a2[1];
    }
    unint64_t v34 = (const void *)(v29 + 1);
    size_t v35 = &v32[v27];
LABEL_47:
    memcpy(v35, v34, v21);
LABEL_48:
    size_t v27 = (size_t)&a2[1][v21];
    a2[1] = (char *)v27;
  }
  unint64_t v41 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v27 + 1 > v41)
  {
    size_t v43 = v27 + 993;
    unint64_t v44 = 2 * v41;
    if (v44 <= v43) {
      size_t v45 = v43;
    }
    else {
      size_t v45 = v44;
    }
    a2[2] = (char *)v45;
    uint64_t result = (char *)realloc(result, v45);
    *a2 = result;
    if (result)
    {
      size_t v27 = (size_t)a2[1];
      goto LABEL_55;
    }
LABEL_56:
    abort();
  }
LABEL_55:
  result[v27] = 62;
  ++a2[1];
  return result;
}

void *llvm::itanium_demangle::SizeofParamPackExpr::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 9 > v6)
  {
    size_t v7 = v5 + 1001;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_20;
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  size_t v10 = &v4[v5];
  *(void *)size_t v10 = *(void *)"sizeof...";
  v10[8] = 46;
  uint64_t v11 = *(void **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  uint64_t v13 = v12 + 9;
  *(void *)(a2 + 8) = v12 + 9;
  ++*(_DWORD *)(a2 + 32);
  uint64_t v14 = v12 + 10;
  unint64_t v15 = *(void *)(a2 + 16);
  if (v12 + 10 > v15)
  {
    if (2 * v15 <= v12 + 1002) {
      size_t v16 = v12 + 1002;
    }
    else {
      size_t v16 = 2 * v15;
    }
    *(void *)(a2 + 16) = v16;
    uint64_t v11 = realloc(v11, v16);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_20;
    }
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = v13 + 1;
  }
  *(void *)(a2 + 8) = v14;
  *((unsigned char *)v11 + v13) = 40;
  uint64_t v17 = *(void *)(a1 + 16);
  char v25 = 42;
  __int16 v26 = 1344;
  char v24 = &unk_1EC9A3100;
  uint64_t v27 = v17;
  llvm::itanium_demangle::ParameterPackExpansion::printLeft((uint64_t)&v24, (char **)a2);
  --*(_DWORD *)(a2 + 32);
  uint64_t result = *(void **)a2;
  uint64_t v19 = *(void *)(a2 + 8);
  uint64_t v20 = v19 + 1;
  unint64_t v21 = *(void *)(a2 + 16);
  if (v19 + 1 > v21)
  {
    unint64_t v22 = v19 + 993;
    if (2 * v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = 2 * v21;
    }
    *(void *)(a2 + 16) = v23;
    uint64_t result = realloc(result, v23);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v19 = *(void *)(a2 + 8);
      uint64_t v20 = v19 + 1;
      goto LABEL_19;
    }
LABEL_20:
    abort();
  }
LABEL_19:
  *(void *)(a2 + 8) = v20;
  *((unsigned char *)result + v19) = 41;
  return result;
}

void *llvm::itanium_demangle::NodeArrayNode::printLeft(void *result, char **a2)
{
  if (result[3])
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = (uint64_t)a2[1];
    char v6 = 1;
    do
    {
      while (1)
      {
        uint64_t v7 = v5;
        if ((v6 & 1) == 0)
        {
          unint64_t v8 = (unint64_t)a2[2];
          size_t v9 = *a2;
          if (v5 + 2 <= v8)
          {
            uint64_t v12 = v5;
          }
          else
          {
            unint64_t v10 = 2 * v8;
            if (v10 <= v5 + 994) {
              size_t v11 = v5 + 994;
            }
            else {
              size_t v11 = v10;
            }
            a2[2] = (char *)v11;
            size_t v9 = (char *)realloc(v9, v11);
            *a2 = v9;
            if (!v9) {
              abort();
            }
            uint64_t v12 = (uint64_t)a2[1];
          }
          *(_WORD *)&v9[v12] = 8236;
          uint64_t v7 = (uint64_t)(a2[1] + 2);
          a2[1] = (char *)v7;
        }
        uint64_t result = llvm::itanium_demangle::Node::printAsOperand(*(void *)(v3[2] + 8 * v4), (uint64_t)a2, 18, 0);
        if ((char *)v7 != a2[1]) {
          break;
        }
        a2[1] = (char *)v5;
        if (++v4 == v3[3]) {
          return result;
        }
      }
      char v6 = 0;
      uint64_t v5 = (uint64_t)a2[1];
      ++v4;
    }
    while (v4 != v3[3]);
  }
  return result;
}

uint64_t llvm::itanium_demangle::ThrowExpr::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 6) > v6)
  {
    size_t v7 = (size_t)(v5 + 998);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      abort();
    }
    uint64_t v5 = a2[1];
  }
  unint64_t v10 = &v5[(void)v4];
  *((_WORD *)v10 + 2) = 8311;
  *(_DWORD *)unint64_t v10 = 1869768820;
  a2[1] += 6;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    uint64_t v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseUnresolvedType(unsigned __int8 **a1, size_t a2)
{
  if (a1[1] != *a1)
  {
    int v3 = **a1;
    if (v3 == 68)
    {
      if (v4)
      {
        uint64_t v5 = a1[38];
        if (v5 == a1[39])
        {
          uint64_t v12 = a1[37];
          int64_t v7 = v5 - v12;
          size_t v8 = 2 * (v5 - v12);
          if (v12 == (unsigned __int8 *)(a1 + 40))
          {
            uint64_t v13 = (unsigned __int8 *)malloc(2 * (v5 - v12));
            if (v13)
            {
              unint64_t v10 = v13;
              if (v5 != v12) {
                memmove(v13, v12, v5 - v12);
              }
              goto LABEL_22;
            }
LABEL_26:
            abort();
          }
          unint64_t v6 = (unsigned __int8 **)a1[37];
LABEL_17:
          unint64_t v10 = (unsigned __int8 *)realloc(v6, v8);
          a1[37] = v10;
          if (v10)
          {
LABEL_23:
            uint64_t v5 = &v10[8 * (v7 >> 3)];
            a1[39] = &v10[8 * (v7 >> 2)];
            goto LABEL_24;
          }
          goto LABEL_26;
        }
LABEL_24:
        a1[38] = v5 + 8;
        *(void *)uint64_t v5 = v4;
      }
      return (char *)v4;
    }
    if (v3 == 84)
    {
      if (v4)
      {
        uint64_t v5 = a1[38];
        if (v5 == a1[39])
        {
          unint64_t v6 = (unsigned __int8 **)a1[37];
          int64_t v7 = v5 - (unsigned __int8 *)v6;
          size_t v8 = 2 * (v5 - (unsigned __int8 *)v6);
          if (v6 == a1 + 40)
          {
            size_t v9 = (unsigned __int8 *)malloc(2 * (v5 - (unsigned __int8 *)v6));
            if (v9)
            {
              unint64_t v10 = v9;
              if (v5 != (unsigned __int8 *)(a1 + 40)) {
                memcpy(v9, a1 + 40, v7);
              }
LABEL_22:
              a1[37] = v10;
              goto LABEL_23;
            }
            goto LABEL_26;
          }
          goto LABEL_17;
        }
        goto LABEL_24;
      }
      return (char *)v4;
    }
  }
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseSimpleId(uint64_t a1)
{
  if (!v2 || *(void *)(a1 + 8) == *(void *)a1 || **(unsigned char **)a1 != 73) {
    return v2;
  }
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void **)(a1 + 4904);
    uint64_t v6 = v5[1];
    if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      int64_t v7 = malloc(0x1000uLL);
      if (!v7) {
        std::terminate();
      }
      uint64_t v6 = 0;
      *int64_t v7 = v5;
      v7[1] = 0;
      uint64_t v5 = v7;
      *(void *)(a1 + 4904) = v7;
    }
    v5[1] = v6 + 32;
    size_t v8 = (char *)v5 + v6;
    v8[24] = 45;
    *(_WORD *)(v8 + 25) = *(_WORD *)(v8 + 25) & 0xF000 | 0x540;
    *((void *)v8 + 2) = &unk_1EC9A2DE8;
    *((void *)v8 + 4) = v2;
    *((void *)v8 + 5) = v4;
    return v8 + 16;
  }
  return 0;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseBaseUnresolvedName(uint64_t a1, size_t a2)
{
  uint64_t v3 = *(unsigned __int8 **)a1;
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60) & 0x400) == 0) {
      goto LABEL_4;
    }
LABEL_16:
  }
  if (((char)*v3 & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v3 + 60) & 0x400) != 0) {
    goto LABEL_16;
  }
LABEL_4:
  if ((unint64_t)&v4[-*(void *)a1] < 2) {
    goto LABEL_7;
  }
  if (*(_WORD *)v3 != 28260)
  {
    if (*(_WORD *)v3 == 28271)
    {
      *(void *)a1 = v3 + 2;
      if (!v5) {
        return v5;
      }
LABEL_8:
      if (*(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 73)
      {
        if (v6)
        {
          uint64_t v7 = v6;
          size_t v8 = *(void **)(a1 + 4904);
          uint64_t v9 = v8[1];
          if ((unint64_t)(v9 - 4048) > 0xFFFFFFFFFFFFF00FLL)
          {
LABEL_14:
            v8[1] = v9 + 32;
            uint64_t v11 = (char *)v8 + v9;
            v11[24] = 45;
            *(_WORD *)(v11 + 25) = *(_WORD *)(v11 + 25) & 0xF000 | 0x540;
            *((void *)v11 + 2) = &unk_1EC9A2DE8;
            *((void *)v11 + 4) = v5;
            *((void *)v11 + 5) = v7;
            return v11 + 16;
          }
          unint64_t v10 = malloc(0x1000uLL);
          if (v10)
          {
            uint64_t v9 = 0;
            *unint64_t v10 = v8;
            v10[1] = 0;
            size_t v8 = v10;
            *(void *)(a1 + 4904) = v10;
            goto LABEL_14;
          }
LABEL_32:
          std::terminate();
        }
        return 0;
      }
      return v5;
    }
LABEL_7:
    if (!v5) {
      return v5;
    }
    goto LABEL_8;
  }
  uint64_t v13 = (char *)(v3 + 2);
  *(void *)a1 = v13;
  if (v4 == v13)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60) & 0x400) == 0) {
      goto LABEL_22;
    }
LABEL_30:
    if (v15) {
      goto LABEL_23;
    }
    return 0;
  }
  int v14 = *v13;
  if ((v14 & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v14 + 60) & 0x400) != 0) {
    goto LABEL_30;
  }
LABEL_22:
  if (!v15) {
    return 0;
  }
LABEL_23:
  size_t v16 = *(void **)(a1 + 4904);
  uint64_t v17 = v16[1];
  if ((unint64_t)(v17 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v18 = malloc(0x1000uLL);
    if (!v18) {
      goto LABEL_32;
    }
    uint64_t v17 = 0;
    *uint64_t v18 = v16;
    v18[1] = 0;
    size_t v16 = v18;
    *(void *)(a1 + 4904) = v18;
  }
  v16[1] = v17 + 32;
  uint64_t v19 = (char *)v16 + v17;
  unsigned char v19[24] = 50;
  *(_WORD *)(v19 + 25) = *(_WORD *)(v19 + 25) & 0xF000 | 0x540;
  *((void *)v19 + 2) = &unk_1EC9A3578;
  *((void *)v19 + 4) = v15;
  return v19 + 16;
}

uint64_t llvm::itanium_demangle::QualifiedName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 2) > v7)
  {
    size_t v8 = (size_t)(v6 + 994);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  *(_WORD *)&v6[(void)v5] = 14906;
  a2[1] += 2;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    uint64_t v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::QualifiedName::getBaseName(llvm::itanium_demangle::QualifiedName *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseOperatorName(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(unsigned __int8 **)a1;
  uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  if ((unint64_t)&v4[-*(void *)a1] >= 2)
  {
    unint64_t v6 = 0;
    int v7 = *v3;
    uint64_t v8 = 61;
    do
    {
      unint64_t v9 = (v6 + v8) >> 1;
          + 16 * v9;
      if (*v10 < (char)v7)
      {
        unint64_t v6 = v9 + 1;
      }
      else if (*v10 == v7)
      {
        if (v10[1] >= (char)v3[1]) {
          uint64_t v8 = (v6 + v8) >> 1;
        }
        else {
          unint64_t v6 = v9 + 1;
        }
      }
      else
      {
        uint64_t v8 = (v6 + v8) >> 1;
      }
    }
    while (v8 != v6);
        + 16 * v6;
    if (*v11 == v7 && v11[1] == v3[1])
    {
      *(void *)a1 = v3 + 2;
      unsigned int v12 = v11[2];
      if (v12 == 8)
      {
        char v13 = *(unsigned char *)(a1 + 776);
        *(unsigned char *)(a1 + 776) = 0;
        int v14 = *(unsigned __int8 *)(a1 + 777);
        if (a2) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v14 == 0;
        }
        char v16 = !v15;
        *(unsigned char *)(a1 + 777) = v16;
        if (!result) {
          goto LABEL_27;
        }
        uint64_t v18 = result;
        if (a2) {
          *a2 = 1;
        }
        uint64_t v19 = *(void **)(a1 + 4904);
        uint64_t v20 = v19[1];
        if ((unint64_t)(v20 - 4048) > 0xFFFFFFFFFFFFF00FLL)
        {
LABEL_26:
          v19[1] = v20 + 32;
          unint64_t v22 = (char *)v19 + v20;
          uint64_t result = v22 + 16;
          v22[24] = 4;
          *(_WORD *)(v22 + 25) = *(_WORD *)(v22 + 25) & 0xF000 | 0x540;
          *((void *)v22 + 2) = &unk_1EC9A3050;
          *((void *)v22 + 4) = v18;
LABEL_27:
          *(unsigned char *)(a1 + 777) = v14;
          *(unsigned char *)(a1 + 776) = v13;
          return result;
        }
        unint64_t v21 = malloc(0x1000uLL);
        if (v21)
        {
          uint64_t v20 = 0;
          *unint64_t v21 = v19;
          v21[1] = 0;
          uint64_t v19 = v21;
          *(void *)(a1 + 4904) = v21;
          goto LABEL_26;
        }
LABEL_53:
        std::terminate();
      }
      if (v12 > 0xA || v12 == 4 && (v11[3] & 1) == 0) {
        return 0;
      }
      unint64_t v32 = (const char *)*((void *)v11 + 1);
      size_t v33 = strlen(v32);
      unint64_t v34 = *(void **)(a1 + 4904);
      uint64_t v35 = v34[1];
      if ((unint64_t)(v35 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        unint64_t v36 = malloc(0x1000uLL);
        if (!v36) {
          goto LABEL_53;
        }
        uint64_t v35 = 0;
        *unint64_t v36 = v34;
        v36[1] = 0;
        unint64_t v34 = v36;
        *(void *)(a1 + 4904) = v36;
      }
      v34[1] = v35 + 32;
      unint64_t v37 = (char *)v34 + v35;
      uint64_t result = v37 + 16;
      v37[24] = 8;
      *(_WORD *)(v37 + 25) = *(_WORD *)(v37 + 25) & 0xF000 | 0x540;
      *((void *)v37 + 2) = &unk_1EC9A3628;
      *((void *)v37 + 4) = v32;
      *((void *)v37 + 5) = v33;
      return result;
    }
    if (*(_WORD *)v3 == 26988)
    {
      *(void *)a1 = v3 + 2;
      if (!result) {
        return result;
      }
      size_t v23 = result;
      uint64_t v29 = *(void **)(a1 + 4904);
      uint64_t v30 = v29[1];
      if ((unint64_t)(v30 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        unint64_t v31 = malloc(0x1000uLL);
        if (!v31) {
          goto LABEL_53;
        }
        uint64_t v30 = 0;
        *unint64_t v31 = v29;
        v31[1] = 0;
        uint64_t v29 = v31;
        *(void *)(a1 + 4904) = v31;
      }
      v29[1] = v30 + 32;
      uint64_t v27 = (char *)v29 + v30;
      uint64_t result = v27 + 16;
      v27[24] = 20;
      *(_WORD *)(v27 + 25) = *(_WORD *)(v27 + 25) & 0xF000 | 0x540;
      uint64_t v28 = &unk_1EC9A27B8;
LABEL_43:
      *((void *)v27 + 2) = v28;
      *((void *)v27 + 4) = v23;
      return result;
    }
  }
  if (v3 == v4) {
    return 0;
  }
  if (*v3 != 118) {
    return 0;
  }
  *(void *)a1 = v3 + 1;
  if (v4 == v3 + 1 || v3[1] - 48 > 9) {
    return 0;
  }
  *(void *)a1 = v3 + 2;
  if (result)
  {
    size_t v23 = result;
    char v24 = *(void **)(a1 + 4904);
    uint64_t v25 = v24[1];
    if ((unint64_t)(v25 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      __int16 v26 = malloc(0x1000uLL);
      if (!v26) {
        goto LABEL_53;
      }
      uint64_t v25 = 0;
      *__int16 v26 = v24;
      v26[1] = 0;
      char v24 = v26;
      *(void *)(a1 + 4904) = v26;
    }
    v24[1] = v25 + 32;
    uint64_t v27 = (char *)v24 + v25;
    uint64_t result = v27 + 16;
    v27[24] = 4;
    *(_WORD *)(v27 + 25) = *(_WORD *)(v27 + 25) & 0xF000 | 0x540;
    uint64_t v28 = &unk_1EC9A3050;
    goto LABEL_43;
  }
  return result;
}

uint64_t llvm::itanium_demangle::DtorName::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 1 > v6)
  {
    size_t v7 = v5 + 993;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      abort();
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  *((unsigned char *)v4 + v5) = 126;
  ++*(void *)(a2 + 8);
  size_t v10 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 32);

  return v10();
}

uint64_t llvm::itanium_demangle::ConversionOperatorType::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 9) > v6)
  {
    size_t v7 = (size_t)(v5 + 1001);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      abort();
    }
    uint64_t v5 = a2[1];
  }
  size_t v10 = &v5[(void)v4];
  *(void *)size_t v10 = *(void *)"operator ";
  v10[8] = 32;
  a2[1] += 9;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    char v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::LiteralOperator::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 11) > v6)
  {
    size_t v7 = (size_t)(v5 + 1003);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      abort();
    }
    uint64_t v5 = a2[1];
  }
  size_t v10 = &v5[(void)v4];
  *(void *)size_t v10 = *(void *)"operator\"\" ";
  *(_DWORD *)(v10 + 7) = 539107954;
  a2[1] += 11;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    char v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::GlobalQualifiedName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 2) > v6)
  {
    size_t v7 = (size_t)(v5 + 994);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      abort();
    }
    uint64_t v5 = a2[1];
  }
  *(_WORD *)&v5[(void)v4] = 14906;
  a2[1] += 2;
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40)
  {
    unsigned int v12 = *(uint64_t (**)(uint64_t, char **))(*(void *)v10 + 40);
    return v12(v10, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::GlobalQualifiedName::getBaseName(llvm::itanium_demangle::GlobalQualifiedName *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48))();
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseAbiTags(uint64_t a1, char *a2)
{
  int v2 = a2;
  uint64_t v4 = *(unsigned __int8 **)a1;
  uint64_t v3 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v3) {
    return a2;
  }
  while (*v4 == 66)
  {
    *(void *)a1 = v4 + 1;
    if (v3 == v4 + 1 || v4[1] - 58 < 0xFFFFFFF6) {
      return 0;
    }
    unint64_t v9 = 0;
    uint64_t v10 = v4 + 2;
    while (1)
    {
      *(void *)a1 = v10;
      unint64_t v9 = (char)*(v10 - 1) + 10 * v9 - 48;
      if (v10 == v3) {
        break;
      }
      uint64_t v11 = v10 + 1;
      unsigned int v12 = *v10++ - 48;
      if (v12 > 9)
      {
        char v13 = v11 - 1;
        if (v3 - (v11 - 1) < v9) {
          return 0;
        }
        goto LABEL_13;
      }
    }
    char v13 = v3;
    if (v9) {
      return 0;
    }
LABEL_13:
    *(void *)a1 = &v13[v9];
    if (!v9) {
      return 0;
    }
    int v14 = *(void **)(a1 + 4904);
    uint64_t v15 = v14[1];
    if ((unint64_t)(v15 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
    {
      char v16 = malloc(0x1000uLL);
      if (!v16) {
        std::terminate();
      }
      uint64_t v15 = 0;
      *char v16 = v14;
      v16[1] = 0;
      int v14 = v16;
      *(void *)(a1 + 4904) = v16;
    }
    v14[1] = v15 + 48;
    unint64_t v6 = (char *)v14 + v15;
    uint64_t result = v6 + 16;
    __int16 v8 = *(_WORD *)(v2 + 9);
    v6[24] = 9;
    *(_WORD *)(v6 + 25) = *(_WORD *)(v6 + 25) & 0xF000 | v8 & 0xFC0;
    *((void *)v6 + 2) = &unk_1EC9A1A50;
    *((void *)v6 + 4) = v2;
    *((void *)v6 + 5) = v13;
    *((void *)v6 + 6) = v9;
    uint64_t v4 = *(unsigned __int8 **)a1;
    uint64_t v3 = *(unsigned __int8 **)(a1 + 8);
    int v2 = result;
    if (*(unsigned __int8 **)a1 == v3) {
      return result;
    }
  }
  return v2;
}

void *llvm::itanium_demangle::SpecialSubstitution::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 5) > v6)
  {
    size_t v7 = (size_t)(v5 + 997);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
LABEL_21:
    }
      abort();
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  v10[4] = 58;
  *(_DWORD *)uint64_t v10 = 979661939;
  uint64_t v11 = (uint64_t)(a2[1] + 5);
  a2[1] = (char *)v11;
  uint64_t v12 = *(unsigned int *)(a1 + 12);
  char v13 = "basic_string";
  int v14 = "allocator";
  uint64_t v15 = 6;
  size_t v16 = 9;
  switch(v12)
  {
    case 1:
      int v14 = "basic_string";
      size_t v16 = 12;
      goto LABEL_9;
    case 2:
      goto LABEL_14;
    case 3:
      char v13 = "basic_istream";
      uint64_t v15 = 7;
      goto LABEL_14;
    case 4:
      char v13 = "basic_ostream";
      uint64_t v15 = 7;
      goto LABEL_14;
    case 5:
      char v13 = "basic_iostream";
      uint64_t v15 = 8;
LABEL_14:
      int v14 = v13 + 6;
      size_t v16 = v15;
      unint64_t v17 = v11 + v15;
      size_t v18 = (size_t)a2[2];
      uint64_t v19 = *a2;
      if (v17 > v18) {
        goto LABEL_15;
      }
      goto LABEL_20;
    default:
LABEL_9:
      unint64_t v17 = v11 + v16;
      size_t v18 = (size_t)a2[2];
      uint64_t v19 = *a2;
      if (v11 + v16 <= v18) {
        goto LABEL_20;
      }
LABEL_15:
      if (2 * v18 <= v17 + 992) {
        size_t v20 = v17 + 992;
      }
      else {
        size_t v20 = 2 * v18;
      }
      a2[2] = (char *)v20;
      uint64_t v19 = (char *)realloc(v19, v20);
      *a2 = v19;
      if (!v19) {
        goto LABEL_21;
      }
      uint64_t v11 = (uint64_t)a2[1];
LABEL_20:
      uint64_t result = memcpy(&v19[v11], v14, v16);
      a2[1] += v16;
      return result;
  }
}

const char *llvm::itanium_demangle::SpecialSubstitution::getBaseName(llvm::itanium_demangle::SpecialSubstitution *this)
{
  uint64_t v1 = *((unsigned int *)this + 3);
  int v2 = "basic_string";
  uint64_t result = "allocator";
  switch(v1)
  {
    case 1:
      return "basic_string";
    case 2:
      goto LABEL_6;
    case 3:
      int v2 = "basic_istream";
      goto LABEL_6;
    case 4:
      int v2 = "basic_ostream";
      goto LABEL_6;
    case 5:
      int v2 = "basic_iostream";
LABEL_6:
      uint64_t result = v2 + 6;
      break;
    default:
      return result;
  }
  return result;
}

char *llvm::itanium_demangle::ExpandedSpecialSubstitution::printLeft(_DWORD *a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 5) > v6)
  {
    size_t v7 = (size_t)(v5 + 997);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_38;
    }
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  v10[4] = 58;
  *(_DWORD *)uint64_t v10 = 979661939;
  a2[1] += 5;
  uint64_t result = (char *)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 48))(a1);
  if (v12)
  {
    char v13 = result;
    size_t v14 = v12;
    uint64_t v15 = *a2;
    size_t v16 = a2[1];
    unint64_t v17 = &v16[v12];
    size_t v18 = a2[2];
    if (&v16[v12] > v18)
    {
      unint64_t v19 = 2 * (void)v18;
      if (v19 <= (unint64_t)(v17 + 992)) {
        size_t v20 = (size_t)(v17 + 992);
      }
      else {
        size_t v20 = v19;
      }
      a2[2] = (char *)v20;
      uint64_t v15 = (char *)realloc(v15, v20);
      *a2 = v15;
      if (!v15) {
        goto LABEL_38;
      }
      size_t v16 = a2[1];
    }
    uint64_t result = (char *)memcpy(&v16[(void)v15], v13, v14);
    a2[1] += v14;
  }
  if (a1[3] < 2u) {
    return result;
  }
  unint64_t v21 = *a2;
  unint64_t v22 = a2[1];
  unint64_t v23 = (unint64_t)a2[2];
  if ((unint64_t)(v22 + 29) > v23)
  {
    size_t v24 = (size_t)(v22 + 1021);
    unint64_t v25 = 2 * v23;
    if (v25 <= v24) {
      size_t v26 = v24;
    }
    else {
      size_t v26 = v25;
    }
    a2[2] = (char *)v26;
    unint64_t v21 = (char *)realloc(v21, v26);
    *a2 = v21;
    if (!v21) {
      goto LABEL_38;
    }
    unint64_t v22 = a2[1];
  }
  qmemcpy(&v22[(void)v21], "<char, std::char_traits<char>", 29);
  uint64_t v27 = a2[1];
  uint64_t v28 = (uint64_t)(v27 + 29);
  a2[1] = v27 + 29;
  if (a1[3] == 2)
  {
    unint64_t v29 = (unint64_t)a2[2];
    uint64_t v30 = *a2;
    if ((unint64_t)(v27 + 51) > v29)
    {
      if (2 * v29 <= (unint64_t)(v27 + 1043)) {
        size_t v31 = (size_t)(v27 + 1043);
      }
      else {
        size_t v31 = 2 * v29;
      }
      a2[2] = (char *)v31;
      uint64_t v30 = (char *)realloc(v30, v31);
      *a2 = v30;
      if (!v30) {
        goto LABEL_38;
      }
      uint64_t v28 = (uint64_t)a2[1];
    }
    qmemcpy(&v30[v28], ", std::allocator<char>", 22);
    uint64_t v28 = (uint64_t)(a2[1] + 22);
    a2[1] = (char *)v28;
  }
  unint64_t v32 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v28 + 1 > v32)
  {
    size_t v33 = v28 + 993;
    unint64_t v34 = 2 * v32;
    if (v34 <= v33) {
      size_t v35 = v33;
    }
    else {
      size_t v35 = v34;
    }
    a2[2] = (char *)v35;
    uint64_t result = (char *)realloc(result, v35);
    *a2 = result;
    if (result)
    {
      uint64_t v28 = (uint64_t)a2[1];
      goto LABEL_36;
    }
LABEL_38:
    abort();
  }
LABEL_36:
  result[v28] = 62;
  ++a2[1];
  return result;
}

char *llvm::itanium_demangle::ExpandedSpecialSubstitution::getBaseName(llvm::itanium_demangle::ExpandedSpecialSubstitution *this)
{
  return off_1E4FC0FB8[*((int *)this + 3)];
}

char *llvm::itanium_demangle::AbiTagAttr::printLeft(uint64_t a1, char **a2)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 5) > v6)
  {
    size_t v7 = (size_t)(v5 + 997);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_22;
    }
    uint64_t v5 = a2[1];
  }
  uint64_t v10 = &v5[(void)v4];
  v10[4] = 58;
  *(_DWORD *)uint64_t v10 = 1768055131;
  uint64_t v11 = (uint64_t)(a2[1] + 5);
  a2[1] = (char *)v11;
  size_t v12 = *(void *)(a1 + 32);
  if (v12)
  {
    char v13 = *(const void **)(a1 + 24);
    size_t v14 = v11 + v12;
    size_t v15 = (size_t)a2[2];
    size_t v16 = *a2;
    if (v11 + v12 > v15)
    {
      if (2 * v15 <= v14 + 992) {
        size_t v17 = v14 + 992;
      }
      else {
        size_t v17 = 2 * v15;
      }
      a2[2] = (char *)v17;
      size_t v16 = (char *)realloc(v16, v17);
      *a2 = v16;
      if (!v16) {
        goto LABEL_22;
      }
      uint64_t v11 = (uint64_t)a2[1];
    }
    memcpy(&v16[v11], v13, v12);
    uint64_t v11 = (uint64_t)&a2[1][v12];
    a2[1] = (char *)v11;
  }
  unint64_t v18 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v11 + 1 > v18)
  {
    size_t v20 = v11 + 993;
    unint64_t v21 = 2 * v18;
    if (v21 <= v20) {
      size_t v22 = v20;
    }
    else {
      size_t v22 = v21;
    }
    a2[2] = (char *)v22;
    uint64_t result = (char *)realloc(result, v22);
    *a2 = result;
    if (result)
    {
      uint64_t v11 = (uint64_t)a2[1];
      goto LABEL_21;
    }
LABEL_22:
    abort();
  }
LABEL_21:
  result[v11] = 93;
  ++a2[1];
  return result;
}

uint64_t llvm::itanium_demangle::AbiTagAttr::getBaseName(llvm::itanium_demangle::AbiTagAttr *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48))();
}

char *llvm::itanium_demangle::StructuredBindingName::printLeft(uint64_t a1, uint64_t a2)
{
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_28;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  v4[v5] = 91;
  uint64_t v10 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 24))
  {
    uint64_t v11 = 0;
    char v12 = 1;
    while (1)
    {
      uint64_t v13 = v10;
      if ((v12 & 1) == 0)
      {
        unint64_t v14 = *(void *)(a2 + 16);
        size_t v15 = *(char **)a2;
        if (v10 + 2 <= v14)
        {
          uint64_t v18 = v10;
        }
        else
        {
          unint64_t v16 = 2 * v14;
          if (v16 <= v10 + 994) {
            size_t v17 = v10 + 994;
          }
          else {
            size_t v17 = v16;
          }
          *(void *)(a2 + 16) = v17;
          size_t v15 = (char *)realloc(v15, v17);
          *(void *)a2 = v15;
          if (!v15) {
            goto LABEL_28;
          }
          uint64_t v18 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v15[v18] = 8236;
        uint64_t v13 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v13;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 16) + 8 * v11), a2, 18, 0);
      if (v13 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v10;
        if (++v11 == *(void *)(a1 + 24)) {
          break;
        }
      }
      else
      {
        char v12 = 0;
        uint64_t v10 = *(void *)(a2 + 8);
        if (++v11 == *(void *)(a1 + 24)) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v19 = v10 + 1;
  unint64_t v20 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v10 + 1 > v20)
  {
    unint64_t v22 = 2 * v20;
    if (v22 <= v10 + 993) {
      size_t v23 = v10 + 993;
    }
    else {
      size_t v23 = v22;
    }
    *(void *)(a2 + 16) = v23;
    uint64_t result = (char *)realloc(result, v23);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v19 = v10 + 1;
      goto LABEL_27;
    }
LABEL_28:
    abort();
  }
LABEL_27:
  *(void *)(a2 + 8) = v19;
  result[v10] = 93;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::CtorDtorName,llvm::itanium_demangle::Node *&,BOOL,int &>(uint64_t a1, uint64_t *a2, char a3, int a4)
{
  unint64_t v7 = *(void **)(a1 + 4904);
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v10 = malloc(0x1000uLL);
    if (!v10) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *uint64_t v10 = v7;
    v10[1] = 0;
    unint64_t v7 = v10;
    *(void *)(a1 + 4904) = v10;
  }
  v7[1] = v8 + 32;
  uint64_t v11 = (char *)v7 + v8;
  uint64_t result = v11 + 16;
  uint64_t v13 = *a2;
  v11[24] = 49;
  *(_WORD *)(v11 + 25) = *(_WORD *)(v11 + 25) & 0xF000 | 0x540;
  *((void *)v11 + 2) = &unk_1EC9A1FD0;
  *((void *)v11 + 4) = v13;
  v11[40] = a3 != 0;
  *((_DWORD *)v11 + 11) = a4;
  return result;
}

void *llvm::itanium_demangle::CtorDtorName::printLeft(uint64_t a1, char **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
    unint64_t v6 = (unint64_t)a2[2];
    if ((unint64_t)(v5 + 1) > v6)
    {
      size_t v7 = (size_t)(v5 + 993);
      unint64_t v8 = 2 * v6;
      if (v8 <= v7) {
        size_t v9 = v7;
      }
      else {
        size_t v9 = v8;
      }
      a2[2] = (char *)v9;
      uint64_t v4 = (char *)realloc(v4, v9);
      *a2 = v4;
      if (!v4) {
        goto LABEL_18;
      }
      uint64_t v5 = a2[1];
    }
    v5[(void)v4] = 126;
    ++a2[1];
  }
  uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 48))(*(void *)(a1 + 16));
  if (!v11) {
    return result;
  }
  char v12 = result;
  size_t v13 = v11;
  unint64_t v14 = *a2;
  size_t v15 = a2[1];
  unint64_t v16 = &v15[v11];
  size_t v17 = a2[2];
  if (&v15[v11] > v17)
  {
    unint64_t v18 = 2 * (void)v17;
    if (v18 <= (unint64_t)(v16 + 992)) {
      size_t v19 = (size_t)(v16 + 992);
    }
    else {
      size_t v19 = v18;
    }
    a2[2] = (char *)v19;
    unint64_t v14 = (char *)realloc(v14, v19);
    *a2 = v14;
    if (v14)
    {
      size_t v15 = a2[1];
      goto LABEL_16;
    }
LABEL_18:
    abort();
  }
LABEL_16:
  uint64_t result = memcpy(&v15[(void)v14], v12, v13);
  a2[1] += v13;
  return result;
}

uint64_t llvm::itanium_demangle::ModuleEntity::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *(void **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = v6 + 1;
  unint64_t v8 = *(void *)(a2 + 16);
  if (v6 + 1 > v8)
  {
    unint64_t v9 = v6 + 993;
    if (2 * v8 <= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = 2 * v8;
    }
    *(void *)(a2 + 16) = v10;
    uint64_t v5 = realloc(v5, v10);
    *(void *)a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = v6 + 1;
  }
  *(void *)(a2 + 8) = v7;
  *((unsigned char *)v5 + v6) = 64;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    size_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::ModuleEntity::getBaseName(llvm::itanium_demangle::ModuleEntity *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t llvm::itanium_demangle::MemberLikeFriendName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 9) > v7)
  {
    size_t v8 = (size_t)(v6 + 1001);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  uint64_t v11 = &v6[(void)v5];
  *(void *)uint64_t v11 = *(void *)"::friend ";
  v11[8] = 32;
  a2[1] += 9;
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v12 + 32))(v12, a2);
  if ((*(_WORD *)(v12 + 9) & 0xC0) != 0x40)
  {
    unint64_t v14 = *(uint64_t (**)(uint64_t, char **))(*(void *)v12 + 40);
    return v14(v12, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::MemberLikeFriendName::getBaseName(llvm::itanium_demangle::MemberLikeFriendName *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t llvm::itanium_demangle::NestedName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 2) > v7)
  {
    size_t v8 = (size_t)(v6 + 994);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  *(_WORD *)&v6[(void)v5] = 14906;
  a2[1] += 2;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    size_t v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::NestedName::getBaseName(llvm::itanium_demangle::NestedName *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::LocalName,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    size_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  unint64_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  v9[24] = 26;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A3788;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

uint64_t llvm::itanium_demangle::LocalName::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 2) > v7)
  {
    size_t v8 = (size_t)(v6 + 994);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      abort();
    }
    uint64_t v6 = a2[1];
  }
  *(_WORD *)&v6[(void)v5] = 14906;
  a2[1] += 2;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    size_t v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::ParameterPack::hasRHSComponentSlow(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(a1 + 24) > v2) {
      goto LABEL_3;
    }
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v6 = *(void *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if (!v6) {
    return 0;
  }
LABEL_3:
  uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8 * v2);
  unsigned int v4 = *(unsigned __int8 *)(v3 + 9);
  if ((v4 & 0xC0) == 0x80) {
    return (**(uint64_t (***)(uint64_t))v3)(v3);
  }
  else {
    return v4 < 0x40;
  }
}

uint64_t llvm::itanium_demangle::ParameterPack::hasArraySlow(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(a1 + 24) > v2) {
      goto LABEL_3;
    }
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v6 = *(void *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if (!v6) {
    return 0;
  }
LABEL_3:
  uint64_t v3 = *(unsigned char **)(*(void *)(a1 + 16) + 8 * v2);
  int v4 = v3[10] & 3;
  if (v4 == 2) {
    return (*(uint64_t (**)(void))(*(void *)v3 + 8))();
  }
  else {
    return v4 == 0;
  }
}

uint64_t llvm::itanium_demangle::ParameterPack::hasFunctionSlow(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(a1 + 24) > v2) {
      goto LABEL_3;
    }
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v6 = *(void *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if (!v6) {
    return 0;
  }
LABEL_3:
  uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8 * v2);
  int v4 = (*(unsigned __int16 *)(v3 + 9) >> 10) & 3;
  if (v4 == 2) {
    return (*(uint64_t (**)(void))(*(void *)v3 + 16))();
  }
  else {
    return v4 == 0;
  }
}

uint64_t llvm::itanium_demangle::ParameterPack::getSyntaxNode(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(result + 24) <= v2) {
      return result;
    }
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 24))();
  }
  unint64_t v2 = 0;
  uint64_t v3 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v3;
  if (v3) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 24))();
  }
  return result;
}

uint64_t llvm::itanium_demangle::ParameterPack::printLeft(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(result + 24) <= v2) {
      return result;
    }
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 32))();
  }
  unint64_t v2 = 0;
  uint64_t v3 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v3;
  if (v3) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 32))();
  }
  return result;
}

uint64_t llvm::itanium_demangle::ParameterPack::printRight(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 28) != -1)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 24);
    if (*(void *)(result + 24) <= v2) {
      return result;
    }
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 40))();
  }
  unint64_t v2 = 0;
  uint64_t v3 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v3;
  if (v3) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 16) + 8 * v2) + 40))();
  }
  return result;
}

char *llvm::itanium_demangle::TemplateArgs::printLeft(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  uint64_t v5 = *(char **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)(a2 + 16);
  if (v6 + 1 > v7)
  {
    size_t v8 = v6 + 993;
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    *(void *)(a2 + 16) = v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *(void *)a2 = v5;
    if (!v5) {
      goto LABEL_28;
    }
    uint64_t v6 = *(void *)(a2 + 8);
  }
  v5[v6] = 60;
  uint64_t v11 = *(void *)(a2 + 8) + 1;
  *(void *)(a2 + 8) = v11;
  if (*(void *)(a1 + 24))
  {
    uint64_t v12 = 0;
    char v13 = 1;
    while (1)
    {
      uint64_t v14 = v11;
      if ((v13 & 1) == 0)
      {
        unint64_t v15 = *(void *)(a2 + 16);
        unint64_t v16 = *(char **)a2;
        if (v11 + 2 <= v15)
        {
          uint64_t v19 = v11;
        }
        else
        {
          unint64_t v17 = 2 * v15;
          if (v17 <= v11 + 994) {
            size_t v18 = v11 + 994;
          }
          else {
            size_t v18 = v17;
          }
          *(void *)(a2 + 16) = v18;
          unint64_t v16 = (char *)realloc(v16, v18);
          *(void *)a2 = v16;
          if (!v16) {
            goto LABEL_28;
          }
          uint64_t v19 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v16[v19] = 8236;
        uint64_t v14 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v14;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 16) + 8 * v12), a2, 18, 0);
      if (v14 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v11;
        if (++v12 == *(void *)(a1 + 24)) {
          break;
        }
      }
      else
      {
        char v13 = 0;
        uint64_t v11 = *(void *)(a2 + 8);
        if (++v12 == *(void *)(a1 + 24)) {
          break;
        }
      }
    }
  }
  unint64_t v20 = *(void *)(a2 + 16);
  uint64_t result = *(char **)a2;
  if (v11 + 1 > v20)
  {
    unint64_t v22 = 2 * v20;
    if (v22 <= v11 + 993) {
      size_t v23 = v11 + 993;
    }
    else {
      size_t v23 = v22;
    }
    *(void *)(a2 + 16) = v23;
    uint64_t result = (char *)realloc(result, v23);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v11 = *(void *)(a2 + 8);
      goto LABEL_27;
    }
LABEL_28:
    abort();
  }
LABEL_27:
  result[v11] = 62;
  ++*(void *)(a2 + 8);
  *(_DWORD *)(a2 + 32) = v4;
  return result;
}

uint64_t llvm::itanium_demangle::NameWithTemplateArgs::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5, a2);
  if ((*(_WORD *)(v5 + 9) & 0xC0) != 0x40)
  {
    unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40);
    return v7(v5, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::NameWithTemplateArgs::getBaseName(llvm::itanium_demangle::NameWithTemplateArgs *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48))();
}

void *llvm::itanium_demangle::TemplateArgumentPack::printLeft(void *result, char **a2)
{
  if (result[3])
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = (uint64_t)a2[1];
    char v6 = 1;
    do
    {
      while (1)
      {
        uint64_t v7 = v5;
        if ((v6 & 1) == 0)
        {
          unint64_t v8 = (unint64_t)a2[2];
          unint64_t v9 = *a2;
          if (v5 + 2 <= v8)
          {
            uint64_t v12 = v5;
          }
          else
          {
            unint64_t v10 = 2 * v8;
            if (v10 <= v5 + 994) {
              size_t v11 = v5 + 994;
            }
            else {
              size_t v11 = v10;
            }
            a2[2] = (char *)v11;
            unint64_t v9 = (char *)realloc(v9, v11);
            *a2 = v9;
            if (!v9) {
              abort();
            }
            uint64_t v12 = (uint64_t)a2[1];
          }
          *(_WORD *)&v9[v12] = 8236;
          uint64_t v7 = (uint64_t)(a2[1] + 2);
          a2[1] = (char *)v7;
        }
        uint64_t result = llvm::itanium_demangle::Node::printAsOperand(*(void *)(v3[2] + 8 * v4), (uint64_t)a2, 18, 0);
        if ((char *)v7 != a2[1]) {
          break;
        }
        a2[1] = (char *)v5;
        if (++v4 == v3[3]) {
          return result;
        }
      }
      char v6 = 0;
      uint64_t v5 = (uint64_t)a2[1];
      ++v4;
    }
    while (v4 != v3[3]);
  }
  return result;
}

uint64_t llvm::itanium_demangle::TemplateParamQualifiedArg::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  if ((*(_WORD *)(v3 + 9) & 0xC0) != 0x40)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v5(v3, a2);
  }
  return result;
}

void *llvm::itanium_demangle::EnableIfAttr::printLeft(uint64_t a1, void **a2)
{
  uint64_t v4 = (char *)*a2;
  uint64_t v5 = (char *)a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 12) > v6)
  {
    size_t v7 = (size_t)(v5 + 1004);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (void *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_28;
    }
    uint64_t v5 = (char *)a2[1];
  }
  unint64_t v10 = &v5[(void)v4];
  *(void *)unint64_t v10 = *(void *)" [enable_if:";
  *((_DWORD *)v10 + 2) = 979790175;
  uint64_t v11 = (uint64_t)a2[1] + 12;
  a2[1] = (void *)v11;
  if (*(void *)(a1 + 24))
  {
    uint64_t v12 = 0;
    char v13 = 1;
    while (1)
    {
      uint64_t v14 = v11;
      if ((v13 & 1) == 0)
      {
        unint64_t v15 = (unint64_t)a2[2];
        unint64_t v16 = (char *)*a2;
        if (v11 + 2 <= v15)
        {
          uint64_t v19 = v11;
        }
        else
        {
          unint64_t v17 = 2 * v15;
          if (v17 <= v11 + 994) {
            size_t v18 = v11 + 994;
          }
          else {
            size_t v18 = v17;
          }
          a2[2] = (void *)v18;
          unint64_t v16 = (char *)realloc(v16, v18);
          *a2 = v16;
          if (!v16) {
            goto LABEL_28;
          }
          uint64_t v19 = (uint64_t)a2[1];
        }
        *(_WORD *)&v16[v19] = 8236;
        uint64_t v14 = (uint64_t)a2[1] + 2;
        a2[1] = (void *)v14;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 16) + 8 * v12), (uint64_t)a2, 18, 0);
      if ((void *)v14 == a2[1])
      {
        a2[1] = (void *)v11;
        if (++v12 == *(void *)(a1 + 24)) {
          break;
        }
      }
      else
      {
        char v13 = 0;
        uint64_t v11 = (uint64_t)a2[1];
        if (++v12 == *(void *)(a1 + 24)) {
          break;
        }
      }
    }
  }
  uint64_t v20 = v11 + 1;
  unint64_t v21 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v11 + 1 > v21)
  {
    unint64_t v23 = 2 * v21;
    if (v23 <= v11 + 993) {
      size_t v24 = v11 + 993;
    }
    else {
      size_t v24 = v23;
    }
    a2[2] = (void *)v24;
    uint64_t result = realloc(result, v24);
    *a2 = result;
    if (result)
    {
      uint64_t v11 = (uint64_t)a2[1];
      uint64_t v20 = v11 + 1;
      goto LABEL_27;
    }
LABEL_28:
    abort();
  }
LABEL_27:
  a2[1] = (void *)v20;
  *((unsigned char *)result + v11) = 93;
  return result;
}

uint64_t llvm::itanium_demangle::FunctionEncoding::hasRHSComponentSlow()
{
  return 1;
}

uint64_t llvm::itanium_demangle::FunctionEncoding::hasFunctionSlow()
{
  return 1;
}

uint64_t llvm::itanium_demangle::FunctionEncoding::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4, a2);
    uint64_t v5 = *(void *)(a1 + 16);
    unsigned int v6 = *(unsigned __int8 *)(v5 + 9);
    if ((v6 & 0xC0) == 0x80)
    {
      if ((**(uint64_t (***)(uint64_t, uint64_t))v5)(v5, a2)) {
        goto LABEL_13;
      }
    }
    else if (v6 < 0x40)
    {
      goto LABEL_13;
    }
    size_t v7 = *(void **)a2;
    uint64_t v8 = *(void *)(a2 + 8);
    unint64_t v9 = *(void *)(a2 + 16);
    if (v8 + 1 > v9)
    {
      size_t v10 = v8 + 993;
      unint64_t v11 = 2 * v9;
      if (v11 <= v10) {
        size_t v12 = v10;
      }
      else {
        size_t v12 = v11;
      }
      *(void *)(a2 + 16) = v12;
      size_t v7 = realloc(v7, v12);
      *(void *)a2 = v7;
      if (!v7) {
        abort();
      }
      uint64_t v8 = *(void *)(a2 + 8);
    }
    *((unsigned char *)v7 + v8) = 32;
    ++*(void *)(a2 + 8);
  }
LABEL_13:
  uint64_t v13 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 32))(v13, a2);
  if ((*(_WORD *)(v13 + 9) & 0xC0) != 0x40)
  {
    unint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 40);
    return v15(v13, a2);
  }
  return result;
}

char *llvm::itanium_demangle::FunctionEncoding::printRight(uint64_t a1, uint64_t a2)
{
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_85;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  v4[v5] = 40;
  uint64_t v10 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 40))
  {
    uint64_t v11 = 0;
    char v12 = 1;
    while (1)
    {
      uint64_t v13 = v10;
      if ((v12 & 1) == 0)
      {
        unint64_t v14 = *(void *)(a2 + 16);
        unint64_t v15 = *(char **)a2;
        if (v10 + 2 <= v14)
        {
          uint64_t v18 = v10;
        }
        else
        {
          unint64_t v16 = 2 * v14;
          if (v16 <= v10 + 994) {
            size_t v17 = v10 + 994;
          }
          else {
            size_t v17 = v16;
          }
          *(void *)(a2 + 16) = v17;
          unint64_t v15 = (char *)realloc(v15, v17);
          *(void *)a2 = v15;
          if (!v15) {
            goto LABEL_85;
          }
          uint64_t v18 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v15[v18] = 8236;
        uint64_t v13 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v13;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 32) + 8 * v11), a2, 18, 0);
      if (v13 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v10;
        if (++v11 == *(void *)(a1 + 40)) {
          break;
        }
      }
      else
      {
        char v12 = 0;
        uint64_t v10 = *(void *)(a2 + 8);
        if (++v11 == *(void *)(a1 + 40)) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v19 = v10 + 1;
  unint64_t v20 = *(void *)(a2 + 16);
  unint64_t v21 = *(char **)a2;
  if (v10 + 1 > v20)
  {
    unint64_t v22 = 2 * v20;
    if (v22 <= v10 + 993) {
      size_t v23 = v10 + 993;
    }
    else {
      size_t v23 = v22;
    }
    *(void *)(a2 + 16) = v23;
    unint64_t v21 = (char *)realloc(v21, v23);
    *(void *)a2 = v21;
    if (!v21) {
      goto LABEL_85;
    }
    uint64_t v10 = *(void *)(a2 + 8);
    uint64_t v19 = v10 + 1;
  }
  *(void *)(a2 + 8) = v19;
  v21[v10] = 41;
  uint64_t result = *(char **)(a1 + 16);
  if (result) {
    uint64_t result = (char *)(*(uint64_t (**)(char *, uint64_t))(*(void *)result + 40))(result, a2);
  }
  int v25 = *(_DWORD *)(a1 + 64);
  if (v25)
  {
    uint64_t result = *(char **)a2;
    uint64_t v26 = *(void *)(a2 + 8);
    unint64_t v27 = *(void *)(a2 + 16);
    if (v26 + 6 > v27)
    {
      size_t v28 = v26 + 998;
      unint64_t v29 = 2 * v27;
      if (v29 <= v28) {
        size_t v30 = v28;
      }
      else {
        size_t v30 = v29;
      }
      *(void *)(a2 + 16) = v30;
      uint64_t result = (char *)realloc(result, v30);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_85;
      }
      uint64_t v26 = *(void *)(a2 + 8);
    }
    size_t v31 = &result[v26];
    *((_WORD *)v31 + 2) = 29811;
    *(_DWORD *)size_t v31 = 1852793632;
    *(void *)(a2 + 8) += 6;
    int v25 = *(_DWORD *)(a1 + 64);
  }
  if ((v25 & 2) != 0)
  {
    uint64_t result = *(char **)a2;
    uint64_t v32 = *(void *)(a2 + 8);
    unint64_t v33 = *(void *)(a2 + 16);
    if (v32 + 9 > v33)
    {
      size_t v34 = v32 + 1001;
      unint64_t v35 = 2 * v33;
      if (v35 <= v34) {
        size_t v36 = v34;
      }
      else {
        size_t v36 = v35;
      }
      *(void *)(a2 + 16) = v36;
      uint64_t result = (char *)realloc(result, v36);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_85;
      }
      uint64_t v32 = *(void *)(a2 + 8);
    }
    unint64_t v37 = &result[v32];
    *(void *)unint64_t v37 = *(void *)" volatile";
    v37[8] = 101;
    *(void *)(a2 + 8) += 9;
    int v25 = *(_DWORD *)(a1 + 64);
  }
  if ((v25 & 4) != 0)
  {
    uint64_t result = *(char **)a2;
    uint64_t v38 = *(void *)(a2 + 8);
    unint64_t v39 = *(void *)(a2 + 16);
    if (v38 + 9 > v39)
    {
      size_t v40 = v38 + 1001;
      unint64_t v41 = 2 * v39;
      if (v41 <= v40) {
        size_t v42 = v40;
      }
      else {
        size_t v42 = v41;
      }
      *(void *)(a2 + 16) = v42;
      uint64_t result = (char *)realloc(result, v42);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_85;
      }
      uint64_t v38 = *(void *)(a2 + 8);
    }
    size_t v43 = &result[v38];
    *(void *)size_t v43 = *(void *)" restrict";
    v43[8] = 116;
    *(void *)(a2 + 8) += 9;
  }
  int v44 = *(unsigned __int8 *)(a1 + 68);
  if (v44 == 2)
  {
    uint64_t result = *(char **)a2;
    uint64_t v51 = *(void *)(a2 + 8);
    unint64_t v52 = *(void *)(a2 + 16);
    if (v51 + 3 > v52)
    {
      size_t v53 = v51 + 995;
      unint64_t v54 = 2 * v52;
      if (v54 <= v53) {
        size_t v55 = v53;
      }
      else {
        size_t v55 = v54;
      }
      *(void *)(a2 + 16) = v55;
      uint64_t result = (char *)realloc(result, v55);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_85;
      }
      uint64_t v51 = *(void *)(a2 + 8);
    }
    size_t v56 = &result[v51];
    v56[2] = 38;
    *(_WORD *)size_t v56 = 9760;
    uint64_t v50 = 3;
    goto LABEL_69;
  }
  if (v44 == 1)
  {
    uint64_t result = *(char **)a2;
    uint64_t v45 = *(void *)(a2 + 8);
    unint64_t v46 = *(void *)(a2 + 16);
    if (v45 + 2 > v46)
    {
      size_t v47 = v45 + 994;
      unint64_t v48 = 2 * v46;
      if (v48 <= v47) {
        size_t v49 = v47;
      }
      else {
        size_t v49 = v48;
      }
      *(void *)(a2 + 16) = v49;
      uint64_t result = (char *)realloc(result, v49);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_85;
      }
      uint64_t v45 = *(void *)(a2 + 8);
    }
    *(_WORD *)&result[v45] = 9760;
    uint64_t v50 = 2;
LABEL_69:
    *(void *)(a2 + 8) += v50;
  }
  uint64_t v57 = *(void *)(a1 + 48);
  if (v57)
  {
    uint64_t result = (char *)(*(uint64_t (**)(void, uint64_t))(*(void *)v57 + 32))(*(void *)(a1 + 48), a2);
    if ((*(_WORD *)(v57 + 9) & 0xC0) != 0x40) {
      uint64_t result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v57 + 40))(v57, a2);
    }
  }
  if (*(void *)(a1 + 56))
  {
    uint64_t v58 = *(char **)a2;
    uint64_t v59 = *(void *)(a2 + 8);
    unint64_t v60 = *(void *)(a2 + 16);
    if (v59 + 10 <= v60) {
      goto LABEL_80;
    }
    size_t v61 = v59 + 1002;
    unint64_t v62 = 2 * v60;
    if (v62 <= v61) {
      size_t v63 = v61;
    }
    else {
      size_t v63 = v62;
    }
    *(void *)(a2 + 16) = v63;
    uint64_t v58 = (char *)realloc(v58, v63);
    *(void *)a2 = v58;
    if (v58)
    {
      uint64_t v59 = *(void *)(a2 + 8);
LABEL_80:
      uint64_t v64 = &v58[v59];
      *(void *)uint64_t v64 = *(void *)" requires ";
      *((_WORD *)v64 + 4) = 8307;
      *(void *)(a2 + 8) += 10;
      uint64_t v65 = *(void *)(a1 + 56);
      uint64_t result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v65 + 32))(v65, a2);
      if ((*(_WORD *)(v65 + 9) & 0xC0) != 0x40)
      {
        int64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v65 + 40);
        return (char *)v66(v65, a2);
      }
      return result;
    }
LABEL_85:
    abort();
  }
  return result;
}

char *llvm::itanium_demangle::DotSuffix::printLeft(void *a1, char **a2)
{
  uint64_t v4 = a1[2];
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 2) > v7)
  {
    size_t v8 = (size_t)(v6 + 994);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      goto LABEL_24;
    }
    uint64_t v6 = a2[1];
  }
  *(_WORD *)&v6[(void)v5] = 10272;
  uint64_t v11 = (uint64_t)(a2[1] + 2);
  a2[1] = (char *)v11;
  size_t v12 = a1[4];
  if (v12)
  {
    uint64_t v13 = (const void *)a1[3];
    size_t v14 = v11 + v12;
    size_t v15 = (size_t)a2[2];
    unint64_t v16 = *a2;
    if (v11 + v12 > v15)
    {
      if (2 * v15 <= v14 + 992) {
        size_t v17 = v14 + 992;
      }
      else {
        size_t v17 = 2 * v15;
      }
      a2[2] = (char *)v17;
      unint64_t v16 = (char *)realloc(v16, v17);
      *a2 = v16;
      if (!v16) {
        goto LABEL_24;
      }
      uint64_t v11 = (uint64_t)a2[1];
    }
    memcpy(&v16[v11], v13, v12);
    uint64_t v11 = (uint64_t)&a2[1][v12];
    a2[1] = (char *)v11;
  }
  unint64_t v18 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v11 + 1 > v18)
  {
    size_t v20 = v11 + 993;
    unint64_t v21 = 2 * v18;
    if (v21 <= v20) {
      size_t v22 = v20;
    }
    else {
      size_t v22 = v21;
    }
    a2[2] = (char *)v22;
    uint64_t result = (char *)realloc(result, v22);
    *a2 = result;
    if (result)
    {
      uint64_t v11 = (uint64_t)a2[1];
      goto LABEL_23;
    }
LABEL_24:
    abort();
  }
LABEL_23:
  result[v11] = 41;
  ++a2[1];
  return result;
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseFunctionType(void *a1, size_t a2)
{
  uint64_t v4 = (unsigned char *)*a1;
  uint64_t v3 = (unsigned char *)a1[1];
  if ((unsigned char *)*a1 == v3 || *v4 != 114)
  {
    int v5 = 0;
    if (v4 == v3) {
      goto LABEL_4;
    }
  }
  else
  {
    *a1 = ++v4;
    int v5 = 4;
    if (v4 == v3)
    {
LABEL_4:
      uint64_t v4 = v3;
      goto LABEL_12;
    }
  }
  if (*v4 == 86)
  {
    *a1 = ++v4;
    v5 |= 2u;
  }
  if (v4 == v3) {
    goto LABEL_13;
  }
  if (*v4 == 75)
  {
    *a1 = ++v4;
    v5 |= 1u;
    if ((unint64_t)(v3 - v4) < 2) {
      goto LABEL_13;
    }
    goto LABEL_15;
  }
LABEL_12:
  if ((unint64_t)(v3 - v4) < 2)
  {
LABEL_13:
    uint64_t v6 = 0;
    goto LABEL_35;
  }
LABEL_15:
  if (*(_WORD *)v4 == 28484)
  {
    *a1 = v4 + 2;
    size_t v17 = (void *)a1[613];
    uint64_t v18 = v17[1];
    if ((unint64_t)(v18 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      uint64_t v19 = malloc(0x1000uLL);
      if (!v19) {
        goto LABEL_83;
      }
      uint64_t v18 = 0;
      *uint64_t v19 = v17;
      v19[1] = 0;
      size_t v17 = v19;
      a1[613] = v19;
    }
    v17[1] = v18 + 32;
    size_t v20 = (char *)v17 + v18;
    uint64_t v6 = v20 + 16;
    v20[24] = 8;
    *(_WORD *)(v20 + 25) = *(_WORD *)(v20 + 25) & 0xF000 | 0x540;
    *((void *)v20 + 2) = &unk_1EC9A3628;
    *((void *)v20 + 4) = "noexcept";
    *((void *)v20 + 5) = 8;
    goto LABEL_35;
  }
  if (*(_WORD *)v4 != 20292)
  {
    if (*(_WORD *)v4 == 30532)
    {
      unint64_t v7 = v4 + 2;
      *a1 = v7;
      uint64_t v8 = (uint64_t)(a1[3] - a1[2]) >> 3;
      unint64_t v9 = (char *)(a1 + 5);
      while (v7 == v3 || *v7 != 69)
      {
        if (!v12) {
          return;
        }
        uint64_t v13 = v12;
        uint64_t v11 = (char *)a1[3];
        if (v11 == (char *)a1[4])
        {
          size_t v14 = (char *)a1[2];
          int64_t v15 = v11 - v14;
          if (v14 == v9)
          {
            unint64_t v16 = (char *)malloc(2 * (v11 - v14));
            if (!v16) {
LABEL_82:
            }
              abort();
            size_t v10 = v16;
            if (v11 != v9) {
              memcpy(v16, a1 + 5, v15);
            }
            a1[2] = v10;
          }
          else
          {
            size_t v10 = (char *)realloc(v14, 2 * (v11 - v14));
            a1[2] = v10;
            if (!v10) {
              goto LABEL_82;
            }
          }
          uint64_t v11 = &v10[8 * (v15 >> 3)];
          a1[4] = &v10[8 * (v15 >> 2)];
        }
        a1[3] = v11 + 8;
        *(void *)uint64_t v11 = v13;
        unint64_t v7 = (unsigned char *)*a1;
        uint64_t v3 = (unsigned char *)a1[1];
      }
      *a1 = v7 + 1;
      uint64_t v53 = v52;
      unint64_t v54 = (void *)a1[613];
      uint64_t v55 = v54[1];
      if ((unint64_t)(v55 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        size_t v56 = malloc(0x1000uLL);
        if (!v56) {
          goto LABEL_83;
        }
        uint64_t v55 = 0;
        *size_t v56 = v54;
        v56[1] = 0;
        unint64_t v54 = v56;
        a1[613] = v56;
      }
      v54[1] = v55 + 32;
      uint64_t v57 = (char *)v54 + v55;
      uint64_t v6 = v57 + 16;
      v57[24] = 18;
      *(_WORD *)(v57 + 25) = *(_WORD *)(v57 + 25) & 0xF000 | 0x540;
      *((void *)v57 + 2) = &unk_1EC9A2D38;
      *((void *)v57 + 4) = v51;
      *((void *)v57 + 5) = v53;
      goto LABEL_35;
    }
    goto LABEL_13;
  }
  *a1 = v4 + 2;
  if (!v35) {
    return;
  }
  size_t v36 = (unsigned char *)*a1;
  if (*a1 == a1[1] || *v36 != 69) {
    return;
  }
  uint64_t v37 = v35;
  *a1 = v36 + 1;
  uint64_t v38 = (void *)a1[613];
  uint64_t v39 = v38[1];
  if ((unint64_t)(v39 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    size_t v40 = malloc(0x1000uLL);
    if (!v40) {
      goto LABEL_83;
    }
    uint64_t v39 = 0;
    *size_t v40 = v38;
    v40[1] = 0;
    uint64_t v38 = v40;
    a1[613] = v40;
  }
  v38[1] = v39 + 32;
  unint64_t v41 = (char *)v38 + v39;
  uint64_t v6 = v41 + 16;
  v41[24] = 17;
  *(_WORD *)(v41 + 25) = *(_WORD *)(v41 + 25) & 0xF000 | 0x540;
  *((void *)v41 + 2) = &unk_1EC9A2188;
  *((void *)v41 + 4) = v37;
LABEL_35:
  unint64_t v21 = (unsigned char *)*a1;
  size_t v22 = (unsigned char *)a1[1];
  if ((unint64_t)&v22[-*a1] >= 2 && *(_WORD *)v21 == 30788)
  {
    v21 += 2;
    *a1 = v21;
    if (v21 == v22) {
      return;
    }
  }
  else if (v21 == v22)
  {
    return;
  }
  if (*v21 == 70)
  {
    *a1 = v21 + 1;
    if (v21 + 1 != v22 && v21[1] == 89) {
      *a1 = v21 + 2;
    }
    if (v23)
    {
      uint64_t v58 = v23;
      uint64_t v59 = (uint64_t)(a1[3] - a1[2]) >> 3;
      size_t v24 = (char *)(a1 + 5);
      int v25 = (_WORD *)*a1;
      uint64_t v26 = a1[1];
      if (*a1 != v26) {
        goto LABEL_46;
      }
LABEL_52:
      while (1)
      {
        if ((unint64_t)(v26 - (void)v25) >= 2)
        {
          if (*v25 == 17746)
          {
            char v42 = 1;
            uint64_t v43 = 2;
            goto LABEL_74;
          }
          if (*v25 == 17743) {
            break;
          }
        }
        if (!v30) {
          return;
        }
        uint64_t v31 = v30;
        unint64_t v29 = (char *)a1[3];
        if (v29 == (char *)a1[4])
        {
          uint64_t v32 = (char *)a1[2];
          int64_t v33 = v29 - v32;
          if (v32 == v24)
          {
            size_t v34 = (char *)malloc(2 * (v29 - v32));
            if (!v34) {
              goto LABEL_82;
            }
            size_t v28 = v34;
            if (v29 != v24) {
              memcpy(v34, a1 + 5, v33);
            }
            a1[2] = v28;
          }
          else
          {
            size_t v28 = (char *)realloc(v32, 2 * (v29 - v32));
            a1[2] = v28;
            if (!v28) {
              goto LABEL_82;
            }
          }
          unint64_t v29 = &v28[8 * (v33 >> 3)];
          a1[4] = &v28[8 * (v33 >> 2)];
        }
        a1[3] = v29 + 8;
        *(void *)unint64_t v29 = v31;
        int v25 = (_WORD *)*a1;
        uint64_t v26 = a1[1];
        if (*a1 != v26)
        {
LABEL_46:
          while (1)
          {
            int v27 = *(unsigned __int8 *)v25;
            if (v27 != 118) {
              break;
            }
            *a1 = (char *)v25 + 1;
            int v25 = (_WORD *)*a1;
            uint64_t v26 = a1[1];
            if (*a1 == v26) {
              goto LABEL_52;
            }
          }
          if (v27 == 69)
          {
            char v42 = 0;
            uint64_t v43 = 1;
            goto LABEL_74;
          }
        }
      }
      uint64_t v43 = 2;
      char v42 = 2;
LABEL_74:
      *a1 = (char *)v25 + v43;
      uint64_t v46 = v45;
      size_t v47 = (void *)a1[613];
      uint64_t v48 = v47[1];
      if ((unint64_t)(v48 - 4016) > 0xFFFFFFFFFFFFF00FLL) {
        goto LABEL_77;
      }
      size_t v49 = malloc(0x1000uLL);
      if (v49)
      {
        uint64_t v48 = 0;
        *size_t v49 = v47;
        v49[1] = 0;
        size_t v47 = v49;
        a1[613] = v49;
LABEL_77:
        v47[1] = v48 + 64;
        uint64_t v50 = (char *)v47 + v48;
        v50[24] = 16;
        *(_WORD *)(v50 + 25) = *(_WORD *)(v50 + 25) & 0xF000 | 0x100;
        *((void *)v50 + 2) = &unk_1EC9A2080;
        *((void *)v50 + 4) = v58;
        *((void *)v50 + 5) = v44;
        *((void *)v50 + 6) = v46;
        *((_DWORD *)v50 + 14) = v5;
        v50[60] = v42;
        *((void *)v50 + 8) = v6;
        return;
      }
LABEL_83:
      std::terminate();
    }
  }
}

uint64_t llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseQualifiedType(unsigned __int8 **a1)
{
  uint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  if (*a1 == v2) {
    goto LABEL_7;
  }
  int v4 = *v3;
  if (v4 == 114)
  {
    *a1 = ++v3;
    int v6 = 4;
    if (v3 == v2) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  if (v4 != 85)
  {
LABEL_7:
    int v6 = 0;
    if (v3 == v2) {
      goto LABEL_15;
    }
LABEL_10:
    if (*v3 == 86)
    {
      *a1 = ++v3;
      v6 |= 2u;
    }
    if (v3 != v2 && *v3 == 75)
    {
      *a1 = v3 + 1;
      v6 |= 1u;
    }
LABEL_15:
    if (v5 && v6)
    {
      unint64_t v7 = a1[613];
      uint64_t v8 = *((void *)v7 + 1);
      if ((unint64_t)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        unint64_t v9 = (unsigned __int8 *)malloc(0x1000uLL);
        if (!v9) {
          goto LABEL_59;
        }
        uint64_t v8 = 0;
        *(void *)unint64_t v9 = v7;
        *((void *)v9 + 1) = 0;
        unint64_t v7 = v9;
        a1[613] = v9;
      }
      *((void *)v7 + 1) = v8 + 32;
      size_t v10 = (char *)&v7[v8];
      __int16 v11 = *(_WORD *)(v5 + 9);
      v10[24] = 3;
      *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | v11 & 0xFC0;
      *((void *)v10 + 2) = &unk_1EC9A3680;
      *((_DWORD *)v10 + 7) = v6;
      *((void *)v10 + 4) = v5;
      return (uint64_t)(v10 + 16);
    }
    return v5;
  }
  *a1 = v3 + 1;
  if (v2 == v3 + 1) {
    return 0;
  }
  if (v3[1] - 58 < 0xFFFFFFF6) {
    return 0;
  }
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  do
  {
    unint64_t v15 = v14;
    uint64_t v16 = v13;
    size_t v17 = &v3[v13];
    uint64_t v18 = &v3[v13 + 2];
    *a1 = v18;
    uint64_t v19 = (char)v17[1];
    unint64_t v14 = v19 + 10 * v14 - 48;
    if (v18 == v2)
    {
      uint64_t v21 = (uint64_t)v2;
      if (!v14) {
        goto LABEL_28;
      }
      return 0;
    }
    unsigned int v20 = *v18 - 48;
    uint64_t v13 = v16 + 1;
  }
  while (v20 <= 9);
  uint64_t v21 = (uint64_t)&v3[v13 + 1];
  if ((unint64_t)&v2[-v21] < v14) {
    return 0;
  }
LABEL_28:
  size_t v22 = (unsigned __int8 *)(v21 + v14);
  *a1 = (unsigned __int8 *)(v21 + v14);
  if (!v14) {
    return 0;
  }
  if (v14 < 9 || (*(void *)v21 == 0x746F7270636A626FLL ? (BOOL v23 = *(unsigned char *)(v21 + 8) == 111) : (BOOL v23 = 0), !v23))
  {
    if (v2 == v22 || *v22 != 73)
    {
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = v24;
      if (!v24) {
        return 0;
      }
    }
    if (!v26) {
      return 0;
    }
    uint64_t v27 = v26;
    size_t v28 = a1[613];
    uint64_t v29 = *((void *)v28 + 1);
    if ((unint64_t)(v29 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
    {
      uint64_t v30 = (unsigned __int8 *)malloc(0x1000uLL);
      if (v30)
      {
        uint64_t v29 = 0;
        *(void *)uint64_t v30 = v28;
        *((void *)v30 + 1) = 0;
        size_t v28 = v30;
        a1[613] = v30;
        goto LABEL_43;
      }
LABEL_59:
      std::terminate();
    }
LABEL_43:
    *((void *)v28 + 1) = v29 + 48;
    uint64_t v31 = (char *)&v28[v29];
    v31[24] = 2;
    *(_WORD *)(v31 + 25) = *(_WORD *)(v31 + 25) & 0xF000 | 0x540;
    *((void *)v31 + 2) = &unk_1EC9A2B28;
    *((void *)v31 + 4) = v27;
    *((void *)v31 + 5) = v21;
    *((void *)v31 + 6) = v14;
    *((void *)v31 + 7) = v25;
    return (uint64_t)(v31 + 16);
  }
  uint64_t v32 = &v3[v16 + 11];
  uint64_t v33 = (uint64_t)&v3[10 * v15 - 46 + v16 + v19];
  *a1 = v32;
  a1[1] = (unsigned __int8 *)v33;
  if (v14 == 9 || *v32 - 58 < 0xFFFFFFF6) {
    goto LABEL_51;
  }
  unint64_t v34 = 0;
  uint64_t v35 = v17 + 12;
  uint64_t v36 = 10 * v15;
  uint64_t v37 = v36 + v19 - 58;
  while (1)
  {
    *a1 = v35;
    unint64_t v34 = (char)*(v35 - 1) + 10 * v34 - 48;
    if (!v37) {
      break;
    }
    uint64_t v38 = v35 + 1;
    unsigned int v39 = *v35 - 48;
    --v37;
    ++v35;
    if (v39 > 9)
    {
      uint64_t v33 = (uint64_t)(v38 - 1);
      break;
    }
  }
  if ((unint64_t)&v3[v19 - 46 + v36 - v33 + v16] < v34)
  {
LABEL_51:
    *a1 = v22;
    a1[1] = v2;
    return 0;
  }
  *a1 = v22;
  a1[1] = v2;
  if (!v34) {
    return 0;
  }
  if (!v40) {
    return 0;
  }
  uint64_t v41 = v40;
  char v42 = a1[613];
  uint64_t v43 = *((void *)v42 + 1);
  if ((unint64_t)(v43 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    int v44 = (unsigned __int8 *)malloc(0x1000uLL);
    if (!v44) {
      goto LABEL_59;
    }
    uint64_t v43 = 0;
    *(void *)int v44 = v42;
    *((void *)v44 + 1) = 0;
    char v42 = v44;
    a1[613] = v44;
  }
  *((void *)v42 + 1) = v43 + 48;
  uint64_t v45 = (char *)&v42[v43];
  v45[24] = 11;
  *(_WORD *)(v45 + 25) = *(_WORD *)(v45 + 25) & 0xF000 | 0x540;
  *((void *)v45 + 2) = &unk_1EC9A2398;
  *((void *)v45 + 4) = v41;
  *((void *)v45 + 5) = v33;
  *((void *)v45 + 6) = v34;
  return (uint64_t)(v45 + 16);
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::TransformedType,std::string_view &,llvm::itanium_demangle::Node *&>(uint64_t a1, __n128 *a2, uint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 48;
  unint64_t v9 = (char *)v5 + v6;
  uint64_t v10 = *a3;
  v9[24] = 7;
  __int16 v11 = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A2868;
  __n128 result = *a2;
  *(_WORD *)(v9 + 25) = v11;
  *((__n128 *)v9 + 2) = result;
  *((void *)v9 + 6) = v10;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::BinaryFPType,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  unint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 31;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A1F78;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::BitIntType,llvm::itanium_demangle::Node *&,BOOL &>(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  uint64_t v9 = (char *)v5 + v6;
  __n128 result = v9 + 16;
  uint64_t v11 = *a2;
  v9[24] = 32;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A1B00;
  *((void *)v9 + 4) = v11;
  v9[40] = a3 != 0;
  return result;
}

__n128 llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PostfixQualifiedType,llvm::itanium_demangle::Node *&,std::string_view &>(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 48;
  uint64_t v9 = (char *)v5 + v6;
  uint64_t v10 = *a2;
  v9[24] = 5;
  __int16 v11 = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A2E40;
  __n128 result = *a3;
  *(_WORD *)(v9 + 25) = v11;
  *((void *)v9 + 4) = v10;
  *(__n128 *)(v9 + 40) = result;
  return result;
}

void llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseVectorType(void *a1, size_t a2)
{
  uint64_t v3 = (_WORD *)*a1;
  unint64_t v2 = (unsigned __int8 *)a1[1];
  if ((unint64_t)&v2[-*a1] < 2 || *v3 != 30276) {
    return;
  }
  uint64_t v5 = v3 + 1;
  *a1 = v3 + 1;
  if (v2 == (unsigned __int8 *)(v3 + 1) || (char)*v5 < 49) {
    goto LABEL_16;
  }
  if (*v5 > 0x39u)
  {
    if (*v5 == 95)
    {
      *a1 = (char *)v3 + 3;
      if (!v8) {
        return;
      }
      uint64_t v9 = v8;
      uint64_t v10 = (void *)a1[613];
      uint64_t v11 = v10[1];
      if ((unint64_t)(v11 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
      {
        uint64_t v12 = malloc(0x1000uLL);
        if (!v12) {
          goto LABEL_40;
        }
        uint64_t v11 = 0;
        *uint64_t v12 = v10;
        v12[1] = 0;
        uint64_t v10 = v12;
        a1[613] = v12;
      }
      v10[1] = v11 + 32;
      uint64_t v13 = (char *)v10 + v11;
      v13[24] = 29;
      *(_WORD *)(v13 + 25) = *(_WORD *)(v13 + 25) & 0xF000 | 0x540;
      *((void *)v13 + 2) = &unk_1EC9A1DC0;
      *((void *)v13 + 4) = v9;
      *((void *)v13 + 5) = 0;
      return;
    }
LABEL_16:
    if (!v14) {
      return;
    }
    unint64_t v15 = (unsigned char *)*a1;
    if (*a1 == a1[1]) {
      return;
    }
    if (*v15 != 95) {
      return;
    }
    uint64_t v16 = v14;
    *a1 = v15 + 1;
    if (!v17) {
      return;
    }
    uint64_t v18 = v17;
    uint64_t v19 = (void *)a1[613];
    uint64_t v20 = v19[1];
    if ((unint64_t)(v20 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
    {
      uint64_t v21 = malloc(0x1000uLL);
      if (!v21) {
        goto LABEL_40;
      }
      uint64_t v20 = 0;
      *uint64_t v21 = v19;
      v21[1] = 0;
      uint64_t v19 = v21;
      a1[613] = v21;
    }
    v19[1] = v20 + 32;
    size_t v22 = (char *)v19 + v20;
    v22[24] = 29;
    *(_WORD *)(v22 + 25) = *(_WORD *)(v22 + 25) & 0xF000 | 0x540;
    *((void *)v22 + 2) = &unk_1EC9A1DC0;
    *((void *)v22 + 4) = v18;
    *((void *)v22 + 5) = v16;
    return;
  }
  uint64_t v6 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *v5 + 60) & 0x400) != 0)
  {
    BOOL v23 = (unsigned __int8 *)(v3 + 1);
    while (((char)*v23 & 0x80000000) == 0 && (*(_DWORD *)(v6 + 4 * *v23 + 60) & 0x400) != 0)
    {
      *a1 = ++v23;
      if (v23 == v2)
      {
        BOOL v23 = v2;
        break;
      }
    }
    uint64_t v7 = v23 - v5;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v7 = 0;
  }
  uint64_t v24 = (void *)a1[613];
  uint64_t v25 = v24[1];
  if ((unint64_t)(v25 - 4048) > 0xFFFFFFFFFFFFF00FLL) {
    goto LABEL_33;
  }
  uint64_t v26 = malloc(0x1000uLL);
  if (!v26) {
LABEL_40:
  }
    std::terminate();
  uint64_t v25 = 0;
  *uint64_t v26 = v24;
  v26[1] = 0;
  uint64_t v24 = v26;
  a1[613] = v26;
LABEL_33:
  v24[1] = v25 + 32;
  uint64_t v27 = (char *)v24 + v25;
  v27[24] = 8;
  *(_WORD *)(v27 + 25) = *(_WORD *)(v27 + 25) & 0xF000 | 0x540;
  *((void *)v27 + 2) = &unk_1EC9A3628;
  *((void *)v27 + 4) = v5;
  *((void *)v27 + 5) = v7;
  uint64_t v31 = v27 + 16;
  size_t v28 = (unsigned char *)*a1;
  uint64_t v29 = (unsigned char *)a1[1];
  if ((unsigned char *)*a1 != v29 && *v28 == 95)
  {
    *a1 = v28 + 1;
    if (v28 + 1 == v29 || v28[1] != 112)
    {
      if (v30) {
    }
      }
    else
    {
      *a1 = v28 + 2;
    }
  }
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::parseClassEnumType(void *a1)
{
  unint64_t v2 = (_WORD *)*a1;
  if (a1[1] - *a1 < 2uLL)
  {
LABEL_2:
  }
  switch(*v2)
  {
    case 0x7354:
      uint64_t v4 = "struct";
      uint64_t v5 = 6;
      *a1 = v2 + 1;
      if (!result) {
        return result;
      }
      break;
    case 0x7554:
      uint64_t v4 = "union";
      uint64_t v5 = 5;
      *a1 = v2 + 1;
      if (!result) {
        return result;
      }
      break;
    case 0x6554:
      uint64_t v4 = "enum";
      uint64_t v5 = 4;
      *a1 = v2 + 1;
      if (!result) {
        return result;
      }
      break;
    default:
      goto LABEL_2;
  }
  uint64_t v6 = result;
  uint64_t v7 = (void *)a1[613];
  uint64_t v8 = v7[1];
  if ((unint64_t)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v9 = malloc(0x1000uLL);
    if (!v9) {
      std::terminate();
    }
    uint64_t v8 = 0;
    *uint64_t v9 = v7;
    v9[1] = 0;
    uint64_t v7 = v9;
    a1[613] = v9;
  }
  v7[1] = v8 + 48;
  uint64_t v10 = (char *)v7 + v8;
  __n128 result = v10 + 16;
  v10[24] = 6;
  *(_WORD *)(v10 + 25) = *(_WORD *)(v10 + 25) & 0xF000 | 0x540;
  *((void *)v10 + 2) = &unk_1EC9A30A8;
  *((void *)v10 + 4) = v4;
  *((void *)v10 + 5) = v5;
  *((void *)v10 + 6) = v6;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PointerType,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  char v10 = *(_WORD *)(*a2 + 9);
  v7[24] = 12;
  *(_WORD *)(v7 + 25) = v10 & 0xC0 | 0x500 | *(_WORD *)(v7 + 25) & 0xF000;
  *((void *)v7 + 2) = &unk_1EC9A1E70;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ReferenceType,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::ReferenceKind>(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  uint64_t v9 = (char *)v5 + v6;
  __n128 result = v9 + 16;
  uint64_t v11 = *a2;
  char v12 = *(_WORD *)(*a2 + 9);
  v9[24] = 13;
  *(_WORD *)(v9 + 25) = v12 & 0xC0 | 0x500 | *(_WORD *)(v9 + 25) & 0xF000;
  *((void *)v9 + 2) = &unk_1EC9A24A0;
  *((void *)v9 + 4) = v11;
  *((_DWORD *)v9 + 10) = a3;
  v9[44] = 0;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PostfixQualifiedType,llvm::itanium_demangle::Node *&,char const(&)[9]>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 5;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2E40;
  *((void *)v7 + 4) = v9;
  *((void *)v7 + 5) = " complex";
  *((void *)v7 + 6) = 8;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PostfixQualifiedType,llvm::itanium_demangle::Node *&,char const(&)[11]>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL)
  {
    uint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 48;
  uint64_t v7 = (char *)v3 + v4;
  __n128 result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 5;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2E40;
  *((void *)v7 + 4) = v9;
  *((void *)v7 + 5) = " imaginary";
  *((void *)v7 + 6) = 10;
  return result;
}

char *llvm::itanium_demangle::NoexceptSpec::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 8 > v6)
  {
    size_t v7 = v5 + 1000;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_20;
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  *(void *)&v4[v5] = 0x7470656378656F6ELL;
  char v10 = *(char **)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = v11 + 8;
  *(void *)(a2 + 8) = v11 + 8;
  ++*(_DWORD *)(a2 + 32);
  uint64_t v13 = v11 + 9;
  unint64_t v14 = *(void *)(a2 + 16);
  if (v11 + 9 > v14)
  {
    if (2 * v14 <= v11 + 1001) {
      size_t v15 = v11 + 1001;
    }
    else {
      size_t v15 = 2 * v14;
    }
    *(void *)(a2 + 16) = v15;
    char v10 = (char *)realloc(v10, v15);
    *(void *)a2 = v10;
    if (!v10) {
      goto LABEL_20;
    }
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v13 = v12 + 1;
  }
  *(void *)(a2 + 8) = v13;
  v10[v12] = 40;
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), a2, 19, 0);
  --*(_DWORD *)(a2 + 32);
  __n128 result = *(char **)a2;
  uint64_t v17 = *(void *)(a2 + 8);
  uint64_t v18 = v17 + 1;
  unint64_t v19 = *(void *)(a2 + 16);
  if (v17 + 1 > v19)
  {
    unint64_t v20 = v17 + 993;
    if (2 * v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = 2 * v19;
    }
    *(void *)(a2 + 16) = v21;
    __n128 result = (char *)realloc(result, v21);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v18 = v17 + 1;
      goto LABEL_19;
    }
LABEL_20:
    abort();
  }
LABEL_19:
  *(void *)(a2 + 8) = v18;
  result[v17] = 41;
  return result;
}

char *llvm::itanium_demangle::DynamicExceptionSpec::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 + 5 > v6)
  {
    size_t v7 = v5 + 997;
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_34;
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  char v10 = &v4[v5];
  v10[4] = 119;
  *(_DWORD *)char v10 = 1869768820;
  uint64_t v11 = *(char **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  uint64_t v13 = v12 + 5;
  *(void *)(a2 + 8) = v12 + 5;
  ++*(_DWORD *)(a2 + 32);
  uint64_t v14 = v12 + 6;
  unint64_t v15 = *(void *)(a2 + 16);
  if (v12 + 6 > v15)
  {
    if (2 * v15 <= v12 + 998) {
      size_t v16 = v12 + 998;
    }
    else {
      size_t v16 = 2 * v15;
    }
    *(void *)(a2 + 16) = v16;
    uint64_t v11 = (char *)realloc(v11, v16);
    *(void *)a2 = v11;
    if (!v11) {
      goto LABEL_34;
    }
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = v13 + 1;
  }
  *(void *)(a2 + 8) = v14;
  v11[v13] = 40;
  uint64_t v17 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 24))
  {
    uint64_t v18 = 0;
    char v19 = 1;
    while (1)
    {
      uint64_t v20 = v17;
      if ((v19 & 1) == 0)
      {
        unint64_t v21 = *(void *)(a2 + 16);
        size_t v22 = *(char **)a2;
        if (v17 + 2 <= v21)
        {
          uint64_t v25 = v17;
        }
        else
        {
          unint64_t v23 = 2 * v21;
          if (v23 <= v17 + 994) {
            size_t v24 = v17 + 994;
          }
          else {
            size_t v24 = v23;
          }
          *(void *)(a2 + 16) = v24;
          size_t v22 = (char *)realloc(v22, v24);
          *(void *)a2 = v22;
          if (!v22) {
            goto LABEL_34;
          }
          uint64_t v25 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v22[v25] = 8236;
        uint64_t v20 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v20;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 16) + 8 * v18), a2, 18, 0);
      if (v20 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v17;
        if (++v18 == *(void *)(a1 + 24)) {
          break;
        }
      }
      else
      {
        char v19 = 0;
        uint64_t v17 = *(void *)(a2 + 8);
        if (++v18 == *(void *)(a1 + 24)) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v26 = v17 + 1;
  unint64_t v27 = *(void *)(a2 + 16);
  __n128 result = *(char **)a2;
  if (v17 + 1 > v27)
  {
    unint64_t v29 = 2 * v27;
    if (v29 <= v17 + 993) {
      size_t v30 = v17 + 993;
    }
    else {
      size_t v30 = v29;
    }
    *(void *)(a2 + 16) = v30;
    __n128 result = (char *)realloc(result, v30);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v26 = v17 + 1;
      goto LABEL_33;
    }
LABEL_34:
    abort();
  }
LABEL_33:
  *(void *)(a2 + 8) = v26;
  result[v17] = 41;
  return result;
}

uint64_t llvm::itanium_demangle::FunctionType::hasRHSComponentSlow()
{
  return 1;
}

uint64_t llvm::itanium_demangle::FunctionType::hasFunctionSlow()
{
  return 1;
}

void *llvm::itanium_demangle::FunctionType::printLeft(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  __n128 result = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = *(void *)(a2 + 16);
  if (v4 + 1 > v5)
  {
    size_t v6 = v4 + 993;
    unint64_t v7 = 2 * v5;
    if (v7 <= v6) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v7;
    }
    *(void *)(a2 + 16) = v8;
    __n128 result = realloc(result, v8);
    *(void *)a2 = result;
    if (!result) {
      abort();
    }
    uint64_t v4 = *(void *)(a2 + 8);
  }
  *((unsigned char *)result + v4) = 32;
  ++*(void *)(a2 + 8);
  return result;
}

char *llvm::itanium_demangle::FunctionType::printRight(uint64_t a1, uint64_t a2)
{
  ++*(_DWORD *)(a2 + 32);
  uint64_t v4 = *(char **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = v5 + 1;
  unint64_t v7 = *(void *)(a2 + 16);
  if (v5 + 1 > v7)
  {
    unint64_t v8 = v5 + 993;
    if (2 * v7 <= v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = 2 * v7;
    }
    *(void *)(a2 + 16) = v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_80;
    }
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a2 + 8) = v6;
  v4[v5] = 40;
  uint64_t v10 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 32))
  {
    uint64_t v11 = 0;
    char v12 = 1;
    while (1)
    {
      uint64_t v13 = v10;
      if ((v12 & 1) == 0)
      {
        unint64_t v14 = *(void *)(a2 + 16);
        unint64_t v15 = *(char **)a2;
        if (v10 + 2 <= v14)
        {
          uint64_t v18 = v10;
        }
        else
        {
          unint64_t v16 = 2 * v14;
          if (v16 <= v10 + 994) {
            size_t v17 = v10 + 994;
          }
          else {
            size_t v17 = v16;
          }
          *(void *)(a2 + 16) = v17;
          unint64_t v15 = (char *)realloc(v15, v17);
          *(void *)a2 = v15;
          if (!v15) {
            goto LABEL_80;
          }
          uint64_t v18 = *(void *)(a2 + 8);
        }
        *(_WORD *)&v15[v18] = 8236;
        uint64_t v13 = *(void *)(a2 + 8) + 2;
        *(void *)(a2 + 8) = v13;
      }
      llvm::itanium_demangle::Node::printAsOperand(*(void *)(*(void *)(a1 + 24) + 8 * v11), a2, 18, 0);
      if (v13 == *(void *)(a2 + 8))
      {
        *(void *)(a2 + 8) = v10;
        if (++v11 == *(void *)(a1 + 32)) {
          break;
        }
      }
      else
      {
        char v12 = 0;
        uint64_t v10 = *(void *)(a2 + 8);
        if (++v11 == *(void *)(a1 + 32)) {
          break;
        }
      }
    }
  }
  --*(_DWORD *)(a2 + 32);
  uint64_t v19 = v10 + 1;
  unint64_t v20 = *(void *)(a2 + 16);
  unint64_t v21 = *(char **)a2;
  if (v10 + 1 > v20)
  {
    unint64_t v22 = 2 * v20;
    if (v22 <= v10 + 993) {
      size_t v23 = v10 + 993;
    }
    else {
      size_t v23 = v22;
    }
    *(void *)(a2 + 16) = v23;
    unint64_t v21 = (char *)realloc(v21, v23);
    *(void *)a2 = v21;
    if (!v21) {
      goto LABEL_80;
    }
    uint64_t v10 = *(void *)(a2 + 8);
    uint64_t v19 = v10 + 1;
  }
  *(void *)(a2 + 8) = v19;
  v21[v10] = 41;
  __n128 result = (char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16), a2);
  int v25 = *(_DWORD *)(a1 + 40);
  if (v25)
  {
    __n128 result = *(char **)a2;
    uint64_t v26 = *(void *)(a2 + 8);
    unint64_t v27 = *(void *)(a2 + 16);
    if (v26 + 6 > v27)
    {
      size_t v28 = v26 + 998;
      unint64_t v29 = 2 * v27;
      if (v29 <= v28) {
        size_t v30 = v28;
      }
      else {
        size_t v30 = v29;
      }
      *(void *)(a2 + 16) = v30;
      __n128 result = (char *)realloc(result, v30);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_80;
      }
      uint64_t v26 = *(void *)(a2 + 8);
    }
    uint64_t v31 = &result[v26];
    *((_WORD *)v31 + 2) = 29811;
    *(_DWORD *)uint64_t v31 = 1852793632;
    *(void *)(a2 + 8) += 6;
    int v25 = *(_DWORD *)(a1 + 40);
  }
  if ((v25 & 2) != 0)
  {
    __n128 result = *(char **)a2;
    uint64_t v32 = *(void *)(a2 + 8);
    unint64_t v33 = *(void *)(a2 + 16);
    if (v32 + 9 > v33)
    {
      size_t v34 = v32 + 1001;
      unint64_t v35 = 2 * v33;
      if (v35 <= v34) {
        size_t v36 = v34;
      }
      else {
        size_t v36 = v35;
      }
      *(void *)(a2 + 16) = v36;
      __n128 result = (char *)realloc(result, v36);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_80;
      }
      uint64_t v32 = *(void *)(a2 + 8);
    }
    uint64_t v37 = &result[v32];
    *(void *)uint64_t v37 = *(void *)" volatile";
    v37[8] = 101;
    *(void *)(a2 + 8) += 9;
    int v25 = *(_DWORD *)(a1 + 40);
  }
  if ((v25 & 4) != 0)
  {
    __n128 result = *(char **)a2;
    uint64_t v38 = *(void *)(a2 + 8);
    unint64_t v39 = *(void *)(a2 + 16);
    if (v38 + 9 > v39)
    {
      size_t v40 = v38 + 1001;
      unint64_t v41 = 2 * v39;
      if (v41 <= v40) {
        size_t v42 = v40;
      }
      else {
        size_t v42 = v41;
      }
      *(void *)(a2 + 16) = v42;
      __n128 result = (char *)realloc(result, v42);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_80;
      }
      uint64_t v38 = *(void *)(a2 + 8);
    }
    uint64_t v43 = &result[v38];
    *(void *)uint64_t v43 = *(void *)" restrict";
    v43[8] = 116;
    *(void *)(a2 + 8) += 9;
  }
  int v44 = *(unsigned __int8 *)(a1 + 44);
  if (v44 == 2)
  {
    __n128 result = *(char **)a2;
    uint64_t v51 = *(void *)(a2 + 8);
    unint64_t v52 = *(void *)(a2 + 16);
    if (v51 + 3 > v52)
    {
      size_t v53 = v51 + 995;
      unint64_t v54 = 2 * v52;
      if (v54 <= v53) {
        size_t v55 = v53;
      }
      else {
        size_t v55 = v54;
      }
      *(void *)(a2 + 16) = v55;
      __n128 result = (char *)realloc(result, v55);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_80;
      }
      uint64_t v51 = *(void *)(a2 + 8);
    }
    size_t v56 = &result[v51];
    v56[2] = 38;
    *(_WORD *)size_t v56 = 9760;
    uint64_t v50 = 3;
  }
  else
  {
    if (v44 != 1) {
      goto LABEL_68;
    }
    __n128 result = *(char **)a2;
    uint64_t v45 = *(void *)(a2 + 8);
    unint64_t v46 = *(void *)(a2 + 16);
    if (v45 + 2 > v46)
    {
      size_t v47 = v45 + 994;
      unint64_t v48 = 2 * v46;
      if (v48 <= v47) {
        size_t v49 = v47;
      }
      else {
        size_t v49 = v48;
      }
      *(void *)(a2 + 16) = v49;
      __n128 result = (char *)realloc(result, v49);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_80;
      }
      uint64_t v45 = *(void *)(a2 + 8);
    }
    *(_WORD *)&result[v45] = 9760;
    uint64_t v50 = 2;
  }
  *(void *)(a2 + 8) += v50;
LABEL_68:
  if (!*(void *)(a1 + 48)) {
    return result;
  }
  uint64_t v57 = *(char **)a2;
  uint64_t v58 = *(void *)(a2 + 8);
  uint64_t v59 = v58 + 1;
  unint64_t v60 = *(void *)(a2 + 16);
  if (v58 + 1 > v60)
  {
    unint64_t v61 = v58 + 993;
    if (2 * v60 <= v61) {
      size_t v62 = v61;
    }
    else {
      size_t v62 = 2 * v60;
    }
    *(void *)(a2 + 16) = v62;
    uint64_t v57 = (char *)realloc(v57, v62);
    *(void *)a2 = v57;
    if (v57)
    {
      uint64_t v58 = *(void *)(a2 + 8);
      uint64_t v59 = v58 + 1;
      goto LABEL_75;
    }
LABEL_80:
    abort();
  }
LABEL_75:
  *(void *)(a2 + 8) = v59;
  v57[v58] = 32;
  uint64_t v63 = *(void *)(a1 + 48);
  __n128 result = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v63 + 32))(v63, a2);
  if ((*(_WORD *)(v63 + 9) & 0xC0) != 0x40)
  {
    uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v63 + 40);
    return (char *)v64(v63, a2);
  }
  return result;
}

char *llvm::itanium_demangle::ObjCProtoName::printLeft(void *a1, char **a2)
{
  uint64_t v4 = a1[2];
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 1) > v7)
  {
    size_t v8 = (size_t)(v6 + 993);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      goto LABEL_24;
    }
    uint64_t v6 = a2[1];
  }
  v6[(void)v5] = 60;
  uint64_t v11 = (uint64_t)(a2[1] + 1);
  a2[1] = (char *)v11;
  size_t v12 = a1[4];
  if (v12)
  {
    uint64_t v13 = (const void *)a1[3];
    size_t v14 = v11 + v12;
    size_t v15 = (size_t)a2[2];
    unint64_t v16 = *a2;
    if (v11 + v12 > v15)
    {
      if (2 * v15 <= v14 + 992) {
        size_t v17 = v14 + 992;
      }
      else {
        size_t v17 = 2 * v15;
      }
      a2[2] = (char *)v17;
      unint64_t v16 = (char *)realloc(v16, v17);
      *a2 = v16;
      if (!v16) {
        goto LABEL_24;
      }
      uint64_t v11 = (uint64_t)a2[1];
    }
    memcpy(&v16[v11], v13, v12);
    uint64_t v11 = (uint64_t)&a2[1][v12];
    a2[1] = (char *)v11;
  }
  unint64_t v18 = (unint64_t)a2[2];
  __n128 result = *a2;
  if (v11 + 1 > v18)
  {
    size_t v20 = v11 + 993;
    unint64_t v21 = 2 * v18;
    if (v21 <= v20) {
      size_t v22 = v20;
    }
    else {
      size_t v22 = v21;
    }
    a2[2] = (char *)v22;
    __n128 result = (char *)realloc(result, v22);
    *a2 = result;
    if (result)
    {
      uint64_t v11 = (uint64_t)a2[1];
      goto LABEL_23;
    }
LABEL_24:
    abort();
  }
LABEL_23:
  result[v11] = 62;
  ++a2[1];
  return result;
}

uint64_t llvm::itanium_demangle::VendorExtQualType::printLeft(void *a1, char **a2)
{
  uint64_t v4 = a1[2];
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t result = (uint64_t)*a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 1) > v7)
  {
    size_t v8 = (size_t)(v6 + 993);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    uint64_t result = (uint64_t)realloc((void *)result, v10);
    *a2 = (char *)result;
    if (!result) {
      goto LABEL_23;
    }
    uint64_t v6 = a2[1];
  }
  v6[result] = 32;
  uint64_t v11 = (uint64_t)(a2[1] + 1);
  a2[1] = (char *)v11;
  size_t v12 = a1[4];
  if (v12)
  {
    uint64_t v13 = (const void *)a1[3];
    size_t v14 = v11 + v12;
    size_t v15 = (size_t)a2[2];
    unint64_t v16 = *a2;
    if (v11 + v12 <= v15)
    {
LABEL_16:
      uint64_t result = (uint64_t)memcpy(&v16[v11], v13, v12);
      a2[1] += v12;
      goto LABEL_17;
    }
    if (2 * v15 <= v14 + 992) {
      size_t v17 = v14 + 992;
    }
    else {
      size_t v17 = 2 * v15;
    }
    a2[2] = (char *)v17;
    unint64_t v16 = (char *)realloc(v16, v17);
    *a2 = v16;
    if (v16)
    {
      uint64_t v11 = (uint64_t)a2[1];
      goto LABEL_16;
    }
LABEL_23:
    abort();
  }
LABEL_17:
  uint64_t v18 = a1[5];
  if (v18)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v18 + 32))(v18, a2);
    if ((*(_WORD *)(v18 + 9) & 0xC0) != 0x40)
    {
      uint64_t v19 = *(uint64_t (**)(uint64_t, char **))(*(void *)v18 + 40);
      return v19(v18, a2);
    }
  }
  return result;
}

uint64_t llvm::itanium_demangle::QualType::hasRHSComponentSlow(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 9);
  if ((v2 & 0xC0) == 0x80) {
    return (**(uint64_t (***)(uint64_t))v1)(v1);
  }
  else {
    return v2 < 0x40;
  }
}

uint64_t llvm::itanium_demangle::QualType::hasArraySlow(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 16);
  int v2 = v1[10] & 3;
  if (v2 == 2) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 8))();
  }
  else {
    return v2 == 0;
  }
}

uint64_t llvm::itanium_demangle::QualType::hasFunctionSlow(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = (*(unsigned __int16 *)(v1 + 9) >> 10) & 3;
  if (v2 == 2) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 16))();
  }
  else {
    return v2 == 0;
  }
}

_DWORD *llvm::itanium_demangle::QualType::printLeft(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));

  return llvm::itanium_demangle::QualType::printQuals((_DWORD *)a1, a2);
}

uint64_t llvm::itanium_demangle::QualType::printRight(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))();
}

_DWORD *llvm::itanium_demangle::QualType::printQuals(_DWORD *result, uint64_t a2)
{
  uint64_t v3 = result;
  int v4 = result[3];
  if (v4)
  {
    uint64_t result = *(_DWORD **)a2;
    uint64_t v5 = *(void *)(a2 + 8);
    unint64_t v6 = *(void *)(a2 + 16);
    if (v5 + 6 > v6)
    {
      size_t v7 = v5 + 998;
      unint64_t v8 = 2 * v6;
      if (v8 <= v7) {
        size_t v9 = v7;
      }
      else {
        size_t v9 = v8;
      }
      *(void *)(a2 + 16) = v9;
      uint64_t result = realloc(result, v9);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_26;
      }
      uint64_t v5 = *(void *)(a2 + 8);
    }
    size_t v10 = (char *)result + v5;
    *((_WORD *)v10 + 2) = 29811;
    *(_DWORD *)size_t v10 = 1852793632;
    *(void *)(a2 + 8) += 6;
    int v4 = v3[3];
  }
  if ((v4 & 2) != 0)
  {
    uint64_t result = *(_DWORD **)a2;
    uint64_t v11 = *(void *)(a2 + 8);
    unint64_t v12 = *(void *)(a2 + 16);
    if (v11 + 9 > v12)
    {
      size_t v13 = v11 + 1001;
      unint64_t v14 = 2 * v12;
      if (v14 <= v13) {
        size_t v15 = v13;
      }
      else {
        size_t v15 = v14;
      }
      *(void *)(a2 + 16) = v15;
      uint64_t result = realloc(result, v15);
      *(void *)a2 = result;
      if (!result) {
        goto LABEL_26;
      }
      uint64_t v11 = *(void *)(a2 + 8);
    }
    unint64_t v16 = (char *)result + v11;
    *(void *)unint64_t v16 = *(void *)" volatile";
    v16[8] = 101;
    *(void *)(a2 + 8) += 9;
    int v4 = v3[3];
  }
  if ((v4 & 4) == 0) {
    return result;
  }
  uint64_t result = *(_DWORD **)a2;
  uint64_t v17 = *(void *)(a2 + 8);
  unint64_t v18 = *(void *)(a2 + 16);
  if (v17 + 9 > v18)
  {
    size_t v19 = v17 + 1001;
    unint64_t v20 = 2 * v18;
    if (v20 <= v19) {
      size_t v21 = v19;
    }
    else {
      size_t v21 = v20;
    }
    *(void *)(a2 + 16) = v21;
    uint64_t result = realloc(result, v21);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      goto LABEL_24;
    }
LABEL_26:
    abort();
  }
LABEL_24:
  size_t v22 = (char *)result + v17;
  *(void *)size_t v22 = *(void *)" restrict";
  v22[8] = 116;
  *(void *)(a2 + 8) += 9;
  return result;
}

char *llvm::itanium_demangle::TransformedType::printLeft(void *a1, char **a2)
{
  size_t v4 = a1[3];
  size_t v5 = (size_t)a2[1];
  if (v4)
  {
    unint64_t v6 = (const void *)a1[2];
    size_t v7 = v5 + v4;
    size_t v8 = (size_t)a2[2];
    size_t v9 = *a2;
    if (v5 + v4 > v8)
    {
      if (2 * v8 <= v7 + 992) {
        size_t v10 = v7 + 992;
      }
      else {
        size_t v10 = 2 * v8;
      }
      a2[2] = (char *)v10;
      size_t v9 = (char *)realloc(v9, v10);
      *a2 = v9;
      if (!v9) {
        goto LABEL_24;
      }
      size_t v5 = (size_t)a2[1];
    }
    memcpy(&v9[v5], v6, v4);
    size_t v5 = (size_t)&a2[1][v4];
    a2[1] = (char *)v5;
  }
  size_t v11 = v5 + 1;
  unint64_t v12 = (unint64_t)a2[2];
  size_t v13 = *a2;
  if (v5 + 1 > v12)
  {
    unint64_t v14 = v5 + 993;
    if (2 * v12 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = 2 * v12;
    }
    a2[2] = (char *)v15;
    size_t v13 = (char *)realloc(v13, v15);
    *a2 = v13;
    if (!v13) {
      goto LABEL_24;
    }
    size_t v5 = (size_t)a2[1];
    size_t v11 = v5 + 1;
  }
  a2[1] = (char *)v11;
  v13[v5] = 40;
  uint64_t v16 = a1[4];
  (*(void (**)(uint64_t, char **))(*(void *)v16 + 32))(v16, a2);
  if ((*(_WORD *)(v16 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v16 + 40))(v16, a2);
  }
  uint64_t result = *a2;
  unint64_t v18 = a2[1];
  size_t v19 = v18 + 1;
  unint64_t v20 = (unint64_t)a2[2];
  if ((unint64_t)(v18 + 1) > v20)
  {
    unint64_t v21 = (unint64_t)(v18 + 993);
    if (2 * v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = 2 * v20;
    }
    a2[2] = (char *)v22;
    uint64_t result = (char *)realloc(result, v22);
    *a2 = result;
    if (result)
    {
      unint64_t v18 = a2[1];
      size_t v19 = v18 + 1;
      goto LABEL_23;
    }
LABEL_24:
    abort();
  }
LABEL_23:
  a2[1] = v19;
  v18[(void)result] = 41;
  return result;
}

uint64_t llvm::itanium_demangle::BinaryFPType::printLeft(uint64_t a1, char **a2)
{
  size_t v4 = *a2;
  size_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 6) > v6)
  {
    size_t v7 = (size_t)(v5 + 998);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    size_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      abort();
    }
    size_t v5 = a2[1];
  }
  size_t v10 = &v5[(void)v4];
  *((_WORD *)v10 + 2) = 29793;
  *(_DWORD *)size_t v10 = 1869366879;
  a2[1] += 6;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
  if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40)
  {
    size_t v13 = *(uint64_t (**)(uint64_t, char **))(*(void *)v11 + 40);
    return v13(v11, a2);
  }
  return result;
}

char *llvm::itanium_demangle::BitIntType::printLeft(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(unsigned char *)(a1 + 24))
  {
    unint64_t v5 = *(void *)(a2 + 16);
    unint64_t v6 = *(char **)a2;
    if (v4 + 7 <= v5) {
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  unint64_t v7 = *(void *)(a2 + 16);
  unint64_t v8 = *(char **)a2;
  if (v4 + 9 > v7)
  {
    size_t v9 = v4 + 1001;
    unint64_t v10 = 2 * v7;
    if (v10 <= v9) {
      size_t v11 = v9;
    }
    else {
      size_t v11 = v10;
    }
    *(void *)(a2 + 16) = v11;
    unint64_t v8 = (char *)realloc(v8, v11);
    *(void *)a2 = v8;
    if (!v8) {
      goto LABEL_29;
    }
    uint64_t v4 = *(void *)(a2 + 8);
  }
  unint64_t v12 = &v8[v4];
  *(void *)unint64_t v12 = *(void *)"unsigned ";
  v12[8] = 32;
  unint64_t v5 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 8) + 9;
  *(void *)(a2 + 8) = v4;
  unint64_t v6 = *(char **)a2;
  if (v4 + 7 > v5)
  {
LABEL_11:
    size_t v13 = v4 + 999;
    unint64_t v14 = 2 * v5;
    if (v14 <= v13) {
      size_t v15 = v13;
    }
    else {
      size_t v15 = v14;
    }
    *(void *)(a2 + 16) = v15;
    unint64_t v6 = (char *)realloc(v6, v15);
    *(void *)a2 = v6;
    if (!v6) {
      goto LABEL_29;
    }
    uint64_t v4 = *(void *)(a2 + 8);
  }
LABEL_16:
  uint64_t v16 = &v6[v4];
  *(_DWORD *)(v16 + 3) = 1953384820;
  *(_DWORD *)uint64_t v16 = 1953055327;
  uint64_t v17 = *(char **)a2;
  uint64_t v18 = *(void *)(a2 + 8);
  uint64_t v19 = v18 + 7;
  *(void *)(a2 + 8) = v18 + 7;
  ++*(_DWORD *)(a2 + 32);
  uint64_t v20 = v18 + 8;
  unint64_t v21 = *(void *)(a2 + 16);
  if (v18 + 8 > v21)
  {
    if (2 * v21 <= v18 + 1000) {
      size_t v22 = v18 + 1000;
    }
    else {
      size_t v22 = 2 * v21;
    }
    *(void *)(a2 + 16) = v22;
    uint64_t v17 = (char *)realloc(v17, v22);
    *(void *)a2 = v17;
    if (!v17) {
      goto LABEL_29;
    }
    uint64_t v19 = *(void *)(a2 + 8);
    uint64_t v20 = v19 + 1;
  }
  *(void *)(a2 + 8) = v20;
  v17[v19] = 40;
  llvm::itanium_demangle::Node::printAsOperand(*(void *)(a1 + 16), a2, 19, 0);
  --*(_DWORD *)(a2 + 32);
  uint64_t result = *(char **)a2;
  uint64_t v24 = *(void *)(a2 + 8);
  uint64_t v25 = v24 + 1;
  unint64_t v26 = *(void *)(a2 + 16);
  if (v24 + 1 > v26)
  {
    unint64_t v27 = v24 + 993;
    if (2 * v26 <= v27) {
      size_t v28 = v27;
    }
    else {
      size_t v28 = 2 * v26;
    }
    *(void *)(a2 + 16) = v28;
    uint64_t result = (char *)realloc(result, v28);
    *(void *)a2 = result;
    if (result)
    {
      uint64_t v24 = *(void *)(a2 + 8);
      uint64_t v25 = v24 + 1;
      goto LABEL_28;
    }
LABEL_29:
    abort();
  }
LABEL_28:
  *(void *)(a2 + 8) = v25;
  result[v24] = 41;
  return result;
}

void *llvm::itanium_demangle::PostfixQualifiedType::printLeft(uint64_t a1, char **a2)
{
  uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  size_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    unint64_t v6 = *(const void **)(a1 + 24);
    unint64_t v7 = *a2;
    unint64_t v8 = a2[1];
    size_t v9 = &v8[v5];
    size_t v10 = (size_t)a2[2];
    if ((unint64_t)&v8[v5] > v10)
    {
      unint64_t v11 = 2 * v10;
      if (v11 <= (unint64_t)(v9 + 992)) {
        size_t v12 = (size_t)(v9 + 992);
      }
      else {
        size_t v12 = v11;
      }
      a2[2] = (char *)v12;
      unint64_t v7 = (char *)realloc(v7, v12);
      *a2 = v7;
      if (!v7) {
        abort();
      }
      unint64_t v8 = a2[1];
    }
    uint64_t result = memcpy(&v8[(void)v7], v6, v5);
    a2[1] += v5;
  }
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PixelVectorType,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 4904);
  uint64_t v4 = v3[1];
  if ((unint64_t)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v6 = malloc(0x1000uLL);
    if (!v6) {
      std::terminate();
    }
    uint64_t v4 = 0;
    void *v6 = v3;
    v6[1] = 0;
    uint64_t v3 = v6;
    *(void *)(a1 + 4904) = v6;
  }
  v3[1] = v4 + 32;
  unint64_t v7 = (char *)v3 + v4;
  uint64_t result = v7 + 16;
  uint64_t v9 = *a2;
  v7[24] = 30;
  *(_WORD *)(v7 + 25) = *(_WORD *)(v7 + 25) & 0xF000 | 0x540;
  *((void *)v7 + 2) = &unk_1EC9A2810;
  *((void *)v7 + 4) = v9;
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::VectorType,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  size_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    size_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  uint64_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  v9[24] = 29;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x540;
  *((void *)v9 + 2) = &unk_1EC9A1DC0;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

char *llvm::itanium_demangle::PixelVectorType::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  size_t v5 = a2[1];
  unint64_t v6 = (unint64_t)a2[2];
  if ((unint64_t)(v5 + 13) > v6)
  {
    size_t v7 = (size_t)(v5 + 1005);
    unint64_t v8 = 2 * v6;
    if (v8 <= v7) {
      size_t v9 = v7;
    }
    else {
      size_t v9 = v8;
    }
    a2[2] = (char *)v9;
    uint64_t v4 = (char *)realloc(v4, v9);
    *a2 = v4;
    if (!v4) {
      goto LABEL_16;
    }
    size_t v5 = a2[1];
  }
  qmemcpy(&v5[(void)v4], "pixel vector[", 13);
  a2[1] += 13;
  uint64_t v10 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v10 + 32))(v10, a2);
  if ((*(_WORD *)(v10 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v10 + 40))(v10, a2);
  }
  uint64_t result = *a2;
  uint64_t v12 = a2[1];
  unint64_t v13 = (unint64_t)a2[2];
  if ((unint64_t)(v12 + 1) > v13)
  {
    size_t v14 = (size_t)(v12 + 993);
    unint64_t v15 = 2 * v13;
    if (v15 <= v14) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
    a2[2] = (char *)v16;
    uint64_t result = (char *)realloc(result, v16);
    *a2 = result;
    if (result)
    {
      uint64_t v12 = a2[1];
      goto LABEL_15;
    }
LABEL_16:
    abort();
  }
LABEL_15:
  v12[(void)result] = 93;
  ++a2[1];
  return result;
}

char *llvm::itanium_demangle::VectorType::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  if ((*(_WORD *)(v4 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 40))(v4, a2);
  }
  size_t v5 = *a2;
  unint64_t v6 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)(v6 + 8) > v7)
  {
    size_t v8 = (size_t)(v6 + 1000);
    unint64_t v9 = 2 * v7;
    if (v9 <= v8) {
      size_t v10 = v8;
    }
    else {
      size_t v10 = v9;
    }
    a2[2] = (char *)v10;
    size_t v5 = (char *)realloc(v5, v10);
    *a2 = v5;
    if (!v5) {
      goto LABEL_19;
    }
    unint64_t v6 = a2[1];
  }
  *(void *)&v6[(void)v5] = 0x5B726F7463657620;
  a2[1] += 8;
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    (*(void (**)(uint64_t, char **))(*(void *)v11 + 32))(v11, a2);
    if ((*(_WORD *)(v11 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, char **))(*(void *)v11 + 40))(v11, a2);
    }
  }
  uint64_t result = *a2;
  unint64_t v13 = a2[1];
  unint64_t v14 = (unint64_t)a2[2];
  if ((unint64_t)(v13 + 1) > v14)
  {
    size_t v15 = (size_t)(v13 + 993);
    unint64_t v16 = 2 * v14;
    if (v16 <= v15) {
      size_t v17 = v15;
    }
    else {
      size_t v17 = v16;
    }
    a2[2] = (char *)v17;
    uint64_t result = (char *)realloc(result, v17);
    *a2 = result;
    if (result)
    {
      unint64_t v13 = a2[1];
      goto LABEL_18;
    }
LABEL_19:
    abort();
  }
LABEL_18:
  v13[(void)result] = 93;
  ++a2[1];
  return result;
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::ArrayType,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  size_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    size_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    size_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  unint64_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  v9[24] = 15;
  *(_WORD *)(v9 + 25) = *(_WORD *)(v9 + 25) & 0xF000 | 0x400;
  *((void *)v9 + 2) = &unk_1EC9A36D8;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

uint64_t llvm::itanium_demangle::ArrayType::hasRHSComponentSlow()
{
  return 1;
}

uint64_t llvm::itanium_demangle::ArrayType::hasArraySlow()
{
  return 1;
}

uint64_t llvm::itanium_demangle::ArrayType::printLeft(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))();
}

uint64_t llvm::itanium_demangle::ArrayType::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(unsigned char *)(v5 + *(void *)a2 - 1) != 93)
  {
    unint64_t v6 = *(void *)(a2 + 16);
    if (v5 + 1 > v6)
    {
      size_t v7 = v5 + 993;
      unint64_t v8 = 2 * v6;
      if (v8 <= v7) {
        size_t v9 = v7;
      }
      else {
        size_t v9 = v8;
      }
      *(void *)(a2 + 16) = v9;
      uint64_t v4 = realloc(v4, v9);
      *(void *)a2 = v4;
      if (!v4) {
        goto LABEL_27;
      }
      uint64_t v5 = *(void *)(a2 + 8);
    }
    *((unsigned char *)v4 + v5) = 32;
    uint64_t v4 = *(void **)a2;
    uint64_t v5 = *(void *)(a2 + 8) + 1;
    *(void *)(a2 + 8) = v5;
  }
  unint64_t v10 = *(void *)(a2 + 16);
  if (v5 + 1 > v10)
  {
    size_t v11 = v5 + 993;
    unint64_t v12 = 2 * v10;
    if (v12 <= v11) {
      size_t v13 = v11;
    }
    else {
      size_t v13 = v12;
    }
    *(void *)(a2 + 16) = v13;
    uint64_t v4 = realloc(v4, v13);
    *(void *)a2 = v4;
    if (!v4) {
      goto LABEL_27;
    }
    uint64_t v5 = *(void *)(a2 + 8);
  }
  *((unsigned char *)v4 + v5) = 91;
  ++*(void *)(a2 + 8);
  uint64_t v14 = *(void *)(a1 + 24);
  if (v14)
  {
    (*(void (**)(void, uint64_t))(*(void *)v14 + 32))(*(void *)(a1 + 24), a2);
    if ((*(_WORD *)(v14 + 9) & 0xC0) != 0x40) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 40))(v14, a2);
    }
  }
  size_t v15 = *(void **)a2;
  uint64_t v16 = *(void *)(a2 + 8);
  unint64_t v17 = *(void *)(a2 + 16);
  if (v16 + 1 > v17)
  {
    size_t v18 = v16 + 993;
    unint64_t v19 = 2 * v17;
    if (v19 <= v18) {
      size_t v20 = v18;
    }
    else {
      size_t v20 = v19;
    }
    *(void *)(a2 + 16) = v20;
    size_t v15 = realloc(v15, v20);
    *(void *)a2 = v15;
    if (v15)
    {
      uint64_t v16 = *(void *)(a2 + 8);
      goto LABEL_24;
    }
LABEL_27:
    abort();
  }
LABEL_24:
  *((unsigned char *)v15 + v16) = 93;
  ++*(void *)(a2 + 8);
  unint64_t v21 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 40);

  return v21();
}

char *llvm::itanium_demangle::AbstractManglingParser<llvm::itanium_demangle::ManglingParser<anonymous namespace'::DefaultAllocator>,anonymous namespace'::DefaultAllocator>::make<llvm::itanium_demangle::PointerToMemberType,llvm::itanium_demangle::Node *&,llvm::itanium_demangle::Node *&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 4904);
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL)
  {
    unint64_t v8 = malloc(0x1000uLL);
    if (!v8) {
      std::terminate();
    }
    uint64_t v6 = 0;
    void *v8 = v5;
    v8[1] = 0;
    uint64_t v5 = v8;
    *(void *)(a1 + 4904) = v8;
  }
  v5[1] = v6 + 32;
  size_t v9 = (char *)v5 + v6;
  uint64_t result = v9 + 16;
  uint64_t v11 = *a2;
  uint64_t v12 = *a3;
  char v13 = *(_WORD *)(*a3 + 9);
  v9[24] = 14;
  *(_WORD *)(v9 + 25) = v13 & 0xC0 | 0x500 | *(_WORD *)(v9 + 25) & 0xF000;
  *((void *)v9 + 2) = &unk_1EC9A2C30;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v12;
  return result;
}

uint64_t llvm::itanium_demangle::PointerToMemberType::hasRHSComponentSlow(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 9);
  if ((v2 & 0xC0) == 0x80) {
    return (**(uint64_t (***)(uint64_t))v1)(v1);
  }
  else {
    return v2 < 0x40;
  }
}

char *llvm::itanium_demangle::PointerToMemberType::printLeft(uint64_t a1, char **a2)
{
  (*(void (**)(void))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24));
  uint64_t v4 = *(void *)(a1 + 24);
  unsigned int v5 = *(unsigned __int16 *)(v4 + 9);
  int v6 = (v5 >> 8) & 3;
  if (!v6) {
    goto LABEL_8;
  }
  if (v6 == 2)
  {
    if ((*(uint64_t (**)(uint64_t, char **))(*(void *)v4 + 8))(v4, a2))
    {
LABEL_8:
      unint64_t v8 = *a2;
      size_t v9 = a2[1];
      unint64_t v10 = (unint64_t)a2[2];
      if ((unint64_t)(v9 + 1) > v10)
      {
        size_t v11 = (size_t)(v9 + 993);
        unint64_t v12 = 2 * v10;
        if (v12 <= v11) {
          size_t v13 = v11;
        }
        else {
          size_t v13 = v12;
        }
        a2[2] = (char *)v13;
        unint64_t v8 = (char *)realloc(v8, v13);
        *a2 = v8;
        if (!v8) {
          goto LABEL_31;
        }
        size_t v9 = a2[1];
      }
      char v14 = 40;
      goto LABEL_22;
    }
    uint64_t v4 = *(void *)(a1 + 24);
    unsigned int v5 = *(unsigned __int16 *)(v4 + 9);
  }
  int v7 = (v5 >> 10) & 3;
  if (!v7 || v7 == 2 && (*(unsigned int (**)(uint64_t, char **))(*(void *)v4 + 16))(v4, a2)) {
    goto LABEL_8;
  }
  unint64_t v8 = *a2;
  size_t v9 = a2[1];
  unint64_t v15 = (unint64_t)a2[2];
  if ((unint64_t)(v9 + 1) > v15)
  {
    size_t v16 = (size_t)(v9 + 993);
    unint64_t v17 = 2 * v15;
    if (v17 <= v16) {
      size_t v18 = v16;
    }
    else {
      size_t v18 = v17;
    }
    a2[2] = (char *)v18;
    unint64_t v8 = (char *)realloc(v8, v18);
    *a2 = v8;
    if (!v8) {
      goto LABEL_31;
    }
    size_t v9 = a2[1];
  }
  char v14 = 32;
LABEL_22:
  v9[(void)v8] = v14;
  ++a2[1];
  uint64_t v19 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, char **))(*(void *)v19 + 32))(v19, a2);
  if ((*(_WORD *)(v19 + 9) & 0xC0) != 0x40) {
    (*(void (**)(uint64_t, char **))(*(void *)v19 + 40))(v19, a2);
  }
  uint64_t result = *a2;
  unint64_t v21 = a2[1];
  unint64_t v22 = (unint64_t)a2[2];
  if ((unint64_t)(v21 + 3) > v22)
  {
    size_t v23 = (size_t)(v21 + 995);
    unint64_t v24 = 2 * v22;
    if (v24 <= v23) {
      size_t v25 = v23;
    }
    else {
      size_t v25 = v24;
    }
    a2[2] = (char *)v25;
    uint64_t result = (char *)realloc(result, v25);
    *a2 = result;
    if (result)
    {
      unint64_t v21 = a2[1];
      goto LABEL_30;
    }
LABEL_31:
    abort();
  }
LABEL_30:
  unint64_t v26 = &v21[(void)result];
  v26[2] = 42;
  *(_WORD *)unint64_t v26 = 14906;
  a2[1] += 3;
  return result;
}

uint64_t llvm::itanium_demangle::PointerToMemberType::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  unsigned int v5 = *(unsigned __int16 *)(v4 + 9);
  int v6 = (v5 >> 8) & 3;
  if (v6)
  {
    if (v6 != 2)
    {
LABEL_5:
      int v7 = (v5 >> 10) & 3;
      if (v7 && (v7 != 2 || !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v4 + 16))(v4, a2))) {
        goto LABEL_15;
      }
      goto LABEL_8;
    }
    if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 8))(v4, a2) & 1) == 0)
    {
      uint64_t v4 = *(void *)(a1 + 24);
      unsigned int v5 = *(unsigned __int16 *)(v4 + 9);
      goto LABEL_5;
    }
  }
LABEL_8:
  unint64_t v8 = *(void **)a2;
  uint64_t v9 = *(void *)(a2 + 8);
  unint64_t v10 = *(void *)(a2 + 16);
  if (v9 + 1 > v10)
  {
    size_t v11 = v9 + 993;
    unint64_t v12 = 2 * v10;
    if (v12 <= v11) {
      size_t v13 = v11;
    }
    else {
      size_t v13 = v12;
    }
    *(void *)(a2 + 16) = v13;
    unint64_t v8 = realloc(v8, v13);
    *(void *)a2 = v8;
    if (!v8) {
      abort();
    }
    uint64_t v9 = *(void *)(a2 + 8);
  }
  *((unsigned char *)v8 + v9) = 41;
  ++*(void *)(a2 + 8);
LABEL_15:
  char v14 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 40);

  return v14();
}

uint64_t llvm::itanium_demangle::ElaboratedTypeSpefType::printLeft(void *a1, char **a2)
{
  size_t v4 = a1[3];
  size_t v5 = (size_t)a2[1];
  if (v4)
  {
    int v6 = (const void *)a1[2];
    size_t v7 = v5 + v4;
    size_t v8 = (size_t)a2[2];
    uint64_t v9 = *a2;
    if (v5 + v4 > v8)
    {
      if (2 * v8 <= v7 + 992) {
        size_t v10 = v7 + 992;
      }
      else {
        size_t v10 = 2 * v8;
      }
      a2[2] = (char *)v10;
      uint64_t v9 = (char *)realloc(v9, v10);
      *a2 = v9;
      if (!v9) {
        goto LABEL_19;
      }
      size_t v5 = (size_t)a2[1];
    }
    memcpy(&v9[v5], v6, v4);
    size_t v5 = (size_t)&a2[1][v4];
    a2[1] = (char *)v5;
  }
  size_t v11 = v5 + 1;
  unint64_t v12 = (unint64_t)a2[2];
  size_t v13 = *a2;
  if (v5 + 1 <= v12) {
    goto LABEL_15;
  }
  unint64_t v14 = v5 + 993;
  if (2 * v12 <= v14) {
    size_t v15 = v14;
  }
  else {
    size_t v15 = 2 * v12;
  }
  a2[2] = (char *)v15;
  size_t v13 = (char *)realloc(v13, v15);
  *a2 = v13;
  if (!v13) {
LABEL_19:
  }
    abort();
  size_t v5 = (size_t)a2[1];
  size_t v11 = v5 + 1;
LABEL_15:
  a2[1] = (char *)v11;
  v13[v5] = 32;
  uint64_t v16 = a1[4];
  uint64_t result = (*(uint64_t (**)(uint64_t, char **))(*(void *)v16 + 32))(v16, a2);
  if ((*(_WORD *)(v16 + 9) & 0xC0) != 0x40)
  {
    size_t v18 = *(uint64_t (**)(uint64_t, char **))(*(void *)v16 + 40);
    return v18(v16, a2);
  }
  return result;
}

uint64_t llvm::itanium_demangle::PointerType::hasRHSComponentSlow(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 9);
  if ((v2 & 0xC0) == 0x80) {
    return (**(uint64_t (***)(uint64_t))v1)(v1);
  }
  else {
    return v2 < 0x40;
  }
}

char *llvm::itanium_demangle::PointerType::printLeft(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v4 + 8) == 11)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    if (*(unsigned char *)(v5 + 8) == 8 && *(void *)(v5 + 24) == 11)
    {
      int v6 = *(uint64_t **)(v5 + 16);
      uint64_t v7 = *v6;
      uint64_t v8 = *(uint64_t *)((char *)v6 + 3);
      if (v7 == 0x6A626F5F636A626FLL && v8 == 0x7463656A626F5F63)
      {
        size_t v28 = (uint64_t *)(a2 + 1);
        uint64_t v35 = (uint64_t)a2[1];
        unint64_t v36 = (unint64_t)a2[2];
        uint64_t v37 = *a2;
        if (v35 + 3 > v36)
        {
          size_t v38 = v35 + 995;
          unint64_t v39 = 2 * v36;
          if (v39 <= v38) {
            size_t v40 = v38;
          }
          else {
            size_t v40 = v39;
          }
          a2[2] = (char *)v40;
          uint64_t v37 = (char *)realloc(v37, v40);
          *a2 = v37;
          if (!v37) {
            goto LABEL_61;
          }
          uint64_t v35 = *v28;
        }
        unint64_t v41 = &v37[v35];
        v41[2] = 60;
        *(_WORD *)unint64_t v41 = 25705;
        uint64_t v27 = *v28 + 3;
        uint64_t *v28 = v27;
        size_t v42 = *(void *)(v4 + 32);
        if (v42)
        {
          uint64_t v43 = *(const void **)(v4 + 24);
          size_t v44 = v27 + v42;
          size_t v45 = (size_t)a2[2];
          unint64_t v46 = *a2;
          if (v27 + v42 > v45)
          {
            if (2 * v45 <= v44 + 992) {
              size_t v47 = v44 + 992;
            }
            else {
              size_t v47 = 2 * v45;
            }
            a2[2] = (char *)v47;
            unint64_t v46 = (char *)realloc(v46, v47);
            *a2 = v46;
            if (!v46) {
              goto LABEL_61;
            }
            uint64_t v27 = *v28;
          }
          memcpy(&v46[v27], v43, v42);
          uint64_t v27 = *v28 + v42;
          uint64_t *v28 = v27;
        }
        unint64_t v48 = (unint64_t)a2[2];
        uint64_t result = *a2;
        if (v27 + 1 > v48)
        {
          size_t v49 = v27 + 993;
          unint64_t v50 = 2 * v48;
          if (v50 <= v49) {
            size_t v51 = v49;
          }
          else {
            size_t v51 = v50;
          }
          a2[2] = (char *)v51;
          uint64_t result = (char *)realloc(result, v51);
          *a2 = result;
          if (!result) {
            goto LABEL_61;
          }
          uint64_t v27 = *v28;
        }
        char v34 = 62;
        goto LABEL_39;
      }
    }
  }
  (*(void (**)(void, char **))(*(void *)v4 + 32))(*(void *)(a1 + 16), a2);
  size_t v10 = *(unsigned char **)(a1 + 16);
  if ((v10[10] & 3) == 0
    || (v10[10] & 3) == 2 && (*(unsigned int (**)(unsigned char *, char **))(*(void *)v10 + 8))(v10, a2))
  {
    size_t v11 = *a2;
    unint64_t v12 = a2[1];
    unint64_t v13 = (unint64_t)a2[2];
    if ((unint64_t)(v12 + 1) > v13)
    {
      size_t v14 = (size_t)(v12 + 993);
      unint64_t v15 = 2 * v13;
      if (v15 <= v14) {
        size_t v16 = v14;
      }
      else {
        size_t v16 = v15;
      }
      a2[2] = (char *)v16;
      size_t v11 = (char *)realloc(v11, v16);
      *a2 = v11;
      if (!v11) {
        goto LABEL_61;
      }
      unint64_t v12 = a2[1];
    }
    v12[(void)v11] = 32;
    ++a2[1];
  }
  uint64_t v17 = *(void *)(a1 + 16);
  unsigned int v18 = *(unsigned __int16 *)(v17 + 9);
  int v19 = (v18 >> 8) & 3;
  if (v19)
  {
    if (v19 != 2)
    {
LABEL_22:
      int v20 = (v18 >> 10) & 3;
      if (v20 && (v20 != 2 || !(*(unsigned int (**)(uint64_t, char **))(*(void *)v17 + 16))(v17, a2))) {
        goto LABEL_32;
      }
      goto LABEL_25;
    }
    if (((*(uint64_t (**)(uint64_t, char **))(*(void *)v17 + 8))(v17, a2) & 1) == 0)
    {
      uint64_t v17 = *(void *)(a1 + 16);
      unsigned int v18 = *(unsigned __int16 *)(v17 + 9);
      goto LABEL_22;
    }
  }
LABEL_25:
  unint64_t v21 = *a2;
  unint64_t v22 = a2[1];
  unint64_t v23 = (unint64_t)a2[2];
  if ((unint64_t)(v22 + 1) > v23)
  {
    size_t v24 = (size_t)(v22 + 993);
    unint64_t v25 = 2 * v23;
    if (v25 <= v24) {
      size_t v26 = v24;
    }
    else {
      size_t v26 = v25;
    }
    a2[2] = (char *)v26;
    unint64_t v21 = (char *)realloc(v21, v26);
    *a2 = v21;
    if (!v21) {
      goto LABEL_61;
    }
    unint64_t v22 = a2[1];
  }
  v22[(void)v21] = 40;
  ++a2[1];
LABEL_32:
  size_t v28 = (uint64_t *)(a2 + 1);
  uint64_t v27 = (uint64_t)a2[1];
  unint64_t v29 = (unint64_t)a2[2];
  uint64_t result = *a2;
  if (v27 + 1 > v29)
  {
    size_t v31 = v27 + 993;
    unint64_t v32 = 2 * v29;
    if (v32 <= v31) {
      size_t v33 = v31;
    }
    else {
      size_t v33 = v32;
    }
    a2[2] = (char *)v33;
    uint64_t result = (char *)realloc(result, v33);
    *a2 = result;
    if (result)
    {
      uint64_t v27 = *v28;
      goto LABEL_38;
    }
LABEL_61:
    abort();
  }
LABEL_38:
  char v34 = 42;
LABEL_39:
  result[v27] = v34;
  ++*v28;
  return result;
}

uint64_t llvm::itanium_demangle::PointerType::printRight(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 16);
  if (*(unsigned char *)(result + 8) != 11
    || (uint64_t v5 = *(void *)(result + 16), *(unsigned char *)(v5 + 8) != 8)
    || *(void *)(v5 + 24) != 11
    || ((int v6 = *(uint64_t **)(v5 + 16), v7 = *v6, v8 = *(uint64_t *)((char *)v6 + 3), v7 == 0x6A626F5F636A626FLL)
      ? (BOOL v9 = v8 == 0x7463656A626F5F63)
      : (BOOL v9 = 0),
        !v9))
  {
    unsigned int v10 = *(unsigned __int16 *)(result + 9);
    int v11 = (v10 >> 8) & 3;
    if (v11)
    {
      if (v11 == 2)
      {
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 8))(result, a2)) {
          goto LABEL_15;
        }
        uint64_t result = *(void *)(a1 + 16);
        unsigned int v10 = *(unsigned __int16 *)(result + 9);
      }
      int v12 = (v10 >> 10) & 3;
      if (v12
        && (v12 != 2 || !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)result + 16))(result, a2)))
      {
LABEL_22:
        int v19 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 40);
        return v19();
      }
    }
LABEL_15:
    unint64_t v13 = *(void **)a2;
    uint64_t v14 = *(void *)(a2 + 8);
    unint64_t v15 = *(void *)(a2 + 16);
    if (v14 + 1 > v15)
    {
      size_t v16 = v14 + 993;
      unint64_t v17 = 2 * v15;
      if (v17 <= v16) {
        size_t v18 = v16;
      }
      else {
        size_t v18 = v17;
      }
      *(void *)(a2 + 16) = v18;
      unint64_t v13 = realloc(v13, v18);
      *(void *)a2 = v13;
      if (!v13) {
        abort();
      }
      uint64_t v14 = *(void *)(a2 + 8);
    }
    *((unsigned char *)v13 + v14) = 41;
    ++*(void *)(a2 + 8);
    goto LABEL_22;
  }
  return result;
}

uint64_t llvm::itanium_demangle::ReferenceType::hasRHSComponentSlow(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 9);
  if ((v2 & 0xC0) == 0x80) {
    return (**(uint64_t (***)(uint64_t))v1)(v1);
  }
  else {
    return v2 < 0x40;
  }
}

uint64_t llvm::itanium_demangle::ReferenceType::printLeft(uint64_t result, char **a2)
{
  if (!*(unsigned char *)(result + 28))
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 28) = 1;
    uint64_t result = llvm::itanium_demangle::ReferenceType::collapse(result);
    if (!v4)
    {
LABEL_40:
      *(unsigned char *)(v3 + 28) = 0;
      return result;
    }
    int v5 = result;
    uint64_t v6 = v4;
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 32))(v4, a2);
    if ((*(unsigned char *)(v6 + 10) & 3) == 0
      || (*(unsigned char *)(v6 + 10) & 3) == 2
      && (*(unsigned int (**)(uint64_t, char **))(*(void *)v6 + 8))(v6, a2))
    {
      uint64_t v7 = *a2;
      uint64_t v8 = a2[1];
      unint64_t v9 = (unint64_t)a2[2];
      if ((unint64_t)(v8 + 1) > v9)
      {
        size_t v10 = (size_t)(v8 + 993);
        unint64_t v11 = 2 * v9;
        if (v11 <= v10) {
          size_t v12 = v10;
        }
        else {
          size_t v12 = v11;
        }
        a2[2] = (char *)v12;
        uint64_t v7 = (char *)realloc(v7, v12);
        *a2 = v7;
        if (!v7) {
          goto LABEL_41;
        }
        uint64_t v8 = a2[1];
      }
      v8[(void)v7] = 32;
      ++a2[1];
    }
    unsigned int v13 = *(unsigned __int16 *)(v6 + 9);
    int v14 = (v13 >> 8) & 3;
    if (!v14) {
      goto LABEL_20;
    }
    if (v14 == 2)
    {
      if ((*(uint64_t (**)(uint64_t, char **))(*(void *)v6 + 8))(v6, a2)) {
        goto LABEL_20;
      }
      unsigned int v13 = *(unsigned __int16 *)(v6 + 9);
    }
    int v15 = (v13 >> 10) & 3;
    if (v15 && (v15 != 2 || !(*(unsigned int (**)(uint64_t, char **))(*(void *)v6 + 16))(v6, a2)))
    {
LABEL_27:
      if (v5) {
        unint64_t v22 = "&&";
      }
      else {
        unint64_t v22 = "&";
      }
      if (v5) {
        size_t v23 = 2;
      }
      else {
        size_t v23 = 1;
      }
      size_t v24 = *a2;
      unint64_t v25 = a2[1];
      size_t v26 = &v25[v23];
      size_t v27 = (size_t)a2[2];
      if ((unint64_t)&v25[v23] <= v27) {
        goto LABEL_39;
      }
      unint64_t v28 = 2 * v27;
      if (v28 <= (unint64_t)(v26 + 992)) {
        size_t v29 = (size_t)(v26 + 992);
      }
      else {
        size_t v29 = v28;
      }
      a2[2] = (char *)v29;
      size_t v24 = (char *)realloc(v24, v29);
      *a2 = v24;
      if (v24)
      {
        unint64_t v25 = a2[1];
LABEL_39:
        uint64_t result = (uint64_t)memcpy(&v25[(void)v24], v22, v23);
        a2[1] += v23;
        goto LABEL_40;
      }
LABEL_41:
      abort();
    }
LABEL_20:
    size_t v16 = *a2;
    unint64_t v17 = a2[1];
    unint64_t v18 = (unint64_t)a2[2];
    if ((unint64_t)(v17 + 1) > v18)
    {
      size_t v19 = (size_t)(v17 + 993);
      unint64_t v20 = 2 * v18;
      if (v20 <= v19) {
        size_t v21 = v19;
      }
      else {
        size_t v21 = v20;
      }
      a2[2] = (char *)v21;
      size_t v16 = (char *)realloc(v16, v21);
      *a2 = v16;
      if (!v16) {
        goto LABEL_41;
      }
      unint64_t v17 = a2[1];
    }
    v17[(void)v16] = 40;
    ++a2[1];
    goto LABEL_27;
  }
  return result;
}

uint64_t llvm::itanium_demangle::ReferenceType::printRight(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 28))
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 28) = 1;
    uint64_t result = llvm::itanium_demangle::ReferenceType::collapse(result);
    if (!v4)
    {
LABEL_18:
      *(unsigned char *)(v3 + 28) = 0;
      return result;
    }
    uint64_t v5 = v4;
    unsigned int v6 = *(unsigned __int16 *)(v4 + 9);
    int v7 = (v6 >> 8) & 3;
    if (!v7) {
      goto LABEL_10;
    }
    if (v7 == 2)
    {
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 8))(v4, a2)) {
        goto LABEL_10;
      }
      unsigned int v6 = *(unsigned __int16 *)(v5 + 9);
    }
    int v8 = (v6 >> 10) & 3;
    if (v8 && (v8 != 2 || !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, a2)))
    {
LABEL_17:
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, a2);
      goto LABEL_18;
    }
LABEL_10:
    unint64_t v9 = *(void **)a2;
    uint64_t v10 = *(void *)(a2 + 8);
    unint64_t v11 = *(void *)(a2 + 16);
    if (v10 + 1 > v11)
    {
      size_t v12 = v10 + 993;
      unint64_t v13 = 2 * v11;
      if (v13 <= v12) {
        size_t v14 = v12;
      }
      else {
        size_t v14 = v13;
      }
      *(void *)(a2 + 16) = v14;
      unint64_t v9 = realloc(v9, v14);
      *(void *)a2 = v9;
      if (!v9) {
        abort();
      }
      uint64_t v10 = *(void *)(a2 + 8);
    }
    *((unsigned char *)v9 + v10) = 41;
    ++*(void *)(a2 + 8);
    goto LABEL_17;
  }
  return result;
}

uint64_t llvm::itanium_demangle::ReferenceType::collapse(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 16);
  __ptr = (char *)v13;
  unint64_t v11 = (char *)v13;
  size_t v12 = (char *)&v14;
  memset(v13, 0, sizeof(v13));
  for (uint64_t i = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
        *(unsigned char *)(i + 8) == 13;
        uint64_t i = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (*(_DWORD *)(i + 24) < (signed int)v1) {
      unsigned int v1 = *(_DWORD *)(i + 24);
    }
    uint64_t v5 = v11;
    if (v11 == v12)
    {
      int64_t v6 = v11 - __ptr;
      if (__ptr == (char *)v13)
      {
        int v8 = (char *)malloc(2 * (v11 - __ptr));
        if (!v8) {
LABEL_20:
        }
          abort();
        int v7 = v8;
        if (v11 != (char *)v13) {
          memcpy(v8, v13, v6);
        }
        __ptr = v7;
      }
      else
      {
        int v7 = (char *)realloc(__ptr, 2 * (v11 - __ptr));
        __ptr = v7;
        if (!v7) {
          goto LABEL_20;
        }
      }
      uint64_t v5 = &v7[8 * (v6 >> 3)];
      size_t v12 = &v7[8 * (v6 >> 2)];
    }
    unint64_t v11 = v5 + 8;
    *(void *)uint64_t v5 = v4;
    if ((unint64_t)(v5 + 8 - __ptr) >= 9
      && v4 == *(void *)&__ptr[(((v11 - __ptr) >> 1) - 4) & 0xFFFFFFFFFFFFFFF8])
    {
      break;
    }
  }
  if (__ptr != (char *)v13) {
    free(__ptr);
  }
  return v1;
}

unint64_t mlir::detail::ValueImpl::debug_getType(mlir::detail::ValueImpl *this)
{
  return *((void *)this + 1) & 0xFFFFFFFFFFFFFFF8;
}

uint64_t mlir::detail::ValueImpl::debug_getKind(mlir::detail::ValueImpl *this)
{
  return *((_DWORD *)this + 2) & 7;
}

uint64_t mlir::Operation::debug_getOperands(mlir::Operation *this)
{
  if ((*((unsigned char *)this + 46) & 0x80) != 0) {
    return *((void *)this + 9);
  }
  else {
    return 0;
  }
}

uint64_t mlir::Operation::debug_getResults(mlir::Operation *this)
{
  if (*((_DWORD *)this + 9)) {
    return (uint64_t)this - 16;
  }
  else {
    return 0;
  }
}

unint64_t mlir::Operation::debug_getSuccessors(mlir::Operation *this)
{
  mlir::SuccessorRange::SuccessorRange(&v2, this);
  return v2;
}

unint64_t mlir::Operation::debug_getRegions(mlir::Operation *this)
{
  unint64_t v1 = *((unsigned int *)this + 11);
  if ((v1 & 0x7FFFFF) == 0) {
    return 0;
  }
  unint64_t v2 = (char *)this + 16 * ((v1 >> 23) & 1) + ((v1 >> 21) & 0x7F8) + 64;
  if ((unint64_t)v2 >= 0xFFFFFFFFFFFFFFF9) {
    __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
  }
  return ((unint64_t)(v2 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *((unsigned int *)this + 10);
}

GPU::RuntimeExecutionReport *GPU::RuntimeExecutionReport::RuntimeExecutionReport(GPU::RuntimeExecutionReport *this, ModuleOp a2)
{
  *(ModuleOp *)this = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = (char *)this + 56;
  *((void *)this + 6) = 0x600000000;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = (char *)this + 144;
  *((void *)this + 17) = 0x600000000;
  *((void *)this + 24) = 0;
  uint64_t v4 = this;
  mlir::detail::walk<mlir::ForwardIterator>(a2.state, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::RuntimeExecutionReport::RuntimeExecutionReport(mlir::ModuleOp)::$_0>, (uint64_t)&v4, 1);
  return this;
}

void sub_180CC9CD4()
{
  unint64_t v2 = *(void **)(v0 + 128);
  if (v2 != v1) {
    free(v2);
  }
  uint64_t v3 = *(unsigned int *)(v0 + 120);
  uint64_t v4 = *(llvm **)(v0 + 104);
  if (v3)
  {
    uint64_t v6 = 80 * v3;
    int v7 = (char *)v4 + 32;
    do
    {
      if (*((void *)v7 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v8 = (char *)*((void *)v7 - 2);
        if (v7 != v8) {
          free(v8);
        }
      }
      v7 += 80;
      v6 -= 80;
    }
    while (v6);
    uint64_t v4 = *(llvm **)(v0 + 104);
    uint64_t v5 = 80 * *(unsigned int *)(v0 + 120);
  }
  else
  {
    uint64_t v5 = 0;
  }
  llvm::deallocate_buffer(v4, (void *)v5);
}

llvm::raw_ostream *mlir::operator<<(llvm::raw_ostream *a1, mlir::Operation *a2)
{
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v6);
  uint64_t v4 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope((uint64_t)v6);
  mlir::Operation::print(a2, a1, v4);
  return a1;
}

uint64_t GPURegionRuntime::createRuntimeResources(GPURegionRuntime *this)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0x100000000;
  uint64_t v5 = &v7;
  unint64_t v2 = (mlir::ForwardIterator *)*((void *)this + 8);
  uint64_t v6 = (GPU::ANECompilerHelper *)&v5;
  int v7 = v9;
  mlir::detail::walk<mlir::ForwardIterator>(v2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN16GPURegionRuntime22createRuntimeResourcesEvE3__0NS1_9placement10RegionCallEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESM_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&v6, 1);
  if (v8)
  {
    WeakRetained = (char *)objc_loadWeakRetained((id *)this + 9);
    std::recursive_mutex::lock((std::recursive_mutex *)(WeakRetained + 200));

    GPU::ANECompilerHelper::get();
  }
  if (v7 != v9) {
    free(v7);
  }
  return 1;
}

void sub_180CC9F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::recursive_mutex::unlock(v11);
  if (a11 != v12)
  {
    free(a11);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

GPU::ANECompilerHelper **std::unique_ptr<GPU::ANECompilerHelper>::~unique_ptr[abi:ne180100](GPU::ANECompilerHelper **a1)
{
  unint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    GPU::ANECompilerHelper::~ANECompilerHelper(v2);
  }
  return a1;
}

mlir::GenericProgramPoint *GPURegionRuntime::initializeOps(mlir::ForwardIterator **this)
{
  unint64_t v2 = this;
  return mlir::detail::walk<mlir::ForwardIterator>(this[29], (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::initializeOps(void)::$_0>, (uint64_t)&v2, 1);
}

uint64_t GPURegionRuntime::initOp(GPURegionRuntime *this, mlir::Operation *a2, GPU::MPSGraphKernelDAG *a3)
{
  unint64_t v25 = *(void ***)(*((void *)a2 + 6) + 8);
  AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v25);
  size_t v6 = strlen(AttrData);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  int v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    unint64_t v24 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v24) = v6;
  uint64_t v8 = __dst;
  if (v6) {
LABEL_8:
  }
    memmove(v8, AttrData, (size_t)v7);
  *((unsigned char *)v7 + (void)v8) = 0;
  unint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::find<std::string>((void *)this + 1, (uint64_t)__dst);
  if (!v11) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  switch(*((_DWORD *)v11 + 10))
  {
    case 1:
      GPURegionRuntime::createOp<GPU::AbsoluteOpHandler>();
    case 2:
      GPURegionRuntime::createOp<GPU::AbsoluteSquareOpHandler>();
    case 3:
      GPURegionRuntime::createOp<GPU::ACosOpHandler>();
    case 4:
      GPURegionRuntime::createOp<GPU::ACoshOpHandler>();
    case 5:
      GPURegionRuntime::createOp<GPU::AddOpHandler>();
    case 6:
      GPURegionRuntime::createOp<GPU::AndOpHandler>();
    case 7:
      GPURegionRuntime::createOp<GPU::ASinOpHandler>();
    case 8:
      GPURegionRuntime::createOp<GPU::ASinhOpHandler>();
    case 9:
      GPURegionRuntime::createOp<GPU::ATanOpHandler>();
    case 0xA:
      GPURegionRuntime::createOp<GPU::ATan2OpHandler>();
    case 0xB:
      GPURegionRuntime::createOp<GPU::ATanhOpHandler>();
    case 0xC:
      GPURegionRuntime::createOp<GPU::AssignVariableOpHandler>();
    case 0xD:
      GPURegionRuntime::createOp<GPU::BandPartOpHandler>();
    case 0xE:
      GPURegionRuntime::createOp<GPU::BatchToSpaceOpHandler>();
    case 0x10:
      GPURegionRuntime::createOp<GPU::BitwiseAndOpHandler>();
    case 0x11:
      GPURegionRuntime::createOp<GPU::BitwiseLeftShiftOpHandler>();
    case 0x12:
      GPURegionRuntime::createOp<GPU::BitwiseNotOpHandler>();
    case 0x13:
      GPURegionRuntime::createOp<GPU::BitwiseOrOpHandler>();
    case 0x14:
      GPURegionRuntime::createOp<GPU::BitwisePopcountOpHandler>();
    case 0x15:
      GPURegionRuntime::createOp<GPU::BitwiseRightShiftOpHandler>();
    case 0x16:
      GPURegionRuntime::createOp<GPU::BitwiseXorOpHandler>();
    case 0x17:
      GPURegionRuntime::createOp<GPU::BroadcastGradientArgsOpHandler>();
    case 0x18:
      GPURegionRuntime::createOp<GPU::BroadcastToOpHandler>();
    case 0x19:
      GPURegionRuntime::createOp<GPU::CallOpHandler>();
    case 0x1A:
      GPURegionRuntime::createOp<GPU::CastOpHandler>();
    case 0x1B:
      GPURegionRuntime::createOp<GPU::CeilOpHandler>();
    case 0x1C:
      GPURegionRuntime::createOp<GPU::ClampOpHandler>();
    case 0x1D:
      GPURegionRuntime::createOp<GPU::ColToImOpHandler>();
    case 0x1E:
      GPURegionRuntime::createOp<GPU::ConcatOpHandler>();
    case 0x1F:
      GPURegionRuntime::createOp<GPU::ConditionOpHandler>();
    case 0x20:
      GPURegionRuntime::createOp<GPU::ConjugateOpHandler>();
    case 0x21:
      GPURegionRuntime::createOp<GPU::Conv2DOpHandler>();
    case 0x22:
      GPURegionRuntime::createOp<GPU::Conv2DDataGradientOpHandler>();
    case 0x23:
      GPURegionRuntime::createOp<GPU::Conv2DWeightsGradientOpHandler>();
    case 0x24:
      GPURegionRuntime::createOp<GPU::Conv3DOpHandler>();
    case 0x25:
      GPURegionRuntime::createOp<GPU::Conv3DDataGradientOpHandler>();
    case 0x26:
      GPURegionRuntime::createOp<GPU::Conv3DWeightsGradientOpHandler>();
    case 0x27:
      GPURegionRuntime::createOp<GPU::ConstantOpHandler>();
    case 0x28:
      GPURegionRuntime::createOp<GPU::CosOpHandler>();
    case 0x29:
      GPURegionRuntime::createOp<GPU::CoshOpHandler>();
    case 0x2A:
      GPURegionRuntime::createOp<GPU::CostVolumeOpHandler>();
    case 0x2B:
      GPURegionRuntime::createOp<GPU::CreateComplexOpHandler>();
    case 0x2C:
      GPURegionRuntime::createOp<GPU::CreateTextureTensorOpHandler>();
    case 0x2D:
      GPURegionRuntime::createOp<GPU::CropOpHandler>();
    case 0x2E:
      GPURegionRuntime::createOp<GPU::CropResizeOpHandler>();
    case 0x2F:
      GPURegionRuntime::createOp<GPU::CumulativeSumOpHandler>();
    case 0x30:
      GPURegionRuntime::createOp<GPU::CumulativeProductOpHandler>();
    case 0x31:
      GPURegionRuntime::createOp<GPU::CumulativeMaximumOpHandler>();
    case 0x32:
      GPURegionRuntime::createOp<GPU::CumulativeMinimumOpHandler>();
    case 0x33:
      GPURegionRuntime::createOp<GPU::DepthToSpace2DOpHandler>();
    case 0x34:
      GPURegionRuntime::createOp<GPU::DepthwiseConv2DOpHandler>();
    case 0x35:
      GPURegionRuntime::createOp<GPU::DepthwiseConv2DDataGradientOpHandler>();
    case 0x36:
      GPURegionRuntime::createOp<GPU::DepthwiseConv2DWeightsGradientOpHandler>();
    case 0x37:
      GPURegionRuntime::createOp<GPU::DepthwiseConv3DOpHandler>();
    case 0x38:
      GPURegionRuntime::createOp<GPU::DepthwiseConv3DDataGradientOpHandler>();
    case 0x39:
      GPURegionRuntime::createOp<GPU::DepthwiseConv3DWeightsGradientOpHandler>();
    case 0x3A:
      GPURegionRuntime::createOp<GPU::DequantizeLutOpHandler>();
    case 0x3B:
      GPURegionRuntime::createOp<GPU::DequantizeOpHandler>();
    case 0x3C:
      GPURegionRuntime::createOp<GPU::DimensionSizeOpHandler>();
    case 0x3D:
      GPURegionRuntime::createOp<GPU::DivideOpHandler>();
    case 0x3E:
      GPURegionRuntime::createOp<GPU::DynamicShapeCastOpHandler>();
    case 0x40:
      GPURegionRuntime::createOp<GPU::EqualToOpHandler>();
    case 0x41:
      GPURegionRuntime::createOp<GPU::ErfOpHandler>();
    case 0x42:
      GPURegionRuntime::createOp<GPU::ExpandDimsOpHandler>();
    case 0x43:
      GPURegionRuntime::createOp<GPU::ExponentOpHandler>();
    case 0x44:
      GPURegionRuntime::createOp<GPU::ExponentBase2OpHandler>();
    case 0x45:
      GPURegionRuntime::createOp<GPU::ExponentBase10OpHandler>();
    case 0x46:
      GPURegionRuntime::createOp<GPU::ExtractOpHandler>();
    case 0x47:
      GPURegionRuntime::createOp<GPU::FFTOpHandler>();
    case 0x48:
      GPURegionRuntime::createOp<GPU::FFT_RToCOpHandler>();
    case 0x49:
      GPURegionRuntime::createOp<GPU::FFT_CToROpHandler>();
    case 0x4A:
      GPURegionRuntime::createOp<GPU::Flatten2DOpHandler>();
    case 0x4B:
      GPURegionRuntime::createOp<GPU::FloorOpHandler>();
    case 0x4C:
      GPURegionRuntime::createOp<GPU::ForOpHandler>();
    case 0x4D:
      GPURegionRuntime::createOp<GPU::FPToIntClampedOpHandler>();
    case 0x4E:
      GPURegionRuntime::createOp<GPU::GatherOpHandler>();
    case 0x4F:
      GPURegionRuntime::createOp<GPU::GatherAlongAxisOpHandler>();
    case 0x50:
      GPURegionRuntime::createOp<GPU::GatherNDOpHandler>();
    case 0x51:
      GPURegionRuntime::createOp<GPU::GetCoordOpHandler>();
    case 0x52:
      GPURegionRuntime::createOp<GPU::GreaterThanOpHandler>();
    case 0x53:
      GPURegionRuntime::createOp<GPU::GreaterThanOrEqualToOpHandler>();
    case 0x54:
      GPURegionRuntime::createOp<GPU::GRUOpHandler>();
    case 0x55:
      GPURegionRuntime::createOp<GPU::GRUGradientOpHandler>();
    case 0x56:
      GPURegionRuntime::createOp<GPU::HammingDistanceOpHandler>();
    case 0x57:
      GPURegionRuntime::createOp<GPU::IdentityOpHandler>();
    case 0x58:
      GPURegionRuntime::createOp<GPU::IfOpHandler>();
    case 0x59:
      GPURegionRuntime::createOp<GPU::ImToColOpHandler>();
    case 0x5A:
      GPURegionRuntime::createOp<GPU::ImaginaryPartOpHandler>();
    case 0x5B:
      GPURegionRuntime::createOp<GPU::IsFiniteOpHandler>();
    case 0x5C:
      GPURegionRuntime::createOp<GPU::IsInfiniteOpHandler>();
    case 0x5D:
      GPURegionRuntime::createOp<GPU::IsNaNOpHandler>();
    case 0x5F:
      GPURegionRuntime::createOp<GPU::LessThanOpHandler>();
    case 0x60:
      GPURegionRuntime::createOp<GPU::LessThanOrEqualToOpHandler>();
    case 0x61:
      GPURegionRuntime::createOp<GPU::LocalConvolutionOpHandler>();
    case 0x62:
      GPURegionRuntime::createOp<GPU::LocalConvolutionDataGradientOpHandler>();
    case 0x63:
      GPURegionRuntime::createOp<GPU::LocalConvolutionWeightGradientOpHandler>();
    case 0x64:
      GPURegionRuntime::createOp<GPU::LogarithmOpHandler>();
    case 0x65:
      GPURegionRuntime::createOp<GPU::LogarithmBase2OpHandler>();
    case 0x66:
      GPURegionRuntime::createOp<GPU::LogarithmBase10OpHandler>();
    case 0x67:
      GPURegionRuntime::createOp<GPU::LSTMOpHandler>();
    case 0x68:
      GPURegionRuntime::createOp<GPU::LSTMGradientOpHandler>();
    case 0x69:
      GPURegionRuntime::createOp<GPU::MakeListOpHandler>();
    case 0x6A:
      GPURegionRuntime::createOp<GPU::MaterializeSparseTensorOpHandler>();
    case 0x6B:
      GPURegionRuntime::createOp<GPU::MatMulOpHandler>();
    case 0x6C:
      GPURegionRuntime::createOp<GPU::MatrixDecompositionLUOpHandler>();
    case 0x6D:
      GPURegionRuntime::createOp<GPU::MatrixInverseOpHandler>();
    case 0x6E:
      GPURegionRuntime::createOp<GPU::MatrixSolverLUOpHandler>();
    case 0x6F:
      GPURegionRuntime::createOp<GPU::MaximumOpHandler>();
    case 0x70:
      GPURegionRuntime::createOp<GPU::MemrefToTensorOpHandler>();
    case 0x71:
      GPURegionRuntime::createOp<GPU::MinimumOpHandler>();
    case 0x72:
      GPURegionRuntime::createOp<GPU::ModuloOpHandler>();
    case 0x73:
      GPURegionRuntime::createOp<GPU::MultiplyOpHandler>();
    case 0x74:
      GPURegionRuntime::createOp<GPU::NandOpHandler>();
    case 0x75:
      GPURegionRuntime::createOp<GPU::NegativeOpHandler>();
    case 0x76:
      GPURegionRuntime::createOp<GPU::NorOpHandler>();
    case 0x78:
      GPURegionRuntime::createOp<GPU::NotOpHandler>();
    case 0x79:
      GPURegionRuntime::createOp<GPU::NotEqualToOpHandler>();
    case 0x7A:
      GPURegionRuntime::createOp<GPU::OneHotOpHandler>();
    case 0x7B:
      GPURegionRuntime::createOp<GPU::OrOpHandler>();
    case 0x7C:
      GPURegionRuntime::createOp<GPU::PadOpHandler>();
    case 0x7D:
      GPURegionRuntime::createOp<GPU::PadGradientOpHandler>();
    case 0x7E:
      GPURegionRuntime::createOp<GPU::PermuteOpHandler>();
    case 0x7F:
      GPURegionRuntime::createOp<GPU::PoolAvgOpHandler>();
    case 0x80:
      GPURegionRuntime::createOp<GPU::PoolAvgGradientOpHandler>();
    case 0x81:
      GPURegionRuntime::createOp<GPU::PoolL2NormOpHandler>();
    case 0x82:
      GPURegionRuntime::createOp<GPU::PoolL2NormGradientOpHandler>();
    case 0x83:
      GPURegionRuntime::createOp<GPU::PoolMaxOpHandler>();
    case 0x85:
      GPURegionRuntime::createOp<GPU::PoolMaxGradientOpHandler>();
    case 0x86:
      GPURegionRuntime::createOp<GPU::PowerOpHandler>();
    case 0x87:
      GPURegionRuntime::createOp<GPU::PruneOpHandler>();
    case 0x88:
      GPURegionRuntime::createOp<GPU::PruneGradientOpHandler>();
    case 0x8A:
      GPURegionRuntime::createOp<GPU::QuantizedGatherOpHandler>();
    case 0x8B:
      GPURegionRuntime::createOp<GPU::RandomUniformOpHandler>();
    case 0x8C:
      GPURegionRuntime::createOp<GPU::RandomTruncatedNormalOpHandler>();
    case 0x8D:
      GPURegionRuntime::createOp<GPU::RandomNormalOpHandler>();
    case 0x8E:
      GPURegionRuntime::createOp<GPU::RankOpHandler>();
    case 0x8F:
      GPURegionRuntime::createOp<GPU::ReadDataFromFileOpHandler>();
    case 0x90:
      GPURegionRuntime::createOp<GPU::ReadVariableOpHandler>();
    case 0x91:
      GPURegionRuntime::createOp<GPU::RealPartOpHandler>();
    case 0x92:
      GPURegionRuntime::createOp<GPU::ReciprocalOpHandler>();
    case 0x93:
      GPURegionRuntime::createOp<GPU::ReductionAndOpHandler>();
    case 0x94:
      GPURegionRuntime::createOp<GPU::ReductionArgMaxOpHandler>();
    case 0x95:
      GPURegionRuntime::createOp<GPU::ReductionArgMinOpHandler>();
    case 0x96:
      GPURegionRuntime::createOp<GPU::ReductionMaxOpHandler>();
    case 0x98:
      GPURegionRuntime::createOp<GPU::ReductionMinOpHandler>();
    case 0x99:
      GPURegionRuntime::createOp<GPU::ReductionOrOpHandler>();
    case 0x9A:
      GPURegionRuntime::createOp<GPU::ReductionProdOpHandler>();
    case 0x9B:
      GPURegionRuntime::createOp<GPU::ReductionSumOpHandler>();
    case 0x9D:
      GPURegionRuntime::createOp<GPU::RegionCallOpHandler>();
    case 0x9E:
      GPURegionRuntime::createOp<GPU::RegionReturnOpHandler>();
    case 0x9F:
      GPURegionRuntime::createOp<GPU::ReinterpretCastOpHandler>();
    case 0xA2:
      GPURegionRuntime::createOp<GPU::ReshapeOpHandler>();
    case 0xA3:
      GPURegionRuntime::createOp<GPU::ResizeOpHandler>();
    case 0xA4:
      GPURegionRuntime::createOp<GPU::ResizeGradientOpHandler>();
    case 0xA5:
      GPURegionRuntime::createOp<GPU::ReturnOpHandler>();
    case 0xA6:
      GPURegionRuntime::createOp<GPU::ReturnStitchedOpHandler>();
    case 0xA7:
      GPURegionRuntime::createOp<GPU::ReverseOpHandler>();
    case 0xA8:
      GPURegionRuntime::createOp<GPU::ReciprocalSquareRootOpHandler>();
    case 0xA9:
      GPURegionRuntime::createOp<GPU::RintOpHandler>();
    case 0xAA:
      GPURegionRuntime::createOp<GPU::RMSNormOpHandler>();
    case 0xAB:
      GPURegionRuntime::createOp<GPU::RoundOpHandler>();
    case 0xAC:
      GPURegionRuntime::createOp<GPU::SampleGridOpHandler>();
    case 0xAD:
      GPURegionRuntime::createOp<GPU::SampleGridDataGradientOpHandler>();
    case 0xAE:
      GPURegionRuntime::createOp<GPU::ScatterOpHandler>();
    case 0xAF:
      GPURegionRuntime::createOp<GPU::ScatterAlongAxisOpHandler>();
    case 0xB0:
      GPURegionRuntime::createOp<GPU::ScatterNDOpHandler>();
    case 0xB1:
      GPURegionRuntime::createOp<GPU::SelectOpHandler>();
    case 0xB2:
      GPURegionRuntime::createOp<GPU::ShapeOpHandler>();
    case 0xB4:
      GPURegionRuntime::createOp<GPU::SignOpHandler>();
    case 0xB5:
      GPURegionRuntime::createOp<GPU::SignbitOpHandler>();
    case 0xB6:
      GPURegionRuntime::createOp<GPU::SinOpHandler>();
    case 0xB7:
      GPURegionRuntime::createOp<GPU::SingleGateRNNOpHandler>();
    case 0xB8:
      GPURegionRuntime::createOp<GPU::SingleGateRNNGradientOpHandler>();
    case 0xB9:
      GPURegionRuntime::createOp<GPU::SinhOpHandler>();
    case 0xBA:
      GPURegionRuntime::createOp<GPU::SizeOpHandler>();
    case 0xBB:
      GPURegionRuntime::createOp<GPU::SliceOpHandler>();
    case 0xBC:
      GPURegionRuntime::createOp<GPU::SoftmaxOpHandler>();
    case 0xBD:
      GPURegionRuntime::createOp<GPU::SortOpHandler>();
    case 0xBF:
      GPURegionRuntime::createOp<GPU::SpaceToBatchOpHandler>();
    case 0xC0:
      GPURegionRuntime::createOp<GPU::SpaceToDepth2DOpHandler>();
    case 0xC1:
      GPURegionRuntime::createOp<GPU::SparseDenseMatMulOpHandler>();
    case 0xC2:
      GPURegionRuntime::createOp<GPU::SplitOpHandler>();
    case 0xC3:
      GPURegionRuntime::createOp<GPU::SquareOpHandler>();
    case 0xC4:
      GPURegionRuntime::createOp<GPU::SquareRootOpHandler>();
    case 0xC5:
      GPURegionRuntime::createOp<GPU::SqueezeOpHandler>();
    case 0xC6:
      GPURegionRuntime::createOp<GPU::StencilOpHandler>();
    case 0xC7:
      GPURegionRuntime::createOp<GPU::StitchedOpHandler>();
    case 0xC8:
      GPURegionRuntime::createOp<GPU::StridedSliceOpHandler>();
    case 0xC9:
      GPURegionRuntime::createOp<GPU::StridedSliceGradientOpHandler>();
    case 0xCA:
      GPURegionRuntime::createOp<GPU::StridedSliceUpdateOpHandler>();
    case 0xCB:
      GPURegionRuntime::createOp<GPU::SubtractOpHandler>();
    case 0xCD:
      GPURegionRuntime::createOp<GPU::TanOpHandler>();
    case 0xCE:
      GPURegionRuntime::createOp<GPU::TanhOpHandler>();
    case 0xCF:
      GPURegionRuntime::createOp<GPU::FromElementsOpHandler>();
    case 0xD0:
      GPURegionRuntime::createOp<GPU::ListPopBackOpHandler>();
    case 0xD1:
      GPURegionRuntime::createOp<GPU::ListPushBackOpHandler>();
    case 0xD2:
      GPURegionRuntime::createOp<GPU::ScaledDotProductAttentionOpHandler>();
    case 0xD3:
      GPURegionRuntime::createOp<GPU::TensorToMemrefOpHandler>();
    case 0xD4:
      GPURegionRuntime::createOp<GPU::TileOpHandler>();
    case 0xD5:
      GPURegionRuntime::createOp<GPU::TileGradientOpHandler>();
    case 0xD6:
      GPURegionRuntime::createOp<GPU::TopKOpHandler>();
    case 0xD7:
      GPURegionRuntime::createOp<GPU::TopKGradientOpHandler>();
    case 0xD8:
      GPURegionRuntime::createOp<GPU::TransposeOpHandler>();
    case 0xD9:
      GPURegionRuntime::createOp<GPU::TypeConstraintOpHandler>();
    case 0xDA:
      GPURegionRuntime::createOp<GPU::UpdateRandomStateOpHandler>();
    case 0xDB:
      GPURegionRuntime::createOp<GPU::VarHandleOpHandler>();
    case 0xDC:
      GPURegionRuntime::createOp<GPU::VariableFromTensorOpHandler>();
    case 0xDD:
      GPURegionRuntime::createOp<GPU::WhileOpHandler>();
    case 0xDE:
      GPURegionRuntime::createOp<GPU::XorOpHandler>();
    case 0xDF:
      GPURegionRuntime::createOp<GPU::XnorOpHandler>();
    case 0xE0:
      GPURegionRuntime::createOp<GPU::YieldOpHandler>();
    case 0xE1:
      GPURegionRuntime::createOp<GPU::QuantizedMatMulOpHandler>();
    default:
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ReshapeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReshapeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a2);
      uint64_t v13 = v12;
      if (!v12) {
        goto LABEL_232;
      }
      if ((*(unsigned char *)(v12 + 46) & 0x80) == 0)
      {
        size_t v19 = "hasOperandStorage && \"expected operation to have operand storage\"";
        int v20 = 960;
        size_t v21 = "Operation.h";
        unint64_t v22 = "getOperandStorage";
        goto LABEL_237;
      }
      if (!*(_DWORD *)(v12 + 68))
      {
        size_t v19 = "Index < this->size() && \"Invalid index!\"";
        int v20 = 443;
        size_t v21 = "ArrayRef.h";
        unint64_t v22 = "operator[]";
        goto LABEL_237;
      }
      unint64_t v25 = *(void ***)(*(void *)(v12 + 72) + 24);
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v25);
      if (DefiningOp)
      {
        if (llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible(DefiningOp))
        {
          int v15 = v25;
          if (*v25)
          {
            if (!**v25)
            {
              if (*(_DWORD *)(v13 + 36))
              {
                unint64_t v16 = v13 - 16;
                unint64_t v17 = (char *)this + 608;
                std::__hash_table<std::__hash_value_type<void *,void *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,void *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,void *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,void *>>>::__emplace_unique_key_args<void *,std::pair<void *,void *> &>((uint64_t)v17, (unint64_t)v25, (uint64_t)v25, v16);
                std::__hash_table<std::__hash_value_type<void *,void *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,void *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,void *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,void *>>>::__emplace_unique_key_args<void *,std::pair<void *,void *> &>((uint64_t)v17, v16, v16, (uint64_t)v15);
                goto LABEL_232;
              }
              size_t v19 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
              int v20 = 984;
              size_t v21 = "Operation.h";
              unint64_t v22 = "getOpResultImpl";
LABEL_237:
              __assert_rtn(v22, v21, v20, v19);
            }
          }
        }
      }
LABEL_232:
      ((void (*)(void))*MEMORY[0])(0);
      if (SHIBYTE(v24) < 0) {
        operator delete(__dst[0]);
      }
      return 0;
  }
}

void sub_180CCB330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GPURegionRuntime::createOp<GPU::AbsoluteOpHandler>()
{
}

void sub_180CCB9DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::AbsoluteSquareOpHandler>()
{
}

void sub_180CCBDB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ACosOpHandler>()
{
}

void sub_180CCC194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ACoshOpHandler>()
{
}

void sub_180CCC570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::AddOpHandler>()
{
}

void sub_180CCC94C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::AndOpHandler>()
{
}

void sub_180CCCD28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ASinOpHandler>()
{
}

void sub_180CCD104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ASinhOpHandler>()
{
}

void sub_180CCD4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ATanOpHandler>()
{
}

void sub_180CCD8BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ATan2OpHandler>()
{
}

void sub_180CCDC98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ATanhOpHandler>()
{
}

void sub_180CCE074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::AssignVariableOpHandler>()
{
}

void sub_180CCE434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BandPartOpHandler>()
{
}

void sub_180CCE810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseAndOpHandler>()
{
}

void sub_180CCEBEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseLeftShiftOpHandler>()
{
}

void sub_180CCEFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseNotOpHandler>()
{
}

void sub_180CCF3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseOrOpHandler>()
{
}

void sub_180CCF780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwisePopcountOpHandler>()
{
}

void sub_180CCFB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseRightShiftOpHandler>()
{
}

void sub_180CCFF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BitwiseXorOpHandler>()
{
}

void sub_180CD0314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BatchToSpaceOpHandler>()
{
}

void sub_180CD06F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BroadcastGradientArgsOpHandler>()
{
}

void sub_180CD0ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::BroadcastToOpHandler>()
{
}

void sub_180CD0E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CallOpHandler>()
{
}

void sub_180CD124C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CastOpHandler>()
{
}

void sub_180CD1628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CeilOpHandler>()
{
}

void sub_180CD1A04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ClampOpHandler>()
{
}

void sub_180CD1DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ColToImOpHandler>()
{
}

void sub_180CD21BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ConcatOpHandler>()
{
}

void sub_180CD257C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ConditionOpHandler>()
{
}

void sub_180CD293C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ConjugateOpHandler>()
{
}

void sub_180CD2D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv2DOpHandler>()
{
}

void sub_180CD3108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv2DDataGradientOpHandler>()
{
}

void sub_180CD3534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv2DWeightsGradientOpHandler>()
{
}

void sub_180CD3930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv3DOpHandler>()
{
}

void sub_180CD3D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv3DDataGradientOpHandler>()
{
}

void sub_180CD4144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Conv3DWeightsGradientOpHandler>()
{
}

void sub_180CD4540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ConstantOpHandler>()
{
}

void sub_180CD4930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CosOpHandler>()
{
}

void sub_180CD4D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CoshOpHandler>()
{
}

void sub_180CD50E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CostVolumeOpHandler>()
{
}

void sub_180CD54F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CreateComplexOpHandler>()
{
}

void sub_180CD58DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CreateTextureTensorOpHandler>()
{
}

void sub_180CD5C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CropOpHandler>()
{
}

void sub_180CD6078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CropResizeOpHandler>()
{
}

void sub_180CD6438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CumulativeSumOpHandler>()
{
}

void sub_180CD6814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CumulativeProductOpHandler>()
{
}

void sub_180CD6BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CumulativeMaximumOpHandler>()
{
}

void sub_180CD6FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::CumulativeMinimumOpHandler>()
{
}

void sub_180CD73A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthToSpace2DOpHandler>()
{
}

void sub_180CD7784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv2DOpHandler>()
{
}

void sub_180CD7B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv2DDataGradientOpHandler>()
{
}

void sub_180CD7F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv2DWeightsGradientOpHandler>()
{
}

void sub_180CD8318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv3DOpHandler>()
{
}

void sub_180CD8708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv3DDataGradientOpHandler>()
{
}

void sub_180CD8B24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DepthwiseConv3DWeightsGradientOpHandler>()
{
}

void sub_180CD8F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DequantizeLutOpHandler>()
{
}

void sub_180CD92C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DequantizeOpHandler>()
{
}

void sub_180CD9680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DimensionSizeOpHandler>()
{
}

void sub_180CD9A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DivideOpHandler>()
{
}

void sub_180CD9E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::DynamicShapeCastOpHandler>()
{
}

void sub_180CDA1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ErfOpHandler>()
{
}

void sub_180CDA5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::EqualToOpHandler>()
{
}

void sub_180CDA9B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ExpandDimsOpHandler>()
{
}

void sub_180CDAD8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ExponentOpHandler>()
{
}

void sub_180CDB168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ExponentBase2OpHandler>()
{
}

void sub_180CDB544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ExponentBase10OpHandler>()
{
}

void sub_180CDB920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ExtractOpHandler>()
{
}

void sub_180CDBCE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FFTOpHandler>()
{
}

void sub_180CDC0A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FFT_RToCOpHandler>()
{
}

void sub_180CDC460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FFT_CToROpHandler>()
{
}

void sub_180CDC820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::Flatten2DOpHandler>()
{
}

void sub_180CDCBFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FloorOpHandler>()
{
}

void sub_180CDCFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ForOpHandler>()
{
}

void sub_180CDD398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FPToIntClampedOpHandler>()
{
}

void sub_180CDD774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GatherOpHandler>()
{
}

void sub_180CDDB7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GatherAlongAxisOpHandler>()
{
}

void sub_180CDDF94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GatherNDOpHandler>()
{
}

void sub_180CDE3AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GetCoordOpHandler>()
{
}

void sub_180CDE79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GreaterThanOpHandler>()
{
}

void sub_180CDEB78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GreaterThanOrEqualToOpHandler>()
{
}

void sub_180CDEF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GRUOpHandler>()
{
}

void sub_180CDF314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::GRUGradientOpHandler>()
{
}

void sub_180CDF6D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::HammingDistanceOpHandler>()
{
}

void sub_180CDFADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::IdentityOpHandler>()
{
}

void sub_180CDFEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::IfOpHandler>()
{
}

void sub_180CE026C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ImaginaryPartOpHandler>()
{
}

void sub_180CE0648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ImToColOpHandler>()
{
}

void sub_180CE0A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::IsFiniteOpHandler>()
{
}

void sub_180CE0E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::IsInfiniteOpHandler>()
{
}

void sub_180CE11DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::IsNaNOpHandler>()
{
}

void sub_180CE15B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LessThanOpHandler>()
{
}

void sub_180CE1994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LessThanOrEqualToOpHandler>()
{
}

void sub_180CE1D70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LocalConvolutionOpHandler>()
{
}

void sub_180CE2178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LocalConvolutionDataGradientOpHandler>()
{
}

void sub_180CE2548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LocalConvolutionWeightGradientOpHandler>()
{
}

void sub_180CE2908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LogarithmOpHandler>()
{
}

void sub_180CE2CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LogarithmBase2OpHandler>()
{
}

void sub_180CE30C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LogarithmBase10OpHandler>()
{
}

void sub_180CE349C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LSTMOpHandler>()
{
}

void sub_180CE385C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::LSTMGradientOpHandler>()
{
}

void sub_180CE3C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MakeListOpHandler>()
{
}

void sub_180CE3FFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MaterializeSparseTensorOpHandler>()
{
}

void sub_180CE43D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MatMulOpHandler>()
{
}

void sub_180CE4798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MatrixDecompositionLUOpHandler>()
{
}

void sub_180CE4B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MatrixInverseOpHandler>()
{
}

void sub_180CE4F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MatrixSolverLUOpHandler>()
{
}

void sub_180CE52D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MaximumOpHandler>()
{
}

void sub_180CE56B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MemrefToTensorOpHandler>()
{
}

void sub_180CE5A74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MinimumOpHandler>()
{
}

void sub_180CE5E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ModuloOpHandler>()
{
}

void sub_180CE622C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::MultiplyOpHandler>()
{
}

void sub_180CE6608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::NandOpHandler>()
{
}

void sub_180CE69E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::NegativeOpHandler>()
{
}

void sub_180CE6DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::NorOpHandler>()
{
}

void sub_180CE719C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::NotOpHandler>()
{
}

void sub_180CE7578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::NotEqualToOpHandler>()
{
}

void sub_180CE7954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::OneHotOpHandler>()
{
}

void sub_180CE7D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::OrOpHandler>()
{
}

void sub_180CE80F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PadOpHandler>()
{
}

void sub_180CE84B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PadGradientOpHandler>()
{
}

void sub_180CE88A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PermuteOpHandler>()
{
}

void sub_180CE8C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolAvgOpHandler>()
{
}

void sub_180CE9084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolAvgGradientOpHandler>()
{
}

void sub_180CE949C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolL2NormOpHandler>()
{
}

void sub_180CE98B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolL2NormGradientOpHandler>()
{
}

void sub_180CE9CCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolMaxOpHandler>()
{
}

void sub_180CEA09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PoolMaxGradientOpHandler>()
{
}

void sub_180CEA4A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PowerOpHandler>()
{
}

void sub_180CEA890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PruneOpHandler>()
{
}

void sub_180CEAC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::PruneGradientOpHandler>()
{
}

void sub_180CEB010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::QuantizedGatherOpHandler>()
{
}

void sub_180CEB3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RandomUniformOpHandler>()
{
}

void sub_180CEB7D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RandomTruncatedNormalOpHandler>()
{
}

void sub_180CEBBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RandomNormalOpHandler>()
{
}

void sub_180CEC008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RankOpHandler>()
{
}

void sub_180CEC3F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RealPartOpHandler>()
{
}

void sub_180CEC7D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReadDataFromFileOpHandler>()
{
}

void sub_180CECB90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReadVariableOpHandler>()
{
}

void sub_180CECF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReciprocalOpHandler>()
{
}

void sub_180CED32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionAndOpHandler>()
{
}

void sub_180CED708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionArgMaxOpHandler>()
{
}

void sub_180CEDAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionArgMinOpHandler>()
{
}

void sub_180CEDEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionMaxOpHandler>()
{
}

void sub_180CEE29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionMinOpHandler>()
{
}

void sub_180CEE678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionProdOpHandler>()
{
}

void sub_180CEEA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionOrOpHandler>()
{
}

void sub_180CEEE30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReductionSumOpHandler>()
{
}

void sub_180CEF20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RegionCallOpHandler>()
{
}

void sub_180CEF5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RegionReturnOpHandler>()
{
}

void sub_180CEF9A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReinterpretCastOpHandler>()
{
}

void sub_180CEFD68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReshapeOpHandler>()
{
}

void sub_180CF0144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ResizeOpHandler>()
{
}

void sub_180CF054C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ResizeGradientOpHandler>()
{
}

void sub_180CF0964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReturnOpHandler>()
{
}

void sub_180CF0D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReturnStitchedOpHandler>()
{
}

void sub_180CF1110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReverseOpHandler>()
{
}

void sub_180CF14D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ReciprocalSquareRootOpHandler>()
{
}

void sub_180CF18AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RintOpHandler>()
{
}

void sub_180CF1C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RMSNormOpHandler>()
{
}

void sub_180CF2048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::RoundOpHandler>()
{
}

void sub_180CF2424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SampleGridOpHandler>()
{
}

void sub_180CF282C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SampleGridDataGradientOpHandler>()
{
}

void sub_180CF2BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ScaledDotProductAttentionOpHandler>()
{
}

void sub_180CF2FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ScatterOpHandler>()
{
}

void sub_180CF3398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ScatterAlongAxisOpHandler>()
{
}

void sub_180CF3774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ScatterNDOpHandler>()
{
}

void sub_180CF3B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SelectOpHandler>()
{
}

void sub_180CF3F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ShapeOpHandler>()
{
}

void sub_180CF4308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SignOpHandler>()
{
}

void sub_180CF46E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SignbitOpHandler>()
{
}

void sub_180CF4AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SinOpHandler>()
{
}

void sub_180CF4E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SingleGateRNNOpHandler>()
{
}

void sub_180CF525C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SingleGateRNNGradientOpHandler>()
{
}

void sub_180CF561C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SinhOpHandler>()
{
}

void sub_180CF59F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SizeOpHandler>()
{
}

void sub_180CF5DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SliceOpHandler>()
{
}

void sub_180CF61B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SoftmaxOpHandler>()
{
}

void sub_180CF6570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SortOpHandler>()
{
}

void sub_180CF6930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SpaceToBatchOpHandler>()
{
}

void sub_180CF6D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SpaceToDepth2DOpHandler>()
{
}

void sub_180CF70E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SparseDenseMatMulOpHandler>()
{
}

void sub_180CF74C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SplitOpHandler>()
{
}

void sub_180CF78A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SquareOpHandler>()
{
}

void sub_180CF7C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SquareRootOpHandler>()
{
}

void sub_180CF8058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SqueezeOpHandler>()
{
}

void sub_180CF8434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::StencilOpHandler>()
{
}

void sub_180CF883C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::StitchedOpHandler>()
{
}

void sub_180CF8C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::StridedSliceOpHandler>()
{
}

void sub_180CF8FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::StridedSliceGradientOpHandler>()
{
}

void sub_180CF938C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::StridedSliceUpdateOpHandler>()
{
}

void sub_180CF974C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::SubtractOpHandler>()
{
}

void sub_180CF9B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TanOpHandler>()
{
}

void sub_180CF9F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TanhOpHandler>()
{
}

void sub_180CFA2E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::FromElementsOpHandler>()
{
}

void sub_180CFA6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ListPopBackOpHandler>()
{
}

void sub_180CFAA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::ListPushBackOpHandler>()
{
}

void sub_180CFAE64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TensorToMemrefOpHandler>()
{
}

void sub_180CFB224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TileOpHandler>()
{
}

void sub_180CFB618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TileGradientOpHandler>()
{
}

void sub_180CFBA28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TopKOpHandler>()
{
}

void sub_180CFBDF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TopKGradientOpHandler>()
{
}

void sub_180CFC1B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TransposeOpHandler>()
{
}

void sub_180CFC578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::TypeConstraintOpHandler>()
{
}

void sub_180CFC938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::UpdateRandomStateOpHandler>()
{
}

void sub_180CFCD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::VarHandleOpHandler>()
{
}

void sub_180CFD110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::VariableFromTensorOpHandler>()
{
}

void sub_180CFD4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::WhileOpHandler>()
{
}

void sub_180CFD890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::XorOpHandler>()
{
}

void sub_180CFDC6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::XnorOpHandler>()
{
}

void sub_180CFE048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::YieldOpHandler>()
{
}

void sub_180CFE408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::createOp<GPU::QuantizedMatMulOpHandler>()
{
}

void sub_180CFE7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::setupFeedsAndTargets(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  id v70 = a3;
  id v9 = a4;
  uint64_t v68 = a2;
  id v69 = *(id *)(a2 + 8);
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  uint64_t v10 = a1[31];
  if ((*(unsigned char *)(v10 + 46) & 0x80) != 0)
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    id v72 = v9;
    uint64_t v71 = (char **)a5;
    while (1)
    {
      if (v12 >= *(unsigned int *)(v10 + 68)) {
        goto LABEL_57;
      }
      int v15 = *(uint64_t **)(*(void *)(v10 + 72) + 32 * v12 + 24);
      v79[0] = v15;
      uint64_t v82 = *((void *)mlir::Value::getParentRegion((mlir::Value *)v79) + 2);
      uint64_t v16 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(a1 + 11, &v82);
      if (v16
        && (uint64_t v81 = v79[0],
            (unint64_t v17 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v16 + 3, &v81)) != 0))
      {
        id v18 = (id)v17[3];
      }
      else
      {
        id v18 = 0;
      }
      size_t v19 = objc_msgSend(v9, "objectAtIndexedSubscript:", v12, v68);
      int v20 = [MEMORY[0x1E4F1CA98] null];

      if (v19 != v20) {
        break;
      }
LABEL_6:

      ++v12;
      uint64_t v10 = a1[31];
      if ((*(unsigned char *)(v10 + 46) & 0x80) == 0) {
        goto LABEL_57;
      }
    }
    if (!v18)
    {
      uint64_t v37 = [v9 objectAtIndexedSubscript:v12];
      BaseRuntime::setTensorDataToDataMap((uint64_t)a1, v15, v37);

      size_t v38 = [v9 objectAtIndexedSubscript:v12];
      uint64_t v39 = [v38 tensorDataType];

      if (v39 != 1) {
        goto LABEL_6;
      }
      size_t v40 = (void *)a1[17];
      uint64_t v14 = [v9 objectAtIndexedSubscript:v12];
      [v40 addObject:v14];
      goto LABEL_5;
    }
    id v21 = [v9 objectAtIndexedSubscript:v12];

    if (v18 == v21) {
      goto LABEL_6;
    }
    uint64_t v22 = [v9 objectAtIndexedSubscript:v12];
    id v23 = v18;
    id v24 = v23;
    unint64_t v25 = a5[2];
    if ((unint64_t)v11 < v25)
    {
      *(void *)unint64_t v11 = v23;
      *((void *)v11 + 1) = v22;
      uint64_t v13 = v11 + 16;
LABEL_4:
      a5[1] = v13;
      uint64_t v14 = 0;
      unint64_t v11 = v13;
LABEL_5:

      goto LABEL_6;
    }
    size_t v26 = (char *)*a5;
    uint64_t v27 = (uint64_t)&v11[-*a5];
    unint64_t v28 = (v27 >> 4) + 1;
    if (v28 >> 60) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v29 = v25 - (void)v26;
    if (v29 >> 3 > v28) {
      unint64_t v28 = v29 >> 3;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    size_t v31 = (char *)operator new(16 * v30);
    unint64_t v32 = &v31[16 * (v27 >> 4)];
    size_t v33 = &v31[16 * v30];
    *(void *)unint64_t v32 = v24;
    *((void *)v32 + 1) = v22;
    uint64_t v13 = v32 + 16;
    char v34 = (char *)(v11 - v26);
    if (v11 == v26)
    {
      id v9 = v72;
      *uint64_t v71 = v32;
      v71[1] = v13;
      v71[2] = v33;
      a5 = v71;
      if (!v11) {
        goto LABEL_4;
      }
      goto LABEL_56;
    }
    uint64_t v35 = v34 - 16;
    if ((unint64_t)(v34 - 16) >= 0x230)
    {
      int64_t v41 = v11 - 16 - v26;
      unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFF0;
      id v9 = v72;
      a5 = v71;
      if (&v11[-(v41 & 0xFFFFFFFFFFFFFFF0) - 16] <= v11 - 16
        && &v31[v27 - 16 - v42] <= &v31[v27 - 16]
        && (uint64_t v43 = v11 - 8, &v11[-v42 - 8] <= v11 - 8)
        && &v31[v27 - 8 - v42] <= &v31[v27 - 8]
        && ((unint64_t v44 = v41 & 0xFFFFFFFFFFFFFFF0,
             unint64_t v45 = (unint64_t)&v11[-v44 - 16],
             unint64_t v46 = (unint64_t)&v31[v27 - v44 - 16],
             &v43[-v44] < v32)
          ? (BOOL v47 = &v31[v27 - v44 - 8] >= v11)
          : (BOOL v47 = 1),
            v47 ? (char v48 = 0) : (char v48 = 1),
            v46 < (unint64_t)v43 ? (BOOL v49 = v45 >= (unint64_t)&v31[v27 - 8]) : (BOOL v49 = 1),
            v49))
      {
        unint64_t v36 = v11;
        if ((v48 & 1) == 0)
        {
          uint64_t v50 = ((unint64_t)v35 >> 4) + 1;
          uint64_t v51 = 16 * (v50 & 0x1FFFFFFFFFFFFFFELL);
          unint64_t v52 = &v32[-v51];
          unint64_t v36 = &v11[-v51];
          size_t v53 = (double *)(v32 - 32);
          unint64_t v54 = (const double *)(v11 - 32);
          uint64_t v55 = v50 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            float64x2x2_t v83 = vld2q_f64(v54);
            *(_OWORD *)unint64_t v54 = 0uLL;
            *((_OWORD *)v54 + 1) = 0uLL;
            v54 -= 4;
            vst2q_f64(v53, v83);
            v53 -= 4;
            v55 -= 2;
          }
          while (v55);
          unint64_t v32 = v52;
          if (v50 == (v50 & 0x1FFFFFFFFFFFFFFELL))
          {
LABEL_53:
            *a5 = v52;
            a5[1] = v13;
            a5[2] = v33;
            do
            {

              uint64_t v57 = (void *)*((void *)v11 - 2);
              v11 -= 16;
            }
            while (v11 != v26);
            unint64_t v11 = v26;
            if (!v26) {
              goto LABEL_4;
            }
LABEL_56:
            operator delete(v11);
            goto LABEL_4;
          }
        }
      }
      else
      {
        unint64_t v36 = v11;
      }
    }
    else
    {
      unint64_t v36 = v11;
      id v9 = v72;
      a5 = v71;
    }
    unint64_t v52 = v32;
    do
    {
      long long v56 = *((_OWORD *)v36 - 1);
      v36 -= 16;
      *(void *)unint64_t v36 = 0;
      *((void *)v36 + 1) = 0;
      *((_OWORD *)v52 - 1) = v56;
      v52 -= 16;
    }
    while (v36 != v26);
    goto LABEL_53;
  }
LABEL_57:
  v79[0] = 0;
  v79[1] = v79;
  v79[2] = 0x3032000000;
  v79[3] = __Block_byref_object_copy_;
  v79[4] = __Block_byref_object_dispose_;
  id v80 = 0;
  uint64_t v58 = a1[29];
  unint64_t v59 = *(unsigned int *)(v58 + 44);
  if ((v59 & 0x7FFFFF) == 0)
  {
    uint64_t v64 = "index < numRegions && \"invalid region index\"";
    int v65 = 666;
    int64_t v66 = "Operation.h";
    uint64_t v67 = "getRegion";
    goto LABEL_65;
  }
  unint64_t v60 = v58 + 16 * ((v59 >> 23) & 1) + ((v59 >> 21) & 0x7F8) + 64;
  if (v60 >= 0xFFFFFFFFFFFFFFF9)
  {
    uint64_t v64 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v65 = 191;
    int64_t v66 = "Alignment.h";
    uint64_t v67 = "alignAddr";
LABEL_65:
    __assert_rtn(v67, v66, v65, v64);
  }
  uint64_t v61 = *(void *)(((v60 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v58 + 40) + 8);
  v73[0] = MEMORY[0x1E4F143A8];
  v73[1] = 3221225472;
  v73[2] = ___ZN16GPURegionRuntime20setupFeedsAndTargetsEPN3GPU16EncodeDescriptorEP7NSArrayIP18MPSGraphTensorDataES7__block_invoke;
  v73[3] = &unk_1E4FC0FF0;
  if (v61) {
    uint64_t v62 = v61 - 8;
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t v76 = a1;
  uint64_t v77 = v62;
  id v63 = v69;
  id v74 = v63;
  uint64_t v75 = v79;
  uint64_t v78 = v68;
  [v70 enumerateObjectsUsingBlock:v73];

  _Block_object_dispose(v79, 8);
}

void sub_180CFEE3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id a29)
{
  _Block_object_dispose(&a24, 8);
  std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::~vector[abi:ne180100](v29);

  _Unwind_Resume(a1);
}

void BaseRuntime::setTensorDataToDataMap(uint64_t a1, uint64_t *a2, void *a3)
{
  int v7 = a2;
  id v6 = a3;
  uint64_t v5 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v7) + 2);
  uint64_t v8 = &v5;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(a1 + 88, &v5, (uint64_t)&std::piecewise_construct, &v8);
  uint64_t v8 = v7;
  std::__hash_table<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>>>::__emplace_unique_key_args<void *,void *,MPSGraphTensorData * {__strong}&>((uint64_t)(v4 + 24), (uint64_t *)&v8, &v8, &v6);
}

void sub_180CFEF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_180CFEFA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180CFEFB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void ___ZN16GPURegionRuntime20setupFeedsAndTargetsEPN3GPU16EncodeDescriptorEP7NSArrayIP18MPSGraphTensorDataES7__block_invoke(uint64_t a1, void *a2, unsigned int a3)
{
  v48[1] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 48);
  int v7 = *(uint64_t **)(*(void *)(*(void *)(a1 + 56) + 48) + 8 * a3);
  uint64_t v8 = (MPSGraphTensorData *)v5;
  id v9 = v8;
  uint64_t v10 = (void *)*v7;
  if (*v7)
  {
    LODWORD(v11) = 0;
    do
    {
      LODWORD(v11) = v11 + 1;
      uint64_t v10 = (void *)*v10;
    }
    while (v10);
  }
  else
  {
    LODWORD(v11) = 0;
  }
  uint64_t v11 = (int)v11;
  unint64_t v12 = v8;
  if ([(MPSGraphTensorData *)v8 tensorDataType] == 1)
  {
    uint64_t v13 = (void *)*v7;
    if (!*v7) {
      goto LABEL_32;
    }
    int v14 = 0;
    int v15 = (void *)*v7;
    do
    {
      int v15 = (void *)*v15;
      --v14;
    }
    while (v15);
    if (!v14) {
      goto LABEL_32;
    }
    uint64_t v16 = 0;
    uint64_t v42 = -v14;
    do
    {
      uint64_t v17 = *(void *)(v13[2] + 48);
      id v18 = *(void **)(v17 + 16);
      if (v18 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v47[0] = *(void *)(v17 + 8);
        uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
        if (v20 == 25)
        {
          BOOL v21 = *(void *)AttrData == 0x616572632E73706DLL && *(void *)(AttrData + 8) == 0x75747865745F6574;
          BOOL v22 = v21 && *(void *)(AttrData + 16) == 0x6F736E65745F6572;
          if (v22 && *(unsigned char *)(AttrData + 24) == 114)
          {
            __int16 v46 = 1283;
            v45[0] = (uint64_t)"classof on '";
            v45[2] = (uint64_t)"mps.create_texture_tensor";
            v45[3] = 25;
            v43[0] = (uint64_t)"' failed due to the operation not being registered";
            __int16 v44 = 259;
            llvm::operator+(v45, v43, (uint64_t)v47);
            llvm::report_fatal_error((llvm::Twine *)v47, 1);
          }
        }
      }
      else if (v18 == &mlir::detail::TypeIDResolver<mlir::mps::CreateTextureTensorOp,void>::id)
      {
        ++v16;
      }
      uint64_t v13 = (void *)*v13;
    }
    while (v13);
    uint64_t v11 = (int)v11;
    if (v16)
    {
      unint64_t v12 = v9;
      if (v16 != v42)
      {
        id v24 = [(MPSGraphTensorData *)v9 mpsndarrayWithCommandBuffer:*(void *)(a1 + 32)];
        unint64_t v12 = v9;
      }
    }
    else
    {
LABEL_32:
      unint64_t v25 = -[MPSGraphTensorData mpsndarrayWithCommandBuffer:](v9, "mpsndarrayWithCommandBuffer:", *(void *)(a1 + 32), v42);
      size_t v26 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v25];

      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [v25 setReadCount:v11];
      }

      unint64_t v12 = v26;
    }
  }
  v47[0] = v7;
  v45[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v47) + 2);
  uint64_t v27 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v6 + 88), v45);
  if (v27
    && (v43[0] = v47[0],
        (v28 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v27 + 3, v43)) != 0)&& (id v29 = (id)v28[3]) != 0)
  {
    unint64_t v30 = v29;
    size_t v31 = [(MPSGraphTensorData *)v9 mpsndarrayWithCommandBuffer:*(void *)(a1 + 32)];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [v31 setReadCount:v11];
    }
    unint64_t v32 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    if (!v32)
    {
      id v33 = objc_alloc(MEMORY[0x1E4F35770]);
      char v34 = [*(id *)(a1 + 32) device];
      uint64_t v35 = [v33 initWithDevice:v34];
      uint64_t v36 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v37 = *(void **)(v36 + 40);
      *(void *)(v36 + 40) = v35;

      [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setLabel:@"argAsReturnCopy"];
      unint64_t v32 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    }
    size_t v38 = GPU::EncodeDescriptor::getcomputeEncoder(*(GPU::EncodeDescriptor **)(a1 + 64));
    uint64_t v39 = *(void *)(*(void *)(a1 + 64) + 8);
    v48[0] = v31;
    size_t v40 = [MEMORY[0x1E4F1C978] arrayWithObjects:v48 count:1];
    int64_t v41 = [v30 mpsndarray];
    [v32 encodeToMPSCommandEncoder:v38 commandBuffer:v39 sourceArrays:v40 destinationArray:v41];
  }
  else
  {
    BaseRuntime::setTensorDataToDataMap(v6, v7, v12);
  }
}

void sub_180CFF420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GPU::EncodeDescriptor::getcomputeEncoder(GPU::EncodeDescriptor *this)
{
  unint64_t v2 = (void *)*((void *)this + 9);
  if (!v2)
  {
    uint64_t v3 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)this + 1) withDispatchType:0];
    uint64_t v4 = (void *)*((void *)this + 9);
    *((void *)this + 9) = v3;

    id v5 = (void *)*((void *)this + 11);
    unint64_t v2 = (void *)*((void *)this + 9);
    if (v5)
    {
      uint64_t v6 = [v5 wrapComputeEncoder:*((void *)this + 9)];
      int v7 = (void *)*((void *)this + 9);
      *((void *)this + 9) = v6;

      unint64_t v2 = (void *)*((void *)this + 9);
    }
  }
  if (*((void *)this + 10))
  {
    objc_msgSend(v2, "setLabel:");
    unint64_t v2 = (void *)*((void *)this + 9);
  }

  return v2;
}

void **std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::~vector[abi:ne180100](void **a1)
{
  unint64_t v2 = (id *)*a1;
  if (*a1)
  {
    uint64_t v3 = (id *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {

        id v5 = *(v3 - 2);
        v3 -= 2;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

id GPURegionRuntime::evaluateOps(uint64_t a1, void *a2, void *a3, void *a4, void *a5, char a6, char a7, uint64_t a8, unsigned char *a9)
{
  id v126 = a2;
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  if (a9) {
    *a9 = 1;
  }
  id v18 = (std::mutex *)(a1 + 144);
  std::mutex::lock((std::mutex *)(a1 + 144));
  size_t v19 = *(void **)(a1 + 208);
  id v20 = v17;
  id v21 = v19;
  BOOL v22 = (id *)v16;
  v132[0] = &unk_1EC9887A0;
  v132[1] = v20;
  v132[2] = v22;
  char v133 = a6;
  char v134 = a7;
  long long v135 = 0u;
  long long v136 = 0u;
  int v137 = 1065353216;
  uint64_t v138 = 0;
  uint64_t v139 = 0;
  id v140 = v21;
  id v23 = v22[1];
  id v127 = v22[2];
  v130[0] = MEMORY[0x1E4F143A8];
  v130[1] = 3221225472;
  v130[2] = ___ZN16GPURegionRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPb_block_invoke;
  v130[3] = &unk_1E4FC1018;
  id v24 = v20;
  id v131 = v24;
  [v23 enumerateObjectsUsingBlock:v130];
  unint64_t v25 = v126;
  GPURegionRuntime::evaluateOps(a1, (GPU::EncodeDescriptor *)v132, v126, v15);
  id v125 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v124 = v15;
  v128[0] = MEMORY[0x1E4F143A8];
  v128[1] = 3221225472;
  void v128[2] = ___ZN16GPURegionRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPb_block_invoke_2;
  v128[3] = &unk_1E4FC1040;
  id v26 = v24;
  id v129 = v26;
  uint64_t v27 = (llvm *)[v127 enumerateObjectsUsingBlock:v128];
  if (!*(unsigned char *)(a1 + 256)) {
    goto LABEL_129;
  }
  uint64_t v28 = *(void *)(a1 + 424);
  if (!v28) {
    goto LABEL_129;
  }
  id v123 = v23;
  unint64_t v30 = *(void *)(v28 + 24);
  unint64_t v29 = *(void *)(v28 + 32);
  unint64_t v31 = *(void *)(v28 + 8);
  uint64_t v32 = *(void *)(v28 + 16);
  id v33 = (llvm::raw_ostream *)llvm::dbgs(v27);
  char v34 = (void *)*((void *)v33 + 4);
  if (*((void *)v33 + 3) - (void)v34 > 0x1CuLL)
  {
    qmemcpy(v34, "============================\n", 29);
    *((void *)v33 + 4) += 29;
  }
  else
  {
    id v33 = llvm::raw_ostream::write(v33, "============================\n", 0x1DuLL);
  }
  uint64_t v35 = (llvm::raw_ostream *)llvm::dbgs(v33);
  uint64_t v36 = (void *)*((void *)v35 + 4);
  if (*((void *)v35 + 3) - (void)v36 > 0x19uLL)
  {
    qmemcpy(v36, "Runtime Execution Report:\n", 26);
    *((void *)v35 + 4) += 26;
  }
  else
  {
    uint64_t v35 = llvm::raw_ostream::write(v35, "Runtime Execution Report:\n", 0x1AuLL);
  }
  uint64_t v37 = (llvm::raw_ostream *)llvm::dbgs(v35);
  size_t v38 = (void *)*((void *)v37 + 4);
  if (*((void *)v37 + 3) - (void)v38 > 0xDuLL)
  {
    qmemcpy(v38, "Layers Count: ", 14);
    *((void *)v37 + 4) += 14;
  }
  else
  {
    uint64_t v37 = llvm::raw_ostream::write(v37, "Layers Count: ", 0xEuLL);
  }
  unint64_t v39 = v29 + v30;
  size_t v40 = llvm::raw_ostream::operator<<(v37, v29 + v30);
  int64_t v41 = (_WORD *)*((void *)v40 + 4);
  if (*((void *)v40 + 3) - (void)v41 > 1uLL)
  {
    *int64_t v41 = 8250;
    uint64_t v43 = *((void *)v40 + 3);
    uint64_t v42 = *((void *)v40 + 4) + 2;
    *((void *)v40 + 4) = v42;
    if ((unint64_t)(v43 - v42) > 4) {
      goto LABEL_16;
    }
  }
  else
  {
    size_t v40 = llvm::raw_ostream::write(v40, ": ", 2uLL);
    uint64_t v42 = *((void *)v40 + 4);
    if ((unint64_t)(*((void *)v40 + 3) - v42) > 4)
    {
LABEL_16:
      *(unsigned char *)(v42 + 4) = 32;
      *(_DWORD *)uint64_t v42 = 977620545;
      *((void *)v40 + 4) += 5;
      goto LABEL_19;
    }
  }
  size_t v40 = llvm::raw_ostream::write(v40, "ANE: ", 5uLL);
LABEL_19:
  __int16 v44 = llvm::raw_ostream::operator<<(v40, *(void *)(v28 + 24));
  unint64_t v45 = (_WORD *)*((void *)v44 + 4);
  if (*((void *)v44 + 3) - (void)v45 > 1uLL)
  {
    _WORD *v45 = 10272;
    *((void *)v44 + 4) += 2;
  }
  else
  {
    __int16 v44 = llvm::raw_ostream::write(v44, " (", 2uLL);
  }
  __int16 v46 = llvm::raw_ostream::operator<<(v44, (double)v30 * 100.0 / (double)v39);
  BOOL v47 = (_DWORD *)*((void *)v46 + 4);
  if (*((void *)v46 + 3) - (void)v47 > 3uLL)
  {
    *BOOL v47 = 539765029;
    uint64_t v49 = *((void *)v46 + 3);
    uint64_t v48 = *((void *)v46 + 4) + 4;
    *((void *)v46 + 4) = v48;
    if ((unint64_t)(v49 - v48) > 4) {
      goto LABEL_24;
    }
  }
  else
  {
    __int16 v46 = llvm::raw_ostream::write(v46, "%), ", 4uLL);
    uint64_t v48 = *((void *)v46 + 4);
    if ((unint64_t)(*((void *)v46 + 3) - v48) > 4)
    {
LABEL_24:
      *(unsigned char *)(v48 + 4) = 32;
      *(_DWORD *)uint64_t v48 = 978669639;
      *((void *)v46 + 4) += 5;
      goto LABEL_27;
    }
  }
  __int16 v46 = llvm::raw_ostream::write(v46, "GPU: ", 5uLL);
LABEL_27:
  uint64_t v50 = llvm::raw_ostream::operator<<(v46, *(void *)(v28 + 32));
  uint64_t v51 = (_WORD *)*((void *)v50 + 4);
  if (*((void *)v50 + 3) - (void)v51 > 1uLL)
  {
    _WORD *v51 = 10272;
    *((void *)v50 + 4) += 2;
  }
  else
  {
    uint64_t v50 = llvm::raw_ostream::write(v50, " (", 2uLL);
  }
  unint64_t v52 = llvm::raw_ostream::operator<<(v50, (double)v29 * 100.0 / (double)v39);
  uint64_t v53 = *((void *)v52 + 4);
  if ((unint64_t)(*((void *)v52 + 3) - v53) > 2)
  {
    *(unsigned char *)(v53 + 2) = 10;
    *(_WORD *)uint64_t v53 = 10533;
    *((void *)v52 + 4) += 3;
  }
  else
  {
    unint64_t v52 = llvm::raw_ostream::write(v52, "%)\n", 3uLL);
  }
  unint64_t v54 = (llvm::raw_ostream *)llvm::dbgs(v52);
  if (v31)
  {
    uint64_t v55 = llvm::raw_ostream::operator<<(v54, v31);
    long long v56 = (void *)*((void *)v55 + 4);
    if (*((void *)v55 + 3) - (void)v56 > 0x2AuLL)
    {
      qmemcpy(v56, " MPS operations couldn't be placed on ANE.\n", 43);
      *((void *)v55 + 4) += 43;
    }
    else
    {
      uint64_t v55 = llvm::raw_ostream::write(v55, " MPS operations couldn't be placed on ANE.\n", 0x2BuLL);
    }
    unint64_t v54 = (llvm::raw_ostream *)llvm::dbgs(v55);
    if (v31 == v32)
    {
      unint64_t v60 = (void *)*((void *)v54 + 4);
      uint64_t v58 = "All unplaced operations are typechangers.\n";
      if (*((void *)v54 + 3) - (void)v60 >= 0x2AuLL)
      {
        qmemcpy(v60, "All unplaced operations are typechangers.\n", 42);
        *((void *)v54 + 4) += 42;
        if (!*(_DWORD *)(v28 + 112)) {
          goto LABEL_88;
        }
        goto LABEL_45;
      }
      size_t v59 = 42;
    }
    else
    {
      unint64_t v54 = llvm::raw_ostream::operator<<(v54, v31 - v32);
      uint64_t v61 = (void *)*((void *)v54 + 4);
      uint64_t v58 = " MPS operations (excluding TypeChangers) couldn't be placed on ANE.\n";
      if (*((void *)v54 + 3) - (void)v61 > 0x43uLL)
      {
        qmemcpy(v61, " MPS operations (excluding TypeChangers) couldn't be placed on ANE.\n", 68);
        *((void *)v54 + 4) += 68;
        if (!*(_DWORD *)(v28 + 112)) {
          goto LABEL_88;
        }
        goto LABEL_45;
      }
      size_t v59 = 68;
    }
  }
  else
  {
    uint64_t v57 = (void *)*((void *)v54 + 4);
    uint64_t v58 = "All MPS operations were placed on ANE.\n";
    if (*((void *)v54 + 3) - (void)v57 >= 0x27uLL)
    {
      qmemcpy(v57, "All MPS operations were placed on ANE.\n", 39);
      *((void *)v54 + 4) += 39;
      if (!*(_DWORD *)(v28 + 112)) {
        goto LABEL_88;
      }
      goto LABEL_45;
    }
    size_t v59 = 39;
  }
  unint64_t v54 = llvm::raw_ostream::write(v54, v58, v59);
  if (!*(_DWORD *)(v28 + 112)) {
    goto LABEL_88;
  }
LABEL_45:
  unint64_t v54 = (llvm::raw_ostream *)llvm::dbgs(v54);
  uint64_t v62 = (void *)*((void *)v54 + 4);
  if (*((void *)v54 + 3) - (void)v62 > 0x14uLL)
  {
    qmemcpy(v62, "Unplaced operations:\n", 21);
    *((void *)v54 + 4) += 21;
    if (!*(_DWORD *)(v28 + 112)) {
      goto LABEL_88;
    }
  }
  else
  {
    unint64_t v54 = llvm::raw_ostream::write(v54, "Unplaced operations:\n", 0x15uLL);
    if (!*(_DWORD *)(v28 + 112)) {
      goto LABEL_88;
    }
  }
  uint64_t v63 = *(unsigned int *)(v28 + 120);
  if (v63)
  {
    uint64_t v64 = 80 * v63;
    unint64_t v65 = *(void *)(v28 + 104);
    while (*(void *)v65 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v65 += 80;
      v64 -= 80;
      if (!v64) {
        goto LABEL_88;
      }
    }
  }
  else
  {
    unint64_t v65 = *(void *)(v28 + 104);
  }
  unint64_t v66 = *(void *)(v28 + 104) + 80 * v63;
  if (v65 != v66)
  {
    id v122 = v26;
    while (1)
    {
      uint64_t v67 = (llvm::raw_ostream *)llvm::dbgs(v54);
      uint64_t v68 = *(const void **)v65;
      unint64_t v69 = *(void *)(v65 + 8);
      id v70 = (_WORD *)*((void *)v67 + 4);
      if (v69 <= *((void *)v67 + 3) - (void)v70)
      {
        if (v69)
        {
          memcpy(v70, v68, *(void *)(v65 + 8));
          id v70 = (_WORD *)(*((void *)v67 + 4) + v69);
          *((void *)v67 + 4) = v70;
        }
      }
      else
      {
        uint64_t v67 = llvm::raw_ostream::write(v67, (const char *)v68, *(void *)(v65 + 8));
        id v70 = (_WORD *)*((void *)v67 + 4);
      }
      if (*((void *)v67 + 3) - (void)v70 > 1uLL)
      {
        *id v70 = 10272;
        *((void *)v67 + 4) += 2;
      }
      else
      {
        uint64_t v67 = llvm::raw_ostream::write(v67, " (", 2uLL);
      }
      uint64_t v71 = llvm::raw_ostream::operator<<(v67, *(unsigned int *)(v65 + 24));
      uint64_t v72 = *((void *)v71 + 4);
      if ((unint64_t)(*((void *)v71 + 3) - v72) > 2)
      {
        *(unsigned char *)(v72 + 2) = 10;
        *(_WORD *)uint64_t v72 = 14889;
        *((void *)v71 + 4) += 3;
        uint64_t v73 = *(unsigned int *)(v65 + 24);
        if (!v73) {
          goto LABEL_79;
        }
      }
      else
      {
        uint64_t v71 = llvm::raw_ostream::write(v71, "):\n", 3uLL);
        uint64_t v73 = *(unsigned int *)(v65 + 24);
        if (!v73) {
          goto LABEL_79;
        }
      }
      id v74 = *(mlir::Operation ***)(v65 + 16);
      uint64_t v75 = 8 * v73;
      do
      {
        uint64_t v76 = *v74;
        uint64_t v77 = (llvm::raw_ostream *)llvm::dbgs(v71);
        uint64_t v78 = mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v141);
        uint64_t v79 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope(v78);
        uint64_t v71 = mlir::Operation::print(v76, v77, v79);
        id v80 = (unsigned char *)*((void *)v77 + 4);
        if (*((unsigned char **)v77 + 3) == v80)
        {
          uint64_t v71 = llvm::raw_ostream::write(v77, "\n", 1uLL);
        }
        else
        {
          *id v80 = 10;
          ++*((void *)v77 + 4);
        }
        ++v74;
        v75 -= 8;
      }
      while (v75);
LABEL_79:
      unint64_t v54 = (llvm::raw_ostream *)llvm::dbgs(v71);
      id v26 = v122;
      uint64_t v81 = (unsigned char *)*((void *)v54 + 4);
      if (*((unsigned char **)v54 + 3) == v81)
      {
        unint64_t v54 = llvm::raw_ostream::write(v54, "\n", 1uLL);
      }
      else
      {
        *uint64_t v81 = 10;
        ++*((void *)v54 + 4);
      }
      v65 += 80;
      if (v65 > v66) {
        __assert_rtn("AdvancePastEmptyBuckets", "DenseMap.h", 1309, "Ptr <= End");
      }
      if (v65 != v66)
      {
        while (*(void *)v65 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v65 += 80;
          if (v65 == v66) {
            goto LABEL_88;
          }
        }
        if (v65 != v66) {
          continue;
        }
      }
      break;
    }
  }
LABEL_88:
  int v82 = *(_DWORD *)(v28 + 48);
  if (v82 == 1)
  {
    float64x2x2_t v83 = (llvm::raw_ostream *)llvm::dbgs(v54);
    int v84 = (void *)((char *)v83 + 32);
    char v85 = (_OWORD *)*((void *)v83 + 4);
    unsigned int v86 = "Found exactly one ANERegionCall operation.\n";
    if (*((void *)v83 + 3) - (void)v85 < 0x2BuLL) {
      goto LABEL_91;
    }
    goto LABEL_93;
  }
  if (!v82)
  {
    float64x2x2_t v83 = (llvm::raw_ostream *)llvm::dbgs(v54);
    int v84 = (void *)((char *)v83 + 32);
    char v85 = (_OWORD *)*((void *)v83 + 4);
    unsigned int v86 = "Couldn't find any ANERegionCall operation.\n";
    if (*((void *)v83 + 3) - (void)v85 < 0x2BuLL)
    {
LABEL_91:
      size_t v87 = 43;
      goto LABEL_97;
    }
LABEL_93:
    long long v88 = *((_OWORD *)v86 + 1);
    _OWORD *v85 = *(_OWORD *)v86;
    v85[1] = v88;
    *(_OWORD *)((char *)v85 + 27) = *(_OWORD *)(v86 + 27);
    *v84 += 43;
    id v89 = v26;
    uint64_t v90 = *(unsigned int *)(v28 + 48);
    if (!v90) {
      goto LABEL_104;
    }
    goto LABEL_98;
  }
  uint64_t v91 = (llvm::raw_ostream *)llvm::dbgs(v54);
  float64x2x2_t v83 = llvm::raw_ostream::operator<<(v91, *(unsigned int *)(v28 + 48));
  uint64_t v92 = (void *)*((void *)v83 + 4);
  unsigned int v86 = " ANERegionCall operations found.\n";
  if (*((void *)v83 + 3) - (void)v92 > 0x20uLL)
  {
    qmemcpy(v92, " ANERegionCall operations found.\n", 33);
    *((void *)v83 + 4) += 33;
    id v89 = v26;
    uint64_t v90 = *(unsigned int *)(v28 + 48);
    if (!v90) {
      goto LABEL_104;
    }
    goto LABEL_98;
  }
  size_t v87 = 33;
LABEL_97:
  float64x2x2_t v83 = llvm::raw_ostream::write(v83, v86, v87);
  id v89 = v26;
  uint64_t v90 = *(unsigned int *)(v28 + 48);
  if (!v90) {
    goto LABEL_104;
  }
LABEL_98:
  int64_t v93 = *(mlir::Operation ***)(v28 + 40);
  uint64_t v94 = 8 * v90;
  do
  {
    size_t v95 = *v93;
    uint64_t v96 = (llvm::raw_ostream *)llvm::dbgs(v83);
    uint64_t v97 = mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v141);
    uint64_t v98 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope(v97);
    float64x2x2_t v83 = mlir::Operation::print(v95, v96, v98);
    std::string v99 = (unsigned char *)*((void *)v96 + 4);
    if (*((unsigned char **)v96 + 3) == v99)
    {
      float64x2x2_t v83 = llvm::raw_ostream::write(v96, "\n", 1uLL);
    }
    else
    {
      *std::string v99 = 10;
      ++*((void *)v96 + 4);
    }
    ++v93;
    v94 -= 8;
  }
  while (v94);
LABEL_104:
  if (*(_DWORD *)(v28 + 136))
  {
    uint64_t v100 = (llvm::raw_ostream *)llvm::dbgs(v83);
    uint64_t v101 = (unsigned char *)*((void *)v100 + 4);
    if (*((unsigned char **)v100 + 3) == v101)
    {
      uint64_t v100 = llvm::raw_ostream::write(v100, "\n", 1uLL);
    }
    else
    {
      unsigned char *v101 = 10;
      ++*((void *)v100 + 4);
    }
    char v102 = (llvm::raw_ostream *)llvm::dbgs(v100);
    uint64_t v103 = *((void *)v102 + 4);
    if ((unint64_t)(*((void *)v102 + 3) - v103) > 5)
    {
      *(_WORD *)(v103 + 4) = 8292;
      *(_DWORD *)uint64_t v103 = 1853189958;
      *((void *)v102 + 4) += 6;
    }
    else
    {
      char v102 = llvm::raw_ostream::write(v102, "Found ", 6uLL);
    }
    float64x2x2_t v83 = llvm::raw_ostream::operator<<(v102, *(unsigned int *)(v28 + 136));
    unint64_t v104 = (void *)*((void *)v83 + 4);
    if (*((void *)v83 + 3) - (void)v104 <= 0x2DuLL)
    {
      float64x2x2_t v83 = llvm::raw_ostream::write(v83, " ops that triggered an extra copy at runtime:\n", 0x2EuLL);
      uint64_t v105 = *(unsigned int *)(v28 + 136);
      if (!v105) {
        goto LABEL_120;
      }
LABEL_115:
      uint64_t v106 = *(mlir::Operation ***)(v28 + 128);
      uint64_t v107 = 8 * v105;
      do
      {
        char v108 = *v106;
        uint64_t v109 = (llvm::raw_ostream *)llvm::dbgs(v83);
        uint64_t v110 = mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v141);
        char v111 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope(v110);
        float64x2x2_t v83 = mlir::Operation::print(v108, v109, v111);
        uint64_t v112 = (unsigned char *)*((void *)v109 + 4);
        if (*((unsigned char **)v109 + 3) == v112)
        {
          float64x2x2_t v83 = llvm::raw_ostream::write(v109, "\n", 1uLL);
        }
        else
        {
          *uint64_t v112 = 10;
          ++*((void *)v109 + 4);
        }
        ++v106;
        v107 -= 8;
      }
      while (v107);
      goto LABEL_120;
    }
    qmemcpy(v104, " ops that triggered an extra copy at runtime:\n", 46);
    *((void *)v83 + 4) += 46;
    uint64_t v105 = *(unsigned int *)(v28 + 136);
    if (v105) {
      goto LABEL_115;
    }
  }
LABEL_120:
  uint64_t v113 = (llvm::raw_ostream *)llvm::dbgs(v83);
  id v26 = v89;
  uint64_t v114 = *((void *)v113 + 4);
  if ((unint64_t)(*((void *)v113 + 3) - v114) > 0x13)
  {
    *(_DWORD *)(v114 + 16) = 540701806;
    *(_OWORD *)uint64_t v114 = *(_OWORD *)"Runtime Wait count: ";
    *((void *)v113 + 4) += 20;
  }
  else
  {
    uint64_t v113 = llvm::raw_ostream::write(v113, "Runtime Wait count: ", 0x14uLL);
  }
  int64_t v115 = llvm::raw_ostream::operator<<(v113, *(void *)(v28 + 192));
  v116 = (unsigned char *)*((void *)v115 + 4);
  if (*((unsigned char **)v115 + 3) == v116)
  {
    int64_t v115 = llvm::raw_ostream::write(v115, "\n", 1uLL);
  }
  else
  {
    unsigned char *v116 = 10;
    ++*((void *)v115 + 4);
  }
  unint64_t v117 = (llvm::raw_ostream *)llvm::dbgs(v115);
  unint64_t v118 = (void *)*((void *)v117 + 4);
  if (*((void *)v117 + 3) - (void)v118 <= 0x1DuLL)
  {
    llvm::raw_ostream::write(v117, "============================\n\n", 0x1EuLL);
    uint64_t v119 = a1 + 424;
    uint64_t v120 = *(void *)(a1 + 424);
    *(void *)(a1 + 424) = 0;
    unint64_t v25 = v126;
    id v23 = v123;
    id v18 = (std::mutex *)(a1 + 144);
    if (!v120) {
      goto LABEL_129;
    }
    goto LABEL_128;
  }
  qmemcpy(v118, "============================\n\n", 30);
  *((void *)v117 + 4) += 30;
  uint64_t v119 = a1 + 424;
  uint64_t v120 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = 0;
  unint64_t v25 = v126;
  id v23 = v123;
  id v18 = (std::mutex *)(a1 + 144);
  if (v120) {
LABEL_128:
  }
    std::default_delete<GPU::RuntimeExecutionReport>::operator()[abi:ne180100](v119, v120);
LABEL_129:

  GPU::EncodeDescriptor::~EncodeDescriptor((GPU::EncodeDescriptor *)v132);
  std::mutex::unlock(v18);

  return v125;
}

void sub_180D00334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, std::mutex *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,char a29)
{
  GPU::EncodeDescriptor::~EncodeDescriptor((GPU::EncodeDescriptor *)&a29);
  std::mutex::unlock(a12);

  _Unwind_Resume(a1);
}

uint64_t ___ZN16GPURegionRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPb_block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) encodeWaitForEvent:*(void *)(a2 + 8) value:*(void *)(a2 + 16)];
}

id GPURegionRuntime::evaluateOps(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3, void *a4)
{
  id v5 = a2;
  v258[6] = *MEMORY[0x1E4F143B8];
  v238 = a2;
  id v220 = a3;
  id v217 = a4;
  uint64_t v223 = a1;
  if (!*(unsigned char *)(a1 + 256) || (*(unsigned char *)(a1 + 220) & 0x20) == 0) {
    goto LABEL_77;
  }
  int v7 = *(void **)(a1 + 448);
  id v218 = v220;
  id v219 = v217;
  v221 = v7;
  long long v239 = *(_OWORD *)(v7[1] + 232);
  mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v239);
  unsigned int v9 = v8;
  v245 = &v247;
  uint64_t v246 = 0x600000000;
  unint64_t v10 = v8;
  if (v8)
  {
    if (v8 < 7uLL)
    {
      uint64_t v11 = 0;
      unint64_t v12 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v245, &v247, v8, 8);
      uint64_t v11 = v246;
      unint64_t v12 = v10 - v246;
      if (v10 == v246) {
        goto LABEL_9;
      }
    }
    bzero((char *)v245 + 8 * v11, 8 * v12);
LABEL_9:
    if (v10 > HIDWORD(v246)) {
      __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
    LODWORD(v246) = v9;
  }
  mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v239);
  unsigned int v14 = v13;
  v256 = (char *)v258;
  uint64_t v257 = 0x300000000;
  unint64_t v15 = v13;
  if (!v13) {
    goto LABEL_19;
  }
  if (v13 < 4uLL)
  {
    uint64_t v16 = 0;
    unint64_t v17 = v13;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v256, v258, v13, 16);
    uint64_t v16 = v257;
    unint64_t v17 = v15 - v257;
    if (v15 == v257) {
      goto LABEL_17;
    }
  }
  bzero(&v256[16 * v16], 16 * v17);
LABEL_17:
  if (v15 > HIDWORD(v257)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  LODWORD(v257) = v14;
LABEL_19:
  mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v239);
  unsigned int v19 = v18;
  *(void *)&long long v254 = v255;
  *((void *)&v254 + 1) = 0x600000000;
  unint64_t v20 = v18;
  if (!v18) {
    goto LABEL_27;
  }
  if (v18 < 7uLL)
  {
    uint64_t v21 = 0;
    unint64_t v22 = v18;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v254, v255, v18, 8);
    uint64_t v21 = DWORD2(v254);
    unint64_t v22 = v20 - DWORD2(v254);
    if (v20 == DWORD2(v254)) {
      goto LABEL_25;
    }
  }
  bzero((void *)(v254 + 8 * v21), 8 * v22);
LABEL_25:
  if (v20 > HIDWORD(v254)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  DWORD2(v254) = v19;
LABEL_27:
  for (unint64_t i = 0; ; ++i)
  {
    mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v239);
    if (i >= v24) {
      break;
    }
    unint64_t v25 = *(unsigned int *)(v239 + 44);
    if ((v25 & 0x7FFFFF) == 0)
    {
      int v199 = 666;
      v200 = "getRegion";
      v201 = "Operation.h";
      v202 = "index < numRegions && \"invalid region index\"";
      goto LABEL_196;
    }
    unint64_t v26 = v239 + 16 * ((v25 >> 23) & 1) + ((v25 >> 21) & 0x7F8) + 64;
    if (v26 > 0xFFFFFFFFFFFFFFF8)
    {
      int v199 = 191;
      v200 = "alignAddr";
      v201 = "Alignment.h";
      v202 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
      goto LABEL_196;
    }
    uint64_t v27 = (void *)(((v26 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v239 + 40));
    if ((void *)*v27 == v27) {
      goto LABEL_219;
    }
    uint64_t v28 = v27[1];
    uint64_t v29 = v28 - 8;
    if (!v28) {
      uint64_t v29 = 0;
    }
    uint64_t v30 = *(void *)(v29 + 48);
    if (i >= (unint64_t)((*(void *)(v29 + 56) - v30) >> 3))
    {
LABEL_219:
      int v199 = 443;
      v200 = "operator[]";
      v201 = "ArrayRef.h";
      v202 = "Index < this->size() && \"Invalid index!\"";
LABEL_196:
      __assert_rtn(v200, v201, v199, v202);
    }
    unint64_t v31 = (uint64_t **)(*(void *)(*(void *)(v30 + 8 * i) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v31))
    {
      int v203 = 566;
      v206 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v205 = "Casting.h";
      v204 = "cast";
LABEL_198:
      __assert_rtn(v204, v205, v203, v206);
    }
    if (v31)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v31);
      if (!InterfaceFor)
      {
        int v203 = 98;
        v204 = "Interface";
        v205 = "InterfaceSupport.h";
        v206 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        goto LABEL_198;
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    if ((isStaticMPSType(v31) & 1) == 0)
    {
      Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)(v221[1] + 64) + 24));
      char v34 = [v218 objectAtIndexedSubscript:i];
      uint64_t v35 = [v34 shape];
      uint64_t v36 = [v218 objectAtIndexedSubscript:i];
      uint64_t v37 = (mlir::MLIRContext *)[v36 dataType];
      id v38 = v35;
      uint64_t MLIRElementType = getMLIRElementType(Context, v37);
      MLIRType = getMLIRType(v38, MLIRElementType);

      if (i >= v246) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      *((void *)v245 + i) = MLIRType;
    }
    uint64_t v41 = v221[1];
    if ((*(unsigned char *)(v41 + 220) & 0x40) != 0 && GPURegionRuntime::isSmallIntType(v41, v31, 0))
    {
      uint64_t v42 = [v218 objectAtIndexedSubscript:i];
      uint64_t v43 = [v42 mpsndarray];
      *(void *)&long long v241 = v31;
      *((void *)&v241 + 1) = InterfaceFor;
      id v44 = v43;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v241)) {
        goto LABEL_190;
      }
      ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v241);
      if (v46)
      {
        uint64_t v47 = 8 * v46;
        while (*ArgAttrsAttr != 0x8000000000000000)
        {
          ++ArgAttrsAttr;
          v47 -= 8;
          if (!v47) {
            goto LABEL_51;
          }
        }
LABEL_190:
        __assert_rtn("getNumElements", "BuiltinTypeInterfaces.h.inc", 162, "hasStaticShape() && \"cannot get element count of dynamic shaped type\"");
      }
LABEL_51:
      uint64_t v48 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v241);
      uint64_t NumElements = mlir::ShapedType::getNumElements(v48, v49);
      OperandRange = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v241);
      unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
      uint64_t v52 = NumElements * IntOrFloatBitWidth;
      if (v52 >= 0) {
        uint64_t v53 = NumElements * IntOrFloatBitWidth;
      }
      else {
        uint64_t v53 = v52 + 7;
      }
      unint64_t v54 = [*(id *)(v221[1] + 48) metalDevice];
      uint64_t v55 = v53 >> 3;
      long long v56 = (void *)[v54 newBufferWithLength:v55 options:0];

      uint64_t v57 = (void *)*((void *)v5 + 9);
      if (v57)
      {
        [v57 endEncoding];
        uint64_t v58 = (void *)*((void *)v5 + 9);
        *((void *)v5 + 9) = 0;
      }
      uint64_t v59 = *((void *)v5 + 1);
      unint64_t v60 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v241);
      [v44 exportDataWithCommandBuffer:v59 toBuffer:v56 destinationDataType:getMPSDataType(v60) offset:0 rowStrides:0];
      uint64_t v61 = [*((id *)v5 + 1) rootCommandBuffer];
      (**(void (***)(GPU::EncodeDescriptor *))v5)(v5);
      [v61 waitUntilCompleted];
      id v62 = v56;
      uint64_t v63 = [v62 contents];
      OperandRange = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v241, *((void *)&v241 + 1), v63, v55, v64, v65, v66);
      uint64_t v67 = mlir::Attribute::cast<mlir::ElementsAttr>(&OperandRange);
      unint64_t v69 = v68;

      if (i >= v257) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      id v70 = (uint64_t **)&v256[16 * i];
      *id v70 = v67;
      v70[1] = v69;
    }
  }
  unint64_t v71 = 0;
  uint64_t v72 = "Casting.h";
  uint64_t v73 = "cast";
  while (1)
  {
    mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v239);
    if (v71 == v74) {
      break;
    }
    uint64_t v75 = [v219 objectAtIndexedSubscript:v71];
    uint64_t v76 = [MEMORY[0x1E4F1CA98] null];
    BOOL v77 = v75 == v76;

    if (!v77)
    {
      uint64_t v78 = *(void *)(v221[1] + 248);
      if ((*(unsigned char *)(v78 + 46) & 0x80) == 0)
      {
        int v207 = 960;
        v208 = "hasOperandStorage && \"expected operation to have operand storage\"";
        v209 = "Operation.h";
        v210 = "getOperandStorage";
        goto LABEL_201;
      }
      if (*(_DWORD *)(v78 + 68) <= v71)
      {
        int v207 = 443;
        v210 = "operator[]";
        v209 = "ArrayRef.h";
        v208 = "Index < this->size() && \"Invalid index!\"";
LABEL_201:
        __assert_rtn(v210, v209, v207, v208);
      }
      uint64_t v79 = (uint64_t **)(*(void *)(*(void *)(*(void *)(v78 + 72) + 32 * v71 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79))
      {
        int v211 = 566;
        v212 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        goto LABEL_205;
      }
      if (v79 && !mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79))
      {
        int v211 = 98;
        uint64_t v73 = "Interface";
        uint64_t v72 = "InterfaceSupport.h";
        v212 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
LABEL_205:
        __assert_rtn(v73, v72, v211, v212);
      }
      if ((isStaticMPSType(v79) & 1) == 0)
      {
        id v80 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)(v221[1] + 64) + 24));
        uint64_t v81 = [v219 objectAtIndexedSubscript:v71];
        int v82 = [v81 shape];
        float64x2x2_t v83 = [v219 objectAtIndexedSubscript:v71];
        int v84 = (mlir::MLIRContext *)[v83 dataType];
        id v85 = v82;
        uint64_t v86 = getMLIRElementType(v80, v84);
        size_t v87 = getMLIRType(v85, v86);

        if (v71 >= DWORD2(v254)) {
          __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
        }
        *(void *)(v254 + 8 * v71) = v87;
      }
    }
    ++v71;
  }
  (*(void (**)(void *, void *, void, char *, void, void, void))(*v221 + 16))(v221, v245, v246, v256, v257, v254, DWORD2(v254));
  if ((void *)v254 != v255) {
    free((void *)v254);
  }
  if (v256 != (char *)v258) {
    free(v256);
  }
  if (v245 != &v247) {
    free(v245);
  }

  id v5 = v238;
  a1 = v223;
LABEL_77:
  GPURegionRuntime::setupFeedsAndTargets((void *)a1, (uint64_t)v5, v220, v217, &v256);
  unint64_t v236 = 0;
  unint64_t v237 = 0;
  if (!*(unsigned char *)(a1 + 648)) {
    goto LABEL_107;
  }
  *(void *)&long long v241 = 0;
  LODWORD(OperandRange) = 536870920;
  long long v254 = 0uLL;
  v255[0] = 0;
  long long v88 = (char *)operator new(0x80uLL);
  *(void *)&long long v254 = v88;
  *((void *)&v254 + 1) = v88;
  v255[0] = v88 + 128;
  uint64_t v89 = *(void *)(a1 + 232);
  unint64_t v90 = *(unsigned int *)(v89 + 44);
  if ((v90 & 0x7FFFFF) == 0)
  {
    v213 = "index < numRegions && \"invalid region index\"";
    int v214 = 666;
    v215 = "Operation.h";
    v216 = "getRegion";
    goto LABEL_212;
  }
  unint64_t v91 = v89 + 16 * ((v90 >> 23) & 1) + ((v90 >> 21) & 0x7F8) + 64;
  if (v91 >= 0xFFFFFFFFFFFFFFF9)
  {
    v213 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v214 = 191;
    v215 = "Alignment.h";
    v216 = "alignAddr";
LABEL_212:
    __assert_rtn(v216, v215, v214, v213);
  }
  unint64_t v92 = ((v91 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v89 + 40);
  v245 = &v237;
  uint64_t v246 = (uint64_t)&v236;
  v247 = (GPU::EncodeDescriptor **)&v241;
  p_OperandRange = &OperandRange;
  v249 = &v254;
  uint64_t v93 = *(void *)(v92 + 8);
  if (v93 == v92)
  {
    a1 = v223;
LABEL_106:
    *((void *)&v254 + 1) = v88;
    operator delete(v88);
    goto LABEL_107;
  }
  do
  {
    uint64_t v94 = v93 - 8;
    if (!v93) {
      uint64_t v94 = 0;
    }
    size_t v95 = (mlir::GenericProgramPoint *)(v94 + 32);
    uint64_t v96 = *(mlir::GenericProgramPoint **)(v94 + 40);
    if (v96 != (mlir::GenericProgramPoint *)(v94 + 32))
    {
      do
      {
        uint64_t v97 = (mlir::GenericProgramPoint *)*((void *)v96 + 1);
        mlir::GenericProgramPoint::~GenericProgramPoint(v96);
        mlir::detail::walk<mlir::ForwardIterator>(v98, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::evaluateOps(GPU::EncodeDescriptor *,NSArray<MPSGraphTensorData *> *,NSArray<MPSGraphTensorData *> *)::$_0>, (uint64_t)&v245, 1);
        uint64_t v96 = v97;
      }
      while (v97 != v95);
    }
    uint64_t v93 = *(void *)(v93 + 8);
  }
  while (v93 != v92);
  long long v88 = (char *)v254;
  if (v237 >= 5)
  {
    std::string v99 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:((uint64_t)(*((void *)&v254 + 1) - v254) >> 3) + 1];
    unint64_t v100 = v241;
    if ((unint64_t)v241 >> 31) {
      unint64_t v100 = 16;
    }
    v245 = (void *)(v100 / ((unsigned __int16)OperandRange >> 3));
    uint64_t v101 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:dimensionCount:dimensionSizes:");
    [v101 setPreferPackedRows:1];
    char v102 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:*((void *)v238 + 1) descriptor:v101];
    [v102 buffer];

    [v99 addObject:v102];
    unint64_t v104 = (uint64_t *)*((void *)&v254 + 1);
    for (uint32_t j = (uint64_t *)v254; j != v104; ++j)
    {
      uint64_t v105 = *j;
      if ((unint64_t)*j >> 31) {
        uint64_t v105 = 16;
      }
      *(void *)&long long v239 = v105;
      uint64_t v106 = [MEMORY[0x1E4F35720] descriptorWithDataType:536870920 dimensionCount:1 dimensionSizes:&v239];
      [v106 setPreferPackedRows:1];
      uint64_t v107 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:*((void *)v238 + 1) descriptor:v106];
      [v107 buffer];

      [v99 addObject:v107];
    }
    long long v234 = 0u;
    long long v235 = 0u;
    long long v232 = 0u;
    long long v233 = 0u;
    id v108 = v99;
    uint64_t v109 = [v108 countByEnumeratingWithState:&v232 objects:v244 count:16];
    if (v109)
    {
      uint64_t v110 = *(void *)v233;
      do
      {
        for (uint64_t k = 0; k != v109; ++k)
        {
          if (*(void *)v233 != v110) {
            objc_enumerationMutation(v108);
          }
          [*(id *)(*((void *)&v232 + 1) + 8 * k) setReadCount:0];
        }
        uint64_t v109 = [v108 countByEnumeratingWithState:&v232 objects:v244 count:16];
      }
      while (v109);
    }

    long long v88 = (char *)v254;
  }
  a1 = v223;
  if (v88) {
    goto LABEL_106;
  }
LABEL_107:
  unint64_t v231 = 13;
  uint64_t v230 = 45;
  unint64_t v229 = 300000;
  uint64_t v228 = 30000000;
  uint64_t v112 = *(void **)(a1 + 48);
  if (v112)
  {
    uint64_t v113 = [v112 metalDevice];
    if (v113)
    {
      uint64_t v114 = (id *)(v223 + 72);
      id WeakRetained = objc_loadWeakRetained((id *)(v223 + 72));
      BOOL v116 = WeakRetained == 0;

      if (!v116)
      {
        unint64_t v117 = [*(id *)(v223 + 48) metalDevice];
        uint64_t MPSDevice = MPSDevice::GetMPSDevice();

        if (*(_DWORD *)(MPSDevice + 1472) == 18)
        {
          uint64_t v119 = (os_unfair_lock_s *)objc_loadWeakRetained(v114);
          os_unfair_lock_lock(v119 + 140);

          uint64_t v120 = objc_loadWeakRetained(v114);
          uint64_t v121 = v120[71];

          id v122 = (os_unfair_lock_s *)objc_loadWeakRetained(v114);
          os_unfair_lock_unlock(v122 + 140);

          if (!v121)
          {
            unint64_t v231 = 4;
            unint64_t v229 = 100000;
          }
        }
      }
    }
  }
  if (v237 >= 0xC9 && v236 >= 0x36EE81)
  {
    v229 *= 12;
    v230 += 30;
LABEL_116:
    unint64_t v231 = 15;
    goto LABEL_119;
  }
  if (v237 > 0x82 || v236 >= 0x36EE81)
  {
    if (v237 < 0x5B || v236 < 0x1B7741)
    {
      if (v237 < 0xC9)
      {
        if (v237 < 0x33) {
          goto LABEL_119;
        }
      }
      else
      {
        v229 *= 3;
      }
    }
    else
    {
      v229 *= 4;
    }
    goto LABEL_116;
  }
LABEL_119:
  id v222 = (id)[MEMORY[0x1E4F1CBF0] mutableCopy];
  v255[0] = 0;
  long long v254 = 0uLL;
  id v123 = (void *)*((void *)v238 + 1);
  if (!v123 || ([v123 mpsCommandBufferDescriptor], !(void)v254))
  {
    *(void *)&long long v254 = v231 >> 1;
    *((void *)&v254 + 1) = v229 >> 1;
  }
  char v227 = 0;
  unint64_t v124 = 0;
  char v227 = (*(uint64_t (**)(GPU::EncodeDescriptor *))(*(void *)v238 + 8))(v238);
  long long v241 = *(_OWORD *)(v223 + 232);
  id v125 = "getRegion";
  while (1)
  {
    mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v241);
    uint64_t v126 = v241;
    unint64_t v127 = *(unsigned int *)(v241 + 44);
    int v128 = v127 & 0x7FFFFF;
    if (v124 >= v129) {
      break;
    }
    if (!v128)
    {
      int v196 = 666;
      v197 = "index < numRegions && \"invalid region index\"";
      v198 = "Operation.h";
      goto LABEL_193;
    }
    unint64_t v130 = v241 + 16 * ((v127 >> 23) & 1) + ((v127 >> 21) & 0x7F8) + 64;
    if (v130 > 0xFFFFFFFFFFFFFFF8)
    {
      int v196 = 191;
      id v125 = "alignAddr";
      v198 = "Alignment.h";
      v197 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
      goto LABEL_193;
    }
    id v131 = (void *)(((v130 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v241 + 40));
    if ((void *)*v131 == v131) {
      goto LABEL_216;
    }
    uint64_t v132 = v131[1];
    uint64_t v133 = v132 - 8;
    if (!v132) {
      uint64_t v133 = 0;
    }
    uint64_t v134 = *(void *)(v133 + 48);
    if (v124 >= (unint64_t)((*(void *)(v133 + 56) - v134) >> 3))
    {
LABEL_216:
      int v196 = 443;
      id v125 = "operator[]";
      v198 = "ArrayRef.h";
      v197 = "Index < this->size() && \"Invalid index!\"";
LABEL_193:
      __assert_rtn(v125, v198, v196, v197);
    }
    long long v135 = *(uint64_t **)(v134 + 8 * v124);
    if (((*(uint64_t (**)(void, uint64_t *))(**(void **)(v223 + 448) + 24))(*(void *)(v223 + 448), v135) & 1) == 0&& (isStaticMPSType((uint64_t **)(v135[1] & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
    {
      long long v136 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)(v223 + 64) + 24));
      int v137 = [v220 objectAtIndexedSubscript:v124];
      uint64_t v138 = [v137 shape];
      uint64_t v139 = [v220 objectAtIndexedSubscript:v124];
      id v140 = (mlir::MLIRContext *)[v139 dataType];
      id v141 = v138;
      uint64_t v142 = getMLIRElementType(v136, v140);
      unint64_t v143 = getMLIRType(v141, v142);

      GPURegionRuntime::setStaticJITypeForValue(v223, v135, v143);
    }
    ++v124;
  }
  if (!v128) {
    goto LABEL_208;
  }
  unint64_t v144 = v241 + 16 * ((v127 >> 23) & 1) + ((v127 >> 21) & 0x7F8) + 64;
  if (v144 > 0xFFFFFFFFFFFFFFF8)
  {
LABEL_209:
    v197 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v196 = 191;
    v198 = "Alignment.h";
    id v125 = "alignAddr";
    goto LABEL_193;
  }
  unint64_t v145 = ((v144 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v241 + 40);
  v245 = &v241;
  uint64_t v246 = v223;
  v247 = &v238;
  p_OperandRange = (uint64_t **)&v227;
  v249 = &v254;
  v250 = &v228;
  v251 = &v230;
  v252 = &v229;
  v253 = &v231;
  uint64_t v146 = *(void *)(v145 + 8);
  if (v146 != v145)
  {
    do
    {
      uint64_t v147 = v146 - 8;
      if (!v146) {
        uint64_t v147 = 0;
      }
      int v148 = (mlir::GenericProgramPoint *)(v147 + 32);
      uint64_t v149 = *(mlir::GenericProgramPoint **)(v147 + 40);
      if (v149 != (mlir::GenericProgramPoint *)(v147 + 32))
      {
        do
        {
          size_t v150 = (mlir::GenericProgramPoint *)*((void *)v149 + 1);
          mlir::GenericProgramPoint::~GenericProgramPoint(v149);
          mlir::detail::walk<mlir::ForwardIterator>(v151, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::evaluateOps(GPU::EncodeDescriptor *,NSArray<MPSGraphTensorData *> *,NSArray<MPSGraphTensorData *> *)::$_1::operator() const(mlir::FunctionOpInterface)::{lambda(mlir::Operation *)#1}>, (uint64_t)&v245, 1);
          uint64_t v149 = v150;
        }
        while (v150 != v148);
      }
      uint64_t v146 = *(void *)(v146 + 8);
    }
    while (v146 != v145);
    uint64_t v126 = v241;
  }
  unint64_t v152 = *(unsigned int *)(v126 + 44);
  if ((v152 & 0x7FFFFF) == 0)
  {
LABEL_208:
    v197 = "index < numRegions && \"invalid region index\"";
    int v196 = 666;
    v198 = "Operation.h";
    id v125 = "getRegion";
    goto LABEL_193;
  }
  unint64_t v153 = v126 + 16 * ((v152 >> 23) & 1) + ((v152 >> 21) & 0x7F8) + 64;
  if (v153 > 0xFFFFFFFFFFFFFFF8) {
    goto LABEL_209;
  }
  uint64_t v154 = *(void *)(((v153 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v126 + 40) + 8);
  if (v154) {
    unint64_t v155 = (mlir::GenericProgramPoint **)(v154 - 8);
  }
  else {
    unint64_t v155 = 0;
  }
  mlir::Block::getTerminator(v155);
  if ((*(unsigned char *)(v156 + 46) & 0x80) != 0)
  {
    uint64_t v157 = *(unsigned int *)(v156 + 68);
    if (v157)
    {
      uint64_t v158 = (void **)(*(void *)(v156 + 72) + 24);
      do
      {
        v245 = *v158;
        *(void *)&long long v239 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v245) + 2);
        long long v159 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v223 + 88), (uint64_t *)&v239);
        if (v159
          && (OperandRange = (uint64_t *)v245,
              (__n128 v160 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v159 + 3, (uint64_t *)&OperandRange)) != 0))
        {
          id v161 = (id)v160[3];
        }
        else
        {
          id v161 = 0;
        }
        [v222 addObject:v161];

        v158 += 4;
        --v157;
      }
      while (v157);
    }
  }
  __n128 v162 = (void *)*((void *)v238 + 1);
  long long v225 = v254;
  uint64_t v226 = v255[0];
  [v162 setMpsCommandBufferDescriptor:&v225];
  unint64_t v163 = [*(id *)(v223 + 128) allKeys];
  if (![v163 count] && (char *)v257 == v256)
  {
    uint64_t v166 = 0;
  }
  else
  {
    id v164 = objc_alloc(MEMORY[0x1E4F35770]);
    v165 = [*((id *)v238 + 1) device];
    uint64_t v166 = (void *)[v164 initWithDevice:v165];
  }
  if ([v163 count])
  {
    for (unint64_t m = 0; m < [v163 count]; ++m)
    {
      uint64_t v168 = [v163 objectAtIndexedSubscript:m];
      int v169 = [*(id *)(v223 + 128) objectForKeyedSubscript:v168];
      uint64_t v170 = [v169 mpsndarray];

      v171 = [v168 variable];
      unsigned int v172 = [*((id *)v238 + 1) device];
      v173 = [v171 mpsNDArrayWithDevice:v172];

      uint64_t v174 = GPU::EncodeDescriptor::getcomputeEncoder(v238);
      uint64_t v175 = *((void *)v238 + 1);
      v243 = v170;
      v176 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v243 count:1];
      [v166 encodeToMPSCommandEncoder:v174 commandBuffer:v175 sourceArrays:v176 resultState:0 destinationArray:v173 kernelDAGObject:0];
    }
  }
  if ((char *)v257 != v256)
  {
    uint64_t v177 = 0;
    unint64_t v178 = 0;
    do
    {
      v179 = GPU::EncodeDescriptor::getcomputeEncoder(v238);
      if (v178 >= (v257 - (uint64_t)v256) >> 4) {
        std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v180 = *((void *)v238 + 1);
      v181 = [*(id *)&v256[v177] mpsndarray];
      v242 = v181;
      v182 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v242 count:1];
      if (v178 >= (v257 - (uint64_t)v256) >> 4) {
        std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::__throw_out_of_range[abi:ne180100]();
      }
      v183 = [*(id *)&v256[v177 + 8] mpsndarray];
      [v166 encodeToMPSCommandEncoder:v179 commandBuffer:v180 sourceArrays:v182 destinationArray:v183];

      ++v178;
      v177 += 16;
    }
    while (v178 < (v257 - (uint64_t)v256) >> 4);
  }
  v184 = v238;
  v185 = (void *)*((void *)v238 + 9);
  if (v185)
  {
    [v185 endEncoding];
    v186 = (void *)*((void *)v184 + 9);
    *((void *)v184 + 9) = 0;

    v184 = v238;
  }
  v187 = *(void **)(v223 + 136);
  v224[0] = MEMORY[0x1E4F143A8];
  v224[1] = 3221225472;
  v224[2] = ___ZN16GPURegionRuntime11evaluateOpsEPN3GPU16EncodeDescriptorEP7NSArrayIP18MPSGraphTensorDataES7__block_invoke;
  v224[3] = &__block_descriptor_40_e35_v32__0__MPSGraphTensorData_8Q16_B24l;
  v224[4] = v184;
  [v187 enumerateObjectsUsingBlock:v224];
  GPURegionRuntime::postEvalCleanUp((GPURegionRuntime *)v223);
  v188 = v238;
  v189 = (void *)*((void *)v238 + 9);
  if (v189)
  {
    [v189 endEncoding];
    v190 = (void *)*((void *)v188 + 9);
    *((void *)v188 + 9) = 0;
  }
  v191 = v256;
  if (v256)
  {
    v192 = (id *)v257;
    v193 = v256;
    if ((char *)v257 != v256)
    {
      do
      {

        v194 = *(v192 - 2);
        v192 -= 2;
      }
      while (v192 != (id *)v191);
      v193 = v256;
    }
    uint64_t v257 = (uint64_t)v191;
    operator delete(v193);
  }

  return v222;
}

void sub_180D01AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  id v23 = *(void **)(v21 - 248);
  if (v23)
  {
    *(void *)(v21 - 240) = v23;
    operator delete(v23);
  }
  uint64_t v24 = *(void *)(v21 - 184);
  if (v24)
  {
    uint64_t v25 = *(void *)(v21 - 176);
    unint64_t v26 = *(void **)(v21 - 184);
    if (v25 != v24)
    {
      do
      {

        uint64_t v27 = *(void **)(v25 - 16);
        v25 -= 16;
      }
      while (v25 != v24);
      unint64_t v26 = *(void **)(v21 - 184);
    }
    *(void *)(v21 - 176) = v24;
    operator delete(v26);
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZN16GPURegionRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPb_block_invoke_2(uint64_t result, void *a2)
{
  if (!a2[2]) {
    return [*(id *)(result + 32) encodeSignalEvent:a2[1] value:a2[3]];
  }
  return result;
}

uint64_t ___ZN16GPURegionRuntime11evaluateOpsEPN3GPU16EncodeDescriptorEP7NSArrayIP18MPSGraphTensorDataES7__block_invoke(uint64_t a1, void *a2)
{
  return [a2 copyDataFromNDArrayToImageBatchWithCommandBuffer:*(void *)(*(void *)(a1 + 32) + 8)];
}

uint64_t GPURegionRuntime::postEvalCleanUp(GPURegionRuntime *this)
{
  if (*((void *)this + 79))
  {
    unint64_t v2 = (void *)*((void *)this + 78);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        unint64_t v2 = v3;
      }
      while (v3);
    }
    *((void *)this + 78) = 0;
    uint64_t v4 = *((void *)this + 77);
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
        *(void *)(*((void *)this + 76) + 8 * i) = 0;
    }
    *((void *)this + 79) = 0;
  }
  if (*((void *)this + 14))
  {
    uint64_t v6 = (void *)*((void *)this + 13);
    if (v6)
    {
      do
      {
        unint64_t v22 = (void *)*v6;
        id v23 = (id *)v6[5];
        if (v23)
        {
          do
          {
            uint64_t v24 = (id *)*v23;

            operator delete(v23);
            id v23 = v24;
          }
          while (v24);
        }
        uint64_t v25 = (void *)v6[3];
        v6[3] = 0;
        if (v25) {
          operator delete(v25);
        }
        operator delete(v6);
        uint64_t v6 = v22;
      }
      while (v22);
    }
    *((void *)this + 13) = 0;
    uint64_t v7 = *((void *)this + 12);
    if (v7)
    {
      for (uint64_t j = 0; j != v7; ++j)
        *(void *)(*((void *)this + 11) + 8 * j) = 0;
    }
    *((void *)this + 14) = 0;
  }
  if (*((void *)this + 41))
  {
    unsigned int v9 = (void *)*((void *)this + 40);
    if (v9)
    {
      do
      {
        unint64_t v26 = (void *)*v9;
        uint64_t v27 = (void *)v9[5];
        if (v27)
        {
          do
          {
            uint64_t v28 = (void *)*v27;
            operator delete(v27);
            uint64_t v27 = v28;
          }
          while (v28);
        }
        uint64_t v29 = (void *)v9[3];
        v9[3] = 0;
        if (v29) {
          operator delete(v29);
        }
        operator delete(v9);
        unsigned int v9 = v26;
      }
      while (v26);
    }
    *((void *)this + 40) = 0;
    uint64_t v10 = *((void *)this + 39);
    if (v10)
    {
      for (uint64_t k = 0; k != v10; ++k)
        *(void *)(*((void *)this + 38) + 8 * k) = 0;
    }
    *((void *)this + 41) = 0;
  }
  if (*((void *)this + 46))
  {
    unint64_t v12 = (void *)*((void *)this + 45);
    if (v12)
    {
      do
      {
        uint64_t v30 = (void *)*v12;
        unint64_t v31 = (void *)v12[5];
        if (v31)
        {
          do
          {
            uint64_t v32 = (void *)*v31;
            operator delete(v31);
            unint64_t v31 = v32;
          }
          while (v32);
        }
        id v33 = (void *)v12[3];
        v12[3] = 0;
        if (v33) {
          operator delete(v33);
        }
        operator delete(v12);
        unint64_t v12 = v30;
      }
      while (v30);
    }
    *((void *)this + 45) = 0;
    uint64_t v13 = *((void *)this + 44);
    if (v13)
    {
      for (uint64_t m = 0; m != v13; ++m)
        *(void *)(*((void *)this + 43) + 8 * m) = 0;
    }
    *((void *)this + 46) = 0;
  }
  [*((id *)this + 16) removeAllObjects];
  [*((id *)this + 17) removeAllObjects];
  uint64_t v15 = *((unsigned int *)this + 116);
  if (v15)
  {
    uint64_t v16 = (uint64_t *)*((void *)this + 57);
    uint64_t v17 = 8 * v15;
    do
    {
      uint64_t v18 = *v16++;
      unsigned int v19 = *(void **)(v18 + 48);
      *(void *)(v18 + 48) = 0;

      v17 -= 8;
    }
    while (v17);
  }
  *((_DWORD *)this + 116) = 0;
  unint64_t v20 = *(uint64_t (**)(void))(**((void **)this + 56) + 72);

  return v20();
}

void GPURegionRuntime::encodeOp(GPURegionRuntime *this, mlir::GenericProgramPoint ***a2, id *a3)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t v64 = (mlir::Operation *)a2;
  id v5 = a2[6];
  uint64_t v6 = v5[2];
  if (v6 == (mlir::GenericProgramPoint *)&mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long __dst = v5[1];
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
    if (v8 == 21)
    {
      BOOL v9 = *AttrData == 0x6E656D6563616C70 && AttrData[1] == 0x6E6F696765722E74;
      if (v9 && *(void *)((char *)AttrData + 13) == 0x6C6C61635F6E6F69)
      {
        LOWORD(v77) = 1283;
        *(void *)&long long v75 = "classof on '";
        *(void *)&long long v76 = "placement.region_call";
        *((void *)&v76 + 1) = 21;
        id v70 = "' failed due to the operation not being registered";
        LOWORD(v74) = 259;
        llvm::operator+((uint64_t *)&v75, (uint64_t *)&v70, (uint64_t)&__dst);
        llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
      }
    }
    a2 = (mlir::GenericProgramPoint ***)v64;
  }
  else if (v6 == (mlir::GenericProgramPoint *)&mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    goto LABEL_82;
  }
  mlir::Block::getTerminator(a2[2]);
  if (v11 != v64)
  {
    if (!v64) {
      __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
    }
    if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v64))
    {
      uint64_t v67 = 0;
      uint64_t v68 = 0;
LABEL_48:
      unint64_t v31 = *((unsigned int *)v64 + 9);
      if (v31) {
        uint64_t v32 = (char *)v64 - 16;
      }
      else {
        uint64_t v32 = 0;
      }
      id v70 = v32;
      unint64_t v71 = v31;
      mlir::ResultRange::use_begin((uint64_t *)&v70, (uint64_t *)&__dst);
      uint64_t v33 = *((unsigned int *)v64 + 9);
      if (v33) {
        char v34 = (char *)v64 - 16;
      }
      else {
        char v34 = 0;
      }
      uint64_t v67 = v34;
      uint64_t v68 = v33;
      mlir::ResultRange::use_end((uint64_t *)&v67, (uint64_t *)&v70);
      long long v75 = __dst;
      long long v76 = v79;
      uint64_t v35 = v80;
      uint64_t v77 = v80;
      uint64_t v36 = v74;
      v65[0] = __dst;
      v65[1] = v79;
      uint64_t v66 = v80;
      if (v80 == v74) {
        return;
      }
      while (1)
      {
        uint64_t v37 = *(void *)(v35 + 16);
        if (*(_DWORD *)(v37 + 36) != 1) {
          goto LABEL_44;
        }
        uint64_t v38 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(v37 + 16)) + 48);
        unint64_t v39 = *(void **)(v38 + 16);
        if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
        {
          *(void *)&long long __dst = *(void *)(v38 + 8);
          size_t v40 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
          if (v41 == 13 && *v40 == 0x6974732E7873706DLL && *(void *)((char *)v40 + 5) == 0x6465686374697473)
          {
            LOWORD(v74) = 1283;
            id v70 = "classof on '";
            uint64_t v72 = "mpsx.stitched";
            uint64_t v73 = 13;
            uint64_t v67 = "' failed due to the operation not being registered";
            __int16 v69 = 259;
            llvm::operator+((uint64_t *)&v70, (uint64_t *)&v67, (uint64_t)&__dst);
            llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
          }
        }
        else if (v39 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
        {
          goto LABEL_44;
        }
        if (!*(_DWORD *)(v37 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        if (!(*(unsigned int (**)(void, uint64_t))(**((void **)this + 56) + 48))(*((void *)this + 56), v37 - 16))goto LABEL_44; {
        mlir::ResultRange::UseIterator::operator++((uint64_t *)v65);
        }
        uint64_t v35 = v66;
        if (v66 == v36) {
          return;
        }
      }
    }
    uint64_t InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v64);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
    uint64_t v67 = (const char *)v64;
    uint64_t v68 = InterfaceFor;
    *(void *)&long long __dst = &v79;
    *((void *)&__dst + 1) = 0x400000000;
    mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v67, (uint64_t)&__dst);
    uint64_t v13 = (uint64_t **)__dst;
    if (DWORD2(__dst))
    {
      uint64_t v14 = 40 * DWORD2(__dst) - 40;
      uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      do
      {
        if (!*v13) {
          __assert_rtn("doit", "Casting.h", 109, "Val && \"isa<> used on a null pointer\"");
        }
        uint64_t v16 = **v13;
        {
          uint64_t v63 = v13;
          id v62 = "!Name.empty() && \"Unable to find the template parameter!\"";
          uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
          int v21 = v20;
          uint64_t v13 = v63;
          if (v21)
          {
            id v70 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Read]";
            unint64_t v71 = 75;
            unint64_t v22 = llvm::StringRef::find((uint64_t *)&v70, "DesiredTypeName = ", 0x12uLL, 0);
            uint64_t v24 = v70;
            unint64_t v23 = v71;
            if (v71 >= v22) {
              unint64_t v25 = v22;
            }
            else {
              unint64_t v25 = v71;
            }
            unint64_t v26 = v71 - v25;
            uint64_t v27 = &v70[v25];
            v70 += v25;
            v71 -= v25;
            if (v23 <= v22)
            {
              int v61 = 33;
              goto LABEL_113;
            }
            if (v26 < 0x12) {
              __assert_rtn("drop_front", "StringRef.h", 614, "size() >= N && \"Dropping more elements than exist\"");
            }
            id v70 = v27 + 18;
            unint64_t v71 = v26 - 18;
            if (v26 == 18 || v24[v23 - 1] != 93)
            {
              int v61 = 36;
              id v62 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
LABEL_113:
              __assert_rtn("getTypeName", "TypeName.h", v61, v62);
            }
            if (v26 - 18 >= v26 - 19) {
              uint64_t v28 = v26 - 19;
            }
            else {
              uint64_t v28 = v26 - 18;
            }
            mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)(v27 + 18), v28);
            uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
            uint64_t v13 = v63;
          }
        }
        uint64_t v17 = v15[424];
        BOOL v9 = v16 == v17;
        BOOL v18 = v16 != v17;
        BOOL v19 = !v9 || v14 == 0;
        v14 -= 40;
        v13 += 5;
      }
      while (!v19);
      uint64_t v13 = (uint64_t **)__dst;
      if ((long long *)__dst != &v79) {
        goto LABEL_42;
      }
    }
    else
    {
      BOOL v18 = 0;
      if ((long long *)__dst != &v79) {
LABEL_42:
      }
        free(v13);
    }
    if (v18) {
      goto LABEL_44;
    }
    goto LABEL_48;
  }
LABEL_44:
  a2 = (mlir::GenericProgramPoint ***)v64;
  if (*((_DWORD *)v64 + 9) != 1) {
    goto LABEL_82;
  }
  uint64_t v29 = *((void *)v64 + 6);
  uint64_t v30 = *(void **)(v29 + 16);
  if (v30 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long __dst = *(void *)(v29 + 8);
    uint64_t v43 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
    if (v44 == 12 && *(void *)v43 == 0x736E6F632E73706DLL && *(_DWORD *)(v43 + 8) == 1953390964)
    {
      LOWORD(v77) = 1283;
      *(void *)&long long v75 = "classof on '";
      *(void *)&long long v76 = "mps.constant";
      *((void *)&v76 + 1) = 12;
      id v70 = "' failed due to the operation not being registered";
      LOWORD(v74) = 259;
      llvm::operator+((uint64_t *)&v75, (uint64_t *)&v70, (uint64_t)&__dst);
      llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
    }
LABEL_75:
    if (!*((_DWORD *)v64 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v47 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 56) + 64))(*((void *)this + 56), (uint64_t)v64 - 16);
    if (!v47)
    {
      a2 = (mlir::GenericProgramPoint ***)v64;
      goto LABEL_82;
    }
    uint64_t v48 = v46;
    uint64_t v49 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)this + 33, (uint64_t *)&v64);
    if (!v49) {
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    }
    uint64_t v50 = (GPU::BaseOpHandler *)v49[3];
    mlir::mps::CPUNDArray::CPUNDArray(&__dst, v47, v48);
    GPU::BaseOpHandler::encodeConstantOp(v50, a3, (const mlir::mps::CPUNDArray *)&__dst, 0);
    mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)&__dst);
    uint64_t v51 = *((unsigned int *)this + 116);
    if (v51 >= *((_DWORD *)this + 117))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 456, (char *)this + 472, v51 + 1, 8);
      *(void *)(*((void *)this + 57) + 8 * *((unsigned int *)this + 116)) = v50;
      unsigned int v52 = *((_DWORD *)this + 116);
      if (v52 < *((_DWORD *)this + 117)) {
        goto LABEL_80;
      }
    }
    else
    {
      *(void *)(*((void *)this + 57) + 8 * v51) = v50;
      unsigned int v52 = *((_DWORD *)this + 116);
      if (v52 < *((_DWORD *)this + 117))
      {
LABEL_80:
        *((_DWORD *)this + 116) = v52 + 1;
        return;
      }
    }
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  if (v30 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    goto LABEL_75;
  }
LABEL_82:
  *(void *)&long long v75 = a2[6][1];
  uint64_t v53 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v75);
  size_t v54 = strlen(v53);
  if (v54 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v55 = v54;
  if (v54 >= 0x17)
  {
    uint64_t v57 = (v54 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v54 | 7) != 0x17) {
      uint64_t v57 = v54 | 7;
    }
    uint64_t v58 = v57 + 1;
    p_dst = (long long *)operator new(v57 + 1);
    *((void *)&__dst + 1) = v55;
    *(void *)&long long v79 = v58 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    BYTE7(v79) = v54;
    p_dst = &__dst;
    if (!v54) {
      goto LABEL_90;
    }
  }
  memmove(p_dst, v53, v55);
LABEL_90:
  *((unsigned char *)p_dst + v55) = 0;
  uint64_t v59 = std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::find<std::string>((void *)this + 1, (uint64_t)&__dst);
  if (!v59) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  int v60 = *((_DWORD *)v59 + 10);
  switch(v60)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 133:
    case 134:
    case 135:
    case 136:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 152:
    case 153:
    case 154:
    case 155:
    case 157:
    case 158:
    case 159:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
      GPURegionRuntime::runOp<GPU::AbsoluteOpHandler>((uint64_t)this, (uint64_t)v64, (uint64_t)a3);
      break;
    default:
      if (!v60 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      break;
  }
  if (SBYTE7(v79) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_180D03BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180D03BE8);
}

uint64_t GPURegionRuntime::runOp<GPU::AbsoluteOpHandler>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a2;
  id v5 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 264), &v8);
  if (!v5) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  uint64_t v6 = (id *)v5[3];
  if (*(unsigned char *)(a1 + 220)) {
    objc_storeStrong((id *)(a3 + 80), v6[8]);
  }
  return (*((uint64_t (**)(id *, uint64_t))*v6 + 1))(v6, a3);
}

uint64_t getNumberOfUniqueUses(void *a1)
{
  unint64_t v1 = (void *)*a1;
  *(_OWORD *)int v20 = 0u;
  *(_OWORD *)long long __p = 0u;
  int v22 = 1065353216;
  uint64_t v2 = 0;
  if (v1)
  {
    do
    {
      uint64_t v3 = v1[2];
      unint64_t v19 = 0;
      uint64_t v4 = *(mlir::Block **)(v3 + 16);
      if (v4)
      {
        uint64_t ParentOp = mlir::Block::getParentOp(v4);
        unint64_t v19 = ParentOp;
        if (ParentOp)
        {
          if (llvm::DefaultDoCastIfPossible<mlir::mpsx::StitchedOp,mlir::Operation *,llvm::CastInfo<mlir::mpsx::StitchedOp,mlir::Operation *,void>>::doCastIfPossible(ParentOp))
          {
            if (v20[1])
            {
              unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * v19) + 8) ^ HIDWORD(v19));
              unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(v19) ^ (v6 >> 47) ^ v6);
              unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
              uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v20[1]);
              v9.i16[0] = vaddlv_u8(v9);
              if (v9.u32[0] > 1uLL)
              {
                unint64_t v10 = v8;
                if ((void *)v8 >= v20[1]) {
                  unint64_t v10 = v8 % (unint64_t)v20[1];
                }
              }
              else
              {
                unint64_t v10 = v8 & ((unint64_t)v20[1] - 1);
              }
              uint64_t v11 = (void *)*((void *)v20[0] + v10);
              if (v11)
              {
                unint64_t v12 = (void *)*v11;
                if (v12)
                {
                  if (v9.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v14 = v12[1];
                      if (v14 == v8)
                      {
                        if (v12[2] == v19) {
                          goto LABEL_27;
                        }
                      }
                      else if ((v14 & ((uint64_t)v20[1] - 1)) != v10)
                      {
                        goto LABEL_25;
                      }
                      unint64_t v12 = (void *)*v12;
                      if (!v12) {
                        goto LABEL_25;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v13 = v12[1];
                    if (v13 == v8)
                    {
                      if (v12[2] == v19) {
                        goto LABEL_27;
                      }
                    }
                    else
                    {
                      if ((void *)v13 >= v20[1]) {
                        v13 %= (unint64_t)v20[1];
                      }
                      if (v13 != v10) {
                        break;
                      }
                    }
                    unint64_t v12 = (void *)*v12;
                  }
                  while (v12);
                }
              }
            }
LABEL_25:
            std::__hash_table<mlir::Operation *,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,std::allocator<mlir::Operation *>>::__emplace_unique_key_args<mlir::Operation *,mlir::Operation * const&>((uint64_t)v20, (uint64_t *)&v19, &v19);
          }
        }
      }
      ++v2;
LABEL_27:
      unint64_t v1 = (void *)*v1;
    }
    while (v1);
    uint64_t v15 = __p[0];
    if (__p[0])
    {
      do
      {
        uint64_t v16 = (void *)*v15;
        operator delete(v15);
        uint64_t v15 = v16;
      }
      while (v16);
    }
    uint64_t v17 = v20[0];
    v20[0] = 0;
    if (v17) {
      operator delete(v17);
    }
  }
  return v2;
}

void sub_180D041D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_180D041E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

MPSGraphTensorData *GPURegionRuntime::allocateTensorDataForValue(uint64_t a1, uint64_t *a2, void *a3, char a4, uint64_t a5, unint64_t a6)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  id v131 = a2;
  id v125 = a3;
  *(void *)&v143[0] = a2;
  *(void *)&long long v139 = *((void *)mlir::Value::getParentRegion((mlir::Value *)v143) + 2);
  unint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 88), (uint64_t *)&v139);
  if (v10
    && (*(void *)&long long v127 = *(void *)&v143[0],
        (uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&v127)) != 0))
  {
    unint64_t v12 = (MPSGraphTensorData *)(id)v11[3];
    unint64_t v13 = v12;
    if (v12)
    {
      uint64_t v14 = [(MPSGraphTensorData *)v12 mpsndarray];
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) == 0) {
        goto LABEL_141;
      }
      uint64_t v16 = [(MPSGraphTensorData *)v13 mpsndarray];
      if ([v16 readCount])
      {

        goto LABEL_141;
      }
      BaseRuntime::unsetTensorDataFromDataMap(a1, (uint64_t)v131);
    }
  }
  else
  {
    unint64_t v13 = 0;
  }
  unint64_t StaticType = GPURegionRuntime::getStaticType(a1, (uint64_t)v131);
  BOOL v18 = (uint64_t **)StaticType;
  if (!StaticType)
  {
    uint64_t v112 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v113 = 650;
    uint64_t v114 = "Casting.h";
    int64_t v115 = "dyn_cast";
    goto LABEL_175;
  }
  if (!*(void *)StaticType)
  {
    uint64_t v112 = "abstractType && \"Malformed type storage object.\"";
    int v113 = 160;
    uint64_t v114 = "TypeSupport.h";
    int64_t v115 = "getAbstractType";
LABEL_175:
    __assert_rtn(v115, v114, v113, v112);
  }
  unint64_t v19 = *(void **)(*(void *)StaticType + 136);
  BOOL v20 = v19 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v19 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v20) {
    unint64_t v21 = StaticType;
  }
  else {
    unint64_t v21 = 0;
  }
  *(void *)&v143[0] = v21;
  if (v20)
  {
    if (mlir::TensorType::hasRank((mlir::TensorType *)v143)) {
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v143);
    }
    if (mlir::TensorType::hasRank((mlir::TensorType *)v143))
    {
      Value = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v143);
      if (!v23) {
        goto LABEL_25;
      }
      uint64_t v24 = 8 * v23;
      while (*Value != 0x8000000000000000)
      {
        ++Value;
        v24 -= 8;
        if (!v24) {
          goto LABEL_25;
        }
      }
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
  }
LABEL_25:
  uint64_t MPSDataType = getMPSDataType(v18);
  if (valueNeedsReturnAlloc(v131))
  {
    unint64_t v26 = [MPSGraphTensorData alloc];
    uint64_t v27 = *(void *)(a1 + 48);
    uint64_t v28 = getMPSShapeFromMLIR(v18);
    unint64_t v13 = [(MPSGraphTensorData *)v26 initWithDevice:v27 rowBytesAlignment:a6 shape:v28 dataType:MPSDataType];

    BaseRuntime::setTensorDataToDataMap(a1, v131, v13);
    goto LABEL_141;
  }
  BOOL v29 = (a4 & 1) != 0 || !valueCanBeTemporary(v131);
  BOOL v123 = v29;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  v143[4] = xmmword_181129AC0;
  v143[5] = unk_181129AD0;
  v143[6] = xmmword_181129AE0;
  v143[7] = unk_181129AF0;
  v143[0] = xmmword_181129A80;
  v143[1] = unk_181129A90;
  v143[2] = xmmword_181129AA0;
  v143[3] = unk_181129AB0;
  uint64_t MPSSizeVector = getMPSSizeVector(v18, &v127);
  if (MPSSizeVector)
  {
    uint64_t v31 = 0;
    long long v33 = v129;
    long long v32 = v130;
    long long v35 = v127;
    long long v34 = v128;
    do
    {
      v126[0] = v35;
      v126[1] = v34;
      v126[2] = v33;
      v126[3] = v32;
      *((void *)v143 + v31) = *((unsigned int *)v126 + (v31 & 0xF));
      ++v31;
    }
    while (MPSSizeVector != v31);
  }
  uint64_t v36 = [MEMORY[0x1E4F35720] descriptorWithDataType:getMPSDataType(v18) dimensionCount:MPSSizeVector dimensionSizes:v143];
  if (a6 != 1) {
    goto LABEL_56;
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v131);
  if (!DefiningOp) {
    goto LABEL_49;
  }
  uint64_t v38 = *(void *)(DefiningOp + 48);
  unint64_t v39 = *(void **)(v38 + 16);
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v139 = *(void *)(v38 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
    if (v41 == 26)
    {
      BOOL v42 = *(void *)AttrData == 0x6E656D6563616C70 && *(void *)(AttrData + 8) == 0x6665726D656D2E74;
      BOOL v43 = v42 && *(void *)(AttrData + 16) == 0x736E65745F6F745FLL;
      if (v43 && *(_WORD *)(AttrData + 24) == 29295)
      {
        __int16 v138 = 1283;
        uint64_t v134 = "classof on '";
        long long v136 = "placement.memref_to_tensor";
        uint64_t v137 = 26;
        v132[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v133 = 259;
        llvm::operator+((uint64_t *)&v134, v132, (uint64_t)&v139);
        llvm::report_fatal_error((llvm::Twine *)&v139, 1);
      }
    }
LABEL_49:
    unint64_t v45 = (void *)*v131;
    if (*v131)
    {
      a6 = 64;
      while (1)
      {
        uint64_t v46 = *(void *)(v45[2] + 48);
        uint64_t v47 = *(void **)(v46 + 16);
        if (v47 == &mlir::detail::TypeIDResolver<void,void>::id) {
          break;
        }
        if (v47 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
          goto LABEL_90;
        }
        unint64_t v45 = (void *)*v45;
        if (!v45) {
          goto LABEL_56;
        }
      }
      *(void *)&long long v139 = *(void *)(v46 + 8);
      uint64_t v59 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
      if (v60 == 26)
      {
        BOOL v61 = *(void *)v59 == 0x6E656D6563616C70 && *(void *)(v59 + 8) == 0x726F736E65742E74;
        BOOL v62 = v61 && *(void *)(v59 + 16) == 0x726D656D5F6F745FLL;
        if (v62 && *(_WORD *)(v59 + 24) == 26213)
        {
          __int16 v138 = 1283;
          uint64_t v134 = "classof on '";
          long long v136 = "placement.tensor_to_memref";
          uint64_t v137 = 26;
          v132[0] = (uint64_t)"' failed due to the operation not being registered";
          __int16 v133 = 259;
          llvm::operator+((uint64_t *)&v134, v132, (uint64_t)&v139);
          llvm::report_fatal_error((llvm::Twine *)&v139, 1);
        }
      }
LABEL_90:
      [v36 setPreferPackedRows:1];
      goto LABEL_57;
    }
    goto LABEL_55;
  }
  if (v39 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id) {
    goto LABEL_49;
  }
LABEL_55:
  a6 = 64;
LABEL_56:
  [v36 setRowBytes:(a6 + *(void *)&v143[0] * ((unsigned __int16)MPSDataType >> 3) - 1) / a6 * a6];
LABEL_57:
  int8x8_t v48 = *(int8x8_t *)(a1 + 616);
  if (!*(void *)&v48) {
    goto LABEL_98;
  }
  unint64_t v49 = 0x9DDFEA08EB382D69 * (((8 * v131) + 8) ^ ((unint64_t)v131 >> 32));
  unint64_t v50 = 0x9DDFEA08EB382D69 * (((unint64_t)v131 >> 32) ^ (v49 >> 47) ^ v49);
  unint64_t v51 = 0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47));
  uint8x8_t v52 = (uint8x8_t)vcnt_s8(v48);
  v52.i16[0] = vaddlv_u8(v52);
  if (v52.u32[0] > 1uLL)
  {
    unint64_t v53 = v51;
    if (v51 >= *(void *)&v48) {
      unint64_t v53 = v51 % *(void *)&v48;
    }
  }
  else
  {
    unint64_t v53 = v51 & (*(void *)&v48 - 1);
  }
  size_t v54 = *(uint64_t ****)(*(void *)(a1 + 608) + 8 * v53);
  if (!v54) {
    goto LABEL_98;
  }
  size_t v55 = *v54;
  if (!v55) {
    goto LABEL_98;
  }
  if (v52.u32[0] < 2uLL)
  {
    uint64_t v56 = *(void *)&v48 - 1;
    while (1)
    {
      uint64_t v58 = v55[1];
      if (v58 == (uint64_t *)v51)
      {
        if (v55[2] == v131) {
          goto LABEL_91;
        }
      }
      else if (((unint64_t)v58 & v56) != v53)
      {
        goto LABEL_98;
      }
      size_t v55 = (uint64_t **)*v55;
      if (!v55) {
        goto LABEL_98;
      }
    }
  }
  while (1)
  {
    unint64_t v57 = (unint64_t)v55[1];
    if (v57 == v51) {
      break;
    }
    if (v57 >= *(void *)&v48) {
      v57 %= *(void *)&v48;
    }
    if (v57 != v53) {
      goto LABEL_98;
    }
LABEL_67:
    size_t v55 = (uint64_t **)*v55;
    if (!v55) {
      goto LABEL_98;
    }
  }
  if (v55[2] != v131) {
    goto LABEL_67;
  }
LABEL_91:
  *(void *)&long long v139 = v55[3];
  uint64_t v134 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v139) + 2);
  uint64_t v64 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 88), (uint64_t *)&v134);
  if (!v64
    || (v132[0] = v139,
        (uint64_t v65 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v64 + 3, v132)) == 0))
  {
LABEL_98:
    uint64_t v67 = 0;
    goto LABEL_99;
  }
  uint64_t v66 = (char *)(id)v65[3];
  uint64_t v67 = v66;
  if (v66)
  {
    uint64_t v68 = [v66 mpsndarray];
    __int16 v69 = (uint64_t **)GPURegionRuntime::getStaticType(a1, (uint64_t)v131);
    id v70 = getMPSShapeFromMLIR(v69);
    id v71 = objc_alloc_init(MEMORY[0x1E4F35770]);
    [v71 setLabel:@"reshapeAliasedTensor"];
    uint64_t v72 = [v71 reshapeWithCommandBuffer:v125 sourceArray:v68 shape:v70 destinationArray:0];
    if (v72)
    {
      unint64_t v13 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v72];
      BaseRuntime::setTensorDataToDataMap(a1, v131, v13);
    }

    if (v72) {
      goto LABEL_140;
    }
  }
LABEL_99:

  uint64_t v73 = v131;
  id v74 = v125;
  id v75 = v36;
  uint64_t v76 = v73[1];
  uint64_t v67 = (char *)(v76 & 0xFFFFFFFFFFFFFFF8);
  if ((v76 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    BOOL v116 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v117 = 650;
    unint64_t v118 = "Casting.h";
    uint64_t v119 = "dyn_cast";
    goto LABEL_178;
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v76 & 0xFFFFFFFFFFFFFFF8)))
  {
    uint64_t v67 = 0;
    uint64_t v134 = 0;
    uint64_t v135 = 0;
    goto LABEL_137;
  }
  uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)v67);
  if (!InterfaceFor)
  {
    BOOL v116 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v117 = 98;
    unint64_t v118 = "InterfaceSupport.h";
    uint64_t v119 = "Interface";
LABEL_178:
    __assert_rtn(v119, v118, v117, v116);
  }
  uint64_t v134 = v67;
  uint64_t v135 = InterfaceFor;
  if (!v67) {
    goto LABEL_137;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v134)) {
    goto LABEL_136;
  }
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v134);
  if (v79)
  {
    uint64_t v80 = 8 * v79;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v80 -= 8;
      if (!v80) {
        goto LABEL_110;
      }
    }
    goto LABEL_136;
  }
LABEL_110:
  uint64_t v81 = (void *)*v73;
  v132[0] = 0;
  if (!v81) {
    goto LABEL_136;
  }
  uint64_t v82 = 0;
  do
  {
    uint64_t v83 = v81[2];
    if (v83)
    {
      *(void *)&long long v139 = llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible(v81[2]);
      if ((void)v139
        && !mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v139))
      {
        ++v82;
        v132[0] = v139;
      }
      else if (llvm::DefaultDoCastIfPossible<mlir::mps::StridedSliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StridedSliceOp,mlir::Operation *,void>>::doCastIfPossible(v83) {
             || llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible(v83)
      }
             || llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible(v83)
             || llvm::DefaultDoCastIfPossible<mlir::mps::ReshapeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReshapeOp,mlir::Operation *,void>>::doCastIfPossible(v83)
             || llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible(v83)
             || llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible(v83)
             || llvm::DefaultDoCastIfPossible<mlir::mps::Flatten2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Flatten2DOp,mlir::Operation *,void>>::doCastIfPossible(v83))
      {
        ++v82;
      }
    }
    uint64_t v81 = (void *)*v81;
  }
  while (v81);
  if (v82 != 1 || !v132[0]) {
    goto LABEL_136;
  }
  if (!*(_DWORD *)(v132[0] + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  if (!isStaticMPSType((uint64_t **)(*(void *)(v132[0] - 8) & 0xFFFFFFFFFFFFFFF8)))
  {
LABEL_136:
    uint64_t v67 = 0;
    goto LABEL_137;
  }
  if (!*(_DWORD *)(v132[0] + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  int v84 = (*(void (**)(uint64_t, uint64_t, id, BOOL, void, uint64_t))(*(void *)a1 + 80))(a1, v132[0] - 16, v74, v123, 0, 1);
  if (v84)
  {
    uint64_t v120 = v84;
    uint64_t Values = mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)v132);
    uint64_t v87 = v86;
    if (!v86) {
      __assert_rtn("tryConcatAliasedTarget", "MPSRuntime.mm", 871, "inputs.size() > 0");
    }
    uint64_t v88 = Values;
    uint64_t v89 = [v75 numberOfDimensions];
    uint64_t Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)v132);
    char v91 = 0;
    char v92 = 0;
    uint64_t v93 = v89 + ~RuntimeUtils::getAxis(Axis, v89);
    if (!v89) {
      uint64_t v93 = 0;
    }
    uint64_t v121 = v93;
    uint64_t v122 = 0;
    uint64_t v94 = (uint64_t **)(v88 + 24);
    do
    {
      unint64_t v104 = *v94;
      BOOL v105 = *v94 == v73;
      if (!(v91 & 1 | v105))
      {
        long long v141 = 0u;
        long long v142 = 0u;
        long long v139 = 0u;
        long long v140 = 0u;
        uint64_t v106 = getMPSSizeVector((uint64_t **)(v104[1] & 0xFFFFFFFFFFFFFFF8), &v139);
        if (v106)
        {
          if (v121 < v106) {
            v122 += *((unsigned int *)&v139 + (v121 & 0xF));
          }
        }
        else
        {
          ++v122;
        }
      }
      v92 |= v91 & v105;
      v94 += 4;
      v91 |= v105;
      --v87;
    }
    while (v87);
    if (v92)
    {
      uint64_t v67 = 0;
      int v84 = v120;
    }
    else
    {
      long long v141 = 0u;
      long long v142 = 0u;
      long long v139 = 0u;
      long long v140 = 0u;
      uint64_t v107 = getMPSSizeVector((uint64_t **)(v73[1] & 0xFFFFFFFFFFFFFFF8), &v139);
      if (v121 >= v107) {
        unsigned int v108 = v107 == 0;
      }
      else {
        unsigned int v108 = *((_DWORD *)&v139 + (v121 & 0xF));
      }
      uint64_t v109 = [v120 mpsndarray];
      uint64_t v110 = [v109 descriptor];

      objc_msgSend(v110, "sliceDimension:withSubrange:", v121, objc_msgSend(v110, "sliceRangeForDimension:", v121) + v122, v108);
      char v111 = [v120 mpsndarray];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        objc_msgSend(v111, "setReadCount:", objc_msgSend(v111, "readCount") + 1);
      }
      uint64_t v67 = [v111 safeArrayViewWithCommandBuffer:v74 descriptor:v110 aliasing:1];
      if (!v67) {
        __assert_rtn("tryConcatAliasedTarget", "MPSRuntime.mm", 911, "ndarray");
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [v67 setReadCount:getNumberOfUniqueUses(v73)];
      }

      int v84 = v120;
    }
  }
  else
  {
    uint64_t v67 = 0;
  }

LABEL_137:
  if (!v67)
  {
    if (v74)
    {
      if (v123 || !*(unsigned char *)(a1 + 224))
      {
        id v100 = objc_alloc(MEMORY[0x1E4F35690]);
        uint64_t v101 = [v74 device];
        uint64_t v67 = (char *)[v100 initWithDevice:v101 descriptor:v75];
      }
      else
      {
        uint64_t v67 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v74 descriptor:v75];
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [v67 setReadCount:getNumberOfUniqueUses(v131) + a5];
      }
    }
    else
    {
      id v102 = objc_alloc(MEMORY[0x1E4F35690]);
      uint64_t v103 = [*(id *)(a1 + 48) metalDevice];
      uint64_t v67 = (char *)[v102 initWithDevice:v103 descriptor:v75];
    }
  }
  unint64_t v13 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v67 device:*(void *)(a1 + 48)];
  BaseRuntime::setTensorDataToDataMap(a1, v131, v13);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  BOOL v96 = ([WeakRetained options] & 2) == 0;

  if (!v96)
  {
    uint64_t v97 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v131);
    uint64_t v98 = getOpName(v97);
    [(MPSGraphTensorData *)v13 setLabel:v98];
  }
LABEL_140:

LABEL_141:

  return v13;
}

void sub_180D05034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void BaseRuntime::unsetTensorDataFromDataMap(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a2;
  uint64_t v7 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v8) + 2);
  __p[0] = &v7;
  uint64_t v3 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(a1 + 88, &v7, (uint64_t)&std::piecewise_construct, (void **)__p)+ 24;
  uint64_t v6 = v8;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v3, &v6);
  if (v4)
  {
    std::__hash_table<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>>>::remove(v3, v4, (uint64_t)__p);
    id v5 = (id *)__p[0];
    __p[0] = 0;
    if (v5)
    {
      if (v10) {

      }
      operator delete(v5);
    }
  }
}

unint64_t GPURegionRuntime::getStaticType(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = a2;
  uint64_t v4 = (uint64_t **)(*(uint64_t (**)(void))(**(void **)(a1 + 448) + 40))(*(void *)(a1 + 448));
  if (v4) {
    return (unint64_t)v4;
  }
  if (isStaticMPSType((uint64_t **)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8))) {
    return *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
  }
  v22[0] = 0;
  v22[1] = 0;
  unint64_t v21 = (uint64_t **)v22;
  uint64_t v24 = a2;
  if (!a2) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v21, DefiningOp))
  {
    uint64_t v24 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v23) + 2);
    uint64_t v7 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 304), &v24);
    if (!v7)
    {
      uint8x8_t v9 = (llvm::raw_ostream *)llvm::errs(0);
      uint64_t v11 = mlir::operator<<(v10, v23);
      uint64_t v14 = mlir::operator<<(v13, *(void *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8);
      __assert_rtn("getStaticType", "MPSRuntime_Project.h", 705, "0 && \"value has no static type\"");
    }
    unint64_t v21 = (uint64_t **)v23;
    uint64_t v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7 + 3, (uint64_t *)&v21);
    if (!v8)
    {
      uint64_t v15 = (llvm::raw_ostream *)llvm::errs(0);
      uint64_t v17 = mlir::operator<<(v16, v23);
      BOOL v20 = mlir::operator<<(v19, *(void *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8);
      __assert_rtn("getStaticType", "MPSRuntime_Project.h", 714, "0 && \"value has no static type\"");
    }
    uint64_t v4 = (uint64_t **)v8[3];
    if ((isStaticMPSType(v4) & 1) == 0) {
      __assert_rtn("getStaticType", "MPSRuntime_Project.h", 717, "isStaticMPSType(ty)");
    }
    return (unint64_t)v4;
  }
  return mlir::ElementsAttr::getType((mlir::ElementsAttr *)v22);
}

BOOL valueNeedsReturnAlloc(void *a1)
{
  uint64_t v16 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  if (DefiningOp
    && llvm::DefaultDoCastIfPossible<mlir::mps::CallOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CallOp,mlir::Operation *,void>>::doCastIfPossible(DefiningOp))
  {
    return 1;
  }
  uint64_t v3 = v16;
  uint64_t v4 = (void *)*v16;
  if (*v16)
  {
    while (1)
    {
      uint64_t v5 = *(void *)(v4[2] + 48);
      uint64_t v6 = *(void **)(v5 + 16);
      if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v23[0] = *(void *)(v5 + 8);
        uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
        if (v8 == 8 && *AttrData == 0x6C6C61632E73706DLL)
        {
          __int16 v22 = 1283;
          unint64_t v19 = "classof on '";
          BOOL v20 = "mps.call";
          uint64_t v9 = 8;
          goto LABEL_31;
        }
      }
      else if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::CallOp,void>::id)
      {
        return 1;
      }
      uint64_t v4 = (void *)*v4;
      if (!v4)
      {
        uint64_t v3 = v16;
        break;
      }
    }
  }
  if ((isStaticMPSType((uint64_t **)(v3[1] & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
  {
    char v10 = (void *)*v16;
    if (*v16)
    {
      LOBYTE(result) = 0;
      while (1)
      {
        if (result)
        {
          BOOL result = 1;
        }
        else
        {
          uint64_t v11 = *(void *)(v10[2] + 48);
          unint64_t v12 = *(void **)(v11 + 16);
          if (v12 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v23[0] = *(void *)(v11 + 8);
            unint64_t v13 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
            if (v14 == 11 && *v13 == 0x7465722E636E7566 && *(void *)((char *)v13 + 3) == 0x6E72757465722E63)
            {
              __int16 v22 = 1283;
              unint64_t v19 = "classof on '";
              BOOL v20 = "func.return";
              uint64_t v9 = 11;
LABEL_31:
              uint64_t v21 = v9;
              uint64_t v17 = "' failed due to the operation not being registered";
              __int16 v18 = 259;
              llvm::operator+((uint64_t *)&v19, (uint64_t *)&v17, (uint64_t)v23);
              llvm::report_fatal_error((llvm::Twine *)v23, 1);
            }
            BOOL result = 0;
          }
          else
          {
            BOOL result = v12 == &mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id;
          }
        }
        char v10 = (void *)*v10;
        if (!v10) {
          return result;
        }
      }
    }
  }
  return 0;
}

BOOL valueCanBeTemporary(void *a1)
{
  uint64_t v31 = a1;
  ParentBlocuint64_t k = mlir::Value::getParentBlock((mlir::Value *)&v31);
  uint64_t v3 = (void *)*v31;
  if (!*v31) {
    return !valueNeedsReturnAlloc(a1);
  }
  uint64_t v4 = (mlir::Block *)ParentBlock;
  while (1)
  {
    uint64_t v5 = v3[2];
    uint64_t v6 = *(mlir::Block **)(v5 + 16);
    uint64_t v7 = *(void *)(mlir::Block::getParentOp(v6) + 48);
    uint64_t v8 = *(void **)(v7 + 16);
    if (v8 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v38[0] = *(void *)(v7 + 8);
      uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v38);
      if (v10 == 13 && *AttrData == 0x6974732E7873706DLL && *(void *)((char *)AttrData + 5) == 0x6465686374697473)
      {
        __int16 v37 = 1283;
        long long v34 = "classof on '";
        long long v35 = "mpsx.stitched";
        uint64_t v30 = 13;
LABEL_48:
        uint64_t v36 = v30;
        long long v32 = "' failed due to the operation not being registered";
        __int16 v33 = 259;
        llvm::operator+((uint64_t *)&v34, (uint64_t *)&v32, (uint64_t)v38);
        llvm::report_fatal_error((llvm::Twine *)v38, 1);
      }
    }
    else if (v8 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      uint64_t v6 = *(mlir::Block **)(mlir::Block::getParentOp(v6) + 16);
    }
    uint64_t v12 = *(void *)(v5 + 48);
    unint64_t v13 = *(void **)(v12 + 16);
    if (v13 != &mlir::detail::TypeIDResolver<void,void>::id) {
      break;
    }
    v38[0] = *(void *)(v12 + 8);
    uint64_t v14 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v38);
    if (v15 == 19)
    {
      BOOL v16 = *v14 == 0x73696C2E7873706DLL && v14[1] == 0x625F687375705F74;
      if (v16 && *(void *)((char *)v14 + 11) == 0x6B6361625F687375)
      {
        __int16 v37 = 1283;
        long long v34 = "classof on '";
        long long v35 = "mpsx.list_push_back";
        uint64_t v30 = 19;
        goto LABEL_48;
      }
    }
LABEL_27:
    while (v6 != v4)
    {
      uint64_t ParentOp = mlir::Block::getParentOp(v6);
      uint64_t v19 = *(void *)(ParentOp + 48);
      BOOL v20 = *(void **)(v19 + 16);
      if (v20 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v38[0] = *(void *)(v19 + 8);
        uint64_t v21 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v38);
        if (v22 == 9 && *(void *)v21 == 0x6C6968772E666373 && *(unsigned char *)(v21 + 8) == 101)
        {
          __int16 v37 = 1283;
          long long v34 = "classof on '";
          long long v35 = "scf.while";
          uint64_t v30 = 9;
          goto LABEL_48;
        }
      }
      else if (v20 == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
      {
        return 0;
      }
      uint64_t v24 = *(void *)(ParentOp + 48);
      unint64_t v25 = *(void **)(v24 + 16);
      if (v25 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v38[0] = *(void *)(v24 + 8);
        unint64_t v26 = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v38);
        if (v27 == 7 && *v26 == 778462067 && *(_DWORD *)((char *)v26 + 3) == 1919903278)
        {
          __int16 v37 = 1283;
          long long v34 = "classof on '";
          long long v35 = "scf.for";
          uint64_t v30 = 7;
          goto LABEL_48;
        }
      }
      else if (v25 == &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
      {
        return 0;
      }
      uint64_t v6 = *(mlir::Block **)(ParentOp + 16);
    }
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      return !valueNeedsReturnAlloc(a1);
    }
  }
  if (v13 != &mlir::detail::TypeIDResolver<mlir::mpsx::ListPushBackOp,void>::id) {
    goto LABEL_27;
  }
  return 0;
}

id GPURegionRuntime::allocateTensorDataForTargets(GPURegionRuntime *this, mlir::Operation *a2)
{
  id v29 = (id)[MEMORY[0x1E4F1CBF0] mutableCopy];
  if ((*((unsigned char *)a2 + 46) & 0x80) != 0)
  {
    uint64_t v4 = *((unsigned int *)a2 + 17);
    if (v4)
    {
      unint64_t v5 = 0;
      uint64_t v6 = 24;
      do
      {
        while (1)
        {
          if ((*((unsigned char *)a2 + 46) & 0x80) == 0)
          {
            int v21 = 960;
            uint64_t v22 = "hasOperandStorage && \"expected operation to have operand storage\"";
            uint64_t v23 = "Operation.h";
            uint64_t v24 = "getOperandStorage";
            goto LABEL_31;
          }
          if (v5 >= *((unsigned int *)a2 + 17))
          {
            int v21 = 443;
            uint64_t v24 = "operator[]";
            uint64_t v23 = "ArrayRef.h";
            uint64_t v22 = "Index < this->size() && \"Invalid index!\"";
LABEL_31:
            __assert_rtn(v24, v23, v21, v22);
          }
          uint64_t v30 = *(uint64_t **)(*((void *)a2 + 9) + v6);
          __int16 v33 = v30;
          uint64_t v32 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v33) + 2);
          uint64_t v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)this + 11, &v32);
          if (!v8) {
            break;
          }
          uint64_t v31 = v33;
          uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, (uint64_t *)&v31);
          if (!v9) {
            break;
          }
          id v10 = (id)v9[3];
          if (!v10) {
            break;
          }
          uint64_t v7 = v10;
          [v29 addObject:v10];
LABEL_5:

          ++v5;
          v6 += 32;
          if (v4 == v5) {
            goto LABEL_26;
          }
        }
        if ((isStaticMPSType((uint64_t **)(v30[1] & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
        {
          uint64_t v7 = [MEMORY[0x1E4F1CA98] null];
          [v29 addObject:v7];
          goto LABEL_5;
        }
        uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v30);
        if (!DefiningOp)
        {
          __int16 v33 = 0;
LABEL_24:
          uint64_t v15 = 16;
          goto LABEL_25;
        }
        __int16 v33 = (uint64_t *)llvm::DefaultDoCastIfPossible<mlir::placement::MemrefToTensor,mlir::Operation *,llvm::CastInfo<mlir::placement::MemrefToTensor,mlir::Operation *,void>>::doCastIfPossible(DefiningOp);
        if (!v33) {
          goto LABEL_24;
        }
        uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v33);
        unint64_t v13 = *(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8;
        if (!v13)
        {
          int v25 = 650;
          unint64_t v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          uint64_t v27 = "Casting.h";
          uint64_t v28 = "dyn_cast";
          goto LABEL_34;
        }
        if (!*(void *)v13)
        {
          int v25 = 160;
          uint64_t v28 = "getAbstractType";
          uint64_t v27 = "TypeSupport.h";
          unint64_t v26 = "abstractType && \"Malformed type storage object.\"";
LABEL_34:
          __assert_rtn(v28, v27, v25, v26);
        }
        if (*(_UNKNOWN **)(*(void *)v13 + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
          unint64_t v14 = *(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8;
        }
        else {
          unint64_t v14 = 0;
        }
        if ((getMemRefRowBytes(v14) & 0x3F) != 0) {
          uint64_t v15 = 16;
        }
        else {
          uint64_t v15 = 64;
        }
LABEL_25:
        BOOL v16 = [MPSGraphTensorData alloc];
        uint64_t v17 = *((void *)this + 6);
        __int16 v18 = getMPSShapeFromMLIR((uint64_t **)(v30[1] & 0xFFFFFFFFFFFFFFF8));
        uint64_t v19 = [(MPSGraphTensorData *)v16 initWithDevice:v17 rowBytesAlignment:v15 shape:v18 dataType:getMPSDataType((void *)(v30[1] & 0xFFFFFFFFFFFFFFF8))];

        BaseRuntime::setTensorDataToDataMap((uint64_t)this, v30, v19);
        [v29 addObject:v19];

        ++v5;
        v6 += 32;
      }
      while (v4 != v5);
    }
  }
LABEL_26:

  return v29;
}

void sub_180D05D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_180D05E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void GPURegionRuntime::copyNDArrayToTarget(void *a1, void *a2, void *a3, id *a4, void *a5, void *a6, uint64_t *a7, uint64_t a8)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  id v34 = a2;
  id v35 = a3;
  id v15 = a5;
  id v16 = a6;
  uint64_t v17 = (int *)MEMORY[0x1E4F359C0];
  if (v16
    || *((unsigned char *)v15 + (int)*MEMORY[0x1E4F359C0])
    && !valueCanBeTemporary(a7)
    && ((*(void (**)(void *, uint64_t *, id, uint64_t, void, uint64_t))(*a1 + 80))(a1, a7, v35, 1, 0, 1), (id v16 = (id)objc_claimAutoreleasedReturnValue()) != 0))
  {
    __int16 v18 = objc_msgSend(v16, "mpsndarray", v34);
    if (!*a4)
    {
      id v19 = objc_alloc(MEMORY[0x1E4F35770]);
      BOOL v20 = [v18 device];
      uint64_t v21 = [v19 initWithDevice:v20];
      id v22 = *a4;
      *a4 = (id)v21;

      objc_msgSend(*a4, "setOptions:", objc_msgSend(*a4, "options") | 1);
    }
    uint64_t v23 = [v18 buffer];
    uint64_t v24 = [v15 buffer];

    if (v23 != v24)
    {
      if (*((unsigned char *)v15 + *v17) && ![v15 readCount]) {
        __assert_rtn("copyNDArrayToTarget", "MPSRuntime.mm", 1131, "((MPSTemporaryNDArray *)result).readCount != 0");
      }
      id v25 = *a4;
      v36[0] = v15;
      unint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithObjects:v36 count:1];
      [v25 encodeToMPSCommandEncoder:v34 commandBuffer:v35 sourceArrays:v26 destinationArray:v18];
    }
    if (*((unsigned char *)v18 + *v17))
    {
      uint64_t NumberOfUniqueUses = getNumberOfUniqueUses(a7);
      uint64_t v28 = [v18 buffer];
      id v29 = [v15 buffer];
      BOOL v30 = v28 == v29;

      uint64_t v31 = NumberOfUniqueUses + a8;
      if (v30) {
        uint64_t v31 = v31 + [v18 readCount] - 1;
      }
      [v18 setReadCount:v31];
    }
    uint64_t v32 = (MPSGraphTensorData *)v16;

    __int16 v33 = v32;
  }
  else
  {
    if (*((unsigned char *)v15 + *v17)) {
      objc_msgSend(v15, "setReadCount:", a8 + getNumberOfUniqueUses(a7) + objc_msgSend(v15, "readCount") - 1);
    }
    uint64_t v32 = 0;
    __int16 v33 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v15 device:a1[6]];
  }
  BaseRuntime::setTensorDataToDataMap((uint64_t)a1, a7, v33);
}

void sub_180D06180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void GPURegionRuntime::readIntTensorData(uint64_t a1@<X0>, void *a2@<X1>, unsigned char *a3@<X2>, char **a4@<X8>)
{
  v87[4] = *MEMORY[0x1E4F143B8];
  id v85 = (char *)v87;
  uint64_t v86 = 0x400000000;
  if (!mlir::matchConstantWithIntVector<long long>((uint64_t)a2, (uint64_t)&v85))
  {
    uint64_t v81 = a2;
    uint64_t v80 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v81) + 2);
    uint64_t v32 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 88), &v80);
    if (v32
      && (uint64_t v79 = v81,
          (__int16 v33 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v32 + 3, (uint64_t *)&v79)) != 0))
    {
      id v72 = (id)v33[3];
    }
    else
    {
      id v72 = 0;
    }
    unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(a1, (uint64_t)a2);
    id v35 = getMPSShapeFromMLIR(StaticType);
    int MPSDataType = getMPSDataType(StaticType);
    unsigned __int16 v37 = MPSDataType;
    if (MPSDataType > 536870943)
    {
      if (MPSDataType != 536870944 && MPSDataType != 536870976) {
LABEL_99:
      }
        __assert_rtn("readIntTensorData", "MPSRuntime.mm", 1179, "dataType == MPSDataTypeInt32 || dataType == MPSDataTypeUInt32 || dataType == MPSDataTypeInt64 || dataType == MPSDataTypeUInt64");
    }
    else if (MPSDataType != 32 && MPSDataType != 64)
    {
      goto LABEL_99;
    }
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    id v38 = v35;
    uint64_t v39 = [v38 countByEnumeratingWithState:&v75 objects:v84 count:16];
    uint64_t v40 = v37 >> 3;
    if (v39)
    {
      uint64_t v41 = *(void *)v76;
      do
      {
        for (uint64_t i = 0; i != v39; ++i)
        {
          if (*(void *)v76 != v41) {
            objc_enumerationMutation(v38);
          }
          id v43 = *(id *)(*((void *)&v75 + 1) + 8 * i);
          uint64_t v44 = [v43 unsignedLongValue];

          v40 *= v44;
        }
        uint64_t v39 = [v38 countByEnumeratingWithState:&v75 objects:v84 count:16];
      }
      while (v39);
    }

    if (v40)
    {
      uint64_t v45 = (*(uint64_t (**)(void, void *))(**(void **)(a1 + 448) + 64))(*(void *)(a1 + 448), a2);
      if (v45)
      {
        uint64_t v81 = v83;
        uint64_t v82 = 0x400000000;
        mlir::getIntValues<long long>(v45, v46, (uint64_t)&v81, 1);
        *a4 = 0;
        a4[1] = 0;
        a4[2] = 0;
        uint64_t v47 = (char *)v81;
        if (v82)
        {
          int8x8_t v48 = 0;
          unint64_t v49 = (char *)v81 + 8 * v82;
          uint64_t v73 = v49;
          while (1)
          {
            while (1)
            {
              uint64_t v50 = *(void *)v47;
              unint64_t v51 = (unint64_t)a4[2];
              if ((unint64_t)v48 >= v51) {
                break;
              }
              *(void *)int8x8_t v48 = v50;
              v48 += 8;
              a4[1] = v48;
              v47 += 8;
              if (v47 == v49) {
                goto LABEL_86;
              }
            }
            uint8x8_t v52 = *a4;
            uint64_t v53 = v48 - *a4;
            uint64_t v54 = v53 >> 3;
            unint64_t v55 = (v53 >> 3) + 1;
            if (v55 >> 61) {
              std::vector<long>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v56 = v51 - (void)v52;
            if (v56 >> 2 > v55) {
              unint64_t v55 = v56 >> 2;
            }
            if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v57 = v55;
            }
            if (v57)
            {
              if (v57 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v58 = operator new(8 * v57);
              uint64_t v59 = &v58[8 * v54];
              *(void *)uint64_t v59 = v50;
              uint64_t v60 = (uint64_t)(v59 + 8);
              int64_t v61 = v48 - v52;
              if (v48 == v52) {
                goto LABEL_71;
              }
            }
            else
            {
              uint64_t v58 = 0;
              uint64_t v59 = (char *)(8 * v54);
              *(void *)(8 * v54) = v50;
              uint64_t v60 = 8 * v54 + 8;
              int64_t v61 = v48 - v52;
              if (v48 == v52) {
                goto LABEL_71;
              }
            }
            unint64_t v62 = v61 - 8;
            if (v62 >= 0x168)
            {
              unint64_t v65 = (v48 - 8 - v52) & 0xFFFFFFFFFFFFFFF8;
              if (&v58[v53 - 8 - v65] > &v58[v53 - 8])
              {
                uint64_t v63 = v48;
              }
              else if (&v48[-v65 - 8] > v48 - 8)
              {
                uint64_t v63 = v48;
              }
              else if ((unint64_t)(v48 - v58 - v53) >= 0x20)
              {
                uint64_t v66 = (v62 >> 3) + 1;
                uint64_t v67 = 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
                uint64_t v63 = &v48[-v67];
                v59 -= v67;
                uint64_t v68 = &v58[8 * v54 - 16];
                __int16 v69 = v48 - 16;
                uint64_t v70 = v66 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v71 = *(_OWORD *)v69;
                  *(v68 - 1) = *((_OWORD *)v69 - 1);
                  *uint64_t v68 = v71;
                  v68 -= 2;
                  v69 -= 32;
                  v70 -= 4;
                }
                while (v70);
                if (v66 == (v66 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_71;
                }
              }
              else
              {
                uint64_t v63 = v48;
              }
            }
            else
            {
              uint64_t v63 = v48;
            }
            do
            {
              uint64_t v64 = *((void *)v63 - 1);
              v63 -= 8;
              *((void *)v59 - 1) = v64;
              v59 -= 8;
            }
            while (v63 != v52);
LABEL_71:
            *a4 = v59;
            a4[1] = (char *)v60;
            a4[2] = &v58[8 * v57];
            if (v52) {
              operator delete(v52);
            }
            unint64_t v49 = v73;
            a4[1] = (char *)v60;
            v47 += 8;
            int8x8_t v48 = (char *)v60;
            if (v47 == v73)
            {
LABEL_86:
              uint64_t v47 = (char *)v81;
              break;
            }
          }
        }
        *a3 = 1;
        if (v47 != v83) {
          free(v47);
        }
LABEL_91:

        goto LABEL_92;
      }
      *a3 = 0;
    }
    else
    {
      *a3 = 1;
    }
    a4[1] = 0;
    a4[2] = 0;
    *a4 = 0;
    goto LABEL_91;
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (v86)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v85;
    uint64_t v9 = &v85[8 * v86];
    while (1)
    {
      uint64_t v11 = *(void *)v8;
      unint64_t v12 = (unint64_t)a4[2];
      if ((unint64_t)v7 >= v12) {
        break;
      }
      *(void *)uint64_t v7 = v11;
      uint64_t v10 = (uint64_t)(v7 + 8);
LABEL_5:
      a4[1] = (char *)v10;
      v8 += 8;
      uint64_t v7 = (char *)v10;
      if (v8 == v9) {
        goto LABEL_33;
      }
    }
    unint64_t v13 = *a4;
    uint64_t v14 = v7 - *a4;
    uint64_t v15 = v14 >> 3;
    unint64_t v16 = (v14 >> 3) + 1;
    if (v16 >> 61) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v12 - (void)v13;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      id v19 = operator new(8 * v18);
      BOOL v20 = &v19[8 * v15];
      *(void *)BOOL v20 = v11;
      uint64_t v10 = (uint64_t)(v20 + 8);
      int64_t v21 = v7 - v13;
      if (v7 == v13) {
        goto LABEL_21;
      }
    }
    else
    {
      id v19 = 0;
      BOOL v20 = (char *)(8 * v15);
      *(void *)(8 * v15) = v11;
      uint64_t v10 = 8 * v15 + 8;
      int64_t v21 = v7 - v13;
      if (v7 == v13) {
        goto LABEL_21;
      }
    }
    unint64_t v22 = v21 - 8;
    if (v22 >= 0x168)
    {
      unint64_t v25 = (v7 - 8 - v13) & 0xFFFFFFFFFFFFFFF8;
      if (&v19[v14 - 8 - v25] > &v19[v14 - 8])
      {
        uint64_t v23 = v7;
      }
      else if (&v7[-v25 - 8] > v7 - 8)
      {
        uint64_t v23 = v7;
      }
      else if ((unint64_t)(v7 - v19 - v14) >= 0x20)
      {
        uint64_t v26 = (v22 >> 3) + 1;
        uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v23 = &v7[-v27];
        v20 -= v27;
        uint64_t v28 = &v19[8 * v15 - 16];
        id v29 = v7 - 16;
        uint64_t v30 = v26 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v31 = *(_OWORD *)v29;
          *(v28 - 1) = *((_OWORD *)v29 - 1);
          _OWORD *v28 = v31;
          v28 -= 2;
          v29 -= 32;
          v30 -= 4;
        }
        while (v30);
        if (v26 == (v26 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_21:
          *a4 = v20;
          a4[1] = (char *)v10;
          a4[2] = &v19[8 * v18];
          if (v13) {
            operator delete(v13);
          }
          goto LABEL_5;
        }
      }
      else
      {
        uint64_t v23 = v7;
      }
    }
    else
    {
      uint64_t v23 = v7;
    }
    do
    {
      uint64_t v24 = *((void *)v23 - 1);
      v23 -= 8;
      *((void *)v20 - 1) = v24;
      v20 -= 8;
    }
    while (v23 != v13);
    goto LABEL_21;
  }
LABEL_33:
  *a3 = 1;
LABEL_92:
  if (v85 != (char *)v87) {
    free(v85);
  }
}

void sub_180D06898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  if (a25 != a9) {
    free(a25);
  }

  uint64_t v27 = *(void **)(v25 - 160);
  if (v27 != a14)
  {
    free(v27);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void GPURegionRuntime::waitAndReadIntTensorData(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  char v61 = 0;
  GPURegionRuntime::readIntTensorData(a1, a3, &v61, (char **)__p);
  if (v61)
  {
    *(_OWORD *)a4 = *(_OWORD *)__p;
    *(void *)(a4 + 16) = v60;
    return;
  }
  if (!a2 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v64 = (uint64_t)a3;
  uint64_t v63 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v64) + 2);
  uint64_t v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 88), &v63);
  if (v8
    && (uint64_t v62 = v64,
        (uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, &v62)) != 0))
  {
    id v53 = (id)v9[3];
  }
  else
  {
    id v53 = 0;
  }
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(a1, (uint64_t)a3);
  unint64_t v51 = getMPSShapeFromMLIR(StaticType);
  unsigned int MPSDataType = getMPSDataType(StaticType);
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  id v11 = v51;
  uint64_t v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v55, v65, 16, v51);
  unint64_t v13 = (unsigned __int16)MPSDataType >> 3;
  unint64_t v52 = v13;
  if (v12)
  {
    uint64_t v14 = *(void *)v56;
    unint64_t v13 = (unsigned __int16)MPSDataType >> 3;
    do
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (*(void *)v56 != v14) {
          objc_enumerationMutation(v11);
        }
        id v16 = *(id *)(*((void *)&v55 + 1) + 8 * i);
        uint64_t v17 = [v16 unsignedLongValue];

        v13 *= v17;
      }
      uint64_t v12 = [v11 countByEnumeratingWithState:&v55 objects:v65 count:16];
    }
    while (v12);
  }

  int8x8_t v18 = *(int8x8_t *)(a1 + 392);
  if (!*(void *)&v18) {
    goto LABEL_35;
  }
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v20 = v13;
    if (v13 >= *(void *)&v18) {
      unint64_t v20 = v13 % *(void *)&v18;
    }
  }
  else
  {
    unint64_t v20 = (*(void *)&v18 - 1) & v13;
  }
  int64_t v21 = *(uint64_t ****)(*(void *)(a1 + 384) + 8 * v20);
  if (!v21 || (unint64_t v22 = *v21) == 0)
  {
LABEL_35:
    uint64_t v26 = [*(id *)(a1 + 48) metalDevice];
    uint64_t v27 = (uint64_t *)[v26 newBufferWithLength:v13 options:0];

    std::__hash_table<std::__hash_value_type<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong}>,std::__unordered_map_hasher<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto9MTLBuffer}* {__strong}>>::__emplace_unique_key_args<unsigned long,unsigned long &,objc_object  {objcproto9MTLBuffer}*&>((uint64_t *)(a1 + 384), v13, v13, v27);
    goto LABEL_36;
  }
  if (v19.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v18 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == (uint64_t *)v13)
      {
        if (v22[2] == (uint64_t *)v13) {
          goto LABEL_59;
        }
      }
      else if (((unint64_t)v25 & v23) != v20)
      {
        goto LABEL_35;
      }
      unint64_t v22 = (uint64_t **)*v22;
      if (!v22) {
        goto LABEL_35;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = (unint64_t)v22[1];
    if (v24 == v13) {
      break;
    }
    if (v24 >= *(void *)&v18) {
      v24 %= *(void *)&v18;
    }
    if (v24 != v20) {
      goto LABEL_35;
    }
LABEL_25:
    unint64_t v22 = (uint64_t **)*v22;
    if (!v22) {
      goto LABEL_35;
    }
  }
  if (v22[2] != (uint64_t *)v13) {
    goto LABEL_25;
  }
LABEL_59:
  uint64_t v27 = v22[3];
LABEL_36:
  uint64_t v28 = [MEMORY[0x1E4F35720] descriptorWithDataType:MPSDataType shape:v11];
  [v28 setPreferPackedRows:1];
  id v29 = *(void **)(a2 + 72);
  if (v29)
  {
    [v29 endEncoding];
    uint64_t v30 = *(void **)(a2 + 72);
    *(void *)(a2 + 72) = 0;
  }
  long long v31 = [v53 mpsndarray];
  [v31 exportDataWithCommandBuffer:*(void *)(a2 + 8) toBuffer:v27 destinationDataType:MPSDataType offset:0 rowStrides:0];

  uint64_t v32 = [*(id *)(a2 + 8) rootCommandBuffer];
  (**(void (***)(uint64_t))a2)(a2);
  [v32 waitUntilCompleted];
  uint64_t v33 = *(void *)(a1 + 424);
  if (v33) {
    ++*(void *)(v33 + 192);
  }
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (v13 >= v52) {
    std::vector<long long>::__append(a4, v13 / v52);
  }
  if ((MPSDataType & 0xDFFFFFFF) == 0x40)
  {
    memcpy(*(void **)a4, (const void *)[v27 contents], v13);
  }
  else
  {
    if ((MPSDataType & 0xDFFFFFFF) != 0x20) {
      __assert_rtn("waitAndReadIntTensorData", "MPSRuntime.mm", 1292, "0 && \"unsupported data type\"");
    }
    id v34 = (char *)malloc_type_malloc(v13, 0xCCA71743uLL);
    memcpy(v34, (const void *)[v27 contents], v13);
    id v35 = *(char **)a4;
    uint64_t v36 = *(void *)(a4 + 8) - *(void *)a4;
    if (v36)
    {
      unint64_t v37 = v36 >> 3;
      if (v37 <= 1) {
        unint64_t v37 = 1;
      }
      if (v37 < 8)
      {
        unint64_t v38 = 0;
        goto LABEL_53;
      }
      unint64_t v38 = v37 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v39 = v34 + 16;
      uint64_t v40 = v35 + 32;
      unint64_t v41 = v37 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        long long v42 = *((_OWORD *)v39 - 1);
        *(void *)&long long v43 = (int)v42;
        *((void *)&v43 + 1) = SDWORD1(v42);
        long long v44 = v43;
        *(void *)&long long v43 = SDWORD2(v42);
        *((void *)&v43 + 1) = SHIDWORD(v42);
        long long v45 = v43;
        *(void *)&long long v43 = (int)*(_OWORD *)v39;
        *((void *)&v43 + 1) = (int)HIDWORD(*(void *)v39);
        long long v46 = v43;
        *(void *)&long long v43 = (int)*((void *)v39 + 1);
        *((void *)&v43 + 1) = (int)HIDWORD(*(_OWORD *)v39);
        *(v40 - 2) = v44;
        *(v40 - 1) = v45;
        *uint64_t v40 = v46;
        v40[1] = v43;
        v40 += 4;
        v39 += 32;
        v41 -= 8;
      }
      while (v41);
      if (v37 != v38)
      {
LABEL_53:
        unint64_t v47 = v37 - v38;
        int8x8_t v48 = &v35[8 * v38];
        unint64_t v49 = &v34[4 * v38];
        do
        {
          uint64_t v50 = *(int *)v49;
          v49 += 4;
          *(void *)int8x8_t v48 = v50;
          v48 += 8;
          --v47;
        }
        while (v47);
      }
    }
    free(v34);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_180D06EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (__p)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void GPURegionRuntime::waitAndReadFPTensorData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int16x8_t **a4@<X8>)
{
  v329[5] = *MEMORY[0x1E4F143B8];
  v324 = v326;
  uint64_t v325 = 0x400000000;
  if (mlir::matchConstantWithFloatVector<float>(a3, (uint64_t)&v324))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    if (!v325) {
      goto LABEL_491;
    }
    uint64_t v7 = 0;
    uint64_t v8 = v324;
    uint64_t v9 = &v324[4 * v325];
    while (1)
    {
      __int32 v11 = *(_DWORD *)v8;
      unint64_t v12 = (unint64_t)a4[2];
      if ((unint64_t)v7 >= v12) {
        break;
      }
      *(_DWORD *)uint64_t v7 = v11;
      uint64_t v10 = (uint64_t)(v7 + 4);
LABEL_5:
      a4[1] = (int16x8_t *)v10;
      v8 += 4;
      uint64_t v7 = (char *)v10;
      if (v8 == v9) {
        goto LABEL_491;
      }
    }
    unint64_t v13 = *a4;
    uint64_t v14 = v7 - (char *)*a4;
    uint64_t v15 = v14 >> 2;
    unint64_t v16 = (v14 >> 2) + 1;
    if (v16 >> 62) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v12 - (void)v13;
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint8x8_t v19 = operator new(4 * v18);
      unint64_t v20 = (int16x8_t *)&v19[4 * v15];
      v20->i32[0] = v11;
      uint64_t v10 = (uint64_t)v20->i64 + 4;
      int64_t v21 = v7 - (char *)v13;
      if (v7 == (char *)v13) {
        goto LABEL_21;
      }
    }
    else
    {
      uint8x8_t v19 = 0;
      unint64_t v20 = (int16x8_t *)(4 * v15);
      *(_DWORD *)(4 * v15) = v11;
      uint64_t v10 = 4 * v15 + 4;
      int64_t v21 = v7 - (char *)v13;
      if (v7 == (char *)v13) {
        goto LABEL_21;
      }
    }
    unint64_t v22 = v21 - 4;
    if (v22 >= 0xBC)
    {
      unint64_t v25 = (v7 - 4 - (char *)v13) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v19[v14 - 4 - v25] > &v19[v14 - 4])
      {
        uint64_t v23 = (int16x8_t *)v7;
      }
      else if (&v7[-v25 - 4] > v7 - 4)
      {
        uint64_t v23 = (int16x8_t *)v7;
      }
      else if ((unint64_t)(v7 - v19 - v14) >= 0x20)
      {
        uint64_t v26 = (v22 >> 2) + 1;
        uint64_t v27 = 4 * (v26 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v23 = (int16x8_t *)&v7[-v27];
        unint64_t v20 = (int16x8_t *)((char *)v20 - v27);
        uint64_t v28 = &v19[4 * v15 - 16];
        id v29 = v7 - 16;
        uint64_t v30 = v26 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v31 = *(_OWORD *)v29;
          *(v28 - 1) = *((_OWORD *)v29 - 1);
          _OWORD *v28 = v31;
          v28 -= 2;
          v29 -= 32;
          v30 -= 8;
        }
        while (v30);
        if (v26 == (v26 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_21:
          *a4 = v20;
          a4[1] = (int16x8_t *)v10;
          a4[2] = (int16x8_t *)&v19[4 * v18];
          if (v13) {
            operator delete(v13);
          }
          goto LABEL_5;
        }
      }
      else
      {
        uint64_t v23 = (int16x8_t *)v7;
      }
    }
    else
    {
      uint64_t v23 = (int16x8_t *)v7;
    }
    do
    {
      __int32 v24 = v23[-1].i32[3];
      uint64_t v23 = (int16x8_t *)((char *)v23 - 4);
      v20[-1].i32[3] = v24;
      unint64_t v20 = (int16x8_t *)((char *)v20 - 4);
    }
    while (v23 != v13);
    goto LABEL_21;
  }
  v321 = v323;
  uint64_t v322 = 0x400000000;
  long long v313 = 0uLL;
  if (!a3) {
    goto LABEL_42;
  }
  *(void *)&long long v319 = &v313;
  ArgOperands = (unsigned char *)a3;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v319, DefiningOp)) {
    goto LABEL_42;
  }
  ArgOperands = (unsigned char *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v313);
  unint64_t v328 = v33;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  if (!OperandRange) {
    goto LABEL_298;
  }
  if (!*(void *)OperandRange) {
    goto LABEL_411;
  }
  id v35 = *(void **)(*(void *)OperandRange + 136);
  _ZF = v35 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id;
  if (v35 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    uint64_t v37 = OperandRange;
  }
  else {
    uint64_t v37 = 0;
  }
  uint64_t v312 = v37;
  if (!_ZF) {
    goto LABEL_42;
  }
  uint64_t v99 = *(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v312);
  if (!v99) {
    goto LABEL_411;
  }
  id v100 = *(void **)(v99 + 136);
  if (v100 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v100 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    long long v315 = v313;
    ArgOperands = (unsigned char *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v315);
    unint64_t v328 = v101;
    uint64_t v102 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
    if (v102)
    {
      if (!*(void *)v102) {
        goto LABEL_411;
      }
      uint64_t v103 = *(void **)(*(void *)v102 + 136);
      BOOL v104 = v103 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id;
      if (v103 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
        uint64_t v105 = v102;
      }
      else {
        uint64_t v105 = 0;
      }
      uint64_t v314 = v105;
      if (!v104) {
        goto LABEL_313;
      }
      uint64_t v106 = *(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v314);
      if (!v106) {
        goto LABEL_411;
      }
      uint64_t v107 = *(void **)(v106 + 136);
      if (v107 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
        && v107 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
      {
LABEL_313:
        uint64_t v114 = "complexTy && complexTy.getElementType().isa<FloatType>() && \"must be a complex float attr\"";
        int v115 = 294;
        BOOL v116 = "MPSRawAttributeUtils.h";
        int v117 = "getComplexFloatValues";
        goto LABEL_412;
      }
      mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v315);
      unint64_t NumElements = mlir::ElementsAttr::getNumElements(v315, *((uint64_t *)&v315 + 1));
      unint64_t v109 = NumElements;
      uint64_t v110 = v322;
      if (NumElements == v322) {
        goto LABEL_148;
      }
      if (NumElements >= v322)
      {
        if (NumElements > HIDWORD(v322))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v321, v323, NumElements, 8);
          uint64_t v110 = v322;
        }
        if (v109 != v110) {
          bzero(&v321[8 * v110], 8 * (v109 - v110));
        }
        if (v109 <= HIDWORD(v322)) {
          goto LABEL_147;
        }
      }
      else if (NumElements <= HIDWORD(v322))
      {
LABEL_147:
        LODWORD(v322) = v109;
        unint64_t v109 = v109;
LABEL_148:
        char v111 = v321;
        long long v319 = v315;
        Type = (uint64_t **)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v319);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(Type))
        {
          uint64_t v114 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v115 = 566;
          BOOL v116 = "Casting.h";
          int v117 = "cast";
          goto LABEL_412;
        }
        if (Type)
        {
          uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(Type);
          if (!InterfaceFor)
          {
            uint64_t v114 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v115 = 98;
            BOOL v116 = "InterfaceSupport.h";
            int v117 = "Interface";
            goto LABEL_412;
          }
        }
        else
        {
          uint64_t InterfaceFor = 0;
        }
        v318[0] = (uint64_t)Type;
        v318[1] = InterfaceFor;
        uint64_t v317 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v318);
        int v124 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v319);
        ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v319);
        uint64_t v127 = v126;
        int64_t v128 = mlir::ElementsAttr::getNumElements(v319, *((uint64_t *)&v319 + 1));
        if ((v128 & 0x1FFFFFFFFFFFFFFFLL) != v109)
        {
          uint64_t v114 = "numElements * sizeof(DstT) == outBuffSize && \"invalid output buffer size\"";
          int v115 = 199;
          BOOL v116 = "MPSRawAttributeUtils.h";
          int v117 = "copyElementsAttrData";
          goto LABEL_412;
        }
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&v317, 8))
        {
          if (v128 >= 1)
          {
            uint64_t v130 = 0;
            id v131 = (float *)(v111 + 4);
            do
            {
              if (v124) {
                uint64_t v132 = 0;
              }
              else {
                uint64_t v132 = v130;
              }
              LOBYTE(v129) = ElementsAttrRawData[v132];
              float v129 = (float)LODWORD(v129);
              *(v131 - 1) = v129;
              *id v131 = 0.0;
              v131 += 2;
              ++v130;
            }
            while (v128 != v130);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v317, 8))
        {
          if (v128 >= 1)
          {
            uint64_t v134 = 0;
            uint64_t v135 = v111 + 4;
            do
            {
              if (v124) {
                uint64_t v136 = 0;
              }
              else {
                uint64_t v136 = v134;
              }
              v133.i8[0] = ElementsAttrRawData[v136];
              int8x8_t v133 = (int8x8_t)vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(v133)).u64[0];
              *(float *)v133.i32 = (float)v133.i32[0];
              *(v135 - 1) = v133.i32[0];
              *uint64_t v135 = 0;
              v135 += 2;
              ++v134;
            }
            while (v128 != v134);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&v317, 16))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v142 = 0;
            }
            else
            {
              uint64_t v141 = 0;
              unint64_t v142 = v128 & 0xFFFFFFFFFFFFFFFELL;
              unint64_t v143 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v144 = 0;
                }
                else {
                  uint64_t v144 = v141;
                }
                LOWORD(v137) = *(_WORD *)&ElementsAttrRawData[2 * v144];
                if (v124) {
                  uint64_t v145 = 0;
                }
                else {
                  uint64_t v145 = v141 + 1;
                }
                float v137 = (float)LODWORD(v137);
                LOWORD(v138) = *(_WORD *)&ElementsAttrRawData[2 * v145];
                float v138 = (float)LODWORD(v138);
                *(v143 - 2) = v137;
                *unint64_t v143 = v138;
                *(v143 - 1) = 0.0;
                v143[1] = 0.0;
                v143 += 4;
                v141 += 2;
              }
              while (v141 != v142);
              if (v128 == v142) {
                goto LABEL_420;
              }
            }
            uint64_t v146 = (float *)&v111[8 * v142 + 4];
            do
            {
              if (v124) {
                unint64_t v147 = 0;
              }
              else {
                unint64_t v147 = v142;
              }
              LOWORD(v137) = *(_WORD *)&ElementsAttrRawData[2 * v147];
              float v137 = (float)LODWORD(v137);
              *(v146 - 1) = v137;
              *uint64_t v146 = 0.0;
              v146 += 2;
              ++v142;
            }
            while (v128 != v142);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v317, 16))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v149 = 0;
            }
            else
            {
              uint64_t v148 = 0;
              unint64_t v149 = v128 & 0xFFFFFFFFFFFFFFFELL;
              size_t v150 = v111 + 8;
              do
              {
                if (v124) {
                  uint64_t v151 = 0;
                }
                else {
                  uint64_t v151 = v148;
                }
                if (v124) {
                  uint64_t v152 = 0;
                }
                else {
                  uint64_t v152 = v148 + 1;
                }
                v139.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v151];
                int16x4_t v139 = (int16x4_t)vmovl_s16(v139).u64[0];
                *(float *)v139.i32 = (float)v139.i32[0];
                v140.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v152];
                int16x4_t v140 = (int16x4_t)vmovl_s16(v140).u64[0];
                *(float *)v140.i32 = (float)v140.i32[0];
                *(v150 - 2) = v139.i32[0];
                *size_t v150 = v140.i32[0];
                *(v150 - 1) = 0;
                v150[1] = 0;
                v150 += 4;
                v148 += 2;
              }
              while (v148 != v149);
              if (v128 == v149) {
                goto LABEL_420;
              }
            }
            unint64_t v153 = &v111[8 * v149 + 4];
            do
            {
              if (v124) {
                unint64_t v154 = 0;
              }
              else {
                unint64_t v154 = v149;
              }
              v139.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v154];
              int16x4_t v139 = (int16x4_t)vmovl_s16(v139).u64[0];
              *(float *)v139.i32 = (float)v139.i32[0];
              *((_DWORD *)v153 - 1) = v139.i32[0];
              *(_DWORD *)unint64_t v153 = 0;
              v153 += 8;
              ++v149;
            }
            while (v128 != v149);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&v317, 32))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v156 = 0;
            }
            else
            {
              uint64_t v155 = 0;
              unint64_t v156 = v128 & 0xFFFFFFFFFFFFFFFELL;
              uint64_t v157 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v158 = 0;
                }
                else {
                  uint64_t v158 = v155;
                }
                unsigned int v159 = *(_DWORD *)&ElementsAttrRawData[4 * v158];
                if (v124) {
                  uint64_t v160 = 0;
                }
                else {
                  uint64_t v160 = v155 + 1;
                }
                float v161 = (float)*(unsigned int *)&ElementsAttrRawData[4 * v160];
                *(v157 - 2) = (float)v159;
                *uint64_t v157 = v161;
                *(v157 - 1) = 0.0;
                v157[1] = 0.0;
                v157 += 4;
                v155 += 2;
              }
              while (v155 != v156);
              if (v128 == v156) {
                goto LABEL_420;
              }
            }
            __n128 v162 = (float *)&v111[8 * v156 + 4];
            do
            {
              if (v124) {
                unint64_t v163 = 0;
              }
              else {
                unint64_t v163 = v156;
              }
              *(v162 - 1) = (float)*(unsigned int *)&ElementsAttrRawData[4 * v163];
              *__n128 v162 = 0.0;
              v162 += 2;
              ++v156;
            }
            while (v128 != v156);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v317, 32))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v165 = 0;
            }
            else
            {
              uint64_t v164 = 0;
              unint64_t v165 = v128 & 0xFFFFFFFFFFFFFFFELL;
              uint64_t v166 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v167 = 0;
                }
                else {
                  uint64_t v167 = v164;
                }
                int v168 = *(_DWORD *)&ElementsAttrRawData[4 * v167];
                if (v124) {
                  uint64_t v169 = 0;
                }
                else {
                  uint64_t v169 = v164 + 1;
                }
                float v170 = (float)*(int *)&ElementsAttrRawData[4 * v169];
                *(v166 - 2) = (float)v168;
                *uint64_t v166 = v170;
                *(v166 - 1) = 0.0;
                v166[1] = 0.0;
                v166 += 4;
                v164 += 2;
              }
              while (v164 != v165);
              if (v128 == v165) {
                goto LABEL_420;
              }
            }
            v171 = (float *)&v111[8 * v165 + 4];
            do
            {
              if (v124) {
                unint64_t v172 = 0;
              }
              else {
                unint64_t v172 = v165;
              }
              *(v171 - 1) = (float)*(int *)&ElementsAttrRawData[4 * v172];
              float *v171 = 0.0;
              v171 += 2;
              ++v165;
            }
            while (v128 != v165);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&v317, 64))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v174 = 0;
            }
            else
            {
              uint64_t v173 = 0;
              unint64_t v174 = v128 & 0xFFFFFFFFFFFFFFFELL;
              uint64_t v175 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v176 = 0;
                }
                else {
                  uint64_t v176 = v173;
                }
                if (v124) {
                  uint64_t v177 = 0;
                }
                else {
                  uint64_t v177 = v173 + 1;
                }
                float v178 = (float)*(unint64_t *)&ElementsAttrRawData[8 * v177];
                *(v175 - 2) = (float)*(unint64_t *)&ElementsAttrRawData[8 * v176];
                *uint64_t v175 = v178;
                *(v175 - 1) = 0.0;
                v175[1] = 0.0;
                v175 += 4;
                v173 += 2;
              }
              while (v173 != v174);
              if (v128 == v174) {
                goto LABEL_420;
              }
            }
            v179 = (float *)&v111[8 * v174 + 4];
            do
            {
              if (v124) {
                unint64_t v180 = 0;
              }
              else {
                unint64_t v180 = v174;
              }
              *(v179 - 1) = (float)*(unint64_t *)&ElementsAttrRawData[8 * v180];
              float *v179 = 0.0;
              v179 += 2;
              ++v174;
            }
            while (v128 != v174);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v317, 64))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v185 = 0;
            }
            else
            {
              uint64_t v184 = 0;
              unint64_t v185 = v128 & 0xFFFFFFFFFFFFFFFELL;
              v186 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v187 = 0;
                }
                else {
                  uint64_t v187 = v184;
                }
                if (v124) {
                  uint64_t v188 = 0;
                }
                else {
                  uint64_t v188 = v184 + 1;
                }
                float v189 = (float)*(uint64_t *)&ElementsAttrRawData[8 * v188];
                *(v186 - 2) = (float)*(uint64_t *)&ElementsAttrRawData[8 * v187];
                float *v186 = v189;
                *(v186 - 1) = 0.0;
                v186[1] = 0.0;
                v186 += 4;
                v184 += 2;
              }
              while (v184 != v185);
              if (v128 == v185) {
                goto LABEL_420;
              }
            }
            v190 = (float *)&v111[8 * v185 + 4];
            do
            {
              if (v124) {
                unint64_t v191 = 0;
              }
              else {
                unint64_t v191 = v185;
              }
              *(v190 - 1) = (float)*(uint64_t *)&ElementsAttrRawData[8 * v191];
              float *v190 = 0.0;
              v190 += 2;
              ++v185;
            }
            while (v128 != v185);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isF16((mlir::Type *)&v317))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v193 = 0;
            }
            else
            {
              uint64_t v192 = 0;
              unint64_t v193 = v128 & 0xFFFFFFFFFFFFFFFELL;
              v194 = v111 + 8;
              do
              {
                if (v124) {
                  uint64_t v195 = 0;
                }
                else {
                  uint64_t v195 = v192;
                }
                _H0 = *(_WORD *)&ElementsAttrRawData[2 * v195];
                if (v124) {
                  uint64_t v197 = 0;
                }
                else {
                  uint64_t v197 = v192 + 1;
                }
                _H1 = *(_WORD *)&ElementsAttrRawData[2 * v197];
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                *(v194 - 2) = _S0;
                _DWORD *v194 = _S1;
                *(v194 - 1) = 0;
                v194[1] = 0;
                v194 += 4;
                v192 += 2;
              }
              while (v192 != v193);
              if (v128 == v193) {
                goto LABEL_420;
              }
            }
            v204 = &v111[8 * v193 + 4];
            do
            {
              if (v124) {
                unint64_t v205 = 0;
              }
              else {
                unint64_t v205 = v193;
              }
              _H0 = *(_WORD *)&ElementsAttrRawData[2 * v205];
              __asm { FCVT            S0, H0 }
              *((_DWORD *)v204 - 1) = _S0;
              *(_DWORD *)v204 = 0;
              v204 += 8;
              ++v193;
            }
            while (v128 != v193);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isF32((mlir::Type *)&v317))
        {
          if (v128 >= 1)
          {
            if (v124)
            {
              if ((unint64_t)v128 >= 8
                && (v111 >= ElementsAttrRawData + 4 || &v111[8 * v128] <= ElementsAttrRawData))
              {
                uint64_t v181 = v128 & 0x7FFFFFFFFFFFFFF8;
                long long v233 = v111 + 32;
                unint64_t v234 = v128 & 0xFFFFFFFFFFFFFFF8;
                do
                {
                  *(void *)&long long v235 = *(unsigned int *)ElementsAttrRawData;
                  *((void *)&v235 + 1) = v235;
                  *(v233 - 2) = v235;
                  *(v233 - 1) = v235;
                  *long long v233 = v235;
                  v233[1] = v235;
                  v233 += 4;
                  v234 -= 8;
                }
                while (v234);
                if (v128 == v181) {
                  goto LABEL_420;
                }
              }
              else
              {
                uint64_t v181 = 0;
              }
              int64_t v182 = v128 - v181;
              uint64_t v183 = (uint64_t)&v111[8 * v181 + 4];
              do
              {
                *(void *)(v183 - 4) = *(unsigned int *)ElementsAttrRawData;
                v183 += 8;
                --v182;
              }
              while (v182);
            }
            else
            {
              if ((unint64_t)v128 >= 8
                && (v111 >= &ElementsAttrRawData[4 * v128] || &v111[8 * v128] <= ElementsAttrRawData))
              {
                uint64_t v208 = v128 & 0x7FFFFFFFFFFFFFF8;
                unint64_t v236 = (float *)(v111 + 32);
                unint64_t v237 = (float32x4_t *)(ElementsAttrRawData + 16);
                long long v238 = 0uLL;
                unint64_t v239 = v128 & 0xFFFFFFFFFFFFFFF8;
                do
                {
                  float32x4_t v240 = v237[-1];
                  v330.val[0] = *v237;
                  long long v241 = v236 - 8;
                  vst2q_f32(v241, *(float32x4x2_t *)(&v238 - 1));
                  v330.val[1] = 0uLL;
                  vst2q_f32(v236, v330);
                  v236 += 16;
                  v237 += 2;
                  v239 -= 8;
                }
                while (v239);
                if (v128 == v208) {
                  goto LABEL_420;
                }
              }
              else
              {
                uint64_t v208 = 0;
              }
              int64_t v209 = v128 - v208;
              uint64_t v210 = (uint64_t)&v111[8 * v208 + 4];
              int v211 = &ElementsAttrRawData[4 * v208];
              do
              {
                unsigned int v212 = *(_DWORD *)v211;
                v211 += 4;
                *(void *)(v210 - 4) = v212;
                v210 += 8;
                --v209;
              }
              while (v209);
            }
          }
LABEL_420:
          *a4 = 0;
          a4[1] = 0;
          a4[2] = 0;
          if (!v322) {
            goto LABEL_494;
          }
          v255 = 0;
          v256 = (char *)v321;
          uint64_t v257 = (char *)&v321[8 * v322];
          while (1)
          {
            __int32 v259 = *(_DWORD *)v256;
            __int32 v258 = *((_DWORD *)v256 + 1);
            v260 = a4[2];
            if (v255 < v260)
            {
              v255->i32[0] = v259;
              v261 = (int16x8_t *)((char *)v255->i64 + 4);
              goto LABEL_442;
            }
            v262 = *a4;
            uint64_t v263 = (char *)v255 - (char *)*a4;
            uint64_t v264 = v263 >> 2;
            unint64_t v265 = (v263 >> 2) + 1;
            if (v265 >> 62) {
              std::vector<long>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v266 = (char *)v260 - (char *)v262;
            if (v266 >> 1 > v265) {
              unint64_t v265 = v266 >> 1;
            }
            if ((unint64_t)v266 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v267 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v267 = v265;
            }
            if (v267)
            {
              if (v267 >> 62) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              v268 = operator new(4 * v267);
              v269 = (int16x8_t *)&v268[4 * v264];
              v269->i32[0] = v259;
              v261 = (int16x8_t *)((char *)v269->i64 + 4);
              int64_t v270 = (char *)v255 - (char *)v262;
              if (v255 == v262) {
                goto LABEL_440;
              }
            }
            else
            {
              v268 = 0;
              v269 = (int16x8_t *)(4 * v264);
              *(_DWORD *)(4 * v264) = v259;
              v261 = (int16x8_t *)(4 * v264 + 4);
              int64_t v270 = (char *)v255 - (char *)v262;
              if (v255 == v262) {
                goto LABEL_440;
              }
            }
            unint64_t v271 = v270 - 4;
            if (v271 < 0xBC)
            {
              v272 = v255;
              goto LABEL_439;
            }
            unint64_t v286 = ((char *)&v255[-1].u64[1] + 4 - (char *)v262) & 0xFFFFFFFFFFFFFFFCLL;
            if (&v268[v263 - 4 - v286] > &v268[v263 - 4]) {
              break;
            }
            if ((char *)&v255[-1].u64[1] - v286 + 4 > (char *)&v255[-1].u64[1] + 4)
            {
              v272 = v255;
              goto LABEL_439;
            }
            if ((unint64_t)((char *)v255 - v268 - v263) < 0x20)
            {
              v272 = v255;
              goto LABEL_439;
            }
            uint64_t v288 = (v271 >> 2) + 1;
            uint64_t v289 = 4 * (v288 & 0x7FFFFFFFFFFFFFF8);
            v272 = (int16x8_t *)((char *)v255 - v289);
            v269 = (int16x8_t *)((char *)v269 - v289);
            v290 = (int16x8_t *)&v268[4 * v264 - 16];
            v291 = v255 - 1;
            uint64_t v292 = v288 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              int16x8_t v293 = *v291;
              v290[-1] = v291[-1];
              int16x8_t *v290 = v293;
              v290 -= 2;
              v291 -= 2;
              v292 -= 8;
            }
            while (v292);
            if (v288 != (v288 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_439;
            }
LABEL_440:
            v260 = (int16x8_t *)&v268[4 * v267];
            *a4 = v269;
            a4[1] = v261;
            a4[2] = v260;
            if (v262)
            {
              operator delete(v262);
              v260 = a4[2];
            }
LABEL_442:
            a4[1] = v261;
            if (v261 >= v260)
            {
              v274 = *a4;
              uint64_t v275 = (char *)v261 - (char *)*a4;
              uint64_t v276 = v275 >> 2;
              unint64_t v277 = (v275 >> 2) + 1;
              if (v277 >> 62) {
                std::vector<long>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v278 = (char *)v260 - (char *)v274;
              if (v278 >> 1 > v277) {
                unint64_t v277 = v278 >> 1;
              }
              if ((unint64_t)v278 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v279 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v279 = v277;
              }
              if (v279)
              {
                if (v279 >> 62) {
                  std::__throw_bad_array_new_length[abi:ne180100]();
                }
                v280 = operator new(4 * v279);
                v281 = (int16x8_t *)&v280[4 * v276];
                v281->i32[0] = v258;
                v255 = (int16x8_t *)((char *)v281->i64 + 4);
                int64_t v282 = (char *)v261 - (char *)v274;
                if (v261 == v274) {
                  goto LABEL_457;
                }
LABEL_454:
                unint64_t v283 = v282 - 4;
                if (v283 < 0xBC)
                {
                  v284 = v261;
                  goto LABEL_456;
                }
                unint64_t v287 = ((char *)&v261[-1].u64[1] + 4 - (char *)v274) & 0xFFFFFFFFFFFFFFFCLL;
                if (&v280[v275 - 4 - v287] > &v280[v275 - 4])
                {
                  v284 = v261;
                  goto LABEL_456;
                }
                if ((char *)&v261[-1].u64[1] - v287 + 4 > (char *)&v261[-1].u64[1] + 4)
                {
                  v284 = v261;
                  goto LABEL_456;
                }
                if ((unint64_t)((char *)v261 - v280 - v275) < 0x20)
                {
                  v284 = v261;
                  goto LABEL_456;
                }
                uint64_t v294 = (v283 >> 2) + 1;
                uint64_t v295 = 4 * (v294 & 0x7FFFFFFFFFFFFFF8);
                v284 = (int16x8_t *)((char *)v261 - v295);
                v281 = (int16x8_t *)((char *)v281 - v295);
                v296 = (int16x8_t *)&v280[4 * v276 - 16];
                v297 = v261 - 1;
                uint64_t v298 = v294 & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  int16x8_t v299 = *v297;
                  v296[-1] = v297[-1];
                  int16x8_t *v296 = v299;
                  v296 -= 2;
                  v297 -= 2;
                  v298 -= 8;
                }
                while (v298);
                if (v294 != (v294 & 0x7FFFFFFFFFFFFFF8))
                {
                  do
                  {
LABEL_456:
                    __int32 v285 = v284[-1].i32[3];
                    v284 = (int16x8_t *)((char *)v284 - 4);
                    v281[-1].i32[3] = v285;
                    v281 = (int16x8_t *)((char *)v281 - 4);
                  }
                  while (v284 != v274);
                }
              }
              else
              {
                v280 = 0;
                v281 = (int16x8_t *)(4 * v276);
                *(_DWORD *)(4 * v276) = v258;
                v255 = (int16x8_t *)(4 * v276 + 4);
                int64_t v282 = (char *)v261 - (char *)v274;
                if (v261 != v274) {
                  goto LABEL_454;
                }
              }
LABEL_457:
              *a4 = v281;
              a4[1] = v255;
              a4[2] = (int16x8_t *)&v280[4 * v279];
              if (v274) {
                operator delete(v274);
              }
              goto LABEL_423;
            }
            v261->i32[0] = v258;
            v255 = (int16x8_t *)((char *)v261->i64 + 4);
LABEL_423:
            a4[1] = v255;
            v256 += 8;
            if (v256 == v257) {
              goto LABEL_494;
            }
          }
          v272 = v255;
          do
          {
LABEL_439:
            __int32 v273 = v272[-1].i32[3];
            v272 = (int16x8_t *)((char *)v272 - 4);
            v269[-1].i32[3] = v273;
            v269 = (int16x8_t *)((char *)v269 - 4);
          }
          while (v272 != v262);
          goto LABEL_440;
        }
        if (mlir::Type::isF64((mlir::Type *)&v317))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v221 = 0;
            }
            else
            {
              uint64_t v220 = 0;
              unint64_t v221 = v128 & 0xFFFFFFFFFFFFFFFELL;
              id v222 = (float *)(v111 + 8);
              do
              {
                if (v124) {
                  uint64_t v223 = 0;
                }
                else {
                  uint64_t v223 = v220;
                }
                double v224 = *(double *)&ElementsAttrRawData[8 * v223];
                if (v124) {
                  uint64_t v225 = 0;
                }
                else {
                  uint64_t v225 = v220 + 1;
                }
                float v226 = v224;
                float v227 = *(double *)&ElementsAttrRawData[8 * v225];
                *(v222 - 2) = v226;
                *id v222 = v227;
                *(v222 - 1) = 0.0;
                v222[1] = 0.0;
                v222 += 4;
                v220 += 2;
              }
              while (v220 != v221);
              if (v128 == v221) {
                goto LABEL_420;
              }
            }
            uint64_t v228 = (float *)&v111[8 * v221 + 4];
            do
            {
              if (v124) {
                unint64_t v229 = 0;
              }
              else {
                unint64_t v229 = v221;
              }
              float v230 = *(double *)&ElementsAttrRawData[8 * v229];
              *(v228 - 1) = v230;
              *uint64_t v228 = 0.0;
              v228 += 2;
              ++v221;
            }
            while (v128 != v221);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isBF16((mlir::Type *)&v317))
        {
          if (v128 >= 1)
          {
            if (v128 == 1)
            {
              unint64_t v243 = 0;
            }
            else
            {
              uint64_t v242 = 0;
              unint64_t v243 = v128 & 0xFFFFFFFFFFFFFFFELL;
              v244 = v111 + 8;
              do
              {
                if (v124) {
                  uint64_t v245 = 0;
                }
                else {
                  uint64_t v245 = v242;
                }
                int v246 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v245];
                if (v124) {
                  uint64_t v247 = 0;
                }
                else {
                  uint64_t v247 = v242 + 1;
                }
                unsigned int v248 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v247] << 16;
                *(v244 - 1) = (v246 << 16);
                void *v244 = v248;
                v244 += 2;
                v242 += 2;
              }
              while (v242 != v243);
              if (v128 == v243) {
                goto LABEL_420;
              }
            }
            uint64_t v249 = (uint64_t)&v111[8 * v243 + 4];
            do
            {
              if (v124) {
                unint64_t v250 = 0;
              }
              else {
                unint64_t v250 = v243;
              }
              *(void *)(v249 - 4) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v250] << 16;
              ++v243;
              v249 += 8;
            }
            while (v128 != v243);
          }
          goto LABEL_420;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v317, 1))
        {
          if (v124) {
            unint64_t v213 = 1;
          }
          else {
            unint64_t v213 = v128;
          }
          llvm::SmallVector<char,40u>::SmallVector((uint64_t)&ArgOperands, v213);
          mlir::detail::unpackBooleanData(ElementsAttrRawData, v127, (uint64_t)ArgOperands, v328);
          v215 = ArgOperands;
          if (v128 >= 1)
          {
            unint64_t v216 = 0;
            unint64_t v217 = v328;
            id v218 = v111 + 4;
            do
            {
              if (v124) {
                unint64_t v219 = 0;
              }
              else {
                unint64_t v219 = v216;
              }
              if (v217 <= v219) {
                __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
              }
              v214.i8[0] = v215[v219];
              int8x8_t v214 = (int8x8_t)vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(v214)).u64[0];
              *(float *)v214.i32 = (float)v214.i32[0];
              *(v218 - 1) = v214.i32[0];
              *id v218 = 0;
              v218 += 2;
              ++v216;
            }
            while (v128 != v216);
          }
          if (v215 != (unsigned char *)v329) {
            free(v215);
          }
          goto LABEL_420;
        }
        ArgOperands = (unsigned char *)mlir::Type::dyn_cast<mlir::ComplexType>(&v317);
        if (ArgOperands)
        {
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&ArgOperands);
          if (mlir::Type::isF32((mlir::Type *)&Value))
          {
            if (v128 >= 1)
            {
              for (uint64_t i = 0; i != v128; ++i)
              {
                if (v124) {
                  uint64_t v232 = 0;
                }
                else {
                  uint64_t v232 = i;
                }
                *(void *)&v111[8 * i] = *(void *)&ElementsAttrRawData[8 * v232];
              }
            }
            goto LABEL_420;
          }
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&ArgOperands);
          if (mlir::Type::isF16((mlir::Type *)&Value))
          {
            if (v128 >= 1)
            {
              for (uint64_t j = 0; j != v128; ++j)
              {
                if (v124) {
                  uint64_t v254 = 0;
                }
                else {
                  uint64_t v254 = j;
                }
                v252.i32[0] = *(_DWORD *)&ElementsAttrRawData[4 * v254];
                float16x4_t v252 = (float16x4_t)vcvtq_f32_f16(v252).u64[0];
                *(float16x4_t *)&v111[8 * j] = v252;
              }
            }
            goto LABEL_420;
          }
          uint64_t v300 = 248;
          v301 = "unsupported complex type";
          goto LABEL_488;
        }
        if (*(void *)v317)
        {
          if (*(_UNKNOWN **)(*(void *)v317 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
            && mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v317) <= 7)
          {
            unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v317);
            mlir::detail::unpackQuantizedData<std::complex<float>>(ElementsAttrRawData, v127, (uint64_t)v111, v128, IntOrFloatBitWidth);
            goto LABEL_420;
          }
          uint64_t v300 = 260;
          v301 = "unsupported type";
LABEL_488:
          llvm::llvm_unreachable_internal((llvm *)v301, "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/Utils/MPSRawAttributeUtils.h", (const char *)v300);
        }
LABEL_411:
        uint64_t v114 = "abstractType && \"Malformed type storage object.\"";
        int v115 = 160;
        BOOL v116 = "TypeSupport.h";
        int v117 = "getAbstractType";
LABEL_412:
        __assert_rtn(v117, v116, v115, v114);
      }
      uint64_t v114 = "N <= capacity()";
      int v115 = 102;
      BOOL v116 = "SmallVector.h";
      int v117 = "set_size";
      goto LABEL_412;
    }
LABEL_298:
    uint64_t v114 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v115 = 650;
    BOOL v116 = "Casting.h";
    int v117 = "dyn_cast";
    goto LABEL_412;
  }
LABEL_42:
  if (!a2 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  ArgOperands = (unsigned char *)a3;
  *(void *)&long long v319 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&ArgOperands) + 2);
  unint64_t v38 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 88), (uint64_t *)&v319);
  if (v38
    && (v318[0] = (uint64_t)ArgOperands,
        (uint64_t v39 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v38 + 3, v318)) != 0))
  {
    id v306 = (id)v39[3];
  }
  else
  {
    id v306 = 0;
  }
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(a1, a3);
  unint64_t v41 = getMPSShapeFromMLIR(StaticType);
  uint64_t MPSDataType = getMPSDataType(StaticType);
  if ((MPSDataType & 0x10000000) == 0) {
    __assert_rtn("waitAndReadFPTensorData", "MPSRuntime.mm", 1325, "dataType & MPSDataTypeFloatBit");
  }
  long long v310 = 0u;
  long long v311 = 0u;
  long long v308 = 0u;
  long long v309 = 0u;
  v304 = v41;
  id v43 = v41;
  uint64_t v44 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v308, v320, 16, v304);
  unint64_t v45 = (unsigned __int16)MPSDataType >> 3;
  unint64_t v305 = v45;
  if (v44)
  {
    uint64_t v46 = *(void *)v309;
    unint64_t v45 = (unsigned __int16)MPSDataType >> 3;
    do
    {
      for (uint64_t k = 0; k != v44; ++k)
      {
        if (*(void *)v309 != v46) {
          objc_enumerationMutation(v43);
        }
        id v48 = *(id *)(*((void *)&v308 + 1) + 8 * k);
        uint64_t v49 = [v48 unsignedLongValue];

        v45 *= v49;
      }
      uint64_t v44 = [v43 countByEnumeratingWithState:&v308 objects:v320 count:16];
    }
    while (v44);
  }

  if (!v45)
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    goto LABEL_496;
  }
  uint64_t v50 = (uint64_t *)(a1 + 384);
  int8x8_t v51 = *(int8x8_t *)(a1 + 392);
  if (!*(void *)&v51) {
    goto LABEL_77;
  }
  uint8x8_t v52 = (uint8x8_t)vcnt_s8(v51);
  v52.i16[0] = vaddlv_u8(v52);
  if (v52.u32[0] > 1uLL)
  {
    unint64_t v53 = v45;
    if (v45 >= *(void *)&v51) {
      unint64_t v53 = v45 % *(void *)&v51;
    }
  }
  else
  {
    unint64_t v53 = (*(void *)&v51 - 1) & v45;
  }
  uint64_t v54 = *(uint64_t ****)(*v50 + 8 * v53);
  if (!v54 || (long long v55 = *v54) == 0)
  {
LABEL_77:
    uint64_t v59 = [*(id *)(a1 + 48) metalDevice];
    uint64_t v60 = (uint64_t *)[v59 newBufferWithLength:v45 options:0];

    std::__hash_table<std::__hash_value_type<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong}>,std::__unordered_map_hasher<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto9MTLBuffer}* {__strong}>>::__emplace_unique_key_args<unsigned long,unsigned long &,objc_object  {objcproto9MTLBuffer}*&>(v50, v45, v45, v60);
    goto LABEL_78;
  }
  if (v52.u32[0] < 2uLL)
  {
    uint64_t v56 = *(void *)&v51 - 1;
    while (1)
    {
      long long v58 = v55[1];
      if (v58 == (uint64_t *)v45)
      {
        if (v55[2] == (uint64_t *)v45) {
          goto LABEL_155;
        }
      }
      else if (((unint64_t)v58 & v56) != v53)
      {
        goto LABEL_77;
      }
      long long v55 = (uint64_t **)*v55;
      if (!v55) {
        goto LABEL_77;
      }
    }
  }
  while (1)
  {
    unint64_t v57 = (unint64_t)v55[1];
    if (v57 == v45) {
      break;
    }
    if (v57 >= *(void *)&v51) {
      v57 %= *(void *)&v51;
    }
    if (v57 != v53) {
      goto LABEL_77;
    }
LABEL_67:
    long long v55 = (uint64_t **)*v55;
    if (!v55) {
      goto LABEL_77;
    }
  }
  if (v55[2] != (uint64_t *)v45) {
    goto LABEL_67;
  }
LABEL_155:
  uint64_t v60 = v55[3];
LABEL_78:
  char v61 = [MEMORY[0x1E4F35720] descriptorWithDataType:MPSDataType shape:v43];
  [v61 setPreferPackedRows:1];
  uint64_t v62 = *(void **)(a2 + 72);
  if (v62)
  {
    [v62 endEncoding];
    uint64_t v63 = *(void **)(a2 + 72);
    *(void *)(a2 + 72) = 0;
  }
  uint64_t v64 = [v306 mpsndarray];
  [v64 exportDataWithCommandBuffer:*(void *)(a2 + 8) toBuffer:v60 destinationDataType:MPSDataType offset:0 rowStrides:0];

  unint64_t v65 = [*(id *)(a2 + 8) rootCommandBuffer];
  (**(void (***)(uint64_t))a2)(a2);
  [v65 waitUntilCompleted];
  uint64_t v66 = *(void *)(a1 + 424);
  if (v66) {
    ++*(void *)(v66 + 192);
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (v45 >= v305)
  {
    unint64_t v67 = v45 / v305;
    if ((v45 / v305) >> 62) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v68 = (int16x8_t *)operator new(4 * v67);
    bzero(v68, 4 * v67);
    *a4 = v68;
    a4[1] = (int16x8_t *)((char *)v68 + 4 * v67);
    a4[2] = (int16x8_t *)((char *)v68 + 4 * v67);
  }
  if (MPSDataType == -1879048176)
  {
    uint64_t v83 = v60;
    int v84 = (uint64_t *)[v83 contents];
    uint64_t v85 = [v83 contents];
    uint64_t v87 = *a4;
    unint64_t v88 = (char *)a4[1] - (char *)*a4;
    if (v88 < 0xD)
    {
      unint64_t v89 = 0;
      unint64_t v93 = v88 >> 2;
    }
    else
    {
      unint64_t v89 = 0;
      int16x8_t v90 = (int16x8_t)(unint64_t)vuzp1_s16(0, 0);
      do
      {
        uint64_t v91 = *v84++;
        v86.i64[0] = v91;
        int16x8_t v86 = vzip1q_s16(v90, v86);
        *v87++ = v86;
        unint64_t v92 = v89 + 7;
        v89 += 4;
        unint64_t v93 = ((char *)a4[1] - (char *)*a4) >> 2;
      }
      while (v92 < v93);
      uint64_t v87 = *a4;
    }
    BOOL v94 = v93 > v89;
    unint64_t v95 = v93 - v89;
    if (v94)
    {
      BOOL v96 = &v87[v89 / 4];
      uint64_t v97 = (__int16 *)(v85 + 2 * v89);
      do
      {
        __int16 v98 = *v97++;
        v96->i16[0] = 0;
        v96->i16[1] = v98;
        BOOL v96 = (int16x8_t *)((char *)v96 + 4);
        --v95;
      }
      while (v95);
    }
  }
  else
  {
    if (MPSDataType == 268435472)
    {
      __int16 v69 = (float16x4_t *)malloc_type_malloc(v45, 0x916CA116uLL);
      memcpy(v69, (const void *)[v60 contents], v45);
      uint64_t v79 = *a4;
      uint64_t v80 = (char *)a4[1] - (char *)*a4;
      if (v80)
      {
        unint64_t v81 = v80 >> 2;
        if (v81 <= 1) {
          unint64_t v81 = 1;
        }
        if (v81 >= 0x10)
        {
          unint64_t v82 = v81 & 0xFFFFFFFFFFFFFFF0;
          unint64_t v118 = v69 + 2;
          uint64_t v119 = (float32x4_t *)&v79[2];
          unint64_t v120 = v81 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            float16x8_t v121 = *(float16x8_t *)v118[-2].i8;
            float32x4_t v122 = vcvtq_f32_f16(*v118);
            float32x4_t v123 = vcvt_hight_f32_f16(*(float16x8_t *)v118->i8);
            v119[-2] = vcvtq_f32_f16(*(float16x4_t *)v121.i8);
            v119[-1] = vcvt_hight_f32_f16(v121);
            *uint64_t v119 = v122;
            v119[1] = v123;
            v119 += 4;
            v118 += 4;
            v120 -= 16;
          }
          while (v120);
          goto LABEL_489;
        }
        unint64_t v82 = 0;
        do
        {
          _H0 = v69->i16[v82];
          __asm { FCVT            S0, H0 }
          v79->i32[v82++] = _S0;
LABEL_489:
          ;
        }
        while (v81 != v82);
      }
    }
    else
    {
      if (MPSDataType != 268435488) {
        __assert_rtn("waitAndReadFPTensorData", "MPSRuntime.mm", 1397, "0 && \"unsupported data type\"");
      }
      __int16 v69 = (float16x4_t *)malloc_type_malloc(v45, 0x224A73CFuLL);
      memcpy(v69, (const void *)[v60 contents], v45);
      uint64_t v70 = *a4;
      long long v71 = a4[1];
      uint64_t v72 = (char *)v71 - (char *)*a4;
      if (v71 != *a4)
      {
        unint64_t v73 = 0;
        unint64_t v74 = v72 >> 2;
        if (v74 <= 1) {
          unint64_t v74 = 1;
        }
        if (v74 < 8 || (unint64_t)((char *)v70 - (char *)v69) < 0x20) {
          goto LABEL_497;
        }
        unint64_t v75 = 0;
        unint64_t v73 = v74 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v76 = v74 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int16x8_t v77 = *(int16x8_t *)v69[v75 / 8 + 2].i8;
          long long v78 = &v70[v75 / 0x10];
          int16x8_t *v78 = *(int16x8_t *)v69[v75 / 8].i8;
          v78[1] = v77;
          v75 += 32;
          v76 -= 8;
        }
        while (v76);
        while (v74 != v73)
        {
LABEL_497:
          v70->i32[v73] = v69->i32[v73];
          ++v73;
        }
      }
    }
    free(v69);
  }

LABEL_496:
LABEL_494:
  if (v321 != v323) {
    free(v321);
  }
LABEL_491:
  if (v324 != v326) {
    free(v324);
  }
}

void GPURegionRuntime::writeIntTensorData(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t *a4, unint64_t a5)
{
  uint64_t v48 = a3;
  if (!a5) {
    return;
  }
  uint64_t v9 = a1 + 344;
  uint64_t v47 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v48) + 2);
  *(void *)&long long v46 = &v47;
  uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(v9, &v47, (uint64_t)&std::piecewise_construct, (void **)&v46);
  unint64_t StaticType = GPURegionRuntime::getStaticType(a1, v48);
  if (!*(void *)StaticType) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long v46 = StaticType;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
  uint64_t v14 = v13;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(*(void *)(a1 + 64) + 24));
  uint64_t v16 = mlir::IntegerType::get(Context, 0x40u, 1u);
  uint64_t v17 = (void *)mlir::RankedTensorType::get(Value, v14, v16, 0);
  *(void *)&long long v46 = mlir::createRawElementsAttr(v17, a4, (const void *)(8 * a5));
  *((void *)&v46 + 1) = v18;
  uint64_t v47 = v48;
  std::__hash_table<std::__hash_value_type<void *,mlir::ElementsAttr>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::ElementsAttr>>>::__emplace_unique_key_args<void *,void *,mlir::ElementsAttr&>((uint64_t)(v10 + 24), &v47, &v47, &v46);
  uint8x8_t v19 = (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)a1 + 80))(a1, v48, *(void *)(a2 + 8), 0, 0, 1);
  unint64_t v20 = [v19 mpsndarray];
  int64_t v21 = v20;
  if (!v20) {
    __assert_rtn("writeIntTensorData", "MPSRuntime.mm", 1438, "resultNDArray != nil");
  }
  int v22 = [v20 dataType];
  if ((v22 & 0xDFFFFFFF) != 0x20) {
    __assert_rtn("writeIntTensorData", "MPSRuntime.mm", 1441, "dataType == MPSDataTypeInt32 || dataType == MPSDataTypeUInt32");
  }
  size_t v23 = a5 * ((unsigned __int16)v22 >> 3);
  __int32 v24 = (int32x4_t *)malloc_type_malloc(v23, 0xC797FCB2uLL);
  unint64_t v25 = v24;
  if (a5 < 8)
  {
    unint64_t v26 = 0;
LABEL_11:
    unint64_t v34 = a5 - v26;
    id v35 = &v24->i32[v26];
    uint64_t v36 = &a4->i64[v26];
    do
    {
      uint64_t v37 = *v36++;
      *v35++ = v37;
      --v34;
    }
    while (v34);
    goto LABEL_13;
  }
  unint64_t v26 = a5 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v27 = a4 + 2;
  uint64_t v28 = v24 + 1;
  unint64_t v29 = a5 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    int32x4_t v31 = v27[-2];
    int32x4_t v30 = v27[-1];
    int32x4_t v33 = *v27;
    int32x4_t v32 = v27[1];
    v27 += 4;
    v28[-1] = vuzp1q_s32(v31, v30);
    int32x4_t *v28 = vuzp1q_s32(v33, v32);
    v28 += 2;
    v29 -= 8;
  }
  while (v29);
  if (a5 != v26) {
    goto LABEL_11;
  }
LABEL_13:
  unint64_t v38 = [*(id *)(a1 + 48) metalDevice];
  uint64_t v39 = (void *)[v38 newBufferWithLength:v23 options:0];

  uint64_t v40 = [v21 descriptor];
  [v40 setPreferPackedRows:1];
  unint64_t v41 = (void *)[objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:v39 descriptor:v40];
  id v42 = v39;
  memcpy((void *)[v42 contents], v25, v23);
  id v43 = *(void **)(a2 + 72);
  if (v43)
  {
    [v43 endEncoding];
    uint64_t v44 = *(void **)(a2 + 72);
    *(void *)(a2 + 72) = 0;
  }
  [v21 importDataWithCommandBuffer:*(void *)(a2 + 8) fromBuffer:v42 sourceDataType:536870944 offset:0 rowStrides:0];
  unint64_t v45 = [*(id *)(a2 + 8) rootCommandBuffer];
  (**(void (***)(uint64_t))a2)(a2);
  [v45 waitUntilCompleted];
  free(v25);
}

void sub_180D08E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D08F1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D08F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *FullyPlacedOnANEMPSRuntime::initializeForExecution(void *this)
{
  uint64_t v1 = this[29];
  unint64_t v2 = *(unsigned int *)(v1 + 44);
  if ((v2 & 0x7FFFFF) == 0) {
    __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
  }
  unint64_t v3 = v1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 64;
  if (v3 >= 0xFFFFFFFFFFFFFFF9) {
    __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
  }
  uint64_t v4 = this;
  unint64_t v5 = ((v3 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v1 + 40);
  __int32 v11 = this;
  for (uint64_t i = *(void *)(v5 + 8); i != v5; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v7 = i - 8;
    if (!i) {
      uint64_t v7 = 0;
    }
    uint64_t v8 = (void *)(v7 + 32);
    this = *(void **)(v7 + 40);
    if (this != (void *)(v7 + 32))
    {
      do
      {
        uint64_t v9 = (void *)this[1];
        mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)this);
        mlir::detail::walk<mlir::ForwardIterator>(v10, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<FullyPlacedOnANEMPSRuntime::initializeForExecution(void)::$_0>, (uint64_t)&v11, 1);
        this = v9;
      }
      while (v9 != v8);
    }
  }
  if (!v4[114]) {
    __assert_rtn("initializeForExecution", "MPSRuntime.mm", 1547, "_aneRegionCallOpHandler");
  }
  return this;
}

id FullyPlacedOnANEMPSRuntime::evaluateOps(uint64_t a1, void *a2, void *a3, void *a4, void *a5, char a6, char a7, int a8, BOOL *a9)
{
  id v16 = a2;
  id v17 = a3;
  uint64_t v18 = a4;
  id v19 = a5;
  if (*(void *)(a1 + 424) || [v18[1] count] || objc_msgSend(v18[2], "count")) {
    goto LABEL_7;
  }
  int v43 = a8;
  uint64_t v61 = 0;
  uint64_t v62 = &v61;
  uint64_t v63 = 0x2020000000;
  char v64 = 0;
  long long v46 = (void *)MEMORY[0x1E4F143A8];
  uint64_t v47 = 3221225472;
  uint64_t v48 = (id *)___ZZN26FullyPlacedOnANEMPSRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPbENK3__0clEv_block_invoke;
  uint64_t v49 = &unk_1E4FC1088;
  *(void *)&long long v50 = &v61;
  *((void *)&v50 + 1) = a1;
  [v16 enumerateObjectsUsingBlock:&v46];
  if (*((unsigned char *)v62 + 24))
  {
    _Block_object_dispose(&v61, 8);
LABEL_7:
    GPURegionRuntime::evaluateOps(a1, v16, v17, v18, v19, a6, a7, 0, a9);
    id v21 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_8;
  }
  uint64_t v57 = 0;
  long long v58 = &v57;
  uint64_t v59 = 0x2020000000;
  char v60 = 0;
  v56[0] = MEMORY[0x1E4F143A8];
  v56[1] = 3221225472;
  v56[2] = ___ZZN26FullyPlacedOnANEMPSRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPbENK3__0clEv_block_invoke_2;
  v56[3] = &unk_1E4FC1088;
  v56[4] = &v57;
  v56[5] = a1;
  [v17 enumerateObjectsUsingBlock:v56];
  int v20 = *((unsigned __int8 *)v58 + 24);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(&v61, 8);
  if (v20) {
    goto LABEL_7;
  }
  std::mutex::lock((std::mutex *)(a1 + 144));
  size_t v23 = *(void **)(a1 + 208);
  id v24 = v19;
  id v25 = v23;
  unint64_t v26 = v18;
  long long v46 = &unk_1EC9887A0;
  uint64_t v47 = (uint64_t)v24;
  id v42 = v26;
  uint64_t v48 = v26;
  LOBYTE(v49) = a6;
  BYTE1(v49) = a7;
  long long v50 = 0u;
  long long v51 = 0u;
  int v52 = 1065353216;
  id v53 = 0;
  uint64_t v54 = 0;
  id v55 = v25;
  unint64_t v45 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:*(unsigned int *)(a1 + 664)];
  uint64_t v27 = *(void *)(a1 + 912);
  uint64_t v28 = *(unsigned int *)(v27 + 56);
  if (v28)
  {
    unint64_t v29 = *(void **)(v27 + 48);
    uint64_t v30 = 8 * v28;
    do
    {
      if (*v29 >= (unint64_t)*(unsigned int *)(a1 + 664)) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      int32x4_t v31 = [v16 objectAtIndexedSubscript:*(void *)(*(void *)(a1 + 656) + 8 * *v29)];
      int32x4_t v32 = objc_msgSend(MEMORY[0x1E4F4E048], "objectWithIOSurface:", objc_msgSend(v31, "iosurface"));
      if (!v32 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v45 addObject:v32];

      ++v29;
      v30 -= 8;
    }
    while (v30);
  }
  uint64_t v44 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:*(unsigned int *)(a1 + 728)];
  uint64_t v33 = *(void *)(a1 + 912);
  uint64_t v34 = *(unsigned int *)(v33 + 104);
  if (v34)
  {
    id v35 = *(void **)(v33 + 96);
    uint64_t v36 = 8 * v34;
    do
    {
      if (*v35 >= (unint64_t)*(unsigned int *)(a1 + 728)) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      uint64_t v37 = [v17 objectAtIndexedSubscript:*(void *)(*(void *)(a1 + 720) + 8 * *v35)];
      unint64_t v38 = objc_msgSend(MEMORY[0x1E4F4E048], "objectWithIOSurface:", objc_msgSend(v37, "iosurface"));
      if (!v38 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v44 addObject:v38];

      ++v35;
      v36 -= 8;
    }
    while (v36);
    uint64_t v33 = *(void *)(a1 + 912);
  }
  if (*(unsigned char *)(v33 + 42))
  {
    int v39 = 2;
  }
  else
  {
    char v40 = [v42 waitUntilCompleted];
    uint64_t v33 = *(void *)(a1 + 912);
    int v39 = (v40 & 1) == 0 && *(unsigned char *)(v33 + 40) == 0;
  }
  GPU::ANERegionCallOpHandler::encodeOpWithInputsAndOutputs(v33, (uint64_t)&v46, v45, v44, v39, v43);
  if (a9) {
    *a9 = v39 != 0;
  }
  if (v53)
  {
    [v53 endEncoding];
    id v41 = v53;
    id v53 = 0;
  }
  GPURegionRuntime::postEvalCleanUp((GPURegionRuntime *)a1);
  id v21 = v17;

  GPU::EncodeDescriptor::~EncodeDescriptor((GPU::EncodeDescriptor *)&v46);
  std::mutex::unlock((std::mutex *)(a1 + 144));
LABEL_8:

  return v21;
}

void sub_180D095A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::mutex *a5, uint64_t a6, void *a7, void *a8, ...)
{
  va_start(va, a8);

  GPU::EncodeDescriptor::~EncodeDescriptor((GPU::EncodeDescriptor *)va);
  std::mutex::unlock(a5);

  _Unwind_Resume(a1);
}

void GPU::getRuntime(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  a1;
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  if (!*(unsigned char *)(a5 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a5, (uint64_t)"mps.fullyPlacedOnANE", 20), !v13))
  {
    uint64_t InherentAttr = mlir::DictionaryAttr::get(a5 + 56, "mps.fullyPlacedOnANE", 0x14uLL);
  }
  if (InherentAttr)
  {
    if (!*(void *)InherentAttr) {
      __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
    }
    if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
      operator new();
    }
  }
  operator new();
}

void sub_180D09830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  MEMORY[0x1852FDE70](v13, 0x10A1C40B66D3147);

  _Unwind_Resume(a1);
}

unint64_t GPU::calculateNDArrayAllocationSize(GPU *this, MPSNDArrayDescriptor *a2)
{
  unint64_t v2 = this;
  unint64_t v3 = (int32x4_t *)((char *)v2 + (int)*MEMORY[0x1E4F359F0]);
  int32x4_t v17 = v3[2];
  int32x4_t v19 = v3[3];
  int32x4_t v15 = v3[1];
  v4.i64[0] = 0x100000001;
  v4.i64[1] = 0x100000001;
  int8x16_t v21 = vorrq_s8(*(int8x16_t *)v3, vandq_s8((int8x16_t)vceqzq_s32(*v3), v4));
  uint64_t v5 = *(unsigned __int16 *)((char *)v2 + (int)*MEMORY[0x1E4F359E8]) * (unint64_t)v21.u32[0];
  uint64_t v6 = *(void *)((char *)v2 + (int)*MEMORY[0x1E4F35A10]);
  if (!*((unsigned char *)v2 + (int)*MEMORY[0x1E4F35A08])) {
    uint64_t v5 = (v5 + 127) & 0x1FFFFFFFFFF80;
  }
  if (v6) {
    unint64_t v7 = 8 * v6;
  }
  else {
    unint64_t v7 = v5;
  }
  if ((v7 / *(unsigned __int16 *)((char *)v2 + (int)*MEMORY[0x1E4F359E8])) >> 31
    && MTLReportFailureTypeEnabled())
  {
    MTLReportFailure();
  }
  v8.i64[0] = 0x100000001;
  v8.i64[1] = 0x100000001;
  int8x16_t v16 = vorrq_s8((int8x16_t)v19, vandq_s8((int8x16_t)vceqzq_s32(v19), v8));
  int8x16_t v18 = vorrq_s8((int8x16_t)v17, vandq_s8((int8x16_t)vceqzq_s32(v17), v8));
  int8x16_t v20 = vorrq_s8((int8x16_t)v15, vandq_s8((int8x16_t)vceqzq_s32(v15), v8));
  id v9 = (int *)MEMORY[0x1E4F35A00];
  if (*(void *)((char *)v2 + (int)*MEMORY[0x1E4F35A00]) >= 2uLL)
  {
    unint64_t v10 = 1;
    do
    {
      v22[0] = v21;
      v22[1] = v20;
      void v22[2] = v18;
      void v22[3] = v16;
      if ((*((_DWORD *)v22 + (v10 & 0xF)) & 0x80000000) != 0 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      ++v10;
    }
    while (v10 < *(void *)((char *)v2 + *v9));
  }
  unint64_t v11 = v7 * v21.u32[1];
  if (is_mul_ok(v7, v21.u32[1]) && v11 <= 0x2000000000)
  {
    unint64_t v12 = v11 * v21.u32[2];
    if (!is_mul_ok(v11, v21.u32[2])) {
      goto LABEL_43;
    }
    v11 *= v21.u32[2];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v21.u32[3];
    if (!is_mul_ok(v12, v21.u32[3]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v20.u32[0];
    if (!is_mul_ok(v11, v20.u32[0])) {
      goto LABEL_43;
    }
    v11 *= v20.u32[0];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v20.u32[1];
    if (!is_mul_ok(v12, v20.u32[1]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v20.u32[2];
    if (!is_mul_ok(v11, v20.u32[2])) {
      goto LABEL_43;
    }
    v11 *= v20.u32[2];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v20.u32[3];
    if (!is_mul_ok(v12, v20.u32[3]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v18.u32[0];
    if (!is_mul_ok(v11, v18.u32[0])) {
      goto LABEL_43;
    }
    v11 *= v18.u32[0];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v18.u32[1];
    if (!is_mul_ok(v12, v18.u32[1]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v18.u32[2];
    if (!is_mul_ok(v11, v18.u32[2])) {
      goto LABEL_43;
    }
    v11 *= v18.u32[2];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v18.u32[3];
    if (!is_mul_ok(v12, v18.u32[3]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v16.u32[0];
    if (!is_mul_ok(v11, v16.u32[0])) {
      goto LABEL_43;
    }
    v11 *= v16.u32[0];
    if (v12 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v11 = v12 * v16.u32[1];
    if (!is_mul_ok(v12, v16.u32[1]) || v11 > 0x2000000000) {
      goto LABEL_44;
    }
    unint64_t v12 = v11 * v16.u32[2];
    if (!is_mul_ok(v11, v16.u32[2]))
    {
LABEL_43:
      unint64_t v11 = v12;
      goto LABEL_44;
    }
    v11 *= v16.u32[2];
    if (v12 <= 0x2000000000) {
      unint64_t v11 = v12 * v16.u32[3];
    }
  }
LABEL_44:
  unint64_t v13 = (v11 + 7) >> 3;

  return v13;
}

void sub_180D09C88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D09C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::MPSGraphKernelDAG::createDAGOp(GPU::MPSGraphKernelDAG *this, GPU::BaseOpHandler *a2)
{
  uint64_t v2 = *((void *)a2 + 3);
  if (!*(_DWORD *)(v2 + 36)) {
    return 0;
  }
  unint64_t v5 = v2 - 16;
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((void *)this + 16), v2 - 16);
  unsigned int MPSDataType = getMPSDataType(StaticType);
  if (MPSDataType == 4) {
    unsigned int v8 = 8;
  }
  else {
    unsigned int v8 = MPSDataType;
  }
  if (MPSDataType == -2147483640) {
    uint64_t v9 = 536870920;
  }
  else {
    uint64_t v9 = v8;
  }
  getBaseTensorShape(StaticType, (int8x16_t **)&v19);
  long long __p = 0;
  int32x4_t v17 = 0;
  int8x16_t v18 = 0;
  unint64_t v10 = v19;
  int64_t v11 = v20 - (unsigned char *)v19;
  if (v20 != v19)
  {
    if (v11 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = (char *)operator new(v20 - (unsigned char *)v19);
    unint64_t v13 = &v12[8 * (v11 >> 3)];
    long long __p = v12;
    int8x16_t v18 = v13;
    memcpy(v12, v10, v11);
    int32x4_t v17 = v13;
  }
  uint64_t v14 = (*(uint64_t (**)(GPU::BaseOpHandler *, GPU::MPSGraphKernelDAG *, void **, uint64_t, void))(*(void *)a2 + 24))(a2, this, &__p, v9, 0);
  if (__p)
  {
    int32x4_t v17 = __p;
    operator delete(__p);
  }
  if (v14) {
    std::__hash_table<std::__hash_value_type<void *,BaseTensor *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,BaseTensor *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,BaseTensor *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,BaseTensor *>>>::__emplace_unique_key_args<void *,std::pair<void *,BaseTensor *>>((float *)this + 4, v5, v5, v14);
  }
  if (v19)
  {
    int8x16_t v20 = v19;
    operator delete(v19);
  }
  return v14;
}

void sub_180D09E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

int8x16_t *getBaseTensorShape@<X0>(uint64_t **a1@<X0>, int8x16_t **a2@<X8>)
{
  if (!a1) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v2 = a1;
  if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(a1))
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v2);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
    size_t v23 = v2;
    uint64_t v24 = InterfaceFor;
  }
  else
  {
    uint64_t v2 = 0;
    size_t v23 = 0;
    uint64_t v24 = 0;
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
  }
  if (!*v2) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if ((_UNKNOWN *)(*v2)[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && MTLReportFailureTypeEnabled())
  {
    MTLReportFailure();
  }
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v23) & 1) == 0) {
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
  if (v5)
  {
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
    uint64_t v8 = v7;
    uint64_t v9 = (int8x16_t *)(ArgAttrsAttr + 8 * v7);
    BOOL result = (int8x16_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    uint64_t v11 = (char *)v9 - (char *)result;
    if (v9 != result)
    {
      if (v11 < 0) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v12 = result;
      BOOL result = (int8x16_t *)operator new((char *)v9 - (char *)result);
      *a2 = result;
      a2[1] = result;
      a2[2] = (int8x16_t *)((char *)result + 8 * (v11 >> 3));
      if (v9 == v12)
      {
        int8x16_t v16 = (char *)result;
      }
      else
      {
        unint64_t v13 = ArgAttrsAttr + 8 * v8 - (void)v12 - 8;
        if (v13 < 0x18) {
          goto LABEL_17;
        }
        uint64_t v14 = (v13 >> 3) + 1;
        uint64_t v15 = 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v9 = (int8x16_t *)((char *)v9 - v15);
        int8x16_t v16 = &result->i8[v15];
        int32x4_t v17 = result + 1;
        int8x16_t v18 = (int8x16_t *)(8 * v8 + ArgAttrsAttr - 16);
        uint64_t v19 = v14 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          int8x16_t v20 = vextq_s8(v18[-1], v18[-1], 8uLL);
          v17[-1] = vextq_s8(*v18, *v18, 8uLL);
          *int32x4_t v17 = v20;
          v17 += 2;
          v18 -= 2;
          v19 -= 4;
        }
        while (v19);
        BOOL result = (int8x16_t *)v16;
        if (v14 != (v14 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_17:
          int8x16_t v16 = (char *)result;
          do
          {
            uint64_t v21 = v9[-1].i64[1];
            uint64_t v9 = (int8x16_t *)((char *)v9 - 8);
            *(void *)int8x16_t v16 = v21;
            v16 += 8;
          }
          while (v9 != v12);
        }
      }
      a2[1] = (int8x16_t *)v16;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    int v22 = operator new(8uLL);
    *a2 = (int8x16_t *)v22;
    *int v22 = 1;
    BOOL result = (int8x16_t *)(v22 + 1);
    a2[1] = result;
    a2[2] = result;
  }
  return result;
}

void sub_180D0A0F8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

id GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(GPU::MPSGraphKernelDAG *this, GPURegionRuntime *a2)
{
  int8x16_t v4 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:(uint64_t)(*((void *)this + 8) - *((void *)this + 7)) >> 3];
  uint64_t v5 = (uint64_t *)*((void *)this + 7);
  uint64_t v6 = (uint64_t *)*((void *)this + 8);
  if (v5 != v6)
  {
    uint64_t v7 = (void *)((char *)a2 + 88);
    do
    {
      uint64_t v15 = *v5;
      uint64_t v14 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v15) + 2);
      uint64_t v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7, &v14);
      if (v8
        && (uint64_t v13 = v15,
            (uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, &v13)) != 0))
      {
        id v10 = (id)v9[3];
      }
      else
      {
        id v10 = 0;
      }
      uint64_t v11 = [v10 mpsndarray];

      if (!v11 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v4 addObject:v11];

      ++v5;
    }
    while (v5 != v6);
  }

  return v4;
}

void sub_180D0A25C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D0A270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D0A284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  int16x8_t v77 = (__int16 *)a2;
  uint64_t v5 = (float *)(a1 + 16);
  int8x8_t v6 = *(int8x8_t *)(a1 + 24);
  if (v6)
  {
    unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
    unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v7 >> 47) ^ v7);
    unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v6);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = v9;
      if (v9 >= *(void *)&v6) {
        unint64_t v11 = v9 % *(void *)&v6;
      }
    }
    else
    {
      unint64_t v11 = (*(void *)&v6 - 1) & v9;
    }
    unint64_t v12 = *(void **)(*(void *)v5 + 8 * v11);
    if (v12)
    {
      uint64_t v13 = (void *)*v12;
      if (v13)
      {
        if (v10.u32[0] < 2uLL)
        {
          uint64_t v14 = *(void *)&v6 - 1;
          while (1)
          {
            uint64_t v16 = v13[1];
            if (v16 == v9)
            {
              if (v13[2] == a2) {
                return v13[3];
              }
            }
            else if ((v16 & v14) != v11)
            {
              goto LABEL_21;
            }
            uint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v15 = v13[1];
          if (v15 == v9)
          {
            if (v13[2] == a2) {
              return v13[3];
            }
          }
          else
          {
            if (v15 >= *(void *)&v6) {
              v15 %= *(void *)&v6;
            }
            if (v15 != v11) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_21:
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*(void *)(a1 + 128), a2);
  int MPSDataType = getMPSDataType(StaticType);
  if (MPSDataType == -2147483640)
  {
    int v19 = 536870920;
    getBaseTensorShape(StaticType, (int8x16_t **)&__p);
    if (!a3) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  int v19 = MPSDataType;
  if (MPSDataType == 4) {
    int v19 = 8;
  }
  getBaseTensorShape(StaticType, (int8x16_t **)&__p);
  if (a3)
  {
LABEL_27:
    uint64_t v20 = *a3;
    uint64_t v21 = a3[1] - *a3;
    if ((unint64_t)v21 >= 8)
    {
      unint64_t v28 = 0;
      unint64_t v29 = v21 >> 2;
      uint64_t v30 = (char *)__p;
      unint64_t v31 = (v76 - (unsigned char *)__p) >> 3;
      do
      {
        if (v29 <= v28 + 1) {
          std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::__throw_out_of_range[abi:ne180100]();
        }
        unint64_t v32 = *(int *)(v20 + 4 * v28);
        unint64_t v33 = *(int *)(v20 + 4 * v28 + 4);
        if (v32 != v33 && v31 > v32 && v31 > v33)
        {
          uint64_t v36 = 8 * v32;
          uint64_t v37 = 8 * v33;
          uint64_t v38 = *(void *)&v30[v36];
          *(void *)&v30[v36] = *(void *)&v30[v37];
          *(void *)&v30[v37] = v38;
        }
        v28 += 2;
      }
      while (v29 >> 1 > v28);
    }
  }
LABEL_28:
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  long long v78 = (__int16 **)&v73;
  long long v71 = v77;
  if (!v77) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v71);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v78, DefiningOp)) {
    goto LABEL_73;
  }
  size_t v23 = *(void **)v77;
  if (*(void *)v77)
  {
    uint64_t v24 = 0;
    do
    {
      uint64_t v25 = v23[2];
      uint64_t ParentOp = *(mlir::Block **)(v25 + 16);
      if (ParentOp) {
        uint64_t ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
      }
      if (ParentOp != *(mlir::Block **)(a1 + 112)
        || (uint64_t v27 = mlir::TypeID::get<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>(),
            (*(unsigned int (**)(void, uint64_t))(**(void **)(v25 + 48) + 32))(*(void *)(v25 + 48), v27))&& ((long long v71 = 0, v72 = 0, v78 = &v71, !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v78, v25))|| (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v71) & 1) != 0))
      {
        uint64_t v25 = v24;
      }
      else if (v24 && MTLReportFailureTypeEnabled())
      {
        MTLReportFailure();
      }
      size_t v23 = (void *)*v23;
      uint64_t v24 = v25;
    }
    while (v23);
  }
  else
  {
    uint64_t v25 = 0;
  }
  uint64_t v39 = mlir::Value::getDefiningOp((mlir::Value *)&v77);
  uint64_t v40 = mlir::TypeID::get<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v39 + 48) + 32))(*(void *)(v39 + 48), v40)) {
    goto LABEL_73;
  }
  long long v71 = 0;
  uint64_t v72 = 0;
  long long v78 = &v71;
  if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v78, v39))
  {
    int OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v71);
    if (v25) {
      char v42 = OperandRange;
    }
    else {
      char v42 = 0;
    }
    if ((v42 & 1) == 0)
    {
      if (OperandRange) {
        goto LABEL_99;
      }
      goto LABEL_73;
    }
  }
  else if (!v25)
  {
    goto LABEL_99;
  }
  int v43 = *(_DWORD *)(v25 + 44);
  if ((v43 & 0x800000) == 0) {
    goto LABEL_99;
  }
  unint64_t v44 = 0;
  char v45 = 1;
  uint64_t v46 = 24;
  do
  {
    if (v44 >= *(unsigned int *)(v25 + 68)) {
      break;
    }
    if (*(__int16 **)(*(void *)(v25 + 72) + v46) == v77)
    {
      char v45 = (***(uint64_t (****)(void, uint64_t, unint64_t))(a1 + 136))(*(void *)(a1 + 136), v25, v44);
      int v43 = *(_DWORD *)(v25 + 44);
    }
    ++v44;
    v46 += 32;
  }
  while ((v43 & 0x800000) != 0);
  if (v45)
  {
LABEL_99:
    mlir::mps::CPUNDArray::CPUNDArray(&v71, v73, v74);
    if (mlir::mps::CPUNDArray::isIntegerType((mlir::mps::CPUNDArray *)&v71))
    {
      mlir::mps::CPUNDArray::getSplatIntegerValue((mlir::mps::CPUNDArray *)&v71);
      uint64_t Op = MPSKernelDAG::constantOp();
    }
    else if (mlir::mps::CPUNDArray::isFloatType((mlir::mps::CPUNDArray *)&v71))
    {
      mlir::mps::CPUNDArray::getSplatFloatValue((mlir::mps::CPUNDArray *)&v71);
      uint64_t Op = MPSKernelDAG::constantOp();
    }
    else
    {
      if (!mlir::mps::CPUNDArray::isComplexType((mlir::mps::CPUNDArray *)&v71)) {
        __assert_rtn("getBaseTensorFromDataMap", "MPSRuntime.mm", 1774, "0 && \"unkown type\"");
      }
      mlir::mps::CPUNDArray::getSplatComplexValue(&v71);
      if (v19 != 285212736 && v19 != 285212704) {
        llvm::llvm_unreachable_internal((llvm *)"unsupported complex type", "/Library/Caches/com.apple.xbs/Sources/MetalPerformanceShadersGraph/mpsgraph/MetalPerformanceShadersGraph/Core/Files/MPSGraphUtilities.mm", (const char *)0x6D);
      }
      MPSKernelDAG::constantOp();
      MPSKernelDAG::constantOp();
      uint64_t Op = MPSKernelDAG::complexCreateOp();
    }
    uint64_t v47 = Op;
    std::__hash_table<std::__hash_value_type<void *,BaseTensor *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,BaseTensor *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,BaseTensor *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,BaseTensor *>>>::__emplace_unique_key_args<void *,std::pair<void *,BaseTensor *>>(v5, (unint64_t)v77, (uint64_t)v77, Op);
    mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)&v71);
    long long v50 = __p;
    if (!__p) {
      return v47;
    }
    goto LABEL_97;
  }
LABEL_73:
  uint64_t v47 = MPSKernelDAG::placeholderOp();
  std::__hash_table<std::__hash_value_type<void *,BaseTensor *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,BaseTensor *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,BaseTensor *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,BaseTensor *>>>::__emplace_unique_key_args<void *,std::pair<void *,BaseTensor *>>(v5, (unint64_t)v77, (uint64_t)v77, v47);
  uint64_t v49 = *(__int16 ***)(a1 + 64);
  unint64_t v48 = *(void *)(a1 + 72);
  if ((unint64_t)v49 < v48)
  {
    *uint64_t v49 = v77;
    *(void *)(a1 + 64) = v49 + 1;
    long long v50 = __p;
    if (!__p) {
      return v47;
    }
    goto LABEL_97;
  }
  long long v51 = *(char **)(a1 + 56);
  uint64_t v52 = ((char *)v49 - v51) >> 3;
  unint64_t v53 = v52 + 1;
  if ((unint64_t)(v52 + 1) >> 61) {
    std::vector<long>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v54 = v48 - (void)v51;
  if (v54 >> 2 > v53) {
    unint64_t v53 = v54 >> 2;
  }
  if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v55 = v53;
  }
  if (v55)
  {
    if (v55 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v56 = (char *)operator new(8 * v55);
  }
  else
  {
    uint64_t v56 = 0;
  }
  uint64_t v57 = (__int16 **)&v56[8 * v52];
  long long v58 = &v56[8 * v55];
  void *v57 = v77;
  uint64_t v59 = v57 + 1;
  if (v49 != (__int16 **)v51)
  {
    unint64_t v60 = (char *)v49 - v51 - 8;
    if (v60 < 0x58) {
      goto LABEL_118;
    }
    if ((unint64_t)(v51 - v56) < 0x20) {
      goto LABEL_118;
    }
    uint64_t v61 = (v60 >> 3) + 1;
    uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v63 = &v49[v62 / 0xFFFFFFFFFFFFFFF8];
    uint64_t v57 = (__int16 **)((char *)v57 - v62);
    char v64 = &v56[8 * v52 - 16];
    unint64_t v65 = v49 - 2;
    uint64_t v66 = v61 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v67 = *(_OWORD *)v65;
      *((_OWORD *)v64 - 1) = *((_OWORD *)v65 - 1);
      *(_OWORD *)char v64 = v67;
      v64 -= 32;
      v65 -= 4;
      v66 -= 4;
    }
    while (v66);
    uint64_t v49 = v63;
    if (v61 != (v61 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_118:
      do
      {
        uint64_t v68 = *--v49;
        *--uint64_t v57 = v68;
      }
      while (v49 != (__int16 **)v51);
    }
    uint64_t v49 = *(__int16 ***)(a1 + 56);
  }
  *(void *)(a1 + 56) = v57;
  *(void *)(a1 + 64) = v59;
  *(void *)(a1 + 72) = v58;
  if (v49) {
    operator delete(v49);
  }
  *(void *)(a1 + 64) = v59;
  long long v50 = __p;
  if (__p)
  {
LABEL_97:
    unint64_t v76 = v50;
    operator delete(v50);
  }
  return v47;
}

void sub_180D0A9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

id GPU::doReshapeWithFallBack(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned char *a6, int a7)
{
  id v13 = a1;
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  int8x16_t v18 = [v15 reshapeWithCommandEncoder:v16 commandBuffer:v17 sourceArray:v13 shape:v14 destinationArray:0];
  *a6 = 0;
  if (!v18 && a7)
  {
    int v19 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:shape:", objc_msgSend(v13, "dataType"), v14);
    [v19 setPreferPackedRows:1];
    int8x16_t v18 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v17 descriptor:v19];
    id v20 = (id)[v15 reshapeWithCommandEncoder:v16 commandBuffer:v17 sourceArray:v13 shape:v14 destinationArray:v18];
    *a6 = 1;
  }

  return v18;
}

void sub_180D0ABB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

mlir::Operation **mlir::OwningOpRef<mlir::func::FuncOp>::~OwningOpRef(mlir::Operation **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    mlir::Operation::erase(v2);
  }
  return a1;
}

void GPURegionRuntime::TIAndFoldHelper::init(GPURegionRuntime::TIAndFoldHelper *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 232);
  unint64_t v2 = *(unsigned int *)(v1 + 44);
  if ((v2 & 0x7FFFFF) == 0) {
    goto LABEL_75;
  }
  unint64_t v3 = v1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 64;
  if (v3 >= 0xFFFFFFFFFFFFFFF9) {
    goto LABEL_76;
  }
  uint64_t v4 = *(void *)(((v3 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v1 + 40) + 8);
  if (v4) {
    uint64_t v5 = v4 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  int8x8_t v6 = (mlir::GenericProgramPoint *)(v5 + 32);
  unint64_t v7 = *(mlir::GenericProgramPoint **)(v5 + 40);
  if (v7 != (mlir::GenericProgramPoint *)(v5 + 32))
  {
    do
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v7);
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(v9 + 48);
      unint64_t v12 = *(void **)(v11 + 16);
      if (v12 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v53[0] = *(mlir::Operation **)(v11 + 8);
        uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
        if (v40 == 13 && *AttrData == 0x6974732E7873706DLL && *(void *)((char *)AttrData + 5) == 0x6465686374697473)
        {
          __int16 v52 = 1283;
          v49[0] = (uint64_t)"classof on '";
          long long v50 = "mpsx.stitched";
          uint64_t v44 = 13;
          goto LABEL_79;
        }
      }
      else if (v12 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
      {
        unint64_t v13 = *(unsigned int *)(v9 + 44);
        if ((v13 & 0x7FFFFF) != 0)
        {
          unint64_t v14 = v9 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 64;
          if (v14 < 0xFFFFFFFFFFFFFFF9)
          {
            uint64_t v15 = *(void *)(((v14 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v9 + 40) + 8);
            if (v15) {
              uint64_t v16 = v15 - 8;
            }
            else {
              uint64_t v16 = 0;
            }
            id v17 = (mlir::GenericProgramPoint *)(v16 + 32);
            for (uint64_t i = *(mlir::GenericProgramPoint **)(v16 + 40); ; uint64_t i = (mlir::GenericProgramPoint *)*((void *)i + 1))
            {
              if (i == v17) {
                goto LABEL_9;
              }
              mlir::GenericProgramPoint::~GenericProgramPoint(i);
              char v45 = v19;
              id v20 = (int8x8_t *)*((void *)this + 1);
              int8x8_t v21 = v20[34];
              if (!*(void *)&v21) {
                goto LABEL_73;
              }
              unint64_t v22 = 0x9DDFEA08EB382D69 * (((8 * v19) + 8) ^ ((unint64_t)v19 >> 32));
              unint64_t v23 = 0x9DDFEA08EB382D69 * (((unint64_t)v19 >> 32) ^ (v22 >> 47) ^ v22);
              unint64_t v24 = 0x9DDFEA08EB382D69 * (v23 ^ (v23 >> 47));
              uint8x8_t v25 = (uint8x8_t)vcnt_s8(v21);
              v25.i16[0] = vaddlv_u8(v25);
              if (v25.u32[0] > 1uLL)
              {
                unint64_t v26 = v24;
                if (v24 >= *(void *)&v21) {
                  unint64_t v26 = v24 % *(void *)&v21;
                }
              }
              else
              {
                unint64_t v26 = v24 & (*(void *)&v21 - 1);
              }
              uint64_t v27 = *(void **)(*(void *)&v20[33] + 8 * v26);
              if (!v27) {
                goto LABEL_73;
              }
              unint64_t v28 = (void *)*v27;
              if (!v28) {
                goto LABEL_73;
              }
              if (v25.u32[0] < 2uLL)
              {
                uint64_t v29 = *(void *)&v21 - 1;
                while (1)
                {
                  uint64_t v31 = v28[1];
                  if (v31 == v24)
                  {
                    if ((mlir::Operation *)v28[2] == v19) {
                      goto LABEL_41;
                    }
                  }
                  else if ((v31 & v29) != v26)
                  {
                    goto LABEL_73;
                  }
                  unint64_t v28 = (void *)*v28;
                  if (!v28) {
                    goto LABEL_73;
                  }
                }
              }
              while (1)
              {
                unint64_t v30 = v28[1];
                if (v30 == v24) {
                  break;
                }
                if (v30 >= *(void *)&v21) {
                  v30 %= *(void *)&v21;
                }
                if (v30 != v26) {
                  goto LABEL_73;
                }
LABEL_31:
                unint64_t v28 = (void *)*v28;
                if (!v28) {
                  goto LABEL_73;
                }
              }
              if ((mlir::Operation *)v28[2] != v19) {
                goto LABEL_31;
              }
LABEL_41:
              uint64_t v32 = v28[3];
              if (*(unsigned char *)(v32 + 56) || *(unsigned char *)(v32 + 57))
              {
LABEL_18:
                (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 80))(this, v32);
                continue;
              }
              if (!v19) {
                goto LABEL_74;
              }
              uint64_t v33 = *((void *)v19 + 6);
              uint64_t v34 = *(void **)(v33 + 16);
              if (v34 == &mlir::detail::TypeIDResolver<void,void>::id)
              {
                v53[0] = *(mlir::Operation **)(v33 + 8);
                id v35 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
                if (v36 != 21) {
                  goto LABEL_56;
                }
                BOOL v37 = *v35 == 0x6E656D6563616C70 && v35[1] == 0x6E6F696765722E74;
                if (!v37 || *(void *)((char *)v35 + 13) != 0x6C6C61635F6E6F69) {
                  goto LABEL_56;
                }
                __int16 v52 = 1283;
                v49[0] = (uint64_t)"classof on '";
                long long v50 = "placement.region_call";
                uint64_t v44 = 21;
LABEL_79:
                uint64_t v51 = v44;
                uint64_t v47 = "' failed due to the operation not being registered";
                __int16 v48 = 259;
                llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)v53);
                llvm::report_fatal_error((llvm::Twine *)v53, 1);
              }
              if (v34 == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
              {
                uint64_t v46 = v19;
                if (!mlir::placement::RegionCall::getRegionType(&v46)) {
                  goto LABEL_18;
                }
              }
LABEL_56:
              if (_ZN4llvm3isaIN4mlir4mpsx16ReturnStitchedOpENS1_3mps10IdentityOpEJEPNS1_9OperationEEEbRKT2_((uint64_t)&v45)) {
                goto LABEL_18;
              }
            }
          }
LABEL_76:
          __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
        }
LABEL_75:
        __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
      }
      if ((*(_DWORD *)(v10 + 44) & 0x7FFFFF) == 0)
      {
        v49[0] = v10;
        char v42 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(*((void *)this + 1) + 264), v49);
        if (!v42) {
LABEL_73:
        }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        uint64_t v43 = v42[3];
        if (*(unsigned char *)(v43 + 56) || *(unsigned char *)(v43 + 57)) {
          goto LABEL_8;
        }
        if (!v49[0]) {
LABEL_74:
        }
          __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
        if ((v53[0] = (mlir::Operation *)llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(v49[0])) != 0
          && !mlir::placement::RegionCall::getRegionType(v53)
          || _ZN4llvm3isaIN4mlir4mpsx16ReturnStitchedOpENS1_3mps10IdentityOpEJEPNS1_9OperationEEEbRKT2_((uint64_t)v49))
        {
LABEL_8:
          (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 80))(this, v43);
        }
      }
LABEL_9:
      unint64_t v7 = (mlir::GenericProgramPoint *)*((void *)v7 + 1);
    }
    while (v7 != v6);
  }
}

BOOL GPURegionRuntime::isSmallIntType(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  if (!a2) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(a2))
  {
    id v17 = 0;
    uint64_t v18 = 0;
    return 0;
  }
  uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(a2);
  if (!InterfaceFor) {
    __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  id v17 = a2;
  uint64_t v18 = InterfaceFor;
  uint64_t v6 = *(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v17);
  if (!v6) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(v6 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return 0;
  }
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v17);
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange) < 8) {
    return 0;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v17)) {
    return a3;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v17);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v10 -= 8;
      if (!v10) {
        goto LABEL_16;
      }
    }
    return a3;
  }
LABEL_16:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v17)) {
LABEL_23:
  }
    __assert_rtn("getNumElements", "BuiltinTypeInterfaces.h.inc", 162, "hasStaticShape() && \"cannot get element count of dynamic shaped type\"");
  uint64_t v11 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v17);
  if (v12)
  {
    uint64_t v13 = 8 * v12;
    while (*v11 != 0x8000000000000000)
    {
      ++v11;
      v13 -= 8;
      if (!v13) {
        goto LABEL_21;
      }
    }
    goto LABEL_23;
  }
LABEL_21:
  unint64_t v14 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v17);
  return mlir::ShapedType::getNumElements(v14, v15) < 17;
}

void GPURegionRuntime::TIAndFoldHelper::runOnRegion(GPURegionRuntime::TIAndFoldHelper *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  long long v35 = *(_OWORD *)(*((void *)a1 + 1) + 232);
  mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v35);
  if (v14)
  {
    unint64_t v15 = 0;
    uint64_t v16 = (void *)(a4 + 8);
    while (1)
    {
      unint64_t v18 = *(unsigned int *)(v35 + 44);
      if ((v18 & 0x7FFFFF) == 0) {
        __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
      }
      unint64_t v19 = v35 + 16 * ((v18 >> 23) & 1) + ((v18 >> 21) & 0x7F8) + 64;
      if (v19 >= 0xFFFFFFFFFFFFFFF9) {
        __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
      }
      id v20 = (void *)(((v19 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v35 + 40));
      if ((void *)*v20 == v20) {
        break;
      }
      uint64_t v21 = v20[1];
      uint64_t v22 = v21 - 8;
      if (!v21) {
        uint64_t v22 = 0;
      }
      uint64_t v23 = *(void *)(v22 + 48);
      if (v15 >= (*(void *)(v22 + 56) - v23) >> 3) {
        break;
      }
      if (a3 == v15) {
        goto LABEL_28;
      }
      uint64_t v24 = *(void *)(v23 + 8 * v15);
      if (*(void *)(a2 + 8 * v15)) {
        (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)a1 + 32))(a1, v24);
      }
      if (a5 == v15) {
LABEL_28:
      }
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      uint64_t v25 = *(v16 - 1);
      if (v25) {
        (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t, uint64_t, void))(*(void *)a1 + 56))(a1, v24, v25, *v16);
      }
      ++v15;
      mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v35);
      v16 += 2;
      if (v15 >= v17) {
        goto LABEL_16;
      }
    }
LABEL_32:
    __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
  }
LABEL_16:
  mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v35);
  if (v26)
  {
    uint64_t v27 = 0;
    uint64_t v28 = 24;
    do
    {
      uint64_t v30 = *(void *)(*((void *)a1 + 1) + 248);
      if ((*(unsigned char *)(v30 + 46) & 0x80) == 0) {
        __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
      }
      if (*(_DWORD *)(v30 + 68) <= v27) {
        goto LABEL_32;
      }
      if (a7 == v27) {
        goto LABEL_28;
      }
      if (*(void *)(a6 + 8 * v27)) {
        (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, void))(*(void *)a1 + 32))(a1, *(void *)(*(void *)(v30 + 72) + v28));
      }
      ++v27;
      mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v35);
      v28 += 32;
    }
    while (v27 != v29);
  }
  uint64_t v31 = *((unsigned int *)a1 + 18);
  if (v31)
  {
    uint64_t v32 = (GPU::BaseOpHandler **)*((void *)a1 + 8);
    uint64_t v33 = 8 * v31;
    do
    {
      uint64_t v34 = *v32++;
      GPURegionRuntime::TIAndFoldHelper::runOnOp(a1, v34);
      v33 -= 8;
    }
    while (v33);
  }
}

void GPURegionRuntime::TIAndFoldHelper::runOnOp(GPURegionRuntime::TIAndFoldHelper *this, GPU::BaseOpHandler *a2)
{
  v165[6] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (mlir::Operation *)*((void *)a2 + 3);
  size_t v150 = v2;
  uint64_t v151 = a2;
  if (!v2) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v4 = llvm::DefaultDoCastIfPossible<mlir::mpsx::ReturnStitchedOp,mlir::Operation *,llvm::CastInfo<mlir::mpsx::ReturnStitchedOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v2);
  if (!v4)
  {
    unint64_t v163 = (mlir::mps **)llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v2);
    if (!v163 || (unint64_t v2 = v150, mlir::placement::RegionCall::getRegionType((mlir::Operation **)&v163)))
    {
      uint64_t v149 = 0;
      unint64_t v163 = (mlir::mps **)&v149;
      uint64_t v164 = (uint64_t)this;
      v165[0] = &v150;
      v165[1] = &v151;
      unint64_t v8 = *((unsigned int *)v2 + 9);
      unint64_t v156 = v158;
      uint64_t v157 = 0x100000000;
      if (v8)
      {
        uint64_t v9 = 0;
        if (v8 != 1)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v156, v158, v8, 8);
          uint64_t v9 = v157;
        }
        if (v8 != v9) {
          bzero((char *)v156 + 8 * v9, 8 * (v8 - v9));
        }
        if (HIDWORD(v157) < v8) {
          __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
        }
        LODWORD(v157) = v8;
      }
      if (*((unsigned char *)v151 + 56))
      {
        unsigned int v159 = &v161;
        uint64_t v160 = 0x100000000;
        uint64_t v10 = v150;
        if (!*((_DWORD *)v150 + 9)) {
          goto LABEL_70;
        }
        unint64_t v11 = 0;
        uint64_t v12 = "DenseMap.h";
        uint64_t v13 = "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shou"
              "ldn't be inserted into map!\"";
        int v14 = "LookupBucketFor";
        while (1)
        {
          unint64_t v15 = (char *)v10 + 16 * ~v11;
          uint64_t v16 = (uint64_t)v10 + 24 * (5 - v11) - 96;
          if (v11 >= 6) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = (uint64_t)v15;
          }
          if (isStaticMPSType((uint64_t **)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8)))
          {
            if (v11 >= v157) {
              __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
            }
            unint64_t v18 = *(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8;
            goto LABEL_19;
          }
          uint64_t v19 = *((void *)this + 2);
          uint64_t v20 = *((unsigned int *)this + 8);
          if (!v20) {
            goto LABEL_39;
          }
          if ((v17 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            int v28 = 651;
            goto LABEL_212;
          }
          LODWORD(v21) = (v20 - 1) & ((v17 >> 4) ^ (v17 >> 9));
          uint64_t v22 = (uint64_t *)(v19 + 16 * v21);
          uint64_t v23 = *v22;
          if (*v22 == v17)
          {
            uint64_t v24 = (uint64_t *)(v19 + 16 * v20);
            if (v22 == v24) {
              goto LABEL_39;
            }
          }
          else
          {
            int v25 = 1;
            do
            {
              if (v23 == -4096) {
                goto LABEL_39;
              }
              int v26 = v21 + v25++;
              uint64_t v21 = v26 & (v20 - 1);
              uint64_t v23 = *(void *)(v19 + 16 * v21);
            }
            while (v23 != v17);
            uint64_t v22 = (uint64_t *)(v19 + 16 * v21);
            uint64_t v24 = (uint64_t *)(v19 + 16 * v20);
            if (v22 == v24) {
              goto LABEL_39;
            }
          }
          if (v22 == v24)
          {
            int v28 = 1270;
            int v14 = "operator->";
            uint64_t v13 = "Ptr != End && \"dereferencing end() iterator\"";
            goto LABEL_212;
          }
          unint64_t v18 = v22[1];
          if (v18)
          {
            if (v11 >= v157)
            {
              int v28 = 294;
              int v14 = "operator[]";
              uint64_t v12 = "SmallVector.h";
              uint64_t v13 = "idx < size()";
LABEL_212:
              __assert_rtn(v14, v12, v28, v13);
            }
LABEL_19:
            *((void *)v156 + v11++) = v18;
            uint64_t v10 = v150;
            if (v11 >= *((unsigned int *)v150 + 9)) {
              goto LABEL_57;
            }
          }
          else
          {
LABEL_39:
            if (v160 >= (unint64_t)HIDWORD(v160))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v159, &v161, v160 + 1, 4);
              *((_DWORD *)v159 + v160) = v11;
              int v27 = v160;
              if (v160 >= HIDWORD(v160))
              {
LABEL_44:
                int v28 = 102;
                int v14 = "set_size";
                uint64_t v12 = "SmallVector.h";
                uint64_t v13 = "N <= capacity()";
                goto LABEL_212;
              }
            }
            else
            {
              *((_DWORD *)v159 + v160) = v11;
              int v27 = v160;
              if (v160 >= HIDWORD(v160)) {
                goto LABEL_44;
              }
            }
            LODWORD(v160) = v27 + 1;
            ++v11;
            uint64_t v10 = v150;
            if (v11 >= *((unsigned int *)v150 + 9))
            {
LABEL_57:
              if (v160)
              {
                uint64_t v38 = GPURegionRuntime::TIAndFoldHelper::runOnOp(GPU::BaseOpHandler *)::$_0::operator()(&v163);
                if (v160)
                {
                  uint64_t v39 = v38;
                  uint64_t v40 = (unsigned int *)v159;
                  id v41 = (char *)v38 - 96;
                  uint64_t v42 = 4 * v160;
                  do
                  {
                    uint64_t v43 = *v40;
                    if (*((_DWORD *)v150 + 9) <= v43) {
                      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                    }
                    unsigned int v44 = *((_DWORD *)v39 + 9);
                    if (v43 > 5)
                    {
                      if (v44 <= v43) {
LABEL_204:
                      }
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      uint64_t v46 = (char *)v150 - 24 * (v43 - 5) - 96;
                      uint64_t v47 = &v41[-24 * (v43 - 5)];
                    }
                    else
                    {
                      if (v44 <= v43) {
                        goto LABEL_204;
                      }
                      uint64_t v45 = 16 * v43 + 16;
                      uint64_t v46 = (char *)v150 - v45;
                      uint64_t v47 = (char *)v39 - v45;
                    }
                    if (v157 <= v43) {
                      __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
                    }
                    __int16 v48 = (uint64_t **)(*((void *)v47 + 1) & 0xFFFFFFFFFFFFFFF8);
                    *((void *)v156 + v43) = v48;
                    if (isStaticMPSType(v48)) {
                      (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, char *, uint64_t **))(*(void *)this + 32))(this, v46, v48);
                    }
                    ++v40;
                    v42 -= 4;
                  }
                  while (v42);
                }
              }
LABEL_70:
              uint64_t v49 = v159;
              if (v159 != &v161) {
LABEL_71:
              }
                free(v49);
LABEL_72:
              if (!v150) {
                __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
              }
              uint64_t v148 = llvm::DefaultDoCastIfPossible<mlir::mps::IdentityOp,mlir::Operation *,llvm::CastInfo<mlir::mps::IdentityOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v150);
              if (v148)
              {
                uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v148);
                uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v148);
                uint64_t v53 = (*(uint64_t (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 64))(this, Input);
                if (v53) {
                  (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t, uint64_t, uint64_t))(*(void *)this + 56))(this, Result, v53, v52);
                }
              }
              else if (*((unsigned char *)v151 + 57))
              {
                if (v157)
                {
                  uint64_t v63 = (uint64_t ***)v156;
                  uint64_t v64 = 8 * v157;
                  while (GPURegionRuntime::isSmallIntType(*((void *)this + 1), *v63, 0))
                  {
                    ++v63;
                    v64 -= 8;
                    if (!v64) {
                      goto LABEL_87;
                    }
                  }
                }
                else
                {
LABEL_87:
                  unint64_t v65 = GPURegionRuntime::TIAndFoldHelper::runOnOp(GPU::BaseOpHandler *)::$_0::operator()(&v163);
                  unsigned int v159 = &v161;
                  uint64_t v160 = 0x100000000;
                  if (mlir::Operation::fold((uint64_t)v65, (uint64_t)&v159))
                  {
                    unint64_t v66 = v160;
                    if (v160)
                    {
                      unint64_t v67 = 0;
                      uint64_t v68 = -16;
                      uint64_t v69 = 24;
                      uint64_t v70 = "Casting.h";
                      long long v71 = "cast";
                      do
                      {
                        if (v67 >= *((unsigned int *)v150 + 9)) {
                          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                        }
                        if (v67 >= 6) {
                          uint64_t v72 = (char *)v150 + v69;
                        }
                        else {
                          uint64_t v72 = (char *)v150 + v68;
                        }
                        uint64_t v73 = *((void *)v159 + v67);
                        if ((v73 & 4) == 0)
                        {
                          uint64_t v74 = (uint64_t **)(v73 & 0xFFFFFFFFFFFFFFF8);
                          if ((v73 & 0xFFFFFFFFFFFFFFF8) != 0)
                          {
                            if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor((uint64_t **)(v73 & 0xFFFFFFFFFFFFFFF8)))
                            {
                              int v134 = 566;
                              uint64_t v135 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                              goto LABEL_216;
                            }
                            uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v74);
                            if (!InterfaceFor)
                            {
                              int v134 = 98;
                              long long v71 = "Interface";
                              uint64_t v70 = "InterfaceSupport.h";
                              uint64_t v135 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
                              goto LABEL_216;
                            }
                            unint64_t v153 = v74;
                            uint64_t v154 = InterfaceFor;
                            Type = (llvm *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v153);
                            if (v67 >= v157) {
                              __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
                            }
                            if (*((llvm **)v156 + v67) != Type)
                            {
                              int16x4_t v140 = (llvm::raw_ostream *)llvm::errs(Type);
                              uint64_t v141 = llvm::raw_ostream::operator<<(v140, "folder failure for: ");
                              unint64_t v142 = mlir::operator<<(v141, v150);
                              unint64_t v143 = llvm::raw_ostream::operator<<(v142, ":\n");
                              uint64_t v144 = (llvm::raw_ostream *)llvm::errs(v143);
                              if (v157 <= v67)
                              {
                                uint64_t v135 = "idx < size()";
                                int v134 = 294;
                                uint64_t v70 = "SmallVector.h";
                                long long v71 = "operator[]";
                              }
                              else
                              {
                                uint64_t v146 = v145;
                                v152[0] = *((void *)v156 + v67);
                                mlir::Type::print((llvm::raw_ostream *)v152, v145);
                                v152[0] = (uint64_t)v153;
                                mlir::Attribute::print((mlir::Attribute *)v152, v147, 0);
                                llvm::raw_ostream::operator<<(v147, "\n");
                                uint64_t v135 = "0 && \"folder type doesn't match expected type\"";
                                int v134 = 2076;
                                uint64_t v70 = "MPSRuntime.mm";
                                long long v71 = "runOnOp";
                              }
LABEL_216:
                              __assert_rtn(v71, v70, v134, v135);
                            }
                            (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, char *, uint64_t **, uint64_t))(*(void *)this + 56))(this, v72, v153, v154);
                            unint64_t v66 = v160;
                          }
                        }
                        ++v67;
                        v68 -= 16;
                        v69 -= 24;
                      }
                      while (v67 < v66);
                    }
                  }
                  if (v159 != &v161) {
                    free(v159);
                  }
                }
              }
              unint64_t v82 = (mlir::mps **)v156;
              if (v156 != v158) {
LABEL_116:
              }
                free(v82);
              return;
            }
          }
        }
      }
      uint64_t v54 = *((unsigned int *)v150 + 9);
      unint64_t v55 = (char *)v150 - 16;
      if (!v54) {
        unint64_t v55 = 0;
      }
      v152[0] = (uint64_t)v55;
      v152[1] = v54;
      mlir::OperandRange::getTypes(v152, (uint64_t *)&v159);
      unint64_t v153 = (uint64_t **)&v155;
      uint64_t v154 = 0x100000000;
      uint64_t v56 = v159;
      if (v161 != v159)
      {
        uint64_t v136 = "base == rhs.base && \"incompatible iterators\"";
        int v137 = 1202;
        float v138 = "STLExtras.h";
        int16x4_t v139 = "operator-";
        goto LABEL_222;
      }
      uint64_t v57 = v160;
      uint64_t v58 = v162;
      uint64_t v59 = v162 - v160;
      if ((unint64_t)(v162 - v160) < 2)
      {
        unsigned int v60 = 0;
        uint64_t v62 = 0;
        uint64_t v61 = (uint64_t **)&v155;
        if (v162 == v160)
        {
LABEL_110:
          unint64_t v81 = v59 + v60;
          if (v81 <= HIDWORD(v154))
          {
            LODWORD(v154) = v81;
            llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v156, (uint64_t)&v153);
            uint64_t v49 = v153;
            if (v153 != (uint64_t **)&v155) {
              goto LABEL_71;
            }
            goto LABEL_72;
          }
          uint64_t v136 = "N <= capacity()";
          int v137 = 102;
          float v138 = "SmallVector.h";
          int16x4_t v139 = "set_size";
LABEL_222:
          __assert_rtn(v139, v138, v137, v136);
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v153, &v155, v162 - v160, 8);
        unsigned int v60 = v154;
        uint64_t v61 = v153;
        uint64_t v62 = v154;
        if (v58 == v57) {
          goto LABEL_110;
        }
      }
      uint64_t v80 = (unint64_t *)&v61[v62];
      do
        *v80++ = *(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v56, v57++) + 8) & 0xFFFFFFFFFFFFFFF8;
      while (v58 != v57);
      unsigned int v60 = v154;
      goto LABEL_110;
    }
    int v77 = *((_DWORD *)v150 + 11);
    if ((v77 & 0x800000) != 0)
    {
      unint64_t v78 = *((unsigned int *)v150 + 17);
      unint64_t v163 = (mlir::mps **)v165;
      uint64_t v164 = 0x600000000;
      if (v78)
      {
        if (v78 < 7)
        {
          uint64_t v79 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v163, v165, v78, 8);
          uint64_t v79 = v164;
        }
        if (v78 != v79) {
          bzero(&v163[v79], 8 * (v78 - v79));
        }
        if (HIDWORD(v164) < v78) {
          __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
        }
        LODWORD(v164) = v78;
        unint64_t v2 = v150;
        int v77 = *((_DWORD *)v150 + 11);
      }
      if ((v77 & 0x800000) != 0)
      {
        unint64_t v83 = *((unsigned int *)v2 + 17);
        unsigned int v159 = &v161;
        uint64_t v160 = 0x300000000;
        if (v83)
        {
          if (v83 < 4)
          {
            uint64_t v84 = 0;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v159, &v161, v83, 16);
            uint64_t v84 = v160;
          }
          if (v83 != v84) {
            bzero((char *)v159 + 16 * v84, 16 * (v83 - v84));
          }
          if (HIDWORD(v160) < v83) {
            __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
          }
          LODWORD(v160) = v83;
          unint64_t v2 = v150;
        }
        goto LABEL_132;
      }
    }
    else
    {
      unint64_t v163 = (mlir::mps **)v165;
      uint64_t v164 = 0x600000000;
    }
    unsigned int v159 = &v161;
    uint64_t v160 = 0x300000000;
LABEL_132:
    unint64_t v85 = *((unsigned int *)v2 + 9);
    unint64_t v156 = v158;
    uint64_t v157 = 0x600000000;
    if (v85)
    {
      if (v85 < 7)
      {
        uint64_t v86 = 0;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v156, v158, v85, 8);
        uint64_t v86 = v157;
      }
      if (v85 != v86) {
        bzero((char *)v156 + 8 * v86, 8 * (v85 - v86));
      }
      if (HIDWORD(v157) < v85) {
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
      }
      LODWORD(v157) = v85;
      unint64_t v2 = v150;
    }
    if ((*((unsigned char *)v2 + 46) & 0x80) != 0)
    {
      uint64_t v87 = 0;
      unint64_t v88 = 0;
      uint64_t v89 = 24;
      do
      {
        if (v88 >= *((unsigned int *)v2 + 17)) {
          break;
        }
        uint64_t v90 = *(void *)(*((void *)v2 + 9) + v89);
        uint64_t v91 = (mlir::mps *)(*(uint64_t (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 40))(this, v90);
        if (v91)
        {
          if (v88 >= v164) {
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          v163[v88] = v91;
        }
        uint64_t v92 = (*(uint64_t (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 64))(this, v90);
        if (v92)
        {
          if (v88 >= v160) {
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          BOOL v94 = (uint64_t *)((char *)v159 + v87);
          *BOOL v94 = v92;
          v94[1] = v93;
        }
        ++v88;
        unint64_t v2 = v150;
        v87 += 16;
        v89 += 32;
      }
      while ((*((unsigned char *)v150 + 46) & 0x80) != 0);
    }
    if (!*((_DWORD *)v2 + 9))
    {
LABEL_170:
      uint64_t v110 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(*((void *)this + 1) + 264), (uint64_t *)&v150);
      if (!v110) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v111 = *(void *)(*(void *)(v110[3] + 120) + 176);
      (*(void (**)(void, mlir::mps **, void, void *, void, void *, void))(**(void **)(v111 + 448)
                                                                                           + 16))(*(void *)(v111 + 448), v163, v164, v159, v160, v156, v157);
      uint64_t v112 = v150;
      if (!*((_DWORD *)v150 + 9))
      {
LABEL_185:
        if (v156 != v158) {
          free(v156);
        }
        if (v159 != &v161) {
          free(v159);
        }
        unint64_t v82 = v163;
        if (v163 != v165) {
          goto LABEL_116;
        }
        return;
      }
      unint64_t v113 = 0;
      uint64_t v114 = -16;
      uint64_t v115 = 24;
      uint64_t v116 = 24;
      while (1)
      {
        int v117 = (char *)v112 + v114;
        unint64_t v118 = (char *)v112 + v115;
        uint64_t v119 = v113 >= 6 ? v118 : v117;
        uint64_t v120 = *(void *)(v111 + 248);
        if ((*(unsigned char *)(v120 + 46) & 0x80) == 0) {
          break;
        }
        if (v113 >= *(unsigned int *)(v120 + 68))
        {
          int v126 = 443;
          float v129 = "operator[]";
          int64_t v128 = "ArrayRef.h";
          uint64_t v127 = "Index < this->size() && \"Invalid index!\"";
LABEL_199:
          __assert_rtn(v129, v128, v126, v127);
        }
        uint64_t v121 = (*(uint64_t (**)(void, void))(**(void **)(v111 + 448) + 40))(*(void *)(v111 + 448), *(void *)(*(void *)(v120 + 72) + v116));
        if (v121) {
          (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, char *, uint64_t))(*(void *)this + 32))(this, v119, v121);
        }
        uint64_t v122 = *(void *)(v111 + 248);
        if ((*(unsigned char *)(v122 + 46) & 0x80) == 0)
        {
          int v130 = 960;
          id v131 = "hasOperandStorage && \"expected operation to have operand storage\"";
          uint64_t v132 = "Operation.h";
          int8x8_t v133 = "getOperandStorage";
          goto LABEL_202;
        }
        if (v113 >= *(unsigned int *)(v122 + 68))
        {
          int v130 = 443;
          int8x8_t v133 = "operator[]";
          uint64_t v132 = "ArrayRef.h";
          id v131 = "Index < this->size() && \"Invalid index!\"";
LABEL_202:
          __assert_rtn(v133, v132, v130, v131);
        }
        uint64_t v124 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(v111 + 448) + 64))(*(void *)(v111 + 448), *(void *)(*(void *)(v122 + 72) + v116), v121);
        if (v124) {
          (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, char *, uint64_t, uint64_t))(*(void *)this + 56))(this, v119, v124, v123);
        }
        ++v113;
        uint64_t v112 = v150;
        v116 += 32;
        v115 -= 24;
        v114 -= 16;
        if (v113 >= *((unsigned int *)v150 + 9)) {
          goto LABEL_185;
        }
      }
      int v126 = 960;
      uint64_t v127 = "hasOperandStorage && \"expected operation to have operand storage\"";
      int64_t v128 = "Operation.h";
      float v129 = "getOperandStorage";
      goto LABEL_199;
    }
    unint64_t v95 = 0;
    uint64_t v96 = *((unsigned int *)this + 8);
    unsigned int v97 = v96 - 1;
    unint64_t v98 = v157;
    uint64_t v99 = "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn'"
          "t be inserted into map!\"";
    id v100 = "LookupBucketFor";
    while (1)
    {
      uint64_t v101 = (uint64_t)v2 + 24 * (5 - v95) - 96;
      if (v95 < 6) {
        uint64_t v101 = (uint64_t)v2 + 16 * ~v95;
      }
      uint64_t v102 = *((void *)this + 2);
      if (!v96) {
        goto LABEL_152;
      }
      if ((v101 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        int v125 = 651;
        goto LABEL_208;
      }
      LODWORD(v103) = ((v101 >> 4) ^ (v101 >> 9)) & v97;
      BOOL v104 = (uint64_t *)(v102 + 16 * v103);
      uint64_t v105 = *v104;
      if (*v104 == v101)
      {
        uint64_t v106 = (uint64_t *)(v102 + 16 * v96);
        if (v104 == v106) {
          goto LABEL_152;
        }
      }
      else
      {
        int v107 = 1;
        do
        {
          if (v105 == -4096) {
            goto LABEL_152;
          }
          int v108 = v103 + v107++;
          uint64_t v103 = v108 & v97;
          uint64_t v105 = *(void *)(v102 + 16 * v103);
        }
        while (v105 != v101);
        BOOL v104 = (uint64_t *)(v102 + 16 * v103);
        uint64_t v106 = (uint64_t *)(v102 + 16 * v96);
        if (v104 == v106) {
          goto LABEL_152;
        }
      }
      if (v104 == v106)
      {
        int v125 = 1270;
        id v100 = "operator->";
        uint64_t v99 = "Ptr != End && \"dereferencing end() iterator\"";
LABEL_208:
        __assert_rtn(v100, "DenseMap.h", v125, v99);
      }
      uint64_t v109 = v104[1];
      if (v109)
      {
        if (v95 >= v98) {
          __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
        }
        *((void *)v156 + v95) = v109;
        unint64_t v2 = v150;
      }
LABEL_152:
      if (++v95 >= *((unsigned int *)v2 + 9)) {
        goto LABEL_170;
      }
    }
  }
  uint64_t v5 = v4;
  uint64_t v6 = *(mlir::Block **)(v4 + 16);
  if (v6)
  {
    uint64_t ParentOp = mlir::Block::getParentOp(v6);
    if ((*(unsigned char *)(v5 + 46) & 0x80) == 0) {
      return;
    }
  }
  else
  {
    uint64_t ParentOp = 0;
    if ((*(unsigned char *)(v5 + 46) & 0x80) == 0) {
      return;
    }
  }
  unint64_t v29 = 0;
  uint64_t v30 = ParentOp - 16;
  uint64_t v31 = ParentOp + 24;
  uint64_t v32 = 24;
  do
  {
    if (v29 >= *(unsigned int *)(v5 + 68)) {
      break;
    }
    if (v29 >= *(unsigned int *)(ParentOp + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v33 = *(void *)(*(void *)(v5 + 72) + v32);
    if (v29 >= 6) {
      uint64_t v34 = v31;
    }
    else {
      uint64_t v34 = v30;
    }
    uint64_t v35 = (*(uint64_t (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 40))(this, v33);
    if (v35) {
      (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t, uint64_t))(*(void *)this + 32))(this, v34, v35);
    }
    uint64_t v36 = (*(uint64_t (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t))(*(void *)this + 64))(this, v33);
    if (v36) {
      (*(void (**)(GPURegionRuntime::TIAndFoldHelper *, uint64_t, uint64_t, uint64_t))(*(void *)this + 56))(this, v34, v36, v37);
    }
    ++v29;
    v30 -= 16;
    v31 -= 24;
    v32 += 32;
  }
  while ((*(unsigned char *)(v5 + 46) & 0x80) != 0);
}

void sub_180D0C8A8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_180D0C8C0()
{
}

void sub_180D0C8CC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_180D0C8E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a19 == v28)
  {
    uint64_t v32 = a27;
    if (a27 == v27) {
      goto LABEL_3;
    }
  }
  else
  {
    free(a19);
    uint64_t v32 = a27;
    if (a27 == v27)
    {
LABEL_3:
      if (*(void *)(v30 - 176) == v29) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  free(v32);
  if (*(void *)(v30 - 176) == v29) {
LABEL_4:
  }
    _Unwind_Resume(a1);
LABEL_7:
  JUMPOUT(0x180D0CA0CLL);
}

void sub_180D0C8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a27 == v27) {
    JUMPOUT(0x180D0C9B4);
  }
  JUMPOUT(0x180D0C9D8);
}

void sub_180D0C914(_Unwind_Exception *a1)
{
  if (*(void *)(v2 - 176) == v1) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180D0CA0CLL);
}

void sub_180D0C928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19 == v19) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180D0CA0CLL);
}

void sub_180D0C93C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16 != v16) {
    JUMPOUT(0x180D0C9FCLL);
  }
  JUMPOUT(0x180D0CA00);
}

void sub_180D0C950()
{
}

void sub_180D0C964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a27 != v27) {
    JUMPOUT(0x180D0C9FCLL);
  }
  JUMPOUT(0x180D0CA00);
}

void sub_180D0C9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27 != v28) {
    free(a27);
  }
  if (a19 != v27)
  {
    free(a19);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GPURegionRuntime::TIAndFoldHelper::getType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 32);
  if (!v3) {
    return 0;
  }
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
  uint64_t v6 = *v5;
  if (*v5 != a2)
  {
    int v9 = 1;
    while (v6 != -4096)
    {
      int v10 = v4 + v9++;
      uint64_t v4 = v10 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
        unint64_t v7 = (uint64_t *)(v2 + 16 * v3);
        if (v5 != v7) {
          goto LABEL_5;
        }
        return 0;
      }
    }
    return 0;
  }
  unint64_t v7 = (uint64_t *)(v2 + 16 * v3);
  if (v5 == v7) {
    return 0;
  }
LABEL_5:
  if (v5 == v7) {
    __assert_rtn("operator->", "DenseMap.h", 1270, "Ptr != End && \"dereferencing end() iterator\"");
  }
  return v5[1];
}

mlir::mps *GPURegionRuntime::TIAndFoldHelper::runOnOp(GPU::BaseOpHandler *)::$_0::operator()(mlir::mps ***a1)
{
  v37[4] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = **a1;
  if (!v1)
  {
    uint64_t v3 = a1[1];
    v3[27] = 0;
    v3[34] = 0;
    uint64_t v35 = v37;
    uint64_t v36 = 0x400000000;
    uint64_t v4 = (uint64_t)*a1[2];
    if ((*(unsigned char *)(v4 + 46) & 0x80) != 0)
    {
      unsigned int v5 = *(_DWORD *)(v4 + 68);
      if (v5)
      {
        unint64_t v6 = 0;
        uint64_t v7 = 24;
        while (1)
        {
          v32[0] = *(void *)(*(void *)(v4 + 72) + v7);
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v32);
          if (!DefiningOp) {
            break;
          }
          uint64_t v31 = llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible(DefiningOp);
          if (!v31) {
            goto LABEL_9;
          }
          uint64_t Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v31);
          uint64_t EncodeTimeConstantOperand = GPURegionRuntime::TIAndFoldHelper::getEncodeTimeConstantOperand((uint64_t)v3, Value, v10);
LABEL_14:
          uint64_t v15 = EncodeTimeConstantOperand;
          if (v36 >= (unint64_t)HIDWORD(v36))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v37, v36 + 1, 8);
            *((void *)v35 + v36) = v15;
            int v16 = v36;
            if (v36 >= HIDWORD(v36)) {
LABEL_20:
            }
              __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
          }
          else
          {
            *((void *)v35 + v36) = EncodeTimeConstantOperand;
            int v16 = v36;
            if (v36 >= HIDWORD(v36)) {
              goto LABEL_20;
            }
          }
          unsigned int v5 = v16 + 1;
          LODWORD(v36) = v5;
          uint64_t v4 = (uint64_t)*a1[2];
          if ((*(unsigned char *)(v4 + 46) & 0x80) != 0)
          {
            ++v6;
            v7 += 32;
            if (v6 < *(unsigned int *)(v4 + 68)) {
              continue;
            }
          }
          goto LABEL_21;
        }
        uint64_t v31 = 0;
LABEL_9:
        uint64_t v13 = (void *)(*((uint64_t (**)(mlir::mps **, void))*v3 + 8))(v3, v32[0]);
        if (v13)
        {
          uint64_t EncodeTimeConstantOperand = GPURegionRuntime::TIAndFoldHelper::getEncodeTimeConstantOperand((uint64_t)v3, v13, v12);
        }
        else
        {
          int v14 = (mlir::MLIRContext *)(*((uint64_t (**)(mlir::mps **, void))*v3 + 5))(v3, v32[0]);
          if (v14) {
            uint64_t EncodeTimeConstantOperand = GPURegionRuntime::TIAndFoldHelper::getEncodeTimePlaceholderOperand((uint64_t)v3, v14);
          }
          else {
            uint64_t EncodeTimeConstantOperand = GPURegionRuntime::TIAndFoldHelper::getEncodeTimePlaceholderOperand((uint64_t)v3, (mlir::MLIRContext *)(*(void *)(v32[0] + 8) & 0xFFFFFFFFFFFFFFF8));
          }
        }
        goto LABEL_14;
      }
LABEL_21:
      uint64_t v17 = v35;
    }
    else
    {
      unsigned int v5 = 0;
      uint64_t v17 = v37;
    }
    uint64_t v18 = (uint64_t)*a1[3];
    mlir::ValueRange::ValueRange((unint64_t *)&v33, (uint64_t)v17, v5);
    uint64_t v20 = *(uint64_t **)(v18 + 72);
    if (!v20)
    {
      EncodeTimeTmpIRBuilder = (uint64_t **)GPURegionRuntime::TIAndFoldHelper::getEncodeTimeTmpIRBuilder(*(GPURegionRuntime::TIAndFoldHelper **)(*(void *)(v18 + 16) + 448), v19);
      mlir::OpBuilder::clone(EncodeTimeTmpIRBuilder, *(mlir::Operation **)(v18 + 24));
    }
    mlir::Operation::setOperands(v20, v33, v34);
    **a1 = *(mlir::mps **)(v18 + 72);
    uint64_t v23 = (llvm *)mlir::mps::inferTypes(**a1, v22);
    if (!(_BYTE)v23)
    {
      uint64_t v24 = (llvm::raw_ostream *)llvm::errs(v23);
      int v25 = v24;
      int v26 = (void *)*((void *)v24 + 4);
      if (*((void *)v24 + 3) - (void)v26 > 0xEuLL)
      {
        *((void *)v24 + 4) += 15;
      }
      else
      {
      }
      uint64_t v27 = **a1;
      mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v32);
      int v28 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope((uint64_t)v32);
      mlir::Operation::print(v27, v25, v28);
      uint64_t v29 = *((void *)v25 + 4);
      if ((unint64_t)(*((void *)v25 + 3) - v29) > 2)
      {
        *(unsigned char *)(v29 + 2) = 10;
        *(_WORD *)uint64_t v29 = 11872;
        *((void *)v25 + 4) += 3;
      }
      else
      {
      }
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
    }
    if ((*((unsigned char *)v3[1] + 220) & 0x80) != 0) {
      mlir::verify(**a1, (mlir::Operation *)1);
    }
    uint64_t v1 = **a1;
    if (v35 != v37) {
      free(v35);
    }
  }
  return v1;
}

void sub_180D0CFFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  if (a18 != v18) {
    free(a18);
  }
  _Unwind_Resume(exception_object);
}

mlir::UnknownLoc **GPURegionRuntime::TIAndFoldHelper::getEncodeTimeTmpIRBuilder(GPURegionRuntime::TIAndFoldHelper *this, mlir::MLIRContext *a2)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (mlir::Operation **)((char *)this + 128);
  uint64_t v3 = (mlir::UnknownLoc **)((char *)this + 136);
  if (!*((void *)this + 16))
  {
    unsigned int v5 = *v3;
    uint64_t v6 = mlir::UnknownLoc::get(*v3, a2);
    if (!v6) {
      __assert_rtn("Location", "Location.h", 66, "loc && \"location should never be null.\"");
    }
    uint64_t v7 = v6;
    mlir::ValueRange::ValueRange(v21, 0, 0);
    mlir::ValueRange::ValueRange(v20, 0, 0);
    uint64_t v8 = mlir::FunctionType::get(v5, v21[0], v21[1], v20[0], v20[1]);
    uint64_t v9 = mlir::func::FuncOp::create(v7, (uint64_t)"pre_encode_ti_tmp", 17, v8, 0, 0);
    if (*v2) {
      mlir::Operation::erase(*v2);
    }
    *uint64_t v2 = (mlir::Operation *)v9;
    mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::addEntryBlock((mlir::func::FuncOp *)v2);
    int v10 = *v2;
    unint64_t v11 = *((unsigned int *)*v2 + 11);
    if ((v11 & 0x7FFFFF) == 0) {
      __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
    }
    unint64_t v12 = (unint64_t)v10 + 16 * ((v11 >> 23) & 1) + ((v11 >> 21) & 0x7F8) + 64;
    if (v12 >= 0xFFFFFFFFFFFFFFF9) {
      __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
    }
    uint64_t v13 = *(void *)(((v12 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *((unsigned int *)v10 + 10) + 8);
    if (v13) {
      uint64_t v14 = v13 - 8;
    }
    else {
      uint64_t v14 = 0;
    }
    *((void *)this + 20) = *(void *)(v14 + 40);
    uint64_t v15 = (void *)((char *)this + 160);
    *(v15 - 1) = v14;
    int v16 = (mlir::GenericProgramPoint *)mlir::OpBuilder::create<mlir::func::ReturnOp>((mlir::func::ReturnOp *)v3, *((void *)v10 + 3));
    uint64_t v17 = *((void *)v16 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(v16);
    *(v15 - 1) = v17;
    *uint64_t v15 = v18;
  }
  return v3;
}

void sub_180D0D258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, mlir::Operation *a9)
{
}

uint64_t mlir::OpBuilder::create<mlir::func::ReturnOp>(mlir::func::ReturnOp *a1, uint64_t a2)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  uint64_t v5 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.return", (const unsigned __int8 *)0xB, Context);
  if (!v6)
  {
    __int16 v19 = 1283;
    v18[2] = (uint64_t)"func.return";
    v18[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v5);
  mlir::func::ReturnOp::build(a1, (mlir::OpBuilder *)v21, v7);
  uint64_t v8 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (!v8)
  {
    unint64_t v11 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v12 = 662;
    uint64_t v13 = "Casting.h";
    uint64_t v14 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v9 = llvm::DefaultDoCastIfPossible<mlir::func::ReturnOp,mlir::Operation *,llvm::CastInfo<mlir::func::ReturnOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v8);
  if (!v9)
  {
    unint64_t v11 = "result && \"builder didn't return the right type\"";
    int v12 = 497;
    uint64_t v13 = "Builders.h";
    uint64_t v14 = "create";
LABEL_8:
    __assert_rtn(v14, v13, v12, v11);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v9;
}

void sub_180D0D3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D0D3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t GPURegionRuntime::TIAndFoldHelper::getEncodeTimePlaceholderOperand(uint64_t a1, mlir::MLIRContext *a2)
{
  __int16 v19 = a2;
  uint64_t v3 = (void *)(a1 + 168);
  if (*(void *)(a1 + 216) != *(_DWORD *)(a1 + 176))
  {
LABEL_12:
    unint64_t v16 = *(void *)(a1 + 216);
    *(void *)(a1 + 216) = v16 + 1;
    if (v16 < *(unsigned int *)(a1 + 176)) {
      goto LABEL_13;
    }
LABEL_16:
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  EncodeTimeTmpIRBuilder = GPURegionRuntime::TIAndFoldHelper::getEncodeTimeTmpIRBuilder((GPURegionRuntime::TIAndFoldHelper *)a1, a2);
  uint64_t v5 = *(void *)(a1 + 128);
  unint64_t v6 = *(unsigned int *)(v5 + 44);
  if ((v6 & 0x7FFFFF) == 0) {
    __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
  }
  unint64_t v7 = v5 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 64;
  if (v7 >= 0xFFFFFFFFFFFFFFF9) {
    __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
  }
  uint64_t v8 = EncodeTimeTmpIRBuilder + 2;
  long long v18 = *((_OWORD *)EncodeTimeTmpIRBuilder + 1);
  uint64_t v9 = *(void *)(((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v5 + 40) + 8);
  if (v9) {
    int v10 = (mlir::UnknownLoc *)(v9 - 8);
  }
  else {
    int v10 = 0;
  }
  unint64_t v11 = (mlir::UnknownLoc *)*((void *)v10 + 5);
  EncodeTimeTmpIRBuilder[2] = v10;
  EncodeTimeTmpIRBuilder[3] = v11;
  uint64_t v12 = mlir::OpBuilder::create<mlir::mps::PlaceholderOp,mlir::Type &>((mlir::OpBuilder *)EncodeTimeTmpIRBuilder, *(void *)(*(void *)(a1 + 128) + 24), (uint64_t *)&v19);
  if (!*(_DWORD *)(v12 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v13 = v12 - 16;
  uint64_t v14 = *(unsigned int *)(a1 + 176);
  if (v14 < *(_DWORD *)(a1 + 180))
  {
    *(void *)(*(void *)(a1 + 168) + 8 * v14) = v13;
    unsigned int v15 = *(_DWORD *)(a1 + 176);
    if (v15 < *(_DWORD *)(a1 + 180)) {
      goto LABEL_10;
    }
LABEL_22:
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v3, (void *)(a1 + 184), v14 + 1, 8);
  *(void *)(*(void *)(a1 + 168) + 8 * *(unsigned int *)(a1 + 176)) = v13;
  unsigned int v15 = *(_DWORD *)(a1 + 176);
  if (v15 >= *(_DWORD *)(a1 + 180)) {
    goto LABEL_22;
  }
LABEL_10:
  *(_DWORD *)(a1 + 176) = v15 + 1;
  if ((void)v18)
  {
    *(_OWORD *)uint64_t v8 = v18;
    goto LABEL_12;
  }
  mlir::GenericProgramPoint *v8 = 0;
  v8[1] = 0;
  unint64_t v16 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = v16 + 1;
  if (v16 >= *(unsigned int *)(a1 + 176)) {
    goto LABEL_16;
  }
LABEL_13:
  if ((v19 & 7) != 0) {
    __assert_rtn("updatePointer", "PointerIntPair.h", 203, "(PtrWord & ~PointerBitMask) == 0 && \"Pointer is not sufficiently aligned\"");
  }
  uint64_t result = *(void *)(*v3 + 8 * v16);
  *(void *)(result + 8) = *(void *)(result + 8) & 7 | (unint64_t)v19;
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::mps::PlaceholderOp,mlir::Type &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.placeholder", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.placeholder";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::PlaceholderOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    unsigned int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::PlaceholderOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PlaceholderOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    unsigned int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D0D7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D0D7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t GPURegionRuntime::TIAndFoldHelper::getEncodeTimeConstantOperand(uint64_t a1, void *a2, void *a3)
{
  v23[0] = a2;
  v23[1] = a3;
  uint64_t v4 = (void *)(a1 + 224);
  if (*(void *)(a1 + 272) != *(_DWORD *)(a1 + 232))
  {
LABEL_11:
    unint64_t v17 = *(void *)(a1 + 272);
    *(void *)(a1 + 272) = v17 + 1;
    if (v17 < *(unsigned int *)(a1 + 232)) {
      goto LABEL_12;
    }
LABEL_15:
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  EncodeTimeTmpIRBuilder = GPURegionRuntime::TIAndFoldHelper::getEncodeTimeTmpIRBuilder((GPURegionRuntime::TIAndFoldHelper *)a1, (mlir::MLIRContext *)a2);
  uint64_t v6 = *(void *)(a1 + 128);
  unint64_t v7 = *(unsigned int *)(v6 + 44);
  if ((v7 & 0x7FFFFF) == 0) {
    __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
  }
  unint64_t v8 = v6 + 16 * ((v7 >> 23) & 1) + ((v7 >> 21) & 0x7F8) + 64;
  if (v8 >= 0xFFFFFFFFFFFFFFF9) {
    __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
  }
  uint64_t v9 = EncodeTimeTmpIRBuilder + 2;
  long long v21 = *((_OWORD *)EncodeTimeTmpIRBuilder + 1);
  uint64_t v10 = *(void *)(((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v6 + 40) + 8);
  if (v10) {
    unint64_t v11 = (mlir::UnknownLoc *)(v10 - 8);
  }
  else {
    unint64_t v11 = 0;
  }
  uint64_t v12 = (mlir::UnknownLoc *)*((void *)v11 + 5);
  EncodeTimeTmpIRBuilder[2] = v11;
  EncodeTimeTmpIRBuilder[3] = v12;
  int v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)EncodeTimeTmpIRBuilder, *(void *)(*(void *)(a1 + 128) + 24), (uint64_t)v23);
  uint64_t v14 = v13;
  uint64_t v15 = *(unsigned int *)(a1 + 232);
  if (v15 < *(_DWORD *)(a1 + 236))
  {
    *(void *)(*(void *)(a1 + 224) + 8 * v15) = v13;
    unsigned int v16 = *(_DWORD *)(a1 + 232);
    if (v16 < *(_DWORD *)(a1 + 236)) {
      goto LABEL_9;
    }
LABEL_20:
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v4, (void *)(a1 + 240), v15 + 1, 8);
  *(void *)(*(void *)(a1 + 224) + 8 * *(unsigned int *)(a1 + 232)) = v14;
  unsigned int v16 = *(_DWORD *)(a1 + 232);
  if (v16 >= *(_DWORD *)(a1 + 236)) {
    goto LABEL_20;
  }
LABEL_9:
  *(_DWORD *)(a1 + 232) = v16 + 1;
  if ((void)v21)
  {
    *(_OWORD *)uint64_t v9 = v21;
    goto LABEL_11;
  }
  *uint64_t v9 = 0;
  v9[1] = 0;
  unint64_t v17 = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = v17 + 1;
  if (v17 >= *(unsigned int *)(a1 + 232)) {
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v22 = *(void *)(*v4 + 8 * v17);
  mlir::mps::ConstantOp::setValueAttr((uint64_t)&v22, v23[0]);
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v22);
  uint64_t Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)v23);
  if ((Type & 7) != 0) {
    __assert_rtn("updatePointer", "PointerIntPair.h", 203, "(PtrWord & ~PointerBitMask) == 0 && \"Pointer is not sufficiently aligned\"");
  }
  *(void *)(v18 + 8) = *(void *)(v18 + 8) & 7 | Type;
  return v18;
}

uint64_t GPURegionRuntime::TIAndFoldHelper::reset(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 24);
  if (!*(void *)(this + 24))
  {
LABEL_5:
    int v4 = *(_DWORD *)(v1 + 48);
    if (v4) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  this += 16;
  uint64_t v3 = *(unsigned int *)(v1 + 32);
  if (v3 > 4 * v2 && v3 >= 0x41)
  {
    this = llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::shrink_and_clear(this);
    goto LABEL_5;
  }
  if (v3)
  {
    uint64_t v5 = *(void **)this;
    uint64_t v6 = (v3 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      uint64_t v7 = v6 + 1;
      uint64_t v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v9 = &v5[2 * v8];
      uint64_t v10 = v5 + 2;
      uint64_t v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        *uint64_t v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v9 = *(void **)this;
    }
    uint64_t v12 = &v5[2 * v3];
    do
    {
      *uint64_t v9 = -4096;
      v9 += 2;
    }
    while (v9 != v12);
  }
LABEL_16:
  *(void *)(v1 + 24) = 0;
  int v4 = *(_DWORD *)(v1 + 48);
  if (v4) {
    goto LABEL_18;
  }
LABEL_17:
  if (!*(_DWORD *)(v1 + 52)) {
    return this;
  }
LABEL_18:
  this = v1 + 40;
  unsigned int v13 = *(_DWORD *)(v1 + 56);
  if (v13 <= 4 * v4 || v13 < 0x41)
  {
    if (v13)
    {
      uint64_t v14 = *(void **)this;
      unint64_t v15 = 24 * v13 - 24;
      if (v15 >= 0x18)
      {
        unint64_t v17 = v15 / 0x18 + 1;
        unsigned int v16 = &v14[3 * (v17 & 0x1FFFFFFFFFFFFFFELL)];
        uint64_t v18 = v17 & 0x1FFFFFFFFFFFFFFELL;
        __int16 v19 = *(void **)this;
        do
        {
          *__int16 v19 = -4096;
          v19[3] = -4096;
          v19 += 6;
          v18 -= 2;
        }
        while (v18);
        if (v17 == (v17 & 0x1FFFFFFFFFFFFFFELL)) {
          goto LABEL_31;
        }
      }
      else
      {
        unsigned int v16 = *(void **)this;
      }
      __int16 v20 = &v14[3 * v13];
      do
      {
        *unsigned int v16 = -4096;
        v16 += 3;
      }
      while (v16 != v20);
    }
LABEL_31:
    *(void *)(v1 + 48) = 0;
    return this;
  }

  return llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::shrink_and_clear(this);
}

BOOL GPURegionRuntime::TIAndFoldHelper::hasType(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 32);
  if (!v2) {
    return 0;
  }
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = v2 - 1;
  unsigned int v5 = v4 & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = *(void *)(v3 + 16 * v5);
  if (v6 == a2) {
    return 1;
  }
  int v8 = 1;
  do
  {
    BOOL result = v6 != -4096;
    if (v6 == -4096) {
      break;
    }
    unsigned int v9 = v5 + v8++;
    unsigned int v5 = v9 & v4;
    uint64_t v6 = *(void *)(v3 + 16 * v5);
  }
  while (v6 != a2);
  return result;
}

uint64_t *GPURegionRuntime::TIAndFoldHelper::setType(uint64_t a1, unint64_t a2, uint64_t **a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 440);
  if (!v6 || (uint64_t Set = mlir::ShapeEquivalence::getSet(v6, a2)) == 0)
  {
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v13 = a1 + 16;
    uint64_t v12 = v14;
    *(void *)&long long v54 = a2;
    int v15 = *(_DWORD *)(v13 + 16);
    if (v15)
    {
      if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
LABEL_59:
      }
        __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
      int v16 = v15 - 1;
      unsigned int v17 = v16 & ((a2 >> 4) ^ (a2 >> 9));
      BOOL result = (uint64_t *)(v12 + 16 * v17);
      uint64_t v18 = *result;
      if (*result == a2) {
        goto LABEL_22;
      }
      __int16 v19 = 0;
      int v20 = 1;
      while (v18 != -4096)
      {
        if (v19) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v18 == -8192;
        }
        if (v21) {
          __int16 v19 = result;
        }
        unsigned int v22 = v17 + v20++;
        unsigned int v17 = v22 & v16;
        BOOL result = (uint64_t *)(v12 + 16 * v17);
        uint64_t v18 = *result;
        if (*result == a2) {
          goto LABEL_22;
        }
      }
      if (v19) {
        uint64_t v23 = v19;
      }
      else {
        uint64_t v23 = result;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    BOOL result = llvm::DenseMapBase<llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>,void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::InsertIntoBucket<void *>(v13, v23, (uint64_t *)&v54);
LABEL_22:
    result[1] = (uint64_t)a3;
    return result;
  }
  uint64_t v8 = Set;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(a3)) {
LABEL_60:
  }
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (!a3)
  {
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    BOOL result = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v52);
    uint64_t v11 = *(unsigned int *)(v8 + 8);
    if (!v11) {
      return result;
    }
    goto LABEL_25;
  }
  uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(a3);
  if (!InterfaceFor) {
LABEL_61:
  }
    __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  uint64_t v52 = a3;
  uint64_t v53 = InterfaceFor;
  BOOL result = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v52);
  uint64_t v11 = *(unsigned int *)(v8 + 8);
  if (v11)
  {
LABEL_25:
    uint64_t v24 = result;
    int v25 = *(uint64_t **)v8;
    uint64_t v26 = *(void *)v8 + 8 * v11;
    while (1)
    {
      uint64_t v28 = *v25;
      int v29 = *(_DWORD *)(a1 + 32);
      if (!v29) {
        goto LABEL_37;
      }
      if ((v28 | 0x1000) == 0xFFFFFFFFFFFFF000) {
        goto LABEL_59;
      }
      uint64_t v30 = *(void *)(a1 + 16);
      int v31 = v29 - 1;
      unsigned int v32 = v31 & ((v28 >> 4) ^ (v28 >> 9));
      uint64_t v33 = *(void *)(v30 + 16 * v32);
      if (v33 != v28) {
        break;
      }
LABEL_29:
      if (++v25 == (uint64_t *)v26) {
        return result;
      }
    }
    int v34 = 1;
    while (v33 != -4096)
    {
      unsigned int v35 = v32 + v34++;
      unsigned int v32 = v35 & v31;
      uint64_t v33 = *(void *)(v30 + 16 * v32);
      if (v33 == v28) {
        goto LABEL_29;
      }
    }
LABEL_37:
    uint64_t v36 = (uint64_t **)(*(void *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v36)) {
      goto LABEL_60;
    }
    if (v36)
    {
      uint64_t v37 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v36);
      if (!v37) {
        goto LABEL_61;
      }
      long long v50 = v36;
      uint64_t v51 = v37;
      uint64_t v38 = (uint64_t)a3;
      if ((uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50) != v24) {
        goto LABEL_41;
      }
    }
    else
    {
      long long v50 = 0;
      uint64_t v51 = 0;
      uint64_t v38 = (uint64_t)a3;
      if ((uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50) != v24)
      {
LABEL_41:
        *(void *)&long long v54 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v52);
        *((void *)&v54 + 1) = v39;
        char v55 = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50);
        uint64_t v38 = mlir::ShapedType::cloneWith((uint64_t *)&v50, &v54, OperandRange);
      }
    }
    *(void *)&long long v54 = v28;
    int v41 = *(_DWORD *)(a1 + 32);
    if (v41)
    {
      if ((v28 | 0x1000) == 0xFFFFFFFFFFFFF000) {
        goto LABEL_59;
      }
      uint64_t v42 = *(void *)(a1 + 16);
      int v43 = v41 - 1;
      unsigned int v44 = v43 & ((v28 >> 4) ^ (v28 >> 9));
      BOOL result = (uint64_t *)(v42 + 16 * v44);
      uint64_t v45 = *result;
      if (*result == v28) {
        goto LABEL_28;
      }
      uint64_t v46 = 0;
      int v47 = 1;
      while (v45 != -4096)
      {
        if (v46) {
          BOOL v48 = 0;
        }
        else {
          BOOL v48 = v45 == -8192;
        }
        if (v48) {
          uint64_t v46 = result;
        }
        unsigned int v49 = v44 + v47++;
        unsigned int v44 = v49 & v43;
        BOOL result = (uint64_t *)(v42 + 16 * v44);
        uint64_t v45 = *result;
        if (*result == v28) {
          goto LABEL_28;
        }
      }
      if (v46) {
        uint64_t v27 = v46;
      }
      else {
        uint64_t v27 = result;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    BOOL result = llvm::DenseMapBase<llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>,void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::InsertIntoBucket<void *>(a1 + 16, v27, (uint64_t *)&v54);
LABEL_28:
    result[1] = v38;
    goto LABEL_29;
  }
  return result;
}

BOOL GPURegionRuntime::TIAndFoldHelper::hasConstant(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 56);
  if (!v2) {
    return 0;
  }
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  uint64_t v3 = *(void *)(a1 + 40);
  int v4 = v2 - 1;
  unsigned int v5 = v4 & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = *(void *)(v3 + 24 * v5);
  if (v6 == a2) {
    return 1;
  }
  int v8 = 1;
  do
  {
    BOOL result = v6 != -4096;
    if (v6 == -4096) {
      break;
    }
    unsigned int v9 = v5 + v8++;
    unsigned int v5 = v9 & v4;
    uint64_t v6 = *(void *)(v3 + 24 * v5);
  }
  while (v6 != a2);
  return result;
}

void *GPURegionRuntime::TIAndFoldHelper::setConstant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 40);
  BOOL result = (void *)(a1 + 40);
  uint64_t v7 = v8;
  uint64_t v19 = a2;
  int v9 = *((_DWORD *)result + 4);
  if (v9)
  {
    if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
      __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
    }
    int v10 = v9 - 1;
    unsigned int v11 = (v9 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v12 = (void *)(v7 + 24 * v11);
    uint64_t v13 = *v12;
    if (*v12 == a2)
    {
LABEL_4:
      v12[1] = a3;
      void v12[2] = a4;
      return result;
    }
    int v15 = 0;
    int v16 = 1;
    while (v13 != -4096)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v13 == -8192;
      }
      if (v17) {
        int v15 = v12;
      }
      unsigned int v18 = v11 + v16++;
      unsigned int v11 = v18 & v10;
      uint64_t v12 = (void *)(v7 + 24 * (v18 & v10));
      uint64_t v13 = *v12;
      if (*v12 == a2) {
        goto LABEL_4;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = v12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  BOOL result = llvm::DenseMapBase<llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>,void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::InsertIntoBucket<void *>((uint64_t)result, v14, &v19);
  result[1] = a3;
  result[2] = a4;
  return result;
}

uint64_t GPURegionRuntime::TIAndFoldHelper::getConstant(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unsigned int v3 = *(_DWORD *)(a1 + 56);
  if (v3)
  {
    if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
      __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
    }
    unsigned int v4 = v3 - 1;
    unsigned int v5 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = (uint64_t *)(v2 + 24 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a2)
    {
LABEL_4:
      if (v6 != (uint64_t *)(v2 + 24 * v3)) {
        return v6[1];
      }
    }
    else
    {
      int v9 = 1;
      while (v7 != -4096)
      {
        unsigned int v10 = v5 + v9++;
        unsigned int v5 = v10 & v4;
        uint64_t v6 = (uint64_t *)(v2 + 24 * (v10 & v4));
        uint64_t v7 = *v6;
        if (*v6 == a2) {
          goto LABEL_4;
        }
      }
    }
  }
  return 0;
}

void GPURegionRuntime::TIAndFoldHelper::addOpHandler(GPURegionRuntime::TIAndFoldHelper *this, GPU::BaseOpHandler *a2)
{
  uint64_t v4 = *((unsigned int *)this + 18);
  if (v4 >= *((_DWORD *)this + 19))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 64, (char *)this + 80, v4 + 1, 8);
    *(void *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18)) = a2;
    unsigned int v5 = *((_DWORD *)this + 18);
    if (v5 < *((_DWORD *)this + 19)) {
      goto LABEL_3;
    }
LABEL_5:
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  *(void *)(*((void *)this + 8) + 8 * v4) = a2;
  unsigned int v5 = *((_DWORD *)this + 18);
  if (v5 >= *((_DWORD *)this + 19)) {
    goto LABEL_5;
  }
LABEL_3:
  *((_DWORD *)this + 18) = v5 + 1;
}

GPURegionRuntime::ParallelTIAndFoldHelper *GPURegionRuntime::ParallelTIAndFoldHelper::ParallelTIAndFoldHelper(GPURegionRuntime::ParallelTIAndFoldHelper *this, GPURegionRuntime *a2, mlir::MLIRContext *a3)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = (char *)this + 80;
  *((void *)this + 9) = 0x600000000;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = a3;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = (char *)this + 184;
  *((void *)this + 22) = 0x400000000;
  *((void *)this + 28) = (char *)this + 240;
  *((void *)this + 29) = 0x400000000;
  *(void *)this = &unk_1EC988710;
  *((void *)this + 1) = a2;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = 0;
  *((_DWORD *)this + 74) = 0;
  *((void *)this + 39) = 850045863;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((void *)this + 46) = 0;
  *((void *)this + 47) = 1018212795;
  *((void *)this + 52) = 0;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  llvm::sys::RWMutexImpl::RWMutexImpl((GPURegionRuntime::ParallelTIAndFoldHelper *)((char *)this + 424));
  *((void *)this + 54) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((GPURegionRuntime::ParallelTIAndFoldHelper *)((char *)this + 440));
  *((void *)this + 56) = 0;
  *((void *)this + 57) = 0;
  if (*(unsigned char *)(*((void *)this + 1) + 256)) {
    operator new();
  }
  return this;
}

void sub_180D0E46C()
{
  MEMORY[0x1852FDE70](v2, 0x10A0C4039BF2501);
  std::unique_ptr<llvm::ThreadPool>::~unique_ptr[abi:ne180100](v4);
  llvm::sys::RWMutexImpl::~RWMutexImpl(v3);
  llvm::sys::RWMutexImpl::~RWMutexImpl(v1);
  std::condition_variable::~condition_variable((std::condition_variable *)(v0 + 376));
  std::mutex::~mutex((std::mutex *)(v0 + 312));
  llvm::DenseMap<mlir::Operation *,unsigned long long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long long>>::~DenseMap(v0 + 280);
}

void sub_180D0E4DC()
{
  GPURegionRuntime::TIAndFoldHelper::~TIAndFoldHelper(v0);
}

void sub_180D0E4E4()
{
  _Unwind_Resume(v0);
}

llvm::ThreadPool **std::unique_ptr<llvm::ThreadPool>::~unique_ptr[abi:ne180100](llvm::ThreadPool **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    llvm::ThreadPool::~ThreadPool(v2);
  }
  return a1;
}

void llvm::DenseMap<mlir::Operation *,unsigned long long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long long>>::~DenseMap(uint64_t a1)
{
}

uint64_t sub_180D0E55C()
{
  return v0;
}

void GPURegionRuntime::TIAndFoldHelper::~TIAndFoldHelper(GPURegionRuntime::TIAndFoldHelper *this)
{
  *(void *)this = &unk_1EC9886A8;
  uint64_t v2 = (char *)*((void *)this + 28);
  if (v2 != (char *)this + 240) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 21);
  if (v3 != (char *)this + 184) {
    free(v3);
  }
  uint64_t v4 = (mlir::Operation *)*((void *)this + 16);
  if (v4) {
    mlir::Operation::erase(v4);
  }
  unsigned int v5 = (char *)*((void *)this + 8);
  if (v5 != (char *)this + 80) {
    free(v5);
  }
  llvm::deallocate_buffer(*((llvm **)this + 5), (void *)(24 * *((unsigned int *)this + 14)));
}

{
  GPURegionRuntime::TIAndFoldHelper::~TIAndFoldHelper(this);
}

void sub_180D0E600()
{
  llvm::deallocate_buffer(*(llvm **)(v0 + 16), (void *)(16 * *(unsigned int *)(v0 + 32)));
}

uint64_t sub_180D0E614()
{
  return v0;
}

void GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v14 + 256))
  {
    qos_class_t v15 = qos_class_self();
    llvm::ThreadPool::raiseQOSIfNeeded(*(llvm::ThreadPool **)(a1 + 456), v15);
    int v16 = *(llvm::ThreadPool **)(a1 + 456);
    os_activity_t v17 = _os_activity_create(&dword_180159000, "ParallelTIAndFoldHelper", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    llvm::ThreadPool::setActivity(v16, v17, 1);

    uint64_t v14 = *(void *)(a1 + 8);
  }
  long long v40 = *(_OWORD *)(v14 + 232);
  mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v40);
  if (v18)
  {
    unint64_t v19 = 0;
    int v20 = (void *)(a4 + 8);
    do
    {
      unint64_t v21 = *(unsigned int *)(v40 + 44);
      if ((v21 & 0x7FFFFF) == 0) {
        __assert_rtn("getRegion", "Operation.h", 666, "index < numRegions && \"invalid region index\"");
      }
      unint64_t v22 = v40 + 16 * ((v21 >> 23) & 1) + ((v21 >> 21) & 0x7F8) + 64;
      if (v22 >= 0xFFFFFFFFFFFFFFF9) {
        __assert_rtn("alignAddr", "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"");
      }
      uint64_t v23 = (void *)(((v22 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v40 + 40));
      if ((void *)*v23 == v23) {
        goto LABEL_44;
      }
      uint64_t v24 = v23[1];
      uint64_t v25 = v24 - 8;
      if (!v24) {
        uint64_t v25 = 0;
      }
      uint64_t v26 = *(void *)(v25 + 48);
      if (v19 >= (*(void *)(v25 + 56) - v26) >> 3) {
LABEL_44:
      }
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      if (a3 == v19) {
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      }
      uint64_t v27 = *(void *)(v26 + 8 * v19);
      if (*(void *)(a2 + 8 * v19)) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v27);
      }
      if (a5 == v19) {
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      }
      uint64_t v28 = *(v20 - 1);
      if (v28) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 56))(a1, v27, v28, *v20);
      }
      mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v40);
      ++v19;
      v20 += 2;
    }
    while (v19 < v29);
  }
  mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v40);
  if (v30)
  {
    uint64_t v31 = 0;
    uint64_t v32 = 24;
    do
    {
      uint64_t v33 = *(void *)(*(void *)(a1 + 8) + 248);
      if ((*(unsigned char *)(v33 + 46) & 0x80) == 0) {
        __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
      }
      if (*(_DWORD *)(v33 + 68) <= v31) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      if (a7 == v31) {
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      }
      if (*(void *)(a6 + 8 * v31)) {
        (*(void (**)(uint64_t, void))(*(void *)a1 + 32))(a1, *(void *)(*(void *)(v33 + 72) + v32));
      }
      mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v40);
      ++v31;
      v32 += 32;
    }
    while (v31 != v34);
  }
  std::mutex::lock((std::mutex *)(a1 + 312));
  ++*(void *)(a1 + 304);
  std::mutex::unlock((std::mutex *)(a1 + 312));
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 376));
  if (*(unsigned char *)(*(void *)(a1 + 8) + 256))
  {
    uint64_t v35 = *(void *)(a1 + 456);
    v41[0] = &unk_1EC97F398;
    v41[1] = a1;
    uint64_t v42 = v41;
    llvm::ThreadPool::asyncImpl<void>(v35, v41, 0, (std::future<void> *)&v39);
    if (v42 == v41)
    {
      (*(void (**)(void *))(v41[0] + 32))(v41);
    }
    else if (v42)
    {
      (*(void (**)(void))(*v42 + 40))();
    }
    std::shared_future<void>::~shared_future(&v39);
  }
  else
  {
    uint64_t v36 = *(unsigned int *)(a1 + 72);
    if (v36)
    {
      uint64_t v37 = *(GPU::BaseOpHandler ***)(a1 + 64);
      uint64_t v38 = 8 * v36;
      do
      {
        GPURegionRuntime::TIAndFoldHelper::runOnOp((GPURegionRuntime::TIAndFoldHelper *)a1, *v37);
        std::mutex::lock((std::mutex *)(a1 + 312));
        ++*(void *)(a1 + 304);
        std::mutex::unlock((std::mutex *)(a1 + 312));
        std::condition_variable::notify_all((std::condition_variable *)(a1 + 376));
        ++v37;
        v38 -= 8;
      }
      while (v38);
    }
  }
}

void sub_180D0EB0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_180D0EB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL GPURegionRuntime::ParallelTIAndFoldHelper::hasType(uint64_t a1, uint64_t a2)
{
  GPURegionRuntime::ParallelTIAndFoldHelper::waitForValueProcessed(a1, a2);
  uint64_t v4 = (pthread_rwlock_t **)(a1 + 424);
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(a1 + 424));
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5)
  {
    if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
      __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
    }
    uint64_t v6 = *(void *)(a1 + 16);
    int v7 = v5 - 1;
    unsigned int v8 = v7 & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v9 = *(void *)(v6 + 16 * v8);
    if (v9 == a2)
    {
      BOOL v10 = 1;
    }
    else
    {
      int v12 = 1;
      do
      {
        BOOL v10 = v9 != -4096;
        if (v9 == -4096) {
          break;
        }
        unsigned int v13 = v8 + v12++;
        unsigned int v8 = v13 & v7;
        uint64_t v9 = *(void *)(v6 + 16 * v8);
      }
      while (v9 != a2);
    }
  }
  else
  {
    BOOL v10 = 0;
  }
  llvm::sys::RWMutexImpl::unlock_shared(v4);
  return v10;
}

void sub_180D0EC18(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

void GPURegionRuntime::ParallelTIAndFoldHelper::waitForValueProcessed(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = a2;
  if (!*(_DWORD *)(a1 + 288)) {
    return;
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (DefiningOp)
  {
    if (*(_DWORD *)(a1 + 288))
    {
      uint64_t v4 = *(void *)(a1 + 280);
      uint64_t v5 = *(unsigned int *)(a1 + 296);
      if (v5)
      {
        if ((DefiningOp | 0x1000) == 0xFFFFFFFFFFFFF000) {
          __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
        }
        LODWORD(v6) = (v5 - 1) & ((DefiningOp >> 4) ^ (DefiningOp >> 9));
        int v7 = (uint64_t *)(v4 + 16 * v6);
        uint64_t v8 = *v7;
        if (*v7 == DefiningOp)
        {
          uint64_t v9 = (uint64_t *)(v4 + 16 * v5);
          if (v7 != v9)
          {
LABEL_8:
            if (v7 == v9) {
              __assert_rtn("operator->", "DenseMap.h", 1270, "Ptr != End && \"dereferencing end() iterator\"");
            }
            unint64_t v10 = v7[1];
            goto LABEL_17;
          }
        }
        else
        {
          int v11 = 1;
          while (v8 != -4096)
          {
            int v12 = v6 + v11++;
            uint64_t v6 = v12 & (v5 - 1);
            uint64_t v8 = *(void *)(v4 + 16 * v6);
            if (v8 == DefiningOp)
            {
              int v7 = (uint64_t *)(v4 + 16 * v6);
              uint64_t v9 = (uint64_t *)(v4 + 16 * v5);
              if (v7 != v9) {
                goto LABEL_8;
              }
              break;
            }
          }
        }
      }
    }
  }
  unint64_t v10 = 0;
LABEL_17:
  uint64_t m = (std::mutex *)(a1 + 312);
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 312);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 312));
  if (*(void *)(a1 + 304) > v10)
  {
LABEL_21:
    std::mutex::unlock(m);
    return;
  }
  do
    std::condition_variable::wait((std::condition_variable *)(a1 + 376), &__lk);
  while (*(void *)(a1 + 304) <= v10);
  if (__lk.__owns_)
  {
    uint64_t m = __lk.__m_;
    goto LABEL_21;
  }
}

uint64_t GPURegionRuntime::ParallelTIAndFoldHelper::getType(uint64_t a1, uint64_t a2)
{
  GPURegionRuntime::ParallelTIAndFoldHelper::waitForValueProcessed(a1, a2);
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(a1 + 424));
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if (!v5) {
    goto LABEL_14;
  }
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
    int v11 = "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn'"
          "t be inserted into map!\"";
    int v12 = 651;
    unsigned int v13 = "LookupBucketFor";
    goto LABEL_9;
  }
  LODWORD(v6) = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  int v7 = (uint64_t *)(v4 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t v9 = (uint64_t *)(v4 + 16 * v5);
    if (v7 != v9) {
      goto LABEL_5;
    }
LABEL_14:
    uint64_t v10 = 0;
    goto LABEL_15;
  }
  int v14 = 1;
  do
  {
    if (v8 == -4096) {
      goto LABEL_14;
    }
    int v15 = v6 + v14++;
    uint64_t v6 = v15 & (v5 - 1);
    uint64_t v8 = *(void *)(v4 + 16 * v6);
  }
  while (v8 != a2);
  int v7 = (uint64_t *)(v4 + 16 * v6);
  uint64_t v9 = (uint64_t *)(v4 + 16 * v5);
  if (v7 == v9) {
    goto LABEL_14;
  }
LABEL_5:
  if (v7 == v9)
  {
    int v11 = "Ptr != End && \"dereferencing end() iterator\"";
    int v12 = 1270;
    unsigned int v13 = "operator->";
LABEL_9:
    __assert_rtn(v13, "DenseMap.h", v12, v11);
  }
  uint64_t v10 = v7[1];
LABEL_15:
  llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)(a1 + 424));
  return v10;
}

void sub_180D0EEFC(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

BOOL GPURegionRuntime::ParallelTIAndFoldHelper::setType(uint64_t a1, unint64_t a2, uint64_t **a3)
{
  uint64_t v6 = (pthread_rwlock_t **)(a1 + 424);
  llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(a1 + 424));
  GPURegionRuntime::TIAndFoldHelper::setType(a1, a2, a3);
  return llvm::sys::RWMutexImpl::unlock_shared(v6);
}

void sub_180D0EF6C(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

BOOL GPURegionRuntime::ParallelTIAndFoldHelper::hasConstant(uint64_t a1, uint64_t a2)
{
  GPURegionRuntime::ParallelTIAndFoldHelper::waitForValueProcessed(a1, a2);
  uint64_t v4 = (pthread_rwlock_t **)(a1 + 440);
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(a1 + 440));
  int v5 = *(_DWORD *)(a1 + 56);
  if (v5)
  {
    if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
      __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
    }
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = v5 - 1;
    unsigned int v8 = v7 & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v9 = *(void *)(v6 + 24 * v8);
    if (v9 == a2)
    {
      BOOL v10 = 1;
    }
    else
    {
      int v12 = 1;
      do
      {
        BOOL v10 = v9 != -4096;
        if (v9 == -4096) {
          break;
        }
        unsigned int v13 = v8 + v12++;
        unsigned int v8 = v13 & v7;
        uint64_t v9 = *(void *)(v6 + 24 * v8);
      }
      while (v9 != a2);
    }
  }
  else
  {
    BOOL v10 = 0;
  }
  llvm::sys::RWMutexImpl::unlock_shared(v4);
  return v10;
}

void sub_180D0F06C(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

uint64_t GPURegionRuntime::ParallelTIAndFoldHelper::getConstant(uint64_t a1, uint64_t a2)
{
  GPURegionRuntime::ParallelTIAndFoldHelper::waitForValueProcessed(a1, a2);
  llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(a1 + 440));
  uint64_t Constant = GPURegionRuntime::TIAndFoldHelper::getConstant(a1, a2);
  llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)(a1 + 440));
  return Constant;
}

void sub_180D0F0E8(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

BOOL GPURegionRuntime::ParallelTIAndFoldHelper::setConstant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = (pthread_rwlock_t **)(a1 + 440);
  llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(a1 + 440));
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v10 = a1 + 40;
  uint64_t v9 = v11;
  uint64_t v23 = a2;
  int v12 = *(_DWORD *)(v10 + 16);
  if (!v12)
  {
    unint64_t v21 = 0;
LABEL_14:
    inserted = llvm::DenseMapBase<llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>,void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::InsertIntoBucket<void *>(v10, v21, &v23);
    goto LABEL_15;
  }
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  int v13 = v12 - 1;
  unsigned int v14 = v13 & ((a2 >> 4) ^ (a2 >> 9));
  inserted = (void *)(v9 + 24 * v14);
  uint64_t v16 = *inserted;
  if (*inserted != a2)
  {
    os_activity_t v17 = 0;
    int v18 = 1;
    while (v16 != -4096)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v16 == -8192;
      }
      if (v19) {
        os_activity_t v17 = inserted;
      }
      unsigned int v20 = v14 + v18++;
      unsigned int v14 = v20 & v13;
      inserted = (void *)(v9 + 24 * v14);
      uint64_t v16 = *inserted;
      if (*inserted == a2) {
        goto LABEL_15;
      }
    }
    if (v17) {
      unint64_t v21 = v17;
    }
    else {
      unint64_t v21 = inserted;
    }
    goto LABEL_14;
  }
LABEL_15:
  inserted[1] = a3;
  inserted[2] = a4;
  return llvm::sys::RWMutexImpl::unlock_shared(v8);
}

void sub_180D0F220(_Unwind_Exception *a1)
{
  llvm::sys::RWMutexImpl::unlock_shared(v1);
  _Unwind_Resume(a1);
}

uint64_t GPURegionRuntime::ParallelTIAndFoldHelper::reset(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 24);
  if (!*(void *)(this + 24))
  {
LABEL_5:
    int v4 = *(_DWORD *)(v1 + 48);
    if (v4) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  this += 16;
  uint64_t v3 = *(unsigned int *)(v1 + 32);
  if (v3 > 4 * v2 && v3 >= 0x41)
  {
    this = llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::shrink_and_clear(this);
    goto LABEL_5;
  }
  if (v3)
  {
    int v5 = *(void **)this;
    uint64_t v6 = (v3 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      uint64_t v7 = v6 + 1;
      uint64_t v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v9 = &v5[2 * v8];
      uint64_t v10 = v5 + 2;
      uint64_t v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        *uint64_t v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v9 = *(void **)this;
    }
    int v12 = &v5[2 * v3];
    do
    {
      *uint64_t v9 = -4096;
      v9 += 2;
    }
    while (v9 != v12);
  }
LABEL_16:
  *(void *)(v1 + 24) = 0;
  int v4 = *(_DWORD *)(v1 + 48);
  if (v4) {
    goto LABEL_18;
  }
LABEL_17:
  if (!*(_DWORD *)(v1 + 52))
  {
LABEL_21:
    *(void *)(v1 + 304) = 0;
    return this;
  }
LABEL_18:
  this = v1 + 40;
  unsigned int v13 = *(_DWORD *)(v1 + 56);
  if (v13 > 4 * v4 && v13 >= 0x41)
  {
    this = llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::shrink_and_clear(this);
    goto LABEL_21;
  }
  if (v13)
  {
    unsigned int v14 = *(void **)this;
    unint64_t v15 = 24 * v13 - 24;
    if (v15 >= 0x18)
    {
      unint64_t v17 = v15 / 0x18 + 1;
      uint64_t v16 = &v14[3 * (v17 & 0x1FFFFFFFFFFFFFFELL)];
      uint64_t v18 = v17 & 0x1FFFFFFFFFFFFFFELL;
      BOOL v19 = *(void **)this;
      do
      {
        *BOOL v19 = -4096;
        v19[3] = -4096;
        v19 += 6;
        v18 -= 2;
      }
      while (v18);
      if (v17 == (v17 & 0x1FFFFFFFFFFFFFFELL)) {
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v16 = *(void **)this;
    }
    unsigned int v20 = &v14[3 * v13];
    do
    {
      *uint64_t v16 = -4096;
      v16 += 3;
    }
    while (v16 != v20);
  }
LABEL_30:
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 304) = 0;
  return this;
}

void GPURegionRuntime::ParallelTIAndFoldHelper::addOpHandler(GPURegionRuntime::ParallelTIAndFoldHelper *this, GPU::BaseOpHandler *a2)
{
  int v4 = *((_DWORD *)this + 72);
  unsigned int v5 = *((_DWORD *)this + 74);
  if (!v5) {
    goto LABEL_28;
  }
  uint64_t v6 = *((void *)a2 + 3);
  if ((v6 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    goto LABEL_41;
  }
  uint64_t v7 = *((void *)this + 35);
  unsigned int v8 = v5 - 1;
  unsigned int v9 = ((v6 >> 4) ^ (v6 >> 9)) & (v5 - 1);
  uint64_t v10 = (void *)(v7 + 16 * v9);
  uint64_t v11 = *v10;
  if (v6 == *v10) {
    goto LABEL_20;
  }
  int v12 = 0;
  int v13 = 1;
  while (v11 != -4096)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -8192;
    }
    if (v14) {
      int v12 = v10;
    }
    unsigned int v15 = v9 + v13++;
    unsigned int v9 = v15 & v8;
    uint64_t v10 = (void *)(v7 + 16 * (v15 & v8));
    uint64_t v11 = *v10;
    if (v6 == *v10) {
      goto LABEL_20;
    }
  }
  if (v12) {
    uint64_t v10 = v12;
  }
  if (4 * v4 + 4 < 3 * v5)
  {
    if (v5 + ~v4 - *((_DWORD *)this + 73) > v5 >> 3)
    {
      if (v10) {
        goto LABEL_16;
      }
LABEL_42:
      __assert_rtn("InsertIntoBucketImpl", "DenseMap.h", 616, "TheBucket");
    }
  }
  else
  {
LABEL_28:
    v5 *= 2;
  }
  llvm::DenseMap<mlir::Operation *,unsigned long long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long long>>::grow((uint64_t)this + 280, v5);
  int v19 = *((_DWORD *)this + 74);
  if (!v19) {
    goto LABEL_42;
  }
  uint64_t v16 = *((void *)a2 + 3);
  if ((v16 | 0x1000) == 0xFFFFFFFFFFFFF000) {
LABEL_41:
  }
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  uint64_t v20 = *((void *)this + 35);
  int v21 = v19 - 1;
  unsigned int v22 = ((v16 >> 4) ^ (v16 >> 9)) & (v19 - 1);
  uint64_t v10 = (void *)(v20 + 16 * v22);
  uint64_t v23 = *v10;
  if (v16 == *v10) {
    goto LABEL_17;
  }
  uint64_t v24 = 0;
  int v25 = 1;
  while (v23 != -4096)
  {
    if (v24) {
      BOOL v26 = 0;
    }
    else {
      BOOL v26 = v23 == -8192;
    }
    if (v26) {
      uint64_t v24 = v10;
    }
    unsigned int v27 = v22 + v25++;
    unsigned int v22 = v27 & v21;
    uint64_t v10 = (void *)(v20 + 16 * (v27 & v21));
    uint64_t v23 = *v10;
    if (v16 == *v10) {
      goto LABEL_17;
    }
  }
  if (v24) {
    uint64_t v10 = v24;
  }
LABEL_16:
  uint64_t v16 = *v10;
LABEL_17:
  ++*((_DWORD *)this + 72);
  if (v16 != -4096) {
    --*((_DWORD *)this + 73);
  }
  *uint64_t v10 = *((void *)a2 + 3);
  v10[1] = 0;
LABEL_20:
  v10[1] = (v4 + 1);
  uint64_t v17 = *((unsigned int *)this + 18);
  if (v17 >= *((_DWORD *)this + 19))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 64, (char *)this + 80, v17 + 1, 8);
    *(void *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18)) = a2;
    unsigned int v18 = *((_DWORD *)this + 18);
    if (v18 < *((_DWORD *)this + 19)) {
      goto LABEL_22;
    }
LABEL_24:
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  *(void *)(*((void *)this + 8) + 8 * v17) = a2;
  unsigned int v18 = *((_DWORD *)this + 18);
  if (v18 >= *((_DWORD *)this + 19)) {
    goto LABEL_24;
  }
LABEL_22:
  *((_DWORD *)this + 18) = v18 + 1;
}

void sub_180D0F6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPURegionRuntime::allocateTensorDataForValue(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)a1 + 80))(a1, a2, 0, 0, 0, 1);
}

void GPURegionRuntime::~GPURegionRuntime(GPURegionRuntime *this)
{
  GPURegionRuntime::~GPURegionRuntime(this);

  JUMPOUT(0x1852FDE70);
}

{
  void *v2;
  void *v3;
  void *v4;
  GPU::ANECompilerHelper *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  id *v9;
  id *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t vars8;

  *(void *)this = &unk_1EC9864E8;
  int v2 = (void *)*((void *)this + 78);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      int v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)*((void *)this + 76);
  *((void *)this + 76) = 0;
  if (v4) {
    operator delete(v4);
  }
  unsigned int v5 = (GPU::ANECompilerHelper *)*((void *)this + 75);
  *((void *)this + 75) = 0;
  if (v5) {
    GPU::ANECompilerHelper::~ANECompilerHelper(v5);
  }
  uint64_t v6 = (char *)*((void *)this + 57);
  if (v6 != (char *)this + 472) {
    free(v6);
  }
  uint64_t v7 = *((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  std::unique_ptr<mlir::ShapeEquivalence>::reset[abi:ne180100]((uint64_t *)this + 55, 0);

  unsigned int v8 = *((void *)this + 53);
  *((void *)this + 53) = 0;
  if (v8) {
    std::default_delete<GPU::RuntimeExecutionReport>::operator()[abi:ne180100]((uint64_t)this + 424, v8);
  }
  unsigned int v9 = (id *)*((void *)this + 50);
  if (v9)
  {
    do
    {
      uint64_t v10 = (id *)*v9;

      operator delete(v9);
      unsigned int v9 = v10;
    }
    while (v10);
  }
  uint64_t v11 = (void *)*((void *)this + 48);
  *((void *)this + 48) = 0;
  if (v11) {
    operator delete(v11);
  }
  int v12 = (void *)*((void *)this + 45);
  if (v12)
  {
    do
    {
      unsigned int v18 = (void *)*v12;
      int v19 = (void *)v12[5];
      if (v19)
      {
        do
        {
          uint64_t v20 = (void *)*v19;
          operator delete(v19);
          int v19 = v20;
        }
        while (v20);
      }
      int v21 = (void *)v12[3];
      v12[3] = 0;
      if (v21) {
        operator delete(v21);
      }
      operator delete(v12);
      int v12 = v18;
    }
    while (v18);
  }
  int v13 = (void *)*((void *)this + 43);
  *((void *)this + 43) = 0;
  if (v13) {
    operator delete(v13);
  }
  BOOL v14 = (void *)*((void *)this + 40);
  if (v14)
  {
    do
    {
      unsigned int v22 = (void *)*v14;
      uint64_t v23 = (void *)v14[5];
      if (v23)
      {
        do
        {
          uint64_t v24 = (void *)*v23;
          operator delete(v23);
          uint64_t v23 = v24;
        }
        while (v24);
      }
      int v25 = (void *)v14[3];
      v14[3] = 0;
      if (v25) {
        operator delete(v25);
      }
      operator delete(v14);
      BOOL v14 = v22;
    }
    while (v22);
  }
  unsigned int v15 = (void *)*((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v15) {
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 35);
  if (v16)
  {
    do
    {
      BOOL v26 = (void *)*v16;
      unsigned int v27 = v16[3];
      void v16[3] = 0;
      if (v27) {
        (*(void (**)(uint64_t))(*(void *)v27 + 40))(v27);
      }
      operator delete(v16);
      uint64_t v16 = v26;
    }
    while (v26);
  }
  uint64_t v17 = (void *)*((void *)this + 33);
  *((void *)this + 33) = 0;
  if (v17) {
    operator delete(v17);
  }

  BaseRuntime::~BaseRuntime(this);
}

void sub_180D0F7C0()
{
  JUMPOUT(0x1852FDE70);
}

void FullyPlacedOnANEMPSRuntime::~FullyPlacedOnANEMPSRuntime(FullyPlacedOnANEMPSRuntime *this)
{
  *(void *)this = &unk_1EC995F90;
  int v2 = (char *)*((void *)this + 106);
  if (v2 != (char *)this + 864) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 98);
  if (v3 != (char *)this + 800) {
    free(v3);
  }
  int v4 = (char *)*((void *)this + 90);
  if (v4 != (char *)this + 736) {
    free(v4);
  }
  unsigned int v5 = (char *)*((void *)this + 82);
  if (v5 != (char *)this + 672) {
    free(v5);
  }

  GPURegionRuntime::~GPURegionRuntime(this);
}

{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EC995F90;
  int v2 = (char *)*((void *)this + 106);
  if (v2 != (char *)this + 864) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 98);
  if (v3 != (char *)this + 800) {
    free(v3);
  }
  int v4 = (char *)*((void *)this + 90);
  if (v4 != (char *)this + 736) {
    free(v4);
  }
  unsigned int v5 = (char *)*((void *)this + 82);
  if (v5 != (char *)this + 672) {
    free(v5);
  }
  GPURegionRuntime::~GPURegionRuntime(this);

  JUMPOUT(0x1852FDE70);
}

void GPURegionRuntime::ParallelTIAndFoldHelper::~ParallelTIAndFoldHelper(GPURegionRuntime::ParallelTIAndFoldHelper *this)
{
}

{
  llvm::ThreadPool *v2;

  *(void *)this = &unk_1EC988710;
  int v2 = (llvm::ThreadPool *)*((void *)this + 57);
  *((void *)this + 57) = 0;
  if (v2) {
    llvm::ThreadPool::~ThreadPool(v2);
  }
  llvm::sys::RWMutexImpl::~RWMutexImpl((pthread_rwlock_t **)this + 55);
  llvm::sys::RWMutexImpl::~RWMutexImpl((pthread_rwlock_t **)this + 53);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 376));
  std::mutex::~mutex((std::mutex *)((char *)this + 312));
  llvm::deallocate_buffer(*((llvm **)this + 35), (void *)(16 * *((unsigned int *)this + 74)));
}

void sub_180D0F950()
{
  JUMPOUT(0x1852FDE70);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x6E656D6563616C70
      && AttrData[1] == 0x6E6F696765722E74
      && *(void *)((char *)AttrData + 13) == 0x6C6C61635F6E6F69)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"placement.region_call";
      v9[3] = 21;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReshapeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReshapeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x687365722E73706DLL && *(void *)((char *)AttrData + 3) == 0x657061687365722ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.reshape";
      v8[3] = 11;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x6D74616D2E73706DLL && *(_WORD *)(AttrData + 8) == 27765)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.matmul";
      v8[3] = 10;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
  {
    return 0;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(void *a1, uint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = HIDWORD(*a2);
  unint64_t v5 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v4);
  unint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v2);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = v6;
    if (v6 >= *(void *)&v2) {
      unint64_t v8 = v6 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v8 = v6 & (*(void *)&v2 - 1);
  }
  __int16 v9 = *(void **)(*a1 + 8 * v8);
  if (!v9) {
    return 0;
  }
  BOOL result = (void *)*v9;
  if (*v9)
  {
    if (v7.u32[0] < 2uLL)
    {
      uint64_t v11 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v13 = result[1];
        if (v13 == v6)
        {
          if (result[2] == v3) {
            return result;
          }
        }
        else if ((v13 & v11) != v8)
        {
          return 0;
        }
        BOOL result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v12 = result[1];
      if (v12 == v6)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v12 >= *(void *)&v2) {
          v12 %= *(void *)&v2;
        }
        if (v12 != v8) {
          return 0;
        }
      }
      BOOL result = (void *)*result;
    }
    while (result);
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v23 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v24 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v25 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v27 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v26 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v28 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v29 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v30 = v26 + v28;
      unint64_t v31 = 0x9DDFEA08EB382D69
          * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ (v23 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ (v23 + a3))));
      unint64_t v32 = 0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47));
      unint64_t v33 = v23 + v26 + v27 + a3;
      uint64_t v34 = v33 + v24;
      unint64_t v35 = __ROR8__(v33, 44) + v27 + a3 + __ROR8__(v27 + a3 + v24 - 0x622015F714C7D297 * (v31 ^ (v31 >> 47)), 21);
      uint64_t v36 = v26 + v28 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v37 = v25 + v28 + v36;
      uint64_t v38 = __ROR8__(v37, 44);
      uint64_t v39 = v37 + v29;
      uint64_t v40 = v38 + v36 + __ROR8__(v36 + v24 + v29, 21);
      uint64_t v42 = *a2;
      int v41 = a2 + 4;
      unint64_t v43 = v42 - 0x4B6D499041670D8DLL * v24;
      uint64_t v44 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v45 = *(v41 - 3);
        uint64_t v46 = v43 + v34 + v30 + v45;
        uint64_t v47 = v41[2];
        uint64_t v48 = v41[3];
        uint64_t v49 = v41[1];
        unint64_t v30 = v49 + v34 - 0x4B6D499041670D8DLL * __ROR8__(v30 + v35 + v47, 42);
        uint64_t v50 = v32 + v39;
        uint64_t v51 = *(v41 - 2);
        uint64_t v52 = *(v41 - 1);
        uint64_t v53 = *(v41 - 4) - 0x4B6D499041670D8DLL * v35;
        uint64_t v54 = v53 + v39 + v52;
        uint64_t v55 = v53 + v45 + v51;
        uint64_t v34 = v55 + v52;
        uint64_t v56 = __ROR8__(v55, 44) + v53;
        unint64_t v57 = (0xB492B66FBE98F273 * __ROR8__(v46, 37)) ^ v40;
        unint64_t v43 = 0xB492B66FBE98F273 * __ROR8__(v50, 33);
        unint64_t v35 = v56 + __ROR8__(v54 + v57, 21);
        unint64_t v58 = v43 + v40 + *v41;
        uint64_t v39 = v49 + v47 + v58 + v48;
        uint64_t v40 = __ROR8__(v49 + v47 + v58, 44) + v58 + __ROR8__(v30 + v51 + v58 + v48, 21);
        v41 += 8;
        unint64_t v32 = v57;
        v44 += 64;
      }
      while (v44);
      unint64_t v59 = v43
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v35)))) ^ ((0x9DDFEA08EB382D69 * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v35)))) >> 47));
      unint64_t v60 = 0x9DDFEA08EB382D69
          * (v59 ^ (v57
                  - 0x4B6D499041670D8DLL * (v30 ^ (v30 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ v34)))) ^ ((0x9DDFEA08EB382D69 * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ v34)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v59 ^ (v60 >> 47) ^ v60)) ^ ((0x9DDFEA08EB382D69 * (v59 ^ (v60 >> 47) ^ v60)) >> 47));
    }
    else
    {
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v7 = *a2 - 0x3C5A37A36834CED9 * (v6 + a3);
      uint64_t v9 = a2[2];
      uint64_t v8 = a2[3];
      uint64_t v10 = __ROR8__(v7 + v8, 52);
      uint64_t v11 = v7 + a2[1];
      uint64_t v12 = __ROR8__(v11, 7);
      uint64_t v13 = v11 + v9;
      uint64_t v14 = *(uint64_t *)((char *)a2 + a3 - 32) + v9;
      uint64_t v15 = v12 + __ROR8__(*a2 - 0x3C5A37A36834CED9 * (v6 + a3), 37) + v10 + __ROR8__(v13, 31);
      uint64_t v16 = *(uint64_t *)((char *)a2 + a3 - 24) + v14 + v6;
      unint64_t v17 = 0xC3A5C85C97CB3127 * (v16 + *(uint64_t *)((char *)a2 + a3 - 8) + v8 + v15)
          - 0x651E95C4D06FBFB1
          * (v13
           + v8
           + __ROR8__(v14, 37)
           + __ROR8__(*(uint64_t *)((char *)a2 + a3 - 24) + v14, 7)
           + __ROR8__(*(uint64_t *)((char *)a2 + a3 - 8) + v8 + v14, 52)
           + __ROR8__(v16, 31));
      return 0x9AE16A3B2F90404FLL
           * ((v15 - 0x3C5A37A36834CED9 * (v17 ^ (v17 >> 47))) ^ ((v15 - 0x3C5A37A36834CED9 * (v17 ^ (v17 >> 47))) >> 47));
    }
  }
  else if (a3 > 0x10)
  {
    uint64_t v18 = a2[1];
    unint64_t v19 = 0xB492B66FBE98F273 * *a2;
    uint64_t v20 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8), 30) + __ROR8__(v19 - v18, 43);
    unint64_t v21 = v19 + a3 + __ROR8__(v18 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8);
    unint64_t v22 = 0x9DDFEA08EB382D69 * ((v20 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a2 + a3 - 16)) ^ v21);
    return 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) ^ ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 47));
  }
  else if (a3 < 9)
  {
    if (a3 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a3)
      {
        unint64_t v63 = (0xC949D7C7509E6557 * (a3 + 4 * *((unsigned __int8 *)a2 + a3 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                       * (*(unsigned __int8 *)a2 | ((unint64_t)*((unsigned __int8 *)a2 + (a3 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v63 ^ (v63 >> 47));
      }
    }
    else
    {
      uint64_t v61 = *(unsigned int *)((char *)a2 + a3 - 4);
      unint64_t v62 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a2) + a3) ^ v61);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v61 ^ (v62 >> 47) ^ v62)) ^ ((0x9DDFEA08EB382D69 * (v61 ^ (v62 >> 47) ^ v62)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(uint64_t *)((char *)a2 + a3 - 8);
    uint64_t v4 = __ROR8__(v3 + a3, a3);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *a2)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *a2)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *a2)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *a2)))) >> 47))) ^ v3;
  }
  return result;
}

void __clang_call_terminate(void *a1)
{
}

char *std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (char *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = *((void *)v14 + 1);
            if (v16 == v10)
            {
              if (*((void *)v14 + 2) == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = *(char **)v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            if (*((void *)v14 + 2) == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  unint64_t v17 = (void *)(a1 + 16);
  uint64_t v14 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v10;
  *((void *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    unint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *(void *)uint64_t v14 = *v21;
LABEL_61:
      *unint64_t v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v20 = *(void *)a1;
        unint64_t v21 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v20 = *(void *)a1;
        unint64_t v21 = *(void **)(*(void *)a1 + 8 * v10);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v10;
      uint64_t v20 = *(void *)a1;
      unint64_t v21 = *(void **)(*(void *)a1 + 8 * (v29 & v10));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *(void *)uint64_t v14 = *v17;
  *unint64_t v17 = v14;
  *(void *)(v20 + 8 * v4) = v17;
  if (*(void *)v14)
  {
    unint64_t v30 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11) {
        v30 %= v11;
      }
    }
    else
    {
      v30 &= v11 - 1;
    }
    unint64_t v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_180D10538(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (id *)v2[5];
      if (v3)
      {
        do
        {
          unint64_t v4 = (id *)*v3;

          operator delete(v3);
          uint64_t v3 = v4;
        }
        while (v4);
      }
      unint64_t v5 = (void *)v2[3];
      v2[3] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    unint64_t v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v4 = operator new(8 * a2);
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint8x8_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          uint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          *uint64_t v7 = *v12;
          uint64_t v14 = 8 * v13;
          *uint8x8_t v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          uint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    uint64_t v16 = (void *)*v7;
    if (*v7)
    {
      while (1)
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 == v9) {
          goto LABEL_25;
        }
        if (*(void *)(*(void *)a1 + 8 * v18))
        {
          *uint64_t v7 = *v16;
          uint64_t v17 = 8 * v18;
          *uint64_t v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          uint64_t v16 = v7;
LABEL_25:
          uint64_t v7 = v16;
          uint64_t v16 = (void *)*v16;
          if (!v16) {
            return;
          }
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v18) = v7;
          uint64_t v7 = v16;
          uint64_t v16 = (void *)*v16;
          unint64_t v9 = v18;
          if (!v16) {
            return;
          }
        }
      }
    }
  }
}

void *std::__hash_table<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>>>::__emplace_unique_key_args<void *,void *,MPSGraphTensorData * {__strong}&>(uint64_t a1, uint64_t *a2, void *a3, id *a4)
{
  uint64_t v8 = *a2;
  unint64_t v9 = HIDWORD(*a2);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v9);
  unint64_t v11 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = v11 & (v12 - 1);
    }
    uint64_t v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      unint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == v8) {
                return v15;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_23;
            }
            unint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == v8) {
              return v15;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_23:
  unint64_t v18 = (void *)(a1 + 16);
  unint64_t v15 = operator new(0x20uLL);
  *unint64_t v15 = 0;
  v15[1] = v11;
  void v15[2] = *a3;
  v15[3] = *a4;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v12 && (float)(v20 * (float)v12) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      *unint64_t v15 = *v22;
LABEL_61:
      *BOOL v22 = v15;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v27 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v27) {
      goto LABEL_37;
    }
    if (prime < *(void *)&v27)
    {
      unint64_t v28 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v27 < 3uLL || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (prime <= v28) {
        size_t prime = v28;
      }
      if (prime < *(void *)&v27) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    unint64_t v31 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
      {
        unint64_t v4 = v11 % v12;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v11);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v31 & v11;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v31 & v11));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  *unint64_t v15 = *v18;
  *unint64_t v18 = v15;
  *(void *)(v21 + 8 * v4) = v18;
  if (*v15)
  {
    unint64_t v32 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v32 >= v12) {
        v32 %= v12;
      }
    }
    else
    {
      v32 &= v12 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_180D10AD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  int8x8_t v2 = *(id **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {

    }
    operator delete(v2);
  }
  return a1;
}

uint64_t GPU::EncodeDescriptor::commitAndContinue(GPU::EncodeDescriptor *this)
{
  int8x8_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    [v2 endEncoding];
    uint64_t v3 = (void *)*((void *)this + 9);
    *((void *)this + 9) = 0;
  }
  unint64_t v4 = (void *)*((void *)this + 1);

  return [v4 commitAndContinue];
}

uint64_t GPU::EncodeDescriptor::commitAndContinueDynamicallyChanges(GPU::EncodeDescriptor *this)
{
  return 0;
}

void GPU::EncodeDescriptor::~EncodeDescriptor(GPU::EncodeDescriptor *this)
{
  *(void *)this = &unk_1EC9887A0;
  int8x8_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    [v2 endEncoding];
    uint64_t v3 = (void *)*((void *)this + 9);
    *((void *)this + 9) = 0;
  }
  unint64_t v4 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;

  unint64_t v5 = (id *)*((void *)this + 6);
  if (v5)
  {
    do
    {
      uint64_t v6 = (id *)*v5;

      operator delete(v5);
      unint64_t v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = (void *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v7) {
    operator delete(v7);
  }
}

void *GPURegionRuntime::setStaticJITypeForValue(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  unint64_t v9 = a3;
  unint64_t v10 = a2;
  if (isStaticMPSType((uint64_t **)(a2[1] & 0xFFFFFFFFFFFFFFF8))) {
    __assert_rtn("setStaticJITypeForValue", "MPSRuntime_Project.h", 728, "!isStaticMPSType(value.getType())");
  }
  if ((isStaticMPSType(a3) & 1) == 0) {
    __assert_rtn("setStaticJITypeForValue", "MPSRuntime_Project.h", 729, "isStaticMPSType(type)");
  }
  if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 448) + 24))(*(void *)(a1 + 448), a2)) {
    __assert_rtn("setStaticJITypeForValue", "MPSRuntime_Project.h", 730, "!_tiAndFoldHelper->hasType(value) && \"static type already defined\"");
  }
  uint64_t v8 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v10) + 2);
  unint64_t v11 = &v8;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(a1 + 304, &v8, (uint64_t)&std::piecewise_construct, &v11)+ 24;
  unint64_t v11 = v10;
  if (std::__hash_table<std::__hash_value_type<void *,mlir::Type>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::Type>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::Type>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::Type>>>::find<void *>(v6, (uint64_t *)&v11))
  {
    __assert_rtn("setStaticJITypeForValue", "MPSRuntime_Project.h", 733, "opMap.count(value.getAsOpaquePointer()) == 0 && \"type already computed\"");
  }
  unint64_t v11 = v10;
  return std::__hash_table<std::__hash_value_type<void *,mlir::Type>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::Type>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::Type>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::Type>>>::__emplace_unique_key_args<void *,void *,mlir::Type&>((uint64_t)v6, (uint64_t *)&v11, &v11, (uint64_t *)&v9);
}

char *std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint8x8_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (char *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = *((void *)v14 + 1);
            if (v16 == v10)
            {
              if (*((void *)v14 + 2) == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = *(char **)v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            if (*((void *)v14 + 2) == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  uint64_t v17 = (void *)(a1 + 16);
  uint64_t v14 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v10;
  *((void *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *(void *)uint64_t v14 = *v21;
LABEL_61:
      *uint64_t v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * v10);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v10;
      uint64_t v20 = *(void *)a1;
      uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v29 & v10));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *(void *)uint64_t v14 = *v17;
  *uint64_t v17 = v14;
  *(void *)(v20 + 8 * v4) = v17;
  if (*(void *)v14)
  {
    unint64_t v30 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11) {
        v30 %= v11;
      }
    }
    else
    {
      v30 &= v11 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_180D11134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (void *)v2[5];
      if (v3)
      {
        do
        {
          unint64_t v4 = (void *)*v3;
          operator delete(v3);
          uint64_t v3 = v4;
        }
        while (v4);
      }
      unint64_t v5 = (void *)v2[3];
      v2[3] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<void *,mlir::Type>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::Type>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::Type>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::Type>>>::find<void *>(void *a1, uint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = HIDWORD(*a2);
  unint64_t v5 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v4);
  unint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v2);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = v6;
    if (v6 >= *(void *)&v2) {
      unint64_t v8 = v6 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v8 = v6 & (*(void *)&v2 - 1);
  }
  unint64_t v9 = *(void **)(*a1 + 8 * v8);
  if (!v9) {
    return 0;
  }
  unint64_t result = (void *)*v9;
  if (*v9)
  {
    if (v7.u32[0] < 2uLL)
    {
      uint64_t v11 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v13 = result[1];
        if (v6 == v13)
        {
          if (result[2] == v3) {
            return result;
          }
        }
        else if ((v13 & v11) != v8)
        {
          return 0;
        }
        unint64_t result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v12 = result[1];
      if (v6 == v12)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v12 >= *(void *)&v2) {
          v12 %= *(void *)&v2;
        }
        if (v12 != v8) {
          return 0;
        }
      }
      unint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<void *,mlir::Type>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::Type>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::Type>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::Type>>>::__emplace_unique_key_args<void *,void *,mlir::Type&>(uint64_t a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  uint64_t v8 = *a2;
  unint64_t v9 = HIDWORD(*a2);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v9);
  unint64_t v11 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = v11 & (v12 - 1);
    }
    uint64_t v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      unint64_t v15 = *v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == v8) {
                return v15;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_23;
            }
            unint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == v8) {
              return v15;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_23:
  unint64_t v15 = operator new(0x20uLL);
  *unint64_t v15 = 0;
  v15[1] = v11;
  uint64_t v18 = *a4;
  void v15[2] = *a3;
  v15[3] = v18;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v12 && (float)(v20 * (float)v12) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      *unint64_t v15 = *v22;
LABEL_61:
      *BOOL v22 = v15;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 8);
    }
    if (prime > v12) {
      goto LABEL_37;
    }
    if (prime < v12)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v12) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    unint64_t v30 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
      {
        unint64_t v4 = v11 % v12;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v11);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v11;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v30 & v11));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  *unint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v15)
  {
    unint64_t v31 = *(void *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v31 >= v12) {
        v31 %= v12;
      }
    }
    else
    {
      v31 &= v12 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_180D11610(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::evaluateOps(GPU::EncodeDescriptor *,NSArray<MPSGraphTensorData *> *,NSArray<MPSGraphTensorData *> *)::$_1::operator() const(mlir::FunctionOpInterface)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(GPURegionRuntime **)(a1 + 8);
  unint64_t v5 = *(mlir::Block **)(a2 + 16);
  if (v5)
  {
    uint64_t ParentOp = mlir::Block::getParentOp(v5);
    uint64_t v7 = ParentOp;
    if (ParentOp)
    {
      if (!mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(ParentOp))
      {
        if (**(void **)a1) {
          return;
        }
        goto LABEL_10;
      }
      if (!mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v7)) {
        __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (v7 != **(void **)a1) {
    return;
  }
LABEL_10:
  GPURegionRuntime::encodeOp(v4, (mlir::GenericProgramPoint ***)a2, **(id ***)(a1 + 16));
  uint64_t v8 = **(void **)(a1 + 16);
  if (*(unsigned char *)(v8 + 25))
  {
    unint64_t v9 = *(void **)(v8 + 72);
    if (v9)
    {
      [v9 endEncoding];
      unint64_t v10 = *(void **)(v8 + 72);
      *(void *)(v8 + 72) = 0;

      uint64_t v8 = **(void **)(a1 + 16);
    }
  }
  if (*(unsigned char *)(v8 + 24) || **(unsigned char **)(a1 + 24))
  {
    uint64_t v11 = computeProducedValues(a2, v4, 0, 0, 0);
    if (v11)
    {
      unint64_t v12 = *(unint64_t **)(a1 + 32);
      uint8x8_t v13 = *(unint64_t **)(a1 + 40);
      unint64_t v14 = *v12 + 1;
      unint64_t v15 = v12[1] + v11;
      *unint64_t v12 = v14;
      v12[1] = v15;
      if (v15 >= *v13
        || v14 >= **(void **)(a1 + 48)
        || v15 >= **(void **)(a1 + 56) && v14 >= **(void **)(a1 + 64))
      {
        unint64_t v16 = **(unsigned char ***)(a1 + 16);
        if (v16[24]
          || **(unsigned char **)(a1 + 24)
          && ((*(void (**)(unsigned char *))(*(void *)v16 + 16))(v16), unint64_t v16 = **(unsigned char ***)(a1 + 16), v16[24]))
        {
          (**(void (***)(unsigned char *))v16)(v16);
          uint64_t v17 = *(void **)(a1 + 32);
          *uint64_t v17 = 0;
          v17[1] = 0;
        }
      }
    }
  }
}

uint64_t computeProducedValues(uint64_t result, GPURegionRuntime *a2, char a3, unint64_t *a4, MPSDataType *a5)
{
  if (result)
  {
    uint64_t v9 = result;
    if (llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible(result)
      || llvm::DefaultDoCastIfPossible<mlir::mps::ReshapeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReshapeOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::ExpandDimsOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ExpandDimsOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::TypeConstraintOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TypeConstraintOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::scf::WhileOp,mlir::Operation *,llvm::CastInfo<mlir::scf::WhileOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::scf::ForOp,mlir::Operation *,llvm::CastInfo<mlir::scf::ForOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::scf::IfOp,mlir::Operation *,llvm::CastInfo<mlir::scf::IfOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::DynamicShapeCastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DynamicShapeCastOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::VariableFromTensorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::VariableFromTensorOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::ReadVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReadVariableOp,mlir::Operation *,void>>::doCastIfPossible(v9)
      || llvm::DefaultDoCastIfPossible<mlir::mps::AssignVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AssignVariableOp,mlir::Operation *,void>>::doCastIfPossible(v9))
    {
      return 0;
    }
    if (a4) {
      *a4 = 0;
    }
    uint64_t v10 = *(unsigned int *)(v9 + 36);
    uint64_t v11 = v10 ? v9 - 16 : 0;
    unint64_t result = 0;
    if (v10)
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        uint64_t v13 = result;
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, i);
        uint64_t v15 = NextResultAtOffset;
        unint64_t v37 = 0;
        if (a2)
        {
          if ((*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 56) + 48))(*((void *)a2 + 56), NextResultAtOffset))goto LABEL_25; {
          unint64_t StaticType = GPURegionRuntime::getStaticType((uint64_t)a2, v15);
          }
          if (!StaticType) {
            goto LABEL_66;
          }
        }
        else
        {
          unint64_t StaticType = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
          if (!StaticType) {
            goto LABEL_66;
          }
        }
        if (!*(void *)StaticType) {
          goto LABEL_67;
        }
        if (*(_UNKNOWN **)(*(void *)StaticType + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          unint64_t v37 = StaticType;
          uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
          if (!v18)
          {
            uint64_t v27 = 1;
            goto LABEL_42;
          }
          uint64_t v19 = (v18 - 1) & 0x1FFFFFFFFFFFFFFFLL;
          if (v19)
          {
            uint64_t v20 = v19 + 1;
            uint64_t v21 = (v19 + 1) & 0x3FFFFFFFFFFFFFFELL;
            BOOL v22 = (uint64_t *)(Value + 8 * v21);
            BOOL v23 = (void *)(Value + 8);
            uint64_t v24 = v21;
            uint64_t v25 = 1;
            uint64_t v26 = 1;
            do
            {
              v25 *= *(v23 - 1);
              v26 *= *v23;
              v23 += 2;
              v24 -= 2;
            }
            while (v24);
            uint64_t v27 = v26 * v25;
            if (v20 == v21)
            {
LABEL_42:
              if (a3)
              {
                *a5 = MPSDataTypeFloat32;
                uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v15);
                if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
                {
                  MPSDataType v29 = MPSDataTypeFloat16;
                  goto LABEL_50;
                }
                if (mlir::Type::isBF16((mlir::Type *)&ElementTypeOrSelf))
                {
                  MPSDataType v29 = MPSDataTypeBFloat16;
                  goto LABEL_50;
                }
                if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
                {
                  MPSDataType v29 = MPSDataTypeInt16;
LABEL_50:
                  *a5 = v29;
                  uint64_t v30 = 2;
                }
                else if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8))
                {
                  *a5 = MPSDataTypeInt8;
                  uint64_t v30 = 1;
                }
                else
                {
                  uint64_t v31 = ElementTypeOrSelf;
                  if (!ElementTypeOrSelf) {
LABEL_66:
                  }
                    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
                  if (!*(void *)ElementTypeOrSelf) {
LABEL_67:
                  }
                    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
                  unint64_t v32 = *(void **)(*(void *)ElementTypeOrSelf + 136);
                  if (v32 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
                    uint64_t v31 = 0;
                  }
                  uint64_t v35 = v31;
                  if (v32 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
                  {
                    MPSDataType v33 = MPSDataTypeComplexFloat16;
                    uint64_t v34 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v35);
                    if (mlir::Type::isF32((mlir::Type *)&v34))
                    {
                      MPSDataType v33 = MPSDataTypeComplexFloat32;
                      uint64_t v30 = 8;
                    }
                    else
                    {
                      uint64_t v34 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v35);
                      if (!mlir::Type::isF16((mlir::Type *)&v34)) {
                        __assert_rtn("computeProducedValues", "MPSRuntime.mm", 355, "0 && \"unsupported complex type\"");
                      }
                      uint64_t v30 = 4;
                    }
                    *a5 = v33;
                  }
                  else
                  {
                    uint64_t v30 = 4;
                  }
                }
              }
              else
              {
                uint64_t v30 = 1;
              }
              v13 += v30 * v27;
              if (a4) {
                *a4 += v27;
              }
              goto LABEL_25;
            }
          }
          else
          {
            BOOL v22 = (uint64_t *)Value;
            uint64_t v27 = 1;
          }
          do
          {
            uint64_t v28 = *v22++;
            v27 *= v28;
          }
          while (v22 != (uint64_t *)(Value + 8 * v18));
          goto LABEL_42;
        }
LABEL_25:
        unint64_t result = v13;
      }
    }
  }
  return result;
}

uint64_t mlir::Type::dyn_cast<mlir::ComplexType>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!*(void *)v1) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)v1 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    return *a1;
  }
  else {
    return 0;
  }
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x736E6F632E73706DLL && *(_DWORD *)(AttrData + 8) == 1953390964)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.constant";
      v8[3] = 12;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ExpandDimsOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ExpandDimsOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x617078652E73706DLL && *(void *)((char *)AttrData + 7) == 0x736D69645F646E61)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.expand_dims";
      v8[3] = 15;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x657571732E73706DLL && *(void *)((char *)AttrData + 3) == 0x657A65657571732ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.squeeze";
      v8[3] = 11;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6D7265702E73706DLL && *(void *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.permute";
      v8[3] = 11;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x6E6172742E73706DLL && *(void *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.transpose";
      v8[3] = 13;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TypeConstraintOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TypeConstraintOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x657079742E73706DLL
      && AttrData[1] == 0x617274736E6F635FLL
      && *(void *)((char *)AttrData + 11) == 0x746E69617274736ELL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.type_constraint";
      v9[3] = 19;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::scf::WhileOp,mlir::Operation *,llvm::CastInfo<mlir::scf::WhileOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6C6968772E666373 && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"scf.while";
      v8[3] = 9;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::scf::ForOp,mlir::Operation *,llvm::CastInfo<mlir::scf::ForOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 778462067 && *(_DWORD *)((char *)AttrData + 3) == 1919903278)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"scf.for";
      v8[3] = 7;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::scf::IfOp,mlir::Operation *,llvm::CastInfo<mlir::scf::IfOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 6 && *(_DWORD *)AttrData == 778462067 && *(_WORD *)(AttrData + 4) == 26217)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"scf.if";
      v8[3] = 6;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DynamicShapeCastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DynamicShapeCastOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 22
      && *AttrData == 0x616E79642E73706DLL
      && AttrData[1] == 0x706168735F63696DLL
      && *(void *)((char *)AttrData + 14) == 0x747361635F657061)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.dynamic_shape_cast";
      v9[3] = 22;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::VariableFromTensorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::VariableFromTensorOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 24
      && *AttrData == 0x697261762E73706DLL
      && AttrData[1] == 0x6F72665F656C6261
      && AttrData[2] == 0x726F736E65745F6DLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.variable_from_tensor";
      v9[3] = 24;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReadVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReadVariableOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x646165722E73706DLL
      && *(void *)(AttrData + 8) == 0x6C6261697261765FLL
      && *(unsigned char *)(AttrData + 16) == 101)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.read_variable";
      v9[3] = 17;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AssignVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AssignVariableOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x697373612E73706DLL
      && AttrData[1] == 0x61697261765F6E67
      && *(void *)((char *)AttrData + 11) == 0x656C626169726176)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.assign_variable";
      v9[3] = 19;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AssignVariableOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x636E6F632E73706DLL && *(_WORD *)(AttrData + 8) == 29793)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.concat";
      v8[3] = 10;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::StridedSliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StridedSliceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x697274732E73706DLL
      && *(void *)(AttrData + 8) == 0x63696C735F646564
      && *(unsigned char *)(AttrData + 16) == 101)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mps.strided_slice";
      v9[3] = 17;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x63696C732E73706DLL && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.slice";
      v8[3] = 9;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x706F72632E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.crop";
      v7[3] = 8;
      unint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Flatten2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Flatten2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x74616C662E73706DLL && *(void *)((char *)AttrData + 6) == 0x64325F6E65747461)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.flatten_2d";
      v8[3] = 14;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Flatten2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mpsx::StitchedOp,mlir::Operation *,llvm::CastInfo<mlir::mpsx::StitchedOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x6974732E7873706DLL && *(void *)((char *)AttrData + 5) == 0x6465686374697473)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mpsx.stitched";
      v8[3] = 13;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
  {
    return 0;
  }
  return result;
}

void *std::__hash_table<mlir::Operation *,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,std::allocator<mlir::Operation *>>::__emplace_unique_key_args<mlir::Operation *,mlir::Operation * const&>(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = HIDWORD(*a2);
  unint64_t v8 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      uint64_t v13 = (void *)*v12;
      if (*v12)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == v6) {
                return v13;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_23;
            }
            uint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == v6) {
              return v13;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_23:
  uint64_t v17 = operator new(0x18uLL);
  *uint64_t v17 = 0;
  v17[1] = v9;
  v17[2] = *a3;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v10 && (float)(v19 * (float)v10) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
    if (v21)
    {
LABEL_26:
      *uint64_t v17 = *v21;
LABEL_61:
      *uint64_t v21 = v17;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v10 >= 3) {
      BOOL v22 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v10);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *(void *)(a1 + 8);
    }
    if (prime > v10) {
      goto LABEL_37;
    }
    if (prime < v10)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v10 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v10) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v10 = *(void *)(a1 + 8);
    unint64_t v29 = v10 - 1;
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
      {
        unint64_t v3 = v9 % v10;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v9 % v10));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v3 = v9;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * v9);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v3 = v29 & v9;
      uint64_t v20 = *(void *)a1;
      uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v29 & v9));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *uint64_t v17 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v17;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v17)
  {
    unint64_t v30 = *(void *)(*v17 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v30 >= v10) {
        v30 %= v10;
      }
    }
    else
    {
      v30 &= v10 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v17;
}

void sub_180D13228(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CallOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CallOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6C6C61632E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.call";
      v7[3] = 8;
      uint8x8_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CallOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::placement::MemrefToTensor,mlir::Operation *,llvm::CastInfo<mlir::placement::MemrefToTensor,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  int8x8_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 26
      && *(void *)AttrData == 0x6E656D6563616C70
      && *(void *)(AttrData + 8) == 0x6665726D656D2E74
      && *(void *)(AttrData + 16) == 0x736E65745F6F745FLL
      && *(_WORD *)(AttrData + 24) == 29295)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      int v10[2] = (uint64_t)"placement.memref_to_tensor";
      v10[3] = 26;
      __int16 v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
  {
    return 0;
  }
  return result;
}

void ___ZZN26FullyPlacedOnANEMPSRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPbENK3__0clEv_block_invoke(uint64_t a1, void *a2, unint64_t a3, unsigned char *a4)
{
  __int16 v8 = a2;
  if (!v8) {
    goto LABEL_5;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  if ([(MPSGraphTensorData *)v8 tensorDataType]) {
    goto LABEL_5;
  }
  if (*(unsigned int *)(v7 + 792) <= a3) {
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  if (GPU::TensorToMemrefOpHandler::inputRequiresCopy(*(GPU::TensorToMemrefOpHandler **)(*(void *)(v7 + 784) + 8 * a3), v8))
  {
LABEL_5:
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_180D1365C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZZN26FullyPlacedOnANEMPSRuntime11evaluateOpsEP7NSArrayIP18MPSGraphTensorDataES4_P37MPSGraphExecutableExecutionDescriptorP16MPSCommandBufferbbbPbENK3__0clEv_block_invoke_2(uint64_t a1, void *a2, unint64_t a3, unsigned char *a4)
{
  id v13 = a2;
  if (!v13) {
    goto LABEL_3;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  if ([v13 tensorDataType]) {
    goto LABEL_3;
  }
  if (*(unsigned int *)(v7 + 856) <= a3) {
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  uint64_t v8 = *(void *)(*(void *)(v7 + 848) + 8 * a3);
  id v9 = v13;
  if (![v9 iosurface])
  {

    goto LABEL_3;
  }
  uint64_t v10 = [v9 mpsndarray];
  uint64_t v11 = *(void *)&v10[*MEMORY[0x1E4F359D0]];
  uint64_t v12 = *(void *)(v8 + 120);

  if (v11 != v12)
  {
LABEL_3:
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_180D1377C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_180D13794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::vector<long>::__throw_length_error[abi:ne180100]()
{
}

void std::__hash_table<std::__hash_value_type<void *,BaseTensor *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,BaseTensor *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,BaseTensor *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,BaseTensor *>>>::__emplace_unique_key_args<void *,std::pair<void *,BaseTensor *>>(float *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = v9 ^ (v9 >> 47);
  unint64_t v11 = 0x9DDFEA08EB382D69 * v10;
  unint64_t v12 = *((void *)a1 + 1);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * v10;
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v11;
    }
    unint64_t v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == a2) {
                return;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == a2) {
              return;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_22:
  float v18 = operator new(0x20uLL);
  *float v18 = 0;
  v18[1] = v11;
  v18[2] = a3;
  v18[3] = a4;
  float v19 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v20 = a1[8];
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *((void *)a1 + 1);
    }
    if (prime > v12)
    {
LABEL_36:
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint8x8_t v27 = operator new(8 * prime);
      uint64_t v28 = *(void **)a1;
      *(void *)a1 = v27;
      if (v28) {
        operator delete(v28);
      }
      uint64_t v29 = 0;
      *((void *)a1 + 1) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v29++) = 0;
      while (prime != v29);
      uint64_t v31 = (uint64_t *)(a1 + 4);
      unint64_t v30 = (void *)*((void *)a1 + 2);
      if (!v30) {
        goto LABEL_68;
      }
      size_t v32 = v30[1];
      size_t v33 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v34 = v32 & v33;
        *(void *)(*(void *)a1 + 8 * v34) = v31;
        for (uint64_t i = (void *)*v30; *v30; uint64_t i = (void *)*v30)
        {
          size_t v36 = i[1] & v33;
          if (v36 == v34)
          {
            unint64_t v30 = i;
          }
          else if (*(void *)(*(void *)a1 + 8 * v36))
          {
            *unint64_t v30 = *i;
            uint64_t v37 = 8 * v36;
            *uint64_t i = **(void **)(*(void *)a1 + v37);
            **(void **)(*(void *)a1 + v37) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v36) = v30;
            unint64_t v30 = i;
            size_t v34 = v36;
          }
        }
        goto LABEL_68;
      }
      if (v32 >= prime) {
        v32 %= prime;
      }
      *(void *)(*(void *)a1 + 8 * v32) = v31;
      int v41 = (void *)*v30;
      if (!*v30)
      {
LABEL_68:
        unint64_t v12 = prime;
        uint64_t v44 = prime - 1;
        if ((prime & (prime - 1)) != 0) {
          goto LABEL_69;
        }
        goto LABEL_84;
      }
      while (1)
      {
        size_t v43 = v41[1];
        if (v43 >= prime) {
          v43 %= prime;
        }
        if (v43 == v32) {
          goto LABEL_62;
        }
        if (*(void *)(*(void *)a1 + 8 * v43))
        {
          *unint64_t v30 = *v41;
          uint64_t v42 = 8 * v43;
          *int v41 = **(void **)(*(void *)a1 + v42);
          **(void **)(*(void *)a1 + v42) = v41;
          int v41 = v30;
LABEL_62:
          unint64_t v30 = v41;
          int v41 = (void *)*v41;
          if (!v41) {
            goto LABEL_68;
          }
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v43) = v30;
          unint64_t v30 = v41;
          int v41 = (void *)*v41;
          size_t v32 = v43;
          if (!v41) {
            goto LABEL_68;
          }
        }
      }
    }
    if (prime < v12)
    {
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v12 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime < v12)
      {
        if (!prime)
        {
          uint64_t v45 = *(void **)a1;
          *(void *)a1 = 0;
          if (v45) {
            operator delete(v45);
          }
          unint64_t v12 = 0;
          *((void *)a1 + 1) = 0;
          uint64_t v44 = -1;
          goto LABEL_84;
        }
        goto LABEL_36;
      }
      unint64_t v12 = *((void *)a1 + 1);
    }
    uint64_t v44 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
LABEL_69:
      if (v11 >= v12)
      {
        unint64_t v4 = v11 % v12;
        uint64_t v21 = *(void **)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
        if (v22) {
          goto LABEL_25;
        }
      }
      else
      {
        unint64_t v4 = v11;
        uint64_t v21 = *(void **)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v11);
        if (v22) {
          goto LABEL_25;
        }
      }
      goto LABEL_85;
    }
LABEL_84:
    unint64_t v4 = v44 & v11;
    uint64_t v21 = *(void **)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * (v44 & v11));
    if (v22) {
      goto LABEL_25;
    }
    goto LABEL_85;
  }
  uint64_t v21 = *(void **)a1;
  BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
LABEL_25:
    *float v18 = *v22;
LABEL_91:
    *BOOL v22 = v18;
    goto LABEL_92;
  }
LABEL_85:
  *float v18 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v18;
  v21[v4] = a1 + 4;
  if (*v18)
  {
    unint64_t v46 = *(void *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v46 >= v12) {
        v46 %= v12;
      }
    }
    else
    {
      v46 &= v12 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v46);
    goto LABEL_91;
  }
LABEL_92:
  ++*((void *)a1 + 3);
}

void sub_180D13C90(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(uint64_t **a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    goto LABEL_20;
  }
  uint64_t v3 = *v1;
  uint64_t v4 = v1[17];
  uint64_t v5 = mlir::TypeID::get<mlir::ElementsAttr>();
  BOOL v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ElementsAttr]";
  unint64_t v23 = 68;
  unint64_t v6 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
  unint64_t v8 = v22;
  unint64_t v7 = v23;
  if (v23 >= v6) {
    unint64_t v9 = v6;
  }
  else {
    unint64_t v9 = v23;
  }
  unint64_t v10 = v23 - v9;
  unint64_t v11 = &v22[v9];
  BOOL v22 = v11;
  unint64_t v23 = v10;
  if (v7 <= v6) {
    __assert_rtn("getTypeName", "TypeName.h", 33, "!Name.empty() && \"Unable to find the template parameter!\"");
  }
  if (v10 <= 0x11) {
    __assert_rtn("drop_front", "StringRef.h", 614, "size() >= N && \"Dropping more elements than exist\"");
  }
  BOOL v22 = v11 + 18;
  unint64_t v23 = v10 - 18;
  if (v10 == 18 || v8[v7 - 1] != 93) {
    __assert_rtn("getTypeName", "TypeName.h", 36, "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"");
  }
  mlir::dialect_extension_detail::handleUseOfUndefinedPromisedInterface(v3, v4, v5);
  unint64_t v12 = *a1;
  if (!v12) {
LABEL_20:
  }
    __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
  unint64_t v13 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v14 = *((unsigned int *)v12 + 4);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = (void *)v12[1];
  unint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    float v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    float v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    return v15[1];
  }
  else {
    return 0;
  }
}

BOOL _ZN4llvm3isaIN4mlir4mpsx16ReturnStitchedOpENS1_3mps10IdentityOpEJEPNS1_9OperationEEEbRKT2_(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v21[0] = *(void *)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v21);
    if (v6 == 20)
    {
      BOOL v7 = *(void *)AttrData == 0x6974732E7873706DLL && *(void *)(AttrData + 8) == 0x65725F6465686374;
      if (v7 && *(_DWORD *)(AttrData + 16) == 1852994932)
      {
        __int16 v20 = 1283;
        unint64_t v17 = "classof on '";
        float v18 = "mpsx.stitched_return";
        uint64_t v14 = 20;
        goto LABEL_22;
      }
    }
  }
  else if (v3 == &mlir::detail::TypeIDResolver<mlir::mpsx::ReturnStitchedOp,void>::id)
  {
    return 1;
  }
  uint64_t v9 = *(void *)(*(void *)a1 + 48);
  unint64_t v10 = *(void **)(v9 + 16);
  if (v10 != &mlir::detail::TypeIDResolver<void,void>::id) {
    return v10 == &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id;
  }
  v21[0] = *(void *)(v9 + 8);
  uint64_t v11 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v21);
  if (v12 == 12 && *(void *)v11 == 0x6E6564692E73706DLL && *(_DWORD *)(v11 + 8) == 2037672308)
  {
    __int16 v20 = 1283;
    unint64_t v17 = "classof on '";
    float v18 = "mps.identity";
    uint64_t v14 = 12;
LABEL_22:
    uint64_t v19 = v14;
    uint64_t v15 = "' failed due to the operation not being registered";
    __int16 v16 = 259;
    llvm::operator+((uint64_t *)&v17, (uint64_t *)&v15, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  return 0;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mpsx::ReturnStitchedOp,mlir::Operation *,llvm::CastInfo<mlir::mpsx::ReturnStitchedOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 20
      && *(void *)AttrData == 0x6974732E7873706DLL
      && *(void *)(AttrData + 8) == 0x65725F6465686374
      && *(_DWORD *)(AttrData + 16) == 1852994932)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      void v9[2] = (uint64_t)"mpsx.stitched_return";
      v9[3] = 20;
      BOOL v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mpsx::ReturnStitchedOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::IdentityOp,mlir::Operation *,llvm::CastInfo<mlir::mps::IdentityOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x6E6564692E73706DLL && *(_DWORD *)(AttrData + 8) == 2037672308)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.identity";
      v8[3] = 12;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t std::unordered_map<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong}>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::unordered_map<mlir::Operation *,std::unordered_map<void *,mlir::ElementsAttr>>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      uint64_t v6 = (void *)v2[5];
      if (v6)
      {
        do
        {
          __int16 v7 = (void *)*v6;
          operator delete(v6);
          uint64_t v6 = v7;
        }
        while (v7);
      }
      __int16 v8 = (void *)v2[3];
      v2[3] = 0;
      if (v8) {
        operator delete(v8);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t std::unordered_map<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      uint64_t v6 = v2[3];
      v2[3] = 0;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void BaseRuntime::~BaseRuntime(BaseRuntime *this)
{
  *(void *)this = &unk_1EC995440;

  std::mutex::~mutex((std::mutex *)((char *)this + 144));
  uint64_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    do
    {
      uint64_t v6 = (void *)*v2;
      __int16 v7 = (id *)v2[5];
      if (v7)
      {
        do
        {
          __int16 v8 = (id *)*v7;

          operator delete(v7);
          __int16 v7 = v8;
        }
        while (v8);
      }
      __int16 v9 = (void *)v2[3];
      v2[3] = 0;
      if (v9) {
        operator delete(v9);
      }
      operator delete(v2);
      uint64_t v2 = v6;
    }
    while (v6);
  }
  uint64_t v3 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v3) {
    operator delete(v3);
  }

  objc_destroyWeak((id *)this + 9);
  objc_destroyWeak((id *)this + 7);

  uint64_t v4 = (void **)*((void *)this + 3);
  if (v4)
  {
    do
    {
      __int16 v10 = (void **)*v4;
      if (*((char *)v4 + 39) < 0) {
        operator delete(v4[2]);
      }
      operator delete(v4);
      uint64_t v4 = v10;
    }
    while (v10);
  }
  uint64_t v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v5) {
    operator delete(v5);
  }
}

uint64_t *std::unique_ptr<mlir::ShapeEquivalence>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *unint64_t result = a2;
  if (v2) {
    llvm::deallocate_buffer(*(llvm **)(v2 + 208), (void *)(16 * *(unsigned int *)(v2 + 224)));
  }
  return result;
}

void std::default_delete<GPU::RuntimeExecutionReport>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a2 + 128);
    if (v3 != (void *)(a2 + 144)) {
      free(v3);
    }
    uint64_t v4 = *(unsigned int *)(a2 + 120);
    uint64_t v5 = *(llvm **)(a2 + 104);
    if (v4)
    {
      uint64_t v6 = 80 * v4;
      __int16 v7 = (char *)v5 + 32;
      do
      {
        if (*((void *)v7 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          __int16 v8 = (char *)*((void *)v7 - 2);
          if (v7 != v8) {
            free(v8);
          }
        }
        v7 += 80;
        v6 -= 80;
      }
      while (v6);
      uint64_t v5 = *(llvm **)(a2 + 104);
      uint64_t v9 = 80 * *(unsigned int *)(a2 + 120);
    }
    else
    {
      uint64_t v9 = 0;
    }
    llvm::deallocate_buffer(v5, (void *)v9);
  }
}

void sub_180D14880()
{
  uint64_t v1 = *(void **)(v0 + 40);
  if (v1 != (void *)(v0 + 56)) {
    free(v1);
  }
  JUMPOUT(0x1852FDE70);
}

uint64_t std::unordered_map<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      uint64_t v6 = (id *)v2[5];
      if (v6)
      {
        do
        {
          __int16 v7 = (id *)*v6;

          operator delete(v6);
          uint64_t v6 = v7;
        }
        while (v7);
      }
      __int16 v8 = (void *)v2[3];
      v2[3] = 0;
      if (v8) {
        operator delete(v8);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t std::unordered_map<std::string,MPSMLIROps>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__deallocate_node(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_180D14AAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  GPURegionRuntime::TIAndFoldHelper::~TIAndFoldHelper(v12);
}

uint64_t mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(uint64_t **a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    goto LABEL_20;
  }
  uint64_t v3 = *v1;
  uint64_t v4 = v1[17];
  uint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  BOOL v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ShapedType]";
  unint64_t v23 = 66;
  unint64_t v6 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
  __int16 v8 = v22;
  unint64_t v7 = v23;
  if (v23 >= v6) {
    unint64_t v9 = v6;
  }
  else {
    unint64_t v9 = v23;
  }
  unint64_t v10 = v23 - v9;
  uint64_t v11 = &v22[v9];
  BOOL v22 = v11;
  unint64_t v23 = v10;
  if (v7 <= v6) {
    __assert_rtn("getTypeName", "TypeName.h", 33, "!Name.empty() && \"Unable to find the template parameter!\"");
  }
  if (v10 <= 0x11) {
    __assert_rtn("drop_front", "StringRef.h", 614, "size() >= N && \"Dropping more elements than exist\"");
  }
  BOOL v22 = v11 + 18;
  unint64_t v23 = v10 - 18;
  if (v10 == 18 || v8[v7 - 1] != 93) {
    __assert_rtn("getTypeName", "TypeName.h", 36, "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"");
  }
  mlir::dialect_extension_detail::handleUseOfUndefinedPromisedInterface(v3, v4, v5);
  uint64_t v12 = *a1;
  if (!v12) {
LABEL_20:
  }
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *((unsigned int *)v12 + 4);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = (void *)v12[1];
  __int16 v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    float v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    uint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    return v15[1];
  }
  else {
    return 0;
  }
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E4FBE4D0, MEMORY[0x1E4FBA1D0]);
}

void sub_180D14CDC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  unint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::RuntimeExecutionReport::RuntimeExecutionReport(mlir::ModuleOp)::$_0>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(mlir::Block **)(a2 + 16);
  if (v4)
  {
    uint64_t ParentOp = mlir::Block::getParentOp(v4);
    uint64_t v6 = ParentOp;
    if (ParentOp
      && mlir::OpInterface<mlir::TargetLegalizerInterface,mlir::detail::TargetLegalizerInterfaceInterfaceTraits>::getInterfaceFor(ParentOp))
    {
      ++*(void *)(v3 + 24);
    }
    *(void *)&v92[0] = llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(a2);
    if (!*(void *)&v92[0]) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v6 = 0;
    *(void *)&v92[0] = llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(a2);
    if (!*(void *)&v92[0]) {
      goto LABEL_12;
    }
  }
  if (mlir::placement::RegionCall::getRegionType((mlir::Operation **)v92) == 1)
  {
    uint64_t v7 = *(unsigned int *)(v3 + 48);
    if (v7 >= *(_DWORD *)(v3 + 52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 40, (void *)(v3 + 56), v7 + 1, 8);
      *(void *)(*(void *)(v3 + 40) + 8 * *(unsigned int *)(v3 + 48)) = a2;
      unsigned int v8 = *(_DWORD *)(v3 + 48);
      if (v8 >= *(_DWORD *)(v3 + 52)) {
        goto LABEL_139;
      }
    }
    else
    {
      *(void *)(*(void *)(v3 + 40) + 8 * v7) = a2;
      unsigned int v8 = *(_DWORD *)(v3 + 48);
      if (v8 >= *(_DWORD *)(v3 + 52)) {
        goto LABEL_139;
      }
    }
    *(_DWORD *)(v3 + 48) = v8 + 1;
  }
LABEL_12:
  uint64_t v9 = *(void *)(a2 + 48);
  if (*(_UNKNOWN **)(v9 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&v92[0] = *(void *)(v9 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v92);
    if (*(void *)(Values + 16) != 3) {
      return;
    }
  }
  else
  {
    uint64_t Values = *(void *)(v9 + 24);
    if (*(void *)(Values + 16) != 3) {
      return;
    }
  }
  uint64_t v11 = *(unsigned __int16 **)(Values + 8);
  int v12 = *v11;
  int v13 = *((unsigned __int8 *)v11 + 2);
  if (v12 == 28781 && v13 == 115)
  {
    uint64_t v15 = *(void *)(v6 + 48);
    __int16 v16 = *(void **)(v15 + 16);
    if (v16 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      *(void *)&v92[0] = *(void *)(v15 + 8);
      uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
      if (v18 == 13 && *AttrData == 0x6974732E7873706DLL && *(void *)((char *)AttrData + 5) == 0x6465686374697473) {
        goto LABEL_141;
      }
    }
    else if (v16 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_66;
    }
    uint64_t v20 = *(void *)(a2 + 48);
    uint64_t v21 = *(void **)(v20 + 16);
    if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      *(void *)&v92[0] = *(void *)(v20 + 8);
      uint64_t v22 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
      if (v23 == 26)
      {
        BOOL v24 = *(void *)v22 == 0x6E656D6563616C70 && *(void *)(v22 + 8) == 0x726F736E65742E74;
        BOOL v25 = v24 && *(void *)(v22 + 16) == 0x726D656D5F6F745FLL;
        if (v25 && *(_WORD *)(v22 + 24) == 26213) {
          goto LABEL_140;
        }
      }
    }
    else if (v21 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
    {
      goto LABEL_66;
    }
    uint64_t v27 = *(void *)(a2 + 48);
    uint64_t v28 = *(void **)(v27 + 16);
    if (v28 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      *(void *)&v92[0] = *(void *)(v27 + 8);
      uint64_t v29 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
      if (v30 == 26)
      {
        BOOL v31 = *(void *)v29 == 0x6E656D6563616C70 && *(void *)(v29 + 8) == 0x6665726D656D2E74;
        BOOL v32 = v31 && *(void *)(v29 + 16) == 0x736E65745F6F745FLL;
        if (v32 && *(_WORD *)(v29 + 24) == 29295)
        {
LABEL_142:
          __int16 v91 = 1283;
          uint64_t v84 = "placement.memref_to_tensor";
          goto LABEL_143;
        }
      }
    }
    else if (v28 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
    {
      goto LABEL_66;
    }
    uint64_t v34 = *(void *)(a2 + 48);
    uint64_t v35 = *(void **)(v34 + 16);
    if (v35 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      *(void *)&v92[0] = *(void *)(v34 + 8);
      uint64_t v36 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
      if (v37 == 12 && *(void *)v36 == 0x736E6F632E73706DLL && *(_DWORD *)(v36 + 8) == 1953390964) {
        goto LABEL_144;
      }
    }
    else if (v35 == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    {
      goto LABEL_66;
    }
    ++*(void *)(v3 + 32);
LABEL_66:
    uint64_t v39 = *(void *)(a2 + 48);
    uint64_t v40 = *(void **)(v39 + 16);
    if (v40 != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      if (v40 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
        return;
      }
      goto LABEL_80;
    }
    *(void *)&v92[0] = *(void *)(v39 + 8);
    uint64_t v41 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
    if (v42 != 26
      || (*(void *)v41 == 0x6E656D6563616C70 ? (BOOL v43 = *(void *)(v41 + 8) == 0x726F736E65742E74) : (BOOL v43 = 0),
          v43 ? (BOOL v44 = *(void *)(v41 + 16) == 0x726D656D5F6F745FLL) : (BOOL v44 = 0),
          v44 ? (BOOL v45 = *(unsigned __int16 *)(v41 + 24) == 26213) : (BOOL v45 = 0),
          !v45))
    {
LABEL_80:
      uint64_t v46 = *(void *)(a2 + 48);
      uint64_t v47 = *(void **)(v46 + 16);
      if (v47 != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        if (v47 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id) {
          return;
        }
        goto LABEL_94;
      }
      *(void *)&v92[0] = *(void *)(v46 + 8);
      uint64_t v48 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
      if (v49 != 26
        || (*(void *)v48 == 0x6E656D6563616C70 ? (BOOL v50 = *(void *)(v48 + 8) == 0x6665726D656D2E74) : (BOOL v50 = 0),
            v50 ? (BOOL v51 = *(void *)(v48 + 16) == 0x736E65745F6F745FLL) : (BOOL v51 = 0),
            v51 ? (BOOL v52 = *(unsigned __int16 *)(v48 + 24) == 29295) : (BOOL v52 = 0),
            !v52))
      {
LABEL_94:
        uint64_t v53 = *(void *)(a2 + 48);
        uint64_t v54 = *(void **)(v53 + 16);
        if (v54 != &mlir::detail::TypeIDResolver<void,void>::id)
        {
          if (v54 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id) {
            return;
          }
          goto LABEL_102;
        }
        *(void *)&v92[0] = *(void *)(v53 + 8);
        uint64_t v55 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
        if (v56 != 13
          || (*v55 == 0x6974732E7873706DLL ? (BOOL v57 = *(void *)((char *)v55 + 5) == 0x6465686374697473) : (BOOL v57 = 0),
              !v57))
        {
LABEL_102:
          uint64_t v58 = *(void *)(a2 + 48);
          unint64_t v59 = *(void **)(v58 + 16);
          if (v59 != &mlir::detail::TypeIDResolver<void,void>::id)
          {
            if (v59 == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
              return;
            }
LABEL_110:
            *(void *)&v92[0] = *(void *)(*(void *)(a2 + 48) + 8);
            *(void *)&v92[0] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
            *((void *)&v92[0] + 1) = v63;
            v88[0] = 0;
            char v64 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>>>,llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>>>::LookupBucketFor<llvm::StringRef>((uint64_t *)(v3 + 104), (uint64_t)v92, v88);
            unint64_t v65 = v88[0];
            if (v64)
            {
              uint64_t v66 = *((unsigned int *)v88[0] + 6);
              unint64_t v67 = v88[0] + 3;
              if (v66 >= *((_DWORD *)v88[0] + 7))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v88[0] + 2), v88[0] + 4, v66 + 1, 8);
                LODWORD(v66) = *((_DWORD *)v65 + 6);
              }
            }
            else
            {
              unint64_t v65 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>>>,llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::SmallVector<mlir::Operation *,6u>>>::InsertIntoBucketImpl<llvm::StringRef>(v3 + 104, (uint64_t)v92, (uint64_t)v92, v88[0]);
              LODWORD(v66) = 0;
              *(_OWORD *)unint64_t v65 = v92[0];
              _OWORD v65[2] = v65 + 4;
              v65[3] = 0x600000000;
              unint64_t v67 = v65 + 3;
            }
            *(void *)(v65[2] + 8 * v66) = a2;
            unsigned int v68 = *((_DWORD *)v65 + 6);
            if (v68 < *((_DWORD *)v65 + 7))
            {
              _DWORD *v67 = v68 + 1;
              ++*(void *)(v3 + 8);
              uint64_t v69 = *(void *)(a2 + 48);
              uint64_t v70 = *(void **)(v69 + 16);
              if (v70 == &mlir::detail::TypeIDResolver<void,void>::id)
              {
                *(void *)&v92[0] = *(void *)(v69 + 8);
                long long v71 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
                if (v72 == 11 && *v71 == 0x687365722E73706DLL && *(void *)((char *)v71 + 3) == 0x657061687365722ELL)
                {
                  __int16 v91 = 1283;
                  unint64_t v83 = "mps.reshape";
                  goto LABEL_146;
                }
              }
              else if (v70 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
              {
                goto LABEL_130;
              }
              uint64_t v74 = *(void *)(a2 + 48);
              unint64_t v75 = *(void **)(v74 + 16);
              if (v75 == &mlir::detail::TypeIDResolver<void,void>::id)
              {
                *(void *)&v92[0] = *(void *)(v74 + 8);
                unint64_t v76 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
                if (v77 == 8 && *v76 == 0x747361632E73706DLL)
                {
                  __int16 v91 = 1283;
                  v88[0] = "classof on '";
                  uint64_t v89 = "mps.cast";
                  uint64_t v85 = 8;
LABEL_148:
                  uint64_t v90 = v85;
                  uint64_t v86 = "' failed due to the operation not being registered";
                  __int16 v87 = 259;
                  llvm::operator+((uint64_t *)v88, (uint64_t *)&v86, (uint64_t)v92);
                  llvm::report_fatal_error((llvm::Twine *)v92, 1);
                }
              }
              else if (v75 == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
              {
                goto LABEL_130;
              }
              uint64_t v78 = *(void *)(a2 + 48);
              uint64_t v79 = *(void **)(v78 + 16);
              if (v79 != &mlir::detail::TypeIDResolver<void,void>::id)
              {
                if (v79 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
                  return;
                }
LABEL_130:
                ++*(void *)(v3 + 16);
                return;
              }
              *(void *)&v92[0] = *(void *)(v78 + 8);
              uint64_t v80 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
              if (v81 != 11) {
                return;
              }
              if (*v80 != 0x6D7265702E73706DLL || *(void *)((char *)v80 + 3) != 0x6574756D7265702ELL) {
                return;
              }
              __int16 v91 = 1283;
              unint64_t v83 = "mps.permute";
LABEL_146:
              v88[0] = "classof on '";
              uint64_t v89 = v83;
              uint64_t v85 = 11;
              goto LABEL_148;
            }
LABEL_139:
            __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
          }
          *(void *)&v92[0] = *(void *)(v58 + 8);
          uint64_t v60 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v92);
          if (v61 != 12) {
            goto LABEL_110;
          }
          if (*(void *)v60 != 0x736E6F632E73706DLL || *(_DWORD *)(v60 + 8) != 1953390964) {
            goto LABEL_110;
          }
LABEL_144:
          __int16 v91 = 1283;
          v88[0] = "classof on '";
          uint64_t v89 = "mps.constant";
          uint64_t v85 = 12;
          goto LABEL_148;
        }
LABEL_141:
        __int16 v91 = 1283;
        v88[0] = "classof on '";
        uint64_t v89 = "mpsx.stitched";
        uint64_t v85 = 13;
        goto LABEL_148;
      }
      goto LABEL_142;
    }
LABEL_140:
    __int16 v91 = 1283;
    uint64_t v84 = "placement.tensor_to_memref";
LABEL_143:
    v88[0] = "classof on '";
    uint64_t v89 = v84;
    uint64_t v85 = 26;
    goto LABEL_148;
  }
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN16GPURegionRuntime22createRuntimeResourcesEvE3__0NS1_9placement10RegionCallEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESM_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, uint64_t a2)
{
  if (!a2) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v3 = (mlir::Operation *)llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v9 = v3;
    if (mlir::placement::RegionCall::getRegionType(&v9) == 1)
    {
      uint64_t v5 = *v4;
      uint64_t v6 = v9;
      uint64_t v7 = *(unsigned int *)(v5 + 8);
      if (v7 >= *(_DWORD *)(v5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v5, (void *)(v5 + 16), v7 + 1, 8);
        *(void *)(*(void *)v5 + 8 * *(unsigned int *)(v5 + 8)) = v6;
        unsigned int v8 = *(_DWORD *)(v5 + 8);
        if (v8 < *(_DWORD *)(v5 + 12)) {
          goto LABEL_6;
        }
      }
      else
      {
        *(void *)(*(void *)v5 + 8 * v7) = v9;
        unsigned int v8 = *(_DWORD *)(v5 + 8);
        if (v8 < *(_DWORD *)(v5 + 12))
        {
LABEL_6:
          *(_DWORD *)(v5 + 8) = v8 + 1;
          return;
        }
      }
      __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
  }
}

mlir::Block *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::initializeOps(void)::$_0>(void **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t result = *(mlir::Block **)(a2 + 16);
  if (result)
  {
    unint64_t result = (mlir::Block *)mlir::Block::getParentOp(result);
    uint64_t v5 = (uint64_t)result;
    if (result)
    {
      unint64_t result = (mlir::Block *)mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)result);
      if (!result)
      {
        if (v3[29]) {
          return result;
        }
        goto LABEL_10;
      }
      unint64_t result = (mlir::Block *)mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v5);
      if (!result) {
        __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (v5 != v3[29]) {
    return result;
  }
LABEL_10:
  uint64_t v6 = *(uint64_t (**)(void *, uint64_t, void))(*v3 + 64);

  return (mlir::Block *)v6(v3, a2, 0);
}

void std::__hash_table<std::__hash_value_type<void *,void *>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,void *>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,void *>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,void *>>>::__emplace_unique_key_args<void *,std::pair<void *,void *> &>(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = v9 ^ (v9 >> 47);
  unint64_t v11 = 0x9DDFEA08EB382D69 * v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * v10;
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v11;
    }
    unint64_t v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == a2) {
                return;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v11)
          {
            if (v15[2] == a2) {
              return;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_22:
  uint64_t v18 = operator new(0x20uLL);
  *uint64_t v18 = 0;
  v18[1] = v11;
  v18[2] = a3;
  v18[3] = a4;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v12 && (float)(v20 * (float)v12) >= v19) {
    goto LABEL_50;
  }
  BOOL v21 = 1;
  if (v12 >= 3) {
    BOOL v21 = (v12 & (v12 - 1)) != 0;
  }
  unint64_t v22 = v21 | (2 * v12);
  unint64_t v23 = vcvtps_u32_f32(v19 / v20);
  if (v22 <= v23) {
    size_t prime = v23;
  }
  else {
    size_t prime = v22;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v12 = *(void *)(a1 + 8);
  }
  if (prime > v12) {
    goto LABEL_34;
  }
  if (prime < v12)
  {
    unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v12 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (prime <= v25) {
      size_t prime = v25;
    }
    if (prime < v12) {
LABEL_34:
    }
      std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
  }
  unint64_t v12 = *(void *)(a1 + 8);
  unint64_t v28 = v12 - 1;
  if ((v12 & (v12 - 1)) != 0)
  {
    if (v11 >= v12)
    {
      unint64_t v4 = v11 % v12;
      uint64_t v29 = *(void *)a1;
      uint64_t v30 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
      if (!v30) {
        goto LABEL_53;
      }
LABEL_51:
      *uint64_t v18 = *v30;
LABEL_59:
      *uint64_t v30 = v18;
      goto LABEL_60;
    }
    unint64_t v4 = v11;
LABEL_50:
    uint64_t v29 = *(void *)a1;
    uint64_t v30 = *(void **)(*(void *)a1 + 8 * v4);
    if (!v30) {
      goto LABEL_53;
    }
    goto LABEL_51;
  }
  unint64_t v4 = v28 & v11;
  uint64_t v29 = *(void *)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * (v28 & v11));
  if (v30) {
    goto LABEL_51;
  }
LABEL_53:
  *uint64_t v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v29 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v31 >= v12) {
        v31 %= v12;
      }
    }
    else
    {
      v31 &= v12 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_59;
  }
LABEL_60:
  ++*(void *)(a1 + 24);
}

void sub_180D15AC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::find<std::string>(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0;
  }
  unint64_t v8 = v6;
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v10 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v10 = v6 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v10 = (*(void *)&v7 - 1) & v6;
  }
  unint64_t v12 = *(uint64_t ***)(*a1 + 8 * v10);
  if (v12)
  {
    uint8x8_t v13 = *v12;
    if (*v12)
    {
      char v14 = v2[23];
      if (v14 >= 0) {
        uint64_t v15 = v2[23];
      }
      else {
        uint64_t v15 = *((void *)v2 + 1);
      }
      if (v14 < 0) {
        uint64_t v2 = *(unsigned char **)v2;
      }
      if (v9.u32[0] < 2uLL)
      {
        uint64_t v16 = *(void *)&v7 - 1;
        while (1)
        {
          uint64_t v21 = v13[1];
          if (v21 == v8)
          {
            uint64_t v22 = *((unsigned __int8 *)v13 + 39);
            if ((v22 & 0x80u) == 0) {
              uint64_t v23 = *((unsigned __int8 *)v13 + 39);
            }
            else {
              uint64_t v23 = v13[3];
            }
            if (v23 == v15)
            {
              if ((v22 & 0x80) != 0)
              {
                if (!memcmp((const void *)v13[2], v2, v13[3])) {
                  return v13;
                }
              }
              else
              {
                if (!*((unsigned char *)v13 + 39)) {
                  return v13;
                }
                uint64_t v24 = 0;
                while (*((unsigned __int8 *)v13 + v24 + 16) == v2[v24])
                {
                  if (v22 == ++v24) {
                    return v13;
                  }
                }
              }
            }
          }
          else if ((v21 & v16) != v10)
          {
            return 0;
          }
          unint64_t result = 0;
          uint8x8_t v13 = (uint64_t *)*v13;
          if (!v13) {
            return result;
          }
        }
      }
      while (1)
      {
        unint64_t v17 = v13[1];
        if (v17 == v8)
        {
          uint64_t v18 = *((unsigned __int8 *)v13 + 39);
          if ((v18 & 0x80u) == 0) {
            uint64_t v19 = *((unsigned __int8 *)v13 + 39);
          }
          else {
            uint64_t v19 = v13[3];
          }
          if (v19 == v15)
          {
            if ((v18 & 0x80) != 0)
            {
              if (!memcmp((const void *)v13[2], v2, v13[3])) {
                return v13;
              }
            }
            else
            {
              if (!*((unsigned char *)v13 + 39)) {
                return v13;
              }
              uint64_t v20 = 0;
              while (*((unsigned __int8 *)v13 + v20 + 16) == v2[v20])
              {
                if (v18 == ++v20) {
                  return v13;
                }
              }
            }
          }
        }
        else
        {
          if (v17 >= *(void *)&v7) {
            v17 %= *(void *)&v7;
          }
          if (v17 != v10) {
            return 0;
          }
        }
        unint64_t result = 0;
        uint8x8_t v13 = (uint64_t *)*v13;
        if (!v13) {
          return result;
        }
      }
    }
  }
  return 0;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::AbsoluteOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      int8x8_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)int8x8_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      uint8x8_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        uint64_t v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        uint64_t v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      char v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      int8x8_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      int8x8_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>>>::__emplace_unique_key_args<mlir::Operation *,std::pair<mlir::Operation * const,std::unique_ptr<GPU::BaseOpHandler>>>(uint64_t a1, unint64_t a2, long long *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = v7 ^ (v7 >> 47);
  unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * v8;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
    unint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      uint64_t v13 = (void *)*v12;
      if (v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == a2) {
                return;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == a2) {
              return;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_22:
  uint64_t v16 = (void *)(a1 + 16);
  unint64_t v17 = operator new(0x20uLL);
  *unint64_t v17 = 0;
  v17[1] = v9;
  long long v18 = *a3;
  *((void *)a3 + 1) = 0;
  *((_OWORD *)v17 + 1) = v18;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v10 && (float)(v20 * (float)v10) >= v19) {
    goto LABEL_50;
  }
  BOOL v21 = 1;
  if (v10 >= 3) {
    BOOL v21 = (v10 & (v10 - 1)) != 0;
  }
  unint64_t v22 = v21 | (2 * v10);
  unint64_t v23 = vcvtps_u32_f32(v19 / v20);
  if (v22 <= v23) {
    size_t prime = v23;
  }
  else {
    size_t prime = v22;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v10 = *(void *)(a1 + 8);
  }
  if (prime > v10) {
    goto LABEL_34;
  }
  if (prime < v10)
  {
    unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v10 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (prime <= v25) {
      size_t prime = v25;
    }
    if (prime < v10) {
LABEL_34:
    }
      std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
  }
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v28 = v10 - 1;
  if ((v10 & (v10 - 1)) != 0)
  {
    if (v9 >= v10)
    {
      unint64_t v3 = v9 % v10;
      uint64_t v29 = *(void *)a1;
      uint64_t v30 = *(void **)(*(void *)a1 + 8 * (v9 % v10));
      if (!v30) {
        goto LABEL_53;
      }
LABEL_51:
      *unint64_t v17 = *v30;
LABEL_59:
      *uint64_t v30 = v17;
      goto LABEL_60;
    }
    unint64_t v3 = v9;
LABEL_50:
    uint64_t v29 = *(void *)a1;
    uint64_t v30 = *(void **)(*(void *)a1 + 8 * v3);
    if (!v30) {
      goto LABEL_53;
    }
    goto LABEL_51;
  }
  unint64_t v3 = v28 & v9;
  uint64_t v29 = *(void *)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * (v28 & v9));
  if (v30) {
    goto LABEL_51;
  }
LABEL_53:
  *unint64_t v17 = *v16;
  *uint64_t v16 = v17;
  *(void *)(v29 + 8 * v3) = v16;
  if (*v17)
  {
    unint64_t v31 = *(void *)(*v17 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v31 >= v10) {
        v31 %= v10;
      }
    }
    else
    {
      v31 &= v10 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_59;
  }
LABEL_60:
  ++*(void *)(a1 + 24);
}

void sub_180D16220(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[3];
      v2[3] = 0;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::AbsoluteSquareOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ACosOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ACoshOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::AddOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::AndOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ASinOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ASinhOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ATanOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ATan2OpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ATanhOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::AssignVariableOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BandPartOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseAndOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseLeftShiftOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseNotOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseOrOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwisePopcountOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseRightShiftOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BitwiseXorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BatchToSpaceOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BroadcastGradientArgsOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::BroadcastToOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CallOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CastOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CeilOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ClampOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ColToImOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ConcatOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ConditionOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ConjugateOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv2DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv2DDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv2DWeightsGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv3DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv3DDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Conv3DWeightsGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ConstantOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CosOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CoshOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CostVolumeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CreateComplexOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CreateTextureTensorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CropOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CropResizeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CumulativeSumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CumulativeProductOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CumulativeMaximumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::CumulativeMinimumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthToSpace2DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv2DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv2DDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv2DWeightsGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv3DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv3DDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DepthwiseConv3DWeightsGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DequantizeLutOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DequantizeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DimensionSizeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DivideOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::DynamicShapeCastOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ErfOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::EqualToOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ExpandDimsOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ExponentOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ExponentBase2OpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ExponentBase10OpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ExtractOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FFTOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FFT_RToCOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FFT_CToROpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::Flatten2DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FloorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ForOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FPToIntClampedOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GatherOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GatherAlongAxisOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GatherNDOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GetCoordOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GreaterThanOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GreaterThanOrEqualToOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GRUOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::GRUGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::HammingDistanceOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::IdentityOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::IfOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ImaginaryPartOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ImToColOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::IsFiniteOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::IsInfiniteOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::IsNaNOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LessThanOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LessThanOrEqualToOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LocalConvolutionOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LocalConvolutionDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LocalConvolutionWeightGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LogarithmOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LogarithmBase2OpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LogarithmBase10OpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LSTMOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::LSTMGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MakeListOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MaterializeSparseTensorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MatMulOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MatrixDecompositionLUOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MatrixInverseOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MatrixSolverLUOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MaximumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MemrefToTensorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MinimumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (uint64_t v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      unint64_t v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      unint64_t v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)unint64_t v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      unint64_t v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v15 = operator new(8 * v14);
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        *(void *)uint64_t v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = (char *)(8 * v11);
        unint64_t v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        long long v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *unint64_t v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v25 = &v7[-v24];
      v16 -= v24;
      uint8x8_t v26 = &v15[8 * v11 - 16];
      uint64_t v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint8x8_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      unint64_t v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      unint64_t v7 = *v4;
      goto LABEL_26;
    }
  }
}