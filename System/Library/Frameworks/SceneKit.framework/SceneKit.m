unint64_t _C3DRasterizerStatesCFHash(uint64_t a1)
{
  return __hashCodeFromDesc((int *)(a1 + 16));
}

uint64_t C3DTransactionFlush()
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  uint64_t result = ((uint64_t (*)(void))C3DTransactionGetStack)();
  if ((*(unsigned char *)(result + 52) & 4) != 0) {
    return result;
  }
  uint64_t v1 = result;
  if (*(_DWORD *)(result + 48))
  {
    char v2 = *(unsigned char *)(result + 52) | 2;
LABEL_4:
    *(unsigned char *)(v1 + 52) = v2;
    return result;
  }
  pthread_rwlock_rdlock(&gCommandQueueFlushLock);
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  uint64_t v3 = gTransactionStacks;
  if (!gTransactionStacks)
  {
LABEL_9:
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    return pthread_rwlock_unlock(&gCommandQueueFlushLock);
  }
  while (!*(void *)(v3 + 32))
  {
    uint64_t v3 = *(void *)(v3 + 8);
    if (!v3) {
      goto LABEL_9;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  uint64_t v4 = pthread_rwlock_unlock(&gCommandQueueFlushLock);
  uint64_t Stack = C3DTransactionGetStack(v4);
  pthread_rwlock_wrlock(&gCommandQueueFlushLock);
  *(unsigned char *)(Stack + 52) |= 1u;
  kdebug_trace();
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  uint64_t v6 = gTransactionStacks;
  if (!gTransactionStacks)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
LABEL_77:
    uint64_t v66 = kdebug_trace();
    uint64_t v1 = C3DTransactionGetStack(v66);
    uint64_t result = pthread_rwlock_unlock(&gCommandQueueFlushLock);
    char v2 = *(unsigned char *)(v1 + 52) & 0xFE;
    goto LABEL_4;
  }
  v7 = 0;
  v8 = 0;
  do
  {
    uint64_t v9 = 0;
    v10 = v8;
    double v11 = 3.40282347e38;
    do
    {
      uint64_t v12 = v9;
      uint64_t v13 = *(void *)(v6 + 32);
      if (!v13)
      {
        uint64_t v9 = v12;
LABEL_24:
        double v15 = v11;
        goto LABEL_25;
      }
      uint64_t v14 = *(void *)(v13 + 32);
      double v15 = *(double *)(v14 + 40);
      BOOL v16 = v15 != 0.0 && v15 < v11;
      uint64_t v9 = v6;
      if (!v16)
      {
        if ((*(unsigned char *)(v14 + 60) & 2) != 0) {
          uint64_t v9 = v6;
        }
        else {
          uint64_t v9 = v12;
        }
        goto LABEL_24;
      }
LABEL_25:
      uint64_t v6 = *(void *)(v6 + 8);
      double v11 = v15;
    }
    while (v6);
    if (!v9) {
      break;
    }
    v17 = *(void **)(v9 + 32);
    uint64_t v18 = v17[4];
    v8 = v17;
    if (v10)
    {
      if (v7) {
        void *v7 = v17;
      }
      v8 = v10;
    }
    while (1)
    {
      v7 = v17;
      if (!v17[5] && v17[4] == v18) {
        break;
      }
      v17 = (void *)*v17;
      if (!*v7)
      {
        *(void *)(v9 + 32) = 0;
LABEL_35:
        *(void *)(v9 + 40) = 0;
        goto LABEL_36;
      }
    }
    uint64_t v19 = *v17;
    *(void *)(v9 + 32) = *v17;
    if (!v19) {
      goto LABEL_35;
    }
LABEL_36:
    void *v7 = 0;
    uint64_t v6 = gTransactionStacks;
  }
  while (gTransactionStacks);
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  if (!v8) {
    goto LABEL_77;
  }
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x263EFFFA0]);
  *(unsigned char *)(v1 + 52) |= 4u;
  v21 = 0;
  gAtomicTime = CACurrentMediaTime();
  v22 = v8;
  do
  {
    uint64_t v23 = v22[4];
    if (v22[5])
    {
      gCurrentlyCommittedTransaction = v22[4];
      double v24 = 0.0;
      if ((*(unsigned char *)(v23 + 60) & 4) == 0) {
        double v24 = *(double *)(v23 + 32);
      }
      v25 = *(const void **)(v23 + 24);
      if (!v25)
      {
        C3DTimingFunctionGetDefaultFunction();
        v25 = v26;
      }
      v27 = (const void *)v22[2];
      if (v27)
      {
        if (CFTypeIsC3DEntity(v27))
        {
          v28 = (const void *)C3DGetScene((void *)v22[2]);
          if (v28)
          {
            v29 = v28;
            if (!CFSetContainsValue(Mutable, v28))
            {
              CFSetAddValue(Mutable, v29);
              C3DSceneLock((uint64_t)v29);
            }
            uint64_t AnimationManager = C3DSceneGetAnimationManager((uint64_t)v29);
            if (AnimationManager)
            {
              uint64_t v31 = AnimationManager;
              v32 = (float32x4_t *)v22[2];
              if (v32)
              {
                CFStringRef v33 = (const __CFString *)v22[3];
                if (v33)
                {
                  v101 = Mutable;
                  v102 = (void *)v22[2];
                  CFStringRef v34 = C3DCFTypeCopyModelInfoAtPath(v32, v33, 0);
                  uint64_t TargetAddress = C3DModelTargetGetTargetAddress((uint64_t)v34);
                  if (v34 && TargetAddress)
                  {
                    uint64_t v97 = v31;
                    unint64_t v36 = TargetAddress;
                    int BaseType = C3DModelTargetGetBaseType((uint64_t)v34);
                    char v37 = BYTE2(v34[1].isa);
                    uint64_t v99 = (uint64_t)v34;
                    char v38 = BYTE3(v34[1].isa);
                    qmemcpy(bytes, "transition-0x", 13);
                    v100 = (void *)v36;
                    uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v36);
                    v40.i64[0] = 0xF0000000FLL;
                    v40.i64[1] = 0xF0000000FLL;
                    int32x4_t v41 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE750), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE740)), v40);
                    int32x4_t v42 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE770), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE760)), v40);
                    int32x4_t v43 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE790), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE780)), v40);
                    int32x4_t v44 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE7B0), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_20B5EE7A0)), v40);
                    v45.i64[0] = 0xA0000000ALL;
                    v45.i64[1] = 0xA0000000ALL;
                    v46.i64[0] = 0x5700000057;
                    v46.i64[1] = 0x5700000057;
                    *(int8x16_t *)&bytes[13] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v42), (int8x16_t)(*(_OWORD *)&v42 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v42, v46)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v41), (int8x16_t)(*(_OWORD *)&v41 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v41, v46))), (int8x16_t)vuzp1q_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v44), (int8x16_t)(*(_OWORD *)&v44 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v44, v46)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v43), (int8x16_t)(*(_OWORD *)&v43 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v43, v46))));
                    bytes[29] = v37 + 97;
                    bytes[30] = v38 + 97;
                    bytes[31] = 0;
                    v47 = (__CFString *)CFStringCreateWithBytes(0, bytes, 31, 0x8000100u, 0);
                    v95 = v47;
                    if (v24 > 0.0)
                    {
                      CFTypeRef cf = (CFTypeRef)C3DValueCreate(BaseType, 1);
                      CFStringRef v50 = v34;
                      data = v34->data;
                      v90 = (void *)C3DValueGetBytes((uint64_t)cf);
                      size_t Length = C3DValueGetLength((uint64_t)cf);
                      C3DGetValue(data, v100, v90, Length, SBYTE2(v50[1].isa), BYTE3(v50[1].isa));
                      (*(void (**)(double))(v22[5] + 16))(v24);
                      uint64_t v52 = C3DValueCreate(BaseType, 1);
                      v91 = v34->data;
                      uint64_t v94 = v52;
                      uint64_t v53 = v52;
                      v87 = (void *)C3DValueGetBytes(v52);
                      size_t v54 = C3DValueGetLength(v53);
                      C3DGetValue(v91, v100, v87, v54, SBYTE2(v50[1].isa), BYTE3(v50[1].isa));
                      v92 = *(const void **)(v99 + 16);
                      v88 = (const void *)C3DValueGetBytes((uint64_t)cf);
                      size_t v55 = C3DValueGetLength((uint64_t)cf);
                      C3DSetValue(v92, v100, v88, v55, SBYTE2(v50[1].isa), BYTE3(v50[1].isa));
                      v56 = (const void *)C3DSimpleAnimationCreate();
                      C3DAnimationSetIsSceneTimeBased((uint64_t)v56, 0);
                      C3DSimpleAnimationSetEndValue((uint64_t)v56, v94);
                      double v57 = *(double *)&gAtomicTime;
                      if (*(double *)&gAtomicTime == 0.0)
                      {
                        double v57 = CACurrentMediaTime();
                        gAtomicTime = *(void *)&v57;
                      }
                      C3DAnimationManagerSetSystemTime(v97, v57);
                      C3DAnimationManagerApplyAnimationsForTarget(v97, v99);
                      v89 = *(const void **)(v99 + 16);
                      v86 = (void *)C3DValueGetBytes((uint64_t)cf);
                      size_t v58 = C3DValueGetLength((uint64_t)cf);
                      C3DGetValue(v89, v100, v86, v58, *(char *)(v99 + 34), *(unsigned __int8 *)(v99 + 35));
                      C3DSimpleAnimationSetStartValue((uint64_t)v56, (uint64_t)cf);
                      C3DAnimationSetIsImplicit((uint64_t)v56, 1);
                      float v59 = v24;
                      C3DAnimationSetDuration((uint64_t)v56, v59);
                      C3DAnimationSetTimingFunction((uint64_t)v56, v25);
                      C3DAnimationManagerExecRemoveAnimation(v97, v102, v95);
                      CFStringRef v34 = (const __CFString *)v99;
                      C3DAnimationManagerAddAnimationForKey(v97, v56, (const void *)v99, v102, v95);
                      CFRelease(v56);
                      CFRelease(cf);
                      v60 = (const void *)v94;
                      if (v94)
                      {
                        uint64_t ModelValueStorage = C3DSceneGetModelValueStorage((uint64_t)v29);
                        C3DModelValueStorageUpdateModelValueWithValue(ModelValueStorage, v99, v94);
                        v62 = v95;
LABEL_76:
                        CFRelease(v62);
                        CFRelease(v34);
                        CFRelease(v60);
                        Mutable = v101;
                        goto LABEL_68;
                      }
                    }
                    else
                    {
                      C3DAnimationManagerExecRemoveAnimation(v97, v102, v47);
                    }
                    (*(void (**)(double))(v22[5] + 16))(v24);
                    v60 = (const void *)C3DValueCreate(BaseType, 1);
                    v103 = v34->data;
                    v63 = (void *)C3DValueGetBytes((uint64_t)v60);
                    size_t v64 = C3DValueGetLength((uint64_t)v60);
                    C3DGetValue(v103, v100, v63, v64, SBYTE2(v34[1].isa), BYTE3(v34[1].isa));
                    uint64_t v65 = C3DSceneGetModelValueStorage((uint64_t)v29);
                    C3DModelValueStorageUpdateModelValueWithValue(v65, (uint64_t)v34, (uint64_t)v60);
                    v62 = v95;
                    goto LABEL_76;
                  }
                  if (v34) {
                    CFRelease(v34);
                  }
                  v48 = scn_default_log();
                  Mutable = v101;
                  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v49 = v22[3];
                    *(_DWORD *)bytes = 138412546;
                    *(void *)&bytes[4] = v49;
                    *(_WORD *)&bytes[12] = 2112;
                    *(void *)&bytes[14] = v102;
                    _os_log_impl(&dword_20B249000, v48, OS_LOG_TYPE_DEFAULT, "Warning: invalid keypath: %@ sent to object %@", bytes, 0x16u);
                  }
                }
              }
            }
          }
        }
      }
      (*(void (**)(double))(v22[5] + 16))(v24);
LABEL_68:
      gCurrentlyCommittedTransaction = 0;
      goto LABEL_69;
    }
    if (!v21) {
      v21 = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    }
    CFArrayAppendValue(v21, (const void *)v23);
LABEL_69:
    v22 = (void *)*v22;
  }
  while (v22);
  if (v21)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    v107.length = CFArrayGetCount(v21);
    v107.location = 0;
    CFArrayApplyFunction(v21, v107, (CFArrayApplierFunction)_transactionsDidFlush, 0);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    CFRelease(v21);
  }
  v67 = v8;
  do
  {
    v69 = (void *)*v67;
    v68 = (const void *)v67[1];
    if (v68)
    {
      CFRelease(v68);
      v67[1] = 0;
    }
    v70 = (const void *)v67[2];
    if (v70)
    {
      CFRelease(v70);
      v67[2] = 0;
    }
    v71 = (const void *)v67[3];
    if (v71)
    {
      CFRelease(v71);
      v67[3] = 0;
    }
    v72 = (const void *)v67[4];
    if (v72)
    {
      CFRelease(v72);
      v67[4] = 0;
    }
    v73 = (const void *)v67[5];
    if (v73) {
      _Block_release(v73);
    }
    v67 = v69;
  }
  while (v69);
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  do
  {
    v74 = (void *)*v8;
    C3DAllocatorDelete(gCommandAllocator, (unint64_t)v8);
    v8 = v74;
  }
  while (v74);
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)_C3DUnlockScenesAndBumpStateStamps, 0);
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  if (!LocalCenter)
  {
    v76 = scn_default_log();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
      C3DTransactionFlush_cold_1(v76, v77, v78, v79, v80, v81, v82, v83);
    }
  }
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)_C3DPostSceneDidChangeNotifications, LocalCenter);
  *(unsigned char *)(v1 + 52) &= ~4u;
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t v85 = C3DTransactionGetStack(v84);
  pthread_rwlock_unlock(&gCommandQueueFlushLock);
  *(unsigned char *)(v85 + 52) &= ~1u;
  return kdebug_trace();
}

uint64_t C3DGetScene(void *a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((CFTypeIsC3DEntity(a1) & 1) == 0)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DGetScene_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  return a1[6];
}

const void *CFTypeIsC3DEntity(const void *result)
{
  if (result)
  {
    uint64_t v1 = (const void *)CFGetTypeID(result);
    if (CFTypeIsC3DEntity_onceToken != -1) {
      dispatch_once(&CFTypeIsC3DEntity_onceToken, &__block_literal_global_34_0);
    }
    return (const void *)(CFDictionaryGetValue((CFDictionaryRef)CFTypeIsC3DEntity__cfTypeRegistry, v1) != 0);
  }
  return result;
}

void C3DAllocatorDelete(uint64_t a1, unint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAllocatorNew_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v13 = (uint64_t *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 48);
  if (v12 < 1)
  {
LABEL_11:
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      C3DAllocatorDelete_cold_1(v21);
    }
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v16 = *(void *)(a1 + 16);
    uint64_t v17 = *(void *)(a1 + 24);
    uint64_t v18 = *(void *)(a1 + 32);
    while (1)
    {
      unint64_t v19 = *(void *)(v18 + v14);
      if (v19 <= a2 && v19 + v17 * v16 > a2) {
        break;
      }
      ++v15;
      v14 += 16;
      if (!--v12) {
        goto LABEL_11;
      }
    }
    C3DIndexSetAddIndex(*(void *)(a1 + 40), (a2 - v19) / v16 + v15 * v17);
    uint64_t v22 = *(int *)(v18 + v14 + 8) + 1;
    *(_DWORD *)(v18 + v14 + 8) = v22;
    if (*(void *)(a1 + 24) == v22 && (!*(unsigned char *)(a1 + 64) || *v13 >= 2))
    {
      ++*(void *)(a1 + 56);
      free(*(void **)(*(void *)(a1 + 32) + v14));
      uint64_t v23 = *(char **)(a1 + 32);
      *(void *)&v23[v14] = 0;
      if (*(void *)(a1 + 56) == *(void *)(a1 + 48))
      {
        free(v23);
        *(void *)(a1 + 32) = 0;
        C3DIndexSetRemoveAllIndexes(*(void *)(a1 + 40));
        *uint64_t v13 = 0;
        *(void *)(a1 + 56) = 0;
      }
    }
  }
}

void C3DIndexSetAddIndexesInRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v6 = a2 + a3;
    uint64_t v7 = _indexOfRangeBeforeOrContainingIndex(a1, a2);
    if (v7 == -1) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v7;
    }
    uint64_t v9 = a1 + 24;
    for (uint64_t i = 16 * v8; ; i += 16)
    {
      uint64_t v11 = (*(unsigned char *)(a1 + 16) & 1) == 0;
      if ((*(unsigned char *)(a1 + 16) & 3) == 0) {
        uint64_t v11 = *(void *)(*(void *)v9 + 8);
      }
      if (v8 >= v11) {
        goto LABEL_25;
      }
      uint64_t v12 = a1 + 24;
      if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
        uint64_t v12 = *(void *)v9 + 56;
      }
      uint64_t v13 = (uint64_t *)(v12 + i);
      uint64_t v14 = *v13;
      uint64_t v15 = v6 - *v13;
      if (v6 < *v13) {
        break;
      }
      uint64_t v16 = v13[1] + v14;
      if (a2 < v14)
      {
        uint64_t v14 = a2;
        if (v6 <= v16) {
          uint64_t v15 = v16 - a2;
        }
        else {
          uint64_t v15 = v3;
        }
        if (v6 <= v16) {
          uint64_t v3 = v16 - a2;
        }
LABEL_24:
        _replaceRangeInArrayAtIndex(a1, v8, v14, v15);
LABEL_25:
        if (*(unsigned char *)(a1 + 16))
        {
          if (v8) {
            goto LABEL_40;
          }
          uint64_t v18 = 1;
        }
        else
        {
          if ((*(unsigned char *)(a1 + 16) & 2) == 0)
          {
            uint64_t v17 = *(void *)(*(void *)v9 + 8);
            if (v17 == v8)
            {
              uint64_t v18 = v17 + 1;
              goto LABEL_33;
            }
LABEL_40:
            while (1)
            {
              if (*(unsigned char *)(a1 + 16)) {
                uint64_t v24 = 0;
              }
              else {
                uint64_t v24 = (*(unsigned char *)(a1 + 16) & 2) != 0 ? 1 : *(void *)(*(void *)v9 + 8);
              }
              if (v8 >= v24 - 1) {
                break;
              }
              uint64_t v25 = a1 + 24;
              if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
                uint64_t v25 = *(void *)v9 + 56;
              }
              v26 = (uint64_t *)(v25 + 16 * v8);
              uint64_t v27 = *v26;
              uint64_t v28 = v26[1];
              v29 = (uint64_t *)(v25 + 16 * (v8 + 1));
              uint64_t v30 = v28 + v27;
              if (v30 < *v29) {
                break;
              }
              uint64_t v31 = v29[1] + *v29;
              if (v30 < v31)
              {
                _replaceRangeInArrayAtIndex(a1, v8, v27, v31 - v27);
                _removeRangeInArrayAtIndex(a1, ++v8);
              }
              else
              {
                _removeRangeInArrayAtIndex(a1, v8 + 1);
              }
            }
            return;
          }
          if (v8 != 1) {
            goto LABEL_40;
          }
          uint64_t v18 = 2;
        }
LABEL_33:
        _ensureRangeCapacity(a1, v18);
        char v19 = *(unsigned char *)(a1 + 16);
        if ((v19 & 2) != 0)
        {
          *(void *)(a1 + 24) = a2;
          *(void *)(a1 + 32) = v3;
        }
        else
        {
          *(void *)(*(void *)(a1 + 24) + 48) = 0;
          uint64_t v20 = *(void *)(a1 + 24);
          if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
            uint64_t v21 = a1 + 24;
          }
          else {
            uint64_t v21 = v20 + 56;
          }
          uint64_t v22 = *(void *)(v20 + 8);
          *(void *)(v20 + 8) = v22 + 1;
          uint64_t v23 = (uint64_t *)(v21 + 16 * v22);
          *uint64_t v23 = a2;
          v23[1] = v3;
          *(void *)(*(void *)(a1 + 24) + 16) += v3;
          char v19 = *(unsigned char *)(a1 + 16);
        }
        *(unsigned char *)(a1 + 16) = v19 & 0xFE;
        goto LABEL_40;
      }
      if (v6 <= v16) {
        return;
      }
      if (v16 >= a2) {
        goto LABEL_24;
      }
      ++v8;
    }
    _insertRange(a1, a2, v3, v8);
  }
}

char *C3DAllocatorNew(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAllocatorNew_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t FirstIndex = C3DIndexSetGetFirstIndex(*(void *)(a1 + 40));
  if (FirstIndex == -1)
  {
    uint64_t v11 = *(void *)(a1 + 48);
    if (v11)
    {
      *(void *)(a1 + 48) = v11 + 1;
      uint64_t v12 = (char *)malloc_type_realloc(*(void **)(a1 + 32), 16 * (v11 + 1), 0x10800409227ACB4uLL);
      *(void *)(a1 + 32) = v12;
      uint64_t v13 = &v12[16 * v11];
      *(void *)uint64_t v13 = malloc_type_malloc(*(void *)(a1 + 24) * *(void *)(a1 + 16), 0x2213EC01uLL);
      uint64_t v14 = *(void *)(a1 + 24);
      *((_DWORD *)v13 + 2) = v14;
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = v14 * v11;
    }
    else
    {
      uint64_t v17 = malloc_type_calloc(0x10uLL, 1uLL, 0x299EC358uLL);
      *(void *)(a1 + 32) = v17;
      *(void *)uint64_t v17 = malloc_type_malloc(*(void *)(a1 + 24) * *(void *)(a1 + 16), 0x2213EC01uLL);
      uint64_t v14 = *(void *)(a1 + 24);
      v17[2] = v14;
      *(void *)(a1 + 48) = 1;
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = 0;
    }
    C3DIndexSetAddIndexesInRange(v15, v16, v14);
    uint64_t FirstIndex = C3DIndexSetGetFirstIndex(*(void *)(a1 + 40));
  }
  C3DIndexSetRemoveIndex(*(void *)(a1 + 40), FirstIndex);
  uint64_t v18 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 32) + 16 * (FirstIndex / v18);
  --*(_DWORD *)(v19 + 8);
  uint64_t v20 = *(char **)v19;
  if (!*(void *)v19)
  {
    uint64_t v20 = (char *)malloc_type_malloc(*(void *)(a1 + 16) * v18, 0x2213EC01uLL);
    *(void *)uint64_t v19 = v20;
    *(_DWORD *)(v19 + 8) = *(_DWORD *)(a1 + 24) - 1;
    --*(void *)(a1 + 56);
  }
  return &v20[*(void *)(a1 + 16) * (FirstIndex % v18)];
}

void _replaceRangeInArrayAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v4 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (a4 <= 0)
  {
    _removeRangeInArrayAtIndex(a1, a2);
  }
  else if (v4 >= a2)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = a1 + 24;
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v7 = *(void *)v6 + 56;
    }
    uint64_t v8 = (void *)(v7 + 16 * a2);
    uint64_t v9 = v8[1];
    void *v8 = a3;
    v8[1] = a4;
    if ((*(unsigned char *)(a1 + 16) & 2) == 0)
    {
      *(void *)(*(void *)v6 + 48) = 0;
      *(void *)(*(void *)v6 + 16) -= v9;
      *(void *)(*(void *)v6 + 16) += a4;
    }
  }
  else
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      _insertRange_cold_1();
    }
  }
}

uint64_t C3DIndexSetGetFirstIndex(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 1) == 0)
  {
    uint64_t v1 = (uint64_t *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
      return *v1;
    }
    uint64_t v2 = *v1;
    if (*(void *)(v2 + 8))
    {
      uint64_t v1 = (uint64_t *)(v2 + 56);
      return *v1;
    }
  }
  return -1;
}

void C3DIndexSetRemoveIndexesInRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (a2 < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = _indexOfRangeAfterOrContainingIndex(a1, a2);
      if (v6 == -1) {
        return;
      }
    }
    uint64_t v7 = a2 + a3;
    uint64_t v8 = a1 + 24;
    while (1)
    {
      if (*(unsigned char *)(a1 + 16)) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = (*(unsigned char *)(a1 + 16) & 2) != 0 ? 1 : *(void *)(*(void *)v8 + 8);
      }
      if (v6 >= v9) {
        break;
      }
      uint64_t v10 = a1 + 24;
      if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
        uint64_t v10 = *(void *)v8 + 56;
      }
      uint64_t v11 = (uint64_t *)(v10 + 16 * v6);
      uint64_t v12 = *v11;
      if (v7 < *v11) {
        break;
      }
      uint64_t v13 = v11[1] + v12;
      if (a2 > v12)
      {
        if (v13 > v7)
        {
          _replaceRangeInArrayAtIndex(a1, v6, v7, v13 - v7);
          _insertRange(a1, v12, a2 - v12, v6);
          return;
        }
        if (a2 < v13) {
          _replaceRangeInArrayAtIndex(a1, v6, v12, a2 - v12);
        }
        ++v6;
      }
      else
      {
        if (v13 > v7)
        {
          _replaceRangeInArrayAtIndex(a1, v6, v7, v13 - v7);
          return;
        }
        _removeRangeInArrayAtIndex(a1, v6);
      }
    }
  }
}

void C3DIndexSetRemoveIndex(uint64_t a1, uint64_t a2)
{
}

uint64_t _indexOfRangeAfterOrContainingIndex(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    goto LABEL_6;
  }
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(v3 + 8);
  BOOL v5 = v4 == 1;
  BOOL v6 = v4 < 1;
  uint64_t v7 = v4 - 1;
  if (v6) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(v3 + 56);
  if (!v5)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v7;
    do
    {
      uint64_t v11 = v10 + v9;
      if (v10 + v9 < 0 != __OFADD__(v10, v9)) {
        ++v11;
      }
      uint64_t result = v11 >> 1;
      uint64_t v12 = &v2[2 * (v11 >> 1)];
      if (*v12 <= a2)
      {
        if (v12[1] + *v12 > a2) {
          return result;
        }
        uint64_t v9 = result + 1;
      }
      else
      {
        uint64_t v10 = result;
      }
    }
    while (v9 < v10);
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v7 = 0;
  uint64_t v9 = 0;
LABEL_7:
  if (v2[2 * v9 + 1] + v2[2 * v9] > a2) {
    return v9;
  }
  if (v9 < v7) {
    return v9 + 1;
  }
  return -1;
}

uint64_t _indexOfRangeBeforeOrContainingIndex(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    goto LABEL_5;
  }
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4 < 1) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(v3 + 56);
  uint64_t v5 = v4 - 1;
  if (v4 != 1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v10 = v5 + v6;
      if (v5 + v6 < 0 != __OFADD__(v5, v6)) {
        ++v10;
      }
      uint64_t result = v10 >> 1;
      uint64_t v11 = &v2[2 * (v10 >> 1)];
      if (*v11 <= a2)
      {
        if (v11[1] + *v11 > a2) {
          return result;
        }
        uint64_t v6 = result + 1;
      }
      else
      {
        uint64_t v5 = result;
      }
    }
    while (v6 < v5);
    goto LABEL_6;
  }
LABEL_5:
  uint64_t v6 = 0;
LABEL_6:
  uint64_t v7 = v2[2 * v6];
  uint64_t v8 = v6 - 1;
  if (v6 <= 0) {
    uint64_t v8 = -1;
  }
  if (v7 > a2) {
    return v8;
  }
  else {
    return v6;
  }
}

void C3DIndexSetAddIndex(uint64_t a1, uint64_t a2)
{
}

void C3DTimingFunctionGetDefaultFunction()
{
  if (!C3DTimingFunctionGetDefaultFunction_func)
  {
    C3DTimingFunctionCreateWithName(@"default");
    C3DTimingFunctionGetDefaultFunction_func = v0;
  }
}

uint64_t C3DEffectSlotGetTextureSampler(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 56);
}

uint64_t C3DTextureSamplerCreateEx(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t result = C3DTextureSamplerCreate();
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = a5;
  *(_DWORD *)(result + 24) = a6;
  *(_DWORD *)(result + 28) = a1;
  *(_DWORD *)(result + 32) = a2;
  *(_DWORD *)(result + 36) = a3;
  unsigned int v19 = 1;
  *(void *)(result + 48) = a7;
  *(void *)(result + 56) = a8;
  *(float *)(result + 64) = a9;
  if (a9 <= 128.0) {
    unsigned int v19 = ((a9 * 65536.0 * 0.0078125) << 19) | 1;
  }
  *(void *)(result + 80) = (a2 << 12) | (a1 << 10) | (a3 << 14) | (2 * a4) | (16 * a5) | (a6 << 7) | v19 | (*(unsigned __int8 *)(result + 68) << 16);
  return result;
}

uint64_t C3DTextureSamplerCreate()
{
  if (C3DTextureSamplerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerGetTypeID_onceToken, &__block_literal_global_29);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTextureSamplerGetTypeID_typeID, 0x50uLL);
  *(_OWORD *)(Instance + 16) = xmmword_20B5CCF10;
  *(void *)(Instance + 32) = 2;
  *(_DWORD *)(Instance + 64) = 1065353216;
  C3DColor4Make((float *)(Instance + 48), 0.0, 0.0, 0.0, 1.0);
  float v1 = *(float *)(Instance + 64);
  unsigned int v2 = 1;
  if (v1 <= 128.0) {
    unsigned int v2 = ((v1 * 65536.0 * 0.0078125) << 19) | 1;
  }
  int8x16_t v3 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(Instance + 16), (uint32x4_t)xmmword_20B5CCF20);
  *(int8x8_t *)v3.i8 = vorr_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  *(void *)(Instance + 80) = v3.i32[0] | v3.i32[1] | (*(_DWORD *)(Instance + 32) << 12) | (*(_DWORD *)(Instance + 36) << 14) | (*(unsigned __int8 *)(Instance + 68) << 16) | v2;
  return Instance;
}

uint64_t C3DTypeCreateInstance_(CFTypeID a1, size_t a2)
{
  if (HIDWORD(a2)) {
    return 0;
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), a2);
  }
  else
  {
    CFStringRef v6 = CFCopyTypeIDDescription(a1);
    CFRelease(v6);
  }
  return v2;
}

float *C3DColor4Make(float *result, float a2, float a3, float a4, float a5)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

CFTypeRef scn_NSColorFromCGColorIfApplicable(CFTypeRef cf)
{
  if (!cf) {
    return cf;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 != CGColorGetTypeID()) {
    return cf;
  }
  int8x16_t v3 = (void *)MEMORY[0x263F1C550];

  return (CFTypeRef)[v3 colorWithCGColor:cf];
}

void C3DEffectSlotSetColor(uint64_t a1, float *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v17[0] = 0;
  v17[1] = 0;
  *(_WORD *)(a1 + 48) &= ~0x200u;
  if (!a2)
  {
    a2 = (float *)v17;
    C3DColor4Make((float *)v17, 0.0, 0.0, 0.0, 1.0);
  }
  if (!C3DColor4IsEqualToColor4(a2, (float *)(a1 + 16)))
  {
    float v12 = *(float *)(a1 + 28);
    BOOL IsBlack = C3DColor4IsBlack((float *)(a1 + 16));
    BOOL v14 = C3DColor4IsBlack(a2);
    *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
    if (v12 != 0.0 || a2[3] == 0.0) {
      BOOL v15 = v12 == 1.0 && a2[3] != 1.0;
    }
    else {
      BOOL v15 = 1;
    }
    int v16 = IsBlack ^ v14;
    if (*(unsigned char *)(a1 + 50) != 5) {
      int v16 = 0;
    }
    __PostParentDidChangeNotification(a1, v15 | v16, 0);
  }
}

BOOL C3DColor4IsBlack(float *a1)
{
  return *a1 <= 0.001 && a1[1] <= 0.001 && a1[2] <= 0.001;
}

void C3DEffectSlotSetTextureSampler(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 56);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 56) = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    *(void *)(a1 + 56) = v13;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

void __PostCommonProfileDidChangeNotification(uint64_t a1)
{
  CFTypeID v2 = *(void **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = C3DGetScene(v2);
    C3DScenePostPipelineEvent(v3, 3, *(const void **)(a1 + 16), 0);
  }
  else
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      __PostCommonProfileDidChangeNotification_cold_1(v4);
    }
  }
  C3DMaterialTouchValueStorageModificationCount(*(void *)(a1 + 16));
}

void C3DScenePostPipelineEvent(uint64_t a1, int a2, const void *a3, const void *a4)
{
  if (!a3 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DScenePostPipelineEvent_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (!a1) {
      return;
    }
  }
  else if (!a1)
  {
    return;
  }
  uint64_t NotificationQueue = C3DEnginePipelineGetNotificationQueue(*(void *)(a1 + 120));
  C3DEngineNotificationQueueEnqueueEvent(NotificationQueue, a2, a3, a4);
}

void C3DMaterialTouchValueStorageModificationCount(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(_DWORD *)(a1 + 96);
}

void __PostParentDidChangeNotification(uint64_t a1, int a2, int a3)
{
  uint64_t CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
  if (CommonProfile)
  {
    if (a2) {
      *(_WORD *)(CommonProfile + 194) &= ~0x80u;
    }
    if (a3) {
      *(_WORD *)(CommonProfile + 194) &= ~0x40u;
    }
    __PostCommonProfileDidChangeNotification(CommonProfile);
  }
  else
  {
    switch(*(unsigned char *)(a1 + 50))
    {
      case 0x16:
      case 0x17:
        uint64_t v7 = *(void **)(a1 + 80);
        if (v7)
        {
          __C3DLightDidChange(v7);
        }
        break;
      case 0x19:
        uint64_t v8 = *(const void **)(a1 + 80);
        if (v8) {
          BOOL v9 = a3 == 0;
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          CFTypeID v10 = CFGetTypeID(v8);
          if (v10 == C3DLightGetTypeID())
          {
            __C3DLightProbeEnvironmentDidChange((uint64_t)v8);
          }
          else
          {
            if (v10 != C3DSceneGetTypeID())
            {
              uint64_t v14 = scn_default_log();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
                __PostParentDidChangeNotification_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
              }
            }
            __C3DSceneLightEnvironmentDidChange((uint64_t)v8);
          }
        }
        break;
      case 0x1A:
        uint64_t v11 = *(void **)(a1 + 80);
        if (v11)
        {
          _C3DCameraInvalidatePasses(v11);
        }
        break;
      case 0x1B:
        uint64_t v12 = *(void **)(a1 + 80);
        if (v12)
        {
          CFTypeID v13 = CFGetTypeID(v12);
          if (v13 == C3DGeometryGetTypeID())
          {
            _C3DGeometryShadingDidUpdate(v12);
          }
          else if (v13 == C3DMaterialGetTypeID())
          {
            _C3DMaterialShadingDidUpdate(v12);
          }
        }
        break;
      default:
        return;
    }
  }
}

uint64_t _C3DEffectSlotGetCommonProfile(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(char *)(a1 + 50) > 20) {
    return 0;
  }
  else {
    return *(void *)(a1 + 80);
  }
}

BOOL C3DColor4IsEqualToColor4(float *a1, float *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

uint64_t C3DTextureSamplerGetWrapModeP(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t C3DMaterialGetCommonProfile(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

void *C3DEffectCommonProfileGetColor(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot) {
    return (void *)(EffectSlot + 16);
  }
  else {
    return C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
  }
}

void *C3DEffectCommonProfileDefaultColorForEffectProperty(int a1)
{
  uint64_t v1 = a1 - 1;
  if (v1 > 0xD) {
    return &c3dBlack;
  }
  else {
    return *(&off_264007558 + v1);
  }
}

uint64_t C3DWasLinkedBeforeMajorOSYear2017()
{
  if (C3DWasLinkedBeforeMajorOSYear2017_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2017_onceToken, &__block_literal_global_8_0);
  }
  return C3DWasLinkedBeforeMajorOSYear2017_linkedBeforeMajorOSYear2017;
}

CGColorRef C3DCGColorCreateExtendedSRGBWithC3DColor(uint64_t a1, unint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  v7.i64[0] = a1;
  v7.i64[1] = a2;
  if (C3DLinearRenderingIsEnabled())
  {
    C3DColor4ConvertToNonLinear(&v7);
    float32x2_t v5 = *(float32x2_t *)&v7.u32[2];
    float32x2_t v4 = *(float32x2_t *)v7.f32;
  }
  else
  {
    float32x2_t v4 = (float32x2_t)a1;
    float32x2_t v5 = (float32x2_t)vzip1_s32((int32x2_t)a2, (int32x2_t)HIDWORD(a2));
  }
  *(float64x2_t *)components = vcvtq_f64_f32(v4);
  float64x2_t v9 = vcvtq_f64_f32(v5);
  if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
  }
  return CGColorCreate((CGColorSpaceRef)C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB, components);
}

uint64_t C3DLinearRenderingIsEnabled()
{
  if (C3DLinearRenderingIsEnabled_onceToken != -1) {
    dispatch_once(&C3DLinearRenderingIsEnabled_onceToken, &__block_literal_global_231);
  }
  return _gC3DEnableLinearRendering;
}

float64_t C3DColor4ConvertToNonLinear(float32x4_t *a1)
{
  v3.f64[0] = 0.0;
  v3.f64[1] = a1->f32[3];
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_44);
    }
    if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
    }
  }
  else
  {
    if (C3DGetColorTransformToSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToSRGB_onceToken, &__block_literal_global_47);
    }
    if (C3DColorSpaceLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_4);
    }
  }
  CGColorTransformConvertColorComponents();
  float64_t result = v3.f64[0];
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v3);
  return result;
}

uint64_t C3DWideGamutIsUsed()
{
  if (C3DWideGamutIsUsed_onceToken != -1) {
    dispatch_once(&C3DWideGamutIsUsed_onceToken, &__block_literal_global_238);
  }
  return C3DWideGamutIsUsed_useWideGamut;
}

uint64_t C3DEffectCommonProfileGetImage(uint64_t a1, int a2)
{
  if (!a1)
  {
    float32x2_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result)
  {
    if (*(unsigned char *)(result + 48)) {
      return 0;
    }
    else {
      return *(void *)(result + 40);
    }
  }
  return result;
}

MDLTextureSampler *setupSCNMaterialProperty(MDLTextureSampler *result, MDLMaterial *a2, MDLMaterialSemantic a3, int a4, NSDictionary *a5)
{
  if (!result) {
    return result;
  }
  uint64_t v7 = result;
  uint64_t v8 = [(MDLMaterial *)a2 propertyWithSemantic:a3];
  if ([(MDLMaterialProperty *)v8 type] == MDLMaterialPropertyTypeURL
    && [(MDLMaterialProperty *)v8 URLValue])
  {
    uint64_t v9 = [(MDLMaterialProperty *)v8 URLValue];
LABEL_32:
    [(MDLTextureSampler *)v7 setContents:v9];
    goto LABEL_33;
  }
  if ([(MDLMaterialProperty *)v8 type] == MDLMaterialPropertyTypeString
    && [(MDLMaterialProperty *)v8 stringValue])
  {
    if (![(MDLMaterialProperty *)v8 URLValue])
    {
      uint64_t v9 = [(MDLMaterialProperty *)v8 stringValue];
      goto LABEL_32;
    }
    uint64_t v10 = [(NSURL *)[(MDLMaterialProperty *)v8 URLValue] path];
    if ([(MDLMaterialProperty *)v8 stringValue])
    {
      if ([[(NSString *)v10 pathExtension] isEqualToString:@"usdz"])
      {
        uint64_t v11 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08B88], "currentThread"), "threadDictionary"), "valueForKey:", @"SCN_MDLCurrentAssetResolver");
        if (v11)
        {
          uint64_t v12 = (void *)v11;
          if (objc_opt_respondsToSelector())
          {
            CFTypeID v13 = objc_msgSend(v12, "resolveInsideArchiveWithAssetNamed:", -[MDLMaterialProperty stringValue](v8, "stringValue"));
            if ((unint64_t)[v13 count] >= 2)
            {
              uint64_t v14 = [NSURL fileURLWithPath:v10];
              uint64_t v15 = (void *)[objc_alloc(MEMORY[0x263F08BA0]) initWithURL:v14 resolvingAgainstBaseURL:0];
              int v16 = 1;
              [v15 setQuery:objc_msgSend(NSString, "stringWithFormat:", @"offset=%d&size=%d", objc_msgSend((id)objc_msgSend(v13, "objectAtIndexedSubscript:", 0), "intValue"), objc_msgSend((id)objc_msgSend(v13, "objectAtIndexedSubscript:", 1), "intValue"))];
              -[MDLTextureSampler setContents:](v7, "setContents:", [v15 URL]);

              goto LABEL_34;
            }
          }
        }
      }
    }
    [(MDLTextureSampler *)v7 _setImagePath:[(MDLMaterialProperty *)v8 stringValue] withResolvedPath:[(NSURL *)[(MDLMaterialProperty *)v8 URLValue] absoluteString]];
LABEL_33:
    int v16 = 1;
    goto LABEL_34;
  }
  if ([(MDLMaterialProperty *)v8 type] != MDLMaterialPropertyTypeTexture)
  {
    if ([(MDLMaterialProperty *)v8 type] == MDLMaterialPropertyTypeFloat4)
    {
      [(MDLMaterialProperty *)v8 float4Value];
      uint64_t v17 = (void *)MEMORY[0x263F1C550];
      double v19 = v18;
      double v21 = v20;
      double v23 = v22;
      double v25 = v24;
    }
    else
    {
      if ([(MDLMaterialProperty *)v8 type] != MDLMaterialPropertyTypeFloat3)
      {
        if ([(MDLMaterialProperty *)v8 type] == MDLMaterialPropertyTypeFloat)
        {
          [(MDLMaterialProperty *)v8 floatValue];
          uint64_t v9 = objc_msgSend(NSNumber, "numberWithFloat:");
          goto LABEL_32;
        }
        if ([(MDLMaterialProperty *)v8 type] == MDLMaterialPropertyTypeColor)
        {
          uint64_t v9 = objc_msgSend(MEMORY[0x263F1C550], "colorWithCGColor:", -[MDLMaterialProperty color](v8, "color"));
          goto LABEL_32;
        }
        goto LABEL_33;
      }
      [(MDLMaterialProperty *)v8 float3Value];
      uint64_t v17 = (void *)MEMORY[0x263F1C550];
      double v19 = v26;
      double v21 = v27;
      double v23 = v28;
      double v25 = 1.0;
    }
    uint64_t v9 = objc_msgSend(v17, "scn_colorWithModelIORed:green:blue:alpha:options:", a5, v19, v21, v23, v25);
    goto LABEL_32;
  }
  if ([(MDLMaterialProperty *)v8 textureSamplerValue]
    && [(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] texture])
  {
    [(MDLTextureSampler *)v7 setContents:[(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] texture]];
    int v16 = 0;
  }
  else
  {
    int v16 = 1;
  }
  if (C3DWasLinkedBeforeMajorOSYear2018())
  {
    memset(&a.m22, 0, 40);
    *(_OWORD *)&a.m12 = 0u;
    a.m11 = 1.0;
    a.m22 = -1.0;
    a.m33 = 1.0;
    a.m44 = 1.0;
    *(void *)&b.m14 = 0;
    *(void *)&b.m12 = 0;
    b.m11 = 1.0;
    b.m22 = 1.0;
    *(void *)&b.m31 = 0;
    *(void *)&b.m23 = 0;
    *(_OWORD *)&b.m33 = xmmword_20B5CB6E0;
    *(void *)&b.m43 = 0x3F80000000000000;
    SCNMatrix4Mult(&v80, &a, &b);
    SCNMatrix4 v77 = v80;
    [(MDLTextureSampler *)v7 setContentsTransform:&v77];
  }
LABEL_34:
  if (v16)
  {
    if (a4)
    {
      [(MDLTextureSampler *)v7 setWrapS:2];
      [(MDLTextureSampler *)v7 setWrapT:2];
      if (C3DWasLinkedBeforeMajorOSYear2018())
      {
        memset(&v75.m22, 0, 40);
        *(_OWORD *)&v75.m12 = 0u;
        v75.m11 = 1.0;
        v75.m22 = -1.0;
        v75.m33 = 1.0;
        v75.m44 = 1.0;
        *(void *)&v74.m14 = 0;
        *(void *)&v74.m12 = 0;
        v74.m11 = 1.0;
        v74.m22 = 1.0;
        *(void *)&v74.m31 = 0;
        *(void *)&v74.m23 = 0;
        *(_OWORD *)&v74.m33 = xmmword_20B5CB6E0;
        *(void *)&v74.m43 = 0x3F80000000000000;
        SCNMatrix4Mult(&v76, &v75, &v74);
        SCNMatrix4 v73 = v76;
        [(MDLTextureSampler *)v7 setContentsTransform:&v73];
      }
    }
  }
  uint64_t result = [(MDLMaterialProperty *)v8 textureSamplerValue];
  if (!result) {
    return result;
  }
  [(MDLTextureSampler *)v7 setTextureComponents:__rbit32([(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] textureComponents]) >> 28];
  [(MDLTextureSampler *)v7 setMappingChannel:[(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] mappingChannel]];
  if ([(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] transform])
  {
    if (C3DWasLinkedBeforeMajorOSYear2018())
    {
      memset(&v82, 0, sizeof(v82));
      memset(&v72.m22, 0, 40);
      *(_OWORD *)&v72.m12 = 0u;
      v72.m11 = 1.0;
      v72.m22 = -1.0;
      v72.m33 = 1.0;
      v72.m44 = 1.0;
      *(void *)&v71.m14 = 0;
      *(void *)&v71.m12 = 0;
      v71.m11 = 1.0;
      v71.m22 = 1.0;
      *(void *)&v71.m23 = 0;
      *(void *)&v71.m31 = 0;
      *(_OWORD *)&v71.m33 = xmmword_20B5CB6E0;
      *(void *)&v71.m43 = 0x3F80000000000000;
      SCNMatrix4Mult(&v82, &v72, &v71);
      [(MDLTransform *)[(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] transform] matrix];
      *(_OWORD *)&v69.m11 = v29;
      *(_OWORD *)&v69.m21 = v30;
      *(_OWORD *)&v69.m31 = v31;
      *(_OWORD *)&v69.m41 = v32;
      SCNMatrix4 v68 = v82;
      SCNMatrix4Mult(&v70, &v69, &v68);
      SCNMatrix4 v67 = v70;
      CFStringRef v33 = &v67;
    }
    else
    {
      [(MDLTransform *)[(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] transform] matrix];
      uint64_t v35 = 0;
      int8x16_t v37 = (int8x16_t)vmulq_f32(v36, v36);
      float32x2_t v38 = (float32x2_t)vextq_s8(v37, v37, 8uLL).u64[0];
      v38.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v37.i8, v38)));
      int8x16_t v40 = (int8x16_t)vmulq_f32(v39, v39);
      float32x2_t v41 = (float32x2_t)vextq_s8(v40, v40, 8uLL).u64[0];
      v41.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v40.i8, v41)));
      int8x16_t v42 = (int8x16_t)vmulq_f32(v34, v34);
      float32x2_t v43 = (float32x2_t)vextq_s8(v42, v42, 8uLL).u64[0];
      v43.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v42.i8, v43)));
      float32x4_t v44 = vdivq_f32(v36, (float32x4_t)vdupq_lane_s32((int32x2_t)v38, 0));
      float32x4_t v45 = vdivq_f32(v39, (float32x4_t)vdupq_lane_s32((int32x2_t)v41, 0));
      float32x4_t v46 = *(float32x4_t *)MEMORY[0x263EF89A8];
      float32x4_t v47 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
      float32x4_t v48 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
      float32x4_t v49 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
      LODWORD(v51) = v50.i32[0];
      DWORD1(v51) = vnegq_f32(v50).i32[1];
      *((void *)&v51 + 1) = __PAIR64__(1.0, v50.u32[2]);
      *(_OWORD *)&v81.m11 = *MEMORY[0x263EF89A8];
      *(float32x4_t *)&v81.m21 = v47;
      *(float32x4_t *)&v81.m31 = v48;
      *(_OWORD *)&v81.m41 = v51;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v35) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v35))), v47, *(float32x2_t *)((char *)&v81.m11 + v35), 1), v48, *(float32x4_t *)((char *)&v81.m11 + v35), 2), (float32x4_t)xmmword_20B5CB6F0, *(float32x4_t *)((char *)&v81.m11 + v35), 3);
        v35 += 16;
      }
      while (v35 != 64);
      uint64_t v52 = 0;
      float32x4_t v53 = vdivq_f32(v34, (float32x4_t)vdupq_lane_s32((int32x2_t)v43, 0));
      v44.i32[1] = vnegq_f32(v44).i32[1];
      v45.f32[0] = -v45.f32[0];
      SCNMatrix4 v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v52) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v52))), v45, *(float32x2_t *)((char *)&v81.m11 + v52), 1), v53, *(float32x4_t *)((char *)&v81.m11 + v52), 2), v49, *(float32x4_t *)((char *)&v81.m11 + v52), 3);
        v52 += 16;
      }
      while (v52 != 64);
      uint64_t v54 = 0;
      v55.i32[0] = 0;
      v55.i64[1] = 0;
      v55.i32[1] = v41.i32[0];
      v56.i64[0] = 0;
      v56.i64[1] = v43.u32[0];
      SCNMatrix4 v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v54) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v38.u32[0], COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v54))), v55, *(float32x2_t *)((char *)&v81.m11 + v54), 1), v56, *(float32x4_t *)((char *)&v81.m11 + v54), 2), (float32x4_t)xmmword_20B5CB530, *(float32x4_t *)((char *)&v81.m11 + v54), 3);
        v54 += 16;
      }
      while (v54 != 64);
      uint64_t v57 = 0;
      SCNMatrix4 v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v57) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v57))), v47, *(float32x2_t *)((char *)&v81.m11 + v57), 1), v48, *(float32x4_t *)((char *)&v81.m11 + v57), 2), (float32x4_t)xmmword_20B5CB700, *(float32x4_t *)((char *)&v81.m11 + v57), 3);
        v57 += 16;
      }
      while (v57 != 64);
      SCNMatrix4 v66 = v82;
      CFStringRef v33 = &v66;
    }
    [(MDLTextureSampler *)v7 setContentsTransform:v33];
  }
  uint64_t result = [(MDLTextureSampler *)[(MDLMaterialProperty *)v8 textureSamplerValue] hardwareFilter];
  if (!result) {
    return result;
  }
  size_t v58 = result;
  unint64_t v59 = [(MDLTextureSampler *)result sWrapMode];
  if (v59 <= 2) {
    [(MDLTextureSampler *)v7 setWrapS:qword_20B5CB760[v59]];
  }
  unint64_t v60 = [(MDLTextureSampler *)v58 tWrapMode];
  if (v60 <= 2) {
    [(MDLTextureSampler *)v7 setWrapT:qword_20B5CB760[v60]];
  }
  uint64_t v61 = [(MDLTextureSampler *)v58 minFilter];
  if (v61)
  {
    if (v61 != 1) {
      goto LABEL_62;
    }
    uint64_t v62 = 2;
  }
  else
  {
    uint64_t v62 = 1;
  }
  [(MDLTextureSampler *)v7 setMinificationFilter:v62];
LABEL_62:
  uint64_t v63 = [(MDLTextureSampler *)v58 magFilter];
  if (!v63)
  {
    uint64_t v64 = 1;
    goto LABEL_66;
  }
  if (v63 == 1)
  {
    uint64_t v64 = 2;
LABEL_66:
    [(MDLTextureSampler *)v7 setMagnificationFilter:v64];
  }
  uint64_t result = (MDLTextureSampler *)[(MDLTextureSampler *)v58 mipFilter];
  if (result)
  {
    if (result != (MDLTextureSampler *)1) {
      return result;
    }
    uint64_t v65 = 2;
  }
  else
  {
    uint64_t v65 = 1;
  }
  return (MDLTextureSampler *)[(MDLTextureSampler *)v7 setMipFilter:v65];
}

uint64_t C3DWasLinkedBeforeMajorOSYear2018()
{
  if (C3DWasLinkedBeforeMajorOSYear2018_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2018_onceToken, &__block_literal_global_10_0);
  }
  return C3DWasLinkedBeforeMajorOSYear2018_linkedBeforeMajorOSYear2018;
}

uint64_t C3DTransactionAllowImmediate(uint64_t a1, id *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 60);
  if ((v2 & 8) != 0)
  {
    uint64_t v5 = (id **)(a1 + 48);
    float32x2_t v4 = *(id **)(a1 + 48);
    if (v4 != a2 && a2 != 0 && v4 != 0 && (C3DTransactionAllowImmediate_done & 1) == 0)
    {
      C3DTransactionAllowImmediate_done = 1;
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        C3DTransactionAllowImmediate_cold_1(a2, v5, v8);
      }
    }
  }
  return (v2 >> 3) & 1;
}

void C3DTransactionAddCommandBlock(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  if (!a6 && (uint64_t v12 = scn_default_log(), os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    C3DTransactionAddCommandBlock_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  float v20 = scn_default_log();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
    C3DTransactionAddCommandBlock_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
  }
LABEL_6:
  uint64_t Stack = (char **)C3DTransactionGetStack();
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  appended = C3DCommandQueueAppendNewCommand(Stack + 4);
  if (a4 || (a4 = a2) != 0) {
    CFTypeRef v30 = CFRetain(a4);
  }
  else {
    CFTypeRef v30 = 0;
  }
  *((void *)appended + 2) = v30;
  if (a5) {
    CFTypeRef v31 = CFRetain(a5);
  }
  else {
    CFTypeRef v31 = 0;
  }
  *((void *)appended + 3) = v31;
  if (a3) {
    CFTypeRef v32 = CFRetain(a3);
  }
  else {
    CFTypeRef v32 = 0;
  }
  *((void *)appended + 1) = v32;
  *((void *)appended + 5) = _Block_copy(a6);
  if (a1) {
    CFTypeRef v33 = CFRetain(a1);
  }
  else {
    CFTypeRef v33 = 0;
  }
  *((void *)appended + 4) = v33;
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
}

const void *C3DTransactionGetCurrent()
{
  CFArrayRef v0 = *(const __CFArray **)(C3DTransactionGetStack() + 16);
  CFIndex v1 = CFArrayGetCount(v0) - 1;

  return CFArrayGetValueAtIndex(v0, v1);
}

void *C3DTransactionGetStack()
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (_setupTransactionIfNeeded_onceToken != -1) {
    dispatch_once(&_setupTransactionIfNeeded_onceToken, &__block_literal_global_10_1);
  }
  CFArrayRef v0 = pthread_getspecific(gTransactionKey);
  if (!v0)
  {
    CFArrayRef v0 = malloc_type_calloc(0x38uLL, 1uLL, 0xFB6EB80uLL);
    *((void *)v0 + 2) = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    pthread_setspecific(gTransactionKey, v0);
    _C3DTransactionBegin(1, 0.0);
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    CFIndex v1 = (void *)gTransactionStacks;
    *((void *)v0 + 1) = gTransactionStacks;
    if (v1) {
      *CFIndex v1 = v0;
    }
    gTransactionStacks = (uint64_t)v0;
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (!*((void *)v0 + 3))
    {
      float64x2_t v3 = pthread_self();
      pthread_getname_np(v3, __s1, 0x40uLL);
      if (strcmp(__s1, "com.apple.scenekit.scnview-renderer"))
      {
        Current = CFRunLoopGetCurrent();
        CFRunLoopMode v5 = CFRunLoopCopyCurrentMode(Current);
        uint64_t v6 = CFRunLoopObserverCreate(0, 0xA0uLL, 1u, 2000000, (CFRunLoopObserverCallBack)_commitImplicitTransaction, 0);
        *((void *)v0 + 3) = v6;
        if (v6) {
          CFRunLoopAddObserver(Current, v6, (CFRunLoopMode)*MEMORY[0x263EFFE78]);
        }
        if (v5)
        {
          if (*((void *)v0 + 3) && v5 != (CFRunLoopMode)*MEMORY[0x263EFFE88])
          {
            if (!C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode
              && CFEqual(v5, @"UITrackingRunLoopMode"))
            {
              C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode = (uint64_t)CFRetain(v5);
              CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v5);
            }
            if (v5 != (CFRunLoopMode)C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode) {
              CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v5);
            }
          }
          CFRelease(v5);
        }
      }
    }
  }
  return v0;
}

char *C3DCommandQueueAppendNewCommand(char **a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineNotificationQueueStartObserving_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = C3DAllocatorNew(gCommandAllocator);
  *(_OWORD *)uint64_t result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  uint64_t v11 = (char **)a1[1];
  if (!v11) {
    uint64_t v11 = a1;
  }
  *uint64_t v11 = result;
  a1[1] = result;
  return result;
}

CFDictionaryRef C3DEntityGetAnimations(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return _C3DEntityGetSubAttributeOrderedDictionary(a1, @"kAnimationsKey", 0);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2016()
{
  if (C3DWasLinkedBeforeMajorOSYear2016_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2016_onceToken, &__block_literal_global_6_2);
  }
  return C3DWasLinkedBeforeMajorOSYear2016_linkedBeforeMajorOSYear2016;
}

uint64_t C3DEffectSlotDefaultSRGBForPropertyType(unsigned int a1)
{
  return (a1 > 0x1A) | (0x37F325Fu >> a1) & 1;
}

CFStringRef C3DEntitySetName(uint64_t a1, CFStringRef theString)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFStringRef result = *(CFStringRef *)(a1 + 32);
  if (result != theString)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 32) = 0;
    }
    if (theString) {
      CFStringRef result = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], theString);
    }
    else {
      CFStringRef result = 0;
    }
    *(void *)(a1 + 32) = result;
  }
  return result;
}

uint64_t C3DEnginePipelineGetNotificationQueue(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

void sub_20B24F70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
}

uint64_t C3DEffectSlotGetDefaultTextureOptions(int a1, int a2)
{
  if (a1 == 4) {
    int v2 = 2;
  }
  else {
    int v2 = 0;
  }
  if (a1 == 26) {
    int v3 = 8;
  }
  else {
    int v3 = v2;
  }
  if ((a1 - 24) >= 2) {
    int v4 = v3;
  }
  else {
    int v4 = 6;
  }
  return v4 | a2 ^ 1u;
}

uint64_t C3DSceneGetModelValueStorage(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 96);
}

void C3DModelValueStorageUpdateModelValueWithValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DConstraintApplyIK_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  ModelValueIfAny = (__n128 *)C3DModelValueStorageGetModelValueIfAny(a1, a2);
  if (ModelValueIfAny) {
    C3DModelValueStorageUpdateItemModelValueWithValue(ModelValueIfAny, a2, a3);
  }
}

uint64_t C3DModelTargetGetBaseType(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(__int16 *)(a1 + 32);
}

void *C3DGetValue(CFTypeRef cf, const void *a2, void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  if (!cf)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (uint64_t v21 = (uint64_t (*)(CFTypeRef, const void *, void *, size_t, uint64_t, uint64_t))ClassWithTypeID[13]) != 0)
  {
    return (void *)v21(cf, a2, a3, a4, a5, a6);
  }
  else
  {
    return memcpy(a3, a2, a4);
  }
}

void _removeRangeInArrayAtIndex(uint64_t a1, uint64_t a2)
{
  char v2 = *(unsigned char *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v3 = 1;
  }
  else
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v3 >= a2)
  {
    uint64_t v5 = (void *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v5 = (void *)(*v5 + 56);
    }
    uint64_t v6 = &v5[2 * a2];
    uint64_t v7 = v6[1];
    if (a2 + 1 < v3)
    {
      uint64_t v8 = v6 + 2;
      uint64_t v9 = ~a2 + v3;
      do
      {
        *(v8 - 1) = *v8;
        ++v8;
        --v9;
      }
      while (v9);
      char v2 = *(unsigned char *)(a1 + 16);
    }
    if ((v2 & 2) != 0)
    {
      char v10 = v2 | 1;
    }
    else
    {
      *(void *)(*(void *)(a1 + 24) + 48) = 0;
      --*(void *)(*(void *)(a1 + 24) + 8);
      *(void *)(*(void *)(a1 + 24) + 16) -= v7;
      char v10 = *(unsigned char *)(a1 + 16) & 0xFE | (*(void *)(*(void *)(a1 + 24) + 8) == 0);
    }
    *(unsigned char *)(a1 + 16) = v10;
  }
  else
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      _insertRange_cold_1();
    }
  }
}

uint64_t C3DTextureSamplerGetBorderColor(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 48;
}

uint64_t C3DEffectSlotGetSRGB(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 48) >> 10) & 1;
}

void _C3DNodeGetValue(uint64_t a1, const void *a2, void *__dst, size_t __n, int a5, unsigned int a6)
{
  if ((const void *)(a1 + 96) == a2) {
    C3DTransformGetValue((uint64_t)a2, __dst, __n, a5, a6);
  }
  else {
    memcpy(__dst, a2, __n);
  }
}

void C3DNodeSetOpacity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 204);
  if (v12 != a2)
  {
    if (a2 >= 1.0 && v12 < 1.0)
    {
      *(float *)(a1 + 204) = a2;
      __DirtyWorldAlpha(a1, 1);
    }
    else
    {
      if (a2 >= 1.0)
      {
        *(float *)(a1 + 204) = a2;
        __DirtyWorldAlpha(a1, 0);
        goto LABEL_15;
      }
      *(float *)(a1 + 204) = a2;
      __DirtyWorldAlpha(a1, v12 >= 1.0);
      if (v12 < 1.0) {
        goto LABEL_15;
      }
    }
    uint64_t v14 = *(void *)(a1 + 48);
    C3DScenePostPipelineEvent(v14, 4, (const void *)a1, 0);
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    v15[2] = ____IsOpaqueDidChange_block_invoke;
    v15[3] = &__block_descriptor_tmp_164;
    v15[4] = v14;
    C3DNodeApplyHierarchy(a1, (uint64_t)v15);
LABEL_15:
    if (a2 == 0.0 || v12 == 0.0) {
      __UpdateCullingSystemFlags(a1, 1);
    }
  }
}

void __C3DSceneLightEnvironmentDidChange(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(_DWORD *)(a1 + 320);
}

__n128 C3DTimingFunctionCreateWithName(__CFString *a1)
{
  if (C3DTimingFunctionGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTimingFunctionGetTypeID_onceToken, &__block_literal_global_22);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTimingFunctionGetTypeID_typeID, 0x20uLL);
  *(void *)(Instance + 16) = C3DTimingFunctionCurve;
  if (@"default" == a1)
  {
    uint64_t v4 = &function_values;
  }
  else if (@"easeIn" == a1)
  {
    uint64_t v4 = &xmmword_20B5CC188;
  }
  else if (@"easeOut" == a1)
  {
    uint64_t v4 = &xmmword_20B5CC198;
  }
  else
  {
    if (@"easeInEaseOut" != a1)
    {
      *(void *)(Instance + 16) = C3DTimingFunctionLinear;
      return result;
    }
    uint64_t v4 = &xmmword_20B5CC1A8;
  }
  __n128 result = (__n128)*v4;
  *(_OWORD *)(Instance + 24) = *v4;
  return result;
}

__n128 C3DSceneSetFogColor(__n128 *a1, __n128 *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *a2;
  a1[22] = *a2;
  return result;
}

void C3DNodeSetCamera(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DGetSceneRef(a1))
  {
    CamerSCNMatrix4 a = C3DNodeGetCamera(a1);
    if (Camera) {
      C3DRemoveSceneRef(Camera, *(void *)(a1 + 48));
    }
  }
  BOOL v13 = C3DGetSceneRef(a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, @"kCameraKey", a2, v13);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFBFF | ((a2 != 0) << 10);
  if (a2)
  {
    uint64_t v14 = *(void *)(a1 + 48);
    if (v14) {
      C3DAddSceneRef((uint64_t *)a2, v14);
    }
  }
}

void C3DEffectSlotSetPrecomputedLightingEnvironment(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned char *)(a1 + 50) == 25 && (cf || *(_WORD *)(a1 + 48) == 4))
  {
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 48) & 0xFF00 | 4;
    CFTypeRef v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 40) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 40) = v13;
      uint64_t CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
      if (CommonProfile) {
        *(_WORD *)(CommonProfile + 196) &= 0xE000u;
      }
      __PostParentDidChangeNotification(a1, 0, 1);
    }
  }
}

void C3DEffectSlotSetHasNoContents(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEffectSlotSetHasNoContents_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(_WORD *)(a1 + 48) |= 0x200u;
}

void _C3DValueCFFinalize(uint64_t a1)
{
}

void __C3DProgramHashCodeRelease_block_invoke(uint64_t a1)
{
}

void __AppendArgument(uint64_t a1, int a2, uint64_t a3, void *a4, int a5)
{
  if (([a4 hasPrefix:@"texture"] & 1) != 0
    || ([a4 hasPrefix:@"depth"] & 1) != 0)
  {
    uint64_t v10 = 176;
    if (a2) {
      uint64_t v10 = 184;
    }
    uint64_t v11 = *(void **)(a1 + v10);
    if ([a4 hasSuffix:@">"]) {
      [v11 appendFormat:@", %@ %@\n", a4, a3];
    }
    else {
      [v11 appendFormat:@", %@<float> %@\n", a4, a3];
    }
    int v12 = 1;
  }
  else
  {
    char v14 = [a4 hasPrefix:@"sampler"];
    uint64_t v15 = 176;
    if (a2) {
      uint64_t v15 = 184;
    }
    uint64_t v16 = *(void **)(a1 + v15);
    if (v14)
    {
      [v16 appendFormat:@", %@ %@\n", a4, a3];
      int v12 = 2;
    }
    else
    {
      if ([a4 hasSuffix:@"*"]) {
        [v16 appendFormat:@", device %@ %@\n", a4, a3];
      }
      else {
        [v16 appendFormat:@", constant %@& %@\n", a4, a3];
      }
      int v12 = 0;
    }
  }
  if (a5 == 3)
  {
    [*(id *)(a1 + 168) appendFormat:@"_lightingContribution.%@=%@;\n", a3, a3];
    if (v12 != 1)
    {
      CFTypeRef v13 = *(void **)(a1 + 160);
LABEL_17:
      [v13 appendFormat:@"%@ %@;\n", a4, a3];
      return;
    }
    int v17 = [a4 hasSuffix:@">"];
    CFTypeRef v13 = *(void **)(a1 + 160);
    if (v17) {
      goto LABEL_17;
    }
    [v13 appendFormat:@"%@<float> %@;\n", a4, a3];
  }
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBuffers(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a5)
  {
    uint64_t v9 = result;
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    for (uint64_t i = (void *)(result + 16 * a4 + 88); ; i += 2)
    {
      uint64_t v13 = a4 + v11;
      uint64_t v14 = *(void *)(a2 + 8 * v11);
      if (*(i - 1) != v14) {
        break;
      }
      uint64_t v15 = *(void *)(a3 + 8 * v11);
      if (*i != v15)
      {
        *uint64_t i = v15;
        __n128 result = [*(id *)(v9 + 3392) setVertexBufferOffset:*(void *)(a3 + 8 * v11) atIndex:a4 + v11];
      }
      ++v11;
      v10 -= 8;
      if (a5 == v11) {
        return result;
      }
    }
    unint64_t v16 = a5 - v11;
    if (a5 != v11)
    {
      if (a5 - 1 == v11)
      {
        *(i - 1) = v14;
        *uint64_t i = *(void *)(a3 + 8 * v11);
        int v17 = *(void **)(v9 + 3392);
        uint64_t v18 = *(void *)(a2 + 8 * v11);
        uint64_t v19 = *(void *)(a3 + 8 * v11);
        return [v17 setVertexBuffer:v18 offset:v19 atIndex:v13];
      }
      else
      {
        uint64_t v20 = (uint64_t *)(a2 - v10);
        uint64_t v21 = (uint64_t *)(a3 - v10);
        __n128 result = objc_msgSend(*(id *)(v9 + 3392), "setVertexBuffers:offsets:withRange:", v20, v21, v13, a5 - v11);
        if (a5 > v11)
        {
          do
          {
            uint64_t v22 = *v20++;
            *(i - 1) = v22;
            uint64_t v23 = *v21++;
            *uint64_t i = v23;
            i += 2;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  return result;
}

NSUInteger SCNObject_resolveInstanceMethod(objc_class *a1, SEL aSelector)
{
  uint64_t v4 = NSStringFromSelector(aSelector);
  BOOL v5 = [(NSString *)v4 hasPrefix:@"set"];
  if (!v5)
  {
    NSUInteger result = [(NSString *)v4 length];
    if (!result) {
      return result;
    }
    unsigned int outCount = 0;
    uint64_t v13 = class_copyMethodList(a1, &outCount);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = -[NSString capitalizedString](-[NSString substringWithRange:](v4, "substringWithRange:", 0, 1), "capitalizedString");
      if ([(NSString *)v4 length] < 2) {
        unint64_t v16 = &stru_26BF72F58;
      }
      else {
        unint64_t v16 = [(NSString *)v4 substringFromIndex:1];
      }
      uint64_t v17 = [NSString stringWithFormat:@"is%@%@", v15, v16];
      if (outCount)
      {
        uint64_t v18 = (void *)v17;
        uint64_t v19 = 0;
        while (1)
        {
          Name = method_getName(v14[v19]);
          if ([v18 isEqualToString:NSStringFromSelector(Name)]) {
            break;
          }
          if (++v19 >= (unint64_t)outCount) {
            goto LABEL_13;
          }
        }
        free(v14);
        return 1;
      }
LABEL_13:
      free(v14);
    }
    NSUInteger result = (NSUInteger)SCNBaseTypeOfObjCProperty(a1, v4);
    unsigned __int16 v8 = result;
    if (!result) {
      return result;
    }
    uint64_t v21 = (int)result - 1;
    if ((unsigned __int16)(result - 1) >= 0xEu || ((0x27FFu >> v21) & 1) == 0)
    {
LABEL_17:
      uint64_t v22 = scn_default_log();
      NSUInteger result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
      if (result)
      {
        SCNObject_resolveInstanceMethod_cold_1(v8, v22);
        return 0;
      }
      return result;
    }
    uint64_t v12 = qword_20B5EFBE8[v21];
    uint64_t v10 = (void (*)(void))*(&off_26BF722C8 + (__int16)v21);
LABEL_31:
    class_addMethod(a1, aSelector, v10, (&method_encodings[2 * v12])[!v5]);
    return 1;
  }
  uint64_t v6 = (void *)propertyNameForSetter(v4);
  unsigned int v7 = SCNBaseTypeOfObjCProperty(a1, v6);
  unsigned __int16 v8 = v7;
  unsigned int v9 = v7;
  uint64_t v10 = (void (*)(void))SCNFloat_setter;
  NSUInteger result = 0;
  uint64_t v12 = v8;
  switch(v9)
  {
    case 0u:
      return result;
    case 1u:
      goto LABEL_31;
    case 2u:
      uint64_t v10 = (void (*)(void))SCNInteger_setter;
      uint64_t v12 = 2;
      goto LABEL_31;
    case 3u:
      uint64_t v10 = (void (*)(void))SCNBoolean_setter;
      uint64_t v12 = 3;
      goto LABEL_31;
    case 4u:
      uint64_t v10 = (void (*)(void))SCNChar_setter;
      uint64_t v12 = 4;
      goto LABEL_31;
    case 5u:
      uint64_t v10 = (void (*)(void))SCNPointer_setter;
      uint64_t v12 = 5;
      goto LABEL_31;
    case 6u:
      uint64_t v10 = (void (*)(void))SCNDouble_setter;
      uint64_t v12 = 6;
      goto LABEL_31;
    case 7u:
      uint64_t v10 = (void (*)(void))SCNC3DFloat_setter;
      uint64_t v12 = 7;
      goto LABEL_31;
    case 8u:
      uint64_t v10 = (void (*)(void))SCNVector2_setter;
      uint64_t v12 = 8;
      goto LABEL_31;
    case 9u:
      uint64_t v10 = (void (*)(void))SCNVector3_setter;
      uint64_t v12 = 9;
      goto LABEL_31;
    case 0xAu:
      uint64_t v10 = (void (*)(void))SCNVector4_setter;
      uint64_t v12 = 10;
      goto LABEL_31;
    case 0xBu:
      uint64_t v10 = (void (*)(void))SCNMatrix4x4_setter;
      uint64_t v12 = 11;
      goto LABEL_31;
    case 0xEu:
      uint64_t v10 = (void (*)(void))SCNShort_setter;
      uint64_t v12 = 14;
      goto LABEL_31;
    default:
      goto LABEL_17;
  }
  return result;
}

unint64_t anonymous namespace'::add_geometry_sources(_anonymous_namespace_ *this, NSMutableArray *a2, NSMutableArray *a3, MDLMesh *a4, NSDictionary *a5)
{
  uint64_t v6 = (void *)[(NSMutableArray *)a3 vertexDescriptor];
  unint64_t result = objc_msgSend((id)objc_msgSend(v6, "attributes"), "count");
  if (result)
  {
    unint64_t v8 = 0;
    int v9 = 0;
    int v10 = 0;
    uint64_t v11 = *MEMORY[0x263F135C8];
    uint64_t v12 = *MEMORY[0x263F135B8];
    uint64_t v13 = *MEMORY[0x263F135A0];
    uint64_t v14 = *MEMORY[0x263F135A8];
    do
    {
      uint64_t v15 = objc_msgSend((id)objc_msgSend(v6, "attributes"), "objectAtIndexedSubscript:", v8);
      if ([v15 format])
      {
        int v16 = objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v11);
        if (v10 & v16)
        {
          int v10 = 1;
        }
        else
        {
          v10 |= v16;
          int v17 = objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v12);
          if (v9 & v17)
          {
            int v9 = 1;
          }
          else
          {
            v9 |= v17;
            if ((objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v13) & 1) == 0
              && (objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v14) & 1) == 0
              && (objc_msgSend((id)objc_msgSend(v15, "name"), "hasSuffix:", @"UVi") & 1) == 0)
            {
              uint64_t v18 = +[SCNGeometrySource geometrySourceWithMDLVertexAttribute:v15 mesh:a3];
              if (v18)
              {
                [(_anonymous_namespace_ *)this addObject:v18];
                -[NSMutableArray addObject:](a2, "addObject:", [NSNumber numberWithUnsignedInteger:v8]);
              }
            }
          }
        }
      }
      ++v8;
      unint64_t result = objc_msgSend((id)objc_msgSend(v6, "attributes"), "count");
    }
    while (v8 < result);
  }
  return result;
}

void sub_20B252688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DBaseTypeFromDescription(uint64_t a1, uint64_t a2, int a3)
{
  LOWORD(v4) = 6;
  switch(a1)
  {
    case 1:
      if (a3) {
        goto LABEL_10;
      }
      goto LABEL_21;
    case 2:
      char v5 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) >= 4) {
          goto LABEL_10;
        }
        char v6 = 16 * v5;
        unint64_t v7 = 0x2D002C002B000FLL;
      }
      else
      {
        if ((unint64_t)(a2 - 1) >= 4) {
          goto LABEL_21;
        }
        char v6 = 16 * v5;
        unint64_t v7 = 0x2200210020000ELL;
      }
      goto LABEL_20;
    case 4:
      char v8 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) < 4)
        {
          unint64_t v4 = 0xA000900080001uLL >> (16 * v8);
          return (__int16)v4;
        }
LABEL_10:
        if ((C3DBaseTypeFromDescription_done & 1) == 0)
        {
          C3DBaseTypeFromDescription_done = 1;
          int v9 = scn_default_log();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            C3DBaseTypeFromDescription_cold_2();
          }
        }
        if (a2 == 1)
        {
          LOWORD(v4) = 21;
          return (__int16)v4;
        }
        if (a2 == 4)
        {
          LOWORD(v4) = 27;
          return (__int16)v4;
        }
LABEL_27:
        uint64_t v11 = scn_default_log();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeFromDescription_cold_1();
        }
        LOWORD(v4) = 0;
        return (__int16)v4;
      }
      if ((unint64_t)(a2 - 1) >= 4)
      {
LABEL_21:
        if ((C3DBaseTypeFromDescription_done_155 & 1) == 0)
        {
          C3DBaseTypeFromDescription_done_155 = 1;
          int v10 = scn_default_log();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            C3DBaseTypeFromDescription_cold_2();
          }
        }
        if (a2 == 1)
        {
          LOWORD(v4) = 16;
          return (__int16)v4;
        }
        if (a2 == 4)
        {
          LOWORD(v4) = 25;
          return (__int16)v4;
        }
        goto LABEL_27;
      }
      char v6 = 16 * v8;
      unint64_t v7 = 0x14001300120002;
LABEL_20:
      unint64_t v4 = v7 >> v6;
      return (__int16)v4;
    case 8:
      return (__int16)v4;
    default:
      goto LABEL_27;
  }
}

void flip_UVs(MDLVertexFormat a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 == MDLVertexFormatFloat2)
  {
    if (a5)
    {
      char v5 = (float *)&a2[a3 + 4];
      do
      {
        *char v5 = 1.0 - *v5;
        char v5 = (float *)((char *)v5 + a4);
        --a5;
      }
      while (a5);
    }
  }
  else
  {
    char v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v7 = 0;
      _os_log_impl(&dword_20B249000, v6, OS_LOG_TYPE_DEFAULT, "Warning: Warning: unable to flip non-float2 texture coordinates, skipping\n", v7, 2u);
    }
  }
}

void sub_20B253480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SCNMTLFunctionTypeToProgramStage(uint64_t a1)
{
  if (a1 != 3) {
    return a1 == 2;
  }
  char v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    SCNMTLFunctionTypeToProgramStage_cold_1(v2);
  }
  return 2;
}

void std::vector<SCNSemanticBinding>::push_back[abi:nn180100](void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      abort();
    }
    uint64_t v11 = v5 - (void)*a1;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      uint64_t v13 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(_OWORD *)uint64_t v14 = *a2;
    char v8 = v14 + 16;
    int v17 = (char *)*a1;
    int v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      int v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    _OWORD *v7 = *a2;
    char v8 = v7 + 1;
  }
  a1[1] = v8;
}

void *_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a2);
}

uint64_t __structMemberSize(MTLStructMember *a1)
{
  for (int i = 0; ; i += [(MTLStructMember *)a1 offset])
  {
    MTLDataType v3 = [(MTLStructMember *)a1 dataType];
    if (v3 != MTLDataTypeStruct) {
      break;
    }
    a1 = [(NSArray *)[(MTLStructType *)[(MTLStructMember *)a1 structType] members] lastObject];
  }
  if (v3 == MTLDataTypeArray)
  {
    uint64_t v4 = [(MTLStructMember *)a1 arrayType];
    int v5 = [(MTLArrayType *)v4 arrayLength];
    int Size = SCNMTLDataTypeGetSize([(MTLArrayType *)v4 elementType]) * v5;
  }
  else
  {
    int Size = SCNMTLDataTypeGetSize(v3);
  }
  return (Size + i);
}

uint64_t SCNMTLDataTypeGetSize(uint64_t a1)
{
  return mtl_DataTypeSize[a1];
}

objc_property *SCNBaseTypeOfObjCProperty(objc_class *a1, void *a2)
{
  unint64_t result = class_getProperty(a1, (const char *)[a2 UTF8String]);
  if (result)
  {
    MTLDataType v3 = (const char *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(NSString, "stringWithUTF8String:", property_getAttributes(result)), "componentsSeparatedByString:", @","), "objectAtIndex:", 0), "substringFromIndex:", 1), "UTF8String");
    return (objc_property *)SCNObjCEncodedTypeToC3DBaseType(v3);
  }
  return result;
}

uint64_t propertyNameForSetter(void *a1)
{
  CFIndex v1 = (const char *)[a1 UTF8String];
  size_t v2 = strlen(v1);
  MTLDataType v3 = malloc_type_malloc(v2 - 3, 0x52FC7095uLL);
  memcpy(v3, v1 + 3, v2 - 4);
  *MTLDataType v3 = __tolower((char)*v3);
  v3[v2 - 4] = 0;
  uint64_t v4 = [NSString stringWithUTF8String:v3];
  free(v3);
  return v4;
}

uint64_t _C3DCFDictionaryApplyBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

BOOL _C3DRasterizerStatesCFEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) == *(void *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && *(void *)(a1 + 32) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 40) == (unint64_t)*(unsigned int *)(a2 + 40);
}

float C3DEffectCommonProfileGetSelfIlluminationOcclusion(uint64_t a1)
{
  return *(float *)(a1 + 176);
}

uint64_t C3DProgramHashCodeCreate(void *a1, __C3DGeometry *a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, unint64_t a7)
{
  uint64_t v186 = *MEMORY[0x263EF8340];
  if (!a6) {
    return 0;
  }
  if (a5)
  {
    unsigned int v8 = *(unsigned __int16 *)a5;
    int v9 = (v8 >> 1) & 1;
    int v145 = (v8 >> 4) & 7;
    int v10 = v8 & 1;
  }
  else
  {
    LOWORD(v145) = 0;
    int v9 = 0;
    int v10 = 1;
  }
  long long v178 = 0u;
  memset(v179, 0, 88);
  memset(v177, 0, sizeof(v177));
  long long v175 = 0u;
  long long v176 = 0u;
  long long v173 = 0u;
  long long v174 = 0u;
  long long v171 = 0u;
  long long v172 = 0u;
  long long v169 = 0u;
  long long v170 = 0u;
  long long v167 = 0u;
  long long v168 = 0u;
  WORD4(v178) = 7;
  WORD2(v178) = a7;
  BYTE6(v178) = BYTE2(a7);
  BYTE7(v178) = BYTE3(a7);
  int v160 = 0;
  __int16 updated = __UpdateShaderModifiersInProgramHashCode((uint64_t)&v167, a6, 0, (_WORD *)&v160 + 1, &v160);
  __int16 v148 = __UpdateShaderModifiersInProgramHashCode((uint64_t)&v167, (uint64_t)a2, 1, (_WORD *)&v160 + 1, &v160);
  C3DNodeGetWorldAlpha((uint64_t)a1);
  float v14 = v13;
  uint64_t CommonProfile = (float *)C3DMaterialGetCommonProfile(a6);
  int TransparencyMode = C3DEffectCommonProfileGetTransparencyMode((uint64_t)CommonProfile);
  if (TransparencyMode == 1)
  {
    BOOL v150 = v14 >= 1.0;
    Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)CommonProfile, 5);
    uint64_t v16 = a3;
    if ((C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)CommonProfile, 5) & 1) != 0
      || !C3DColor4IsBlack(Color) && C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18) != 0.0)
    {
      BOOL v150 = 0;
    }
  }
  else
  {
    BOOL v150 = (float)(v14 * C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18)) >= 1.0;
    uint64_t v16 = a3;
  }
  int LightingModel = C3DEffectCommonProfileGetLightingModel((uint64_t)CommonProfile);
  int v19 = LightingModel;
  if (LightingModel == 5) {
    int v20 = 1;
  }
  else {
    int v20 = v9;
  }
  BOOL v22 = LightingModel != 4 && v10 == 0 || LightingModel == 5;
  if ((LightingModel | 4) == 4) {
    int v20 = 0;
  }
  int v157 = v20;
  if (a1)
  {
    BOOL v23 = C3DNodeGetLightmapInfo((uint64_t)a1) != 0;
    if (v16)
    {
LABEL_25:
      BOOL v24 = C3DMeshContainsSourcesWithSemantic(v16, 2);
      goto LABEL_28;
    }
  }
  else
  {
    BOOL v23 = 0;
    if (v16) {
      goto LABEL_25;
    }
  }
  BOOL v24 = 0;
LABEL_28:
  uint64_t v25 = a2;
  BOOL v156 = v22;
  if (a2)
  {
    BOOL WantsHardwareTessellation = C3DGeometryGetWantsHardwareTessellation(a2);
    if (WantsHardwareTessellation)
    {
      C3DGeometryGetTessellator((uint64_t)a2, &v159);
      int v27 = v159.n128_u8[12];
      uint64_t v25 = a2;
    }
    else
    {
      int v27 = 0;
    }
    CFTypeID v29 = CFGetTypeID(v25);
    BOOL v28 = v29 == C3DBezierCurveGeometryGetTypeID();
  }
  else
  {
    int v27 = 0;
    BOOL WantsHardwareTessellation = 0;
    BOOL v28 = 0;
  }
  if (a1
    && (Skinner = C3DNodeGetSkinner((uint64_t)a1), (uint64_t v31 = Skinner) != 0)
    && C3DSkinnerGetEffectiveCalculationMode(Skinner, a2) == 1)
  {
    uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial(v31);
    if (!OverrideMaterial)
    {
      v147 = scn_default_log();
      if (os_log_type_enabled(v147, OS_LOG_TYPE_FAULT)) {
        C3DSkinnerUpdateJointsAndBoundingBox_cold_7(v147, v33, v34, v35, v36, v37, v38, v39);
      }
    }
    int MaxInfluencesPerVertex = C3DSkinGetMaxInfluencesPerVertex(OverrideMaterial);
    if (MaxInfluencesPerVertex >= 4) {
      LODWORD(v41) = 4;
    }
    else {
      LODWORD(v41) = MaxInfluencesPerVertex;
    }
    uint64_t v41 = (int)v41;
  }
  else
  {
    uint64_t v41 = 0;
  }
  uint64_t v143 = v41;
  int v42 = v23 | (v41 << 28);
  if (v24) {
    int v43 = 2;
  }
  else {
    int v43 = 0;
  }
  int v44 = v42 | v43;
  if (WantsHardwareTessellation) {
    int v45 = 4;
  }
  else {
    int v45 = 0;
  }
  int v46 = v44 | v45 | (8 * v27);
  if (v28) {
    int v47 = 0x8000000;
  }
  else {
    int v47 = 0;
  }
  HIDWORD(v174) = v46 | v47;
  WORD4(v174) = C3DEffectCommonProfileGetHashCode((uint64_t)CommonProfile);
  if (!C3DGeometryOpenSubdivGPUIsActive(a2))
  {
    char v53 = BYTE10(v178) & 0xF8;
    goto LABEL_64;
  }
  memset(&c, 0, 24);
  C3DGeometryGetTessellator((uint64_t)a2, (__n128 *)&c);
  uint64_t v48 = (a7 >> 24) & 7;
  int v49 = BYTE1(c.hash[2]);
  if ((c.hash[2] & 0x100) != 0)
  {
    if (C3DGeometryOpenSubdivGetGPUCanBenefitFromSingleCreasePatches((uint64_t)a2))
    {
      BOOL PathTypeSupportsSingleCrease = C3DSubdivisionGetPathTypeSupportsSingleCrease(v48);
      int v49 = BYTE1(c.hash[2]);
      uint64_t PrimvarDataTypeHash = C3DGeometryOsdGetPrimvarDataTypeHash(a2);
      if (PathTypeSupportsSingleCrease) {
        int v52 = 96;
      }
      else {
        int v52 = 32;
      }
      goto LABEL_63;
    }
    int v49 = BYTE1(c.hash[2]);
  }
  uint64_t PrimvarDataTypeHash = C3DGeometryOsdGetPrimvarDataTypeHash(a2);
  int v52 = 32;
LABEL_63:
  HIDWORD(v174) |= v52 & 0xF80000FF | ((PrimvarDataTypeHash & 0x7FFFF) << 8) | (v49 << 6) & 0x80;
  char v53 = BYTE10(v178) & 0xF8 | v48;
LABEL_64:
  BYTE10(v178) = v53;
  __int16 v149 = v148 | updated;
  if (a5)
  {
    unint64_t v54 = *(unsigned __int16 *)a5;
    unsigned int v55 = *(unsigned __int16 *)a5;
    uint64_t v56 = (v54 >> 7);
    if ((v54 >> 7))
    {
      __memcpy_chk();
      bzero((char *)&v175 + 4 * v56, (32 - (4 * v56)) & 0x3FFFFFFFCLL);
    }
    else
    {
      long long v175 = 0u;
      long long v176 = 0u;
    }
    char v57 = v55 >> 7;
  }
  else
  {
    char v57 = 0;
    long long v175 = 0u;
    long long v176 = 0u;
  }
  uint64_t v58 = 0;
  v177[0] = v57;
  unsigned int v59 = HIWORD(v160);
  do
  {
    unsigned int EffectPropertyHashCode = C3DEffectCommonProfileGetEffectPropertyHashCode(CommonProfile, (char)v58);
    if (EffectPropertyHashCode & 1) != 0 || ((v59 >> v58)) {
      unsigned int EffectPropertyHashCode = __UpdateHashCodeWithTextureType((uint64_t)&v167, a3, (uint64_t)CommonProfile, (char)v58, EffectPropertyHashCode, v59 != 0);
    }
    int v61 = v157;
    if (v58 != 1) {
      int v61 = v156;
    }
    if (v61) {
      int v62 = v19;
    }
    else {
      int v62 = 4;
    }
    if (C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel(v62, (char)v58))
    {
      int v63 = 1;
      switch(v58)
      {
        case 2:
        case 10:
        case 11:
          goto LABEL_114;
        case 5:
          int v63 = (EffectPropertyHashCode >> 5) & 1;
          if ((EffectPropertyHashCode & 8) == 0) {
            int v63 = 1;
          }
          int v64 = EffectPropertyHashCode & 1;
          if ((EffectPropertyHashCode & 2) == 0) {
            int v64 = 1;
          }
          if (TransparencyMode == 1) {
            int v63 = v64;
          }
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 6:
          int v63 = (EffectPropertyHashCode & 4) == 0;
          if (EffectPropertyHashCode) {
            int v63 = 1;
          }
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 13:
          int v63 = (BYTE5(v172) >> 3) & 1;
          if ((EffectPropertyHashCode & 3) == 2) {
            int v63 = 0;
          }
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 14:
          int v63 = EffectPropertyHashCode & ((BYTE5(v172) & 8) >> 3);
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 15:
          int v63 = EffectPropertyHashCode & 1;
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 16:
          int v63 = (BYTE1(v170) >> 3) & 1;
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 17:
          goto LABEL_129;
        case 18:
          int v63 = C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18) < 1.0;
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 19:
          int v63 = (EffectPropertyHashCode & 0x10) == 0;
          if ((EffectPropertyHashCode & 0x2000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_115;
        case 20:
          if ((EffectPropertyHashCode & 0x10) == 0) {
            goto LABEL_114;
          }
          LODWORD(v174) = 0;
          goto LABEL_129;
        default:
          if (EffectPropertyHashCode)
          {
            int v63 = 1;
LABEL_114:
            if ((EffectPropertyHashCode & 0x2000) == 0) {
              goto LABEL_121;
            }
          }
          else
          {
            if (v58 == 6)
            {
              if ((EffectPropertyHashCode & 4) != 0) {
                goto LABEL_129;
              }
            }
            else if ((EffectPropertyHashCode & 2) != 0)
            {
              goto LABEL_129;
            }
            int v63 = !((v19 == 4) & C3DEffectCommonProfileGetEnableNormals((uint64_t)CommonProfile));
            if ((EffectPropertyHashCode & 0x2000) == 0) {
              goto LABEL_121;
            }
          }
LABEL_115:
          if (v58 != 2 && v63)
          {
            float Intensity = C3DEffectCommonProfileGetIntensity((uint64_t)CommonProfile, (char)v58);
            if (Intensity == 0.0) {
              goto LABEL_129;
            }
            unsigned int v66 = EffectPropertyHashCode & 0xFFFFF7FF | ((Intensity != 0.0) << 11);
            goto LABEL_126;
          }
LABEL_121:
          if (v63) {
            int v67 = 2048;
          }
          else {
            int v67 = 0;
          }
          if ((v63 & 1) == 0) {
            goto LABEL_129;
          }
          unsigned int v66 = v67 | EffectPropertyHashCode & 0xFFFFF7FF;
LABEL_126:
          *((_DWORD *)&v169 + v58 + 1) = v66;
          if (v66 >= 0x400000)
          {
            SCNMatrix4 v68 = scn_default_log();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT)) {
              C3DProgramHashCodeCreate_cold_1(buf, &v166, v68);
            }
          }
          break;
      }
    }
    else
    {
LABEL_129:
      *((_DWORD *)&v169 + v58 + 1) = 0;
    }
    ++v58;
  }
  while (v58 != 21);
  *(void *)c.count = MEMORY[0x263EF8330];
  *(void *)c.hash = 3221225472;
  *(void *)&c.hash[2] = ____ComputeCustomSlotsUsage_block_invoke;
  *(void *)&c.hash[4] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  *(void *)&c.hash[6] = &v167;
  C3DEntityEnumerateKeyValuesWithBlockBySortingKeys(a6, (uint64_t)&c);
  *(void *)c.count = MEMORY[0x263EF8330];
  *(void *)c.hash = 3221225472;
  *(void *)&c.hash[2] = ____ComputeCustomSlotsUsage_block_invoke;
  *(void *)&c.hash[4] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  *(void *)&c.hash[6] = &v167;
  C3DEntityEnumerateKeyValuesWithBlockBySortingKeys((uint64_t)a2, (uint64_t)&c);
  int v69 = 0;
  unsigned int v70 = (unsigned __int16)v160;
  unsigned __int8 v71 = v177[3];
  do
  {
    if ((v70 >> v69))
    {
      if (v71)
      {
        uint64_t v72 = v71;
        SCNMatrix4 v73 = &v177[4];
        uint64_t v74 = v71;
        while (1)
        {
          int v75 = *v73;
          v73 += 2;
          if (v69 == v75) {
            break;
          }
          if (!--v74) {
            goto LABEL_139;
          }
        }
      }
      else
      {
        uint64_t v72 = 0;
LABEL_139:
        SCNMatrix4 v76 = (char *)&v167 + 2 * v72;
        v76[164] = v69;
        v76[165] = -1;
        v177[3] = ++v71;
      }
    }
    ++v69;
  }
  while (v69 != 16);
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 7, 0);
  uint64_t v78 = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 14, 0);
  uint64_t v79 = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 15, 0);
  if (EffectSlot)
  {
    if (C3DEffectSlotHasImageOrTexture(EffectSlot)) {
      __int16 v80 = 16;
    }
    else {
      __int16 v80 = 0;
    }
    WORD4(v178) = WORD4(v178) & 0xFFEF | v80;
  }
  if (v79)
  {
    BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(v79);
    __int16 v82 = BYTE8(v178) & 0x10;
    if (HasImageOrTexture) {
      __int16 v82 = 16;
    }
    WORD4(v178) = v82 | WORD4(v178) & 0xFFEF;
  }
  if (v78)
  {
    BOOL v83 = C3DEffectSlotHasImageOrTexture(v78);
    __int16 v84 = BYTE8(v178) & 0x10;
    if (v83) {
      __int16 v84 = 16;
    }
    __int16 v85 = v84 | WORD4(v178) & 0xFFEF;
  }
  else
  {
    __int16 v85 = WORD4(v178);
  }
  WORD4(v178) = v85 | (4 * v149) & 0x10;
  uint64_t v86 = a3;
  if (v85 & 0x10 | (4 * (_BYTE)v149) & 0x10)
  {
    __int16 v87 = C3DMeshGetSourcesCountForSemantic(a3, 3) > 0;
    WORD4(v178) = WORD4(v178) & 0xFFEF | (16 * v87);
    uint64_t v86 = a3;
  }
  BOOL v88 = v86 == 0;
  BOOL EffectiveDataKindForRendering = C3DGeometryGetEffectiveDataKindForRendering(a2);
  if (v88)
  {
    __int16 v92 = 0;
    __int16 v91 = WORD4(v178);
  }
  else
  {
    __int16 v90 = C3DMeshGetSourceWithSemanticAtIndex(a3, 1, 0, EffectiveDataKindForRendering) != 0;
    __int16 v91 = WORD4(v178);
    __int16 v92 = 8 * v90;
  }
  WORD4(v178) = v91 & 0xFFF7 | v92;
  if (a1)
  {
    uint64_t v93 = C3DGetScene(a1);
    if (v93)
    {
      if (C3DSceneGetFogEndDistance(v93) > 0.0) {
        WORD4(v178) |= 0x80u;
      }
    }
  }
  if (v150) {
    int IsOpaque = C3DEffectCommonProfileIsOpaque((uint64_t)CommonProfile);
  }
  else {
    int IsOpaque = 0;
  }
  if ((v149 & 2) != 0)
  {
    int v96 = 0;
    BlendStatesUseConstantAlphSCNMatrix4 a = 0;
  }
  else
  {
    int v95 = (v149 & 2) >> 1;
    if (a3 && C3DMeshHasNonOpaqueColorSources(a3)) {
      int v95 = 1;
    }
    int v96 = 0;
    BlendStatesUseConstantAlphSCNMatrix4 a = 0;
    if (v19 != 6 && !v95)
    {
      BlendStatesUseConstantAlphSCNMatrix4 a = C3DMaterialGetBlendStatesUseConstantAlpha(a6, IsOpaque);
      int v96 = IsOpaque;
    }
  }
  if (v19 == 5) {
    BlendStatesUseConstantAlpha &= ~((TransparencyMode != 1) & C3DPBROpacityIsEnabled());
  }
  int v98 = C3DWasLinkedBeforeMajorOSYear2017();
  BOOL v99 = v156;
  if ((v98 & v156) == 1) {
    BOOL v99 = C3DMeshGetNormalSource(a3, 0) != 0;
  }
  if (v96) {
    __int16 v100 = 4;
  }
  else {
    __int16 v100 = 0;
  }
  if (BlendStatesUseConstantAlpha) {
    __int16 v101 = 2;
  }
  else {
    __int16 v101 = 0;
  }
  if (v99) {
    __int16 v102 = 32;
  }
  else {
    __int16 v102 = 0;
  }
  if (v157) {
    __int16 v103 = 64;
  }
  else {
    __int16 v103 = 0;
  }
  WORD4(v178) = v103 | v150 | v100 | v101 | v102 | WORD4(v178) & 0xFF98;
  LOBYTE(v104) = (_BYTE)a5;
  if (a5)
  {
    BYTE10(v178) = (2 * *a5) & 0x18 | BYTE10(v178) & 0xE7;
    uint64_t CategoryBitMask = C3DNodeGetCategoryBitMask((uint64_t)a1);
    unint64_t v106 = *(unsigned __int16 *)a5;
    uint64_t v107 = (v106 >> 7);
    if ((v106 >> 7))
    {
      uint64_t v108 = 0;
      int v104 = 0;
      uint64_t v109 = (uint64_t)a2;
      do
      {
        uint64_t v110 = *(void *)&a5[8 * v108 + 40];
        int v111 = v104 | (1 << v108);
        if ((v110 & CategoryBitMask) == 0) {
          int v111 = v104;
        }
        if (v19 != 5) {
          v104 |= 1 << v108;
        }
        if (v110 != 0xDEFA017DEFA017) {
          int v104 = v111;
        }
        ++v108;
      }
      while (v107 != v108);
      goto LABEL_205;
    }
    LOBYTE(v104) = 0;
  }
  else
  {
    BYTE10(v178) &= 0xE7u;
  }
  uint64_t v109 = (uint64_t)a2;
LABEL_205:
  v177[1] = v104;
  __int16 v112 = ((_WORD)v145 << 11) | 0x400;
  if (v19 != 5) {
    __int16 v112 = 0;
  }
  WORD4(v178) = v112 | WORD4(v178) & 0xC3FF;
  int IsDynamicBatchingEnabled = C3DGeometryIsDynamicBatchingEnabled(v109);
  if (v143) {
    int v114 = 0;
  }
  else {
    int v114 = IsDynamicBatchingEnabled;
  }
  if ((v114 & v150) != 0) {
    __int16 v115 = 256;
  }
  else {
    __int16 v115 = 0;
  }
  WORD4(v178) = v115 | WORD4(v178) & 0xFCFF;
  if (a4)
  {
    __int16 v116 = C3DMeshElementGetType(a4) == 3;
    WORD4(v178) = WORD4(v178) & 0xFDFF | (v116 << 9);
  }
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  uint64_t v117 = 0;
  uint64_t v118 = MEMORY[0x263EF8330];
  char v119 = 1;
  do
  {
    int v120 = 0;
    char v121 = v119;
    CFArrayRef v122 = (const __CFArray *)*((void *)&v168 + v117);
    do
    {
      v162[0] = v118;
      v162[1] = 3221225472;
      v162[2] = ____createHashCode_block_invoke;
      v162[3] = &__block_descriptor_44_e13_v24__0q8r_v16l;
      int v163 = v120;
      v162[4] = &c;
      C3DCFArrayApplyBlock(v122, (uint64_t)v162);
      ++v120;
    }
    while (v120 != 4);
    char v119 = 0;
    uint64_t v117 = 1;
  }
  while ((v121 & 1) != 0);
  for (uint64_t i = 216; i != 280; i += 8)
  {
    uint64_t v124 = *(void *)((char *)&v167 + i);
    if (v124) {
      CFStringUpdateHash(v124);
    }
  }
  CC_SHA256_Update(&c, (char *)&v169 + 4, 0xB4u);
  datSCNMatrix4 a = 2;
  CC_SHA256_Update(&c, &data, 4u);
  CC_SHA256_Final(md, &c);
  uint64_t v125 = 0;
  v126 = cStr;
  v127.i64[0] = 0xA0A0A0A0A0A0A0A0;
  v127.i64[1] = 0xA0A0A0A0A0A0A0A0;
  v128.i64[0] = 0x3737373737373737;
  v128.i64[1] = 0x3737373737373737;
  v129.i64[0] = 0x3030303030303030;
  v129.i64[1] = 0x3030303030303030;
  v130.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v130.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  v131.i64[0] = 0xA0A0A0A0A0A0A0ALL;
  v131.i64[1] = 0xA0A0A0A0A0A0A0ALL;
  do
  {
    int8x16_t v132 = *(int8x16_t *)&md[v125];
    v187.val[0] = (int8x16_t)vsraq_n_u8((uint8x16_t)vbslq_s8((int8x16_t)vcgtq_u8(v127, (uint8x16_t)v132), v129, v128), (uint8x16_t)v132, 4uLL);
    int8x16_t v133 = vandq_s8(v132, v130);
    v187.val[1] = vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v131, (uint8x16_t)v133), v129, v128), v133);
    vst2q_s8(v126, v187);
    v126 += 32;
    v125 += 16;
  }
  while (v125 != 32);
  char v184 = 0;
  CFStringRef v134 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x600u);
  if (C3DProgramHashCodeCreate_once != -1) {
    dispatch_once(&C3DProgramHashCodeCreate_once, &__block_literal_global_11_1);
  }
  *(void *)c.count = 0;
  *(void *)c.hash = &c;
  *(void *)&c.hash[2] = 0x2020000000;
  *(void *)&c.hash[4] = 0;
  *(void *)cStr = 0;
  v181 = cStr;
  uint64_t v182 = 0x2020000000;
  uint64_t v183 = 0;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __C3DProgramHashCodeCreate_block_invoke_2;
  block[3] = &unk_264009BB0;
  block[4] = cStr;
  block[5] = &c;
  block[6] = v134;
  block[7] = &v167;
  block[8] = a1;
  block[9] = a2;
  block[10] = a3;
  block[11] = a5;
  block[12] = a6;
  dispatch_sync((dispatch_queue_t)s_ProgramHashCodeDictionaryQueue, block);
  CFRelease(v134);
  uint64_t v135 = 0;
  char v136 = 1;
  do
  {
    char v137 = v136;
    v138 = (const void *)*((void *)&v168 + v135);
    if (v138)
    {
      CFRelease(v138);
      *((void *)&v168 + v135) = 0;
    }
    char v136 = 0;
    uint64_t v135 = 1;
  }
  while ((v137 & 1) != 0);
  unsigned int v139 = v177[2];
  if (v177[2])
  {
    unint64_t v140 = 0;
    do
    {
      v141 = (const void *)v179[v140 + 1];
      if (v141)
      {
        CFRelease(v141);
        v179[v140 + 1] = 0;
        unsigned int v139 = v177[2];
      }
      ++v140;
    }
    while (v140 < v139);
  }
  uint64_t v11 = *(void *)(*(void *)c.hash + 24);
  _Block_object_dispose(cStr, 8);
  _Block_object_dispose(&c, 8);
  return v11;
}

void sub_20B255378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  _Block_object_dispose((const void *)(v43 - 224), 8);
  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel(int a1, int a2)
{
  if ((C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapsReady & 1) == 0)
  {
    int v4 = a1;
    int v5 = a2;
    uint64_t v2 = 0;
    *(int *)((char *)&dword_267696D52 + 1) = 0;
    xmmword_267696D34 = 0u;
    unk_267696D44 = 0u;
    xmmword_267696D14 = 0u;
    unk_267696D24 = 0u;
    xmmword_267696CF4 = 0u;
    unk_267696D04 = 0u;
    xmmword_267696CD4 = 0u;
    unk_267696CE4 = 0u;
    C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities = 0u;
    while (2)
    {
      switch(v2)
      {
        case 0:
          LODWORD(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 65793;
          WORD2(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 257;
          BYTE6(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 1;
          *(_DWORD *)((char *)&C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities
                    + 7) = 0;
          BYTE11(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 0;
          HIDWORD(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 0x1000000;
          LOBYTE(xmmword_267696CD4) = 0;
          *(_DWORD *)((char *)&xmmword_267696CD4 + 1) = 16843009;
          goto LABEL_10;
        case 1:
          *(void *)((char *)&xmmword_267696CD4 + 5) = 0x101010100010101;
          *(_WORD *)((char *)&xmmword_267696CD4 + 13) = 257;
          *(_DWORD *)((char *)&xmmword_267696CD4 + 15) = 0;
          byte_267696CE7 = 0;
          unk_267696CE8 = 1;
          unk_267696CEA = 16843009;
          goto LABEL_10;
        case 2:
          unk_267696CEE = 0x101010101010101;
          WORD1(xmmword_267696CF4) = 257;
          DWORD1(xmmword_267696CF4) = 0;
          BYTE8(xmmword_267696CF4) = 0;
          *(_DWORD *)((char *)&xmmword_267696CF4 + 9) = 16843009;
          *(_WORD *)((char *)&xmmword_267696CF4 + 13) = 257;
          goto LABEL_10;
        case 3:
          *(void *)((char *)&xmmword_267696CF4 + 15) = 0x101010101010101;
          word_267696D0B = 257;
          unk_267696D0D = 0;
          byte_267696D11 = 0;
          *(_DWORD *)algn_267696D12 = 16843009;
          WORD1(xmmword_267696D14) = 257;
          goto LABEL_10;
        case 4:
          DWORD1(xmmword_267696D14) = 65537;
          WORD4(xmmword_267696D14) = 257;
          BYTE10(xmmword_267696D14) = 1;
          *(void *)((char *)&xmmword_267696D14 + 11) = 0;
          unk_267696D27 = 1;
          unk_267696D29 = 16843009;
          goto LABEL_10;
        case 5:
          dword_267696D2D = 65537;
          word_267696D31 = 256;
          byte_267696D33 = C3DWasLinkedBeforeMajorOSYear2018() ^ 1;
          *(void *)&xmmword_267696D34 = 0x101010101010101;
          BYTE8(xmmword_267696D34) = 1;
          *(_DWORD *)((char *)&xmmword_267696D34 + 9) = 0x10000;
          BYTE13(xmmword_267696D34) = 0;
          goto LABEL_10;
        case 6:
          *(void *)((char *)&xmmword_267696D34 + 14) = 0;
          unk_267696D4A = 0;
          dword_267696D52 = 0x10000;
          byte_267696D56 = 0;
          goto LABEL_11;
        default:
LABEL_10:
          if (++v2 != 7) {
            continue;
          }
LABEL_11:
          C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapsReady = 1;
          a1 = v4;
          a2 = v5;
          break;
      }
      break;
    }
  }
  return *((unsigned __int8 *)&C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities
         + 21 * a1
         + a2);
}

uint64_t C3DEffectCommonProfileGetEffectPropertyHashCode(float *a1, unsigned int a2)
{
  uint64_t v4 = 0;
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)a1, a2, 0);
  if (a2 >= 0x10)
  {
    if (a2 <= 0x14 && ((1 << a2) & 0x1D0000) != 0) {
      return 16 * (C3DEffectCommonProfileGetFloatProperty(a1, a2) == 0.0);
    }
    return v4;
  }
  else
  {
    return _C3DEffectSlotGetHashCode(EffectSlot, a2);
  }
}

uint64_t C3DEffectCommonProfileGetEffectSlot(uint64_t a1, int a2, int a3)
{
  if (!a1)
  {
    unint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DEffectCommonProfileReleaseSlot_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  switch(a2)
  {
    case 0:
      float v14 = (uint64_t *)(a1 + 32);
      goto LABEL_22;
    case 1:
      float v14 = (uint64_t *)(a1 + 40);
      goto LABEL_22;
    case 2:
      float v14 = (uint64_t *)(a1 + 48);
      goto LABEL_22;
    case 3:
      float v14 = (uint64_t *)(a1 + 56);
      goto LABEL_22;
    case 4:
      float v14 = (uint64_t *)(a1 + 64);
      goto LABEL_22;
    case 5:
      float v14 = (uint64_t *)(a1 + 72);
      goto LABEL_22;
    case 6:
      float v14 = (uint64_t *)(a1 + 80);
      goto LABEL_22;
    case 7:
      float v14 = (uint64_t *)(a1 + 88);
      goto LABEL_22;
    case 8:
      float v14 = (uint64_t *)(a1 + 104);
      goto LABEL_22;
    case 9:
      float v14 = (uint64_t *)(a1 + 96);
      goto LABEL_22;
    case 10:
      float v14 = (uint64_t *)(a1 + 112);
      goto LABEL_22;
    case 11:
      float v14 = (uint64_t *)(a1 + 120);
      goto LABEL_22;
    case 12:
      float v14 = (uint64_t *)(a1 + 136);
      goto LABEL_22;
    case 13:
      float v14 = (uint64_t *)(a1 + 144);
      goto LABEL_22;
    case 14:
      float v14 = (uint64_t *)(a1 + 152);
      goto LABEL_22;
    case 15:
      float v14 = (uint64_t *)(a1 + 128);
LABEL_22:
      uint64_t result = *v14;
      if (a3)
      {
        if (!result)
        {
          uint64_t v16 = C3DEffectSlotCreate(a1, a2);
          *float v14 = v16;
          int v17 = (float *)C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
          C3DEffectSlotSetColor(v16, v17);
          uint64_t result = *v14;
        }
      }
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _C3DEffectSlotGetHashCode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v8 = (float *)C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
    goto LABEL_5;
  }
  BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(a1);
  int v4 = 1;
  if (!HasImageOrTexture)
  {
    unsigned int v12 = *(unsigned __int8 *)(a1 + 50);
    BOOL v13 = v12 > 0xF;
    int v14 = (1 << v12) & 0x8C80;
    BOOL v15 = v13 || v14 == 0;
    if (!v15)
    {
      BOOL v5 = 0;
      BOOL IsWhite = 0;
      BOOL IsBlack = 0;
      int v4 = 0;
      goto LABEL_12;
    }
    uint64_t v8 = (float *)(a1 + 16);
LABEL_5:
    BOOL IsBlack = C3DColor4IsBlack(v8);
    BOOL IsWhite = C3DColor4IsWhite(v8);
    int v4 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    BOOL v5 = v8[3] >= 1.0;
    if (!a1) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  BOOL v5 = 0;
  BOOL IsWhite = 0;
  BOOL IsBlack = 0;
LABEL_12:
  int v9 = (*(float *)(a1 + 72) != 1.0) << 13;
  int v16 = (*(unsigned __int16 *)(a1 + 48) >> 11) & 0xF;
  BOOL v15 = v16 == 15;
  int v11 = v16 << 14;
  if (v15) {
    int v11 = 0;
  }
  int v10 = v4;
LABEL_15:
  if (IsBlack) {
    int v17 = 2;
  }
  else {
    int v17 = 0;
  }
  if (IsWhite) {
    int v18 = 4;
  }
  else {
    int v18 = 0;
  }
  if (v5) {
    int v19 = 8;
  }
  else {
    int v19 = 0;
  }
  return v10 | v9 | v17 | v18 | v11 | v19;
}

float C3DEffectCommonProfileGetFloatProperty(float *a1, int a2)
{
  if (!a1)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float result = 0.0;
  switch(a2)
  {
    case 16:
      float result = a1[40];
      break;
    case 18:
      float result = a1[41];
      break;
    case 19:
      float result = a1[42];
      break;
    case 20:
      float result = a1[43];
      break;
    default:
      return result;
  }
  return result;
}

BOOL C3DColor4IsWhite(float *a1)
{
  return fabsf(*a1 + -1.0) <= 0.001 && fabsf(a1[1] + -1.0) <= 0.001 && fabsf(a1[2] + -1.0) <= 0.001;
}

uint64_t C3DEffectSlotCreate(uint64_t a1, int a2)
{
  if (C3DEffectSlotGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEffectSlotGetTypeID_onceToken, &__block_literal_global_34);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DEffectSlotGetTypeID_typeID, 0x50uLL);
  *(unsigned char *)(result + 50) = a2;
  *(void *)(result + 72) = 0xFFFFFFFE3F800000;
  *(void *)(result + 80) = a1;
  uint64_t v5 = a2 - 5;
  if (v5 > 0x15) {
    __int16 v6 = 1024;
  }
  else {
    __int16 v6 = word_20B5ED9E6[v5];
  }
  if (a2 == 15) {
    __int16 v7 = 0x4000;
  }
  else {
    __int16 v7 = 30720;
  }
  *(_WORD *)(result + 48) = v6 | v7 | *(_WORD *)(result + 48) & 0x83FF;
  return result;
}

void C3DCFArrayApplyBlock(const __CFArray *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      v3[0] = 0;
      v3[1] = a2;
      v4.length = CFArrayGetCount(a1);
      v4.location = 0;
      CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)_C3DCFArrayApplyBlock, v3);
    }
  }
}

BOOL C3DEffectSlotHasImageOrTexture(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Image = C3DEffectSlotGetImage(a1);
  return Image && (C3DImageIsValid(Image) & 1) != 0
      || C3DEffectSlotGetImageProxy(a1)
      || C3DEffectSlotGetTexture(a1)
      || C3DEffectSlotGetMTLTexture(a1) != 0;
}

uint64_t C3DEffectSlotGetImage(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 48)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 40);
  }
}

uint64_t C3DEffectSlotGetImageProxy(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 48) == 2) {
    return *(void *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t C3DEffectSlotGetMTLTexture(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 48) == 3) {
    return *(void *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t C3DEffectSlotGetTexture(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(unsigned __int8 *)(a1 + 48);
  if (v10 == 2) {
    return *(void *)(a1 + 32);
  }
  if (v10 == 1) {
    return *(void *)(a1 + 40);
  }
  return 0;
}

uint64_t C3DImageIsValid(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  unsigned int v10 = *(unsigned __int8 *)(a1 + 116);
  if ((v10 & 0x20) == 0)
  {
    CFBooleanRef Attribute = C3DImageGetAttribute(a1, @"isAttachment");
    if (Attribute)
    {
      int Value = CFBooleanGetValue(Attribute);
      if (*(_DWORD *)(a1 + 96) == 5 || Value) {
        goto LABEL_8;
      }
    }
    else if (*(_DWORD *)(a1 + 96) == 5)
    {
LABEL_8:
      int v13 = *(unsigned __int8 *)(a1 + 116) | 0x10;
LABEL_11:
      unsigned int v10 = v13 | 0x20;
      *(unsigned char *)(a1 + 116) = v10;
      return (v10 >> 4) & 1;
    }
    C3DImageGetSize(a1);
    int v13 = *(unsigned __int8 *)(a1 + 116);
    goto LABEL_11;
  }
  return (v10 >> 4) & 1;
}

BOOL C3DGeometryOpenSubdivGPUIsActive(__C3DGeometry *a1)
{
  return a1->var11.var0 == 4 && a1->var10.var0 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

uint64_t C3DEffectCommonProfileGetTransparencyMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 180);
}

uint64_t __UpdateShaderModifiersInProgramHashCode(uint64_t a1, uint64_t a2, int a3, _WORD *a4, _WORD *a5)
{
  CFDictionaryRef ShaderModifiers = C3DEntityGetShaderModifiers(a2);
  uint64_t v11 = a1 + 16;
  unint64_t v12 = *(void *)(a1 + 16 + 8 * a3);
  if (!((unint64_t)ShaderModifiers | v12)) {
    goto LABEL_25;
  }
  CFArrayRef v13 = ShaderModifiers;
  if (ShaderModifiers)
  {
    if (v12 && CFEqual(ShaderModifiers, (CFTypeRef)v12)) {
      goto LABEL_25;
    }
  }
  uint64_t v14 = a3;
  CFIndex Count = CFArrayGetCount(v13);
  if (v13)
  {
    uint64_t v16 = Count;
    if (Count)
    {
      CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v13);
      CFArrayRef v18 = *(CFArrayRef *)(v11 + 8 * v14);
      if (v18 != Copy)
      {
        if (v18)
        {
          CFRelease(v18);
          *(void *)(v11 + 8 * v14) = 0;
        }
        if (Copy) {
          CFTypeRef v19 = CFRetain(Copy);
        }
        else {
          CFTypeRef v19 = 0;
        }
        *(void *)(v11 + 8 * v14) = v19;
      }
      CFRelease(Copy);
      CFDictionaryRef ShadableMinimumMTLLanguageVersion = C3DEntityGetShadableMinimumMTLLanguageVersion(a2);
      if (ShadableMinimumMTLLanguageVersion)
      {
        unint64_t valuePtr = 0;
        CFNumberGetValue(ShadableMinimumMTLLanguageVersion, kCFNumberNSIntegerType, &valuePtr);
        unint64_t v23 = *(unsigned int *)(a1 + 32);
        if (valuePtr > v23) {
          LODWORD(v23) = valuePtr;
        }
        *(_DWORD *)(a1 + 32) = v23;
      }
      if (v16 >= 1)
      {
        CFIndex v24 = 0;
        int v21 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v13, v24);
          v21 |= C3DShaderModifierGetFlags((uint64_t)ValueAtIndex);
          *a4 |= C3DShaderModifierGetEffectPropertyMaskForTexcoordsUse((uint64_t)ValueAtIndex);
          *a5 |= C3DShaderModifierGetMappingChannelyMaskForTexcoordsUse((uint64_t)ValueAtIndex);
          ++v24;
        }
        while (v16 != v24);
        return (__int16)v21;
      }
LABEL_25:
      LOWORD(v21) = 0;
      return (__int16)v21;
    }
  }
  int v20 = *(const void **)(v11 + 8 * v14);
  if (v20)
  {
    CFRelease(v20);
    *(void *)(v11 + 8 * v14) = 0;
  }
  LOWORD(v21) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return (__int16)v21;
}

CFDictionaryRef C3DEntityEnumerateKeyValuesWithBlockBySortingKeys(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"_kvc");
    if (result) {
      return (const __CFDictionary *)C3DKeyValueStoreEnumerateBySortingKeys((uint64_t)result, a2);
    }
  }
  return result;
}

uint64_t __UpdateHashCodeWithTextureType(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, char a6)
{
  int v12 = C3DEffectCommonProfileContainsContentForEffectProperty(a3, a4);
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a3, a4, 0);
  BOOL HasInterpolationModesPerKey = 0;
  if (a4 != 4 && EffectSlot) {
    BOOL HasInterpolationModesPerKey = C3DKeyframeControllerHasInterpolationModesPerKey(EffectSlot);
  }
  if (!a3 || a4 == 4)
  {
    uint64_t v18 = a5 & 0xFFFFFFFE | v12;
    if (!v12) {
      return v18;
    }
  }
  else
  {
    uint64_t UVSet = C3DEffectCommonProfileGetUVSet(a3, a4);
    if (UVSet == -1) {
      uint64_t UVSet = C3DMaterialDefaultUVSetForProperty(a4);
    }
    if (UVSet == -1) {
      int v16 = 0;
    }
    else {
      int v16 = v12;
    }
    if (v16 == 1)
    {
      if (C3DMeshGetSourceWithSemanticAtIndex(a2, 3, UVSet, 0))
      {
        int v17 = 1;
        goto LABEL_24;
      }
LABEL_21:
      if (UVSet == -1 || (a6 & 1) == 0) {
        return a5 & 0xFFC3FFFE | ((UVSet & 0xF) << 18);
      }
      int v17 = 0;
LABEL_24:
      uint64_t v18 = a5 & 0xFFC3FFFE | v17 & 0xFFC3FFFF | ((__UpdateHashCodeUVSetForEffectProperty(a1, UVSet, HasInterpolationModesPerKey, a4) & 0xF) << 18);
      if ((v17 & 1) == 0) {
        return v18;
      }
      goto LABEL_25;
    }
    if (UVSet == -1) {
      int v19 = v12;
    }
    else {
      int v19 = 0;
    }
    if (v19 != 1) {
      goto LABEL_21;
    }
    LODWORD(v18) = a5 | 0x3C0001;
  }
LABEL_25:
  int v35 = 0;
  unsigned __int8 v34 = 0;
  unsigned __int8 v33 = 1;
  uint64_t v20 = C3DEffectCommonProfileGetEffectSlot(a3, a4, 0);
  if (!v20 || (C3DEffectSlotGetTextureInfo(v20, &v35, &v34, &v33), (int v21 = v35) == 0))
  {
    int v21 = 2;
    int v35 = 2;
  }
  int v22 = v18 & 0xFFFFE81F | (32 * v34) | (v33 << 10);
  if (HasInterpolationModesPerKey) {
    int v23 = 4096;
  }
  else {
    int v23 = 0;
  }
  if (v21 >= 7)
  {
    CFIndex v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      __UpdateHashCodeWithTextureType_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  return v22 | v23 | (v35 << 6);
}

uint64_t C3DEffectCommonProfileContainsContentForEffectProperty(uint64_t a1, int a2)
{
  uint64_t result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result)
  {
    return C3DEffectSlotHasImageOrTexture(result);
  }
  return result;
}

BOOL C3DKeyframeControllerHasInterpolationModesPerKey(uint64_t a1)
{
  return *(void *)(a1 + 64) != 0;
}

uint64_t __UpdateHashCodeUVSetForEffectProperty(uint64_t a1, uint64_t a2, int a3, char a4)
{
  uint64_t v4 = *(unsigned __int8 *)(a1 + 163);
  if (a3)
  {
LABEL_7:
    LODWORD(v5) = *(unsigned __int8 *)(a1 + 163);
LABEL_8:
    uint64_t v7 = a1 + 2 * v4;
    *(unsigned char *)(v7 + 164) = a2;
    if (!a3) {
      a4 = -1;
    }
    *(unsigned char *)(v7 + 165) = a4;
    *(unsigned char *)(a1 + 163) = v4 + 1;
    return v5;
  }
  if (*(unsigned char *)(a1 + 163))
  {
    uint64_t v5 = 0;
    uint64_t v6 = (unsigned __int8 *)(a1 + 165);
    while (*(v6 - 1) != a2 || *v6 != 255)
    {
      v6 += 2;
      if (v4 == ++v5) {
        goto LABEL_7;
      }
    }
    int v10 = *(unsigned __int8 *)(a1 + 163);
  }
  else
  {
    int v10 = 0;
    LODWORD(v5) = 0;
  }
  if (v5 == v10) {
    goto LABEL_8;
  }
  return v5;
}

uint64_t C3DEffectCommonProfileGetUVSet(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (!EffectSlot) {
    return -1;
  }
  int v13 = *(_DWORD *)(EffectSlot + 76);
  if (v13 == -2)
  {
    if (*(unsigned char *)(EffectSlot + 50) == 4) {
      return -1;
    }
    else {
      return 0;
    }
  }
  return v13;
}

uint64_t C3DEffectSlotGetTextureInfo(uint64_t a1, int *a2, unsigned char *a3, unsigned char *a4)
{
  if (!C3DEffectSlotGetTextureSampler(a1)) {
    C3DTextureSamplerGetDefault();
  }
  MTLTexture = (void *)C3DEffectSlotGetMTLTexture(a1);
  if (MTLTexture)
  {
    *a2 = SCNMTLTextureToC3DTextureType(MTLTexture);
    uint64_t result = C3DEffectSlotIsOpaque(a1);
    *a3 = result ^ 1;
    *a4 = 0;
    return result;
  }
  uint64_t ImageProxy = C3DEffectSlotGetImageProxy(a1);
  if (ImageProxy)
  {
    uint64_t v11 = ImageProxy;
    *a2 = C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(1u);
    *a3 = C3DImageProxyIsOpaque(v11) ^ 1;
    uint64_t result = C3DImageProxyIsPremultiplied(v11);
    *a4 = result;
    return result;
  }
  uint64_t result = C3DEffectSlotGetImage(a1);
  if (result)
  {
    uint64_t v12 = result;
    uint64_t result = C3DImageIsValid(result);
    if (result)
    {
      CFBooleanRef Attribute = C3DImageGetAttribute(v12, @"isAttachment");
      if (Attribute)
      {
        uint64_t result = CFBooleanGetValue(Attribute);
        if (result)
        {
          *a2 = 2;
          *a3 = 1;
          return result;
        }
      }
      char TextureOptions = C3DEffectSlotGetTextureOptions(a1);
      if (C3DMetalIsUsed() && (TextureOptions & 2) != 0 && C3DImageIsConvertibleToCubeMap(v12))
      {
        int v15 = 4;
      }
      else
      {
        unsigned int ImageType = C3DImageGetImageType(v12);
        if (ImageType > 7)
        {
LABEL_20:
          uint64_t result = C3DImageHasAlpha(v12);
          *a3 = result;
          if (result)
          {
            uint64_t result = C3DImageNeedsUnpremultiply(v12);
            char v17 = result ^ 1;
          }
          else
          {
            char v17 = 0;
          }
          *a4 = v17;
          return result;
        }
        int v15 = dword_20B5EDA14[ImageType];
      }
      *a2 = v15;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t C3DEffectSlotGetTextureOptions(uint64_t a1)
{
  int v1 = *(char *)(a1 + 50);
  unsigned int v2 = v1 - 24;
  if (v1 == 4) {
    int v3 = 2;
  }
  else {
    int v3 = 0;
  }
  if (v1 == 26) {
    int v4 = 8;
  }
  else {
    int v4 = v3;
  }
  if (v2 < 2) {
    int v4 = 6;
  }
  return v4 | ((*(_WORD *)(a1 + 48) & 0x400) == 0);
}

uint64_t C3DImageGetImageType(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 120);
}

uint64_t C3DImageHasAlpha(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DImageIsCubeMap(a1)) {
    return 0;
  }
  char v11 = *(unsigned char *)(a1 + 116);
  if (*(_DWORD *)(a1 + 96) != 5 && (*(unsigned char *)(a1 + 116) & 4) == 0)
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    if ((*(unsigned char *)(a1 + 80) & 2) != 0 || C3DImageGetTextureRawData(a1))
    {
      if ((*(unsigned char *)(a1 + 116) & 4) == 0) {
        *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFE | *(unsigned char *)(*(void *)(a1 + 72) + 6) & 1 | 4;
      }
    }
    else
    {
      pthread_mutex_unlock(&bitmapAccessSharedMutex);
      pthread_mutex_lock(&bitmapAccessSharedMutex);
      CFTypeRef v12 = C3DImageCopyBitmap(a1, 1);
      if (v12) {
        CFRelease(v12);
      }
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
    char v11 = *(unsigned char *)(a1 + 116);
  }
  return v11 & 1;
}

BOOL C3DImageIsCubeMap(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(_DWORD *)(a1 + 120) - 3) < 5;
}

uint64_t C3DMetalIsUsed()
{
  return gMetalIsUsed;
}

CFDictionaryRef C3DImageGetAttribute(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntityGetAttribute(a1, key);
}

uint64_t C3DPBROpacityIsEnabled()
{
  if (C3DPBROpacityIsEnabled_onceToken != -1) {
    dispatch_once(&C3DPBROpacityIsEnabled_onceToken, &__block_literal_global_265);
  }
  return C3DPBROpacityIsEnabled_usePBROpacity;
}

void _C3DRendererElementSync(uint64_t a1, char a2)
{
  if ((a2 & 4) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if ((*(_WORD *)(a1 + 72) & 7) == 5)
    {
      unsigned int RenderingOrder = 0x80000000;
    }
    else if (v4)
    {
      unsigned int RenderingOrder = C3DNodeGetRenderingOrder(*(void *)(a1 + 8));
    }
    else
    {
      unsigned int RenderingOrder = 0;
    }
    *(_DWORD *)(a1 + 64) = RenderingOrder;
    if (v4)
    {
      if (C3DNodeGetCastsShadow(v4)) {
        __int16 v6 = 16;
      }
      else {
        __int16 v6 = 0;
      }
    }
    else
    {
      __int16 v6 = 0;
    }
    *(_WORD *)(a1 + 72) = *(_WORD *)(a1 + 72) & 0xFFEF | v6;
  }
  if ((a2 & 8) != 0)
  {
    if (!a1)
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        _C3DRendererElementSync_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      }
    }
    uint64_t Material = C3DRendererElementGetMaterial(a1);
    if (Material)
    {
      CFArrayRef ShaderModifiers = C3DEntityGetShaderModifiers(Material);
      __int16 ModifierFlags = _GetModifierFlags(ShaderModifiers);
    }
    else
    {
      __int16 ModifierFlags = 0;
    }
    uint64_t Geometry = C3DRendererElementGetGeometry(a1);
    if (!Geometry
      || (uint64_t v19 = Geometry,
          CFArrayRef v20 = C3DEntityGetShaderModifiers(Geometry),
          ModifierFlags |= _GetModifierFlags(v20),
          C3DGeometryUsesDeformerBasedDynamicMesh(v19))
      || (uint64_t Mesh = C3DGeometryGetMesh(v19)) == 0
      || (C3DMeshHasNonOpaqueColorSources(Mesh) & 1) == 0)
    {
      if (ModifierFlags)
      {
        __int16 v23 = *(_WORD *)(a1 + 72);
        goto LABEL_35;
      }
      if ((ModifierFlags & 2) == 0)
      {
        uint64_t v22 = *(void *)(a1 + 8);
        if (!v22) {
          goto LABEL_29;
        }
        __int16 v23 = *(_WORD *)(a1 + 72);
        if ((v23 & 7) == 1) {
          goto LABEL_35;
        }
        C3DNodeGetWorldAlpha(v22);
        if (v24 >= 1.0)
        {
LABEL_29:
          uint64_t v25 = *(void *)(a1 + 40);
          if (v25)
          {
            int IsOpaque = C3DFXTechniqueIsOpaque(v25);
            goto LABEL_31;
          }
          __int16 v23 = *(_WORD *)(a1 + 72);
          if ((v23 & 7) != 1)
          {
            uint64_t v36 = *(void *)(a1 + 32);
            if (v36)
            {
              int IsOpaque = C3DMaterialIsOpaque(v36);
LABEL_31:
              __int16 v23 = *(_WORD *)(a1 + 72);
              if ((IsOpaque ^ ((v23 & 8) == 0))) {
                goto LABEL_40;
              }
              if (!IsOpaque)
              {
LABEL_38:
                __int16 v27 = 0;
                goto LABEL_39;
              }
LABEL_36:
              __int16 v27 = 8;
LABEL_39:
              *(_WORD *)(a1 + 72) = v23 & 0xFFF7 | v27;
              Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
              C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationRendererElementWillDie", (const void *)a1, 0, 1u);
              goto LABEL_40;
            }
          }
LABEL_35:
          if ((v23 & 8) != 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
      }
    }
    __int16 v23 = *(_WORD *)(a1 + 72);
    if ((v23 & 8) == 0) {
      goto LABEL_40;
    }
    goto LABEL_38;
  }
LABEL_40:
  if ((a2 & 0x10) == 0) {
    return;
  }
  uint64_t v29 = *(void *)(a1 + 32);
  if (!v29)
  {
    unsigned __int8 v33 = (_WORD *)(a1 + 72);
    __int16 v35 = -65;
    goto LABEL_51;
  }
  uint64_t CommonProfileIfNoTechnique = C3DMaterialGetCommonProfileIfNoTechnique(v29);
  uint64_t v31 = CommonProfileIfNoTechnique;
  if (CommonProfileIfNoTechnique
    && (C3DEffectCommonProfileGetLightingModel(CommonProfileIfNoTechnique) & 0xFFFFFFFB) != 0)
  {
    __int16 v32 = 64;
  }
  else
  {
    __int16 v32 = 0;
  }
  if (!v31) {
    __int16 v32 = 0;
  }
  __int16 v34 = *(_WORD *)(a1 + 72);
  unsigned __int8 v33 = (_WORD *)(a1 + 72);
  *unsigned __int8 v33 = v34 & 0xFFBF | v32;
  if (!C3DMaterialGetEnableWriteInDepthBuffer(*((void *)v33 - 5)))
  {
    __int16 v35 = -17;
LABEL_51:
    *v33 &= v35;
  }
}

CFDictionaryRef C3DEntityGetShaderModifiers(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetAttribute(a1, @"kShaderModifiers");
}

CFDictionaryRef C3DEntityGetAttribute(uint64_t a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DEntityGetAttribute_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 40);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

uint64_t C3DRendererElementGetMaterial(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

void C3DNodeGetWorldAlpha(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(_DWORD *)(a1 + 220);
  if ((v10 & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 256) = *(_DWORD *)(a1 + 204);
    if (*(void *)(a1 + 64))
    {
      *(float *)(a1 + 256) = C3DNodeGetWorldAlpha() * *(float *)(a1 + 256);
      int v10 = *(_DWORD *)(a1 + 220);
    }
    *(_DWORD *)(a1 + 220) = v10 & 0xFFFFFFDF;
  }
}

uint64_t C3DRendererElementGetGeometry(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(_WORD *)(a1 + 72) & 5 | 2) == 3) {
    return 0;
  }
  else {
    return *(void *)(a1 + 16);
  }
}

BOOL C3DGeometryUsesDeformerBasedDynamicMesh(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t _GetModifierFlags(const __CFArray *a1)
{
  if (a1 && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
  {
    CFIndex v3 = Count;
    CFIndex v4 = 0;
    int v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v4);
      v5 |= C3DShaderModifierGetFlags((uint64_t)ValueAtIndex);
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    LOWORD(v5) = 0;
  }
  return (__int16)v5;
}

uint64_t C3DMeshHasNonOpaqueColorSources(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200) >> 7;
}

BOOL C3DMaterialGetEnableWriteInDepthBuffer(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 88) != 0;
}

uint64_t C3DMaterialGetCommonProfileIfNoTechnique(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(void *)(a1 + 72)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 64);
  }
}

uint64_t C3DEffectCommonProfileIsOpaque(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 194);
  if ((v10 & 0x80) == 0)
  {
    int v11 = *(unsigned __int8 *)(a1 + 180);
    *(_WORD *)(a1 + 194) = v10 | 0x80;
    if (*(float *)(a1 + 164) >= 1.0
      && __imageSlotIsOpaque(a1, 5)
      && __imageSlotIsOpaque(a1, 2))
    {
      Color = (float *)C3DEffectCommonProfileGetColor(a1, 5);
      int v13 = *(unsigned __int8 *)(a1 + 180);
      if ((v13 - 2) < 2)
      {
LABEL_11:
        int v14 = Color[3] >= 1.0;
LABEL_21:
        if (v14) {
          BOOL v18 = v11 == 1;
        }
        else {
          BOOL v18 = 1;
        }
        if (!v18)
        {
          uint64_t v19 = (float *)C3DEffectCommonProfileGetColor(a1, 2);
          int v15 = *(unsigned __int16 *)(a1 + 194);
          if (v19[3] < 1.0)
          {
            int v14 = 0;
            goto LABEL_15;
          }
LABEL_30:
          int v14 = 256;
          goto LABEL_15;
        }
        int v15 = *(unsigned __int16 *)(a1 + 194);
        if (v14) {
          goto LABEL_30;
        }
LABEL_15:
        unsigned int v10 = v15 & 0xFFFFFEFF | v14;
        *(_WORD *)(a1 + 194) = v10;
        return (v10 >> 8) & 1;
      }
      if (v13 != 1)
      {
        if (*(unsigned char *)(a1 + 180))
        {
          uint64_t v17 = scn_default_log();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            v20[0] = 67109120;
            v20[1] = v13;
            _os_log_impl(&dword_20B249000, v17, OS_LOG_TYPE_DEFAULT, "Warning: __OpacityFromColorSlot:unexpected transparency mode %d", (uint8_t *)v20, 8u);
          }
          int v14 = 1;
          goto LABEL_21;
        }
        goto LABEL_11;
      }
      if (*Color <= 0.0 && Color[1] <= 0.0)
      {
        int v14 = Color[2] <= 0.0;
        goto LABEL_21;
      }
    }
    int v14 = 0;
    int v15 = *(unsigned __int16 *)(a1 + 194);
    goto LABEL_15;
  }
  return (v10 >> 8) & 1;
}

uint64_t __imageSlotIsOpaque(uint64_t a1, int a2)
{
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  uint64_t v5 = EffectSlot;
  if (a2 == 5)
  {
    if (*(unsigned char *)(a1 + 180) == 1)
    {
      if (!C3DEffectCommonProfileGetImageProxy(a1, 5) && !C3DEffectCommonProfileGetImage(a1, 5)) {
        goto LABEL_5;
      }
    }
    else
    {
      if (!EffectSlot) {
        return 1;
      }
      if ((*(_WORD *)(EffectSlot + 48) & 0x800) != 0) {
        goto LABEL_6;
      }
    }
    return 0;
  }
LABEL_5:
  if (!v5) {
    return 1;
  }
LABEL_6:

  return C3DEffectSlotIsOpaque(v5);
}

uint64_t C3DEffectSlotIsOpaque(uint64_t a1)
{
  uint64_t ImageProxy = C3DEffectSlotGetImageProxy(a1);
  if (!ImageProxy)
  {
    uint64_t Image = C3DEffectSlotGetImage(a1);
    if (Image)
    {
      HasAlphSCNMatrix4 a = C3DImageHasAlpha(Image);
    }
    else
    {
      uint64_t Texture = C3DEffectSlotGetTexture(a1);
      if (!Texture)
      {
        if (C3DEffectSlotGetMTLTexture(a1)) {
          return HIBYTE(*(unsigned __int16 *)(a1 + 48)) & 1;
        }
        else {
          return 1;
        }
      }
      HasAlphSCNMatrix4 a = C3DTextureHasAlpha(Texture);
    }
    return HasAlpha ^ 1u;
  }

  return C3DImageProxyIsOpaque(ImageProxy);
}

CFDictionaryRef C3DNodeGetRenderingOrder(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRef result = C3DEntityGetAttribute(a1, @"kRenderingPriorityKey");
  if (result)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(result, kCFNumberLongType, &valuePtr);
    return (const __CFDictionary *)valuePtr;
  }
  return result;
}

float C3DNodeGetOpacity(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 204);
}

uint64_t __C3DCullingSystem::_updateNodeMasksAtIndex(uint64_t this, unsigned int a2)
{
  if (*(_DWORD *)(this + 16) > a2)
  {
    unsigned int v2 = (void *)this;
    uint64_t v3 = *(void *)(this + 104);
    uint64_t v4 = *(void *)(v3 + 8 * a2);
    if (v4)
    {
      uint64_t v5 = a2;
      uint64_t CategoryBitMask = C3DNodeGetCategoryBitMask(*(void *)(v3 + 8 * a2));
      uint64_t v7 = v2[10];
      *(_DWORD *)(v2[9] + 4 * v5) = CategoryBitMask;
      *(_DWORD *)(v7 + 4 * v5) = HIDWORD(CategoryBitMask);
      C3DNodeIsHiddenOrTransparentOrIsHiddenOrTransparentByAncestor(v4);
      __int16 v9 = v8;
      if (C3DNodeGetMovability(v4)) {
        __int16 v10 = 4;
      }
      else {
        __int16 v10 = 2;
      }
      __int16 v11 = v10 | v9;
      if (C3DNodeGetCastsShadow(v4)) {
        v11 |= 8u;
      }
      if (C3DNodeIsLighted(v4)) {
        v11 |= 0x20u;
      }
      if ((C3DNodeIsAlwaysRendered(v4) & 1) != 0 || (*(unsigned char *)(v4 + 221) & 0x20) != 0) {
        v11 |= 0x10u;
      }
      this = C3DNodeGetLayerIndex(v4);
      *(_WORD *)(v2[11] + 2 * v5) = (256 << this) | v11;
    }
  }
  return this;
}

uint64_t C3DNodeGetCategoryBitMask(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 208);
}

uint64_t C3DNodeGetCastsShadow(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 222) >> 5) & 1;
}

uint64_t C3DNodeGetMovability(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(_DWORD *)(a1 + 220) >> 22) & 1;
}

uint64_t C3DNodeGetLayerIndex(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 220) >> 23) & 7;
}

uint64_t C3DNodeIsLighted(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 240);
  if (result)
  {
    uint64_t result = (uint64_t)C3DGeometryGetMaterialAtIndex(result, 0);
    if (result)
    {
      uint64_t result = C3DMaterialGetCommonProfile(result);
      if (result) {
        return (C3DEffectCommonProfileGetLightingModel(result) & 0xFFFFFFFB) != 0;
      }
    }
  }
  return result;
}

uint64_t C3DEffectCommonProfileGetLightingModel(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 24);
}

float C3DNodeIsHiddenOrTransparentOrIsHiddenOrTransparentByAncestor(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!C3DNodeIsHiddenOrTransparent(a1))
  {
    do
    {
      uint64_t v1 = *(void *)(v1 + 64);
      if (!v1) {
        break;
      }
      if (*(unsigned char *)(v1 + 200)) {
        break;
      }
      float result = *(float *)(v1 + 204);
    }
    while (result > 0.0);
  }
  return result;
}

BOOL C3DNodeIsHiddenOrTransparent(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 200) || *(float *)(a1 + 204) <= 0.0;
}

uint64_t C3DNodeIsAlwaysRendered(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 220);
  if ((v1 & 2) != 0)
  {
    if ((v1 & 4) != 0)
    {
      int v5 = 0;
    }
    else
    {
      CFDictionaryRef RendererDelegate = C3DNodeGetRendererDelegate(a1);
      uint64_t v4 = *(void *)(a1 + 240);
      if (v4) {
        LODWORD(v4) = C3DGeometryIsAlwaysRendered(v4);
      }
      if (RendererDelegate) {
        int v5 = 1;
      }
      else {
        int v5 = v4;
      }
      unsigned int v1 = *(_DWORD *)(a1 + 220);
    }
    unsigned int v1 = v1 & 0xFFFFFFFC | v5;
    *(_DWORD *)(a1 + 220) = v1;
  }
  return v1 & 1;
}

uint64_t C3DTransformTreeAddNode(__C3DTransformTree *this, __C3DNode *a2, int a3)
{
  if (!this)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DTransformTreeAddNode_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  return __C3DTransformTree::add(this, a2, a3);
}

uint64_t __C3DTransformTree::add(__C3DTransformTree *this, __C3DNode *a2, int a3)
{
  if (a3 == -1)
  {
    int v6 = -1;
    int v7 = -1;
  }
  else
  {
    int v5 = (int *)(*((void *)this + 3) + 8 * a3);
    int v6 = *v5;
    int v7 = v5[1];
  }
  unsigned int v8 = v6;
  uint64_t v9 = v6 + 1;
  if ((int)v9 >= *((_DWORD *)this + 16)) {
    __C3DTransformTree::_setLevelCount(this, v6 + 2);
  }
  uint64_t v10 = *((void *)this + 7);
  uint64_t v11 = v10 + 80 * v9;
  int v13 = *(_DWORD *)(v11 + 72);
  int v12 = *(_DWORD *)(v11 + 76);
  int v14 = (int *)(v11 + 72);
  if (v13 == v12)
  {
    C3DTransformLevel::allocateData((C3DTransformLevel *)(v10 + 80 * v9), 2 * v13);
    int v13 = *v14;
  }
  uint64_t v15 = v10 + 80 * v9;
  BOOL v18 = *(char **)(v15 + 24);
  uint64_t v17 = (void *)(v15 + 24);
  uint64_t v16 = v18;
  uint64_t v19 = v13;
  if (!v13) {
    goto LABEL_16;
  }
  unint64_t v20 = v13;
  uint64_t v21 = v16;
  uint64_t v22 = &v16[4 * v13];
  do
  {
    unint64_t v23 = v20 >> 1;
    float v24 = (int *)&v21[4 * (v20 >> 1)];
    int v26 = *v24;
    uint64_t v25 = (char *)(v24 + 1);
    v20 += ~(v20 >> 1);
    if (v7 < v26) {
      unint64_t v20 = v23;
    }
    else {
      uint64_t v21 = v25;
    }
  }
  while (v20);
  if (v21 == v22)
  {
LABEL_16:
    unint64_t v27 = 4 * v19;
  }
  else
  {
    unint64_t v27 = v21 - v16;
    __C3DTransformTree::_offset((uint64_t)this, v9 | ((unint64_t)((unint64_t)(v21 - v16) >> 2) << 32), v8 | ((unint64_t)v7 << 32), 1);
  }
  if ((v27 >> 2) == -1)
  {
    uint64_t v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      __C3DTransformTree::add(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }
  ++*v14;
  uint64_t v36 = (void *)(v10 + 80 * v9);
  *(void *)(v36[5] + ((uint64_t)(v27 << 30) >> 29)) = a2;
  uint64_t v37 = (uint64_t)(v27 << 30) >> 30;
  *(_DWORD *)(v36[7] + v37) = *((_DWORD *)a2 + 54);
  *(_DWORD *)(*v17 + v37) = v7;
  *(_DWORD *)(v36[4] + v37) = -1;
  C3DNodeGetMatrix((uint64_t)a2, (uint64_t)v45);
  long long v38 = v45[1];
  long long v39 = v45[2];
  long long v40 = v45[3];
  uint64_t v41 = (_OWORD *)(v36[2] + ((uint64_t)(v27 << 30) >> 26));
  *uint64_t v41 = v45[0];
  v41[1] = v38;
  v41[2] = v39;
  v41[3] = v40;
  __C3DTransformTree::updateWorldTransformOnInsertion((uint64_t)this, v9 | (v27 << 30));
  uint64_t v42 = __C3DTransformTree::_newHandle((uint64_t)this, v9 | (v27 << 30));
  *(_DWORD *)(v36[6] + v37) = v42;
  if (v8 != -1)
  {
    uint64_t v43 = *(void *)(*((void *)this + 7) + 80 * (int)v8 + 32);
    if (*(_DWORD *)(v43 + 4 * v7) == -1) {
      *(_DWORD *)(v43 + 4 * v7) = v27 >> 2;
    }
  }
  __C3DTransformTree::_fixupParentAndSiblings((uint64_t)this, v9 | (v27 << 30), v8 | ((unint64_t)v7 << 32), -1);
  ++*((_DWORD *)this + 18);
  return v42;
}

__n128 __C3DTransformTree::updateWorldTransformOnInsertion(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = a2;
  uint64_t v4 = (void *)(v2 + 80 * (int)a2);
  uint64_t v5 = a2 >> 32;
  int v6 = a2 - 1;
  if (a2 == 0x100000000)
  {
    int v7 = (long long *)(*(void *)(v2 + 80 * (int)a2 + 16) + (v5 << 6));
    unsigned int v8 = (_OWORD *)(*v4 + (v5 << 6));
    long long v9 = *v7;
    long long v10 = v7[1];
    long long v11 = v7[3];
    v8[2] = v7[2];
    v8[3] = v11;
    _OWORD *v8 = v9;
    v8[1] = v10;
  }
  else
  {
    uint64_t v13 = v2 + 80 * (int)a2;
    uint64_t v14 = *(int *)(*(void *)(v13 + 24) + 4 * v5);
    __C3DTransformTree::updateWorldTransformOnInsertion();
    uint64_t v15 = 0;
    uint64_t v16 = (float32x4_t *)(*(void *)(*(void *)(a1 + 56) + 80 * v6) + (v14 << 6));
    uint64_t v17 = *v4 + (v5 << 6);
    uint64_t v18 = *(void *)(v13 + 16) + (v5 << 6);
    do
    {
      *(float32x4_t *)(v17 + v15) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v16[1], *(float32x2_t *)(v18 + v15), 1), *v16, COERCE_FLOAT(*(_OWORD *)(v18 + v15))), v16[2], *(float32x4_t *)(v18 + v15), 2), v16[3], *(float32x4_t *)(v18 + v15), 3);
      v15 += 16;
    }
    while (v15 != 64);
  }
  uint64_t v19 = *v4 + (v5 << 6);
  uint64_t v20 = *(void *)(v2 + 80 * v3 + 8) + (v5 << 6);
  __n128 result = *(__n128 *)v19;
  long long v22 = *(_OWORD *)(v19 + 16);
  long long v23 = *(_OWORD *)(v19 + 48);
  *(_OWORD *)(v20 + 32) = *(_OWORD *)(v19 + 32);
  *(_OWORD *)(v20 + 48) = v23;
  *(__n128 *)uint64_t v20 = result;
  *(_OWORD *)(v20 + 16) = v22;
  return result;
}

double C3DNodeGetMatrix@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)&double result = C3DTransformGetMatrix(a1 + 96, a2).n128_u64[0];
  uint64_t v13 = *(void *)(a1 + 192);
  if (v13)
  {
    if (*(float *)(v13 + 124) == 0.0)
    {
      C3DMatrix4x4Invert((simd_float4x4 *)v13, (simd_float4x4 *)(v13 + 64));
      uint64_t v13 = *(void *)(a1 + 192);
    }
    return C3DMatrix4x4Mult(v13 + 64, (float32x4_t *)a2, (_OWORD *)a2);
  }
  return result;
}

__n128 C3DTransformGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if ((*(unsigned char *)(a1 + 92) & 8) == 0) {
    _updateMatrix((float32x4_t *)a1);
  }
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  __n128 result = *(__n128 *)(a1 + 32);
  long long v6 = *(_OWORD *)(a1 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v6;
  return result;
}

void __C3DTransformTree::_fixupParentAndSiblings(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v6 = HIDWORD(a2);
  if (a3 + 1 != a2)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      __C3DTransformTree::_fixupParentAndSiblings(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a3 != -1)
  {
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      uint64_t v17 = *(void *)(v16 + 80 * (int)a3 + 32);
      if (*(_DWORD *)(v17 + 4 * (a3 >> 32)) == a4) {
        *(_DWORD *)(v17 + 4 * (a3 >> 32)) = v6;
      }
    }
  }
}

uint64_t __C3DTransformTree::_newHandle(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(unsigned int *)(a1 + 48);
  if (result == -1)
  {
    unint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void **)(a1 + 32);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = *(void *)(a1 + 24);
      uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v6 - v9;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(a1 + 40, v13);
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      uint64_t v16 = &v14[8 * v13];
      *(void *)uint64_t v15 = a2;
      uint64_t v8 = v15 + 8;
      uint64_t v18 = *(char **)(a1 + 24);
      uint64_t v17 = *(char **)(a1 + 32);
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        uint64_t v17 = *(char **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v15;
      *(void *)(a1 + 32) = v8;
      *(void *)(a1 + 40) = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      void *v7 = a2;
      uint64_t v8 = v7 + 1;
    }
    *(void *)(a1 + 32) = v8;
    return (((unint64_t)v8 - *(void *)(a1 + 24)) >> 3) - 1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 24) + 8 * (int)result;
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v5 + 4);
    *(void *)uint64_t v5 = a2;
  }
  return result;
}

uint64_t C3DNodeIsJoint(uint64_t a1)
{
  return *(unsigned char *)(a1 + 221) & 1;
}

BOOL C3DNodeGetHasPivot(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 192) != 0;
}

uint64_t C3DEnginePipelineAddNodeToRendering(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)a3);
  if ((result & 1) == 0 && !a3[57])
  {
    uint64_t result = C3DNodeGetRenderableAttributeHash((uint64_t)a3);
    if (result)
    {
      _C3DEnginePipelineAllocateAndTrackRendererElements(a1, a2, (uint64_t)a3, result);
      return __TrackRenderNodeDependencies(a1, a3);
    }
  }
  return result;
}

uint64_t C3DNodeIsHiddenOrIsHiddenByAncestor(uint64_t a1)
{
  uint64_t v1 = a1;
  if (C3DNodeIsHidden(a1)) {
    return 1;
  }
  do
  {
    uint64_t v1 = *(void *)(v1 + 64);
    BOOL v2 = v1 != 0;
  }
  while (v1 && !C3DNodeIsHidden(v1));
  return v2;
}

uint64_t C3DNodeIsHidden(uint64_t a1)
{
  if (!a1)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 200);
}

uint64_t C3DNodeGetRenderableAttributeHash(uint64_t a1)
{
  if (C3DNodeGetRendererDelegate(a1))
  {
    unsigned int v2 = 2;
  }
  else if (C3DNodeGetFilters(a1))
  {
    unsigned int v2 = 8;
  }
  else
  {
    unsigned int v2 = C3DNodeGetGeometry(a1) != 0;
  }
  CFDictionaryRef Light = C3DNodeGetLight(a1);
  if (Light && C3DLightGetType((uint64_t)Light) == 6) {
    v2 |= 0x10u;
  }
  if (C3DNodeGetUsesDepthPrePass(a1)) {
    return v2 | 0x20;
  }
  else {
    return v2;
  }
}

CFDictionaryRef C3DNodeGetRendererDelegate(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 0x20) != 0) {
    return C3DEntityGetAttribute(a1, @"rendererDelegate");
  }
  else {
    return 0;
  }
}

const void *_C3DNodeGetMeshToRender(uint64_t a1, __C3DGeometry *a2)
{
  if ((__C3DGeometry *)C3DNodeGetGeometry(a1) == a2)
  {
    return C3DNodeGetPresentationMesh(a1);
  }
  else
  {
    return C3DGeometryGetRenderingMesh(a2);
  }
}

uint64_t C3DNodeGetGeometry(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 240);
}

uint64_t C3DNodeGetUsesDepthPrePass(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 223) >> 2) & 1;
}

CFDictionaryRef C3DNodeGetFilters(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 0x40) == 0) {
    return 0;
  }
  CFDictionaryRef result = C3DEntityGetAttribute(a1, @"kFilterKey");
  if (result) {
    return (const __CFDictionary *)C3DModelTargetGetTarget((uint64_t)result);
  }
  return result;
}

uint64_t C3DEntityGetName(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

uint64_t C3DMaterialIsOpaque(uint64_t a1)
{
  uint64_t Technique = C3DMaterialGetTechnique(a1);
  if (Technique)
  {
    return C3DFXTechniqueIsOpaque(Technique);
  }
  else if (*(unsigned char *)(a1 + 92) == 5)
  {
    return 1;
  }
  else if (*(unsigned char *)(a1 + 92))
  {
    return 0;
  }
  else
  {
    uint64_t CommonProfile = C3DMaterialGetCommonProfile(a1);
    return C3DEffectCommonProfileIsOpaque(CommonProfile);
  }
}

float C3DSceneGetFogEndDistance(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 332);
}

CFDictionaryRef C3DNodeGetLightmapInfo(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 8) != 0) {
    return C3DEntityGetAttribute(a1, @"kLightmapInfoKey");
  }
  else {
    return 0;
  }
}

uint64_t C3DMaterialGetBlendStatesUseConstantAlpha(uint64_t a1, char a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 92);
  uint64_t result = *(unsigned char *)(a1 + 92) == 0;
  if (!v3 && (a2 & 1) == 0)
  {
    int v5 = 1065353216;
    return C3DEffectCommonProfileHasConstantAlpha(*(float **)(a1 + 64), (float *)&v5);
  }
  return result;
}

uint64_t C3DGeometryIsDynamicBatchingEnabled(uint64_t a1)
{
  return *(unsigned char *)(a1 + 112) & 1;
}

BOOL C3DMeshContainsSourcesWithSemantic(uint64_t a1, int a2)
{
  return *(unsigned char *)(a1 + 2 * a2 + 73) != 0;
}

uint64_t C3DMaterialGetFillMode(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 91);
}

BOOL C3DMaterialGetEnableReadsFromDepthBuffer(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 89) != 0;
}

uint64_t C3DMaterialGetCullMode(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 90);
}

uint64_t C3DMaterialGetBlendMode(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 92);
}

uint64_t C3DEffectCommonProfileIsPerPixelLit(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 192);
}

uint64_t C3DEffectCommonProfileGetEnableLockAmbientWithDiffuse(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 193);
}

uint64_t C3DEffectCommonProfileGetAvoidsOverLighting(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_WORD *)(a1 + 194) & 1;
}

uint64_t C3DEffectCommonProfileGetEnableNormals(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 194) >> 2) & 1;
}

uint64_t C3DMeshGetSourcesCountForSemantic(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(a1 + 2 * a2 + 73);
}

uint64_t C3DEffectCommonProfileHasConstantAlpha(float *a1, float *a2)
{
  if (C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 5)) {
    return 0;
  }
  int v5 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 2);
  char v6 = v5;
  if (!v5 || (uint64_t result = __imageSlotIsOpaque((uint64_t)a1, 2), result))
  {
    float FloatProperty = C3DEffectCommonProfileGetFloatProperty(a1, 18);
    float v8 = FloatProperty * *((float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 5) + 3);
    Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 2);
    if ((v6 & 1) == 0) {
      float v8 = v8 * Color[3];
    }
    *a2 = v8;
    return 1;
  }
  return result;
}

float32x4_t _updateMatrix(float32x4_t *a1)
{
  if ((a1[5].i8[12] & 4) == 0)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _updateMatrix_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((a1[5].i8[12] & 8) != 0)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _updateMatrix_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  uint64_t v18 = (float32x4_t *)MEMORY[0x263EF89A8];
  if ((a1[5].i32[3] & 3) == 2)
  {
    float32x4_t v20 = a1[4];
    float32x4_t v21 = vmulq_f32(v20, v20);
    float v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
    if (v22 <= 0.000000001)
    {
      float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
    }
    else
    {
      float v42 = v22;
      float32x4_t v43 = a1[4];
      __float2 v23 = __sincosf_stret(vmuls_lane_f32(0.5, v20, 3));
      float32x2_t v24 = vrsqrte_f32((float32x2_t)LODWORD(v42));
      float32x2_t v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)LODWORD(v42), vmul_f32(v24, v24)));
      float32x4_t v19 = vmulq_n_f32(vmulq_n_f32(v43, vmul_f32(v25, vrsqrts_f32((float32x2_t)LODWORD(v42), vmul_f32(v25, v25))).f32[0]), v23.__sinval);
      v19.i32[3] = LODWORD(v23.__cosval);
    }
  }
  else if ((a1[5].i32[3] & 3) != 0)
  {
    float v26 = a1[4].f32[1];
    float v27 = a1[4].f32[2];
    __float2 v28 = __sincosf_stret(a1[4].f32[0] * 0.5);
    __float2 v29 = __sincosf_stret(v26 * 0.5);
    __float2 v30 = __sincosf_stret(v27 * 0.5);
    v19.f32[0] = (float)(v28.__sinval * (float)(v29.__cosval * v30.__cosval))
               - (float)(v28.__cosval * (float)(v29.__sinval * v30.__sinval));
    v19.f32[1] = (float)(v30.__sinval * (float)(v28.__sinval * v29.__cosval))
               + (float)((float)(v28.__cosval * v29.__sinval) * v30.__cosval);
    v19.f32[2] = (float)(v30.__cosval * (float)-(float)(v28.__sinval * v29.__sinval))
               + (float)((float)(v28.__cosval * v29.__cosval) * v30.__sinval);
    v19.f32[3] = (float)(v28.__sinval * (float)(v29.__sinval * v30.__sinval))
               + (float)(v28.__cosval * (float)(v29.__cosval * v30.__cosval));
  }
  else
  {
    float32x4_t v19 = a1[4];
  }
  float32x4_t result = a1[5];
  float32x4_t v32 = *v18;
  float32x4_t v33 = v18[1];
  float32x4_t v34 = vmulq_f32(v19, v19);
  float32x4_t v35 = vaddq_f32(v34, v34);
  float32x4_t v36 = vmulq_laneq_f32(v19, v19, 3);
  float v37 = vmulq_lane_f32(v19, *(float32x2_t *)v19.f32, 1).f32[0];
  v32.f32[0] = (float)(1.0 - v35.f32[1]) - v35.f32[2];
  v32.f32[1] = (float)(v37 + v36.f32[2]) + (float)(v37 + v36.f32[2]);
  v33.f32[0] = (float)(v37 - v36.f32[2]) + (float)(v37 - v36.f32[2]);
  v35.f32[0] = 1.0 - v35.f32[0];
  v33.f32[1] = v35.f32[0] - v35.f32[2];
  float32x2_t v38 = vmul_laneq_f32(*(float32x2_t *)v19.f32, v19, 2);
  v32.f32[2] = (float)(v38.f32[0] - v36.f32[1]) + (float)(v38.f32[0] - v36.f32[1]);
  v33.f32[2] = (float)(v38.f32[1] + v36.f32[0]) + (float)(v38.f32[1] + v36.f32[0]);
  *(int32x2_t *)v36.f32 = vrev64_s32(*(int32x2_t *)v36.f32);
  v39.i32[0] = vadd_f32(v38, *(float32x2_t *)v36.f32).u32[0];
  v39.i32[1] = vsub_f32(v38, *(float32x2_t *)&v36).i32[1];
  *(float32x2_t *)v40.f32 = vadd_f32(v39, v39);
  v40.i32[3] = HIDWORD(v18[2].i64[1]);
  v40.f32[2] = v35.f32[0] - v35.f32[1];
  float32x4_t v41 = vaddq_f32(a1[3], v18[3]);
  v41.i32[3] = HIDWORD(*(_OWORD *)&v18[3]);
  *a1 = vmulq_n_f32(v32, result.f32[0]);
  a1[1] = vmulq_lane_f32(v33, *(float32x2_t *)result.f32, 1);
  a1[2] = vmulq_laneq_f32(v40, result, 2);
  a1[3] = v41;
  a1[5].i32[3] = result.i32[3] | 8;
  return result;
}

uint64_t C3DShaderModifierGetMappingChannelyMaskForTexcoordsUse(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int16 *)(a1 + 96);
}

uint64_t C3DShaderModifierGetEffectPropertyMaskForTexcoordsUse(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int16 *)(a1 + 94);
}

CFDictionaryRef C3DEntityGetShadableMinimumMTLLanguageVersion(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetAttribute(a1, @"kShadableMinimumMTLLanguageVersionKey");
}

void __removeMatchingProgram(const void *value, void *a2, void *a3)
{
  if (!*a3 || a2[2] == *a3)
  {
    uint64_t v5 = a3[1];
    if (!v5 || a2[3] == v5)
    {
      Mutable = (__CFArray *)a3[2];
      if (!Mutable)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
        a3[2] = Mutable;
      }
      CFArrayAppendValue(Mutable, value);
    }
  }
}

void _C3DModelTargetCFFinalize(uint64_t a1)
{
  unsigned int v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

void C3DArraySetCapacity(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 28);
  if (v3 != a2)
  {
    __allocate(a1, *(_DWORD *)(a1 + 32) * v3, (*(_DWORD *)(a1 + 32) * a2));
    *(_DWORD *)(a1 + 28) = a2;
  }
}

uint64_t C3DEngineContextCreateWithOptions()
{
  if (C3DEngineContextGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEngineContextGetTypeID_onceToken, &__block_literal_global_31);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DEngineContextGetTypeID_typeID, 0x740uLL);
  uint64_t v1 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[17] = 0;
    Instance[53] = 0x7FF0000000000000;
    Instance[205] = C3DRendererElementStateCreate();
    *((_WORD *)v1 + 106) = 1;
    *((_DWORD *)v1 + 51) = 1065353216;
    C3DRenderGraphCreate();
  }
  return 0;
}

void sub_20B259020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,void *a34,uint64_t a35,char a36,void *a37)
{
}

void std::__tree<char>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<char>::destroy(a1, *a2);
    std::__tree<char>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void sub_20B259778(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B25991C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B259A2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DNodeCreate()
{
  if (C3DNodeGetTypeID_onceToken != -1) {
    dispatch_once(&C3DNodeGetTypeID_onceToken, &__block_literal_global_62);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DNodeGetTypeID_typeID, 0x120uLL);
  C3DTransformInit(Instance + 96);
  *(_DWORD *)(Instance + 204) = 1065353216;
  *(unsigned char *)(Instance + 200) = 0;
  unsigned int v1 = *(_DWORD *)(Instance + 220) & 0xFFDFFFD1 | 0x20002A;
  *(void *)(Instance + 208) = 1;
  *(_DWORD *)(Instance + 216) = -1;
  *(_DWORD *)(Instance + 220) = v1;
  *(_DWORD *)(Instance + 88) = -1;
  *(_OWORD *)(Instance + 272) = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  *(_OWORD *)(Instance + 288) = xmmword_20B5CB570;
  return Instance;
}

__n128 C3DMatrix4x4MakeIdentity(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *(_OWORD *)a1 = *MEMORY[0x263EF89A8];
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(v1 + 32);
  long long v4 = *(_OWORD *)(v1 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

double C3DTransformInit(uint64_t a1)
{
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFF3 | 8;
  *(void *)&double result = C3DMatrix4x4MakeIdentity(a1).n128_u64[0];
  return result;
}

uint64_t *anonymous namespace'::build_crease_map(void *a1, uint64_t **a2, uint64_t **a3)
{
  double result = (uint64_t *)[a1 topology];
  if (result)
  {
    if (objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreases"))
    {
      if (objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseIndices"))
      {
        uint64_t v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseIndices"), "map"), "bytes");
        uint64_t v8 = (int *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreases"), "map"), "bytes");
        int v9 = objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseCount");
        if (v9 >= 1)
        {
          uint64_t v10 = v9;
          uint64_t v11 = (unsigned int *)(v7 + 4);
          do
          {
            unint64_t v17 = *v11 | ((unint64_t)*(v11 - 1) << 32);
            int v12 = *v8++;
            uint64_t v18 = &v17;
            *((_DWORD *)std::__tree<std::__value_type<unsigned long long,float>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,float>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,float>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, &v17, (uint64_t)&std::piecewise_construct, &v18)+ 10) = v12;
            v11 += 2;
            --v10;
          }
          while (v10);
        }
      }
    }
    double result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreases");
    if (result)
    {
      double result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseIndices");
      if (result)
      {
        uint64_t v13 = (unint64_t *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseIndices"), "map"), "bytes");
        uint64_t v14 = (int *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreases"), "map"), "bytes");
        double result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseCount");
        if ((int)result >= 1)
        {
          uint64_t v15 = result;
          do
          {
            int v16 = *v14++;
            uint64_t v18 = v13;
            double result = std::__tree<std::__value_type<unsigned int,float>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,float>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a3, (unsigned int *)v13, (uint64_t)&std::piecewise_construct, (unsigned int **)&v18);
            *((_DWORD *)result + 8) = v16;
            uint64_t v13 = (unint64_t *)((char *)v13 + 4);
            --v15;
          }
          while (v15);
        }
      }
    }
  }
  return result;
}

SCNGeometryElement *anonymous namespace'::add_creases(SCNGeometryElement *result, void *a2, SCNGeometryElement **a3)
{
  elementDatSCNMatrix4 a = result->_elementData;
  if (elementData)
  {
    uint64_t v6 = result;
    uint64_t v7 = 4 * (void)elementData;
    uint64_t v8 = (void *)[MEMORY[0x263EFF990] dataWithLength:4 * (void)elementData];
    [v8 setLength:v7];
    uint64_t v9 = [v8 mutableBytes];
    uint64_t v10 = 8 * (uint64_t)v6->_elementData;
    uint64_t v11 = (void *)[MEMORY[0x263EFF990] dataWithLength:v10];
    [v11 setLength:v10];
    uint64_t v12 = [v11 mutableBytes];
    isSCNMatrix4 a = (__C3DMeshElement *)v6->super.isa;
    if ((__C3DMeshElement **)v6->super.isa != &v6->_meshElement)
    {
      unsigned int v14 = 0;
      do
      {
        var3 = isa->var0.var3;
        *(_DWORD *)(v12 + 8 * v14) = HIDWORD(var3);
        *(_DWORD *)(v12 + 4 * ((2 * v14) | 1)) = var3;
        *(_DWORD *)(v9 + 4 * v14) = isa->var0.var4;
        var1 = (__C3DMeshElement *)isa->var0.var0.var1;
        if (var1)
        {
          do
          {
            unint64_t v17 = (__C3DMeshElement **)var1;
            var1 = (__C3DMeshElement *)var1->var0.var0.var0;
          }
          while (var1);
        }
        else
        {
          do
          {
            unint64_t v17 = (__C3DMeshElement **)isa->var0.var1;
            BOOL v18 = *v17 == isa;
            isSCNMatrix4 a = (__C3DMeshElement *)v17;
          }
          while (!v18);
        }
        ++v14;
        isSCNMatrix4 a = (__C3DMeshElement *)v17;
      }
      while (v17 != &v6->_meshElement);
    }
    *a2 = +[SCNGeometrySource geometrySourceWithData:v8 semantic:@"kGeometrySourceSemanticEdgeCrease" vectorCount:v6->_elementData floatComponents:1 componentsPerVector:1 bytesPerComponent:4 dataOffset:0 dataStride:4];
    double result = +[SCNGeometryElement geometryElementWithData:v11 primitiveType:2 primitiveCount:v6->_elementData bytesPerIndex:4];
    *a3 = result;
  }
  return result;
}

SCNGeometrySource *anonymous namespace'::add_corners(SCNGeometrySource *result, void *a2, void *a3)
{
  if (a2[2])
  {
    uint64_t v5 = result;
    uint64_t v6 = (void *)[a3 vertexDescriptor];
    uint64_t v7 = (void *)[v6 attributeNamed:*MEMORY[0x263F135C8]];
    if (!v7)
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
    }
      }
    unint64_t v9 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "vertexBuffers"), "objectAtIndexedSubscript:", objc_msgSend(v7, "bufferIndex")), "length");
    unint64_t v10 = v9
        / objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "vertexDescriptor"), "layouts"), "objectAtIndexedSubscript:", objc_msgSend(v7, "bufferIndex")), "stride");
    uint64_t v11 = (void *)[MEMORY[0x263EFF990] dataWithLength:4 * v10];
    [v11 setLength:4 * v10];
    uint64_t v12 = (void *)[v11 mutableBytes];
    bzero(v12, 4 * v10);
    uint64_t v15 = (void *)*a2;
    unsigned int v14 = a2 + 1;
    uint64_t v13 = v15;
    if (v15 != v14)
    {
      do
      {
        *((_DWORD *)v12 + *((unsigned int *)v13 + 7)) = *((_DWORD *)v13 + 8);
        int v16 = (void *)v13[1];
        if (v16)
        {
          do
          {
            unint64_t v17 = v16;
            int v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            unint64_t v17 = (void *)v13[2];
            BOOL v18 = *v17 == (void)v13;
            uint64_t v13 = v17;
          }
          while (!v18);
        }
        uint64_t v13 = v17;
      }
      while (v17 != v14);
    }
    double result = +[SCNGeometrySource geometrySourceWithData:v11 semantic:@"kGeometrySourceSemanticVertexCrease" vectorCount:v10 floatComponents:1 componentsPerVector:1 bytesPerComponent:4 dataOffset:0 dataStride:4];
    if (result) {
      return (SCNGeometrySource *)[(SCNGeometrySource *)v5 addObject:result];
    }
  }
  return result;
}

void sub_20B25BDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void C3DTextureSamplerSetBorderColor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
}

uint64_t C3DStackAllocatorCreate(uint64_t a1)
{
  if (C3DStackAllocatorGetTypeID(void)::onceToken != -1) {
    dispatch_once(&C3DStackAllocatorGetTypeID(void)::onceToken, &__block_literal_global_138);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DStackAllocatorGetTypeID(void)::typeID, 0x238uLL);
  __allocateChunk((vm_address_t *)(Instance + 24), a1);
  *(void *)(Instance + 16) = Instance + 24;
  *(_DWORD *)(Instance + 56) = *(_DWORD *)(Instance + 32);
  return Instance;
}

uint64_t __allocateChunk(vm_address_t *address, uint64_t a2)
{
  if (!address) {
    __allocateChunk();
  }
  if (!a2) {
    __allocateChunk();
  }
  vm_size_t v3 = ((*MEMORY[0x263EF8AF8] - 1) | (a2 - 1)) + 1;
  *((_DWORD *)address + 2) = v3;
  uint64_t result = vm_allocate(*MEMORY[0x263EF8960], address, v3, 1);
  if (!*address) {
    __allocateChunk();
  }
  return result;
}

uint64_t C3DSortSystemCreate()
{
  if (C3DSortSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSortSystemGetTypeID_onceToken, &__block_literal_global_1);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DSortSystemGetTypeID_typeID, 0x20uLL);
  *(void *)(Instance + 16) = C3DArrayCreate(8, 0);
  return Instance;
}

uint64_t C3DArrayCreate(int a1, int a2)
{
  if (C3DArrayGetTypeID_onceToken != -1) {
    dispatch_once(&C3DArrayGetTypeID_onceToken, &__block_literal_global_142);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DArrayGetTypeID_typeID, 0x18uLL);
  uint64_t v5 = Instance;
  *(_DWORD *)(Instance + 32) = a1;
  int v6 = *(_DWORD *)(Instance + 28);
  if (v6 != a2)
  {
    __allocate(Instance, v6 * a1, (a2 * a1));
    *(_DWORD *)(v5 + 28) = a2;
  }
  return v5;
}

void __allocate(uint64_t a1, unsigned int a2, size_t size)
{
  long long v4 = *(void **)(a1 + 16);
  if (size)
  {
    unsigned int v5 = size;
    size_t v6 = size;
    if (v4)
    {
      uint64_t v8 = (char *)malloc_type_realloc(v4, size, 0xA9E1E891uLL);
      *(void *)(a1 + 16) = v8;
      size_t v9 = v5 - a2;
      if (v5 <= a2) {
        return;
      }
      uint64_t v10 = &v8[a2];
    }
    else
    {
      uint64_t v10 = (char *)C3DMallocWithName(size);
      *(void *)(a1 + 16) = v10;
      size_t v9 = v6;
    }
    bzero(v10, v9);
  }
  else
  {
    free(v4);
    *(void *)(a1 + 16) = 0;
  }
}

void *C3DMallocWithName(size_t a1)
{
  return malloc_type_malloc(a1, 0xA9292AECuLL);
}

float C3DSetupHaltonFilterKernel(uint64_t a1, int a2, float result, float a4)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; *(void *)(a1 + 8 * i++) = v14)
    {
      if (i)
      {
        float v5 = 0.5;
        float v6 = 0.0;
        unsigned int v7 = i;
        do
        {
          if (v7) {
            float v8 = v5;
          }
          else {
            float v8 = -0.0;
          }
          float v6 = v6 + v8;
          float v5 = v5 * 0.5;
          BOOL v9 = v7 > 1;
          v7 >>= 1;
        }
        while (v9);
        float v10 = 0.0;
        int v11 = i;
        float v12 = 0.33333;
        do
        {
          if (v11 != 3 * (v11 / 3)) {
            float v10 = v10 + (float)((float)(v11 % 3) * v12);
          }
          float v12 = v12 * 0.33333;
          unsigned int v13 = v11 + 2;
          v11 /= 3;
        }
        while (v13 > 4);
      }
      else
      {
        float v6 = 0.0;
        float v10 = 0.0;
      }
      *(float *)&uint64_t v14 = (float)((float)(v6 * 2.0) + -1.0) * result;
      *((float *)&v14 + 1) = (float)((float)(v10 * 2.0) + -1.0) * a4;
    }
  }
  return result;
}

void *C3DRendererElementStateCreate()
{
  if (C3DRendererElementStateGetTypeID_onceToken != -1) {
    dispatch_once(&C3DRendererElementStateGetTypeID_onceToken, &__block_literal_global_33);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DRendererElementStateGetTypeID_typeID, 0x1A0uLL);
  if (!Instance)
  {
    uint64_t v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  Instance[7] = 0;
  BOOL v9 = (const void *)Instance[41];
  if (v9)
  {
    CFRelease(v9);
    Instance[41] = 0;
  }
  Instance[42] = 0;
  return Instance;
}

void C3DRenderGraphCreate()
{
}

void sub_20B25C714(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10F0C405F2E17D2);
  _Unwind_Resume(a1);
}

void C3D::RenderGraph::RenderGraph(C3D::RenderGraph *this, __C3DEngineContext *a2, void *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  C3DScratchAllocatorCreate();
}

void sub_20B25C808(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1030C408C11463FLL);
  _Unwind_Resume(a1);
}

void C3DScratchAllocatorCreate()
{
}

void VMAllocateChunk(vm_address_t *address, uint64_t a2)
{
  if (!address) {
    VMAllocateChunk();
  }
  if (address[3]) {
    VMAllocateChunk();
  }
  if (!a2) {
    VMAllocateChunk();
  }
  uint64_t v3 = ((*MEMORY[0x263EF8AF8] - 1) | (a2 - 1)) + 1;
  if (vm_allocate(*MEMORY[0x263EF8960], address, v3, 1))
  {
    *__error() = 12;
    *address = 0;
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      VMAllocateChunk(v3, v4);
    }
  }
  else
  {
    address[1] = v3;
    if (!*address) {
      VMAllocateChunk();
    }
  }
}

uint64_t C3DProgramHashCodeStoreCreate()
{
  if (C3DProgramHashCodeStoreGetTypeID(void)::onceToken != -1) {
    dispatch_once(&C3DProgramHashCodeStoreGetTypeID(void)::onceToken, &__block_literal_global_81);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DProgramHashCodeStoreGetTypeID(void)::typeID, 0x30uLL);
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(Instance + 16, 32);
  *(void *)(Instance + 48) = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  return Instance;
}

void C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(uint64_t a1, int a2)
{
  if ((a2 & (a2 - 1)) != 0) {
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  }
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  *(void *)(a1 + 16) = malloc_type_malloc((2 * (a2 + 15)), 0x74F3E194uLL);
  size_t v5 = 8 * v3;
  *(void *)a1 = malloc_type_malloc(v5 & 0xFFFFFFF8, 0x74F3E194uLL);
  *(void *)(a1 + 8) = malloc_type_malloc(v5 & 0xFFFFFFF8, 0x74F3E194uLL);
  memset(*(void **)a1, 255, v5);
  uint64_t v6 = *(void **)(a1 + 16);

  bzero(v6, v4);
}

void sub_20B25DA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void __UpdateSourcesMutability(uint64_t a1)
{
  *(unsigned char *)(a1 + 200) &= ~4u;
  v1[0] = MEMORY[0x263EF8330];
  v1[1] = 0x40000000;
  v1[2] = ____UpdateSourcesMutability_block_invoke;
  v1[3] = &__block_descriptor_tmp_35;
  v1[4] = a1;
  C3DMeshApplySources(a1, 0, (uint64_t)v1);
}

void C3DMeshApplySources(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v5 = a1 + 112;
  }
  else if (a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = a1 + 64;
  }
  for (uint64_t i = 0; i != 9; ++i)
  {
    uint64_t v15 = v5 + 2 * i;
    uint64_t v18 = *(char *)(v15 + 8);
    uint64_t v16 = v15 + 8;
    uint64_t v17 = v18;
    if (v18 != -1)
    {
      uint64_t v19 = *(unsigned __int8 *)(v16 + 1);
      if (*(unsigned char *)(v16 + 1))
      {
        uint64_t v20 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)v5, v17 + v20);
          (*(void (**)(uint64_t, const void *, void, uint64_t, void))(a3 + 16))(a3, ValueAtIndex, (char)i, v20, *(unsigned __int8 *)(v17 + v20 + *(void *)(v5 + 40)));
          ++v20;
        }
        while (v19 != v20);
      }
    }
  }
}

uint64_t C3DGenericSourceIsMutable(uint64_t a1)
{
  return *(unsigned char *)(a1 + 88) & 1;
}

const void *C3DMeshGetElementAtIndex(uint64_t a1, CFIndex idx, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!*(void *)(a1 + 96))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshGetElementAtIndex_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (a3 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    CFArrayRef v22 = *(const __CFArray **)(a1 + 144);
    return CFArrayGetValueAtIndex(v22, idx);
  }
  if (!a3)
  {
    CFArrayRef v22 = *(const __CFArray **)(a1 + 96);
    return CFArrayGetValueAtIndex(v22, idx);
  }
  float32x2_t v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
    C3DMeshGetElementAtIndex_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
  }
  return 0;
}

const void *C3DMeshGetSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a4 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v8 = (CFArrayRef *)(a1 + 112);
  }
  else if (a4)
  {
    uint64_t v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    }
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = (CFArrayRef *)(a1 + 64);
  }
  CFIndex v17 = __indexOfSourceWithSemanticAtIndex(a1, a2, a3, a4);
  if (v17 == -1) {
    return 0;
  }
  else {
    return CFArrayGetValueAtIndex(*v8, v17);
  }
}

uint64_t __indexOfSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a4 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v16 = (CFArrayRef *)(a1 + 112);
  }
  else if (a4)
  {
    CFIndex v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = (CFArrayRef *)(a1 + 64);
  }
  uint64_t v25 = (char *)v16 + 2 * a2;
  uint64_t v28 = v25[8];
  uint64_t v27 = v25 + 8;
  uint64_t v26 = v28;
  if (v28 == -1 || v27[1] <= a3) {
    return -1;
  }
  CFIndex v29 = v26 + a3;
  if (v29 >= CFArrayGetCount(*v16))
  {
    uint64_t v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      __indexOfSourceWithSemanticAtIndex_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
    }
  }
  return v29;
}

void C3DMeshBuildRenderableData(uint64_t a1, char a2)
{
  uint64_t v3 = a1;
  uint64_t v130 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    size_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(const void **)(v3 + 112);
  if (v12)
  {
    if (*(void *)(v3 + 144)) {
      return;
    }
    CFRelease(v12);
    *(void *)(v3 + 112) = 0;
  }
  char v100 = a2;
  uint64_t v13 = *(const void **)(v3 + 144);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(v3 + 144) = 0;
  }
  free(*(void **)(v3 + 168));
  *(void *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 160) = 0;
  free(*(void **)(v3 + 176));
  *(void *)(v3 + 176) = 0;
  __int16 v116 = 0;
  uint64_t v117 = 0;
  __int16 v115 = 0;
  unsigned int v114 = 0;
  v113 = 0;
  __C3DMeshDeindex((CFArrayRef *)v3, &v117, &v116, &v115, &v114, &v113);
  uint64_t v14 = v117;
  if (v117)
  {
    uint64_t v15 = v116;
    if (!v116)
    {
      uint64_t v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        C3DMeshBuildRenderableData_cold_1(v3, v22);
      }
      uint64_t v21 = v14;
      goto LABEL_83;
    }
    CFIndex Count = CFArrayGetCount(v117);
    if (Count < 1)
    {
LABEL_15:
      uint64_t v98 = 0;
    }
    else
    {
      CFIndex v17 = Count;
      CFIndex v18 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v14, v18);
        if (!C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex)) {
          break;
        }
        if (v17 == ++v18) {
          goto LABEL_15;
        }
      }
      uint64_t v98 = (uint64_t)ValueAtIndex;
    }
    uint64_t v23 = CFArrayGetCount(v15);
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], v23, MEMORY[0x263EFFF70]);
    CFArrayRef v25 = Mutable;
    if (v23 < 1)
    {
LABEL_72:
      CFRelease(v15);
      if (v23 != CFArrayGetCount(v25))
      {
        int v67 = scn_default_log();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_FAULT)) {
          C3DMeshBuildRenderableData_cold_4(v67, v68, v69, v70, v71, v72, v73, v74);
        }
      }
      *(void *)(v3 + 112) = v117;
      *(void *)(v3 + 144) = v25;
      int v75 = v115;
      *(_DWORD *)(v3 + 160) = v114;
      SCNMatrix4 v76 = v113;
      *(void *)(v3 + 168) = v75;
      *(void *)(v3 + 176) = v76;
      __BuildRenderableSourceChannelsAndSemanticInfos(v3);
      if ((v100 & 1) == 0) {
        __DropOriginalTopology(v3);
      }
      return;
    }
    CFIndex v26 = 0;
    CFAllocatorRef bytesDeallocator = (const __CFAllocator *)*MEMORY[0x263EFFB18];
    theArray = Mutable;
    uint64_t v92 = v23;
LABEL_26:
    CFIndex idx = v26;
    uint64_t v27 = (unsigned __int8 *)CFArrayGetValueAtIndex(v116, v26);
    uint64_t v28 = v27;
    if (v27[88] != 4)
    {
      float32x4_t v41 = CFRetain(v27);
      if (v41) {
        goto LABEL_68;
      }
      goto LABEL_80;
    }
    if (!*((void *)v27 + 12)) {
      goto LABEL_80;
    }
    if (C3DMeshElementGetIndicesChannelCount((uint64_t)v27) != 1)
    {
      uint64_t v86 = scn_default_log();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
        C3DMeshBuildRenderableData_cold_7();
      }
      goto LABEL_80;
    }
    unint64_t v29 = v28[80];
    unint64_t Length = CFDataGetLength(*((CFDataRef *)v28 + 12));
    BytePtr = CFDataGetBytePtr(*((CFDataRef *)v28 + 12));
    unsigned int v32 = *((_DWORD *)v28 + 26);
    if (v32)
    {
      uint64_t v33 = BytePtr;
      uint64_t v34 = 0;
      int v35 = 0;
      LOBYTE(v36) = 1;
      do
      {
        unsigned int IndexInBuffer = __readIndexInBuffer(v33, v35, v29, Length);
        int v38 = IndexInBuffer;
        if (IndexInBuffer <= 2)
        {
          if ((__C3DMeshElementCreateRenderablePrimitiveTypeCopy(__C3DMeshElement *,__C3DMeshSource const*)::done & 1) == 0)
          {
            __C3DMeshElementCreateRenderablePrimitiveTypeCopy(__C3DMeshElement *,__C3DMeshSource const*)::done = 1;
            SCNMatrix4 v77 = scn_default_log();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
              C3DMeshBuildRenderableData_cold_6(v38, v77);
            }
          }
          goto LABEL_80;
        }
        int v36 = (IndexInBuffer == 3) & v36;
        v34 += IndexInBuffer - 2;
        ++v35;
      }
      while (v32 != v35);
      if (v36)
      {
        CFIndex v39 = CFDataGetLength(*((CFDataRef *)v28 + 12));
        CFDataRef v40 = CFDataCreate(allocator, &v33[v32 * (unint64_t)v29], v39 - v32 * (unint64_t)v29);
        float32x4_t v41 = (_OWORD *)C3DMeshElementCreate();
        C3DMeshElementInit((uint64_t)v41, 0, *((_DWORD *)v28 + 26), v40, v29);
        CFDataRef v42 = v40;
        goto LABEL_67;
      }
      float32x4_t v43 = (unsigned __int8 *)malloc_type_malloc(v34 * 3 * v29, 0x70F0CBDBuLL);
      if (!v43) {
        goto LABEL_80;
      }
      uint64_t v97 = v43;
      uint64_t v95 = v34 * 3 * v29;
      int v44 = 0;
      unsigned int v99 = 0;
      int v45 = 0;
      unsigned int v93 = v32 + 2;
      unsigned int v94 = v32 + 1;
      unsigned int v87 = v32 + 3;
      uint64_t v89 = v3;
      unsigned int v108 = v32;
      while (1)
      {
        unsigned int v46 = __readIndexInBuffer(v33, v44, v29, Length);
        if (v46 >= 3) {
          break;
        }
LABEL_65:
        if (++v44 == v32)
        {
          CFDataRef v65 = CFDataCreateWithBytesNoCopy(allocator, v97, v34 * 3 * v29, bytesDeallocator);
          float32x4_t v41 = (_OWORD *)C3DMeshElementCreate();
          C3DMeshElementInit((uint64_t)v41, 0, v34, v65, v29);
          CFDataRef v42 = v65;
LABEL_67:
          CFRelease(v42);
          uint64_t v23 = v92;
          if (!v41) {
            goto LABEL_80;
          }
LABEL_68:
          uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v3, idx);
          if (ElementAtIndex)
          {
            v41[11] = *(_OWORD *)(ElementAtIndex + 176);
            v41[12] = *(_OWORD *)(ElementAtIndex + 192);
          }
          CFArrayRef v25 = theArray;
          CFArrayAppendValue(theArray, v41);
          CFRelease(v41);
          CFIndex v26 = idx + 1;
          if (idx + 1 == v23)
          {
            uint64_t v15 = v116;
            goto LABEL_72;
          }
          goto LABEL_26;
        }
      }
      unsigned int v47 = v46;
      int v48 = v45 + v32;
      unsigned int v49 = v45 + v32 + v46 - 1;
      if (v29 * (unint64_t)v49 > Length)
      {
        int v109 = v45;
        float32x4_t v50 = scn_default_log();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67110144;
          int v121 = v44;
          __int16 v122 = 1024;
          unsigned int v123 = v47;
          __int16 v124 = 1024;
          int v125 = v48;
          __int16 v126 = 1024;
          unsigned int v127 = v49;
          __int16 v128 = 1024;
          int v129 = Length / v29;
          _os_log_error_impl(&dword_20B249000, v50, OS_LOG_TYPE_ERROR, "Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)", buf, 0x20u);
        }
        v34 -= v47 - 2;
        unsigned int v32 = v108;
        int v45 = v109;
        goto LABEL_65;
      }
      if (v46 == 4)
      {
        unsigned int v90 = __readIndexInBuffer(v33, v48, v29, Length);
        int v102 = __readIndexInBuffer(v33, v45 + v94, v29, Length);
        unsigned int v91 = __readIndexInBuffer(v33, v45 + v93, v29, Length);
        int v110 = v45 + 4;
        int v106 = __readIndexInBuffer(v33, v87 + v45, v29, Length);
        __writeIndexInBuffer(v97, v99, v90, v29, v95);
        __writeIndexInBuffer(v97, v99 + 1, v102, v29, v95);
        __writeIndexInBuffer(v97, v99 + 2, v91, v29, v95);
        __writeIndexInBuffer(v97, v99 + 3, v90, v29, v95);
        int v103 = v99 + 5;
        __writeIndexInBuffer(v97, v99 + 4, v91, v29, v95);
        v99 += 6;
        char v53 = v97;
        int v54 = v103;
        int v55 = v106;
        unint64_t v56 = v29;
        unint64_t v57 = v95;
        goto LABEL_50;
      }
      if (v46 == 3)
      {
        int v51 = __readIndexInBuffer(v33, v48, v29, Length);
        int v105 = __readIndexInBuffer(v33, v45 + v94, v29, Length);
        int v110 = v45 + 3;
        int v101 = __readIndexInBuffer(v33, v45 + v93, v29, Length);
        __writeIndexInBuffer(v97, v99, v51, v29, v95);
        int v52 = v99 + 2;
        __writeIndexInBuffer(v97, v99 + 1, v105, v29, v95);
        v99 += 3;
        char v53 = v97;
        int v54 = v52;
        int v55 = v101;
        unint64_t v56 = v29;
        unint64_t v57 = v95;
        uint64_t v3 = v89;
LABEL_50:
        __writeIndexInBuffer(v53, v54, v55, v56, v57);
        int v45 = v110;
LABEL_64:
        unsigned int v32 = v108;
        goto LABEL_65;
      }
      if (!v98) {
        goto LABEL_64;
      }
      uint64_t v58 = (unsigned int *)malloc_type_malloc(4 * v46, 0x100004052888210uLL);
      uint64_t v59 = 0;
      int v111 = v45;
      do
      {
        v58[v59] = __readIndexInBuffer(v33, v108 + v45 + v59, v29, Length);
        ++v59;
      }
      while (v47 != v59);
      *(_DWORD *)buf = 0;
      unint64_t v60 = C3DDelaunayTriangulationForSimplePlanarPolygon(v98, v58, v47, (int *)buf);
      int v61 = v60;
      unsigned int v62 = v47 - 2;
      if (*(_DWORD *)buf)
      {
        if (*(_DWORD *)buf == 3 * v62)
        {
          unint64_t v63 = 0;
          uint64_t v107 = v60;
          do
          {
            __writeIndexInBuffer(v97, v99 + v63, v107[v63], v29, v95);
            ++v63;
          }
          while (v63 < *(unsigned int *)buf);
          v99 += v63;
          uint64_t v3 = v89;
          int v61 = v107;
          goto LABEL_62;
        }
        int v64 = scn_default_log();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
          C3DMeshBuildRenderableData_cold_5(&v118, v119, v64);
        }
      }
      v34 -= v62;
      uint64_t v3 = v89;
      if (!v61)
      {
LABEL_63:
        free(v58);
        int v45 = v47 + v111;
        goto LABEL_64;
      }
LABEL_62:
      free(v61);
      goto LABEL_63;
    }
    float32x4_t v41 = (_OWORD *)C3DMeshElementCreate();
    C3DMeshElementInit((uint64_t)v41, 0, 0, 0, 0);
    if (v41) {
      goto LABEL_68;
    }
LABEL_80:
    uint64_t v78 = scn_default_log();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
      C3DMeshBuildRenderableData_cold_3(v78, v79, v80, v81, v82, v83, v84, v85);
    }
    uint64_t v21 = theArray;
LABEL_83:
    CFRelease(v21);
  }
  else
  {
    uint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      C3DMeshBuildRenderableData_cold_1(v3, v20);
    }
    uint64_t v21 = v116;
    if (v116) {
      goto LABEL_83;
    }
  }
}

uint64_t C3DGenericSourceIsVolatile(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

uint64_t C3DGenericSourceGetMTLBuffer(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(void *)(a1 + 80)) {
    return *(void *)(a1 + 72);
  }
  else {
    return 0;
  }
}

void *C3DGenericSourceGetData(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = (void *)a1[9];
  if (a1[10]) {
    return (void *)C3DDataFromMTLBuffer(result);
  }
  if (!result)
  {
    uint64_t result = (void *)a1[8];
    if (result) {
      return C3DSourceAccessorGetData((uint64_t)result);
    }
  }
  return result;
}

uint64_t C3DMeshSourceGetContent(uint64_t a1)
{
  Accessor = (void *)C3DGenericSourceGetAccessor(a1);
  DatSCNMatrix4 a = C3DSourceAccessorGetData((uint64_t)Accessor);
  uint64_t v4 = 0;
  uint64_t Count = C3DSourceAccessorGetCount((uint64_t)Accessor);
  if (Data && Count)
  {
    if (C3DGenericSourceIsVolatile(a1)) {
      uint64_t VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
    }
    else {
      uint64_t VolatileValuePtrAtIndex = (uint64_t)C3DSourceAccessorGetValuePtrAtIndex(Accessor, 0);
    }
    uint64_t v4 = VolatileValuePtrAtIndex;
  }
  C3DSceneSourceGetLibrary((uint64_t)Accessor);
  unsigned int ComponentsValueType = C3DSourceAccessorGetComponentsValueType((uint64_t)Accessor);
  ComponentsCountPerint Value = C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor);
  if (ComponentsValueType != C3DBaseTypeGetComponentType(ComponentsValueType)) {
    C3DBaseTypeGetComponentCount(ComponentsValueType);
  }
  C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue);
  return v4;
}

uint64_t C3DSourceAccessorGetCount(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t _fillVertexDescriptor(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  char v8 = 0;
  switch(a3)
  {
    case 0:
      break;
    case 1:
      char v8 = 1;
      break;
    case 2:
      char v8 = 3;
      break;
    case 3:
      if (a4 == -1)
      {
        char v8 = 6;
      }
      else
      {
        char v8 = a4 + 6;
        if ((a4 + 6) == 14) {
          goto LABEL_6;
        }
      }
      break;
    case 4:
      char v8 = 2;
      break;
    case 5:
      char v8 = 4;
      break;
    case 6:
      char v8 = 5;
      break;
    default:
LABEL_6:
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        _fillVertexDescriptor();
      }
      char v8 = 14;
      break;
  }
  uint64_t Accessor = C3DMeshSourceGetAccessor(a2);
  int ComponentsValueType = C3DSourceAccessorGetComponentsValueType(Accessor);
  ComponentsCountPerint Value = C3DSourceAccessorGetComponentsCountPerValue(Accessor);
  int CompoundType = C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue);
  uint64_t MTLVertexFormat = C3DMeshSourceGetMTLVertexFormat(a2);
  uint64_t v15 = a5 + 18;
  if (!MTLVertexFormat) {
    uint64_t MTLVertexFormat = SCNMTLVertexFormatFromC3DBaseType(CompoundType);
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setFormat:", MTLVertexFormat);
  if (!objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "format"))
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      _fillVertexDescriptor(CompoundType, v16);
    }
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setOffset:", C3DSourceAccessorGetOffset(Accessor));
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setBufferIndex:", v15);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStride:", C3DSceneSourceGetLibrary(Accessor));
  unsigned int InstancingDivisor = C3DMeshSourceGetInstancingDivisor(a2);
  if (!InstancingDivisor) {
    return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepFunction:", 1);
  }
  uint64_t v18 = InstancingDivisor;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepFunction:", 2);
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepRate:", v18);
}

uint64_t C3DSourceAccessorGetComponentsValueType(uint64_t a1)
{
  return *(__int16 *)(a1 + 24);
}

uint64_t C3DSourceAccessorGetComponentsCountPerValue(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

uint64_t C3DSceneSourceGetLibrary(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t C3DGenericSourceGetAccessor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

uint64_t C3DBaseTypeGetCompoundType(int a1, int a2)
{
  LOWORD(v2) = a1;
  switch(a1)
  {
    case 1:
      if ((a2 - 1) < 4)
      {
        char v3 = 16 * (a2 - 1);
        unint64_t v4 = 0xA000900080001;
        goto LABEL_20;
      }
      uint64_t v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        C3DBaseTypeGetCompoundType_cold_11();
      }
      return (__int16)v2;
    case 2:
      if ((a2 - 1) < 4)
      {
        char v3 = 16 * (a2 - 1);
        unint64_t v4 = 0x14001300120002;
        goto LABEL_20;
      }
      uint64_t v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        C3DBaseTypeGetCompoundType_cold_12();
      }
      return (__int16)v2;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 18:
    case 19:
    case 20:
      goto LABEL_8;
    case 4:
      if (a2 == 1)
      {
        LOWORD(v2) = 4;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 26;
      }
      else
      {
        uint64_t v20 = scn_default_log();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_4();
        }
      }
      return (__int16)v2;
    case 14:
      if ((a2 - 1) < 4)
      {
        char v3 = 16 * (a2 - 1);
        unint64_t v4 = 0x2200210020000ELL;
        goto LABEL_20;
      }
      uint64_t v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        C3DBaseTypeGetCompoundType_cold_8();
      }
      break;
    case 15:
      if ((a2 - 1) >= 4)
      {
        uint64_t v16 = scn_default_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_10();
        }
      }
      else
      {
        char v3 = 16 * (a2 - 1);
        unint64_t v4 = 0x2D002C002B000FLL;
LABEL_20:
        unint64_t v2 = v4 >> v3;
      }
      break;
    case 16:
      if (a2 == 1)
      {
        LOWORD(v2) = 16;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 25;
      }
      else
      {
        uint64_t v21 = scn_default_log();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_2();
        }
      }
      return (__int16)v2;
    case 17:
      if ((a2 - 1) >= 4)
      {
        CFIndex v17 = scn_default_log();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_6();
        }
      }
      else
      {
        unint64_t v2 = 0x1F001E001D0011uLL >> (16 * (a2 - 1));
      }
      return (__int16)v2;
    case 21:
      if (a2 == 1)
      {
        LOWORD(v2) = 21;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 27;
      }
      else
      {
        uint64_t v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_3();
        }
      }
      return (__int16)v2;
    case 22:
      if (a2 == 1)
      {
        LOWORD(v2) = 22;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 28;
      }
      else
      {
        uint64_t v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          C3DBaseTypeGetCompoundType_cold_5();
        }
      }
      return (__int16)v2;
    default:
      if (a1 == 35)
      {
        if ((a2 - 1) >= 4)
        {
          uint64_t v19 = scn_default_log();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            C3DBaseTypeGetCompoundType_cold_7();
          }
        }
        else
        {
          LOWORD(v2) = a2 + 34;
        }
      }
      else if (a1 == 39)
      {
        if ((a2 - 1) >= 4)
        {
          uint64_t v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            C3DBaseTypeGetCompoundType_cold_9();
          }
        }
        else
        {
          LOWORD(v2) = a2 + 38;
        }
      }
      else
      {
LABEL_8:
        if (a2 != 1)
        {
          uint64_t v5 = scn_default_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
            C3DBaseTypeGetCompoundType_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
          }
        }
      }
      return (__int16)v2;
  }
  return (__int16)v2;
}

uint64_t C3DMeshSourceGetMTLVertexFormat(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t SCNMTLVertexFormatFromC3DBaseType(int a1)
{
  if (a1 >= 46)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLDataTypeFromC3DBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return __SCNMTLAttributeFormatFromC3DBaseType[a1];
}

uint64_t C3DSourceAccessorGetOffset(uint64_t a1)
{
  if (!a1)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSourceAccessorGetData_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t C3DMeshSourceGetInstancingDivisor(uint64_t a1)
{
  if (!a1)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 98);
}

const UInt8 *C3DSourceAccessorGetValuePtrAtIndex(void *a1, uint64_t a2)
{
  if (a1[4] <= a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      C3DSourceAccessorGetValuePtrAtIndex_cold_2();
    }
  }
  else
  {
    DatSCNMatrix4 a = (const __CFData *)C3DSourceAccessorGetData((uint64_t)a1);
    if (Data) {
      return &CFDataGetBytePtr(Data)[a1[6] + a1[5] * a2];
    }
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      C3DSourceAccessorGetValuePtrAtIndex_cold_1();
    }
  }
  return 0;
}

void *C3DSourceAccessorGetData(uint64_t a1)
{
  if (!a1)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSourceAccessorGetData_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = *(void **)(a1 + 16);
  if (result) {
    return C3DGenericSourceGetOwnData((uint64_t)result);
  }
  return result;
}

void *C3DGenericSourceGetOwnData(uint64_t a1)
{
  if (!a1)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = *(void **)(a1 + 72);
  if (*(void *)(a1 + 80)) {
    return (void *)C3DDataFromMTLBuffer(result);
  }
  return result;
}

uint64_t C3DBaseTypeGetComponentType(unsigned int a1)
{
  if (a1 < 0x2E)
  {
    return (__int16)__C3DBaseTypeDescArray[3 * (unsigned __int16)a1];
  }
  else
  {
    uint64_t v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
      C3DBaseTypeGetComponentType_cold_1();
    }
    return 0;
  }
}

void __BuildRenderableSourceChannelsAndSemanticInfos(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
  free(*(void **)(a1 + 152));
  *(void *)(a1 + 152) = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);

  __BuildSemanticInfosForData(a1, v2);
}

unint64_t C3DRendererElementStoreAllocateSpanForNode(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  unsigned int v8 = a4 & 4;
  if (!a3 && (a4 & 4) == 0)
  {
LABEL_45:
    unint64_t v43 = 0;
    LOWORD(v33) = -1;
    int v44 = -65536;
    return v44 & 0xFFFF0000 | v43 | (unsigned __int16)v33;
  }
  if (a3)
  {
    if ((a4 & 4) == 0)
    {
      if (*(_DWORD *)(a3 + 228))
      {
        uint64_t v9 = scn_default_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
          C3DRendererElementStoreAllocateSpanForNode_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
        }
      }
    }
    CFDictionaryRef Light = C3DNodeGetLight(a3);
    uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry(a3);
    if (Light)
    {
      AreaVisualisationuint64_t Geometry = (__C3DGeometry *)C3DLightGetAreaVisualisationGeometry((uint64_t)Light);
      char v19 = 1;
      goto LABEL_13;
    }
    char v19 = 0;
  }
  else
  {
    char v19 = 0;
    uint64_t Geometry = 0;
  }
  AreaVisualisationuint64_t Geometry = 0;
LABEL_13:
  unsigned int v20 = a4 & 2;
  if (a4) {
    unsigned int v21 = __SpanCountForGeometryAttribute(a2, a3, Geometry);
  }
  else {
    unsigned int v21 = 0;
  }
  int v55 = v21 + (v20 >> 1) + (v8 >> 2);
  int v51 = a4 & 2;
  unsigned int v52 = v21;
  uint64_t v48 = v21 + (v20 >> 1);
  unsigned int v22 = v8;
  if ((a4 & 8) != 0)
  {
    CFArrayRef v25 = (__C3DGeometry *)C3DNodeGetGeometry(a3);
    uint64_t v23 = a2;
    int v24 = __SpanCountForGeometryAttribute(a2, a3, v25) + 1;
  }
  else
  {
    uint64_t v23 = a2;
    int v24 = 0;
  }
  char v26 = v19 ^ 1;
  if ((a4 & 0x10) == 0) {
    char v26 = 1;
  }
  if (v26) {
    int v27 = 0;
  }
  else {
    int v27 = __SpanCountForGeometryAttribute(v23, a3, AreaVisualisationGeometry);
  }
  uint64_t v28 = (v27 + v24 + v55);
  unsigned __int16 v49 = v24 + v55;
  int v50 = v27;
  if ((a4 & 0x21) == 0x21) {
    int v29 = __SpanCountForGeometryAttribute(v23, a3, Geometry);
  }
  else {
    int v29 = 0;
  }
  uint64_t v30 = (v29 + v28);
  if (!(v29 + v28)) {
    goto LABEL_45;
  }
  CFTypeRef cf = Geometry;
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(a1);
  unint64_t Span = C3DSpanAllocatorAllocateSpan(*(void *)(RendererElementStore + 16), v30);
  unint64_t v33 = Span;
  int v34 = a4 & 0x21;
  if ((a4 & 8) != 0)
  {
    if (cf)
    {
      __InitializeRendererElementsForGeometryAttribute(RendererElementStore, Span, (unsigned __int16)v55, cf, a3, 0);
      if (C3DNodeHasGeometryLOD(a3)) {
        __AllocateSpansAndInitializeRendererElementsForNodeGeometryLOD(v23, RendererElementStore, a3);
      }
    }
    uint64_t v35 = C3DGetScene((void *)a3);
    RegisteredCIFilterTechniqueForNode = C3DSceneGetRegisteredCIFilterTechniqueForNode(v35, (void *)a3);
    if (!RegisteredCIFilterTechniqueForNode) {
      RegisteredCIFilterTechniqueForNode = (const void *)C3DFXTechniqueGetNullTechnique();
    }
    __InitializeRendererElementWithNode(RendererElementStore, v33, (v55 + v24 - 1), a3, 3, 0, 0, RegisteredCIFilterTechniqueForNode, 0, 0);
  }
  if (a4)
  {
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, 0, cf, a3, 0);
    if (C3DNodeHasGeometryLOD(a3)) {
      __AllocateSpansAndInitializeRendererElementsForNodeGeometryLOD(v23, RendererElementStore, a3);
    }
    CFTypeID v37 = CFGetTypeID(cf);
    BOOL v38 = v37 == C3DFloorGetTypeID();
    int v34 = a4 & 0x21;
    if (v38)
    {
      Floor = (const void *)C3DFXTechniqueCreateFloor(v23, (__C3DNode *)a3);
      uint64_t ElementInSpanAtIndex = C3DSpanAllocatorGetElementInSpanAtIndex(*(void *)(RendererElementStore + 16), v33, 0);
      float32x4_t v41 = *(const void **)(ElementInSpanAtIndex + 40);
      if (v41 != Floor)
      {
        if (v41)
        {
          CFRelease(v41);
          *(void *)(ElementInSpanAtIndex + 40) = 0;
        }
        if (Floor) {
          CFTypeRef v42 = CFRetain(Floor);
        }
        else {
          CFTypeRef v42 = 0;
        }
        *(void *)(ElementInSpanAtIndex + 40) = v42;
      }
      CFRelease(Floor);
      _C3DRendererElementSync(ElementInSpanAtIndex, 2);
      *(_WORD *)(ElementInSpanAtIndex + 72) |= 0x20u;
    }
  }
  if (v51) {
    __InitializeRendererElementWithNode(RendererElementStore, v33, v52, a3, 1, 0, 0, 0, 0, 0);
  }
  if (v22) {
    __InitializeRendererElementWithNode(RendererElementStore, v33, v48, a3, 2, 0, 0, 0, 0, 0);
  }
  int v44 = v33 & 0xFFFF0000;
  unint64_t v43 = v33 & 0xFFFFFFFF00000000;
  if (v50) {
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, v49, AreaVisualisationGeometry, a3, 0);
  }
  if (v34 == 33)
  {
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, (unsigned __int16)v28, cf, a3, 5);
    if (v52)
    {
      uint64_t v46 = v52;
      do
      {
        uint64_t v47 = C3DSpanAllocatorGetElementInSpanAtIndex(*(void *)(RendererElementStore + 16), v33, v28);
        *(_WORD *)(v47 + 72) = *(_WORD *)(v47 + 72) & 0xBFA7 | 0x4008;
        ++v28;
        --v46;
      }
      while (v46);
    }
  }
  return v44 & 0xFFFF0000 | v43 | (unsigned __int16)v33;
}

uint64_t C3DEnginePipelineGetRendererElementStore(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t __SpanCountForGeometryAttribute(uint64_t a1, uint64_t a2, __C3DGeometry *a3)
{
  if (!a3) {
    return 0;
  }
  if (!C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a3))
  {
    MeshToRender = _C3DNodeGetMeshToRender(a2, a3);
    if (MeshToRender)
    {
      uint64_t v8 = (uint64_t)MeshToRender;
      ElementsCFIndex Count = C3DMeshGetElementsCount((uint64_t)MeshToRender);
      if ((uint64_t)ElementsCount >= 1)
      {
        CFArrayRef v10 = ElementsCount;
        CFIndex v11 = 0;
        uint64_t v12 = 0;
        do
        {
          uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v8, v11, 0);
          if (C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex)) {
            ++v12;
          }
          ++v11;
        }
        while (v10 != (const __CFArray *)v11);
        if (v12 && C3DGeometryOpenSubdivGPUIsActive(a3))
        {
          uint64_t v14 = 0;
          int v15 = 1;
          do
          {
            C3DGeometryOpenSubdivGetGPUContext((uint64_t)a3, 1, a1);
            unsigned int v16 = v15;
            v14 += C3DGeometryOpenSubdivGetGPUHasPatchOfType((uint64_t)a3, v15++);
          }
          while (v16 < 6);
          v12 *= v14;
        }
        return v12;
      }
    }
    return 0;
  }

  return C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh((uint64_t)a3);
}

const void *C3DGeometryGetRenderingMesh(__C3DGeometry *a1)
{
  if (C3DGeometryOsdGetWantsCPUSubdivision(a1))
  {
    return C3DGeometryOsdGetCPUSubdividedC3DMesh((uint64_t)a1);
  }
  else
  {
    return (const void *)C3DGeometryGetMesh((uint64_t)a1);
  }
}

BOOL C3DGeometryOsdGetWantsCPUSubdivision(__C3DGeometry *a1)
{
  return a1->var10.var0 && a1->var11.var0 != 4 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

void __InitializeRendererElementsForGeometryAttribute(uint64_t a1, unint64_t a2, unsigned int a3, __C3DGeometry *a4, uint64_t a5, char a6)
{
  if (C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a4))
  {
    MeshElementCountForDeformerBasedDynamicuint64_t Mesh = C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh((uint64_t)a4);
    if (MeshElementCountForDeformerBasedDynamicMesh)
    {
      uint64_t v11 = MeshElementCountForDeformerBasedDynamicMesh;
      uint64_t v12 = a3;
      do
      {
        __InitializeRendererElementWithNode(a1, a2, v12++, a5, a6, a4, 0, 0, 0, 0);
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    MeshToRender = _C3DNodeGetMeshToRender(a5, a4);
    ElementsCFIndex Count = C3DMeshGetElementsCount((uint64_t)MeshToRender);
    if ((uint64_t)ElementsCount >= 1)
    {
      CFArrayRef v15 = ElementsCount;
      CFIndex v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = a2;
      uint64_t v19 = a3;
      CFArrayRef v24 = ElementsCount;
      do
      {
        uint64_t ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)MeshToRender, v16, 0);
        if (C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex))
        {
          if (C3DGeometryOpenSubdivGPUIsActive(a4))
          {
            uint64_t v21 = a5;
            unsigned __int8 v22 = 1;
            do
            {
              unsigned int v23 = v22;
              if (C3DGeometryOpenSubdivGetGPUHasPatchOfType((uint64_t)a4, v22))
              {
                a2 = a2 & 0xFFFFFFFF00000000 | v18;
                __InitializeRendererElementWithNode(a1, a2, v17 + v19, v21, a6, a4, MeshToRender, 0, v16, v22);
                ++v17;
              }
              ++v22;
            }
            while (v23 < 6);
            a5 = v21;
            CFArrayRef v15 = v24;
          }
          else
          {
            unint64_t v25 = v25 & 0xFFFFFFFF00000000 | v18;
            __InitializeRendererElementWithNode(a1, v18, v17 + v19, a5, a6, a4, MeshToRender, 0, v16, 0);
            ++v17;
          }
        }
        ++v16;
      }
      while ((const __CFArray *)v16 != v15);
    }
  }
}

CFArrayRef C3DMeshGetElementsCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 96);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

uint64_t C3DMeshElementGetPrimitiveCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

unint64_t __AllocateNewSpanInPage(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*(_DWORD *)(a1 + 32) < a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __AllocateNewSpanInPage_cold_3(v2, v4);
    }
  }
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v8 = 2;
    while (1)
    {
      uint64_t v9 = (unsigned __int16 *)(v7 + v8);
      unsigned int v10 = *(_DWORD *)(v7 + v8 + 2);
      if (v10 >= v2) {
        break;
      }
      ++v6;
      v8 += 8;
      if (v5 == v6) {
        goto LABEL_8;
      }
    }
    unsigned int v20 = *(v9 - 1);
    unsigned int v19 = *v9;
    if (v19 + v2 > *(_DWORD *)(a1 + 8))
    {
      unsigned __int8 v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
        __AllocateNewSpanInPage_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
      }
    }
    uint64_t v30 = *(void *)(a1 + 16);
    int v31 = *(_DWORD *)(v30 + v8 + 2) - v2;
    if (v31)
    {
      *(_WORD *)(v30 + v8) += v2;
      *(_DWORD *)(v30 + v8 + 2) = v31;
    }
    else
    {
      __RemoveFromFreeList((_DWORD *)a1, v6);
    }
    if (*(_DWORD *)(a1 + 32) == v10)
    {
      uint64_t v32 = *(unsigned int *)(a1 + 24);
      if (v32)
      {
        unsigned int v33 = 0;
        int v34 = (unsigned int *)(*(void *)(a1 + 16) + 4);
        do
        {
          unsigned int v36 = *v34;
          v34 += 2;
          unsigned int v35 = v36;
          if (v36 > v33) {
            unsigned int v33 = v35;
          }
          --v32;
        }
        while (v32);
        *(_DWORD *)(a1 + 32) = v33;
      }
      else
      {
        *(_DWORD *)(a1 + 32) = 0;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXPassInitialize_cold_2(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    uint64_t v2 = 0;
    unsigned int v19 = 0xFFFF;
    unsigned int v20 = 0xFFFF;
  }
  return (v2 << 32) | ((unint64_t)v19 << 16) | v20;
}

unint64_t __AllocateNewSpan(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 24);
  if (v6)
  {
    uint64_t NewPage = *(void *)(a1 + 16);
    uint64_t v8 = v6;
    while (!*(void *)NewPage || *(_DWORD *)(NewPage + 32) < a2)
    {
      NewPage += 40;
      if (!--v8)
      {
        uint64_t v9 = 0;
        uint64_t NewPage = 0;
        uint64_t v10 = 40 * v6;
        do
        {
          uint64_t v11 = *(void *)(a1 + 16);
          uint64_t v12 = (void *)(v11 + v9);
          unsigned int v13 = *(_DWORD *)(v11 + v9 + 32);
          if (v13 >= a2)
          {
            if (!*v12) {
              __AllocatePage(a1, (uint64_t)v12, *(_DWORD *)(v11 + v9 + 12), v13);
            }
            uint64_t NewPage = (uint64_t)v12;
          }
          v9 += 40;
        }
        while (v10 != v9);
        if (NewPage) {
          goto LABEL_18;
        }
        goto LABEL_13;
      }
    }
    goto LABEL_18;
  }
LABEL_13:
  if (*(void *)(a1 + 48) >= (uint64_t)a2) {
    unsigned int v14 = *(void *)(a1 + 48);
  }
  else {
    unsigned int v14 = a2;
  }
  if (v14 <= 0x10000)
  {
    uint64_t NewPage = __CreateNewPage(a1, v14);
LABEL_18:
    if (a3) {
      *a3 = NewPage;
    }
    *(_DWORD *)(a1 + 36) += a2;
    return __AllocateNewSpanInPage(NewPage, a2);
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    __AllocateNewSpan_cold_1(v16);
  }
  return 0xFFFFFFFFLL;
}

void _C3DEnginePipelineAllocateAndTrackRendererElements(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  unint64_t SpanForNode = C3DRendererElementStoreAllocateSpanForNode(a1, a2, a3, a4);
  if (SpanForNode != 0xFFFFFFFF)
  {
    unint64_t v7 = SpanForNode;
    unint64_t v8 = HIDWORD(SpanForNode);
    if (HIDWORD(SpanForNode))
    {
      uint64_t v17 = 0;
      *(void *)(a3 + 224) = SpanForNode;
      do
      {
        uint64_t ElementInSpanAtIndex = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), *(void *)(a3 + 224), v17);
        __TrackRendererElementsDependencies(a1, ElementInSpanAtIndex);
        ++v17;
      }
      while (v8 != v17);
    }
    else
    {
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        _C3DEnginePipelineAllocateAndTrackRendererElements_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
      }
      *(void *)(a3 + 224) = v7;
    }
    if (C3DNodeHasGeometryLOD(a3))
    {
      uint64_t Geometry = C3DNodeGetGeometry(a3);
      if (Geometry)
      {
        CFArrayRef LOD = (const __CFArray *)C3DGeometryGetLOD(Geometry);
        CFIndex Count = CFArrayGetCount(LOD);
        if (Count >= 1)
        {
          CFIndex v22 = Count;
          for (uint64_t i = 0; i != v22; ++i)
          {
            uint64_t v24 = *(void *)(a3 + 232) + 12 * i;
            uint64_t v25 = *(unsigned int *)(v24 + 16);
            if (v25)
            {
              uint64_t v26 = 0;
              unint64_t v27 = *(unsigned int *)(v24 + 12) | (unint64_t)(v25 << 32);
              do
              {
                uint64_t v28 = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), v27, v26);
                if (v28) {
                  __TrackRendererElementsDependencies(a1, v28);
                }
                ++v26;
              }
              while (v25 != v26);
            }
          }
        }
      }
    }
  }
}

uint64_t C3DNodeHasGeometryLOD(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 221) >> 7;
}

void __TrackRendererElementsDependencies(uint64_t a1, const void *a2)
{
  uint64_t Material = (const void *)C3DRendererElementGetMaterial((uint64_t)a2);
  if (Material)
  {
    uint64_t v5 = Material;
    int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Material);
    if (!Value)
    {
      int Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, Value);
      CFRelease(Value);
    }
    CFSetAddValue((CFMutableSetRef)Value, a2);
  }
}

unint64_t C3DSpanAllocatorAllocateSpan(uint64_t a1, uint64_t a2)
{
  return __AllocateNewSpan(a1, a2, 0);
}

uint64_t C3DRendererElementStoreGetElementInSpanAtIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v4 = a2;
  uint64_t v6 = HIDWORD(a2);
  if (!a1)
  {
    unint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  if (v6 <= a3)
  {
    uint64_t v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreGetElementInSpanAtIndex_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  return C3DSpanAllocatorGetElementInSpanAtIndex(*(void *)(a1 + 16), v4, a3);
}

uint64_t C3DMeshSourceGetCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DSourceAccessorGetCount(*(void *)(a1 + 64));
}

uint64_t C3DMeshGetSourcesCount(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t result = 0;
  uint64_t v4 = a1 + 73;
  do
  {
    result += *(unsigned __int8 *)(v4 + v2);
    v2 += 2;
  }
  while (v2 != 18);
  return result;
}

uint64_t C3DMeshElementTypeMapsToMTLPrimitiveType(unsigned int a1)
{
  return (a1 < 6) & (0xFu >> a1);
}

uint64_t C3DMeshIsMutable(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 200) >> 2) & 1;
}

__CFString *__stringForProperty()
{
  uint64_t result = @"multiply";
  switch(@"multiply")
  {
    case 0u:
      uint64_t v1 = kC3DEmission;
      goto LABEL_18;
    case 1u:
      uint64_t v1 = kC3DAmbient;
      goto LABEL_18;
    case 2u:
      uint64_t v1 = kC3DDiffuse;
      goto LABEL_18;
    case 3u:
      uint64_t v1 = kC3DSpecular;
      goto LABEL_18;
    case 4u:
      uint64_t v1 = kC3DReflective;
      goto LABEL_18;
    case 5u:
      uint64_t v1 = kC3DTransparent;
      goto LABEL_18;
    case 6u:
      return result;
    case 7u:
      uint64_t v1 = kC3DNormal;
      goto LABEL_18;
    case 8u:
      uint64_t v1 = kC3DAmbientOcclusion;
      goto LABEL_18;
    case 9u:
      uint64_t v1 = kC3DSelfIllumination;
      goto LABEL_18;
    case 0xAu:
      uint64_t v1 = kC3DMetalness;
      goto LABEL_18;
    case 0xBu:
      uint64_t v1 = kC3DRoughness;
      goto LABEL_18;
    case 0xCu:
      uint64_t v1 = kC3DClearCoat;
      goto LABEL_18;
    case 0xDu:
      uint64_t v1 = kC3DClearCoatRoughness;
      goto LABEL_18;
    case 0xEu:
      uint64_t v1 = kC3DClearCoatNormal;
      goto LABEL_18;
    case 0xFu:
      uint64_t v1 = kC3DDisplacement;
LABEL_18:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t __CreateNewPage(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4)
  {
    *(_DWORD *)(a1 + 24) = v4 + 1;
    uint64_t v5 = malloc_type_realloc(*(void **)(a1 + 16), 40 * (v4 + 1), 0x10A00408EF24B1CuLL);
    *(void *)(a1 + 16) = v5;
  }
  else
  {
    uint64_t v5 = malloc_type_malloc(0x28uLL, 0x10A00408EF24B1CuLL);
    *(void *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 24) = 1;
  }
  ++*(_DWORD *)(a1 + 28);
  uint64_t v6 = (uint64_t)v5 + 40 * v4;
  __AllocatePage(a1, v6, v4, a2);
  return v6;
}

void __AllocatePage(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v7 = a4;
  size_t v8 = *(void *)(a1 + 40) * a4;
  uint64_t v9 = malloc_type_malloc(v8, 0xE6913EE2uLL);
  *(void *)a2 = v9;
  bzero(v9, v8);
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a3;

  __AddToFreeList(a2, (unsigned __int16)a3 | (unint64_t)(v7 << 32));
}

void __AddToFreeList(uint64_t a1, unint64_t a2)
{
  unsigned __int16 v2 = WORD1(a2);
  *(void *)&v42[5] = *MEMORY[0x263EF8340];
  unint64_t v40 = a2;
  if (!HIDWORD(a2))
  {
    unsigned int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __AddToFreeList_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unint64_t v39 = *(unsigned int *)(a1 + 24);
  if (!v39)
  {
    BOOL v17 = 0;
    uint64_t v13 = 0;
LABEL_22:
    unsigned int v28 = *(_DWORD *)(a1 + 28);
    if (v28 < *(_DWORD *)(a1 + 24) + 1)
    {
      if (*(void *)(a1 + 16))
      {
        int v29 = 2 * v28;
        *(_DWORD *)(a1 + 28) = v29;
        if (!v29)
        {
          uint64_t v30 = scn_default_log();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
            __AddToFreeList_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
          }
        }
        BOOL v38 = malloc_type_realloc(*(void **)(a1 + 16), 8 * *(unsigned int *)(a1 + 28), 0x100004000313F17uLL);
      }
      else
      {
        *(_DWORD *)(a1 + 28) = 8;
        BOOL v38 = malloc_type_malloc(0x40uLL, 0x100004000313F17uLL);
      }
      *(void *)(a1 + 16) = v38;
    }
    if (HIDWORD(v40) > *(_DWORD *)(a1 + 32)) {
      *(_DWORD *)(a1 + 32) = HIDWORD(v40);
    }
    if (v17) {
      memmove((void *)(*(void *)(a1 + 16) + 8 * v13 + 8), (const void *)(*(void *)(a1 + 16) + 8 * v13), 8 * (v39 - v13));
    }
    *(void *)(*(void *)(a1 + 16) + 8 * v13) = v40;
    ++*(_DWORD *)(a1 + 24);
    return;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  unsigned int v15 = v2;
  uint64_t v16 = (uint64_t *)&v40;
  BOOL v17 = 1;
  while (1)
  {
    uint64_t v18 = (unsigned int *)(*(void *)(a1 + 16) + v12);
    unsigned int v19 = *((unsigned __int16 *)v18 + 1);
    unsigned int v20 = v18[1];
    int v21 = *((unsigned __int16 *)v16 + 1);
    int v22 = *((_DWORD *)v16 + 1);
    uint64_t v23 = v18;
    if (v20 + v19 == v21 || (uint64_t v23 = (unsigned int *)v16, v22 + v21 == v19))
    {
      uint64_t v24 = *v23;
      if (v14 == 1)
      {
        __RemoveFromFreeList((_DWORD *)a1, v13);
        uint64_t v18 = (unsigned int *)v16;
      }
      uint64_t v25 = v22 + v20;
      *(void *)uint64_t v18 = v24 | (v25 << 32);
      if (v25 + WORD1(v24) > *(_DWORD *)(a1 + 8))
      {
        uint64_t v26 = scn_default_log();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          __AddToFreeList_cold_2(buf, v42, v26);
        }
      }
      unsigned int v27 = v18[1];
      if (v27 > *(_DWORD *)(a1 + 32)) {
        *(_DWORD *)(a1 + 32) = v27;
      }
      if (++v14 == 2) {
        return;
      }
      unsigned int v19 = *((unsigned __int16 *)v18 + 1);
      unsigned int v15 = WORD1(v40);
      uint64_t v16 = (uint64_t *)v18;
    }
    if (v19 > v15) {
      break;
    }
    BOOL v17 = ++v13 < v39;
    v12 += 8;
    if (v39 == v13)
    {
      uint64_t v13 = v39;
      break;
    }
  }
  if (!v14) {
    goto LABEL_22;
  }
}

void _C3DAllocatorCFFinalize(uint64_t a1)
{
  C3DAllocatorFree(a1);
  unsigned __int16 v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 40) = 0;
  }
}

void C3DAllocatorFree(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int16 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAllocatorNew_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(uint64_t *)(a1 + 48) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(a1 + 32);
      free(*(void **)(v12 + v10));
      *(void *)(v12 + v10) = 0;
      ++v11;
      v10 += 16;
    }
    while (v11 < *(void *)(a1 + 48));
  }
  free(*(void **)(a1 + 32));
  *(void *)(a1 + 32) = 0;
  C3DIndexSetRemoveAllIndexes(*(void *)(a1 + 40));
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
}

uint64_t C3DWarmupSceneVRAMResourcesForEngineContext(const void *a1, __n128 *a2, uint64_t a3)
{
  uint64_t Scene = C3DEngineContextGetScene((uint64_t)a2);
  if ((const void *)Scene != a1) {
    C3DEngineContextSetScene((uint64_t)a2, a1);
  }
  C3DEngineContextSetupForWarmUp((uint64_t)a2, a3);
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline((uint64_t)a1);
  if (!EnginePipeline)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DWarmupSceneVRAMResourcesForEngineContext_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  v20[0] = EnginePipeline;
  v20[1] = (uint64_t)a2;
  long long v21 = 0u;
  long long v22 = 0u;
  C3DEnginePipelineApplyNotificationQueue(v20);
  C3DEngineContextApplyModifiers((uint64_t)a2, EnginePipeline);
  uint64_t RenderContext = C3DEngineContextGetRenderContext((uint64_t)a2);
  if (RenderContext)
  {
    uint64_t v17 = RenderContext;
    C3DEngineContextRenderWithRenderGraph((uint64_t)a2);
    uint64_t v18 = -[SCNMTLRenderContext resourceManager](v17);
    [(id)-[SCNMTLResourceManager libraryManager](v18) waitForShadersCompilation];
  }
  else
  {
    C3DEngineContextRenderMainTechnique(a2);
  }
  if ((const void *)Scene != a1) {
    C3DEngineContextSetScene((uint64_t)a2, 0);
  }
  C3DEngineContextUnSetupForWarmUp((uint64_t)a2);
  return 1;
}

void C3DEngineContextSetScene(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(const void **)(a1 + 16) != a2)
  {
    uint64_t FXContext = C3DEngineContextGetFXContext(a1);
    if (*(void *)(a1 + 16))
    {
      C3DEngineContextSetPointOfView(a1, 0);
      if (FXContext) {
        C3DFXContextSceneWillChange(FXContext);
      }
      C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
      C3DSceneUnregisterEngineContext(*(void *)(a1 + 16), a1);
    }
    C3DProgramHashCodeStoreClear(*(void *)(a1 + 176));
    C3DSortSystemInvalidate(*(void *)(a1 + 184));
    uint64_t v13 = *(const void **)(a1 + 16);
    if (v13 != a2)
    {
      if (v13)
      {
        CFRelease(v13);
        *(void *)(a1 + 16) = 0;
      }
      if (a2) {
        CFTypeRef v14 = CFRetain(a2);
      }
      else {
        CFTypeRef v14 = 0;
      }
      *(void *)(a1 + 16) = v14;
    }
    if (a2)
    {
      C3DSceneRegisterEngineContext((uint64_t)a2, a1);
      if (FXContext) {
        C3DFXContextSceneDidChange(FXContext, a1);
      }
      C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
    }
    C3DEngineContextSetDefaultPointOfView(a1, 0);
    C3DAudioManagerUpdateEngineContext((__C3DEngineContext *)a1);
  }
}

uint64_t C3DEngineContextGetFXContext(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int16 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 160);
}

uint64_t CPP3DAudioEngine::RemoveContext(CPP3DAudioEngine *this, __C3DEngineContext *a2)
{
  unint64_t Scene = C3DEngineContextGetScene((uint64_t)a2);
  [*((id *)this + 1) lock];
  if (Scene)
  {
    uint64_t v5 = (void *)*((void *)this + 3);
    if (v5)
    {
      uint64_t v6 = (char *)this + 24;
      do
      {
        unint64_t v7 = v5[4];
        BOOL v8 = v7 >= Scene;
        if (v7 >= Scene) {
          uint64_t v9 = v5;
        }
        else {
          uint64_t v9 = v5 + 1;
        }
        if (v8) {
          uint64_t v6 = (char *)v5;
        }
        uint64_t v5 = (void *)*v9;
      }
      while (*v9);
      if (v6 != (char *)this + 24 && Scene >= *((void *)v6 + 4))
      {
        uint64_t v10 = (void *)*((void *)v6 + 6);
        if (v10)
        {
          uint64_t v11 = (uint64_t *)(v6 + 48);
          do
          {
            unint64_t v12 = v10[4];
            BOOL v13 = v12 >= (unint64_t)a2;
            if (v12 >= (unint64_t)a2) {
              CFTypeRef v14 = v10;
            }
            else {
              CFTypeRef v14 = v10 + 1;
            }
            if (v13) {
              uint64_t v11 = v10;
            }
            uint64_t v10 = (void *)*v14;
          }
          while (*v14);
          if (v11 != (uint64_t *)(v6 + 48) && v11[4] <= (unint64_t)a2)
          {
            uint64_t v15 = (id *)v11[5];
            if (v15)
            {
              CPP3DAudioContext::~CPP3DAudioContext(v15);
              MEMORY[0x210534FE0]();
            }
            std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer((uint64_t **)v6 + 5, v11);
            operator delete(v11);
          }
        }
        if (!*((void *)v6 + 7)) {
          std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::erase((uint64_t **)this + 2, (uint64_t)v6);
        }
      }
    }
  }
  else
  {
    uint64_t v16 = *((void *)this + 2);
    if ((CPP3DAudioEngine *)v16 != (CPP3DAudioEngine *)((char *)this + 24))
    {
      do
      {
        uint64_t v17 = *(void **)(v16 + 48);
        if (v17)
        {
          uint64_t v18 = (uint64_t *)(v16 + 48);
          do
          {
            unint64_t v19 = v17[4];
            BOOL v20 = v19 >= (unint64_t)a2;
            if (v19 >= (unint64_t)a2) {
              long long v21 = v17;
            }
            else {
              long long v21 = v17 + 1;
            }
            if (v20) {
              uint64_t v18 = v17;
            }
            uint64_t v17 = (void *)*v21;
          }
          while (*v21);
          if (v18 != (uint64_t *)(v16 + 48) && v18[4] <= (unint64_t)a2)
          {
            long long v22 = (id *)v18[5];
            if (v22)
            {
              CPP3DAudioContext::~CPP3DAudioContext(v22);
              MEMORY[0x210534FE0]();
            }
            std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer((uint64_t **)(v16 + 40), v18);
            operator delete(v18);
          }
        }
        if (*(void *)(v16 + 56))
        {
          uint64_t v23 = *(CPP3DAudioEngine **)(v16 + 8);
          if (v23)
          {
            do
            {
              uint64_t v24 = v23;
              uint64_t v23 = *(CPP3DAudioEngine **)v23;
            }
            while (v23);
          }
          else
          {
            do
            {
              uint64_t v24 = *(CPP3DAudioEngine **)(v16 + 16);
              BOOL v25 = *(void *)v24 == v16;
              uint64_t v16 = (uint64_t)v24;
            }
            while (!v25);
          }
        }
        else
        {
          uint64_t v24 = (CPP3DAudioEngine *)std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::erase((uint64_t **)this + 2, v16);
        }
        uint64_t v16 = (uint64_t)v24;
      }
      while (v24 != (CPP3DAudioEngine *)((char *)this + 24));
    }
  }
  uint64_t v26 = (void *)*((void *)this + 1);

  return [v26 unlock];
}

void C3DProgramHashCodeStoreClear(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::enumerate(a1 + 16, (uint64_t)&__block_literal_global_5_0);
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::clear(v2);
  C3DIndexStoreRemoveAllIndexes(*(void *)(a1 + 48));
  *(_DWORD *)(a1 + 56) = 0;
}

void C3DIndexStoreRemoveAllIndexes(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DIndexStoreGetIndexForKey_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  C3DIndexSetRemoveAllIndexes(*(void *)(a1 + 24));
  C3DIndexSetAddIndexesInRange(*(void *)(a1 + 24), 0, *(void *)(a1 + 40));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 16));
}

void C3DIndexSetRemoveAllIndexes(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 16);
  if ((v2 & 2) == 0)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      char v2 = *(unsigned char *)(a1 + 16);
    }
    *(void *)(a1 + 24) = 0;
  }
  *(unsigned char *)(a1 + 16) = v2 | 3;
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::enumerate(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 28);
  if (v2 != -15)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if (*(_WORD *)(*(void *)(v4 + 16) + 2 * v6))
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a2 + 16))(a2, *(void *)(*(void *)v4 + 8 * v6), *(void *)(v4 + 8) + v5);
        int v2 = *(_DWORD *)(v4 + 28);
      }
      ++v6;
      v5 += 8;
    }
    while (v6 < (v2 + 15));
  }
  return result;
}

void C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::clear(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
}

void C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_destroy_values(CFTypeRef *a1, __int16 *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      __int16 v6 = *a2++;
      if (v6)
      {
        if (*a1) {
          CFRelease(*a1);
        }
      }
      ++a1;
      --v5;
    }
    while (v5);
  }
}

uint64_t C3DAudioManagerRemoveEngineContext(__C3DEngineContext *a1)
{
  if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1) {
    dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
  }
  int v2 = (CPP3DAudioEngine *)gCPP3DAudioEngineInstance;

  return CPP3DAudioEngine::RemoveContext(v2, a1);
}

unint64_t CPP3DAudioEngine::GetContext(id *this, __C3DEngineContext *a2)
{
  unint64_t Scene = C3DEngineContextGetScene((uint64_t)a2);
  if (Scene)
  {
    objc_msgSend(this[1], "lock", Scene, a2);
    uint64_t v5 = this[3];
    if (!v5) {
      goto LABEL_24;
    }
    __int16 v6 = this + 3;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= Scene;
      if (v7 >= Scene) {
        uint64_t v9 = v5;
      }
      else {
        uint64_t v9 = v5 + 1;
      }
      if (v8) {
        __int16 v6 = (id *)v5;
      }
      uint64_t v5 = (void *)*v9;
    }
    while (*v9);
    if (v6 == this + 3) {
      goto LABEL_24;
    }
    if (Scene < (unint64_t)v6[4]) {
      goto LABEL_24;
    }
    unint64_t v12 = v6[6];
    uint64_t v10 = v6 + 6;
    uint64_t v11 = v12;
    if (!v12) {
      goto LABEL_24;
    }
    BOOL v13 = v10;
    do
    {
      unint64_t v14 = v11[4];
      BOOL v15 = v14 >= (unint64_t)a2;
      if (v14 >= (unint64_t)a2) {
        uint64_t v16 = v11;
      }
      else {
        uint64_t v16 = v11 + 1;
      }
      if (v15) {
        BOOL v13 = v11;
      }
      uint64_t v11 = (void *)*v16;
    }
    while (*v16);
    if (v13 == v10 || v13[4] > (unint64_t)a2) {
LABEL_24:
    }
      operator new();
    unint64_t Scene = v13[5];
    [this[1] unlock];
  }
  return Scene;
}

uint64_t C3DSortSystemInvalidate(uint64_t result)
{
  *(unsigned char *)(result + 40) = 1;
  return result;
}

unint64_t C3DAudioManagerUpdateEngineContext(__C3DEngineContext *a1)
{
  if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1) {
    dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
  }
  int v2 = (id *)gCPP3DAudioEngineInstance;

  return CPP3DAudioEngine::GetContext(v2, a1);
}

uint64_t *std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__emplace_unique_key_args<__C3DMesh *,std::piecewise_construct_t const&,std::tuple<__C3DMesh * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  __int16 v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        __int16 v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      __int16 v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::__emplace_unique_key_args<__C3DScene *,std::piecewise_construct_t const&,std::tuple<__C3DScene * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  __int16 v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        __int16 v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      __int16 v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[7] = 0;
    v11[6] = 0;
    v11[4] = v12;
    v11[5] = (uint64_t)(v11 + 6);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t C3DSceneRegisterEngineContext(uint64_t a1, uint64_t a2)
{
  C3DSceneLock(a1);
  int v4 = *(unsigned __int16 *)(a1 + 168);
  if (v4 == 1)
  {
    uint64_t v5 = *(void *)(a1 + 160);
    __int16 v6 = malloc_type_malloc(0x10uLL, 0x2004093837F09uLL);
    *(void *)(a1 + 160) = v6;
    *__int16 v6 = v5;
    *(void *)(*(void *)(a1 + 160) + 8) = a2;
    *(_WORD *)(a1 + 168) = 2;
  }
  else if (*(_WORD *)(a1 + 168))
  {
    unsigned __int16 v7 = v4 + 1;
    *(_WORD *)(a1 + 168) = v7;
    unint64_t v8 = malloc_type_realloc(*(void **)(a1 + 160), 8 * v7, 0x2004093837F09uLL);
    *(void *)(a1 + 160) = v8;
    v8[*(unsigned __int16 *)(a1 + 168) - 1] = a2;
  }
  else
  {
    *(_WORD *)(a1 + 168) = 1;
    *(void *)(a1 + 160) = a2;
  }

  return C3DSceneUnlock(a1);
}

void C3DFXContextSceneDidChange(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t Scene = C3DEngineContextGetScene(a2);
    if (Scene)
    {
      uint64_t v4 = Scene;
      uint64_t v5 = *(uint64_t **)(a1 + 24);
      C3DAddSceneRef(v5, v4);
    }
  }
}

uint64_t C3DMetalFramebufferPixelFormat(char a1)
{
  int IsEnabled = C3DLinearRenderingIsEnabled();
  if ((a1 & 0x20) != 0) {
    int v3 = 0;
  }
  else {
    int v3 = IsEnabled;
  }
  uint64_t v4 = 80;
  if (v3) {
    uint64_t v4 = 81;
  }
  uint64_t v5 = 554;
  if (v3) {
    uint64_t v5 = 555;
  }
  BOOL v6 = v3 == 0;
  uint64_t v7 = 80;
  if (!v6) {
    uint64_t v7 = 81;
  }
  uint64_t v8 = 550;
  if (!v6) {
    uint64_t v8 = 551;
  }
  if ((a1 & 8) == 0) {
    uint64_t v7 = v8;
  }
  if ((a1 & 0x10) == 0) {
    uint64_t v7 = v5;
  }
  if (a1) {
    return v7;
  }
  else {
    return v4;
  }
}

float C3DEngineContextSetPointOfView(uint64_t a1, float32x4_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float result = C3DEngineContextSetDefaultPointOfView(a1, 0);
  if (a2)
  {
    CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)a2);
    if (Camera) {
      *((unsigned char *)Camera + 312) &= ~1u;
    }
  }
  unint64_t v14 = *(float32x4_t **)(a1 + 24);
  if (v14 != a2)
  {
    if (v14)
    {
      CFRelease(v14);
      *(void *)(a1 + 24) = 0;
    }
    if (a2) {
      CFTypeRef v15 = CFRetain(a2);
    }
    else {
      CFTypeRef v15 = 0;
    }
    *(void *)(a1 + 24) = v15;
  }
  if (a2)
  {
    v18.i32[2] = 0;
    v18.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(a2);
    C3DMatrix4x4GetScale(WorldMatrix, &v18);
    float32x4_t v17 = vabsq_f32(v18);
    float result = 1.0 / fmaxf(fmaxf(v17.f32[0], v17.f32[2]), v17.f32[1]);
    *(float *)(a1 + 200) = result;
  }
  return result;
}

float C3DEngineContextSetDefaultPointOfView(uint64_t a1, float32x4_t *cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL v13 = *(float32x4_t **)(a1 + 40);
  if (v13 != cf)
  {
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 40) = 0;
    }
    if (cf) {
      CFTypeRef v14 = CFRetain(cf);
    }
    else {
      CFTypeRef v14 = 0;
    }
    *(void *)(a1 + 40) = v14;
  }
  if (cf)
  {
    v17.i32[2] = 0;
    v17.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(cf);
    C3DMatrix4x4GetScale(WorldMatrix, &v17);
    float32x4_t v16 = vabsq_f32(v17);
    float result = 1.0 / fmaxf(fmaxf(v16.f32[0], v16.f32[2]), v16.f32[1]);
    *(float *)(a1 + 200) = result;
  }
  return result;
}

void C3DNodeSetQuaternion(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetQuaternion((uint64_t)&a1[6], a2);

  __C3DNodeTransformDidChange(a1);
}

void C3DTransformSetQuaternion(uint64_t a1, __n128 a2)
{
  int v3 = *(_DWORD *)(a1 + 92);
  if ((v3 & 4) == 0)
  {
    __n128 v4 = a2;
    _updateAffineScale((float32x4_t *)a1);
    a2 = v4;
    int v3 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v3 & 0xFFFFFFF4;
  *(__n128 *)(a1 + 64) = a2;
}

void _updateAffineScale(float32x4_t *a1)
{
  if ((a1[5].i8[12] & 8) == 0)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _updateAffineScale_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((a1[5].i8[12] & 4) != 0)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _updateAffineScale_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  C3DMatrix4x4GetScale(a1, a1 + 5);
  a1[5].i32[3] |= 4u;
}

float32x4_t C3DMatrix4x4GetScale(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2 = a1[1];
  float32x4_t v3 = a1[2];
  int32x4_t v4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), vnegq_f32(v2)), v3, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL));
  float32x4_t v5 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), *a1);
  BOOL v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0] < 0.0;
  float v7 = 1.0;
  if (v6) {
    float v7 = -1.0;
  }
  float32x4_t v8 = vmulq_f32(*a1, *a1);
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  v9.f32[0] = sqrtf(v9.f32[0]);
  float32x4_t v10 = vmulq_f32(v2, v2);
  float32x4_t v11 = vmulq_f32(v3, v3);
  v9.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  v9.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  float32x4_t result = vmulq_n_f32(v9, v7);
  *a2 = result;
  return result;
}

void __C3DProgramHashCodeStoreClear_block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t *std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  float32x4_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      float32x4_t v3 = v2;
      float32x4_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    int32x4_t v4 = a2;
    do
    {
      float32x4_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      int32x4_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  float32x4_t v3 = a2;
  if (*a2)
  {
    int32x4_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      float32x4_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      float32x4_t v3 = v4;
      int32x4_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  float v7 = *v6;
  if (*v6 == v3)
  {
    *BOOL v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      float v7 = 0;
      float32x4_t result = (uint64_t *)v2;
    }
    else
    {
      float v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    void v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *float32x4_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      float32x4_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *uint64_t v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        float32x4_t result = v7;
      }
      float v7 = *(uint64_t **)(*v7 + 8);
    }
    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        uint64_t *v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        uint64_t v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    float v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      float32x4_t result = v7;
    }
    float v7 = *(uint64_t **)v12;
  }
  unint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  BOOL v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    BOOL v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    uint64_t v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *BOOL v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    unint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void CPP3DAudioContext::~CPP3DAudioContext(id *this)
{
  [this[2] reset];
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "disconnectNodeInput:", this[2]);
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "disconnectNodeOutput:", this[2]);
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "detachNode:", this[2]);

  uint64_t v2 = (CPP3DAudioContext *)this[4];
  if (v2 != (CPP3DAudioContext *)(this + 5))
  {
    do
    {
      float32x4_t v3 = (const void *)*((void *)v2 + 4);
      if (v3) {
        CFRelease(v3);
      }
      int32x4_t v4 = (CPP3DAudioContext *)*((void *)v2 + 1);
      if (v4)
      {
        do
        {
          int v5 = v4;
          int32x4_t v4 = *(CPP3DAudioContext **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          int v5 = (CPP3DAudioContext *)*((void *)v2 + 2);
          BOOL v6 = *(void *)v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != (CPP3DAudioContext *)(this + 5));
  }
  std::__tree<char>::destroy((uint64_t)(this + 4), this[5]);
}

void sub_20B262AAC(_Unwind_Exception *a1)
{
  std::__tree<char>::destroy(v1 + 32, *(void **)(v1 + 40));
  _Unwind_Resume(a1);
}

void ShaderConverter::Parse(char **this)
{
  uint64_t v2 = (char *)(this + 23);
  std::__tree<std::string>::destroy((uint64_t)(this + 22), this[23]);
  this[22] = v2;
  *(void *)uint64_t v2 = 0;
  float32x4_t v3 = this[26];
  this[24] = 0;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)(this + 25), v3);
  this[25] = (char *)(this + 26);
  this[26] = 0;
  this[27] = 0;
  this[10] = 0;
  if (!this[9]) {
    operator new();
  }
  ShaderConverter::Parse();
}

void sub_20B262FD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void ShaderConverter::NextToken(ShaderConverter *this)
{
  Token = (long long *)Tokenizer::NextToken(*((Tokenizer **)this + 9));
  long long v3 = *Token;
  *(_OWORD *)((char *)this + 52) = *(long long *)((char *)Token + 12);
  *(_OWORD *)((char *)this + 40) = v3;
  if (*((_DWORD *)this + 16) != 1) {
    return;
  }
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v18.__r_.__value_.__l.__size_ != 2) {
      goto LABEL_8;
    }
    int32x4_t v4 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) != 2) {
      goto LABEL_8;
    }
    int32x4_t v4 = &v18;
  }
  if (LOWORD(v4->__r_.__value_.__l.__data_) == 28265)
  {
    char v6 = 1;
    goto LABEL_21;
  }
LABEL_8:
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 3)
    {
      BOOL v7 = 0;
LABEL_25:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_26;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 3)
    {
      BOOL v7 = 0;
      goto LABEL_26;
    }
    p_p = &__p;
  }
  char v6 = 0;
  BOOL v7 = 0;
  int data_low = LOWORD(p_p->__r_.__value_.__l.__data_);
  int v9 = p_p->__r_.__value_.__s.__data_[2];
  if (data_low == 30063 && v9 == 116)
  {
LABEL_21:
    BOOL v7 = Tokenizer::GetNextChar(*((Tokenizer **)this + 9)) == 46;
    if ((v6 & 1) != 0 || (*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
    goto LABEL_25;
  }
LABEL_26:
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (v7)
    {
LABEL_37:
      ++*((_DWORD *)this + 20);
      return;
    }
  }
  else if (v7)
  {
    goto LABEL_37;
  }
  uint64_t v11 = ShaderConverter::mpStatics + 24;
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  uint64_t v12 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v11, (const void **)&v18.__r_.__value_.__l.__data_);
  uint64_t v13 = ShaderConverter::mpStatics + 32;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (v13 != v12) {
    ++*((_DWORD *)this + 21);
  }
  uint64_t v14 = ShaderConverter::mpStatics;
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  uint64_t v15 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v14, (const void **)&v18.__r_.__value_.__l.__data_);
  uint64_t v16 = ShaderConverter::mpStatics + 8;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (v16 != v15) {
    goto LABEL_37;
  }
}

void sub_20B263228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if ((v20 & 1) == 0 && a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Tokenizer::NextToken(Tokenizer *this)
{
  *((_DWORD *)this + 14) = 0;
  unint64_t v3 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  if (v2 >= v3)
  {
    uint64_t v8 = *((void *)this + 3);
    *((void *)this + 4) = *(void *)this;
    *((void *)this + 5) = v2;
    *((void *)this + 6) = v8 + ~v2;
    unint64_t v9 = v8 - 1;
LABEL_119:
    *((void *)this + 2) = v9;
    return (uint64_t)this + 32;
  }
  int v4 = *((char *)this + 65);
  if (v4 == 10)
  {
    unint64_t v5 = *((void *)this + 3);
    *((unsigned char *)this + 64) = 10;
    if (v5 >= v3)
    {
      int v7 = 0;
    }
    else
    {
      char v6 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        char v6 = (void *)*v6;
      }
      int v7 = *((unsigned __int8 *)v6 + v5);
    }
    *((unsigned char *)this + 65) = v7;
    *((void *)this + 3) = v5 + 1;
    ++*((_DWORD *)this + 18);
    if (v7 == 10) {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    *((void *)this + 4) = *(void *)this;
    *((void *)this + 5) = v2;
    *((void *)this + 6) = v5 - v2;
    *((_DWORD *)this + 14) = 17;
    *((void *)this + 2) = v5;
    return (uint64_t)this + 32;
  }
  if (v4 <= 32)
  {
    unint64_t v10 = *((void *)this + 3);
    do
    {
      if ((char)v4 > 32 || v4 == 10) {
        break;
      }
      *((unsigned char *)this + 64) = v4;
      if (v10 >= v3)
      {
        int v4 = 0;
      }
      else
      {
        uint64_t v12 = *(void **)this;
        if (*(char *)(*(void *)this + 23) < 0) {
          uint64_t v12 = (void *)*v12;
        }
        int v4 = *((unsigned __int8 *)v12 + v10);
      }
      *((unsigned char *)this + 65) = v4;
      *((void *)this + 3) = ++v10;
      ++*((_DWORD *)this + 18);
      if (v4 == 10) {
        *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      }
    }
    while (v10 < v3);
    if (v2 + 1 < v10)
    {
      *((void *)this + 4) = *(void *)this;
      *((void *)this + 5) = v2;
      *((void *)this + 6) = v10 + ~v2;
      *((_DWORD *)this + 14) = 13;
      unint64_t v9 = v10 - 1;
      goto LABEL_119;
    }
  }
  if (v4 <= 0x3Au)
  {
    switch((char)v4)
    {
      case '#':
        Tokenizer::NextChar(this);
        uint64_t v14 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v14;
        *((void *)this + 6) = v13 + ~v14;
        int v15 = 16;
        goto LABEL_117;
      case '(':
        Tokenizer::NextChar(this);
        uint64_t v18 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v18;
        *((void *)this + 6) = v13 + ~v18;
        int v15 = 6;
        goto LABEL_117;
      case ')':
        Tokenizer::NextChar(this);
        uint64_t v19 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v19;
        *((void *)this + 6) = v13 + ~v19;
        int v15 = 7;
        goto LABEL_117;
      case ',':
        Tokenizer::NextChar(this);
        uint64_t v20 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v20;
        *((void *)this + 6) = v13 + ~v20;
        int v15 = 14;
        goto LABEL_117;
      case '.':
        BOOL v21 = *(void **)this;
        if (*(char *)(*(void *)this + 23) < 0) {
          BOOL v21 = (void *)*v21;
        }
        unsigned int v22 = *((char *)v21 + *((void *)this + 3));
        if ((v22 & 0x80000000) != 0) {
          int v23 = __maskrune(v22, 0x400uLL);
        }
        else {
          int v23 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v22 + 60) & 0x400;
        }
        if (v23) {
          goto LABEL_53;
        }
        goto LABEL_116;
      default:
        goto LABEL_49;
    }
  }
  if (v4 <= 0x5Cu)
  {
    if (v4 == 59)
    {
      Tokenizer::NextChar(this);
      uint64_t v26 = *((void *)this + 2);
      uint64_t v13 = *((void *)this + 3);
      *((void *)this + 4) = *(void *)this;
      *((void *)this + 5) = v26;
      *((void *)this + 6) = v13 + ~v26;
      int v15 = 15;
      goto LABEL_117;
    }
    if (v4 == 91)
    {
      Tokenizer::NextChar(this);
      uint64_t v17 = *((void *)this + 2);
      uint64_t v13 = *((void *)this + 3);
      *((void *)this + 4) = *(void *)this;
      *((void *)this + 5) = v17;
      *((void *)this + 6) = v13 + ~v17;
      int v15 = 10;
      goto LABEL_117;
    }
  }
  else
  {
    switch(v4)
    {
      case ']':
        Tokenizer::NextChar(this);
        uint64_t v24 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v24;
        *((void *)this + 6) = v13 + ~v24;
        int v15 = 11;
        goto LABEL_117;
      case '{':
        Tokenizer::NextChar(this);
        uint64_t v25 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v25;
        *((void *)this + 6) = v13 + ~v25;
        int v15 = 8;
        goto LABEL_117;
      case '}':
        Tokenizer::NextChar(this);
        uint64_t v16 = *((void *)this + 2);
        uint64_t v13 = *((void *)this + 3);
        *((void *)this + 4) = *(void *)this;
        *((void *)this + 5) = v16;
        *((void *)this + 6) = v13 + ~v16;
        int v15 = 9;
LABEL_117:
        *((_DWORD *)this + 14) = v15;
        goto LABEL_118;
    }
  }
LABEL_49:
  if ((char)v4 < 0) {
    int v27 = __maskrune((char)v4, 0x100uLL);
  }
  else {
    int v27 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * (char)v4 + 60) & 0x100;
  }
  if (v27 || (unsigned int v29 = *((char *)this + 65), v29 == 95))
  {
    return Tokenizer::ParseSymbol(this);
  }
  if ((v29 & 0x80000000) != 0) {
    int v30 = __maskrune(v29, 0x400uLL);
  }
  else {
    int v30 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v29 + 60) & 0x400;
  }
  if (v30)
  {
LABEL_53:
    return Tokenizer::ParseNumber(this);
  }
  unsigned int v31 = *((unsigned __int8 *)this + 65);
  if (v31 <= 0x2E)
  {
    if (*((unsigned __int8 *)this + 65) <= 0x29u)
    {
      if (v31 - 37 >= 2)
      {
        if (v31 == 34)
        {
          Tokenizer::ParseString(this);
LABEL_115:
          uint64_t v43 = *((void *)this + 2);
          uint64_t v13 = *((void *)this + 3);
          *((void *)this + 4) = *(void *)this;
          *((void *)this + 5) = v43;
          *((void *)this + 6) = v13 + ~v43;
          *((_DWORD *)this + 14) = 0;
LABEL_118:
          unint64_t v9 = v13 - 1;
          goto LABEL_119;
        }
        goto LABEL_105;
      }
      goto LABEL_86;
    }
    if (v31 - 42 >= 2 && v31 != 45)
    {
LABEL_105:
      BOOL v38 = (char **)*((void *)this + 11);
      if (!v38) {
        goto LABEL_115;
      }
      unint64_t v39 = (char **)((char *)this + 88);
      do
      {
        int v40 = *((char *)v38 + 25);
        BOOL v41 = v40 < (char)v31;
        if (v40 >= (char)v31) {
          CFTypeRef v42 = v38;
        }
        else {
          CFTypeRef v42 = v38 + 1;
        }
        if (!v41) {
          unint64_t v39 = v38;
        }
        BOOL v38 = (char **)*v42;
      }
      while (*v42);
      if (v39 == (char **)((char *)this + 88) || (char)v31 < *((char *)v39 + 25)) {
        goto LABEL_115;
      }
LABEL_116:
      Tokenizer::NextChar(this);
      uint64_t v44 = *((void *)this + 2);
      uint64_t v13 = *((void *)this + 3);
      *((void *)this + 4) = *(void *)this;
      *((void *)this + 5) = v44;
      *((void *)this + 6) = v13 + ~v44;
      int v15 = 4;
      goto LABEL_117;
    }
LABEL_86:
    if (*((void *)this + 2) >= *((void *)this + 1)) {
      goto LABEL_116;
    }
    uint64_t v33 = *(uint64_t **)this;
    uint64_t v34 = *((void *)this + 3);
    goto LABEL_88;
  }
  if (*((unsigned __int8 *)this + 65) > 0x3Du)
  {
    if (v31 != 62)
    {
      if (v31 != 94 && v31 != 124) {
        goto LABEL_105;
      }
      goto LABEL_86;
    }
LABEL_93:
    if (*((void *)this + 2) < *((void *)this + 1))
    {
      uint64_t v36 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v36 = (void *)*v36;
      }
      if (*((unsigned char *)v36 + *((void *)this + 3)) == 61) {
        Tokenizer::NextChar(this);
      }
    }
    goto LABEL_116;
  }
  if (v31 != 47)
  {
    if (v31 != 60)
    {
      if (v31 == 61)
      {
        if (*((void *)this + 2) < *((void *)this + 1))
        {
          uint64_t v32 = *(void **)this;
          if (*(char *)(*(void *)this + 23) < 0) {
            uint64_t v32 = (void *)*v32;
          }
          if (*((unsigned char *)v32 + *((void *)this + 3)) == 61) {
            goto LABEL_116;
          }
        }
        goto LABEL_92;
      }
      goto LABEL_105;
    }
    goto LABEL_93;
  }
  if (*((void *)this + 2) >= *((void *)this + 1)) {
    goto LABEL_116;
  }
  uint64_t v33 = *(uint64_t **)this;
  uint64_t v34 = *((void *)this + 3);
  uint64_t v37 = *(uint64_t **)this;
  if (*(char *)(*(void *)this + 23) < 0) {
    uint64_t v37 = (uint64_t *)*v33;
  }
  if (*((unsigned char *)v37 + v34) == 47)
  {
    return Tokenizer::ParseLineComment(this);
  }
  else
  {
    int v45 = *(uint64_t **)this;
    if (*((char *)v33 + 23) < 0) {
      int v45 = (uint64_t *)*v33;
    }
    if (*((unsigned char *)v45 + v34) != 42)
    {
LABEL_88:
      if (*((char *)v33 + 23) < 0) {
        uint64_t v33 = (uint64_t *)*v33;
      }
      if (*((unsigned char *)v33 + v34) != 61) {
        goto LABEL_116;
      }
      Tokenizer::NextChar(this);
LABEL_92:
      Tokenizer::NextChar(this);
      uint64_t v35 = *((void *)this + 2);
      uint64_t v13 = *((void *)this + 3);
      *((void *)this + 4) = *(void *)this;
      *((void *)this + 5) = v35;
      *((void *)this + 6) = v13 + ~v35;
      int v15 = 5;
      goto LABEL_117;
    }
    return Tokenizer::ParseMultiLineComment(this);
  }
}

void Statement::AddToken(Statement *this, const Token *a2)
{
}

void sub_20B263998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x210534FE0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

std::string *Token::str@<X0>(Token *this@<X0>, std::string *a2@<X8>)
{
  if (!*(void *)this) {
    Token::str();
  }
  return std::string::basic_string(a2, *(const std::string **)this, *((void *)this + 1), *((void *)this + 2), (std::allocator<char> *)&v3);
}

void Statement::AddStatement(Statement *this, Statement *a2)
{
  if (a2)
  {
    unint64_t v6 = *((void *)this + 3);
    int v4 = (char *)this + 24;
    unint64_t v5 = v6;
    int v7 = (void *)*((void *)v4 - 1);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = *((void *)this + 1);
      uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v5 - v9;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)v4, v13);
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      uint64_t v16 = &v14[8 * v13];
      *(void *)uint64_t v15 = a2;
      uint64_t v8 = v15 + 8;
      uint64_t v18 = (char *)*((void *)this + 1);
      uint64_t v17 = (char *)*((void *)this + 2);
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        uint64_t v17 = (char *)*((void *)this + 1);
      }
      *((void *)this + 1) = v15;
      *((void *)this + 2) = v8;
      *((void *)this + 3) = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      void *v7 = a2;
      uint64_t v8 = v7 + 1;
    }
    *((void *)this + 2) = v8;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a2);
}

uint64_t TokenStatement::TokenStatement(uint64_t a1, long long *a2, int a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26BF69B68;
  unint64_t v5 = (std::string *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_DWORD *)(a1 + 56) = a3;
  return a1;
}

void sub_20B263BA0(_Unwind_Exception *a1)
{
  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

uint64_t Tokenizer::ParseLineComment(Tokenizer *this)
{
  int v1 = *((unsigned __int8 *)this + 65);
  while (v1 != 10)
  {
    unint64_t v3 = *((void *)this + 1);
    unint64_t v2 = *((void *)this + 2);
    unint64_t v4 = *((void *)this + 3);
    if (v2 < v3)
    {
      *((unsigned char *)this + 64) = v1;
      if (v4 >= v3)
      {
        int v1 = 0;
      }
      else
      {
        unint64_t v5 = *(void **)this;
        if (*(char *)(*(void *)this + 23) < 0) {
          unint64_t v5 = (void *)*v5;
        }
        int v1 = *((unsigned __int8 *)v5 + v4);
      }
      *((unsigned char *)this + 65) = v1;
      *((void *)this + 3) = ++v4;
      ++*((_DWORD *)this + 18);
      if (v1 == 10) {
        *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      }
      if (v4 < v3) {
        continue;
      }
    }
    goto LABEL_14;
  }
  unint64_t v2 = *((void *)this + 2);
  unint64_t v4 = *((void *)this + 3);
LABEL_14:
  *((void *)this + 4) = *(void *)this;
  *((void *)this + 5) = v2;
  uint64_t result = (uint64_t)this + 32;
  *(void *)(result + 16) = v4 + ~v2;
  *(_DWORD *)(result + 24) = 12;
  *(void *)(result - 16) = v4 - 1;
  return result;
}

uint64_t std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = std::less<std::string>::operator()[abi:nn180100](v5, (const void **)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:nn180100](v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

void std::__tree<std::string>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::string>::destroy(a1, *(void *)a2);
    std::__tree<std::string>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t Tokenizer::Tokenizer(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  uint64_t v3 = (uint64_t **)(a1 + 80);
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  *(void *)(a1 + 8) = v4;
  strcpy(v12, ".<>?:/|&^*/+-=%!~");
  uint64_t v5 = v12;
  do
    std::__tree<char>::__emplace_unique_key_args<char,char const&>(v3, v5, v5);
  while (*++v5);
  unint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) < v7)
  {
    unint64_t v8 = *(void *)(a1 + 24);
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 65);
    if (v8 >= v7)
    {
      int v10 = 0;
    }
    else
    {
      uint64_t v9 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      int v10 = *((unsigned __int8 *)v9 + v8);
    }
    *(unsigned char *)(a1 + 65) = v10;
    *(void *)(a1 + 24) = v8 + 1;
    ++*(_DWORD *)(a1 + 72);
    if (v10 == 10) {
      *(void *)(a1 + 68) = (*(_DWORD *)(a1 + 68) + 1);
    }
  }
  return a1;
}

uint64_t **std::__tree<char>::__emplace_unique_key_args<char,char const&>(uint64_t **a1, char *a2, unsigned char *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        int v9 = *((char *)v5 + 25);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x20uLL);
    *((unsigned char *)v10 + 25) = *a3;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void ___ZN15ShaderConverter10StaticInitEv_block_invoke()
{
  if (!ShaderConverter::mpStatics) {
    operator new();
  }
  CFDictionaryRef StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
  CFIndex Count = CFDictionaryGetCount(StandardUniforms);
  uint64_t v2 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  uint64_t v3 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues(StandardUniforms, v2, v3);
  if (Count >= 1)
  {
    uint64_t v4 = (id *)v2;
    uint64_t v5 = (void ***)v3;
    do
    {
      uint64_t v6 = **v5;
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)[*v4 UTF8String]);
      std::string::basic_string[abi:nn180100]<0>(&v8, (char *)[v6 UTF8String]);
      uint64_t v11 = __p;
      int v7 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(ShaderConverter::mpStatics + 96), (const void **)__p, (uint64_t)&std::piecewise_construct, (long long **)&v11);
      std::string::operator=((std::string *)(v7 + 7), &v8);
      if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v8.__r_.__value_.__l.__data_);
      }
      if (v10 < 0) {
        operator delete(__p[0]);
      }
      ++v5;
      ++v4;
      --Count;
    }
    while (Count);
  }
  free(v2);
  free(v3);
}

void sub_20B2642FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

_OWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    int v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *int v9 = 0;
    *((void *)v7 + 8) = 0;
    *((void *)v7 + 9) = 0;
    *((void *)v7 + 7) = 0;
    char v13 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v12, 0);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  size_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      size_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), size_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            int v9 = (uint64_t **)a2[2];
          }
          else
          {
            int v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *int v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        void v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *size_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, void *a2, const void **a3)
{
  size_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        int v8 = (void *)v4;
        int v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:nn180100](v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        size_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v7, v9, a3)) {
        break;
      }
      size_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    int v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL std::less<std::string>::operator()[abi:nn180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    int v6 = a2;
  }
  else {
    int v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    int v8 = a3;
  }
  else {
    int v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  int v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  size_t v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v11, v8, v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  size_t v7 = (std::string *)(v6 + 4);
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_20B264938(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

_OWORD *std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  std::string::size_type v6 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v12, a2);
  std::string::size_type v7 = *v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    std::string::size_type v7 = operator new(0x40uLL);
    long long v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *long long v9 = 0;
    *((void *)v7 + 7) = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t Tokenizer::ParseSymbol(Tokenizer *this)
{
  unint64_t v3 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  for (unint64_t i = *((void *)this + 3); ; unint64_t i = *((void *)this + 3))
  {
    if (v2 >= v3)
    {
      unint64_t v7 = i + ~v2;
      *((void *)this + 4) = *(void *)this;
      uint64_t result = (uint64_t)this + 32;
      goto LABEL_17;
    }
    *((unsigned char *)this + 64) = *((unsigned char *)this + 65);
    if (i >= v3)
    {
      int v6 = 0;
    }
    else
    {
      uint64_t v5 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v5 = (void *)*v5;
      }
      int v6 = *((unsigned __int8 *)v5 + i);
    }
    *((unsigned char *)this + 65) = v6;
    *((void *)this + 3) = i + 1;
    ++*((_DWORD *)this + 18);
    if (v6 == 10) {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    if ((v6 & 0x80) != 0)
    {
      if (__maskrune((char)v6, 0x500uLL))
      {
LABEL_12:
        unint64_t v2 = *((void *)this + 2);
        goto LABEL_15;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x263EF8318] + 4 * (char)v6 + 60) & 0x500) != 0)
    {
      goto LABEL_12;
    }
    unint64_t v2 = *((void *)this + 2);
    if (*((unsigned char *)this + 65) != 95) {
      break;
    }
LABEL_15:
    unint64_t v3 = *((void *)this + 1);
  }
  *((void *)this + 4) = *(void *)this;
  uint64_t result = (uint64_t)this + 32;
  unint64_t i = *((void *)this + 3);
  unint64_t v7 = i + ~v2;
LABEL_17:
  *((void *)this + 5) = v2;
  *((void *)this + 6) = v7;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 2) = i - 1;
  return result;
}

void Statement::~Statement(Statement *this)
{
  Statement::~Statement(this);

  JUMPOUT(0x210534FE0);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_26BF6C598;
  unint64_t v2 = (void *)*((void *)this + 1);
  unint64_t v3 = (void *)*((void *)this + 2);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    unint64_t v2 = (void *)*((void *)this + 1);
  }
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

void TokenStatement::~TokenStatement(void **this)
{
  *this = &unk_26BF69B68;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  Statement::~Statement((Statement *)this);

  JUMPOUT(0x210534FE0);
}

{
  uint64_t vars8;

  *this = &unk_26BF69B68;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  Statement::~Statement((Statement *)this);
}

uint64_t C3DSceneUnregisterEngineContext(uint64_t result, uint64_t a2)
{
  if (*(_WORD *)(result + 168))
  {
    uint64_t v3 = result;
    C3DSceneLock(result);
    int v4 = *(unsigned __int16 *)(v3 + 168);
    if (*(_WORD *)(v3 + 168))
    {
      if (v4 == 1)
      {
        if (*(void *)(v3 + 160) == a2)
        {
          *(_WORD *)(v3 + 168) = 0;
          *(void *)(v3 + 160) = 0;
        }
      }
      else
      {
        unint64_t v5 = 0;
        uint64_t v6 = 8;
        do
        {
          unint64_t v7 = *(char **)(v3 + 160);
          if (*(void *)&v7[8 * v5] == a2)
          {
            if ((unsigned __int16)v4 == 2)
            {
              uint64_t v8 = *(void *)&v7[v6];
              free(v7);
              *(void *)(v3 + 160) = v8;
              LOWORD(v4) = 1;
              *(_WORD *)(v3 + 168) = 1;
            }
            else
            {
              LOWORD(v4) = v4 - 1;
              *(_WORD *)(v3 + 168) = v4;
              *(void *)&v7[8 * v5] = *(void *)&v7[8 * (unsigned __int16)v4];
            }
          }
          ++v5;
          v6 -= 8;
        }
        while (v5 < (unsigned __int16)v4);
      }
    }
    return C3DSceneUnlock(v3);
  }
  return result;
}

void C3DFXContextSceneWillChange(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = C3DGetScene(*(void **)(a1 + 24));
    C3DRemoveSceneRef(v1, v2);
  }
}

void C3DEngineContextUnSetupForWarmUp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 461) = 0;
  *(void *)(a1 + 464) = 0;
}

void C3DEngineContextSetupForWarmUp(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 461) = 1;
  *(void *)(a1 + 464) = a2;
}

void C3DArrayApply(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetCount_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 24))
  {
    unint64_t v12 = 0;
    do
    {
      (*(void (**)(uint64_t, unint64_t, void))(a2 + 16))(a2, v12, *(void *)(a1 + 16) + (*(_DWORD *)(a1 + 32) * v12));
      ++v12;
    }
    while (v12 < *(unsigned int *)(a1 + 24));
  }
}

void C3DProgramHashCodeRelease(uint64_t a1)
{
  if (a1)
  {
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __C3DProgramHashCodeRelease_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = a1;
    dispatch_sync((dispatch_queue_t)s_ProgramHashCodeDictionaryQueue, block);
  }
}

void __C3DProgramHashCodeStoreClear_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void _commitImplicitTransaction(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  uint64_t Stack = C3DTransactionGetStack(v2);
  if (Stack && (uint64_t v4 = Stack, *(void *)(Stack + 24) == a1))
  {
    int v5 = pthread_main_np();
    uint64_t v6 = *(void *)(v4 + 32);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (v5 != 1 || v6)
    {
      C3DTransactionFlush();
    }
    else
    {
      if (_commitImplicitTransaction_onceToken != -1) {
        dispatch_once(&_commitImplicitTransaction_onceToken, &__block_literal_global_17);
      }
      uint64_t v7 = _commitImplicitTransaction_queue;
      dispatch_async(v7, &__block_literal_global_21);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  }
}

uint64_t C3DValueCreateDefault(int a1)
{
  uint64_t v2 = C3DValueCreate(a1, 1);
  uint64_t v3 = v2;
  if (a1 == 11)
  {
    uint64_t Bytes = C3DValueGetBytes(v2);
    C3DMatrix4x4MakeIdentity(Bytes);
  }
  return v3;
}

uint64_t C3DNodeInsertChildNodeAfterChild(uint64_t a1, float32x4_t *cf, uint64_t a3)
{
  if (cf[5].i64[0])
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DNodeInsertChildNodeAtIndex_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!cf[4].i64[0] || (uint64_t v14 = scn_default_log(), !os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)))
  {
    if (a3) {
      goto LABEL_7;
    }
LABEL_12:
    cf[5].i64[0] = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = cf;
    CFRetain(cf);
    return __FixupParent(a1, cf);
  }
  C3DNodeInsertChildNodeAtIndex_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  if (!a3) {
    goto LABEL_12;
  }
LABEL_7:
  if (*(void *)(a3 + 64) != a1)
  {
    unsigned int v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DNodeInsertChildNodeAfterChild_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t v30 = *(void *)(a3 + 80);
  *(void *)(a3 + 80) = cf;
  CFRetain(cf);
  cf[5].i64[0] = v30;
  return __FixupParent(a1, cf);
}

uint64_t __FixupParent(uint64_t a1, float32x4_t *a2)
{
  a2[4].i64[0] = a1;
  __C3DNodeTransformDidChange(a2);
  if (a1)
  {
    if ((a2[13].i32[3] & 3) != 0)
    {
      uint64_t v4 = a1;
      do
      {
        *(_DWORD *)(v4 + 220) |= 2u;
        uint64_t v4 = *(void *)(v4 + 64);
      }
      while (v4);
      if (!a2)
      {
        int v5 = scn_default_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
          C3DGeometryTrackNode_cold_2(v5, v6, v7, v8, v9, v10, v11, v12);
        }
      }
    }
  }
  uint64_t v13 = a2[4].i64[0];
  if (v13)
  {
    unsigned int v14 = a2[13].i32[3] & 0xFFFFFF7F | (((*(_DWORD *)(v13 + 220) >> 7) & 1) << 7);
    a2[13].i32[3] = v14;
    unsigned int v15 = v14 & 0xFC7FFFFF | (((*(_DWORD *)(v13 + 220) >> 23) & 7) << 23);
    a2[13].i32[3] = v15;
  }
  else
  {
    unsigned int v15 = a2[13].u32[3];
  }
  __PropagateFlagsToChildren((uint64_t)a2, (v15 >> 7) & 1, (v15 >> 23) & 7);
  __DirtyWorldAlpha((uint64_t)a2, 0);
  uint64_t v16 = *(void *)(a1 + 48);
  uint64_t v17 = a2[3].i64[0];
  if (v16)
  {
    if (v17 != v16)
    {
      C3DRemoveSceneRef(a2, v17);
      C3DAddSceneRef((uint64_t *)a2, *(void *)(a1 + 48));
    }
  }
  else
  {
    C3DRemoveSceneRef(a2, v17);
  }
  return __UpdateNodeVisibilityIfNeeded((uint64_t)a2, 1);
}

void __PropagateFlagsToChildren(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  unsigned int v14 = *(_DWORD *)(a1 + 220);
  int v15 = (v14 >> 7) & 0x80;
  if (a2) {
    int v15 = 128;
  }
  *(_DWORD *)(a1 + 220) = v15 & 0xFC7FFFFF | ((a3 & 7) << 23) | v14 & 0xFC7FFF7F;
  for (uint64_t i = *(void *)(a1 + 72); i; uint64_t i = *(void *)(i + 80))
    __PropagateFlagsToChildren(i, (*(_DWORD *)(a1 + 220) >> 7) & 1, a3);
}

void __C3DNodeTransformDidChange(float32x4_t *a1)
{
  uint64_t v2 = a1[3].i64[0];
  if (v2)
  {
    uint64_t TransformTree = C3DSceneGetTransformTree(v2);
    if (TransformTree)
    {
      if (a1[5].i32[2] != -1)
      {
        uint64_t v4 = (__C3DTransformTree *)TransformTree;
        memset(&v5, 0, sizeof(v5));
        C3DNodeGetMatrix((uint64_t)a1, (uint64_t)&v5);
        C3DTransformTreeUpdateNodeTransform(v4, a1[5].i32[2], &v5);
      }
    }
  }
  __UpdateAudioTransform(a1);
}

void __UpdateAudioTransform(float32x4_t *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((a1[13].i8[14] & 8) != 0)
  {
    CFArrayRef Attribute = C3DEntityGetAttribute((uint64_t)a1, @"kAudioPlayer");
    if (!Attribute)
    {
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        __UpdateAudioTransform_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }
    WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix(a1);
    CFIndex Count = CFArrayGetCount(Attribute);
    if (Count >= 1)
    {
      CFIndex v21 = Count;
      for (CFIndex i = 0; i != v21; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(Attribute, i);
        C3DAudioPlayerSetTransform(ValueAtIndex, WorldMatrix);
      }
    }
  }
}

void C3DRemoveSceneRef(void *cf, uint64_t a2)
{
  if (!cf && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (!a2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  if (_C3DEntityGetSceneLink_onceToken != -1) {
    dispatch_once(&_C3DEntityGetSceneLink_onceToken, &__block_literal_global_11);
  }
  uint64_t v12 = _C3DEntityGetSceneLink_sceneLink;
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  uint64_t v14 = *ClassWithTypeID;
  if (*ClassWithTypeID == 749405696) {
    uint64_t v15 = ClassWithTypeID;
  }
  else {
    uint64_t v15 = 0;
  }
  if (*((void *)cf + 6) == a2)
  {
    uint64_t v16 = *((void *)cf + 7);
    if (v16)
    {
      uint64_t v17 = v16 - 1;
      *((void *)cf + 7) = v17;
      if (!v17)
      {
        if (v14 == 749405696)
        {
          uint64_t v18 = (void (*)(void *, uint64_t))v15[19];
          if (v18) {
            v18(cf, a2);
          }
        }
        uint64_t v19 = *(void (**)(void *, uint64_t))(v12 + 16);
        if (v19) {
          v19(cf, a2);
        }
        if (v14 == 749405696)
        {
          uint64_t v20 = (void (*)(void *, void *))v15[17];
          if (v20)
          {
            v22[0] = MEMORY[0x263EF8330];
            v22[1] = 0x40000000;
            v22[2] = __C3DRemoveSceneRef_block_invoke;
            v22[3] = &__block_descriptor_tmp_6;
            v22[4] = a2;
            v20(cf, v22);
          }
        }
        _removeFromScene(cf, a2);
        *((void *)cf + 6) = 0;
      }
    }
    else if ((C3DRemoveSceneRef_done & 1) == 0)
    {
      C3DRemoveSceneRef_done = 1;
      CFIndex v21 = scn_default_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        C3DRemoveSceneRef_cold_1((uint64_t)cf, v21);
      }
    }
  }
}

void __DirtyWorldAlpha(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  int v12 = *(_DWORD *)(a1 + 220);
  if (*(void *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 220) = v12 & 0xFFFFFFDF;
    uint64_t v13 = *(void *)(a1 + 48);
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 0x40000000;
    v14[2] = ____DirtyWorldAlpha_block_invoke;
    v14[3] = &__block_descriptor_tmp_163;
    char v15 = a2;
    v14[4] = v13;
    C3DNodeApplyHierarchy(a1, (uint64_t)v14);
  }
  else
  {
    *(_DWORD *)(a1 + 220) = v12 | 0x20;
  }
}

uint64_t __UpdateNodeVisibilityIfNeeded(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 48);
  if (v2)
  {
    uint64_t v4 = result;
    if (C3DNodeShouldBePutInCullingSystem(result) && *(_DWORD *)(v4 + 216) == -1)
    {
      uint64_t v5 = scn_default_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
        __UpdateNodeVisibilityIfNeeded_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    __UpdateCullingSystemFlags(v4, 1);
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ____UpdateNodeVisibilityIfNeeded_block_invoke;
    v13[3] = &__block_descriptor_tmp_168;
    char v14 = a2;
    v13[4] = v4;
    v13[5] = v2;
    return C3DNodeApplyHierarchy(v4, (uint64_t)v13);
  }
  return result;
}

uint64_t C3DMeshSourceCreate(const void *a1, __int16 a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v10 = C3DSizeOfBaseType(a5) * a4;

  return C3DMeshSourceCreateWithData(a2, a1, a5, a4, a3, v10, 0);
}

CFStringRef C3DCFTypeCopyModelInfoAtPath(float32x4_t *a1, CFStringRef theString, uint64_t a3)
{
  CFStringRef result = C3DCreatePathComponentsFromString(theString);
  if (result)
  {
    CFStringRef v6 = result;
    uint64_t v7 = C3DCFTypeCopyModelInfoAtSplittedPath(a1, (const __CFArray *)result, 0, a3);
    CFRelease(v6);
    return (const __CFString *)v7;
  }
  return result;
}

CFStringRef C3DCreatePathComponentsFromString(const __CFString *theString)
{
  if (theString) {
    return (const __CFString *)CFStringCreateArrayBySeparatingStrings(0, theString, @".");
  }
  return theString;
}

uint64_t C3DCFTypeCopyModelInfoAtSplittedPath(float32x4_t *a1, const __CFArray *SubarrayWithRange, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v7 = a1;
  char v14 = 0;
  uint64_t v8 = C3DModelTargetCreate(0, 0, 0, 0);
  uint64_t v9 = C3DModelDescriptionResolveRootComponentInPath(SubarrayWithRange, v7, a3, &v14);
  if (v9) {
    uint64_t v7 = (float32x4_t *)v9;
  }
  CFIndex Count = CFArrayGetCount(SubarrayWithRange);
  uint64_t v11 = Count;
  if (v14)
  {
    uint64_t v11 = Count - 1;
    SubarrayWithRange = (const __CFArray *)C3DCFArrayGetSubarrayWithRange(SubarrayWithRange, (const char *)1, Count - 1);
  }
  uint64_t v12 = (void *)CFGetTypeID(v7);
  _C3DModelPathResolverRegistryResolvePathWithClassName(v7, v12, SubarrayWithRange, 0, v11, v8, a4);
  if (*(void *)(v8 + 24)) {
    *(unsigned char *)(v8 + 36) = C3DSizeOfBaseType(*(__int16 *)(v8 + 32));
  }
  return v8;
}

uint64_t C3DValueCreate(int a1, uint64_t a2)
{
  if (!a2 || a1 && !C3DSizeOfBaseType(a1)) {
    return 0;
  }
  if (C3DValueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DValueGetTypeID_onceToken, &__block_literal_global_93);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DValueGetTypeID_typeID, 0x18uLL);
  uint64_t v5 = Instance;
  *(unsigned char *)(Instance + 18) = 0;
  *(_WORD *)(Instance + 16) = a1;
  *(void *)(Instance + 32) = a2;
  if (a1)
  {
    size_t Length = C3DValueGetLength(Instance);
    *(void *)(v5 + 24) = malloc_type_calloc(Length, 1uLL, 0xA137D7F8uLL);
  }
  return v5;
}

uint64_t C3DValueGetLength(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32) * C3DSizeOfBaseType(*(__int16 *)(a1 + 16));
}

uint64_t C3DSizeOfBaseType(int a1)
{
  if (a1 >= 46)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSizeOfBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return __C3DSizeOfBaseTypeArray[a1];
}

uint64_t _C3DModelPathResolverRegistryResolvePathWithClassName(float32x4_t *a1, void *a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if ((void *)C3DEntityGetTypeID() == a2)
  {
    if (_C3DModelPathResolveEntity(a1, a3, a4, a5, a6)) {
      return 1;
    }
  }
  else if ((void *)C3DNodeGetTypeID() == a2)
  {
    if (_C3DModelPathResolveNode(a1, a3, a4, a5, a6, a7)) {
      return 1;
    }
  }
  else if ((void *)C3DMaterialGetTypeID() == a2)
  {
    if (_C3DModelPathResolveMaterial((uint64_t)a1, a3, a4, a5, a6, a7)) {
      return 1;
    }
  }
  else
  {
    if ((void *)C3DLightGetTypeID() == a2)
    {
      if (a1)
      {
        if ((_C3DModelPathResolveEntity(a1, a3, a4, a5, a6) & 1) == 0)
        {
          C3DModelTargetSetTarget(a6, a1);
          if ((int)a4 < (int)a5)
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, (int)a4);
            switch(_pathComponentForString(ValueAtIndex))
            {
              case 'N':
                uint64_t v15 = 1;
                Gobo = (char *)C3DLightGetGobo((uint64_t)a1, 1);
                goto LABEL_58;
              case 'O':
                uint64_t v15 = 1;
                Gobo = (char *)C3DLightGetProbeEnvironment((uint64_t)a1, 1);
LABEL_58:
                C3DModelPathResolveCommonProfileProperty(Gobo, a3, a4 + 1, a5, a6, a7);
                return v15;
              case 'Q':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = (float32x4_t *)((char *)a1 + 84);
                goto LABEL_65;
              case 'R':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = (float32x4_t *)((char *)a1 + 88);
                goto LABEL_65;
              case 'S':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = (float32x4_t *)((char *)a1 + 92);
                goto LABEL_65;
              case 'T':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = (float32x4_t *)((char *)a1 + 244);
                goto LABEL_65;
              case 'U':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = a1 + 15;
                goto LABEL_65;
              case 'V':
                uint64_t v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                uint64_t v29 = (float32x4_t *)((char *)a1 + 248);
LABEL_65:
                *(void *)(a6 + 24) = v29;
                break;
              default:
                goto LABEL_21;
            }
            return v15;
          }
          *(void *)(a6 + 24) = 0;
          *(_WORD *)(a6 + 32) = 0;
        }
        return 1;
      }
      goto LABEL_21;
    }
    if ((void *)C3DMorpherGetTypeID() == a2)
    {
      uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)a1);
    }
    else
    {
      if ((void *)C3DMorphGetTypeID() != a2)
      {
        if ((void *)C3DGeometryGetTypeID() == a2)
        {
          if (_C3DModelPathResolveGeometry(a1, a3, a4, a5, a6, a7)) {
            return 1;
          }
        }
        else if ((void *)C3DGenericSourceGetTypeID() == a2)
        {
          if (_C3DModelPathResolveGenericSource(a1, a3, a4, a5, a6)) {
            return 1;
          }
        }
        else if ((void *)C3DSceneGetTypeID() == a2)
        {
          if (_C3DModelPathResolveScene(a1, a3, a4, a5, a6, a7)) {
            return 1;
          }
        }
        else if ((void *)C3DFXTechniqueGetTypeID() == a2 && _C3DModelPathResolveTechnique(a1, a3, a4, a5, a6))
        {
          return 1;
        }
        goto LABEL_21;
      }
      uint64_t OverrideMaterial = (uint64_t)a1;
    }
    if (_C3DModelPathResolveMorph(OverrideMaterial, a3, a4, a5, a6, a7)) {
      return 1;
    }
  }
LABEL_21:
  os_unfair_lock_lock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  CFDictionaryRef Type = (const __CFDictionary *)_C3DModelPathResolverRegistryGetType(a2);
  if ((int)a4 >= (int)a5 || (CFDictionaryRef v19 = Type) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
LABEL_31:
    uint64_t v15 = 0;
    if (!a7 || a4 + 1 != a5) {
      return v15;
    }
    uint64_t v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      _C3DModelPathResolverRegistryResolvePathWithClassName_cold_1();
    }
    return 0;
  }
  uint64_t v20 = CFArrayGetValueAtIndex(a3, (int)a4);
  int Value = CFDictionaryGetValue(v19, v20);
  os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  if (!Value)
  {
    uint64_t v28 = CFDictionaryGetValue(v19, @"superClass");
    if (v28 && (_C3DModelPathResolverRegistryResolvePathWithClassName(a1, v28, a3, a4, a5, a6, a7) & 1) != 0) {
      return 1;
    }
    goto LABEL_31;
  }
  C3DModelTargetSetTarget(a6, a1);
  int v22 = *((unsigned __int16 *)Value + 4);
  *(_WORD *)(a6 + 32) = v22;
  *(unsigned char *)(a6 + 34) = Value[10];
  uint64_t v23 = (const void **)((char *)a1 + *(void *)Value);
  *(void *)(a6 + 24) = v23;
  uint64_t v24 = (a4 + 1);
  if ((int)v24 >= (int)a5) {
    return 1;
  }
  if (v22 == 5)
  {
    if (a1)
    {
      uint64_t v25 = *v23;
      return (uint64_t)_C3DModelPathResolverRegistryResolvePath(v25, (uint64_t)a3, v24, a5, a6, a7);
    }
    return 0;
  }

  return _C3DModelPathResolverRegistryResolveSubPath(a3, (int)a4 + 1, a5, a6);
}

uint64_t C3DEntityGetTypeID()
{
  if (C3DEntityGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEntityGetTypeID_onceToken, &__block_literal_global_96);
  }
  return C3DEntityGetTypeID_typeID;
}

uint64_t C3DNodeGetTypeID()
{
  if (C3DNodeGetTypeID_onceToken != -1) {
    dispatch_once(&C3DNodeGetTypeID_onceToken, &__block_literal_global_62);
  }
  return C3DNodeGetTypeID_typeID;
}

uint64_t C3DModelTargetCreate(const void *a1, uint64_t a2, int a3, char a4)
{
  if (C3DModelTargetGetTypeID_onceToken != -1) {
    dispatch_once(&C3DModelTargetGetTypeID_onceToken, &__block_literal_global_128);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DModelTargetGetTypeID_typeID, 0x18uLL);
  uint64_t v9 = Instance;
  if (a1) {
    C3DModelTargetSetTarget(Instance, a1);
  }
  *(void *)(v9 + 24) = a2;
  *(_WORD *)(v9 + 32) = a3;
  *(unsigned char *)(v9 + 34) = a4;
  *(unsigned char *)(v9 + 36) = C3DSizeOfBaseType(a3);
  return v9;
}

uint64_t C3DModelDescriptionResolveRootComponentInPath(const __CFArray *a1, const void *a2, uint64_t a3, unsigned char *a4)
{
  if (a1
    && CFArrayGetCount(a1) >= 2
    && (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, 0),
        CFIndex Length = CFStringGetLength(ValueAtIndex),
        Length >= 2)
    && (CFIndex v10 = Length, CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47))
  {
    if (a4) {
      *a4 = 1;
    }
    v14.length = v10 - 1;
    v14.location = 1;
    uint64_t v11 = (__CFString *)CFStringCreateWithSubstring(0, ValueAtIndex, v14);
    if (!a3
      || (uint64_t EntryWithUniqueID = (uint64_t)C3DLibraryGetEntryWithUniqueID(a3, v11)) == 0
      && (uint64_t EntryWithUniqueID = (uint64_t)C3DLibraryGetEntryWithDocumentID(a3, v11)) == 0)
    {
      uint64_t EntryWithUniqueID = C3DSearchByID(a2, (uint64_t)v11);
    }
    CFRelease(v11);
  }
  else
  {
    uint64_t EntryWithUniqueID = 0;
    if (a4) {
      *a4 = 0;
    }
  }
  return EntryWithUniqueID;
}

void C3DGeometrySetMesh(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  if (*(uint64_t **)(a1 + 64) == a2)
  {
    if (a2 || !*(void *)(a1 + 120)) {
      return;
    }
    uint64_t v4 = C3DGetSceneRef(a1);
    goto LABEL_8;
  }
  uint64_t v4 = C3DGetSceneRef(a1);
  if (!v4)
  {
LABEL_8:
    int v6 = 0;
    goto LABEL_9;
  }
  uint64_t v5 = *(void **)(a1 + 64);
  if (!v5)
  {
    if (!v2) {
      goto LABEL_20;
    }
    LOBYTE(v6) = 1;
    goto LABEL_13;
  }
  C3DRemoveSceneRef(v5, v4);
  int v6 = 1;
LABEL_9:
  uint64_t v7 = *(uint64_t **)(a1 + 64);
  if (v7 != v2)
  {
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 64) = 0;
    }
    if (!v2)
    {
LABEL_14:
      *(void *)(a1 + 64) = v2;
      if ((v6 & 1) == 0) {
        goto LABEL_22;
      }
LABEL_20:
      if (v2) {
        C3DAddSceneRef(v2, v4);
      }
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v2 = (uint64_t *)CFRetain(v2);
    goto LABEL_14;
  }
  if (v6) {
    goto LABEL_20;
  }
LABEL_22:
  *(unsigned char *)(a1 + 208) = 0;
  CFSetRef v8 = *(const __CFSet **)(a1 + 88);
  if (v8)
  {
    CFSetApplyFunction(v8, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
  }
}

void C3DGeometryInsertMaterialAtIndex(uint64_t a1, void *value, CFIndex idx)
{
  if (!a1)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), idx, value);
  uint64_t v14 = C3DGetSceneRef(a1);
  C3DAddSceneRef((uint64_t *)value, v14);
  __PostGeometryMaterialDidChangeNotification((void *)a1);
}

void C3DGeometryRemoveAllMaterials(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DGetSceneRef(a1))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        uint64_t v14 = C3DGetSceneRef(a1);
        C3DRemoveSceneRef(ValueAtIndex, v14);
      }
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
  __PostGeometryMaterialDidChangeNotification((void *)a1);
}

id C3DEntityCFFinalize(uint64_t a1)
{
  C3DEntityRemoveAllAnimations((void *)a1);
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 32) = 0;
  }

  return objc_storeWeak((id *)(a1 + 16), 0);
}

void C3DEntityRemoveAllAnimations(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DGetSceneRef((uint64_t)a1);
  uint64_t v11 = v10;
  if (v10)
  {
    uint64_t AnimationManager = C3DSceneGetAnimationManager(v10);
    if (AnimationManager) {
      C3DAnimationManagerRemoveAllAnimationsForObject(AnimationManager, a1);
    }
  }
  CFDictionaryRef SubAttributeOrderedDictionary = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, @"kAnimationsKey", 0);
  if (SubAttributeOrderedDictionary)
  {
    C3DOrderedDictionaryApplyFunction(SubAttributeOrderedDictionary, (const char *)_removeAnimationPlayerSceneRef, v11);
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kAnimationsKey", 0, 1);
  }
}

uint64_t C3DGetSceneRef(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t _C3DModelPathResolveMaterial(uint64_t result, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  if (result)
  {
    uint64_t v11 = (const void *)result;
    if (_C3DModelPathResolveEntity((void *)result, a2, a3, a4, a5)) {
      return 1;
    }
    C3DModelTargetSetTarget(a5, v11);
    if (a3 >= a4)
    {
      *(void *)(a5 + 24) = 0;
      *(_WORD *)(a5 + 32) = 0;
      return 1;
    }
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    unsigned int v13 = _pathComponentForString(ValueAtIndex);
    uint64_t CommonProfile = (char *)C3DMaterialGetCommonProfile((uint64_t)v11);
    if (v13 == 42)
    {
      _C3DModelPathResolveCommonProfile(CommonProfile, a2, a3 + 1, a4, a5, a6);
      return 1;
    }
    return _C3DModelPathResolveCommonProfile(CommonProfile, a2, a3, a4, a5, a6);
  }
  return result;
}

CFTypeRef C3DModelTargetSetTarget(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t _C3DModelPathResolveEntity(void *a1, CFArrayRef theArray, int a3, int a4, uint64_t a5)
{
  if (a3 >= a4) {
    return 0;
  }
  CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, a3);
  unsigned int v11 = _pathComponentForString(ValueAtIndex);
  if (v11 == 90)
  {
    if (a3 + 1 < a4)
    {
      uint64_t v17 = CFArrayGetValueAtIndex(theArray, a3 + 1);
      uint64_t result = C3DGetScene(a1);
      if (result)
      {
        uint64_t AnimationManager = C3DSceneGetAnimationManager(result);
        uint64_t result = (uint64_t)C3DAnimationManagerGetAnimationNodeForKey(AnimationManager, a1, v17);
        if (result)
        {
          *(void *)(a5 + 24) = result + 52;
          C3DModelTargetSetTarget(a5, (CFTypeRef)result);
          uint64_t result = 1;
          *(_WORD *)(a5 + 32) = 1;
          *(unsigned char *)(a5 + 34) = 0;
        }
      }
      return result;
    }
    return 0;
  }
  if (v11 != 89)
  {
    uint64_t result = C3DEntityIsTypeSupportingShaderModifiers(a1);
    if (result)
    {
      C3DEntityGetShaderModifiers((uint64_t)a1);
      return C3DEntityResolveKeypathInKeyValueStore((uint64_t)a1, theArray, a3, a5);
    }
    return result;
  }
  if (a3 + 1 >= a4) {
    return 0;
  }
  uint64_t v12 = CFArrayGetValueAtIndex(theArray, a3 + 1);
  CFDictionaryRef ValueForKey = C3DEntityGetValueForKey((uint64_t)a1, v12);
  if (ValueForKey)
  {
    CFDictionaryRef v14 = ValueForKey;
    CFTypeID v15 = CFGetTypeID(ValueForKey);
    if (v15 == C3DValueGetTypeID())
    {
      C3DModelTargetSetTarget(a5, v14);
      *(void *)(a5 + 24) = C3DValueGetBytes((uint64_t)v14);
      *(_WORD *)(a5 + 32) = C3DValueGetType((uint64_t)v14);
      *(unsigned char *)(a5 + 34) = 0;
      return 1;
    }
  }
  CFDictionaryRef v19 = scn_default_log();
  uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_FAULT);
  if (result)
  {
    _C3DModelPathResolveEntity_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return result;
}

const void *_pathComponentForString(void *key)
{
  if (_pathComponentForString_onceToken != -1) {
    dispatch_once(&_pathComponentForString_onceToken, &__block_literal_global_8_1);
  }
  return CFDictionaryGetValue((CFDictionaryRef)_pathComponentForString__pathComponents, key);
}

BOOL C3DEntityIsTypeSupportingShaderModifiers(CFTypeRef cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  return CFTypeIsC3DGeometry(v10) || v10 == C3DMaterialGetTypeID();
}

void __PostGeometryMaterialDidChangeNotification(void *cf)
{
  CFSetRef v2 = (const __CFSet *)cf[11];
  if (v2) {
    CFSetApplyFunction(v2, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == C3DParametricGeometryGetTypeID())
  {
    C3DParametricGeometryMaterialDidChange((uint64_t)cf);
  }
}

void C3DEngineNotificationQueueEnqueueEvent(uint64_t a1, int a2, const void *a3, const void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (!a3 && (uint64_t v9 = scn_default_log(), os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v17 = scn_default_log();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
    C3DEngineNotificationQueueEnqueueEvent_cold_2(v17, v18, v19, v20, v21, v22, v23, v24);
  }
LABEL_6:
  TypeID = (const void *)CFGetTypeID(a3);
  if (CFTypeIsC3DGeometry((uint64_t)TypeID)) {
    TypeID = (const void *)C3DGeometryGetTypeID();
  }
  int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), TypeID);
  if (!Value)
  {
    int Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), TypeID, Value);
    CFRelease(Value);
  }
  unsigned int v27 = CFDictionaryGetValue((CFDictionaryRef)Value, a3);
  unsigned int v28 = v27;
  switch(a2)
  {
    case 0:
      if ((v27 & 0x200) != 0)
      {
        uint64_t v29 = scn_default_log();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          int v41 = 134217984;
          CFTypeRef v42 = a3;
          _os_log_impl(&dword_20B249000, v29, OS_LOG_TYPE_DEFAULT, "Warning: adding a node that was just removed %p", (uint8_t *)&v41, 0xCu);
        }
      }
      uint64_t v30 = (const void *)(v28 & 0xFFEFFF00 | 0x100001);
      goto LABEL_26;
    case 2:
      if (a4)
      {
        if (CFEqual(a4, @"kMeshKey"))
        {
          uint64_t v31 = v28 & 0xFFFFEF00;
          uint64_t v32 = 4097;
        }
        else if (CFEqual(a4, @"kCameraKey"))
        {
          uint64_t v31 = v28 & 0xFFFFDF00;
          uint64_t v32 = 8193;
        }
        else if (CFEqual(a4, @"kLightKey"))
        {
          uint64_t v31 = v28 & 0xFFFFBF00;
          uint64_t v32 = 16385;
        }
        else if (CFEqual(a4, @"kDeformerStackKey"))
        {
          uint64_t v31 = v28 & 0xFFFDFF00;
          uint64_t v32 = 131073;
        }
        else
        {
          if (!CFEqual(a4, @"rendererDelegate")) {
            goto LABEL_27;
          }
          uint64_t v31 = v28 & 0xFFFF7F00;
          uint64_t v32 = 32769;
        }
LABEL_25:
        uint64_t v30 = (const void *)(v31 | v32);
LABEL_26:
        CFDictionarySetValue((CFMutableDictionaryRef)Value, a3, v30);
      }
      else
      {
        uint64_t v33 = scn_default_log();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
          C3DEngineNotificationQueueEnqueueEvent_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
        }
      }
LABEL_27:
      if (!*(unsigned char *)(a1 + 48))
      {
        *(unsigned char *)(a1 + 48) = 1;
        _dispatchAutoFlush(a1);
      }
      os_unfair_lock_unlock(v8);
      return;
    case 3:
      uint64_t v31 = v27 & 0xFFFFFD00;
      uint64_t v32 = 514;
      goto LABEL_25;
    case 4:
      uint64_t v31 = v27 & 0xFFFFFB00;
      uint64_t v32 = 1025;
      goto LABEL_25;
    case 5:
      uint64_t v31 = v27 & 0xFFFFFF00;
      uint64_t v32 = 2049;
      goto LABEL_25;
    case 6:
      uint64_t v31 = v27 & 0xFFFFFB00;
      uint64_t v32 = 1027;
      goto LABEL_25;
    case 7:
      uint64_t v31 = v27 & 0xFFFFFF00;
      uint64_t v32 = 2051;
      goto LABEL_25;
    case 8:
      uint64_t v30 = (const void *)((v27 & 0xFFF7FF00) + 524289);
      goto LABEL_26;
    case 9:
      uint64_t v31 = v27 & 0xFFFFFD00;
      uint64_t v32 = 516;
      goto LABEL_25;
    default:
      goto LABEL_27;
  }
}

BOOL CFTypeIsC3DGeometry(uint64_t a1)
{
  if (C3DGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  }
  return C3DGeometryGetTypeID_typeID == a1
      || C3DFloorGetTypeID() == a1
      || C3DParametricGeometryGetTypeID() == a1
      || C3DShapeGeometryGetTypeID() == a1
      || C3DTextGeometryGetTypeID() == a1
      || C3DBezierCurveGeometryGetTypeID() == a1;
}

uint64_t C3DParametricGeometryGetTypeID()
{
  if (C3DParametricGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParametricGeometryGetTypeID_onceToken, &__block_literal_global_92);
  }
  return C3DParametricGeometryGetTypeID_typeID;
}

uint64_t C3DFloorGetTypeID()
{
  if (C3DFloorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFloorGetTypeID_onceToken, &__block_literal_global_80);
  }
  return C3DFloorGetTypeID_typeID;
}

uint64_t C3DBezierCurveGeometryGetTypeID()
{
  if (C3DBezierCurveGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DBezierCurveGeometryGetTypeID_onceToken, &__block_literal_global_30);
  }
  return C3DBezierCurveGeometryGetTypeID_typeID;
}

uint64_t C3DTextGeometryGetTypeID()
{
  if (C3DTextGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTextGeometryGetTypeID_onceToken, &__block_literal_global_13_0);
  }
  return C3DTextGeometryGetTypeID_typeID;
}

uint64_t C3DShapeGeometryGetTypeID()
{
  if (C3DShapeGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DShapeGeometryGetTypeID_onceToken, &__block_literal_global_145);
  }
  return C3DShapeGeometryGetTypeID_typeID;
}

uint64_t C3DMaterialGetTypeID()
{
  if (C3DMaterialGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMaterialGetTypeID_onceToken, &__block_literal_global_64);
  }
  return C3DMaterialGetTypeID_typeID;
}

uint64_t C3DEntityResolveKeypathInKeyValueStore(uint64_t a1, const __CFArray *a2, int a3, uint64_t a4)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 40);
  if (!v4) {
    return 0;
  }
  int Value = (CFDictionaryRef *)CFDictionaryGetValue(v4, @"_kvc");
  if (!Value) {
    return 0;
  }

  return C3DKeyValueStoreSetupModelTargetWithKey(Value, a2, a3, a4);
}

uint64_t _C3DModelPathResolveCommonProfile(char *cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  C3DModelTargetSetTarget(a5, cf);
  if (a3 < a4)
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    switch(_pathComponentForString(ValueAtIndex))
    {
      case '+':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 2;
        goto LABEL_22;
      case ',':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 1;
        goto LABEL_22;
      case '-':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 3;
        goto LABEL_22;
      case '.':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 0;
        goto LABEL_22;
      case '/':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 4;
        goto LABEL_22;
      case '0':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 7;
        goto LABEL_22;
      case '1':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 8;
        goto LABEL_22;
      case '2':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 9;
        goto LABEL_22;
      case '3':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 10;
        goto LABEL_22;
      case '4':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 11;
        goto LABEL_22;
      case '5':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 12;
        goto LABEL_22;
      case '6':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 13;
        goto LABEL_22;
      case '7':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 14;
        goto LABEL_22;
      case '8':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 15;
        goto LABEL_22;
      case '9':
        uint64_t v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        uint64_t v16 = cf + 176;
        goto LABEL_26;
      case ':':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 5;
        goto LABEL_22;
      case ';':
        uint64_t v13 = 1;
        uint64_t v14 = (uint64_t)cf;
        int v15 = 6;
LABEL_22:
        uint64_t EffectSlot = (char *)C3DEffectCommonProfileGetEffectSlot(v14, v15, 1);
        C3DModelPathResolveCommonProfileProperty(EffectSlot, a2, a3 + 1, a4, a5, a6);
        return v13;
      case '<':
        uint64_t v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        uint64_t v16 = cf + 160;
        goto LABEL_26;
      case '=':
        uint64_t v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        uint64_t v16 = cf + 164;
        goto LABEL_26;
      case '>':
        uint64_t v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        uint64_t v16 = cf + 172;
LABEL_26:
        *(void *)(a5 + 24) = v16;
        return v13;
      case '@':
        *(_WORD *)(a5 + 32) = 3;
        uint64_t v20 = cf + 192;
        goto LABEL_34;
      case 'B':
        *(_WORD *)(a5 + 32) = 3;
        uint64_t v20 = cf + 193;
LABEL_34:
        *(void *)(a5 + 24) = v20;
        return 1;
      default:
        if (a6)
        {
          uint64_t v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            _C3DModelPathResolveCommonProfile_cold_1();
          }
        }
        return 0;
    }
  }
  *(void *)(a5 + 24) = 0;
  *(_WORD *)(a5 + 32) = 0;
  return 1;
}

CFIndex _C3DMeshEnumerateSubEntities(CFArrayRef *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1[8]);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1[8], i);
      (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
    }
  }
  CFIndex v8 = CFArrayGetCount(a1[12]);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    for (CFIndex j = 0; j != v9; ++j)
    {
      uint64_t v11 = CFArrayGetValueAtIndex(a1[12], j);
      (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, v11);
    }
  }
  CFArrayRef v12 = a1[14];
  if (v12)
  {
    CFIndex v13 = CFArrayGetCount(v12);
    if (v13 >= 1)
    {
      CFIndex v14 = v13;
      for (CFIndex k = 0; k != v14; ++k)
      {
        uint64_t v16 = CFArrayGetValueAtIndex(a1[14], k);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, v16);
      }
    }
  }
  CFIndex result = (CFIndex)a1[18];
  if (result)
  {
    CFIndex result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      CFIndex v18 = result;
      for (CFIndex m = 0; m != v18; ++m)
      {
        uint64_t v20 = CFArrayGetValueAtIndex(a1[18], m);
        CFIndex result = (*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, v20);
      }
    }
  }
  return result;
}

void C3DAddSceneRef(uint64_t *cf, uint64_t a2)
{
  if (!cf && (CFDictionaryRef v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (!a2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  if (_C3DEntityGetSceneLink_onceToken != -1) {
    dispatch_once(&_C3DEntityGetSceneLink_onceToken, &__block_literal_global_11);
  }
  CFArrayRef v12 = (void *)_C3DEntityGetSceneLink_sceneLink;
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  uint64_t v14 = *ClassWithTypeID;
  if (*ClassWithTypeID == 749405696) {
    int v15 = ClassWithTypeID;
  }
  else {
    int v15 = 0;
  }
  uint64_t v16 = cf[6];
  if (!v16 || v16 == a2)
  {
    ++cf[7];
    if (v16) {
      return;
    }
  }
  else
  {
    if (v14 == 749405696)
    {
      uint64_t v17 = (void (*)(uint64_t *, uint64_t))v15[19];
      if (v17) {
        v17(cf, cf[6]);
      }
    }
    CFIndex v18 = (void (*)(uint64_t *, uint64_t))v12[2];
    if (v18) {
      v18(cf, v16);
    }
    _removeFromScene(cf, v16);
    cf[7] = 1;
  }
  cf[6] = a2;
  uint64_t v19 = (void (*)(uint64_t *, uint64_t))v12[1];
  if (v19) {
    v19(cf, a2);
  }
  if (v14 == 749405696)
  {
    uint64_t v20 = (void (*)(uint64_t *, uint64_t))v15[18];
    if (v20) {
      v20(cf, a2);
    }
    uint64_t v21 = (void (*)(uint64_t *, void *))v15[17];
    if (v21)
    {
      v26[0] = MEMORY[0x263EF8330];
      v26[1] = 0x40000000;
      v26[2] = __C3DAddSceneRef_block_invoke;
      v26[3] = &__block_descriptor_tmp_3_0;
      v26[4] = a2;
      v21(cf, v26);
    }
  }
  if (v16)
  {
    uint64_t v22 = (void (*)(uint64_t *, uint64_t))v12[4];
    if (v22) {
      v22(cf, v16);
    }
    if (v14 == 749405696)
    {
      uint64_t v23 = (void (*)(uint64_t *, uint64_t))v15[21];
      if (v23) {
        v23(cf, v16);
      }
    }
  }
  uint64_t v24 = (void (*)(uint64_t *, uint64_t))v12[3];
  if (v24) {
    v24(cf, a2);
  }
  if (v14 == 749405696)
  {
    uint64_t v25 = (void (*)(uint64_t *, uint64_t))v15[20];
    if (v25) {
      v25(cf, a2);
    }
  }
}

CFDictionaryRef _C3DEntityFinalizeAddToScene(float32x4_t *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!a1 && (CFDictionaryRef v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  CFArrayRef v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t AnimationManager = C3DSceneGetAnimationManager(a2);
  CFDictionaryRef SubAttributeOrderedDictionary = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, @"kAnimationsKey", 0);
  if (SubAttributeOrderedDictionary)
  {
    uint64_t v32 = a1;
    uint64_t v33 = AnimationManager;
    uint64_t v34 = a2;
    C3DOrderedDictionaryApplyFunction(SubAttributeOrderedDictionary, (const char *)_fillAnimationManager, (uint64_t)&v32);
  }
  CFDictionaryRef v22 = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, @"kActionsKey", 0);
  if (v22)
  {
    uint64_t v32 = a1;
    uint64_t v33 = AnimationManager;
    C3DOrderedDictionaryApplyFunction(v22, (const char *)_fillAnimationManagerWithActions, (uint64_t)&v32);
  }
  CFDictionaryRef result = _C3DEntityGetSubAttributeArray((uint64_t)a1, @"kBindingsKey", 0);
  if (result)
  {
    CFDictionaryRef v24 = result;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    CFDictionaryRef result = (const __CFDictionary *)[(__CFDictionary *)result countByEnumeratingWithState:&v28 objects:&v32 count:16];
    if (result)
    {
      CFDictionaryRef v25 = result;
      uint64_t v26 = *(void *)v29;
      do
      {
        CFDictionaryRef v27 = 0;
        do
        {
          if (*(void *)v29 != v26) {
            objc_enumerationMutation(v24);
          }
          C3DAnimationManagerAddBinding(AnimationManager, a1, (CFStringRef)[*(id *)(*((void *)&v28 + 1) + 8 * (void)v27) keyPathDst], (float32x4_t *)objc_msgSend(*(id *)(*((void *)&v28 + 1) + 8 * (void)v27), "sourceObject"), (const __CFString *)objc_msgSend(*(id *)(*((void *)&v28 + 1) + 8 * (void)v27), "keyPathSrc"), objc_msgSend(*(id *)(*((void *)&v28 + 1) + 8 * (void)v27), "options"));
          CFDictionaryRef v27 = (const __CFDictionary *)((char *)v27 + 1);
        }
        while (v25 != v27);
        CFDictionaryRef result = (const __CFDictionary *)[(__CFDictionary *)v24 countByEnumeratingWithState:&v28 objects:&v32 count:16];
        CFDictionaryRef v25 = result;
      }
      while (result);
    }
  }
  return result;
}

CFDictionaryRef _C3DEntityGetSubAttributeOrderedDictionary(uint64_t a1, void *key, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryRef v14 = *(const __CFDictionary **)(a1 + 40);
  if (v14)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v14, key);
    if (Value) {
      return Value;
    }
  }
  else
  {
    CFDictionaryRef Value = 0;
  }
  if (a3)
  {
    CFDictionaryRef Value = (const __CFDictionary *)C3DOrderedDictionaryCreate();
    _C3DEntitySetAttribute((CFTypeRef *)a1, key, Value, 1);
    if (CFGetRetainCount(Value) <= 1)
    {
      uint64_t v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        _C3DEntityGetSubAttributeOrderedDictionary_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    CFRelease(Value);
  }
  return Value;
}

uint64_t C3DSceneGetAnimationManager(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 72);
}

CFDictionaryRef _C3DEntityGetSubAttributeArray(uint64_t a1, void *key, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryRef v14 = *(const __CFDictionary **)(a1 + 40);
  if (v14)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v14, key);
    if (Value) {
      return Value;
    }
  }
  else
  {
    CFDictionaryRef Value = 0;
  }
  if (a3)
  {
    CFDictionaryRef Value = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    _C3DEntitySetAttribute((CFTypeRef *)a1, key, Value, 1);
    CFRelease(Value);
  }
  return Value;
}

uint64_t __C3DAddSceneRef_block_invoke(int a1, CFTypeRef cf)
{
  return C3DAddSceneRef(cf);
}

void __UpdateCullingHandle(uint64_t a1, uint64_t a2)
{
  ShouldBePutInCullingSysteCFIndex m = C3DNodeShouldBePutInCullingSystem(a1);
  if (((ShouldBePutInCullingSystem ^ (*(_DWORD *)(a1 + 216) == -1)) & 1) == 0)
  {
    int v5 = ShouldBePutInCullingSystem;
    CullingSysteCFIndex m = (__C3DCullingSystem *)C3DSceneGetCullingSystem(a2);
    if (v5)
    {
      int v7 = C3DCullingSystemAdd(CullingSystem, (__C3DNode *)a1);
    }
    else
    {
      C3DCullingSystemRemove(CullingSystem, *(_DWORD *)(a1 + 216));
      int v7 = -1;
    }
    *(_DWORD *)(a1 + 216) = v7;
    uint64_t TransformTree = C3DSceneGetTransformTree(a2);
    int v9 = *(_DWORD *)(a1 + 88);
    int v10 = *(_DWORD *)(a1 + 216);
    C3DTransformTreeUpdateCullingHandle(TransformTree, v9, v10);
  }
}

void _C3DNodeWasAddedToScene(uint64_t a1, uint64_t a2)
{
  uint64_t TransformTree = (__C3DTransformTree *)C3DSceneGetTransformTree(a2);
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5) {
    int v6 = *(_DWORD *)(v5 + 88);
  }
  else {
    int v6 = -1;
  }
  *(_DWORD *)(a1 + 88) = C3DTransformTreeAddNode(TransformTree, (__C3DNode *)a1, v6);

  __UpdateCullingHandle(a1, a2);
}

float32x4_t *C3DNodeGetWorldMatrix(float32x4_t *a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = a1[3].i64[0];
  if (!v10) {
    return C3DTransformGetMatrixPtr(a1 + 6);
  }
  uint64_t TransformTree = C3DSceneGetTransformTree(v10);
  if (!TransformTree)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v23 = 0;
      _os_log_impl(&dword_20B249000, v22, OS_LOG_TYPE_DEFAULT, "Warning: C3DNodeGetWorldMatrix - no transform tree", v23, 2u);
    }
    return C3DTransformGetMatrixPtr(a1 + 6);
  }
  uint64_t v12 = (__C3DTransformTree *)TransformTree;
  if (a1[5].i32[2] == -1)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetWorldMatrix_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  return (float32x4_t *)C3DTransformTreeGetWorldTransformPtr(v12, a1[5].i32[2]);
}

uint64_t C3DSceneGetTransformTree(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 152);
}

uint64_t C3DTransformTreeGetWorldTransformPtr(__C3DTransformTree *this, int a2)
{
  if (!this)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DTransformTreeAddNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 == -1)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      __C3DTransformTree::remove();
    }
  }
  unint64_t v13 = *(void *)(*((void *)this + 3) + 8 * a2);
  if (*((unsigned char *)this + 68)) {
    __C3DTransformTree::updateWorldTransforms(this);
  }
  if (HIDWORD(v13) == 0xFFFFFFFF) {
    LODWORD(v14) = 0;
  }
  else {
    unint64_t v14 = HIDWORD(v13);
  }
  if (HIDWORD(v13) == 0xFFFFFFFF) {
    int v15 = 0;
  }
  else {
    int v15 = -1;
  }
  if (v13 == 0xFFFFFFFFLL) {
    LODWORD(v16) = v14;
  }
  else {
    unint64_t v16 = HIDWORD(v13);
  }
  if (v13 == 0xFFFFFFFFLL) {
    int v17 = v15;
  }
  else {
    int v17 = v13;
  }
  return *(void *)(*((void *)this + 7) + 80 * v17) + ((uint64_t)(int)v16 << 6);
}

void _C3DNodeFinalizeAddToScene(float32x4_t *a1)
{
  if (!a1[4].i64[0]) {
    __UpdateNodeVisibilityIfNeeded((uint64_t)a1, 1);
  }
  uint64_t v2 = a1[15].i64[1];
  if (v2)
  {
    uint64_t Skinner = C3DDeformerStackGetSkinner(v2);
    if (Skinner)
    {
      uint64_t v4 = Skinner;
      if (C3DGeometryGetOverrideMaterial(Skinner))
      {
        C3DSkinnerUpdateJointsAndBoundingBox(v4, a1);
      }
    }
  }
}

uint64_t _C3DNodeEnumerateSubEntities(void *a1, void (**a2)(void))
{
  CFDictionaryRef Attributes = (const __CFDictionary *)C3DEntityGetAttributes((uint64_t)a1);
  if (Attributes) {
    CFDictionaryApplyFunction(Attributes, (CFDictionaryApplierFunction)_C3DNodeEnumerateAttributeEntities, a2);
  }
  if (a1[30]) {
    a2[2](a2);
  }
  uint64_t Morpher = C3DNodeGetMorpher((uint64_t)a1);
  if (Morpher) {
    ((void (*)(void (**)(void), uint64_t))a2[2])(a2, Morpher);
  }
  uint64_t v6 = a1[31];
  if (v6)
  {
    uint64_t Skinner = C3DDeformerStackGetSkinner(v6);
    if (Skinner) {
      ((void (*)(void (**)(void), uint64_t))a2[2])(a2, Skinner);
    }
  }
  CFArrayRef ParticleSystems = C3DNodeGetParticleSystems((uint64_t)a1);
  if (ParticleSystems)
  {
    CFArrayRef v9 = ParticleSystems;
    CFIndex Count = CFArrayGetCount(ParticleSystems);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
        ((void (*)(void (**)(void), const void *))a2[2])(a2, ValueAtIndex);
      }
    }
  }
  uint64_t result = (uint64_t)C3DNodeGetConstraints((uint64_t)a1);
  if (result)
  {
    CFArrayRef v15 = (const __CFArray *)result;
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t v16 = result;
      for (CFIndex j = 0; j != v16; ++j)
      {
        uint64_t v18 = CFArrayGetValueAtIndex(v15, j);
        uint64_t result = ((uint64_t (*)(void (**)(void), const void *))a2[2])(a2, v18);
      }
    }
  }
  v21[0] = MEMORY[0x263EF8330];
  v21[1] = 0x40000000;
  uint64_t v22 = ___C3DNodeEnumerateSubEntities_block_invoke;
  uint64_t v23 = &unk_264007EE0;
  CFDictionaryRef v24 = a2;
  uint64_t v19 = a1[9];
  if (v19)
  {
    uint64_t v20 = 0;
    do
    {
      uint64_t result = ((uint64_t (*)(void *, uint64_t, uint64_t))v22)(v21, v19, v20++);
      uint64_t v19 = *(void *)(v19 + 80);
    }
    while (v19);
  }
  return result;
}

const void *C3DNodeGetPresentationMesh(uint64_t a1)
{
  uint64_t v1 = *(__C3DGeometry **)(a1 + 240);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 248);
  if (v3 && (uint64_t Skinner = C3DDeformerStackGetSkinner(v3)) != 0)
  {
    return (const void *)C3DSkinnerGetSkinnedMeshLegacy(Skinner, a1);
  }
  else
  {
    uint64_t Morpher = C3DNodeGetMorpher(a1);
    if (Morpher)
    {
      return (const void *)C3DMorpherGetMorphedMeshLegacy(Morpher);
    }
    else
    {
      return C3DGeometryGetRenderingMesh(v1);
    }
  }
}

uint64_t C3DNodeGetMorpher(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = *(void *)(a1 + 248);
  if (result) {
    return C3DDeformerStackGetMorpher(result);
  }
  return result;
}

uint64_t C3DEntityGetAttributes(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

CFDictionaryRef C3DNodeGetParticleSystems(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 222) & 4) != 0) {
    return C3DEntityGetAttribute(a1, @"kParticleSystem");
  }
  else {
    return 0;
  }
}

CFDictionaryRef C3DNodeGetConstraints(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 222)) {
    return C3DEntityGetAttribute(a1, @"kConstraints");
  }
  else {
    return 0;
  }
}

uint64_t C3DSceneGetCullingSystem(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 144);
}

CFIndex _C3DGeometryEnumerateSubEntities(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 64)) {
    (*(void (**)(uint64_t))(a2 + 16))(a2);
  }
  CFArrayRef v4 = *(const __CFArray **)(a1 + 80);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }
  }
  CFIndex result = *(void *)(a1 + 96);
  if (result)
  {
    CFIndex result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      CFIndex v10 = result;
      for (CFIndex j = 0; j != v10; ++j)
      {
        uint64_t v12 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), j);
        CFIndex result = (*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, v12);
      }
    }
  }
  return result;
}

void C3DTransformTreeUpdateCullingHandle(uint64_t a1, int a2, int a3)
{
  if (!a1)
  {
    CFIndex v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DTransformTreeAddNode_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (a2 == -1)
  {
    unint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      __C3DTransformTree::remove();
    }
  }
  CFArrayRef v15 = (int *)(*(void *)(a1 + 24) + 8 * a2);
  uint64_t v16 = v15[1];
  if (v16 != -1)
  {
    int v17 = *v15;
    if (*v15 >= *(_DWORD *)(a1 + 64))
    {
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
        C3DTransformTreeUpdateCullingHandle_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
      }
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 80 * v17 + 56) + 4 * v16) = a3;
  }
}

uint64_t C3DCullingSystemAdd(__C3DCullingSystem *a1, __C3DNode *a2)
{
  if (!a1)
  {
    CFArrayRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystemAdd_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return __C3DCullingSystem::add(a1, a2);
}

uint64_t __C3DCullingSystem::add(__C3DCullingSystem *this, __C3DNode *a2)
{
  unsigned int v5 = *((_DWORD *)this + 4);
  unsigned int v4 = *((_DWORD *)this + 5);
  if (v5 >= v4)
  {
    __C3DCullingSystem::_allocateData(this, 2 * v4);
    unsigned int v5 = *((_DWORD *)this + 4);
  }
  *((_DWORD *)this + 4) = v5 + 1;
  uint64_t v6 = __C3DCullingSystem::_newHandle(this, v5);
  C3DNodeGetLocalBoundingBox((uint64_t)a2, v10);
  long long v7 = v10[1];
  uint64_t v8 = (_OWORD *)(*((void *)this + 8) + 32 * v5);
  _OWORD *v8 = v10[0];
  v8[1] = v7;
  *(void *)(*((void *)this + 13) + 8 * v5) = a2;
  __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, v5);
  __C3DCullingSystem::_updateWorldAABBAtIndex(this, v5);
  return v6;
}

uint64_t __C3DCullingSystem::_updateWorldAABBAtIndex(__C3DCullingSystem *this, unsigned int a2)
{
  if ((*(_WORD *)(*((void *)this + 11) + 2 * a2) & 0x10) != 0)
  {
    __n128 v10 = (__n128)xmmword_20B5CBCE0;
    __n128 v8 = *(__n128 *)(MEMORY[0x263EF89A8] + 48);
  }
  else
  {
    WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(*((void *)this + 13) + 8 * a2));
    unsigned int v5 = (float32x4_t *)(*((void *)this + 8) + 32 * a2);
    float32x4_t v6 = WorldMatrix[1];
    float32x4_t v7 = WorldMatrix[2];
    __n128 v8 = (__n128)vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v6, *(float32x2_t *)v5->f32, 1), *WorldMatrix, COERCE_FLOAT(*v5)), v7, *v5, 2));
    v8.n128_u32[3] = 1.0;
    float32x4_t v9 = v5[1];
    v9.i32[1] = v9.i32[0];
    v9.i32[2] = (__int32)v5[1];
    __n128 v10 = (__n128)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(*WorldMatrix, v9)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v5[1].f32, 1), (int32x4_t)v5[1]), v6))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v5[1], (int32x4_t)v5[1]), (int32x4_t)v5[1]), v7)));
  }

  return __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, a2, v8, v10);
}

uint64_t __C3DCullingSystem::_newHandle(__C3DCullingSystem *this, int a2)
{
  uint64_t result = *((unsigned int *)this + 14);
  if (result == -1)
  {
    unint64_t v6 = *((void *)this + 6);
    float32x4_t v7 = (char *)*((void *)this + 5);
    if ((unint64_t)v7 >= v6)
    {
      float32x4_t v9 = (char *)*((void *)this + 4);
      uint64_t v10 = (v7 - v9) >> 2;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 62) {
        abort();
      }
      uint64_t v12 = v6 - (void)v9;
      if (v12 >> 1 > v11) {
        unint64_t v11 = v12 >> 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)this + 48, v13);
        float32x4_t v9 = (char *)*((void *)this + 4);
        float32x4_t v7 = (char *)*((void *)this + 5);
      }
      else
      {
        unint64_t v14 = 0;
      }
      CFArrayRef v15 = &v14[4 * v10];
      uint64_t v16 = &v14[4 * v13];
      *(_DWORD *)CFArrayRef v15 = a2;
      __n128 v8 = v15 + 4;
      while (v7 != v9)
      {
        int v17 = *((_DWORD *)v7 - 1);
        v7 -= 4;
        *((_DWORD *)v15 - 1) = v17;
        v15 -= 4;
      }
      *((void *)this + 4) = v15;
      *((void *)this + 5) = v8;
      *((void *)this + 6) = v16;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *(_DWORD *)float32x4_t v7 = a2;
      __n128 v8 = v7 + 4;
    }
    *((void *)this + 5) = v8;
    return (((unint64_t)v8 - *((void *)this + 4)) >> 2) - 1;
  }
  else
  {
    uint64_t v5 = *((void *)this + 4);
    *((_DWORD *)this + 14) = *(_DWORD *)(v5 + 4 * (int)result);
    *(_DWORD *)(v5 + 4 * (int)result) = a2;
  }
  return result;
}

uint64_t C3DNodeGetLocalBoundingBox(uint64_t a1, _OWORD *a2)
{
  long long v2 = *(_OWORD *)(a1 + 288);
  *a2 = *(_OWORD *)(a1 + 272);
  a2[1] = v2;
  return vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) >> 31;
}

BOOL C3DModelPathResolveCommonProfileProperty(char *cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  C3DModelTargetSetTarget(a5, cf);
  if (a3 >= a4)
  {
    *(void *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  else
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    switch(_pathComponentForString(ValueAtIndex))
    {
      case 'D':
      case 'E':
        uint64_t Color = C3DEffectSlotGetColor((uint64_t)cf);
        goto LABEL_18;
      case 'F':
        C3DEffectSlotGetTexture((uint64_t)cf);
        if (a3 + 1 < a4)
        {
          unint64_t v14 = (void *)CFArrayGetValueAtIndex(a2, a3 + 1);
          _pathComponentForString(v14);
          if (a6)
          {
            CFArrayRef v15 = scn_default_log();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              C3DModelPathResolveCommonProfileProperty_cold_2();
            }
          }
        }
        return 1;
      case 'H':
        ImageTransforCFIndex m = C3DEffectSlotGetImageTransform((uint64_t)cf);
        if (!ImageTransform)
        {
          memset(v21, 0, sizeof(v21));
          C3DMatrix4x4MakeIdentity((uint64_t)v21);
          C3DEffectSlotSetImageTransform((uint64_t)cf, v21);
          ImageTransforCFIndex m = C3DEffectSlotGetImageTransform((uint64_t)cf);
        }
        _C3DModelPathResolveMatrix(ImageTransform, a2, a3 + 1, a4, a5);
        return 1;
      case 'I':
        TextureSampler = (const void *)C3DEffectSlotGetTextureSampler((uint64_t)cf);
        if (!TextureSampler) {
          return 1;
        }
        uint64_t v20 = (uint64_t)TextureSampler;
        C3DModelTargetSetTarget(a5, TextureSampler);
        uint64_t Color = C3DTextureSamplerGetBorderColor(v20);
LABEL_18:
        _C3DModelPathResolveColor4(Color, a2, a3 + 1, a4, a5);
        return 1;
      case 'J':
        *(void *)(a5 + 24) = cf + 72;
        BOOL result = 1;
        *(_WORD *)(a5 + 32) = 1;
        return result;
      default:
        if (!a6) {
          goto LABEL_12;
        }
        uint64_t v16 = scn_default_log();
        BOOL result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
        if (result)
        {
          C3DModelPathResolveCommonProfileProperty_cold_1();
LABEL_12:
          BOOL result = 0;
        }
        break;
    }
  }
  return result;
}

uint64_t C3DNodeApplyHierarchy(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, result);
    if (v4 == 2) {
      return 1;
    }
    uint64_t v5 = v3;
    while (1)
    {
      if (v4 == 1 || (unint64_t v6 = (void *)v5[9]) == 0)
      {
        if (v5 == v3) {
          return 0;
        }
        while (1)
        {
          unint64_t v6 = (void *)v5[10];
          if (v6) {
            break;
          }
          uint64_t v5 = (void *)v5[8];
          if (v5) {
            BOOL v7 = v5 == v3;
          }
          else {
            BOOL v7 = 1;
          }
          if (v7) {
            return 0;
          }
        }
      }
      uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v6);
      uint64_t v5 = v6;
      if (v4 == 2) {
        return 1;
      }
    }
  }
  return result;
}

CFDictionaryRef C3DNodeGetLight(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 2) != 0) {
    return C3DEntityGetAttribute(a1, @"kLightKey");
  }
  else {
    return 0;
  }
}

uint64_t C3DNodeShouldBePutInCullingSystem(uint64_t a1)
{
  if (*(void *)(a1 + 240)) {
    return 1;
  }
  int v1 = *(_DWORD *)(a1 + 220);
  if ((v1 & 0x6000) != 0) {
    return 1;
  }
  if ((v1 & 0x200) == 0) {
    return 0;
  }
  CFDictionaryRef Light = C3DNodeGetLight(a1);

  return C3DLightGetDrawsArea((uint64_t)Light);
}

void *C3DSceneNodeWasAdded(uint64_t a1, float32x4_t *a2)
{
  *(void *)&v31[5] = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  if (!a1) {
    goto LABEL_14;
  }
  __int32 v20 = a2[13].i32[3];
  if ((v20 & 0x10000) != 0)
  {
    C3DSceneRegisterNodeConstrains(a1, a2);
    __int32 v20 = a2[13].i32[3];
    if ((v20 & 0x40000) == 0)
    {
LABEL_9:
      if ((v20 & 0x40) == 0) {
        goto LABEL_10;
      }
      goto LABEL_26;
    }
  }
  else if ((v20 & 0x40000) == 0)
  {
    goto LABEL_9;
  }
  ParticleManager = C3DSceneGetParticleManager(a1, 1);
  C3DParticleManagerRegisterSystem((uint64_t)ParticleManager, a2);
  __int32 v20 = a2[13].i32[3];
  if ((v20 & 0x40) == 0)
  {
LABEL_10:
    if ((v20 & 0x100000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_27;
  }
LABEL_26:
  C3DSceneRegisterNodePhysicsBody((id *)a1, (id *)a2);
  __int32 v20 = a2[13].i32[3];
  if ((v20 & 0x100000) == 0)
  {
LABEL_11:
    if ((v20 & 0x4000) == 0) {
      goto LABEL_12;
    }
LABEL_28:
    C3DSceneRegisterNodeFilters((CFTypeRef *)a1, a2);
    if ((a2[13].i32[3] & 0x200) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_27:
  C3DSceneRegisterNodePhysicsField((id *)a1, (id *)a2);
  __int32 v20 = a2[13].i32[3];
  if ((v20 & 0x4000) != 0) {
    goto LABEL_28;
  }
LABEL_12:
  if ((v20 & 0x200) != 0) {
LABEL_13:
  }
    C3DLightingSystemAdd(*(void *)(a1 + 128), a2);
LABEL_14:
  CFArrayRef AudioPlayers = C3DNodeGetAudioPlayers((uint64_t)a2);
  if (AudioPlayers)
  {
    CFArrayRef v22 = AudioPlayers;
    CFIndex Count = CFArrayGetCount(AudioPlayers);
    if (Count >= 1)
    {
      CFIndex v24 = Count;
      for (CFIndex i = 0; i != v24; ++i)
      {
        CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v22, i);
        if (!ValueAtIndex)
        {
          CFDictionaryRef v27 = scn_default_log();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
            C3DSceneNodeWasAdded_cold_1(v30, v31, v27);
          }
        }
        C3DAudioManagerAddVoice(ValueAtIndex);
      }
    }
  }
  BOOL result = *(void **)(a1 + 416);
  if (result) {
    return (void *)C3DAuthoringEnvironment2NodeAddedToScene(result, (id *)a2);
  }
  return result;
}

uint64_t C3DNodeGetFloor(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 0x10) != 0) {
    return C3DNodeGetGeometry(a1);
  }
  else {
    return 0;
  }
}

CFDictionaryRef C3DNodeGetAudioPlayers(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 222) & 8) != 0) {
    return C3DEntityGetAttribute(a1, @"kAudioPlayer");
  }
  else {
    return 0;
  }
}

uint64_t C3DCullingSystemUpdateFlags(__C3DCullingSystem *this, unsigned int a2)
{
  if (!this && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DCullingSystemAdd_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if ((a2 & 0x80000000) == 0)
    {
LABEL_4:
      if (a2 < (unint64_t)((uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 2)) {
        return __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, *(_DWORD *)(*((void *)this + 4) + 4 * (int)a2));
      }
    }
  }
  else if ((a2 & 0x80000000) == 0)
  {
    goto LABEL_4;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DCullingSystemUpdateFlags_cold_1();
  }
  return __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, *(_DWORD *)(*((void *)this + 4) + 4 * (int)a2));
}

void _C3DModelPathResolveColor4(uint64_t a1, CFArrayRef theArray, int a3, int a4, uint64_t a5)
{
  if (a3 >= a4)
  {
    *(void *)(a5 + 24) = a1;
    *(_WORD *)(a5 + 32) = 13;
  }
  else
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, a3);
    unsigned int v8 = _pathComponentForString(ValueAtIndex);
    *(_WORD *)(a5 + 32) = 1;
    switch(v8)
    {
      case 0x12u:
        *(void *)(a5 + 24) = a1;
        return;
      case 0x13u:
        uint64_t v10 = a1 + 4;
        goto LABEL_10;
      case 0x14u:
        uint64_t v10 = a1 + 8;
        goto LABEL_10;
      case 0x15u:
        uint64_t v10 = a1 + 12;
LABEL_10:
        *(void *)(a5 + 24) = v10;
        break;
      default:
        uint64_t v9 = scn_default_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          _C3DModelPathResolveColor4_cold_1();
        }
        break;
    }
  }
}

uint64_t C3DEffectSlotGetColor(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 16;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a2);
}

uint64_t __C3DNodeCopyNodesWithAttribute_block_invoke_3(uint64_t a1, const void *a2)
{
  if (C3DEntityHasAttribute((uint64_t)a2, *(void **)(a1 + 32))
    && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), a2), *(unsigned char *)(a1 + 48)))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

uint64_t _C3DModelPathResolveNode(float32x4_t *a1, const __CFArray *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a1) {
    return 0;
  }
  if (_C3DModelPathResolveEntity(a1, a2, a3, a4, a5)) {
    return 1;
  }
  C3DModelTargetSetTarget(a5, a1);
  if (a3 >= (int)a4)
  {
    *(void *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
  int v13 = _pathComponentForString(ValueAtIndex);
  if (v13 <= 37)
  {
    switch(v13)
    {
      case 1:
        int v16 = a3 + 1;
        uint64_t v14 = (char *)a1;
        CFArrayRef v15 = a2;
        goto LABEL_7;
      case 2:
        *(void *)(a5 + 24) = (char *)a1 + 204;
        uint64_t v17 = 1;
        *(_WORD *)(a5 + 32) = 1;
        return v17;
      case 3:
        *(void *)(a5 + 24) = (char *)a1 + 200;
        *(_WORD *)(a5 + 32) = 3;
        return 1;
      case 5:
      case 6:
      case 7:
      case 8:
      case 12:
      case 13:
        uint64_t v14 = (char *)a1;
        CFArrayRef v15 = a2;
        int v16 = a3;
LABEL_7:
        _C3DModelPathResolveNodeTransform(v14, v15, v16, a4, a5, a6);
        break;
      case 9:
        *(unsigned char *)(a5 + 34) = 8;
        uint64_t v19 = a1[12].i64[0];
        if (!v19)
        {
          long long v28 = 0u;
          long long v29 = 0u;
          *(_OWORD *)CFTypeRef cf = 0u;
          long long v27 = 0u;
          C3DMatrix4x4MakeIdentity((uint64_t)cf);
          C3DNodeSetPivotMatrix(a1, (long long *)cf);
          uint64_t v19 = a1[12].i64[0];
        }
        _C3DModelPathResolveMatrix(v19, a2, a3 + 1, a4, a5);
        return 1;
      case 10:
        if (a3 + 1 >= (int)a4) {
          goto LABEL_26;
        }
        CFDictionaryRef FiltersParamController = C3DNodeGetFiltersParamController((uint64_t)a1);
        if (!FiltersParamController) {
          goto LABEL_26;
        }
        _C3DModelPathResolveDynamicParameter(FiltersParamController, a2, a3 + 1, a4, a5, a6);
        break;
      default:
        goto LABEL_26;
    }
    return 1;
  }
  if (v13 > 74)
  {
    if (v13 == 75)
    {
      CFDictionaryRef Light = C3DNodeGetLight((uint64_t)a1);
      goto LABEL_32;
    }
    if (v13 == 88)
    {
      CFDictionaryRef Light = (const void *)C3DNodeGetMorpher((uint64_t)a1);
      goto LABEL_32;
    }
  }
  else
  {
    if (v13 == 38)
    {
      CFDictionaryRef Light = C3DNodeGetCamera((uint64_t)a1);
      goto LABEL_32;
    }
    if (v13 == 39)
    {
      CFDictionaryRef Light = (const void *)C3DNodeGetGeometry((uint64_t)a1);
LABEL_32:
      _C3DModelPathResolverRegistryResolvePath(Light, (uint64_t)a2, (a3 + 1), a4, a5, a6);
      return 1;
    }
  }
LABEL_26:
  cf[0] = 0;
  unsigned int v25 = 0;
  if (!_C3DModelPathResolveArray(a2, a3, a4, (SInt32 *)&v25, (CFStringRef *)cf)) {
    goto LABEL_35;
  }
  if (_pathComponentForString((void *)cf[0]) != 11)
  {
    if (cf[0]) {
      CFRelease(cf[0]);
    }
LABEL_35:
    if (a6)
    {
      uint64_t v23 = scn_default_log();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        _C3DModelPathResolveNode_cold_1();
      }
    }
    return 0;
  }
  ChildNodesCFIndex Count = C3DNodeGetChildNodesCount((uint64_t)a1);
  if (ChildNodesCount <= v25)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t ChildNodeAtIndex = C3DNodeGetChildNodeAtIndex((uint64_t)a1, v25);
    uint64_t v17 = _C3DModelPathResolveNode(ChildNodeAtIndex, a2, (a3 + 1), a4, a5, a6);
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v17;
}

CFDictionaryRef C3DEntityHasAttribute(uint64_t a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DEntityGetAttribute_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 40);
  if (result) {
    return (const __CFDictionary *)(CFDictionaryContainsKey(result, key) != 0);
  }
  return result;
}

uint64_t _C3DModelPathResolveScene(CFTypeRef cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  C3DModelTargetSetTarget(a5, cf);
  if (a3 >= a4)
  {
    *(void *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  else
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    unsigned int v13 = _pathComponentForString(ValueAtIndex);
    if (v13 == 91)
    {
      uint64_t v14 = 1;
      Backgrounduint64_t EffectSlot = (char *)C3DSceneGetBackgroundEffectSlot((uint64_t)cf, 1);
    }
    else
    {
      if (v13 != 92) {
        return 0;
      }
      uint64_t v14 = 1;
      Backgrounduint64_t EffectSlot = (char *)C3DSceneGetLightingEnvironmentEffectSlot((uint64_t)cf, 1);
    }
    C3DModelPathResolveCommonProfileProperty(BackgroundEffectSlot, a2, a3 + 1, a4, a5, a6);
  }
  return v14;
}

const void *C3DModelValueStorageGetModelValueIfAny(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DConstraintApplyIK_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t TargetAddress = (const void *)C3DModelTargetGetTargetAddress(a2);
  if (*(const void **)(a1 + 24) == TargetAddress) {
    return *(const void **)(a1 + 32);
  }
  *(void *)(a1 + 24) = TargetAddress;
  CFDictionaryRef result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), TargetAddress);
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t C3DModelTargetGetTargetAddress(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void sub_20B2699A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DCameraCreate()
{
  if (C3DCameraGetTypeID_onceToken != -1) {
    dispatch_once(&C3DCameraGetTypeID_onceToken, &__block_literal_global_61);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DCameraGetTypeID_typeID, 0x220uLL);
  if (C3DWasLinkedBeforeMajorOSYear2017()) {
    char v1 = 16;
  }
  else {
    char v1 = 0;
  }
  *(unsigned char *)(Instance + 64) = *(unsigned char *)(Instance + 64) & 0xEF | v1;
  *(void *)(Instance + 272) = 0;
  *(void *)(Instance + 280) = 0;
  *(_DWORD *)(Instance + 120) = 1114636288;
  *(void *)(Instance + 128) = 0x3FF8000000000000;
  *(_OWORD *)(Instance + 72) = xmmword_20B5EDCD0;
  *(void *)(Instance + 112) = 0x3FF0000000000000;
  *(void *)(Instance + 96) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(Instance + 104) = _D0;
  *(_DWORD *)(Instance + 448) = 0;
  *(_DWORD *)(Instance + 292) = 1112014848;
  *(void *)(Instance + 296) = 0x41C0000040B33333;
  *(void *)(Instance + 304) = 0x1900000006;
  int v7 = C3DWasLinkedBeforeMajorOSYear2017();
  float v8 = 2.5;
  if (v7) {
    float v8 = 10.0;
  }
  *(float *)(Instance + 288) = v8;
  *(void *)(Instance + 528) = -1;
  *(unsigned char *)(Instance + 312) &= ~1u;
  Identity = (long long *)C3DMatrix4x4GetIdentity();
  long long v10 = *Identity;
  long long v11 = Identity[1];
  long long v12 = Identity[3];
  *(_OWORD *)(Instance + 352) = Identity[2];
  *(_OWORD *)(Instance + 368) = v12;
  *(_OWORD *)(Instance + 320) = v10;
  *(_OWORD *)(Instance + 336) = v11;
  char v13 = *(unsigned char *)(Instance + 312);
  *(_OWORD *)(Instance + 384) = xmmword_20B5EDEF0;
  *(_OWORD *)(Instance + 400) = xmmword_20B5EDF00;
  *(unsigned char *)(Instance + 313) = 0;
  *(_OWORD *)(Instance + 416) = xmmword_20B5EDF10;
  *(void *)(Instance + 432) = 1;
  *(void *)(Instance + 440) = 0x3F80000040800000;
  *(unsigned char *)(Instance + 312) = v13 & 0xE9 | 4;
  *(void *)(Instance + 544) = 0;
  *(_DWORD *)(Instance + 552) = 0;
  *(_OWORD *)(Instance + 452) = xmmword_20B5CB7D0;
  *(_OWORD *)(Instance + 468) = xmmword_20B5CB6E0;
  *(_OWORD *)(Instance + 484) = xmmword_20B5EDF20;
  *(_DWORD *)(Instance + 500) = 1022739087;
  *(void *)(Instance + 504) = 0x3E99999A3E4CCCCDLL;
  *(void *)(Instance + 512) = 0x200000009;
  return Instance;
}

uint64_t C3DMatrix4x4GetIdentity()
{
  return MEMORY[0x263EF89A8];
}

void __C3DPreferencesGetInteger_block_invoke()
{
  id v1 = (id)CFPreferencesCopyAppValue(@"internalSettings", @"com.apple.scenekit");
  C3DPreferencesGetInteger_prefs = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceGLES"), "BOOLValue");
  qword_267697770 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceMetal"), "BOOLValue");
  qword_267697778 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"showsStatistics"), "BOOLValue");
  qword_267697780 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"cameraControlEnabled"), "BOOLValue");
  qword_267697788 = (int)objc_msgSend((id)objc_msgSend(v1, "valueForKey:", @"batchMaxCount"), "intValue");
  unk_267697790 = 0;
  qword_267697798 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"disableLinearSpaceRendering"), "BOOLValue");
  qword_2676977A0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"disableWideGamut"), "BOOLValue");
  qword_2676977A8 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"enableWideGamut"), "BOOLValue");
  qword_2676977B0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"enablePostMorphUnifyNormals"), "BOOLValue");
  qword_2676977C0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"enableStandardShadersWithFunctionConstants"), "BOOLValue");
  qword_2676977C8 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceNMOSBehavior"), "BOOLValue");
  qword_2676977D0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceOS2019Behavior"), "BOOLValue");
  qword_2676977D8 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceOS2018Behavior"), "BOOLValue");
  qword_2676977E0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceOS2017Behavior"), "BOOLValue");
  qword_2676977E8 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"forceOS2016Behavior"), "BOOLValue");
  unk_2676977F0 = 0;
  if ([v1 objectForKeyedSubscript:@"useOneCommandQueuePerDevice"]) {
    uint64_t v0 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"useOneCommandQueuePerDevice"), "BOOLValue");
  }
  else {
    uint64_t v0 = 1;
  }
  qword_2676977F8 = v0;
  qword_267697800 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"disableReverseZ"), "BOOLValue");
  qword_2676977B8 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"isolateCacheMissShader"), "BOOLValue");
}

uint64_t C3DCreateTangentsWithGeometryOptimized(uint64_t a1, int a2)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  NormalSource = C3DMeshGetNormalSource(a1, a2);
  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 3, 0, a2);
  if (!PositionSource && (uint64_t v15 = scn_default_log(), os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
    if (NormalSource) {
      goto LABEL_9;
    }
  }
  else if (NormalSource)
  {
    goto LABEL_9;
  }
  uint64_t v23 = scn_default_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
    C3DCreateTangentsWithGeometryOptimized_cold_6(v23, v24, v25, v26, v27, v28, v29, v30);
  }
LABEL_9:
  if (!SourceWithSemanticAtIndex)
  {
    long long v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_5(v31, v32, v33, v34, v35, v36, v37, v38);
    }
  }
  uint64_t Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
  if (!Content || (uint64_t v41 = v40, !v40))
  {
    BOOL v88 = scn_default_log();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
      C3DCreateTangentsWithGeometryOptimized_cold_4();
    }
    return 0;
  }
  uint64_t v42 = Content;
  *(void *)__int16 v116 = a1;
  uint64_t v43 = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
  if (!v43 || (unsigned __int8 v46 = v45, v44 != v41))
  {
    uint64_t v89 = scn_default_log();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
      C3DCreateTangentsWithGeometryOptimized_cold_3();
    }
    return 0;
  }
  uint64_t v47 = v43;
  uint64_t v48 = C3DMeshSourceGetContent((uint64_t)NormalSource);
  if (!v48 || v49 != v41)
  {
    unsigned int v90 = scn_default_log();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      C3DCreateTangentsWithGeometryOptimized_cold_2();
    }
    return 0;
  }
  uint64_t v113 = v48;
  uint64_t v110 = v41;
  unsigned __int8 v111 = v50;
  int v51 = (float32x4_t *)malloc_type_calloc(16 * v41, 1uLL, 0x338AE5ADuLL);
  CFIndex length = 16 * v41;
  unsigned int v52 = (float32x4_t *)malloc_type_calloc(length, 1uLL, 0x900F9350uLL);
  ElementsCFIndex Count = C3DMeshGetElementsCount(a1);
  unsigned int v112 = v41;
  if ((uint64_t)ElementsCount >= 1)
  {
    unsigned __int8 v54 = BYTE5(v41);
    CFIndex v55 = 0;
    char v56 = 0;
    uint64_t v57 = v54;
    uint64_t v58 = v46;
    uint64_t v59 = *(void *)v116;
    while (1)
    {
      uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v59, v55, 1);
      if (C3DMeshElementGetType((uint64_t)ElementAtIndex)
        && C3DMeshElementGetType((uint64_t)ElementAtIndex) != 1)
      {
        goto LABEL_48;
      }
      unsigned int v119 = 0;
      CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, &v119);
      if (!Indexes) {
        goto LABEL_48;
      }
      theDatSCNMatrix4 a = Indexes;
      BytePtr = CFDataGetBytePtr(Indexes);
      if (!BytePtr) {
        goto LABEL_48;
      }
      if (v119 == 1) {
        break;
      }
      if (v119 != 4)
      {
        if (v119 == 2)
        {
          unsigned int v114 = 0;
          unint64_t v63 = BytePtr;
        }
        else
        {
          int v64 = scn_default_log();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            uint64_t v121 = v119;
            _os_log_error_impl(&dword_20B249000, v64, OS_LOG_TYPE_ERROR, "Unreachable code: Unsupported index size (%zu)", buf, 0xCu);
          }
          unsigned int v114 = 0;
          unint64_t v63 = 0;
        }
        goto LABEL_33;
      }
      unsigned int v114 = 0;
      __int16 v115 = BytePtr;
      unint64_t v63 = 0;
LABEL_34:
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      CFIndex v66 = 3 * PrimitiveCount * v119;
      if (v66 > CFDataGetLength(theData))
      {
        free(v51);
        free(v52);
        uint64_t v107 = scn_default_log();
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
          C3DCreateTangentsWithGeometryOptimized_cold_1();
        }
        return 0;
      }
      if (PrimitiveCount < 1)
      {
        char v56 = 0;
        uint64_t v59 = *(void *)v116;
      }
      else
      {
        uint64_t v70 = 0;
        uint64_t v71 = 0;
        uint64_t v72 = 0;
        uint64_t v73 = (unsigned __int16 *)(v63 + 4);
        uint64_t v74 = (unsigned __int8 *)(v114 + 2);
        __int32 v75 = 0;
        SCNMatrix4 v76 = (unsigned int *)(v115 + 4);
        uint64_t v59 = *(void *)v116;
        do
        {
          if (v63)
          {
            uint64_t v72 = *(v73 - 2);
            uint64_t v71 = *(v73 - 1);
            uint64_t v70 = *v73;
          }
          else if (v115)
          {
            uint64_t v72 = *(v76 - 1);
            uint64_t v71 = *v76;
            uint64_t v70 = v76[1];
          }
          else if (v114)
          {
            uint64_t v72 = *(v74 - 2);
            uint64_t v71 = *(v74 - 1);
            uint64_t v70 = *v74;
          }
          float32x2_t v77 = *(float32x2_t *)(v47 + v72 * v58);
          float32x2_t v78 = vsub_f32(*(float32x2_t *)(v47 + v71 * v58), v77);
          float32x2_t v79 = vsub_f32(*(float32x2_t *)(v47 + v70 * v58), v77);
          float v80 = vmlas_n_f32((float)-v78.f32[1] * v79.f32[0], v79.f32[1], v78.f32[0]);
          if (v80 == 0.0)
          {
            float32x2_t v79 = vadd_f32(v79, (float32x2_t)0xB400000034000000);
            float32x2_t v78 = vadd_f32(v78, (float32x2_t)0xB4000000B4000000);
            float v80 = vmlas_n_f32((float)-v78.f32[1] * v79.f32[0], v79.f32[1], v78.f32[0]);
          }
          uint64_t v81 = v42 + v72 * v57;
          v67.i64[0] = *(void *)v81;
          v67.i32[2] = *(_DWORD *)(v81 + 8);
          uint64_t v82 = v42 + v71 * v57;
          v68.i64[0] = *(void *)v82;
          v68.i32[2] = *(_DWORD *)(v82 + 8);
          uint64_t v83 = v42 + v70 * v57;
          v69.i64[0] = *(void *)v83;
          v69.i32[2] = *(_DWORD *)(v83 + 8);
          float32x4_t v68 = vsubq_f32(v68, v67);
          float32x4_t v67 = vsubq_f32(v69, v67);
          float v84 = v80;
          float32x2_t v85 = vrecpe_f32((float32x2_t)LODWORD(v80));
          float32x2_t v86 = vmul_f32(v85, vrecps_f32((float32x2_t)LODWORD(v84), v85));
          v86.i32[0] = vmul_f32(v86, vrecps_f32((float32x2_t)LODWORD(v84), v86)).u32[0];
          float32x4_t v69 = vmulq_n_f32(vmlaq_lane_f32(vmulq_lane_f32(vnegq_f32(v67), v78, 1), v68, v79, 1), v86.f32[0]);
          v69.i32[3] = v75;
          v51[v72] = vaddq_f32(v51[v72], v69);
          v51[v71] = vaddq_f32(v51[v71], v69);
          v51[v70] = vaddq_f32(v51[v70], v69);
          float32x4_t v87 = vmulq_n_f32(vmlaq_n_f32(vmulq_f32(v68, vnegq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v79, 0))), v67, v78.f32[0]), v86.f32[0]);
          v87.i32[3] = 0;
          v52[v72] = vaddq_f32(v87, v52[v72]);
          v52[v71] = vaddq_f32(v87, v52[v71]);
          v52[v70] = vaddq_f32(v87, v52[v70]);
          v73 += 3;
          v74 += 3;
          v76 += 3;
          __int32 v75 = v69.i32[3];
          --PrimitiveCount;
        }
        while (PrimitiveCount);
        char v56 = 1;
      }
LABEL_48:
      if ((const __CFArray *)++v55 == ElementsCount) {
        goto LABEL_57;
      }
    }
    unint64_t v63 = 0;
    unsigned int v114 = BytePtr;
LABEL_33:
    __int16 v115 = 0;
    goto LABEL_34;
  }
  char v56 = 0;
LABEL_57:
  unint64_t v91 = 0;
  unsigned int v92 = 0;
  if (v112 <= 1) {
    unsigned int v93 = 1;
  }
  else {
    unsigned int v93 = v112;
  }
  uint64_t v94 = 16 * v93;
  do
  {
    uint64_t v95 = v113 + v92;
    v53.i64[0] = *(void *)v95;
    float32x4_t v96 = v53;
    v96.i32[2] = *(_DWORD *)(v95 + 8);
    v53.i32[2] = v96.i32[2];
    float32x4_t v97 = v51[v91 / 0x10];
    float32x4_t v98 = vmulq_f32(v97, v53);
    float32x4_t v99 = vmlsq_lane_f32(v97, v96, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 2), vaddq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.f32, 1))), 0);
    int32x4_t v100 = (int32x4_t)vmulq_f32(v99, v99);
    v100.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v100, 2), vadd_f32(*(float32x2_t *)v100.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v100.i8, 1))).u32[0];
    float32x2_t v101 = vrsqrte_f32((float32x2_t)v100.u32[0]);
    float32x4_t v53 = vmulq_n_f32(v99, vmul_f32(v101, vrsqrts_f32((float32x2_t)v100.u32[0], vmul_f32(v101, v101))).f32[0]);
    int32x4_t v102 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), vnegq_f32(v96)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), (int8x16_t)v96, 0xCuLL));
    float32x4_t v103 = vmulq_f32(v52[v91 / 0x10], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v102, v102), (int8x16_t)v102, 0xCuLL));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v103, 2), vaddq_f32(v103, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v103.f32, 1))).f32[0] < 0.0)float v104 = -1.0; {
    else
    }
      float v104 = 1.0;
    v53.f32[3] = v104;
    v51[v91 / 0x10] = v53;
    v92 += v111;
    v91 += 16;
  }
  while (v94 != v91);
  free(v52);
  if ((v56 & 1) == 0)
  {
    free(v51);
    return 0;
  }
  CFDataRef v105 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v51, length, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  uint64_t v106 = C3DMeshSourceCreate(v105, 4, v110, 4, 1);
  CFRelease(v105);
  return v106;
}

uint64_t C3DMeshCreateTangentsIfNeeded(uint64_t a1, int a2)
{
  if (C3DMeshGetSourceWithSemanticAtIndex(a1, 4, 0, a2)) {
    return 1;
  }
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  if (PositionSource)
  {
    uint64_t v6 = (uint64_t)PositionSource;
    unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
    NormalSource = C3DMeshGetNormalSource(a1, a2);
    if (!NormalSource)
    {
      uint64_t result = C3DCreateNormalsWithMesh(a1, a2, 0);
      if (!result) {
        return result;
      }
      NormalSource = (const void *)result;
      if (a2 == 1)
      {
        __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, (const void *)result, 0);
      }
      else if (!a2)
      {
        C3DMeshSetSourceWithInputSet(a1, (const void *)result, 0, ChannelForSourceWithSemanticAtIndex);
      }
      CFRelease(NormalSource);
    }
    SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 3, 0, a2);
    if (SourceWithSemanticAtIndex)
    {
      uint64_t v11 = (uint64_t)SourceWithSemanticAtIndex;
      C3DMeshSourceGetContent(v6);
      unint64_t v13 = v12;
      C3DMeshSourceGetContent((uint64_t)NormalSource);
      unint64_t v15 = v14;
      C3DMeshSourceGetContent(v11);
      if ((v13 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v13) >= 3
        && (v15 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v15) >= 3
        && (v16 & 0xFF000000000000) == 0x1000000000000
        && v16 >> 57)
      {
        uint64_t v17 = C3DCreateTangentsWithGeometryOptimized(a1, a2);
      }
      else
      {
        uint64_t v17 = C3DCreateTangentsWithGeometry(a1, a2);
      }
      uint64_t v24 = (const void *)v17;
      if (v17)
      {
LABEL_32:
        if (a2 == 1)
        {
          __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, v24, 0);
        }
        else if (!a2)
        {
          C3DMeshSetSourceWithInputSet(a1, v24, 0, ChannelForSourceWithSemanticAtIndex);
        }
        CFRelease(v24);
        return 1;
      }
    }
    else
    {
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        C3DMeshCreateTangentsIfNeeded_cold_3();
      }
      uint64_t Count = C3DMeshSourceGetCount(v6);
      uint64_t v20 = 16 * Count;
      uint64_t v21 = (UInt8 *)malloc_type_calloc(16 * Count, 1uLL, 0xBB9B5AC7uLL);
      uint64_t v22 = v21;
      if (Count >= 1) {
        memset_pattern16(v21, &xmmword_20B5CB530, v20);
      }
      CFDataRef v23 = CFDataCreateWithBytesNoCopy(0, v22, v20, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
      uint64_t v24 = (const void *)C3DMeshSourceCreate(v23, 4, Count, 4, 1);
      CFRelease(v23);
      if (v24) {
        goto LABEL_32;
      }
    }
    uint64_t v25 = scn_default_log();
    uint64_t result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (result)
    {
      C3DMeshCreateTangentsIfNeeded_cold_2();
      return 0;
    }
  }
  else
  {
    uint64_t v9 = scn_default_log();
    uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (result)
    {
      C3DMeshCreateTangentsIfNeeded_cold_1();
      return 0;
    }
  }
  return result;
}

const void *C3DMeshGetPositionSource(uint64_t a1, int a2)
{
  return C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, a2);
}

const void *C3DMeshGetNormalSource(uint64_t a1, int a2)
{
  return C3DMeshGetSourceWithSemanticAtIndex(a1, 1, 0, a2);
}

uint64_t __C3DMeshSetSourceWithInputSetAndDataKind(uint64_t a1, const void *a2, uint64_t a3, int a4, int a5)
{
  if (!a1 && (uint64_t v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    C3DMeshSourceCreateWithAccessor_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (a4 && a5 == 1)
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      __C3DMeshSetSourceWithInputSetAndDataKind_cold_3(v26, v27, v28, v29, v30, v31, v32, v33);
    }
    goto LABEL_13;
  }
  if (a5 == 1)
  {
LABEL_13:
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v34 = a1 + 112;
    goto LABEL_17;
  }
  if (a5)
  {
    uint64_t v35 = scn_default_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v35, v36, v37, v38, v39, v40, v41, v42);
    }
    uint64_t v34 = 0;
  }
  else
  {
    uint64_t v34 = a1 + 64;
  }
LABEL_17:
  SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)a2);
  uint64_t v44 = v34 + 2 * Semantic;
  uint64_t v47 = *(char *)(v44 + 8);
  uint64_t v46 = v44 + 8;
  uint64_t v45 = v47;
  if (v47 != -1 && *(unsigned __int8 *)(v46 + 1) > a3)
  {
    CFIndex v48 = v45 + a3;
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)v34, v48, a2);
    if (a4 != 255) {
      *(unsigned char *)(*(void *)(v34 + 40) + v48) = a4;
    }
    if (a5) {
      goto LABEL_43;
    }
    goto LABEL_40;
  }
  if (a4 == 255)
  {
    int v49 = scn_default_log();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
    {
      __C3DMeshSetSourceWithInputSetAndDataKind_cold_1(v49, v50, v51, v52, v53, v54, v55, v56);
      if ((Semantic & 0x80000000) == 0) {
        goto LABEL_26;
      }
LABEL_29:
      CFIndex v63 = 0;
LABEL_30:
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)v34);
      CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)v34, v63, a2);
      if (a5)
      {
        __BuildRenderableSourceChannelsAndSemanticInfos(a1);
LABEL_43:
        CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
        uint64_t v66 = 1;
        CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", (const void *)a1, 0, 1u);
        ++*(void *)(a1 + 208);
        return v66;
      }
      float32x4_t v67 = *(void **)(a1 + 152);
      if (v67)
      {
        free(v67);
        *(void *)(a1 + 152) = 0;
      }
      float32x4_t v68 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x9AF01975uLL);
      *(void *)(a1 + 104) = v68;
      if (Count > v63)
      {
        do
        {
          *(unsigned char *)(*(void *)(a1 + 104) + Count) = *(unsigned char *)(*(void *)(a1 + 104) + Count - 1);
          --Count;
        }
        while (Count > v63);
        float32x4_t v68 = *(unsigned char **)(a1 + 104);
      }
      v68[v63] = a4;
      __BuildSemanticInfosForData(a1, v34);
LABEL_40:
      __UpdateSourcesMutability(a1);
      if (!Semantic) {
        C3DMeshResetBoundingVolumes(a1);
      }
      __C3DMeshInvalidateRenderableData(a1);
      goto LABEL_43;
    }
  }
  if (Semantic < 0) {
    goto LABEL_29;
  }
LABEL_26:
  unsigned __int8 v57 = Semantic;
  while (1)
  {
    uint64_t v58 = v34 + 2 * v57;
    uint64_t v61 = *(char *)(v58 + 8);
    uint64_t v60 = v58 + 8;
    uint64_t v59 = v61;
    if (v61 != -1) {
      break;
    }
    int v62 = (char)v57--;
    if (v62 < 1) {
      goto LABEL_29;
    }
  }
  uint64_t v65 = *(unsigned __int8 *)(v60 + 1);
  if (v65 >= a3)
  {
    CFIndex v63 = v65 + v59;
    goto LABEL_30;
  }
  return 0;
}

uint64_t __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(uint64_t a1, const void *a2, uint64_t a3)
{
  return __C3DMeshSetSourceWithInputSetAndDataKind(a1, a2, a3, 0, 1);
}

uint64_t C3DMeshGetChannelForSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3)
{
  int v3 = a3;
  char v4 = a2;
  uint64_t v6 = __indexOfSourceWithSemanticAtIndex(a1, a2, a3, 0);
  if (v6 == -1)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DMeshGetChannelForSourceWithSemanticAtIndex_cold_1(v4, v3, v7);
    }
  }
  return *(unsigned __int8 *)(*(void *)(a1 + 104) + v6);
}

void _C3DProgramHashCodeCFFinalize(uint64_t a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationProgramHashCodeWillDie", (const void *)a1, 0, 0);
  if (!CFDictionaryContainsKey((CFDictionaryRef)s_ProgramHashCodeDictionary, *(const void **)(a1 + 280)))
  {
    int v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      _C3DProgramHashCodeCFFinalize_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  if (!*(void *)(a1 + 280))
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      _C3DProgramHashCodeCFFinalize_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  CFDictionaryRemoveValue((CFMutableDictionaryRef)s_ProgramHashCodeDictionary, *(const void **)(a1 + 280));
  uint64_t v19 = *(const void **)(a1 + 280);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 280) = 0;
  }
  uint64_t v20 = 0;
  uint64_t v21 = a1 + 16;
  char v22 = 1;
  do
  {
    char v23 = v22;
    uint64_t v24 = *(const void **)(v21 + 8 * v20);
    if (v24)
    {
      CFRelease(v24);
      *(void *)(v21 + 8 * v20) = 0;
    }
    char v22 = 0;
    uint64_t v20 = 1;
  }
  while ((v23 & 1) != 0);
  unsigned int v25 = *(unsigned __int8 *)(a1 + 162);
  if (*(unsigned char *)(a1 + 162))
  {
    unint64_t v26 = 0;
    uint64_t v27 = a1 + 216;
    do
    {
      uint64_t v28 = *(const void **)(v27 + 8 * v26);
      if (v28)
      {
        CFRelease(v28);
        *(void *)(v27 + 8 * v26) = 0;
        unsigned int v25 = *(unsigned __int8 *)(a1 + 162);
      }
      ++v26;
    }
    while (v26 < v25);
  }
}

id _C3DMaterialCFFinalize(uint64_t a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationMaterialWillDie", (const void *)a1, 0, 1u);
  int v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 72) = 0;
  }
  C3DRasterizerStatesRelease(*(CFTypeRef *)(a1 + 80));

  return C3DEntityCFFinalize(a1);
}

void _C3DEffectCommonProfileCFFinalize(void *a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationProfileWillDie", a1, 0, 1u);
  if (a1)
  {
    int v3 = (void *)a1[4];
    if (v3) {
      v3[10] = 0;
    }
    uint64_t v4 = (void *)a1[5];
    if (v4) {
      v4[10] = 0;
    }
    uint64_t v5 = a1[6];
    if (v5) {
      *(void *)(v5 + 80) = 0;
    }
    uint64_t v6 = a1[7];
    if (v6) {
      *(void *)(v6 + 80) = 0;
    }
    uint64_t v7 = a1[8];
    if (v7) {
      *(void *)(v7 + 80) = 0;
    }
    uint64_t v8 = a1[9];
    if (v8) {
      *(void *)(v8 + 80) = 0;
    }
    uint64_t v9 = a1[10];
    if (v9) {
      *(void *)(v9 + 80) = 0;
    }
    uint64_t v10 = a1[11];
    if (v10) {
      *(void *)(v10 + 80) = 0;
    }
    uint64_t v11 = a1[13];
    if (v11) {
      *(void *)(v11 + 80) = 0;
    }
    uint64_t v12 = a1[12];
    if (v12) {
      *(void *)(v12 + 80) = 0;
    }
    uint64_t v13 = a1[14];
    if (v13) {
      *(void *)(v13 + 80) = 0;
    }
    uint64_t v14 = a1[15];
    if (v14) {
      *(void *)(v14 + 80) = 0;
    }
    uint64_t v15 = a1[16];
    if (v15) {
      *(void *)(v15 + 80) = 0;
    }
    uint64_t v16 = a1[17];
    if (v16) {
      *(void *)(v16 + 80) = 0;
    }
    uint64_t v17 = a1[18];
    if (v17) {
      *(void *)(v17 + 80) = 0;
    }
    uint64_t v18 = a1[19];
    if (v18) {
      *(void *)(v18 + 80) = 0;
    }
    if (v3)
    {
      CFRelease(v3);
      a1[4] = 0;
      uint64_t v4 = (void *)a1[5];
    }
    if (v4)
    {
      CFRelease(v4);
      a1[5] = 0;
    }
    uint64_t v19 = (const void *)a1[6];
    if (v19)
    {
      CFRelease(v19);
      a1[6] = 0;
    }
    uint64_t v20 = (const void *)a1[7];
    if (v20)
    {
      CFRelease(v20);
      a1[7] = 0;
    }
    uint64_t v21 = (const void *)a1[8];
    if (v21)
    {
      CFRelease(v21);
      a1[8] = 0;
    }
    char v22 = (const void *)a1[9];
    if (v22)
    {
      CFRelease(v22);
      a1[9] = 0;
    }
    char v23 = (const void *)a1[10];
    if (v23)
    {
      CFRelease(v23);
      a1[10] = 0;
    }
    uint64_t v24 = (const void *)a1[11];
    if (v24)
    {
      CFRelease(v24);
      a1[11] = 0;
    }
    unsigned int v25 = (const void *)a1[13];
    if (v25)
    {
      CFRelease(v25);
      a1[13] = 0;
    }
    unint64_t v26 = (const void *)a1[12];
    if (v26)
    {
      CFRelease(v26);
      a1[12] = 0;
    }
    uint64_t v27 = (const void *)a1[14];
    if (v27)
    {
      CFRelease(v27);
      a1[14] = 0;
    }
    uint64_t v28 = (const void *)a1[15];
    if (v28)
    {
      CFRelease(v28);
      a1[15] = 0;
    }
    uint64_t v29 = (const void *)a1[17];
    if (v29)
    {
      CFRelease(v29);
      a1[17] = 0;
    }
    uint64_t v30 = (const void *)a1[18];
    if (v30)
    {
      CFRelease(v30);
      a1[18] = 0;
    }
    uint64_t v31 = (const void *)a1[19];
    if (v31)
    {
      CFRelease(v31);
      a1[19] = 0;
    }
    uint64_t v32 = (const void *)a1[16];
    if (v32)
    {
      CFRelease(v32);
      a1[16] = 0;
    }
  }
}

uint64_t C3DNotificationCenterGetSharedInstance()
{
  if (C3DNotificationCenterGetSharedInstance_onceToken != -1) {
    dispatch_once(&C3DNotificationCenterGetSharedInstance_onceToken, &__block_literal_global_4_4);
  }
  return C3DNotificationCenterGetSharedInstance_sharedInstance;
}

void C3DNotificationCenterPostNotification(uint64_t a1, const __CFString *a2, const void *a3, const __CFDictionary *a4, Boolean a5)
{
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();

  CFNotificationCenterPostNotification(LocalCenter, a2, a3, a4, a5);
}

id C3DEntitySetObjCWrapper(uint64_t a1, id obj)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return objc_storeWeak((id *)(a1 + 16), obj);
}

uint64_t C3DMeshSourceCreateWithData(__int16 a1, const void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a2)
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithData_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (a4 >= 5)
  {
    char v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithData_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t v30 = (const void *)C3DSourceAccessorCreate(a3, a4, a5, a6, a7);
  uint64_t v31 = C3DMeshSourceCreateWithAccessor(v30, a1);
  *(void *)(v31 + 72) = CFRetain(a2);
  C3DSourceAccessorSetSource((uint64_t)v30, v31);
  if (v30) {
    CFRelease(v30);
  }
  return v31;
}

void C3DSourceAccessorSetSource(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 16) = a2;
  if (a2)
  {
    OwnDatSCNMatrix4 a = (const __CFData *)C3DGenericSourceGetOwnData(a2);
    if (OwnData)
    {
      unint64_t Length = CFDataGetLength(OwnData);
      if (Length || *(void *)(a1 + 32) && (C3DGenericSourceIsMutable(a2) & 1) == 0)
      {
        if (*(void *)(a1 + 48) >= Length)
        {
          uint64_t v12 = scn_default_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            uint64_t v13 = *(void *)(a1 + 48);
            uint64_t v14 = *(void *)(a1 + 32);
            int v18 = 134218496;
            unint64_t v19 = Length;
            __int16 v20 = 2048;
            uint64_t v21 = v13;
            __int16 v22 = 1024;
            int v23 = v14;
            _os_log_error_impl(&dword_20B249000, v12, OS_LOG_TYPE_ERROR, "Error: C3DSourceAccessorSetSource - source has insufficient data (length %zu for offset %zu) ; count capped to 0 (was %d)",
              (uint8_t *)&v18,
              0x1Cu);
          }
          *(void *)(a1 + 32) = 0;
        }
        else
        {
          uint64_t v6 = C3DSizeOfBaseType(*(__int16 *)(a1 + 24));
          unint64_t v7 = *(void *)(a1 + 40);
          unint64_t v8 = Length - *(void *)(a1 + 48);
          unint64_t v9 = v8 / v7;
          if (v8 % v7 < v6 * (unint64_t)*(unsigned __int16 *)(a1 + 26)) {
            uint64_t v10 = v9;
          }
          else {
            uint64_t v10 = (v9 + 1);
          }
          if (*(void *)(a1 + 32) > v10)
          {
            uint64_t v11 = scn_default_log();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              int v15 = *(_DWORD *)(a1 + 32);
              uint64_t v17 = *(void *)(a1 + 40);
              uint64_t v16 = *(void *)(a1 + 48);
              int v18 = 134219264;
              unint64_t v19 = Length;
              __int16 v20 = 2048;
              uint64_t v21 = v16;
              __int16 v22 = 1024;
              int v23 = v15;
              __int16 v24 = 2048;
              uint64_t v25 = v17;
              __int16 v26 = 1024;
              int v27 = v10;
              __int16 v28 = 1024;
              int v29 = v15;
              _os_log_error_impl(&dword_20B249000, v11, OS_LOG_TYPE_ERROR, "Error: C3DSourceAccessorSetSource - source has insufficient data (length %zu for offset %zu, count %d and stride %zu) ; count capped to %d (was %d)",
                (uint8_t *)&v18,
                0x32u);
            }
            *(void *)(a1 + 32) = v10;
          }
        }
      }
    }
  }
}

uint64_t C3DSourceAccessorCreate(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = _C3DSourceAccessorCreate();
  *(_WORD *)(v10 + 24) = a1;
  *(_WORD *)(v10 + 26) = a2;
  if (!a4) {
    a4 = C3DSizeOfBaseType(a1) * a2;
  }
  *(void *)(v10 + 32) = a3;
  *(void *)(v10 + 40) = a4;
  *(void *)(v10 + 48) = a5;
  *(void *)(v10 + 56) = 0;
  return v10;
}

uint64_t _C3DSourceAccessorCreate()
{
  if (C3DSourceAccessorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSourceAccessorGetTypeID_onceToken, &__block_literal_global_88);
  }
  CFTypeID v0 = C3DSourceAccessorGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x30uLL);
}

uint64_t C3DMeshSourceCreateWithAccessor(const void *a1, __int16 a2)
{
  uint64_t v4 = _C3DMeshSourceCreate();
  if (!v4)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  C3DGenericSourceInit(v4, a1);
  *(_WORD *)(v4 + 96) = a2;
  return v4;
}

uint64_t _C3DMeshSourceCreate()
{
  if (C3DMeshSourceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshSourceGetTypeID_onceToken, &__block_literal_global_17);
  }
  CFTypeID v0 = C3DMeshSourceGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x58uLL);
}

CFTypeRef C3DGenericSourceInit(uint64_t a1, CFTypeRef cf)
{
  if (!cf && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DSourceAccessorGetData_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationCopy_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  *(void *)(a1 + 64) = cf;
  return CFRetain(cf);
}

uint64_t SCNGeometrySourceSemanticToMeshSourceSemantic(void *a1)
{
  if ([a1 isEqualToString:@"kGeometrySourceSemanticVertex"]) {
    return 0;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticNormal"]) {
    return 1;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticColor"]) {
    return 2;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticTexcoord"]) {
    return 3;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticTangent"]) {
    return 4;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticVertexCrease"]) {
    return 7;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticEdgeCrease"]) {
    return 8;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticBoneIndices"]) {
    return 5;
  }
  if ([a1 isEqualToString:@"kGeometrySourceSemanticBoneWeights"]) {
    return 6;
  }
  return 0;
}

void C3DMeshSourceSetModelKitSemantic(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 99) = a2;
}

uint64_t C3DMaterialCreate()
{
  if (C3DMaterialGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMaterialGetTypeID_onceToken, &__block_literal_global_64);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DMaterialGetTypeID_typeID, 0x58uLL);
  *(void *)(Instance + 64) = C3DEffectCommonProfileCreate(Instance);
  *(unsigned char *)(Instance + 100) = 0;
  *(_WORD *)(Instance + 92) = 3840;
  *(_DWORD *)(Instance + 88) = 257;
  __RasterizerStatesDidChange(Instance);
  return Instance;
}

uint64_t __RasterizerStatesDidChange(uint64_t a1)
{
  C3DRasterizerStatesRelease(*(CFTypeRef *)(a1 + 80));
  memset(v5, 0, 28);
  C3DRasterizerStatesDescGetDefault(v5);
  if (*(unsigned char *)(a1 + 100)) {
    int v2 = 2;
  }
  else {
    int v2 = *(unsigned __int8 *)(a1 + 90);
  }
  *(void *)&v5[0] = __PAIR64__(*(unsigned __int8 *)(a1 + 91), v2);
  BYTE8(v5[0]) = *(unsigned char *)(a1 + 89) != 0;
  BYTE9(v5[0]) = *(unsigned char *)(a1 + 88) != 0;
  v4[0] = v5[0];
  *(_OWORD *)((char *)v4 + 12) = *(_OWORD *)((char *)v5 + 12);
  uint64_t result = C3DRasterizerStatesCreate((uint64_t)v4);
  *(void *)(a1 + 80) = result;
  return result;
}

void C3DRasterizerStatesRelease(CFTypeRef cf)
{
  if (cf)
  {
    if (*((unsigned char *)cf + 44))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
      CFRelease(cf);
      os_unfair_lock_unlock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
    }
    else
    {
      CFRelease(cf);
    }
  }
}

double C3DRasterizerStatesDescGetDefault@<D0>(_OWORD *a1@<X8>)
{
  *a1 = kDefaultRasterizerStatesDesc;
  double result = *(double *)((char *)&kDefaultRasterizerStatesDesc + 12);
  *(_OWORD *)((char *)a1 + 12) = *(long long *)((char *)&kDefaultRasterizerStatesDesc + 12);
  return result;
}

uint64_t C3DRasterizerStatesCreate(uint64_t a1)
{
  if (C3DRasterizerStatesCreate_once != -1) {
    dispatch_once(&C3DRasterizerStatesCreate_once, &__block_literal_global_4_5);
  }
  if (!*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 10) = 1;
  }
  if (*(unsigned char *)(a1 + 11))
  {
    if (*(unsigned char *)(a1 + 12)) {
      goto LABEL_10;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 13) = 16776961;
    *(unsigned char *)(a1 + 12) = 0;
  }
  *(_DWORD *)(a1 + 23) = 0;
  *(_DWORD *)(a1 + 20) = 16776961;
LABEL_10:
  os_unfair_lock_lock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
  if (C3DRasterizerStatesGetTypeID_onceToken[0] != -1) {
    dispatch_once(C3DRasterizerStatesGetTypeID_onceToken, &__block_literal_global_118);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DRasterizerStatesGetTypeID_typeID, 0x20uLL);
  long long v3 = *(_OWORD *)(a1 + 12);
  *(_OWORD *)(Instance + 16) = *(_OWORD *)a1;
  *(_OWORD *)(Instance + 28) = v3;
  CFDictionaryRef Value = CFSetGetValue((CFSetRef)s_RasterizerStatesRegistry, (const void *)Instance);
  if (Value)
  {
    uint64_t v5 = (uint64_t)Value;
    CFRetain(Value);
    C3DRasterizerStatesRelease((CFTypeRef)Instance);
    uint64_t Instance = v5;
  }
  else
  {
    CFSetSetValue((CFMutableSetRef)s_RasterizerStatesRegistry, (const void *)Instance);
    *(unsigned char *)(Instance + 44) = 1;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
  return Instance;
}

uint64_t C3DEffectCommonProfileCreate(uint64_t a1)
{
  if (C3DEffectCommonProfileGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEffectCommonProfileGetTypeID_onceToken, &__block_literal_global_53);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DEffectCommonProfileGetTypeID_typeID, 0xB8uLL);
  uint64_t v3 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    _C3DEffectCommonProfileSetDefaultValues(Instance);
  }
  return v3;
}

uint64_t _C3DEffectCommonProfileSetDefaultValues(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  C3DEffectCommonProfileSetLightingModel(a1, 3);
  for (uint64_t i = 0; i != 16; ++i)
    _C3DEffectCommonProfileReleaseSlot((CFTypeRef *)a1, byte_20B5ED9D0[i]);
  for (uint64_t j = 0; j != 5; ++j)
  {
    if (j == 4) {
      float v12 = 0.0;
    }
    else {
      float v12 = 1.0;
    }
    C3DEffectCommonProfileSetFloatProperty(a1, byte_20B5ED9E0[j], v12);
  }
  C3DEffectCommonProfileSetImageProxy(a1, 2, 0);
  *(unsigned char *)(a1 + 180) = 0;
  __int16 v13 = *(_WORD *)(a1 + 194);
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 192) = 1;
  *(_WORD *)(a1 + 194) = v13 & 0xFE2C;
  uint64_t result = C3DWasLinkedBeforeMajorOSYear2014();
  *(unsigned char *)(a1 + 193) = result ^ 1;
  return result;
}

void _C3DEffectCommonProfileReleaseSlot(CFTypeRef *a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DEffectCommonProfileReleaseSlot_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  switch(a2)
  {
    case 0:
      float v12 = a1 + 4;
      goto LABEL_21;
    case 1:
      float v12 = a1 + 5;
      goto LABEL_21;
    case 2:
      float v12 = a1 + 6;
      goto LABEL_21;
    case 3:
      float v12 = a1 + 7;
      goto LABEL_21;
    case 4:
      float v12 = a1 + 8;
      goto LABEL_21;
    case 5:
      float v12 = a1 + 9;
      goto LABEL_21;
    case 6:
      float v12 = a1 + 10;
      goto LABEL_21;
    case 7:
      float v12 = a1 + 11;
      goto LABEL_21;
    case 8:
      float v12 = a1 + 13;
      goto LABEL_21;
    case 9:
      float v12 = a1 + 12;
      goto LABEL_21;
    case 10:
      float v12 = a1 + 14;
      goto LABEL_21;
    case 11:
      float v12 = a1 + 15;
      goto LABEL_21;
    case 12:
      float v12 = a1 + 17;
      goto LABEL_21;
    case 13:
      float v12 = a1 + 18;
      goto LABEL_21;
    case 14:
      float v12 = a1 + 19;
      goto LABEL_21;
    case 15:
      float v12 = a1 + 16;
LABEL_21:
      if (*v12)
      {
        CFRelease(*v12);
        *float v12 = 0;
      }
      break;
    default:
      return;
  }
}

void C3DEffectCommonProfileSetFloatProperty(uint64_t a1, int a2, float a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  switch(a2)
  {
    case 16:
      *(float *)(a1 + 160) = a3;
      goto LABEL_16;
    case 18:
      float v14 = *(float *)(a1 + 164);
      if (v14 == a3) {
        return;
      }
      *(float *)(a1 + 164) = a3;
      BOOL v16 = v14 == 1.0 || v14 == 0.0 || a3 == 0.0;
      __int16 v17 = (a3 != 1.0) << 7;
      if (v16) {
        __int16 v17 = 0;
      }
      *(_WORD *)(a1 + 194) = *(_WORD *)(a1 + 194) & 0xFF7F | v17;
      goto LABEL_16;
    case 19:
      float v18 = *(float *)(a1 + 168);
      if (v18 != a3)
      {
        *(float *)(a1 + 168) = a3;
        if (a3 == 0.0 || v18 == 0.0) {
          goto LABEL_16;
        }
      }
      return;
    case 20:
      float v19 = *(float *)(a1 + 172);
      if (v19 == a3) {
        return;
      }
      *(float *)(a1 + 172) = a3;
      if (a3 == 0.0 || v19 == 0.0) {
LABEL_16:
      }
        __PostCommonProfileDidChangeNotification(a1);
      else {
        C3DMaterialTouchValueStorageModificationCount(*(void *)(a1 + 16));
      }
      return;
    default:
      return;
  }
}

void C3DEffectCommonProfileSetLightingModel(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 24) != a2)
  {
    *(_DWORD *)(a1 + 24) = a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

uint64_t C3DWasLinkedBeforeMajorOSYear2014()
{
  if (C3DWasLinkedBeforeMajorOSYear2014_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2014_onceToken, &__block_literal_global_2);
  }
  return C3DWasLinkedBeforeMajorOSYear2014_linkedBeforeMajorOSYear2014;
}

void C3DEffectCommonProfileSetImageProxy(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot) {
    C3DEffectSlotSetImageProxy(EffectSlot, a3);
  }
  *(_WORD *)(a1 + 196) &= 0xE000u;
}

uint64_t C3DGeometryCreate()
{
  if (C3DGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DGeometryGetTypeID_typeID, 0xC8uLL);
  *(void *)(Instance + 80) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  *(void *)(Instance + 104) = 0;
  *(unsigned char *)(Instance + 208) = 0;
  *(void *)(Instance + 120) = 0;
  *(void *)(Instance + 128) = 0;
  C3DGeometryInitSubdivision(Instance);
  return Instance;
}

double C3DGeometryInitSubdivision(uint64_t a1)
{
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(unsigned char *)(a1 + 137) = C3DWasLinkedBeforeMajorOSYear2017() ^ 1;
  *(void *)&double result = 17105153;
  *(_DWORD *)(a1 + 138) = 17105153;
  return result;
}

uint64_t C3DGeometryOsdGetWantsAdaptiveSubdivision(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 137);
}

uint64_t C3DGeometryOsdGetSubdivisionSettings(uint64_t a1)
{
  return *(unsigned int *)(a1 + 138);
}

uint64_t C3DGeometryOsdGetEdgeCreasesSource(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

uint64_t C3DGeometryOsdGetEdgeCreasesElement(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

void __buildSourceChannels(void *a1, size_t a2, void *a3, unsigned char *a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  unsigned int v8 = [a1 count];
  if (v8)
  {
    uint64_t v9 = [a3 count];
    if (v9)
    {
      uint64_t v10 = 0;
      unsigned int v11 = 0;
      do
      {
        unsigned __int8 v12 = objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", v10), "indicesChannelCount");
        if (v10)
        {
          unsigned int v13 = v12;
          if (v12 != v11)
          {
            float v14 = scn_default_log();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_20B249000, v14, OS_LOG_TYPE_DEFAULT, "Warning: Found elements with different channel counts in the same geometry", buf, 2u);
            }
            if (v13 < v11) {
              unsigned int v11 = v13;
            }
          }
        }
        else
        {
          unsigned int v11 = v12;
        }
        ++v10;
      }
      while (v9 != v10);
      if (!a2) {
        return;
      }
    }
    else
    {
      unsigned int v11 = 0;
      if (!a2) {
        return;
      }
    }
    size_t v15 = 0;
    unsigned int v16 = 1;
    while (1)
    {
      if (v16 - 1 >= v8)
      {
        int v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          unsigned int v25 = v16 - 1;
          __int16 v20 = v23;
          uint64_t v21 = "Error: Missing channel for source at index %u";
          uint32_t v22 = 8;
          goto LABEL_30;
        }
      }
      else
      {
        signed int v17 = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v15), "intValue");
        unsigned int v18 = v17;
        if ((v17 & 0x80000000) == 0 && v17 <= (int)v11) {
          goto LABEL_27;
        }
        float v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          unsigned int v25 = v18;
          __int16 v26 = 1024;
          unsigned int v27 = v16 - 1;
          __int16 v20 = v19;
          uint64_t v21 = "Error: Invalid channel (%d) for source at index %u";
          uint32_t v22 = 14;
LABEL_30:
          _os_log_error_impl(&dword_20B249000, v20, OS_LOG_TYPE_ERROR, v21, buf, v22);
        }
      }
      LOBYTE(v18) = 0;
LABEL_27:
      a4[v15] = v18;
      size_t v15 = v16++;
      if (v15 >= a2) {
        return;
      }
    }
  }

  bzero(a4, a2);
}

uint64_t C3DMeshCreateWithMeshSourcesAndMeshElements(const __CFArray *a1, const __CFArray *a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateWithMeshSourcesAndMeshElements_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DMeshCreate();
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v16 = Count;
    for (CFIndex i = 0; i != v16; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      C3DMeshAddSource(v14, ValueAtIndex, *(unsigned char *)(a3 + i), 0);
    }
  }
  CFIndex v19 = CFArrayGetCount(a2);
  if (v19 >= 1)
  {
    CFIndex v20 = v19;
    for (CFIndex j = 0; j != v20; ++j)
    {
      uint32_t v22 = CFArrayGetValueAtIndex(a2, j);
      C3DMeshAppendElement(v14, v22);
    }
  }
  return v14;
}

uint64_t __C3DMeshAddSourceWithDataKind(uint64_t a1, const void *a2, char a3, int a4, int a5)
{
  if (!a1 && (uint64_t v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationCopy_cold_2(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (a5 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    __int16 v26 = (CFArrayRef *)(a1 + 112);
  }
  else if (a5)
  {
    unsigned int v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
    }
    __int16 v26 = 0;
  }
  else
  {
    __int16 v26 = (CFArrayRef *)(a1 + 64);
  }
  SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)a2);
  int v36 = Semantic;
  if (Semantic)
  {
    unsigned __int8 v37 = Semantic;
    if ((Semantic & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_23:
    CFIndex v45 = 0;
    goto LABEL_25;
  }
  if (!C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, a5))
  {
    C3DMeshResetBoundingVolumes(a1);
    unsigned __int8 v37 = v36;
LABEL_21:
    while (1)
    {
      uint64_t v40 = (char *)v26 + 2 * v37;
      uint64_t v43 = v40[8];
      uint64_t v41 = v40 + 8;
      uint64_t v42 = v43;
      if (v43 != -1) {
        break;
      }
      int v44 = (char)v37--;
      if (v44 < 1) {
        goto LABEL_23;
      }
    }
    CFIndex v45 = v41[1] + v42;
LABEL_25:
    CFIndex Count = CFArrayGetCount(*v26);
    CFArrayInsertValueAtIndex(*v26, v45, a2);
    if (a5)
    {
      __BuildRenderableSourceChannelsAndSemanticInfos(a1);
      if (!a4) {
        return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
      }
    }
    else
    {
      CFIndex v48 = *(void **)(a1 + 152);
      if (v48)
      {
        free(v48);
        *(void *)(a1 + 152) = 0;
      }
      int v49 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x9AF01975uLL);
      *(void *)(a1 + 104) = v49;
      if (Count > v45)
      {
        do
        {
          *(unsigned char *)(*(void *)(a1 + 104) + Count) = *(unsigned char *)(*(void *)(a1 + 104) + Count - 1);
          --Count;
        }
        while (Count > v45);
        int v49 = *(unsigned char **)(a1 + 104);
      }
      v49[v45] = a3;
      __BuildSemanticInfosForData(a1, (uint64_t)v26);
      __UpdateSourcesMutability(a1);
      __C3DMeshInvalidateRenderableData(a1);
      if (!a4) {
        return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
      }
    }
    CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", (const void *)a1, 0, 1u);
    ++*(void *)(a1 + 208);
    return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
  }
  uint64_t v38 = scn_default_log();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    v50[0] = 0;
    _os_log_impl(&dword_20B249000, v38, OS_LOG_TYPE_DEFAULT, "Warning: Can't add two position sources", (uint8_t *)v50, 2u);
  }
  return -1;
}

void __BuildSemanticInfosForData(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  *(void *)&v35[5] = *MEMORY[0x263EF8340];
  do
  {
    *(_WORD *)(a2 + v4 + 8) = 255;
    v4 += 2;
  }
  while (v4 != 18);
  *(unsigned char *)(a1 + 200) &= ~0x80u;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)a2);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    char v8 = -1;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a2, v7);
      SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      int v11 = Semantic;
      if (Semantic == v8)
      {
        if (!v8)
        {
          if (*(unsigned char *)(a2 + 9))
          {
            uint64_t v12 = scn_default_log();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
              __BuildSemanticInfosForData_cold_1(v34, v35, v12);
            }
          }
        }
        uint64_t v13 = a2 + 2 * v8;
        unsigned __int8 v14 = *(unsigned char *)(v13 + 9) + 1;
        *(unsigned char *)(v13 + 9) = v14;
        if (v8 != 3 && v14 >= 2u)
        {
          uint64_t v15 = scn_default_log();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t Name = C3DEntityGetName(a1);
            uint64_t v17 = C3DMeshSourceSemanticToSemanticString(v8);
            *(_DWORD *)buf = 138412546;
            uint64_t v31 = Name;
            __int16 v32 = 2112;
            uint64_t v33 = v17;
            _os_log_impl(&dword_20B249000, v15, OS_LOG_TYPE_DEFAULT, "Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering", buf, 0x16u);
          }
        }
      }
      else
      {
        if (Semantic <= v8)
        {
          unsigned int v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            __BuildSemanticInfosForData_cold_3(v28, &v29, v18);
          }
        }
        uint64_t v19 = a2 + 2 * v11;
        int v21 = *(unsigned __int8 *)(v19 + 8);
        uint64_t v20 = (unsigned char *)(v19 + 8);
        if (v21 != 255)
        {
          uint64_t v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            __BuildSemanticInfosForData_cold_2(v26, &v27, v22);
          }
        }
        *uint64_t v20 = v7;
        *(unsigned char *)(a2 + 2 * v11 + 9) = 1;
        char v8 = v11;
      }
      if (v11 == 2)
      {
        int HasNonOpaqueColors = C3DMeshSourceHasNonOpaqueColors((uint64_t)ValueAtIndex);
        char v24 = *(unsigned char *)(a1 + 200);
        char v25 = v24 & 0x80;
        if (HasNonOpaqueColors) {
          char v25 = 0x80;
        }
        *(unsigned char *)(a1 + 200) = v25 & 0x80 | v24 & 0x7F;
      }
      ++v7;
    }
    while (v6 != v7);
  }
}

uint64_t C3DMeshSourceGetSemantic(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(char *)(a1 + 96);
}

void __C3DMeshInvalidateRenderableData(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 144);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 112);
  if (v3)
  {
    for (uint64_t i = 0; i != 18; i += 2)
      *(_WORD *)(a1 + i + 120) = 255;
    CFRelease(v3);
    *(void *)(a1 + 112) = 0;
  }
}

uint64_t C3DMeshAddSource(uint64_t a1, const void *a2, char a3, int a4)
{
  return __C3DMeshAddSourceWithDataKind(a1, a2, a3, a4, 0);
}

void C3DMeshResetBoundingVolumes(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void **)(a1 + 184);
  if (v10) {
    free(v10);
  }
  int v11 = *(void **)(a1 + 192);
  if (v11) {
    free(v11);
  }
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 200) &= ~2u;
}

uint64_t C3DMeshCreate()
{
  if (C3DMeshGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshGetTypeID_onceToken, &__block_literal_global_63);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DMeshGetTypeID_typeID, 0xD0uLL);
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  int v2 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  *(void *)(Instance + 64) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  *(void *)(Instance + 96) = CFArrayCreateMutable(v1, 0, v2);
  *(void *)(Instance + 112) = 0;
  *(void *)(Instance + 144) = 0;
  *(unsigned char *)(Instance + 200) = *(unsigned char *)(Instance + 200) & 0x87 | 0x18;
  __BuildSemanticInfosForData(Instance, Instance + 64);
  return Instance;
}

void C3DMeshAppendElement(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 200) &= ~2u;
  __C3DMeshInvalidateRenderableData(a1);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 96), a2);
}

void C3DGeometryAppendMaterial(uint64_t a1, void *value)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (value) {
      goto LABEL_6;
    }
  }
  else if (value)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryAppendMaterial_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), value);
  uint64_t v20 = C3DGetSceneRef(a1);
  C3DAddSceneRef((uint64_t *)value, v20);
  __PostGeometryMaterialDidChangeNotification((void *)a1);
}

void __C3DMeshElementSetPrimitiveRanges(uint64_t a1, void *a2)
{
  unsigned __int16 v4 = [a2 count];
  __int16 v5 = v4;
  if (v4)
  {
    uint64_t v6 = malloc_type_malloc(16 * v4, 0x1000040451B5BE8uLL);
    v7[0] = MEMORY[0x263EF8330];
    v7[1] = 3221225472;
    v7[2] = ____C3DMeshElementSetPrimitiveRanges_block_invoke;
    v7[3] = &__block_descriptor_40_e24_v32__0__NSValue_8Q16_B24l;
    v7[4] = v6;
    [a2 enumerateObjectsUsingBlock:v7];
  }
  else
  {
    uint64_t v6 = 0;
  }
  C3DMeshElementSetPrimitiveRangesNoCopy(a1, (uint64_t)v6, v5);
}

void C3DMeshElementSetPrimitiveRangesNoCopy(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(void *)(a1 + 120) = a2;
  *(_WORD *)(a1 + 128) = a3;
}

void C3DMeshElementInitIndexed(uint64_t a1, char a2, int a3, char a4, char a5, const void *a6, char a7)
{
  *(unsigned char *)(a1 + 130) = a4;
  *(unsigned char *)(a1 + 131) = a5;
  *(_DWORD *)(a1 + 104) = a3;
  __SetIndexes(a1, a6, a7);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
}

void __SetIndexes(uint64_t a1, CFTypeRef cf, char a3)
{
  CFTypeRef v3 = cf;
  *(unsigned char *)(a1 + 80) = a3;
  CFTypeRef v5 = *(CFTypeRef *)(a1 + 96);
  if (v5 != cf)
  {
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 96) = 0;
    }
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *(void *)(a1 + 96) = v3;
  }
  uint64_t v6 = *(void **)(a1 + 112);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 112) = 0;
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 96);
  }
  if (v3)
  {
    CFIndex Length = CFDataGetLength((CFDataRef)v3);
    uint64_t v8 = *(unsigned int *)(a1 + 64);
    uint64_t v9 = *(unsigned __int8 *)(a1 + 80);
    if (Length < v8 + C3DMeshElementGetIndexCount(a1) * v9)
    {
      uint64_t v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        __SetIndexes_cold_1();
      }
      uint64_t v11 = *(const void **)(a1 + 96);
      if (v11)
      {
        CFRelease(v11);
        *(void *)(a1 + 96) = 0;
      }
    }
  }
}

uint64_t C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount(int a1, uint64_t a2)
{
  switch(a1)
  {
    case 0:
      a2 *= 3;
      break;
    case 1:
    case 5:
      a2 += 2;
      break;
    case 2:
      a2 *= 2;
      break;
    case 3:
      return a2;
    default:
      int v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount_cold_1();
      }
      a2 = 0;
      break;
  }
  return a2;
}

void C3DMeshElementSetType(uint64_t a1, char a2)
{
  if (!a1)
  {
    unsigned __int16 v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 88) = a2;
}

uint64_t C3DMeshElementCreate()
{
  if (C3DMeshElementGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshElementGetTypeID_onceToken, &__block_literal_global_7);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DMeshElementGetTypeID_typeID, 0xD0uLL);
  if (!Instance)
  {
    CFAllocatorRef v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  *(unsigned char *)(Instance + 88) = 0;
  *(void *)(Instance + 96) = 0;
  *(_DWORD *)(Instance + 128) = 0x10000;
  *(void *)(Instance + 112) = 0;
  *(void *)(Instance + 120) = 0;
  *(_DWORD *)(Instance + 68) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(Instance + 144) = _D0;
  *(_DWORD *)(Instance + 152) = 1065353216;
  return Instance;
}

void __C3DProgramHashCodeCreate_block_invoke_2(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)s_ProgramHashCodeDictionary, *(const void **)(a1 + 48));
  uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFRetain(v2);
  }
  else
  {
    if (C3DProgramHashCodeGetTypeID_onceToken != -1) {
      dispatch_once(&C3DProgramHashCodeGetTypeID_onceToken, &__block_literal_global_109);
    }
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = C3DTypeCreateInstance_(C3DProgramHashCodeGetTypeID_typeID, 0x118uLL);
    memcpy((void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 16), (const void *)(*(void *)(a1 + 56) + 16), 0x108uLL);
    uint64_t v3 = *(void *)(a1 + 56);
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 160) = 0u;
    *(_OWORD *)(v3 + 176) = 0u;
    *(_OWORD *)(v3 + 192) = 0u;
    *(_OWORD *)(v3 + 208) = 0u;
    *(_OWORD *)(v3 + 224) = 0u;
    *(_OWORD *)(v3 + 240) = 0u;
    *(_OWORD *)(v3 + 256) = 0u;
    *(void *)(v3 + 272) = 0;
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 48);
    CFTypeRef v5 = *(CFTypeRef *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 280);
    if (v5 != v4)
    {
      if (v5)
      {
        CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 280));
        *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 280) = 0;
        CFTypeRef v4 = *(CFTypeRef *)(a1 + 48);
      }
      if (v4) {
        CFTypeRef v4 = CFRetain(v4);
      }
      *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 280) = v4;
    }
    if (C3DStandardShadersUseFunctionConstants())
    {
      id v6 = SCNCreateFuntionConstants(*(void **)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88) + 4, ((unint64_t)**(unsigned __int16 **)(a1 + 88) >> 7), *(_WORD **)(a1 + 88), *(void *)(a1 + 96));
      id v7 = *(id *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 288);
      if (v7 != v6)
      {
        if (v7)
        {
          CFRelease(v7);
          *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 288) = 0;
        }
        if (v6) {
          CFTypeRef v8 = CFRetain(v6);
        }
        else {
          CFTypeRef v8 = 0;
        }
        *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 288) = v8;
      }
      CFRelease(v6);
    }
    uint64_t v9 = (__CFDictionary *)s_ProgramHashCodeDictionary;
    uint64_t v10 = *(const void **)(a1 + 48);
    uint64_t v11 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    CFDictionarySetValue(v9, v10, v11);
  }
}

uint64_t C3DStandardShadersUseFunctionConstants()
{
  if (C3DStandardShadersUseFunctionConstants_onceToken != -1) {
    dispatch_once(&C3DStandardShadersUseFunctionConstants_onceToken, &__block_literal_global_249);
  }
  return C3DStandardShadersUseFunctionConstants_enableFunctionConstants;
}

uint64_t C3DColorSpaceITUR_709()
{
  if (C3DColorSpaceITUR_709_onceToken != -1) {
    dispatch_once(&C3DColorSpaceITUR_709_onceToken, &__block_literal_global_25);
  }
  return C3DColorSpaceITUR_709_kC3DColorSpaceITUR_709;
}

CGColorRef C3DCGColorCreateExtendedSRGBWithCGColor(CGColorRef color)
{
  if (!color)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DCGColorGetComponentsInColorSpace_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
  }
  uint64_t v10 = (CGColorSpace *)C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
  if (CGColorGetColorSpace(color) == v10) {
    return CGColorRetain(color);
  }
  if (C3DGetColorTransformToExtendedSRGB_onceToken != -1) {
    dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_44);
  }
  return (CGColorRef)CGColorTransformConvertColor();
}

uint64_t __AddProperty(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t DefineForPropertyAndSuffix = __GetDefineForPropertyAndSuffix(a3, 0);
  uint64_t v9 = __GetDefineForPropertyAndSuffix(a3, 1);
  uint64_t result = __GetDefineForPropertyAndSuffix(a3, 5);
  uint64_t v11 = result;
  *(unsigned char *)(a1 + 24) = 0;
  if (a4)
  {
    uint64_t result = C3DProgramHashCodeGetEffectPropertyIsEnabled(*(void *)a1, a2);
    if (result)
    {
      if (a3 == 7) {
        uint64_t v12 = (__CFString *)&unk_26BFC14C8;
      }
      else {
        uint64_t v12 = &stru_26BF72F58;
      }
      [*(id *)(a1 + 8) setObject:v12 forKeyedSubscript:v9];
      if (!C3DProgramHashCodeGetEffectPropertyHasTexture(*(void *)a1, a2))
      {
        uint64_t v19 = __GetDefineForPropertyAndSuffix(a3, 2);
        uint64_t v18 = *(void **)(a1 + 8);
        uint64_t v17 = &stru_26BF72F58;
        goto LABEL_16;
      }
      if (C3DProgramHashCodeGetEffectPropertyTextureType(*(void *)a1, a2) == 4) {
        int v13 = 7;
      }
      else {
        int v13 = 6;
      }
      objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_26BF72F58, __GetDefineForPropertyAndSuffix(a3, v13));
      *(unsigned char *)(a1 + 24) = 1;
      [*(id *)(a1 + 8) setObject:&stru_26BF72F58 forKeyedSubscript:v11];
      uint64_t result = C3DProgramHashCodeGetEffectPropertyHashCode(*(void *)a1, a2);
      unsigned int v14 = result;
      if ((result & 0x2000) != 0) {
        uint64_t result = objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_26BF72F58, __GetDefineForPropertyAndSuffix(a3, 3));
      }
      uint64_t v15 = (v14 >> 14) & 0xF;
      if (v15 && v15 != 15)
      {
        uint64_t v16 = __GetDefineForPropertyAndSuffix(a3, 4);
        uint64_t v17 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"%d", v15);
        uint64_t v18 = *(void **)(a1 + 8);
        uint64_t v19 = v16;
LABEL_16:
        uint64_t result = [v18 setObject:v17 forKeyedSubscript:v19];
      }
    }
  }
  uint64_t v20 = *(void **)(a1 + 16);
  if (v20)
  {
    objc_msgSend(v20, "addObject:", __GetDefineForPropertyAndSuffix(a3, 1));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 2));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 3));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 4));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 5));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 6));
    uint64_t result = objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 7));
  }
  if (a3 != 4)
  {
    uint64_t result = [*(id *)(a1 + 8) objectForKeyedSubscript:v11];
    if (result)
    {
      uint64_t result = C3DProgramHashCodeGetEffectPropertyHashCode(*(void *)a1, a2);
      uint64_t v21 = (result >> 18) & 0xF;
      if (v21 != 15)
      {
        if (a3 == 15)
        {
          __int16 UVSetInfo = C3DProgramHashCodeGetUVSetInfo(*(void *)a1, v21);
          unsigned __int8 v23 = UVSetInfo;
          unsigned int v24 = HIBYTE(UVSetInfo);
          char v25 = *(void **)(a1 + 112);
          if (v24 <= 0xFE) {
            return objc_msgSend(v25, "appendFormat:", @"float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;\n",
          }
                     DefineForPropertyAndSuffix,
                     (*(_DWORD *)(a1 + 128) - 1),
                     v23);
          else {
            return objc_msgSend(v25, "appendFormat:", @"float2 _%@Texcoord = _geometry.texcoords[%d].xy;\n",
          }
                     DefineForPropertyAndSuffix,
                     v23,
                     v26);
        }
        else
        {
          return objc_msgSend(*(id *)(a1 + 120), "appendFormat:", @"    _surface.%@Texcoord = in.texcoord%d;\n",
                   DefineForPropertyAndSuffix,
                   v21,
                   v26);
        }
      }
    }
  }
  return result;
}

uint64_t __GetDefineForPropertyAndSuffix(int a1, int a2)
{
  if (__GetDefineForPropertyAndSuffix_predicate != -1) {
    dispatch_once(&__GetDefineForPropertyAndSuffix_predicate, &__block_literal_global_104);
  }
  return *((void *)&__GetDefineForPropertyAndSuffix_strings + 8 * (uint64_t)a1 + a2);
}

uint64_t C3DProgramHashCodeGetEffectPropertyIsEnabled(uint64_t a1, unsigned int a2)
{
  return (*(_DWORD *)(a1 + 4 * a2 + 36) >> 11) & 1;
}

uint64_t C3DProgramHashCodeGetEffectPropertyHasTexture(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 36) & 1;
}

uint64_t C3DProgramHashCodeGetEffectPropertyHashCode(uint64_t a1, unsigned int a2)
{
  return *(unsigned int *)(a1 + 4 * a2 + 36);
}

BOOL C3DShouldCollectGeneratedShaders()
{
    return 1;
  if (C3DShouldCollectGeneratedShaders::onceToken != -1) {
    dispatch_once(&C3DShouldCollectGeneratedShaders::onceToken, &__block_literal_global_80);
  }
  return C3DShouldCollectGeneratedShaders::traceResources != 0;
}

const void *C3DGetTextResourceWithNameAllowingHotReload(void *key)
{
  __dst[102] = *(const void **)MEMORY[0x263EF8340];
  CFDictionaryRef v2 = (const __CFDictionary *)C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources;
  if (!C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources)
  {
    memcpy(__dst, off_26400A370, 0x330uLL);
    memcpy(values, off_26400A6A0, sizeof(values));
    CFDictionaryRef v2 = CFDictionaryCreate(0, __dst, (const void **)values, 101, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources = (uint64_t)v2;
  }
  return CFDictionaryGetValue(v2, key);
}

uint64_t C3DProgramHashCodeGetReflectionProbesEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 202) >> 4) & 1;
}

uint64_t C3DProgramHashCodeGetNodeHashCode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t C3DProgramHashCodeGetEffectPropertyTextureType(uint64_t a1, unsigned int a2)
{
  return (*(_DWORD *)(a1 + 4 * a2 + 36) >> 6) & 0xF;
}

uint64_t SCNMetalLanguageVersion()
{
  if (SCNMetalLanguageVersion_onceToken != -1) {
    dispatch_once(&SCNMetalLanguageVersion_onceToken, &__block_literal_global_27);
  }
  return SCNMetalLanguageVersion_languageVersion;
}

uint64_t C3DProgramHashCodeGetUVSetInfo(uint64_t a1, uint64_t a2)
{
  if (a2 >= 16)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DProgramHashCodeGetUVSetInfo_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return *(unsigned __int16 *)(a1 + 2 * a2 + 164);
}

CFIndex CFStringUpdateHash(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  CFDictionaryRef v2 = v1;
  CFStringRef v4 = v3;
  uint64_t v11 = *MEMORY[0x263EF8340];
  CStringPtr = CFStringGetCStringPtr(v3, 0x600u);
  CFIndex result = CFStringGetLength(v4);
  CFIndex v7 = result;
  if (CStringPtr)
  {
    return CC_SHA256_Update(v2, CStringPtr, result);
  }
  else
  {
    do
    {
      if (!v7) {
        break;
      }
      CFIndex usedBufLen = 0;
      v13.location = (CFIndex)CStringPtr;
      v13.CFIndex length = v7;
      CFIndex result = CFStringGetBytes(v4, v13, 0x8000100u, 0, 0, buffer, 0x8000, &usedBufLen);
      CFIndex v8 = result;
      if (usedBufLen) {
        CFIndex result = CC_SHA256_Update(v2, buffer, usedBufLen);
      }
      CStringPtr += v8;
      v7 -= v8;
    }
    while (v8);
  }
  return result;
}

uint64_t C3DEngineContextGetCoordinatesSystemOptions(uint64_t a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(__int16 *)(a1 + 214);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2023()
{
  if (C3DWasLinkedBeforeMajorOSYear2023_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2023_onceToken, &__block_literal_global_20);
  }
  return C3DWasLinkedBeforeMajorOSYear2023_linkedBeforeMajorOSYear2023;
}

CFDictionaryRef C3DEngineContextGetRenderingOptionForKey(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 376);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

__CFString *__configureOpenSubdivSupport(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t NodeHashCode = C3DProgramHashCodeGetNodeHashCode(a3);
  int v7 = C3DProgramHashCodeOpenSubdivPatchType(a3);
  if ((NodeHashCode & 0x20) != 0 && a2)
  {
    int v8 = v7;
    uint64_t v9 = 0x2000010000;
    if ((NodeHashCode & 0x80) == 0) {
      uint64_t v9 = 0x2000000000;
    }
    *(void *)(a1 + 208) = C3DSubdivisionOsdGPUGetProgramGeneratorResources(v7 & 0xFFFFFEFF | (((NodeHashCode >> 6) & 1) << 8) | v9, (NodeHashCode >> 8) & 0x7FFFF, *(void **)(a1 + 8));
    *(void *)(a1 + 216) = C3DSubdivisionOsdGPUGetPerPatchTypeSources(v8);
    uint64_t v10 = NSString;
    uint64_t v11 = C3DSubdivisionOsdGPUGetSharedSources();
    uint64_t v12 = C3DGetTextResourceWithNameAllowingHotReload(@"C3D-OpenSubdiv-Utils.h");
    CFDictionaryRef result = (__CFString *)[v10 stringWithFormat:@"%@%@%@", v11, v12, C3DGetTextResourceWithNameAllowingHotReload(@"C3D-OpenSubdiv-Utils.metal")];
  }
  else
  {
    CFDictionaryRef result = &stru_26BF72F58;
    *(void *)(a1 + 208) = &stru_26BF72F58;
    *(void *)(a1 + 216) = &stru_26BF72F58;
  }
  *(void *)(a1 + 224) = result;
  return result;
}

uint64_t __InjectAllModifiersIfNeeded(uint64_t a1)
{
  v23[33] = *MEMORY[0x263EF8340];
  memset(v23, 0, 256);
  uint64_t v2 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(void *)a1, 0, 0, (uint64_t)v23, 32);
  memset(v22, 0, sizeof(v22));
  uint64_t v3 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(void *)a1, 1, 0, (uint64_t)v22, 32);
  memset(v21, 0, sizeof(v21));
  uint64_t v4 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(void *)a1, 2, 0, (uint64_t)v21, 32);
  *(void *)(a1 + 152) = 0;
  uint64_t v5 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(void *)a1, 3, 0, a1 + 152, 1);
  if (v5 >= 2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      -[SCNCommonProfileProgramGeneratorGL _newProgramWithHashCode:engineContext:introspectionDataPtr:].cold.5();
    }
    uint64_t v5 = 1;
  }
  if (v2 >= 2)
  {
    int v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      -[SCNCommonProfileProgramGeneratorGL _newProgramWithHashCode:engineContext:introspectionDataPtr:].cold.5();
    }
    uint64_t v2 = 1;
  }
  if (v3 >= 2)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      -[SCNCommonProfileProgramGeneratorGL _newProgramWithHashCode:engineContext:introspectionDataPtr:].cold.5();
    }
    uint64_t v3 = 1;
  }
  if (v4 >= 2)
  {
    uint64_t v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      -[SCNCommonProfileProgramGeneratorGL _newProgramWithHashCode:engineContext:introspectionDataPtr:].cold.5();
    }
    uint64_t v4 = 1;
  }
  __AppendModifierDefines(*(void **)(a1 + 8), v23, v2);
  __AppendModifierDefines(*(void **)(a1 + 8), v22, v3);
  __AppendModifierDefines(*(void **)(a1 + 8), v21, v4);
  __AppendModifierDefines(*(void **)(a1 + 8), (uint64_t *)(a1 + 152), v5);
  __AppendModifierArguments(a1, v23, v2);
  __AppendModifierArguments(a1, v22, v3);
  __AppendModifierArguments(a1, v21, v4);
  __AppendModifierArguments(a1, (uint64_t *)(a1 + 152), v5);
  id v10 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  __UnifyModifierVaryings((uint64_t)v10, v23, v2);
  __UnifyModifierVaryings((uint64_t)v10, v22, v3);
  __UnifyModifierVaryings((uint64_t)v10, v21, v4);
  __UnifyModifierVaryings((uint64_t)v10, (uint64_t *)(a1 + 152), v5);
  v20[0] = MEMORY[0x263EF8330];
  v20[1] = 3221225472;
  uint64_t v20[2] = ____InjectAllModifiersIfNeeded_block_invoke;
  v20[3] = &__block_descriptor_40_e35_v32__0__NSString_8__NSString_16_B24l;
  v20[4] = a1;
  [v10 enumerateKeysAndObjectsUsingBlock:v20];

  int ModifierFlag = __GetModifierFlag(v21, v4);
  int v12 = __GetModifierFlag(v22, v3);
  int v13 = __GetModifierFlag(v23, v2);
  unsigned int v14 = __GetModifierFlag((uint64_t *)(a1 + 152), v5);
  if (v2)
  {
    [*(id *)(a1 + 8) setObject:&stru_26BF72F58 forKeyedSubscript:@"USE_GEOMETRY_MODIFIER"];
    __InjectModifiers(a1, 0, v23);
  }
  if (v3)
  {
    [*(id *)(a1 + 8) setObject:&stru_26BF72F58 forKeyedSubscript:@"USE_SURFACE_MODIFIER"];
    __InjectModifiers(a1, 1u, v22);
  }
  if (v4)
  {
    [*(id *)(a1 + 8) setObject:&stru_26BF72F58 forKeyedSubscript:@"USE_FRAGMENT_MODIFIER"];
    __InjectModifiers(a1, 2u, v21);
  }
  if (v5)
  {
    [*(id *)(a1 + 8) setObject:&stru_26BF72F58 forKeyedSubscript:@"USE_LIGHT_MODIFIER"];
    __InjectModifiers(a1, 3u, (uint64_t *)(a1 + 152));
  }
  uint64_t v15 = *(void **)(a1 + 16);
  if (v15)
  {
    [v15 addObject:@"USE_GEOMETRY_MODIFIER"];
    [*(id *)(a1 + 16) addObject:@"USE_SURFACE_MODIFIER"];
    [*(id *)(a1 + 16) addObject:@"USE_FRAGMENT_MODIFIER"];
    [*(id *)(a1 + 16) addObject:@"USE_LIGHT_MODIFIER"];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = ____InjectAllModifiersIfNeeded_block_invoke_2;
    v19[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
    v19[4] = a1;
    C3DShaderModifierEnumeratePossibleDefinesUsingBlock((uint64_t)v19);
    CFDictionaryRef StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 3221225472;
    v18[2] = ____InjectAllModifiersIfNeeded_block_invoke_3;
    v18[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    v18[4] = a1;
    C3DCFDictionaryApplyBlock(StandardUniforms, (uint64_t)v18);
  }
  return v12 | ModifierFlag | v13 | v14;
}

uint64_t __UnifyModifierVaryings(uint64_t result, uint64_t *a2, uint64_t a3)
{
  *(void *)&v9[5] = *MEMORY[0x263EF8340];
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v5 = (void *)result;
    do
    {
      uint64_t v6 = *a2;
      if (!*a2)
      {
        int v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
          __UnifyModifierVaryings_cold_1(v8, v9, v7);
        }
      }
      CFDictionaryRef result = C3DShaderModifierGetVaryings(v6);
      if (result) {
        CFDictionaryRef result = [v5 addEntriesFromDictionary:result];
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t __GetModifierFlag(uint64_t *a1, uint64_t a2)
{
  if (a2 < 1)
  {
    LOWORD(v4) = 0;
  }
  else
  {
    uint64_t v2 = a2;
    int v4 = 0;
    do
    {
      uint64_t v5 = *a1++;
      v4 |= C3DShaderModifierGetFlags(v5);
      --v2;
    }
    while (v2);
  }
  return (__int16)v4;
}

void __AppendModifierDefines(void *a1, uint64_t *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    do
    {
      CFDictionaryRef Defines = (const __CFDictionary *)C3DShaderModifierGetDefines(*a2);
      if (Defines) {
        CFDictionaryApplyFunction(Defines, (CFDictionaryApplierFunction)__appendDictionary, a1);
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
}

uint64_t __AppendModifierArguments(uint64_t result, uint64_t *a2, uint64_t a3)
{
  *(void *)&void v15[5] = *MEMORY[0x263EF8340];
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v5 = result;
    do
    {
      uint64_t v6 = *a2;
      if (!*a2)
      {
        int v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
          __UnifyModifierVaryings_cold_1(v14, v15, v7);
        }
      }
      CFDictionaryRef result = C3DShaderModifierGetArguments(v6);
      if (result)
      {
        int v8 = (void *)result;
        int EntryPoint = C3DShaderModifierGetEntryPoint(*a2);
        BOOL v10 = EntryPoint && (EntryPoint != 3 || *(unsigned char *)(v5 + 203));
        v11[0] = MEMORY[0x263EF8330];
        v11[1] = 3221225472;
        v11[2] = ____AppendModifierArguments_block_invoke;
        v11[3] = &__block_descriptor_45_e35_v32__0__NSString_8__NSString_16_B24l;
        v11[4] = v5;
        BOOL v13 = v10;
        int v12 = EntryPoint;
        CFDictionaryRef result = [v8 enumerateKeysAndObjectsUsingBlock:v11];
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t C3DProgramHashCodeCopyShaderModifiersForEntryPoint(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  v11[0] = a4;
  v11[1] = a5;
  uint64_t v12 = 0;
  uint64_t v6 = a1 + 16;
  char v7 = 1;
  int v13 = a2;
  int v14 = a3;
  do
  {
    char v8 = v7;
    CFArrayRef v9 = *(const __CFArray **)(v6 + 8 * v5);
    if (v9)
    {
      v15.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(v6 + 8 * v5));
      v15.location = 0;
      CFArrayApplyFunction(v9, v15, (CFArrayApplierFunction)__dispatchShaderModifiers, v11);
    }
    char v7 = 0;
    uint64_t v5 = 1;
  }
  while ((v8 & 1) != 0);
  return v12;
}

uint64_t C3DSceneSourceGetStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t C3DProgramHashCodeUsePointRendering(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 9) & 1;
}

uint64_t C3DProgramHashCodeOpenSubdivPatchType(uint64_t a1)
{
  return *(unsigned char *)(a1 + 202) & 7;
}

uint64_t C3DProgramHashCodeHasNormals(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 3) & 1;
}

uint64_t C3DProgramHashCodeHasFog(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 7) & 1;
}

uint64_t C3DProgramHashCodeGlobalAlphaIsOne(uint64_t a1)
{
  return *(_WORD *)(a1 + 200) & 1;
}

uint64_t C3DProgramHashCodeGetUVSetsCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 163);
}

uint64_t C3DProgramHashCodeGetRenderMode(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 199) >> 3) & 3;
}

uint64_t C3DProgramHashCodeGetProbesLightingOrder(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 11) & 7;
}

uint64_t C3DProgramHashCodeGetLocalLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 202) >> 3) & 1;
}

uint64_t C3DProgramHashCodeGetLightsMask(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 161);
}

uint64_t C3DProgramHashCodeGetLightsCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 160);
}

uint64_t C3DProgramHashCodeGetLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 5) & 1;
}

uint64_t C3DProgramHashCodeGetEyeCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 198);
}

uint64_t C3DProgramHashCodeGetCustomSlotCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 162);
}

uint64_t C3DProgramHashCodeGetConditioners(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 196);
}

uint64_t C3DProgramHashCodeGetCommonProfileHashCode(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 120);
}

uint64_t C3DProgramHashCodeGetAmbientLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 6) & 1;
}

__CFString *C3DLightingModelGetDescription(unsigned int a1)
{
  if (a1 > 6) {
    return @"SCNLightingModelInvalid";
  }
  else {
    return off_264007650[a1];
  }
}

CFHashCode C3DFXMetalProgramUpdateHashWithCommonProfileHashCode(uint64_t a1, CFTypeRef cf)
{
  if (!cf)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramUpdateHashWithCommonProfileHashCode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFHashCode result = CFHash(cf);
  unint64_t v13 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * result) ^ ((0x9DDFEA08EB382D69 * result) >> 47));
  *(void *)(a1 + 168) = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
  return result;
}

uint64_t C3DFXMetalProgramCreateFromSource(const void *a1, const void *a2, int a3, const void *a4, const void *a5, const void *a6, const void *a7, int a8, char a9)
{
  uint64_t v17 = C3DFXMetalProgramCreate();
  uint64_t v18 = *(const void **)(v17 + 80);
  if (v18 != a1)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(v17 + 80) = 0;
    }
    if (a1) {
      CFTypeRef v19 = CFRetain(a1);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(v17 + 80) = v19;
  }
  uint64_t v20 = *(const void **)(v17 + 88);
  if (v20 != a2)
  {
    if (v20)
    {
      CFRelease(v20);
      *(void *)(v17 + 88) = 0;
    }
    if (a2) {
      CFTypeRef v21 = CFRetain(a2);
    }
    else {
      CFTypeRef v21 = 0;
    }
    *(void *)(v17 + 88) = v21;
  }
  uint64_t v22 = *(const void **)(v17 + 96);
  if (v22 != a4)
  {
    if (v22)
    {
      CFRelease(v22);
      *(void *)(v17 + 96) = 0;
    }
    if (a4) {
      CFTypeRef v23 = CFRetain(a4);
    }
    else {
      CFTypeRef v23 = 0;
    }
    *(void *)(v17 + 96) = v23;
  }
  unsigned int v24 = *(const void **)(v17 + 104);
  if (v24 != a5)
  {
    if (v24)
    {
      CFRelease(v24);
      *(void *)(v17 + 104) = 0;
    }
    if (a5) {
      CFTypeRef v25 = CFRetain(a5);
    }
    else {
      CFTypeRef v25 = 0;
    }
    *(void *)(v17 + 104) = v25;
  }
  uint64_t v26 = *(const void **)(v17 + 112);
  if (v26 != a6)
  {
    if (v26)
    {
      CFRelease(v26);
      *(void *)(v17 + 112) = 0;
    }
    if (a6) {
      CFTypeRef v27 = CFRetain(a6);
    }
    else {
      CFTypeRef v27 = 0;
    }
    *(void *)(v17 + 112) = v27;
  }
  uint64_t v28 = *(const void **)(v17 + 120);
  if (v28 != a7)
  {
    if (v28)
    {
      CFRelease(v28);
      *(void *)(v17 + 120) = 0;
    }
    if (a7) {
      CFTypeRef v29 = CFRetain(a7);
    }
    else {
      CFTypeRef v29 = 0;
    }
    *(void *)(v17 + 120) = v29;
  }
  *(_DWORD *)(v17 + 144) = a3;
  uint64_t v30 = *(const void **)(v17 + 152);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(v17 + 152) = 0;
  }
  uint64_t v31 = *(const void **)(v17 + 160);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(v17 + 160) = 0;
  }
  *(_DWORD *)(v17 + 176) = a8;
  if (a9) {
    _C3DFXMetalProgramUpdateHashWithSource((void *)v17);
  }
  return v17;
}

uint64_t C3DFXMetalProgramCreateFromDefaultLibrary(const void *a1, const void *a2)
{
  uint64_t v4 = C3DFXMetalProgramCreate();
  uint64_t v5 = *(const void **)(v4 + 80);
  if (v5 != a1)
  {
    if (v5)
    {
      CFRelease(v5);
      *(void *)(v4 + 80) = 0;
    }
    if (a1) {
      CFTypeRef v6 = CFRetain(a1);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *(void *)(v4 + 80) = v6;
  }
  uint64_t v7 = *(const void **)(v4 + 88);
  if (v7 != a2)
  {
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v4 + 88) = 0;
    }
    if (a2) {
      CFTypeRef v8 = CFRetain(a2);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *(void *)(v4 + 88) = v8;
  }
  uint64_t v9 = *(const void **)(v4 + 96);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(v4 + 96) = 0;
  }
  uint64_t v10 = *(const void **)(v4 + 104);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(v4 + 104) = 0;
  }
  uint64_t v11 = *(const void **)(v4 + 112);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(v4 + 112) = 0;
  }
  uint64_t v12 = *(const void **)(v4 + 120);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(v4 + 120) = 0;
  }
  *(_DWORD *)(v4 + 144) = 0;
  unint64_t v13 = *(const void **)(v4 + 152);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(v4 + 152) = 0;
  }
  int v14 = *(const void **)(v4 + 160);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(v4 + 160) = 0;
  }
  _C3DFXMetalProgramUpdateHashWithLibrary((void *)v4);
  return v4;
}

uint64_t C3DFXMetalProgramCreate()
{
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFXMetalProgramGetTypeID_typeID, 0xA8uLL);
  uint64_t v1 = Instance;
  if (Instance)
  {
    C3DFXProgramInitialize(Instance);
    *(_DWORD *)(v1 + 64) = 2;
    *(void *)(v1 + 80) = 0;
    *(void *)(v1 + 88) = 0;
  }
  return v1;
}

uint64_t C3DFXProgramInitialize(uint64_t result)
{
  *(unsigned char *)(result + 68) |= 1u;
  return result;
}

CFHashCode _C3DFXMetalProgramUpdateHashWithLibrary(void *a1)
{
  uint64_t v2 = a1[19];
  if (v2) {
    unint64_t v3 = 0x9DDFEA08EB382D69 * (*(uint64_t (**)(void))(v2 + 16))();
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = (const void *)a1[10];
  if (v4) {
    CFHashCode v5 = CFHash(v4);
  }
  else {
    CFHashCode v5 = 0;
  }
  CFHashCode result = a1[11];
  if (result) {
    CFHashCode result = CFHash((CFTypeRef)result);
  }
  unint64_t v7 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) >> 47));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v7)));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  a1[21] = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) >> 47));
  return result;
}

uint64_t C3DEngineContextGetVertexAmplificationEnabled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

void sub_20B271E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DShaderModifierGetVaryings(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 72);
}

void ____arrayOfC3DModifiersFromDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  if (([a2 isEqualToString:@"SCNShaderModifierEntryPointGeometry"] & 1) != 0
    || ([a2 isEqualToString:@"SCNShaderModifierEntryPointSurface"] & 1) != 0
    || ([a2 isEqualToString:@"SCNShaderModifierEntryPointFragment"] & 1) != 0
    || ([a2 isEqualToString:@"SCNShaderModifierEntryPointLightingModel"] & 1) != 0)
  {
    [a3 rangeOfString:@";"];
    if (v5 != 1)
    {
      uint64_t v6 = objc_msgSend((id)SCNGetResourceBundle(), "pathForResource:ofType:inDirectory:", objc_msgSend((id)objc_msgSend(a3, "lastPathComponent"), "stringByDeletingPathExtension"), objc_msgSend(a3, "pathExtension"), objc_msgSend(a3, "stringByDeletingLastPathComponent"));
      if (v6)
      {
        uint64_t v7 = [NSString stringWithContentsOfFile:v6 encoding:4 error:0];
        if (v7) {
          a3 = (void *)v7;
        }
      }
    }
    C3DGetShadingLanguageFromSource((NSString *)a3);
  }
  uint64_t v8 = scn_default_log();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
    ____arrayOfC3DModifiersFromDictionary_block_invoke_cold_1();
  }
}

uint64_t C3DShaderModifiersCreate(CFStringRef theString, int a2, CFDictionaryRef theDict, int a4, int a5, int a6)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (theDict && CFDictionaryGetCount(theDict) >= 1)
  {
    int v25 = a6;
    CFIndex Count = CFDictionaryGetCount(theDict);
    v24[1] = v24;
    MEMORY[0x270FA5388](Count);
    unint64_t v13 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
    int v14 = (void *)((char *)v24 - v13);
    if ((unint64_t)(8 * Count) >= 0x200) {
      size_t v15 = 512;
    }
    else {
      size_t v15 = 8 * Count;
    }
    bzero((char *)v24 - v13, v15);
    MEMORY[0x270FA5388](v16);
    uint64_t v17 = (void *)((char *)v24 - v13);
    bzero((char *)v24 - v13, v15);
    CFDictionaryGetKeysAndValues(theDict, (const void **)((char *)v24 - v13), (const void **)((char *)v24 - v13));
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    if (Count >= 1)
    {
      do
      {
        uint64_t v20 = *v14++;
        uint64_t v19 = v20;
        uint64_t v21 = *v17++;
        CFStringAppendFormat(Mutable, 0, @"#define %@ %@\n", v19, v21);
        --Count;
      }
      while (Count);
    }
    CFStringAppend(Mutable, theString);
    LOWORD(a6) = v25;
  }
  else
  {
    CFMutableStringRef Mutable = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, theString);
  }
  uint64_t v22 = __C3DShaderModifierCreate(Mutable, a2, a4, a5, a6);
  CFRelease(Mutable);
  return v22;
}

uint64_t __C3DShaderModifierCreate(const __CFString *a1, int a2, int a3, int a4, __int16 a5)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v52 = 0u;
  C3DShaderSourceParserContextCreate(0, a3, (uint64_t)&v52);
  C3DShaderSourceParserParseSource(a1, (uint64_t)&v52, 0);
  long long v7 = v52;
  uint64_t v8 = (const void *)v53;
  if (a4) {
    uint64_t v9 = (const void *)*((void *)&v53 + 1);
  }
  else {
    uint64_t v9 = 0;
  }
  long long v10 = v54;
  uint64_t v11 = (const void *)v55;
  uint64_t v12 = (const void *)v56;
  __int16 v13 = WORD4(v56);
  if (C3DShaderModifierGetTypeID_onceToken != -1) {
    dispatch_once(&C3DShaderModifierGetTypeID_onceToken, &__block_literal_global_123);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DShaderModifierGetTypeID_typeID, 0x78uLL);
  if ((void)v7)
  {
    if (CFStringGetLength((CFStringRef)v7))
    {
      size_t v15 = *(const void **)(Instance + 16);
      if (v15 != (const void *)v7)
      {
        if (v15)
        {
          CFRelease(v15);
          *(void *)(Instance + 16) = 0;
        }
        *(void *)(Instance + 16) = CFRetain((CFTypeRef)v7);
      }
    }
  }
  if ((void)v10)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v10))
    {
      uint64_t v16 = *(const void **)(Instance + 56);
      if (v16 != (const void *)v10)
      {
        if (v16)
        {
          CFRelease(v16);
          *(void *)(Instance + 56) = 0;
        }
        *(void *)(Instance + 56) = CFRetain((CFTypeRef)v10);
      }
    }
  }
  if (*((void *)&v10 + 1))
  {
    if (CFDictionaryGetCount(*((CFDictionaryRef *)&v10 + 1)))
    {
      uint64_t v17 = *(const void **)(Instance + 64);
      if (v17 != *((const void **)&v10 + 1))
      {
        if (v17)
        {
          CFRelease(v17);
          *(void *)(Instance + 64) = 0;
        }
        *(void *)(Instance + 64) = CFRetain(*((CFTypeRef *)&v10 + 1));
      }
    }
  }
  if (v11)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v11))
    {
      uint64_t v18 = *(const void **)(Instance + 72);
      if (v18 != v11)
      {
        if (v18)
        {
          CFRelease(v18);
          *(void *)(Instance + 72) = 0;
        }
        *(void *)(Instance + 72) = CFRetain(v11);
      }
    }
  }
  if (!*((void *)&v7 + 1) || !CFStringGetLength(*((CFStringRef *)&v7 + 1)))
  {
    uint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      __C3DShaderModifierCreate_cold_2(v20);
      if (!v8) {
        goto LABEL_44;
      }
      goto LABEL_39;
    }
LABEL_38:
    if (!v8) {
      goto LABEL_44;
    }
    goto LABEL_39;
  }
  uint64_t v19 = *(const void **)(Instance + 24);
  if (v19 == *((const void **)&v7 + 1)) {
    goto LABEL_38;
  }
  if (v19)
  {
    CFRelease(v19);
    *(void *)(Instance + 24) = 0;
  }
  *(void *)(Instance + 24) = CFRetain(*((CFTypeRef *)&v7 + 1));
  if (v8)
  {
LABEL_39:
    if (CFDictionaryGetCount((CFDictionaryRef)v8))
    {
      uint64_t v21 = *(const void **)(Instance + 32);
      if (v21 != v8)
      {
        if (v21)
        {
          CFRelease(v21);
          *(void *)(Instance + 32) = 0;
        }
        *(void *)(Instance + 32) = CFRetain(v8);
      }
    }
  }
LABEL_44:
  if (v9)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v9))
    {
      uint64_t v22 = *(const void **)(Instance + 48);
      if (v22 != v9)
      {
        if (v22)
        {
          CFRelease(v22);
          *(void *)(Instance + 48) = 0;
        }
        *(void *)(Instance + 48) = CFRetain(v9);
      }
    }
  }
  if (v12)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v12))
    {
      CFTypeRef v23 = *(const void **)(Instance + 40);
      if (v23 != v12)
      {
        if (v23)
        {
          CFRelease(v23);
          *(void *)(Instance + 40) = 0;
        }
        *(void *)(Instance + 40) = CFRetain(v12);
      }
    }
  }
  __int16 v24 = v13 | a5;
  *(_DWORD *)(Instance + 88) = a2;
  *(_DWORD *)(Instance + 94) = 0;
  int v25 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
  if (*(void *)(Instance + 24))
  {
    CFDictionaryRef v26 = *(const __CFDictionary **)(Instance + 32);
    CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    if (v26)
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v26);
      CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(Instance + 32));
    }
    else
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      CFIndex Count = 0;
    }
    v57[0] = MEMORY[0x263EF8330];
    v57[1] = 0x40000000;
    v57[2] = ___C3DShaderModifierCreateWithComponents_block_invoke;
    v57[3] = &__block_descriptor_tmp_206;
    v57[4] = Instance;
    v57[5] = MutableCopy;
    if (C3DGetSurfacePropertiesToDefines_onceToken != -1) {
      dispatch_once(&C3DGetSurfacePropertiesToDefines_onceToken, &__block_literal_global_4_7);
    }
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetSurfacePropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetTexturePropertiesToDefines_onceToken != -1) {
      dispatch_once(&C3DGetTexturePropertiesToDefines_onceToken, &__block_literal_global_104);
    }
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetTexturePropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetGeometryPropertiesToDefines_onceToken != -1) {
      dispatch_once(&C3DGetGeometryPropertiesToDefines_onceToken, &__block_literal_global_114);
    }
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetGeometryPropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetFramebufferPropertiesToDefines_onceToken != -1) {
      dispatch_once(&C3DGetFramebufferPropertiesToDefines_onceToken, &__block_literal_global_159);
    }
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetFramebufferPropertiesToDefines_s_dic, (uint64_t)v57);
    if (CFDictionaryGetCount(MutableCopy) != Count)
    {
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v27, MutableCopy);
      if (!Copy)
      {
        uint64_t v31 = scn_default_log();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
          __C3DShaderModifierCreate_cold_1(v31, v32, v33, v34, v35, v36, v37, v38);
        }
      }
      CFDictionaryRef v39 = *(CFDictionaryRef *)(Instance + 32);
      if (v39 != Copy)
      {
        if (v39)
        {
          CFRelease(v39);
          *(void *)(Instance + 32) = 0;
        }
        if (Copy) {
          CFTypeRef v40 = CFRetain(Copy);
        }
        else {
          CFTypeRef v40 = 0;
        }
        *(void *)(Instance + 32) = v40;
      }
      CFRelease(Copy);
    }
    CFRelease(MutableCopy);
  }
  CFDictionaryRef v41 = *(const __CFDictionary **)(Instance + 32);
  if (v41)
  {
    if (CFDictionaryGetCountOfKey(v41, @"USE_TANGENT")
      || CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_TANGENT"))
    {
      v24 |= 4u;
    }
    CFDictionaryRef v42 = *(const __CFDictionary **)(Instance + 32);
    *(_WORD *)(Instance + 92) = v24;
    if (v42)
    {
      if (CFDictionaryGetCountOfKey(v42, @"USE_EMISSIVETEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 1u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_AMBIENTTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 2u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_DIFFUSETEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 4u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_SPECULARTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 8u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_REFLECTIVETEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x10u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_TRANSPARENTTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x20u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_FILTERTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x40u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_NORMALTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x80u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_METALNESSTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x400u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_ROUGHNESSTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x800u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_CLEARCOATTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x1000u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_CLEARCOATROUGHNESSTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x2000u;
      }
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), @"USE_CLEARCOATNORMALTEXCOORD")) {
        *(_WORD *)(Instance + 94) |= 0x4000u;
      }
    }
  }
  else
  {
    *(_WORD *)(Instance + 92) = v24;
  }
  if (*(void *)(Instance + 24))
  {
    strcpy((char *)&cStr, "_geometry.texcoords[x]");
    CFStringRef v43 = CFStringCreateWithCStringNoCopy(*v25, (const char *)&cStr, 0x600u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    for (int i = 0; i != 8; ++i)
    {
      LOBYTE(cStr.hash[3]) = i + 48;
      if (CFStringFind((CFStringRef)*(void *)(Instance + 24), v43, 0).location != -1) {
        *(_WORD *)(Instance + 96) |= 1 << i;
      }
    }
    CFRelease(v43);
  }
  memset(&cStr, 0, sizeof(cStr));
  CC_SHA256_Init(&cStr);
  CC_SHA256_Update(&cStr, (const void *)(Instance + 88), 4u);
  uint64_t v45 = *(void *)(Instance + 24);
  if (v45) {
    CFStringUpdateHash(v45);
  }
  uint64_t v46 = *(void *)(Instance + 16);
  if (v46) {
    CFStringUpdateHash(v46);
  }
  CFDictionaryRef v47 = *(const __CFDictionary **)(Instance + 32);
  if (v47) {
    CFDictionaryApplyFunction(v47, (CFDictionaryApplierFunction)CFStringToStringDictionaryHash, &cStr);
  }
  CC_SHA256_Final((unsigned __int8 *)(Instance + 104), &cStr);
  *(_DWORD *)(Instance + 100) = a3;
  C3DShaderSourceParserContextDestroy((uint64_t)&v52);
  return Instance;
}

void C3DCFDictionaryApplyBlock(const __CFDictionary *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t context = a2;
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)_C3DCFDictionaryApplyBlock, &context);
    }
  }
}

void C3DShaderSourceParserParseSource(CFStringRef theString, uint64_t a2, int a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x263EFFB08], theString, @"\n");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFMutableStringRef Mutable = CFStringCreateMutable(v5, 0);
  *(_WORD *)(a2 + 72) = 0;
  if (Count < 1) {
    goto LABEL_41;
  }
  CFIndex v9 = 0;
  int v10 = 4;
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v9);
    if (C3DSourceCodeHasPrefix(ValueAtIndex, @"//")) {
      goto LABEL_15;
    }
    if (a3)
    {
      if (!C3DSourceCodeHasPrefix(ValueAtIndex, @"uniform")) {
        goto LABEL_15;
      }
      CFStringRef v12 = ValueAtIndex;
      uint64_t v13 = a2;
      char v14 = 1;
      goto LABEL_14;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma opaque"))
    {
      __int16 v15 = *(_WORD *)(a2 + 72) | 1;
LABEL_11:
      *(_WORD *)(a2 + 72) = v15;
      goto LABEL_15;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma transparent"))
    {
      __int16 v15 = *(_WORD *)(a2 + 72) | 2;
      goto LABEL_11;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, @"uniform"))
    {
      CFStringRef v12 = ValueAtIndex;
      uint64_t v13 = a2;
      char v14 = 0;
LABEL_14:
      __analyseUniformDeclaration(v12, v13, v14);
      goto LABEL_15;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma declaration"))
    {
LABEL_18:
      int v10 = 0;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma arguments"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_26BF72F58);
      }
LABEL_23:
      int v10 = 1;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma varyings"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_26BF72F58);
      }
LABEL_35:
      int v10 = 2;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, @"#pragma body"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_26BF72F58);
      }
LABEL_37:
      int v10 = 3;
    }
    else
    {
      switch(v10)
      {
        case 0:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)a2, ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)a2, @"\n");
          goto LABEL_18;
        case 1:
          __analyseArgumentDeclaration(ValueAtIndex, a2);
          goto LABEL_23;
        case 2:
          __analyseVaryingDeclaration(ValueAtIndex, a2);
          goto LABEL_35;
        case 3:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), @"\n");
          goto LABEL_37;
        case 4:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(Mutable, ValueAtIndex);
          CFStringAppend(Mutable, @"\n");
          int v10 = 4;
          break;
        default:
          break;
      }
    }
LABEL_15:
    ++v9;
  }
  while (Count != v9);
  if (v10 == 4)
  {
LABEL_41:
    if (CFStringGetLength(Mutable))
    {
      CFStringAppend(*(CFMutableStringRef *)(a2 + 8), Mutable);
      CFStringReplaceAll(Mutable, &stru_26BF72F58);
    }
  }
  CFRelease(Mutable);

  CFRelease(ArrayBySeparatingStrings);
}

BOOL C3DSourceCodeHasPrefix(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  CFStringRef theString = a1;
  uint64_t v46 = 0;
  uint64_t v47 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  int v44 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  long long v32 = 0uLL;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)CFTypeRef v23 = 0u;
  long long v24 = 0u;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v45 = CStringPtr;
  v31[0] = a2;
  long long v33 = (unint64_t)v5;
  uint64_t v34 = 0;
  CFStringRef v8 = (const __CFString *)CFStringGetCharactersPtr(a2);
  CFIndex v9 = 0;
  v31[1] = v8;
  if (!v8) {
    CFIndex v9 = CFStringGetCStringPtr(a2, 0x600u);
  }
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v36 = 0u;
  *((void *)&v33 + 1) = 0;
  uint64_t v34 = 0;
  *(void *)&long long v32 = v9;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  C3DInlineBufferConsumeWhitespaces(buffer, &v22, Length);
LABEL_6:
  C3DInlineBufferConsumeWhitespaces(v23, &v21, v5);
  uint64_t v10 = v21;
  while (1)
  {
    if (v10 == v5) {
      return 1;
    }
    uint64_t v11 = v22;
    if (v22 == Length) {
      goto LABEL_51;
    }
    if (v22 < 0 || (uint64_t v12 = v47, v47 <= v22))
    {
      UniChar v13 = 0;
    }
    else if (v44)
    {
      UniChar v13 = v44[v46 + v22];
    }
    else if (v45)
    {
      UniChar v13 = v45[v46 + v22];
    }
    else
    {
      if (v49 <= v22 || (uint64_t v16 = v48, v48 > v22))
      {
        uint64_t v17 = v22 - 4;
        if ((unint64_t)v22 < 4) {
          uint64_t v17 = 0;
        }
        if (v17 + 64 < v47) {
          uint64_t v12 = v17 + 64;
        }
        uint64_t v48 = v17;
        uint64_t v49 = v12;
        v50.location = v46 + v17;
        v50.CFIndex length = v12 - v17;
        CFStringGetCharacters(theString, v50, buffer);
        uint64_t v16 = v48;
      }
      UniChar v13 = buffer[v11 - v16];
    }
    if (v10 < 0 || (uint64_t v14 = v33, (uint64_t)v33 <= v10))
    {
      UniChar v15 = 0;
    }
    else if (v31[1])
    {
      UniChar v15 = *((_WORD *)&v31[1]->isa + *((void *)&v32 + 1) + v10);
    }
    else if ((void)v32)
    {
      UniChar v15 = *(char *)(v32 + *((void *)&v32 + 1) + v10);
    }
    else
    {
      if (v34 <= v10 || (uint64_t v18 = *((void *)&v33 + 1), *((uint64_t *)&v33 + 1) > v10))
      {
        uint64_t v19 = v10 - 4;
        if ((unint64_t)v10 < 4) {
          uint64_t v19 = 0;
        }
        if (v19 + 64 < (uint64_t)v33) {
          uint64_t v14 = v19 + 64;
        }
        *((void *)&v33 + 1) = v19;
        uint64_t v34 = v14;
        v51.location = *((void *)&v32 + 1) + v19;
        v51.CFIndex length = v14 - v19;
        CFStringGetCharacters(v31[0], v51, v23);
        uint64_t v18 = *((void *)&v33 + 1);
      }
      UniChar v15 = v23[v10 - v18];
    }
    if (v15 == 12288
      || (unsigned __int16)(v15 - 0x2000) < 0xCu
      || v15 < 0x21u
      || (unsigned __int16)(v15 - 127) <= 0x21u)
    {
      if (v13 == 12288
        || (unsigned __int16)(v13 - 0x2000) < 0xCu
        || v13 < 0x21u
        || (unsigned __int16)(v13 - 127) <= 0x21u)
      {
        C3DInlineBufferConsumeWhitespaces(buffer, &v22, Length);
        goto LABEL_6;
      }
LABEL_51:
      C3DInlineBufferConsumeWhitespaces(v23, &v21, v5);
      return v21 == v5;
    }
    if (v13 != v15) {
      return 0;
    }
    uint64_t v21 = ++v10;
    uint64_t v22 = v11 + 1;
  }
}

void C3DInlineBufferConsumeWhitespaces(UniChar *buffer, uint64_t *a2, uint64_t a3)
{
  for (uint64_t i = *a2; i < a3; *a2 = i)
  {
    if (i < 0 || (uint64_t v7 = *((void *)buffer + 20), v7 <= i))
    {
      UniChar v9 = 0;
    }
    else
    {
      uint64_t v8 = *((void *)buffer + 17);
      if (v8)
      {
        UniChar v9 = *(_WORD *)(v8 + 2 * (*((void *)buffer + 19) + i));
      }
      else
      {
        uint64_t v10 = *((void *)buffer + 18);
        if (v10)
        {
          UniChar v9 = *(char *)(v10 + *((void *)buffer + 19) + i);
        }
        else
        {
          if (*((void *)buffer + 22) <= i || (uint64_t v11 = *((void *)buffer + 21), v11 > i))
          {
            uint64_t v12 = i - 4;
            if ((unint64_t)i < 4) {
              uint64_t v12 = 0;
            }
            if (v12 + 64 < v7) {
              uint64_t v7 = v12 + 64;
            }
            *((void *)buffer + 21) = v12;
            *((void *)buffer + 22) = v7;
            v13.location = *((void *)buffer + 19) + v12;
            v13.CFIndex length = v7 - v12;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v13, buffer);
            uint64_t v11 = *((void *)buffer + 21);
          }
          UniChar v9 = buffer[i - v11];
        }
      }
    }
    if (v9 != 12288 && (unsigned __int16)(v9 - 0x2000) >= 0xCu && v9 >= 0x21u && (unsigned __int16)(v9 - 127) > 0x21u) {
      break;
    }
    uint64_t i = *a2 + 1;
  }
}

uint64_t __analyseStandardUniformUsage(const __CFString *a1, uint64_t a2)
{
  memset(v18, 0, 240);
  CFIndex Length = CFStringGetLength(a1);
  C3DStringTokenizerInit((uint64_t)v18, a1, 0, Length, 1);
  CFDictionaryRef StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
  uint64_t result = C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
  if (result)
  {
    BOOL v7 = 0;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    while (1)
    {
      if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)v18)) {
        C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      }
      CFIndex CurrentTokenRange = C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
      CFIndex v11 = v10;
      v19.location = CurrentTokenRange;
      v19.CFIndex length = v10;
      uint64_t result = CFStringCompareWithOptions(a1, @"/", v19, 0);
      BOOL v12 = result == 0;
      if (!result)
      {
        if (v7) {
          return result;
        }
        goto LABEL_14;
      }
      v20.location = CurrentTokenRange;
      v20.CFIndex length = v11;
      if (CFStringCompareWithOptions(a1, @"scn_node", v20, 0))
      {
        v21.location = CurrentTokenRange;
        v21.CFIndex length = v11;
        if (CFStringCompareWithOptions(a1, @"scn_frame", v21, 0)) {
          goto LABEL_10;
        }
      }
      C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      v22.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
      CFIndex v14 = v13;
      v22.CFIndex length = v13;
      if (CFStringCompareWithOptions(a1, @".", v22, 0) == kCFCompareEqualTo) {
        break;
      }
LABEL_14:
      uint64_t result = C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      BOOL v7 = v12;
      if ((result & 1) == 0) {
        return result;
      }
    }
    C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
    C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
    v11 += v14 + v15;
LABEL_10:
    v23.location = CurrentTokenRange;
    v23.CFIndex length = v11;
    CFStringRef v16 = CFStringCreateWithSubstring(v8, a1, v23);
    CFDictionaryRef Value = (const void **)CFDictionaryGetValue(StandardUniforms, v16);
    if (Value) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 64), v16, *Value);
    }
    CFRelease(v16);
    goto LABEL_14;
  }
  return result;
}

uint64_t _C3DStringTokenizerAdvanceToNextToken(uint64_t a1, int a2)
{
  uint64_t result = 0;
  uint64_t v4 = *(void *)(a1 + 208) + *(void *)(a1 + 200);
  uint64_t v5 = *(void *)(a1 + 8) + *(void *)a1;
  *(unsigned char *)(a1 + 217) = 0;
  if (v4 >= v5) {
    return result;
  }
  uint64_t v7 = a1 + 16;
  while (1)
  {
    uint64_t v8 = v4 - *(void *)a1;
    if (v8 < 0 || (uint64_t v9 = *(void *)(a1 + 176), v9 <= v8))
    {
      UniChar v11 = 0;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 152);
      if (v10)
      {
        UniChar v11 = *(_WORD *)(v10 + 2 * (*(void *)(a1 + 168) + v8));
      }
      else
      {
        uint64_t v22 = *(void *)(a1 + 160);
        if (v22)
        {
          UniChar v11 = *(char *)(v22 + *(void *)(a1 + 168) + v8);
        }
        else
        {
          if (*(void *)(a1 + 192) <= v8 || (uint64_t v23 = *(void *)(a1 + 184), v23 > v8))
          {
            uint64_t v24 = v8 - 4;
            if ((unint64_t)v8 < 4) {
              uint64_t v24 = 0;
            }
            if (v24 + 64 < v9) {
              uint64_t v9 = v24 + 64;
            }
            *(void *)(a1 + 184) = v24;
            *(void *)(a1 + 192) = v9;
            v40.location = *(void *)(a1 + 168) + v24;
            v40.CFIndex length = v9 - v24;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v40, (UniChar *)(a1 + 16));
            uint64_t v23 = *(void *)(a1 + 184);
          }
          UniChar v11 = *(_WORD *)(v7 + 2 * (v8 - v23));
        }
      }
    }
    ++v4;
    if (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v11))
    {
      uint64_t v12 = v4;
      do
      {
        uint64_t v4 = v12;
        uint64_t v13 = v12 - *(void *)a1;
        if (v13 < 0 || (uint64_t v14 = *(void *)(a1 + 176), v14 <= v13))
        {
          UniChar v16 = 0;
        }
        else
        {
          uint64_t v15 = *(void *)(a1 + 152);
          if (v15)
          {
            UniChar v16 = *(_WORD *)(v15 + 2 * (*(void *)(a1 + 168) + v13));
          }
          else
          {
            uint64_t v17 = *(void *)(a1 + 160);
            if (v17)
            {
              UniChar v16 = *(char *)(v17 + *(void *)(a1 + 168) + v13);
            }
            else
            {
              if (*(void *)(a1 + 192) <= v13 || (uint64_t v18 = *(void *)(a1 + 184), v18 > v13))
              {
                uint64_t v19 = v13 - 4;
                if ((unint64_t)v13 < 4) {
                  uint64_t v19 = 0;
                }
                if (v19 + 64 < v14) {
                  uint64_t v14 = v19 + 64;
                }
                *(void *)(a1 + 184) = v19;
                *(void *)(a1 + 192) = v14;
                v39.location = *(void *)(a1 + 168) + v19;
                v39.CFIndex length = v14 - v19;
                CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v39, (UniChar *)(a1 + 16));
                uint64_t v18 = *(void *)(a1 + 184);
              }
              UniChar v16 = *(_WORD *)(v7 + 2 * (v13 - v18));
            }
          }
        }
        uint64_t v12 = v4 + 1;
      }
      while (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v16));
      uint64_t v20 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
      *(void *)(a1 + 200) = v20;
      *(void *)(a1 + 208) = v4 - v20;
      if (*(unsigned char *)(a1 + 216))
      {
        uint64_t result = 1;
        *(unsigned char *)(a1 + 217) = 1;
        return result;
      }
      goto LABEL_32;
    }
    if (v11 == 95 || CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v11)) {
      break;
    }
    uint64_t v21 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
    *(void *)(a1 + 200) = v21;
    *(void *)(a1 + 208) = v4 - v21;
    if (*(unsigned char *)(a1 + 216)) {
      return 1;
    }
LABEL_32:
    if (v4 >= v5) {
      return 0;
    }
  }
  char v25 = 0;
  uint64_t v26 = v4;
  do
  {
LABEL_45:
    uint64_t v27 = v26;
    while (1)
    {
      uint64_t v26 = v27;
      uint64_t v28 = v4++;
      uint64_t v29 = v28 - *(void *)a1;
      if (v29 < 0 || (uint64_t v30 = *(void *)(a1 + 176), v30 <= v29))
      {
        UniChar v32 = 0;
      }
      else
      {
        uint64_t v31 = *(void *)(a1 + 152);
        if (v31)
        {
          UniChar v32 = *(_WORD *)(v31 + 2 * (*(void *)(a1 + 168) + v29));
        }
        else
        {
          uint64_t v35 = *(void *)(a1 + 160);
          if (v35)
          {
            UniChar v32 = *(char *)(v35 + *(void *)(a1 + 168) + v29);
          }
          else
          {
            if (*(void *)(a1 + 192) <= v29 || (uint64_t v36 = *(void *)(a1 + 184), v36 > v29))
            {
              uint64_t v37 = v29 - 4;
              if ((unint64_t)v29 < 4) {
                uint64_t v37 = 0;
              }
              if (v37 + 64 < v30) {
                uint64_t v30 = v37 + 64;
              }
              *(void *)(a1 + 184) = v37;
              *(void *)(a1 + 192) = v30;
              v41.location = *(void *)(a1 + 168) + v37;
              v41.CFIndex length = v30 - v37;
              CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v41, (UniChar *)(a1 + 16));
              uint64_t v36 = *(void *)(a1 + 184);
            }
            UniChar v32 = *(_WORD *)(v7 + 2 * (v29 - v36));
          }
        }
        if (v32 == 95)
        {
          CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), 0x5Fu);
          goto LABEL_52;
        }
      }
      int IsCharacterMember = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v32);
      int v34 = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v32);
      if (!IsCharacterMember) {
        break;
      }
LABEL_52:
      uint64_t v27 = v4;
      if (v25) {
        goto LABEL_70;
      }
    }
    if (!a2) {
      break;
    }
    char v25 = 1;
    if (v32 == 42)
    {
      uint64_t v26 = v4;
      goto LABEL_45;
    }
  }
  while (v34);
LABEL_70:
  uint64_t v38 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
  *(void *)(a1 + 200) = v38;
  *(void *)(a1 + 208) = v26 - v38;
  return 1;
}

uint64_t C3DStringTokenizerAdvanceToNextToken(uint64_t a1)
{
  return _C3DStringTokenizerAdvanceToNextToken(a1, 0);
}

uint64_t C3DStringTokenizerGetCurrentTokenRange(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

uint64_t C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 217);
}

CFCharacterSetRef C3DStringTokenizerInit(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, char a5)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = a4;
  if (theString)
  {
    *(void *)(a1 + 144) = theString;
    *(void *)(a1 + 168) = a3;
    *(void *)(a1 + 176) = a4;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    *(void *)(a1 + 152) = CharactersPtr;
    if (CharactersPtr) {
      CStringPtr = 0;
    }
    else {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    *(void *)(a1 + 160) = CStringPtr;
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
  }
  *(void *)(a1 + 200) = a3;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = a5;
  *(void *)(a1 + 224) = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFCharacterSetRef result = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
  *(void *)(a1 + 232) = result;
  return result;
}

uint64_t C3DShaderGetStandardUniforms()
{
  if (C3DShaderGetStandardUniforms_onceToken != -1) {
    dispatch_once(&C3DShaderGetStandardUniforms_onceToken, &__block_literal_global_146);
  }
  return C3DShaderGetStandardUniforms_s_standardUniforms;
}

void __analyseArgumentDeclaration(const __CFString *a1, uint64_t a2)
{
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  CFIndex Length = CFStringGetLength(a1);
  C3DStringTokenizerInit((uint64_t)&v29, a1, 0, Length, 1);
  _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)&v29)) {
    _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  }
  v44.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  v44.CFIndex length = v5;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFStringRef v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x263EFFB08], a1, v44);
  _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  v45.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  v45.CFIndex length = v8;
  if (CFStringCompareWithOptions(a1, @"<", v45, 0))
  {
    MutableCFDictionaryRef Copy = (CFMutableStringRef)v7;
  }
  else
  {
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(v6, 0, v7);
    do
    {
      CFIndex CurrentTokenRange = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
      CFIndex v12 = v11;
      v46.location = CurrentTokenRange;
      v46.CFIndex length = v11;
      CFStringRef v13 = CFStringCreateWithSubstring(v6, a1, v46);
      CFStringAppend(MutableCopy, v13);
      CFRelease(v13);
      v47.location = CurrentTokenRange;
      v47.CFIndex length = v12;
      CFComparisonResult v14 = CFStringCompareWithOptions(a1, @">", v47, 0);
      char Token = _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
    }
    while (v14 && (Token & 1) != 0);
    CFRelease(v7);
  }
  if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)&v29)) {
    _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  }
  CFIndex v16 = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  CFIndex v18 = v17;
  v48.location = v16;
  v48.CFIndex length = v17;
  CFStringRef v19 = CFStringCreateWithSubstring(v6, a1, v48);
  if (CFStringGetLength(MutableCopy) >= 1)
  {
    int v20 = *(_DWORD *)(a2 + 76) == 1 ? C3DBaseTypeFromGLSLString(MutableCopy) : C3DBaseTypeFromMetalString(MutableCopy);
    int v21 = v20;
    if (v20)
    {
      CFIndex v22 = v16 + v18;
      CFIndex v23 = CFStringGetLength(a1);
      if (v23 > v22)
      {
        v49.location = v22;
        v49.CFIndex length = v23 - v22;
        uint64_t v24 = (__CFString *)CFStringCreateWithSubstring(v6, a1, v49);
        uint64_t v25 = [(__CFString *)v24 rangeOfString:@"=", v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43];
        if (v26)
        {
          CFStringRef v27 = (const __CFString *)[(__CFString *)v24 substringFromIndex:v25 + 1];
          uint64_t v28 = (const void *)C3DValueCreate(v21, 1);
          C3DValueSetValueFromString((uint64_t)v28, v27);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 40), v19, v28);
          CFRelease(v28);
        }
        CFRelease(v24);
      }
    }
  }
  if (CFStringGetLength(v19) >= 1 && CFStringGetLength(MutableCopy) >= 1) {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 32), v19, MutableCopy);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

CFComparisonResult __C3DBaseTypeFromMetalString(const __CFString *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (CFEqual(a1, @"int")) {
    return 2;
  }
  if (CFEqual(a1, @"BOOL")) {
    return 3;
  }
  if (CFEqual(a1, @"texture1d")
    || CFEqual(a1, @"texture2d")
    || CFEqual(a1, @"texture3d")
    || CFEqual(a1, @"texturecube"))
  {
    return 5;
  }
  if (CFEqual(a1, @"float")) {
    return 1;
  }
  if (CFEqual(a1, @"float2")) {
    return 8;
  }
  if (CFEqual(a1, @"float3")) {
    return 9;
  }
  if (CFEqual(a1, @"float4")) {
    return 10;
  }
  if (CFEqual(a1, @"int2")) {
    return 18;
  }
  if (CFEqual(a1, @"int3")) {
    return 19;
  }
  if (CFEqual(a1, @"int4")) {
    return 20;
  }
  if (CFEqual(a1, @"float4x4")) {
    return 11;
  }
  CFComparisonResult result = CFStringCompare(a1, @"none", 0);
  if (result)
  {
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    CFComparisonResult result = kCFCompareEqualTo;
    if (v4)
    {
      int v5 = 138412290;
      CFStringRef v6 = a1;
      _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: C3DBaseTypeFromMetalString: unknown type name '%@'", (uint8_t *)&v5, 0xCu);
      return 0;
    }
  }
  return result;
}

CFComparisonResult C3DBaseTypeFromMetalString(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (v2.length)
  {
    v7.CFIndex length = v2.location;
    v7.location = 0;
    CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v7);
    CFComparisonResult v4 = __C3DBaseTypeFromMetalString(v3);
    CFRelease(v3);
    return v4;
  }
  else
  {
    return __C3DBaseTypeFromMetalString(a1);
  }
}

void C3DShaderSourceParserContextDestroy(uint64_t a1)
{
  CFRange v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(void *)a1 = 0;
  }
  CFStringRef v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 8) = 0;
  }
  CFComparisonResult v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
  int v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0;
  }
  CFStringRef v6 = *(const void **)(a1 + 56);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 56) = 0;
  }
  CFRange v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 40) = 0;
  }
  CFIndex v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 64) = 0;
  }
}

CFMutableDictionaryRef C3DShaderSourceParserContextCreate@<X0>(char a1@<W0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if (a1)
  {
    CFMutableDictionaryRef Mutable = 0;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  }
  else
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    *(void *)a3 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    *(void *)(a3 + 8) = CFStringCreateMutable(v6, 0);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  }
  *(void *)(a3 + 16) = Mutable;
  CFRange v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  *(void *)(a3 + 24) = CFDictionaryCreateMutable(v6, 0, MEMORY[0x263EFFF88], 0);
  CFIndex v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  *(void *)(a3 + 56) = CFDictionaryCreateMutable(v6, 0, v7, MEMORY[0x263EFFF90]);
  *(void *)(a3 + 32) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(void *)(a3 + 40) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(void *)(a3 + 48) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(void *)(a3 + 64) = result;
  *(_DWORD *)(a3 + 76) = a2;
  return result;
}

void C3DGetShadingLanguageFromSource(NSString *a1)
{
  ShaderConverter::ShaderConverter((ShaderConverter *)v1, a1);
  ShaderConverter::Parse(v1);
}

void sub_20B274184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ShaderConverter::~ShaderConverter(ShaderConverter *this)
{
  *(void *)this = &unk_26BF69F80;
  uint64_t v2 = *((void *)this + 11);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 9);
  if (v3)
  {
    std::__tree<char>::destroy(v3 + 80, *(void **)(v3 + 88));
    MEMORY[0x210534FE0](v3, 0x1060C4014D1E9E2);
  }
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 200, *((void **)this + 26));
  std::__tree<std::string>::destroy((uint64_t)this + 176, *((char **)this + 23));
  CFComparisonResult v4 = (void *)*((void *)this + 19);
  if (v4)
  {
    *((void *)this + 20) = v4;
    operator delete(v4);
  }
  int v5 = (void **)((char *)this + 128);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](&v5);
  int v5 = (void **)((char *)this + 104);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](&v5);
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

{
  uint64_t vars8;

  ShaderConverter::~ShaderConverter(this);

  JUMPOUT(0x210534FE0);
}

void std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        std::allocator<Variable>::destroy[abi:nn180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ShaderConverter::ShaderConverter(ShaderConverter *this, NSString *a2)
{
  *(void *)this = &unk_26BF69F80;
  *((void *)this + 1) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 96) = 0;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 132) = 0u;
  *(_OWORD *)((char *)this + 148) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((void *)this + 26) = 0;
  *((void *)this + 25) = (char *)this + 208;
  *((void *)this + 27) = 0;
  MEMORY[0x210534E80]((char *)this + 8, [(NSString *)a2 UTF8String]);
  if (ShaderConverter::StaticInit(void)::onceToken != -1) {
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
  }
}

void sub_20B274428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v6 = v4;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v6, *(void **)(v2 + 208));
  std::__tree<std::string>::destroy(v5, *(char **)(v2 + 184));
  CFIndex v8 = *(void **)(v2 + 152);
  if (v8)
  {
    *(void *)(v2 + 160) = v8;
    operator delete(v8);
  }
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }
  _Unwind_Resume(a1);
}

void _C3DRasterizerStatesCFFinalize(unsigned char *a1)
{
  if (a1[44])
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock))
    {
      uint64_t v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
        _C3DRasterizerStatesCFFinalize_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
    if (!CFSetContainsValue((CFSetRef)s_RasterizerStatesRegistry, a1))
    {
      uint64_t v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        _C3DRasterizerStatesCFFinalize_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
      }
    }
    CFSetRemoveValue((CFMutableSetRef)s_RasterizerStatesRegistry, a1);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationRasterizerStatesDidDie", a1, 0, 1u);
  }
}

void sub_20B274754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DTextureSamplerGetMipFilter(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 36);
}

void sub_20B275074(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DEnumIterator<C3DEffectProperty,(signed char)0,(signed char)15>::end()
{
  CFTypeID v0 = &OBJC_IVAR___SCNGeometry__edgeCreasesSource;
  {
    CFTypeID v0 = &OBJC_IVAR___SCNGeometry__edgeCreasesSource;
    if (v2)
    {
      C3DEnumIterator<C3DEffectProperty,(signed char)0,(signed char)15>::end(void)::end = 16;
      CFTypeID v0 = &OBJC_IVAR___SCNGeometry__edgeCreasesSource;
    }
  }
  return *((unsigned __int8 *)v0 + 2640);
}

uint64_t SCNMTLPixelFormatGetBitSize()
{
  return 0;
}

unint64_t SCNMTLRenderPipelineApplyRenderPassDescriptor(uint64_t a1, void *a2)
{
  for (uint64_t i = 0; i != 8; ++i)
    *(void *)(a1 + 8 * i) = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", i), "texture"), "pixelFormat");
  *(void *)(a1 + 64) = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "depthAttachment"), "texture"), "pixelFormat");
  *(void *)(a1 + 72) = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "stencilAttachment"), "texture"), "pixelFormat");
  *(unsigned char *)(a1 + 80) = 1;
  unint64_t v5 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture"), "sampleCount");
  if (v5 <= 1) {
    unsigned __int8 v6 = 1;
  }
  else {
    unsigned __int8 v6 = v5;
  }
  *(unsigned char *)(a1 + 80) = v6;
  unint64_t v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "depthAttachment"), "texture"), "sampleCount");
  if (v6 <= v7) {
    unsigned __int8 v6 = v7;
  }
  *(unsigned char *)(a1 + 80) = v6;
  unint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "stencilAttachment"), "texture"), "sampleCount");
  char v9 = v6;
  if (v6 <= result) {
    char v9 = result;
  }
  *(unsigned char *)(a1 + 80) = v9;
  return result;
}

void sub_20B275964(_Unwind_Exception *a1)
{
}

uint64_t C3DFXMetalProgramGetFunctionName(CFTypeRef cf, int a2)
{
  if (!cf)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeID v12 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v12 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  return *((void *)cf + a2 + 10);
}

uint64_t C3DFXMetalProgramGetHash(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v2 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return a1[21];
}

id _pipelineDescriptorForPipelineDesc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    uint64_t v21 = 0;
    uint64_t v3 = [*(id *)(a1 + 120) newFunctionWithName:*(void *)(a1 + 312) constantValues:v2 error:&v21];
    if (!v3)
    {
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        _pipelineDescriptorForPipelineDesc_cold_3();
      }
      return 0;
    }
    uint64_t v4 = (void *)v3;
    uint64_t v5 = [*(id *)(a1 + 120) newFunctionWithName:*(void *)(a1 + 320) constantValues:*(void *)(a1 + 296) error:&v21];
    if (!v5)
    {
      uint64_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        _pipelineDescriptorForPipelineDesc_cold_4();
      }
LABEL_35:

      return 0;
    }
  }
  else
  {
    uint64_t v7 = [*(id *)(a1 + 120) newFunctionWithName:*(void *)(a1 + 312)];
    if (!v7)
    {
      uint64_t v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        _pipelineDescriptorForPipelineDesc_cold_1();
      }
      return 0;
    }
    uint64_t v4 = (void *)v7;
    if (!*(void *)(a1 + 320))
    {
      uint64_t v8 = 0;
      goto LABEL_15;
    }
    uint64_t v5 = objc_msgSend(*(id *)(a1 + 120), "newFunctionWithName:");
    if (!v5)
    {
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        _pipelineDescriptorForPipelineDesc_cold_2();
      }
      goto LABEL_35;
    }
  }
  uint64_t v8 = (void *)v5;
LABEL_15:
  id v11 = objc_alloc_init(MEMORY[0x263F129C0]);
  [v11 setVertexFunction:v4];

  [v11 setFragmentFunction:v8];
  [v11 setFragmentLinkedFunctions:*(void *)(a1 + 336)];
  [v11 setVertexLinkedFunctions:*(void *)(a1 + 328)];
  for (uint64_t i = 0; i != 8; ++i)
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", i), "setPixelFormat:", *(void *)(a1 + 128 + 8 * i));
  if (*(unsigned char *)(a1 + 355))
  {
    for (uint64_t j = 0; j != 8; ++j)
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", j), "setWriteMask:", *(void *)(a1 + 224 + 8 * j));
  }
  uint64_t v14 = *(void *)(a1 + 216);
  if (v14) {
    C3DApplyBlendStatesToRenderPipelineDescriptor(v14, v11);
  }
  [v11 setVertexDescriptor:*(void *)(a1 + 304)];
  if (*(unsigned __int8 *)(a1 + 208) <= 1u) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 208);
  }
  [v11 setRasterSampleCount:v15];
  [v11 setDepthAttachmentPixelFormat:*(void *)(a1 + 192)];
  [v11 setStencilAttachmentPixelFormat:*(void *)(a1 + 200)];
  if (*(unsigned __int8 *)(a1 + 59) >= 2uLL) {
    objc_msgSend(v11, "setMaxVertexAmplificationCount:");
  }
  uint64_t v16 = *(void *)(a1 + 344);
  if (v16) {
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v11);
  }
  if (![v11 vertexFunction])
  {
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_impl(&dword_20B249000, v17, OS_LOG_TYPE_INFO, "Info: Shaders without a vertex function are not allowed", v20, 2u);
    }
    return 0;
  }
  [v11 setInputPrimitiveTopology:*(unsigned __int8 *)(a1 + 288)];
  return v11;
}

void SCNMTLRenderPipelineDescRelease(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);

  uint64_t v3 = *(const void **)(a1 + 216);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 216) = 0;
  }

  uint64_t v4 = *(void **)(a1 + 344);
}

uint64_t C3DFXMetalProgramGetLinkedFunctionsFamilies(unsigned int *cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    id v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return cf[36];
}

uint64_t C3DFXMetalProgramGetConstants(CFTypeRef cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    id v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return *((void *)cf + 16);
}

uint64_t C3DApplyBlendStatesToRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  DesCC_SHA256_CTX c = C3DBlendStatesGetDesc(a1, 0);
  unint64_t v4 = HIDWORD(Desc);
  uint64_t v5 = objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", 0);
  uint64_t v6 = [v5 pixelFormat];
  if ((_BYTE)Desc) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  uint64_t v8 = !v7;
  [v5 setBlendingEnabled:v8];
  [v5 setSourceRGBBlendFactor:C3DBlendFactorToMTLBlendFactor(BYTE2(Desc))];
  [v5 setDestinationRGBBlendFactor:C3DBlendFactorToMTLBlendFactor(BYTE3(Desc))];
  [v5 setRgbBlendOperation:C3DBlendOpToMTLBlendOperation(BYTE4(Desc))];
  unint64_t v9 = HIBYTE(Desc);
  unint64_t v10 = Desc >> 40;
  BOOL v11 = (Desc & 0xFF00) == 0;
  if ((Desc & 0xFF00) != 0)
  {
    unsigned __int8 v12 = BYTE6(Desc);
  }
  else
  {
    LOBYTE(v10) = BYTE2(Desc);
    unsigned __int8 v12 = BYTE3(Desc);
  }
  if (v11) {
    unsigned __int8 v13 = v4;
  }
  else {
    unsigned __int8 v13 = v9;
  }
  [v5 setSourceAlphaBlendFactor:C3DBlendFactorToMTLBlendFactor(v10)];
  [v5 setDestinationAlphaBlendFactor:C3DBlendFactorToMTLBlendFactor(v12)];
  uint64_t v14 = C3DBlendOpToMTLBlendOperation(v13);

  return [v5 setAlphaBlendOperation:v14];
}

uint64_t C3DBlendFactorToMTLBlendFactor(unsigned int a1)
{
  if (a1 >= 0xF)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DBlendFactorToMTLBlendFactor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_BlendModes[a1];
}

uint64_t C3DBlendOpToMTLBlendOperation(unsigned int a1)
{
  if (a1 >= 5)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DBlendOpToMTLBlendOperation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_BlendOps[a1];
}

uint64_t C3DBlendStatesGetDesc(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DBlendStatesGetDesc_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 48) <= a2)
  {
    unsigned __int8 v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DBlendStatesGetDesc_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return *(void *)(a1 + 8 * a2 + 16);
}

uint64_t C3DFXMetalProgramGetBufferBindings(CFTypeRef cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return *((void *)cf + 17);
}

id SCNMTLRenderPipelineDescRetain(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  id v3 = *(id *)a1;
  id v4 = v2;
  id v5 = *(id *)(a1 + 120);
  id v6 = *(id *)(a1 + 304);
  uint64_t v7 = *(const void **)(a1 + 216);
  if (v7) {
    CFRetain(v7);
  }
  id v8 = *(id *)(a1 + 296);
  id v9 = *(id *)(a1 + 312);
  id v10 = *(id *)(a1 + 320);
  uint64_t v11 = *(void **)(a1 + 344);

  return v11;
}

uint64_t C3DFXMetalProgramGetSourceCode(CFTypeRef cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return *((void *)cf + 12);
}

uint64_t C3DFXMetalProgramGetPreprocessorsMacros(CFTypeRef cf)
{
  if (!cf)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return *((void *)cf + 14);
}

uint64_t C3DFXMetalProgramGetLibraryProviderBlock(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v2 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return a1[20];
}

BOOL C3DImageIsCatalogTexture(uint64_t a1)
{
  return *(_DWORD *)(a1 + 96) == 5;
}

unint64_t SCNMTLBlitCommandEncoder::generateMipmapsForTexture(void **a1, void *a2)
{
  unint64_t result = [a2 mipmapLevelCount];
  if (result >= 2)
  {
    if ((unint64_t)[a2 width] > 1
      || (unint64_t)[a2 height] > 1
      || (unint64_t result = [a2 depth], result >= 2))
    {
      uint64_t v5 = *a1;
      return [v5 generateMipmapsForTexture:a2];
    }
  }
  return result;
}

unint64_t SCNMTLPixelFormatSupportsMipmapGeneration(uint64_t a1)
{
  return ((unint64_t)(a1 - 160) > 0x3A) | (0x20E008302AB00uLL >> (a1 + 96)) & 1;
}

void C3DImageReleaseBitmapCache(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 96))
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    uint64_t v10 = *(const void **)(a1 + 64);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 64) = 0;
      *(unsigned char *)(a1 + 80) |= 1u;
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    if (*(void *)(a1 + 72))
    {
      _C3DImageDeleteTextureRawDataIfNeeded(a1);
      *(unsigned char *)(a1 + 80) |= 2u;
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
  }
}

uint64_t C3DImageGetTextureRawDataMipmapLevelCount(uint64_t a1, unsigned char *a2)
{
  uint64_t result = C3DImageGetTextureRawData(a1);
  if (result)
  {
    uint64_t v5 = result;
    BOOL IsCubeMap = C3DImageIsCubeMap(a1);
    BOOL HasCubeMapComplexLayout = C3DImageHasCubeMapComplexLayout(a1);
    CFArrayRef v8 = *(const __CFArray **)(v5 + 40);
    if (IsCubeMap && !HasCubeMapComplexLayout)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v8, 0);
      CFTypeID v10 = CFGetTypeID(ValueAtIndex);
      if (v10 != CFArrayGetTypeID())
      {
        uint64_t result = CFArrayGetCount(*(CFArrayRef *)(v5 + 40)) / 6;
        if (!a2) {
          return result;
        }
LABEL_7:
        *a2 = 1;
        return result;
      }
      CFArrayRef v8 = (const __CFArray *)ValueAtIndex;
    }
    uint64_t result = CFArrayGetCount(v8);
    if (!a2) {
      return result;
    }
    goto LABEL_7;
  }
  return result;
}

uint64_t C3DImageGetName(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if (v1 == 5) {
    return *(void *)(a1 + 88);
  }
  if (v1 == 1) {
    return [*(id *)(a1 + 88) lastPathComponent];
  }
  return 0;
}

uint64_t C3DFXMetalProgramGetLanguageVersion(unsigned int *cf)
{
  if (!cf)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return cf[44];
}

uint64_t C3DTextureSamplerGetWrapModeT(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 20);
}

uint64_t C3DTextureSamplerGetWrapModeS(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 16);
}

uint64_t C3DTextureSamplerGetMinFilter(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 28);
}

uint64_t C3DTextureSamplerGetMagFilter(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 32);
}

float C3DTextureSamplerGetAnisotropy(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 64);
}

uint64_t C3DWrapModeToMTLAddressMode(int a1)
{
  if (a1 >= 5)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DWrapModeToMTLAddressMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_AddressMode[a1];
}

uint64_t C3DFilterModeToMTLFilter(int a1)
{
  if (a1 >= 3)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFilterModeToMTLFilter_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_FilterMode[a1];
}

uint64_t SCNMTLComputeCommandEncoder::endEncoding(SCNMTLComputeCommandEncoder *this)
{
  p_encoder = &this->_encoder;
  if (!this->_encoder)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLComputeCommandEncoder::endEncoding(v2, v3, v4);
    }
  }
  uint64_t result = [(MTLComputeCommandEncoder *)*p_encoder endEncoding];
  *p_encoder = 0;
  p_encoder[1] = 0;
  return result;
}

void *SCNMTLBlitCommandEncoder::beginEncoding(void *a1, void *a2, uint64_t a3)
{
  if (*a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    SCNMTLBlitCommandEncoder::beginEncoding(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    SCNMTLBlitCommandEncoder::beginEncoding(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  *a1 = 0;
  a1[1] = 0;
  uint64_t result = (void *)[a2 blitCommandEncoder];
  *a1 = result;
  a1[1] = a2;
  if (a3) {
    return (void *)[result setLabel:a3];
  }
  return result;
}

uint64_t C3DFilterModeToMTLMipFilter(int a1)
{
  if (a1 >= 3)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFilterModeToMTLFilter_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_MipFilterMode[a1];
}

void __appendDictionary(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

void __appendDictionary_0(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t __appendDictionary_1(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 setObject:a2 forKeyedSubscript:a1];
}

unint64_t __hashCodeFromDesc(int *a1)
{
  uint64x2_t v1 = (uint64x2_t)vdupq_n_s64(a1[5] | ((unint64_t)(*((unsigned __int16 *)a1 + 12) | (*((unsigned __int8 *)a1 + 26) << 16)) << 32));
  int8x16_t v2 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_20B5EFB50), (int8x16_t)xmmword_20B5EFB80), vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_20B5EFB60), (int8x16_t)xmmword_20B5EFB70));
  return *((unsigned __int8 *)a1 + 8) | (2 * *((unsigned __int8 *)a1 + 9)) | (4 * *((unsigned __int8 *)a1 + 10)) | (32 * *((unsigned __int8 *)a1 + 11)) | ((unint64_t)*((unsigned __int8 *)a1 + 12) << 6) | *a1 | ((((unint64_t)*(unsigned int *)((char *)a1 + 13) >> 5) & 0x7FFF8 | *(int *)((char *)a1 + 13) | ((unint64_t)*(_WORD *)((char *)a1 + 17) << 19) | (*(unsigned __int16 *)((char *)a1 + 17) << 14) & 0x3FC00000 | (*((unsigned __int8 *)a1 + 19) << 25) & 0x7FFFFFFE000000) << 9) | ((unint64_t)(vorr_s8(*(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL)).u32[0] | a1[5]) << 37);
}

uint64_t C3DEffectCommonProfileGetHashCode(uint64_t a1)
{
  if (!a1)
  {
    int8x16_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(int *)(a1 + 24) >= 7)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DEffectCommonProfileGetHashCode_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  int v18 = *(_DWORD *)(a1 + 24);
  __int16 v19 = *(unsigned __int8 *)(a1 + 192);
  if (C3DMaterialIsDoubleSided(*(void *)(a1 + 16))) {
    __int16 v20 = 32;
  }
  else {
    __int16 v20 = 0;
  }
  int8x16_t v21 = (int8x16_t)vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vdup_n_s16(32 * *(unsigned __int16 *)(a1 + 194)), (int8x8_t)0x400020001000080));
  *(int8x8_t *)v21.i8 = vorr_s8(*(int8x8_t *)v21.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  return v21.i16[0] | ((*(_WORD *)(a1 + 194) & 1) << 6) | v21.i16[2] | ((*(unsigned char *)(a1 + 180) & 0xFu) << 11) | (unsigned __int16)(16 * v19) | (unsigned __int16)(v20 | (*(unsigned __int8 *)(a1 + 193) << 15) | v18);
}

uint64_t C3DMaterialIsDoubleSided(uint64_t a1)
{
  if (!a1)
  {
    int8x16_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 100);
}

uint64_t C3DRendererElementStoreGetElement(uint64_t a1, unsigned int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DSpanAllocatorGetElementInSpanAtIndex(*(void *)(a1 + 16), a2, 0);
}

uint64_t C3DSpanAllocatorGetElementInSpanAtIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DAllocatorNew_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if ((unsigned __int16)a2 >= *(_DWORD *)(a1 + 24))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DSpanAllocatorGetElementInSpanAtIndex_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  unint64_t v22 = a2 >> 16;
  uint64_t v23 = *(void *)(a1 + 16);
  unsigned int v24 = (unsigned __int16)a2;
  if (*(_DWORD *)(v23 + 40 * (unsigned __int16)a2 + 12) != (unsigned __int16)a2
    || *(_DWORD *)(v23 + 40 * (unsigned __int16)a2 + 8) <= WORD1(a2))
  {
    uint64_t v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      C3DSpanAllocatorGetElementInSpanAtIndex_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
    }
  }
  return *(void *)(v23 + 40 * v24) + *(void *)(a1 + 40) * (a3 + (unsigned __int16)v22);
}

uint64_t C3DProgramHashCodeUseDynamicBatching(uint64_t a1)
{
  return HIBYTE(*(unsigned __int16 *)(a1 + 200)) & 1;
}

uint64_t C3DFXPassInstanceGetPass(uint64_t a1)
{
  if (a1) {
    return *(void *)a1;
  }
  int8x16_t v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
    C3DEngineContextRenderSubTechnique_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return 0;
}

void _processRendererElement(SCNMTLRenderContext *a1, __C3DRendererElement *a2, __C3DFXPassInstance *a3)
{
  if (!a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  Node = (float32x4_t *)C3DRendererElementGetNode((uint64_t)a2);
  unsigned __int8 v57 = a1;
  engineContext = a1->_engineContext;
  pass = a1->_processingContext.pass;
  if (C3DRendererElementIsHidden((uint64_t)a2))
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      _processRendererElement(v16, v17, v18, v19, v20, v21, v22, v23);
      if (Node) {
        goto LABEL_7;
      }
LABEL_17:
      if (C3DRendererElementIsRendererDelegate((uint64_t)a2)) {
        return;
      }
      goto LABEL_18;
    }
  }
  if (!Node) {
    goto LABEL_17;
  }
LABEL_7:
  if (C3DNodeGetOpacity((uint64_t)Node) <= 0.0 && (*((_WORD *)a2 + 36) & 7) != 2)
  {
    unsigned int v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      _processRendererElement(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  if (C3DRendererElementIsRendererDelegate((uint64_t)a2))
  {
    CFDictionaryRef RendererDelegate = C3DNodeGetRendererDelegate((uint64_t)Node);
    if (RendererDelegate)
    {
      uint64_t v33 = (uint64_t)RendererDelegate;
      WorldMatrix = C3DNodeGetWorldMatrix(Node);
      C3DEngineContextSetMatrix4x4((uint64_t)engineContext, 2, (uint64_t)WorldMatrix);
      C3DRendererDelegateFireWithNode(v33, (uint64_t)engineContext, (uint64_t)Node, (uint64_t)pass);
      renderEncoder = a1->_renderEncoder;
      unint64_t v36 = renderEncoder->var25[0];
      long long v59 = *(_OWORD *)renderEncoder->var24;
      bzero(v57->_renderEncoder, 0xD70uLL);
      LODWORD(renderEncoder->var14[0].var1) = 1;
      LOBYTE(renderEncoder->var14[1].var0) = 1;
      *(_OWORD *)renderEncoder->var24 = v59;
      renderEncoder->var25[0] = v36;
      *(_WORD *)&renderEncoder->var5 = 257;
      renderEncoder->var7 = 1;
      *(_OWORD *)&renderEncoder->var1 = 0u;
      *(_OWORD *)&renderEncoder->var3 = 0u;
      return;
    }
    long long v37 = scn_default_log();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      _processRendererElement(v37, v38, v39, v40, v41, v42, v43, v44);
    }
  }
LABEL_18:
  uint64_t Technique = *((void *)a2 + 5);
  if (!Technique && ((uint64_t v55 = *((void *)a2 + 4)) == 0 || (Technique = C3DMaterialGetTechnique(v55)) == 0)
    || a3 && *(void *)a3 && (*(unsigned char *)(*(void *)a3 + 186) & 0x10) != 0)
  {
    -[SCNMTLRenderContext drawRenderElement:withPass:]((uint64_t)a1, (uint64_t)a2, (uint64_t)pass);
  }
  else if (Technique != C3DFXTechniqueGetNullTechnique())
  {
    uint64_t RaterizerStates = C3DRendererElementGetRaterizerStates((uint64_t)a2);
    PassCFIndex Count = C3DFXTechniqueGetPassCount(Technique);
    if (PassCount >= 1)
    {
      uint64_t v47 = PassCount;
      for (uint64_t i = 0; i != v47; ++i)
      {
        uint64_t PassAtIndex = C3DFXTechniqueGetPassAtIndex(Technique, i);
        if ((C3DFXPassIsTopLevel(PassAtIndex) & 1) == 0)
        {
          int DrawInstruction = C3DFXPassGetDrawInstruction(PassAtIndex);
          v62[0] = PassAtIndex;
          v62[1] = Technique;
          v62[2] = (uint64_t)Node;
          v62[3] = (uint64_t)engineContext;
          v62[5] = 0;
          v62[6] = 0;
          uint64_t v51 = *(void *)(PassAtIndex + 280);
          v62[4] = (uint64_t)a3 + 80;
          v62[7] = v51;
          v62[8] = (uint64_t)a2;
          v62[9] = *((unsigned __int8 *)a3 + 25);
          uint64_t v63 = 0;
          LOWORD(v63) = *(_WORD *)((char *)a3 + 27);
          C3DFXPassWillExecute(v62);
          switch(DrawInstruction)
          {
            case 1:
            case 7:
              C3DFXPassExecute((uint64_t)v62);
              break;
            case 2:
              uint64_t RasterizerStates = C3DFXPassGetRasterizerStates(PassAtIndex);
              if (RasterizerStates) {
                uint64_t v53 = RasterizerStates;
              }
              else {
                uint64_t v53 = RaterizerStates;
              }
              if (v53) {
                -[SCNMTLRenderContext setRasterizerStates:]((uint64_t)a1, v53);
              }
              -[SCNMTLRenderContext drawRenderElement:withPass:]((uint64_t)a1, (uint64_t)a2, PassAtIndex);
              break;
            case 3:
            case 6:
            case 8:
              break;
            case 4:
              -[SCNMTLRenderContext drawFullScreenQuadForPass:]((uint64_t)a1, PassAtIndex);
              break;
            default:
              long long v54 = scn_default_log();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
                _processRendererElement(&buf, v61, v54);
              }
              break;
          }
          C3DFXPassDidExecute((uint64_t)v62);
        }
      }
    }
  }
}

uint64_t C3DRendererElementGetNode(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

BOOL C3DRendererElementIsRendererDelegate(uint64_t a1)
{
  return (*(_WORD *)(a1 + 72) & 7) == 1;
}

uint64_t C3DRendererElementIsHidden(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return C3DNodeIsHidden(result);
  }
  return result;
}

uint64_t C3DSceneGetDynamicBatchingSystem(uint64_t a1)
{
  if (!a1)
  {
    int8x16_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 136);
}

uint64_t C3DEngineContextGetRenderGraph(uint64_t a1)
{
  return *(void *)(a1 + 1728);
}

uint64_t C3DEngineContextGetMaxDrawingCommand(uint64_t a1)
{
  return *(unsigned int *)(a1 + 456);
}

void C3D::DrawNodesPass::compile(C3D::DrawNodesPass *this)
{
  v23[1] = *MEMORY[0x263EF8340];
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  LightingSysteCFIndex m = C3DSceneGetLightingSystem(Scene);
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(*((void *)this + 2));
  unsigned int Capacity = C3DRendererElementStoreGetCapacity(RendererElementStore);
  C3DProgramHashCodeStoreSetCapacity(ProgramHashCodeStore, Capacity);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  if (RenderContext) {
    -[SCNMTLRenderContext disableLinearRendering](RenderContext);
  }
  BOOL IsClusteredShadingEnabled = C3DEngineContextIsClusteredShadingEnabled(*((void *)this + 2));
  if (*((_DWORD *)this + 1236))
  {
    int v11 = IsClusteredShadingEnabled;
    unint64_t v12 = 0;
    do
    {
      C3DLightingSystemBeginQueries(LightingSystem, (uint64_t)this + 64 * v12 + 3408, *((void *)this + 2));
      uint64_t v22 = 0;
      memset(v21, 0, sizeof(v21));
      C3DLightingSystemGetLightingContext(LightingSystem, *((void *)this + 2), (uint64_t)v21);
      int v20 = 0;
      if (C3DLightingSystemGetInfiniteLightSet(LightingSystem, v23, &v20))
      {
        C3DLightingSystemCheckLightingSetTextureUsage(LightingSystem, (uint64_t)v23);
        unsigned __int8 LightingSetProgramHashCodes = C3DLightingSystemGetLightingSetProgramHashCodes(LightingSystem, (uint64_t)v23, (_OWORD *)((char *)v21 + 4));
        LOWORD(v21[0]) = (LightingSetProgramHashCodes << 7) | v21[0] & 0x807F;
      }
      uint64_t v14 = (char *)this + 16 * v12;
      uint64_t v15 = *((unsigned int *)v14 + 1310);
      if (v15)
      {
        uint64_t v16 = (unsigned int *)*((void *)v14 + 654);
        do
        {
          unsigned int v17 = *v16++;
          unint64_t v1 = v1 & 0xFFFFFFFF00000000 | v17;
          uint64_t Element = C3DRendererElementStoreGetElement(RendererElementStore, v1);
          __int16 v19 = *(_WORD *)(Element + 72);
          if ((v19 & 0x40) != 0) {
            *(_WORD *)(Element + 72) = (8 * LOWORD(v21[0])) & 0x380 | v19 & 0xFC7F;
          }
          C3D::DrawNodesPass::_computeProgramHashCodeForRendererElement((uint64_t)this, Element, ProgramHashCodeStore, (uint64_t)v21, v11);
          --v15;
        }
        while (v15);
      }
      if (*((unsigned char *)this + 296)) {
        C3DLightingSystemEndQueries(LightingSystem);
      }
      ++v12;
    }
    while (v12 < *((unsigned int *)this + 1236));
  }
}

void C3D::DrawNodesPass::_computeProgramHashCodeForRendererElement(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (*(void *)(a2 + 16) || *(void *)(a2 + 24))
  {
    uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(a1 + 16));
    int v11 = *(void **)(a2 + 8);
    unint64_t v12 = *(void **)(a1 + 240);
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
    ProgramHashCodeForRenderuint64_t Element = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(a3, (unsigned __int16 *)a2, v12, v13);
    if (ProgramHashCodeForRenderElement)
    {
      if (!*(unsigned char *)(a1 + 296)) {
        return;
      }
      if (a5)
      {
        long long v15 = *(_OWORD *)(a4 + 80);
        v56[4] = *(_OWORD *)(a4 + 64);
        v56[5] = v15;
        uint64_t v57 = *(void *)(a4 + 96);
        long long v16 = *(_OWORD *)(a4 + 16);
        v56[0] = *(_OWORD *)a4;
        v56[1] = v16;
        long long v17 = *(_OWORD *)(a4 + 48);
        v56[2] = *(_OWORD *)(a4 + 32);
        v56[3] = v17;
        if (C3DProgramHashCodeMatchLightHashCodesAndLightingContext(ProgramHashCodeForRenderElement, (unsigned __int16 *)v56))
        {
          return;
        }
      }
LABEL_10:
      uint64_t v19 = RenderContext;
      long long v54 = v11;
      uint64_t Mesh = C3DRendererElementGetMesh(a2);
      Meshuint64_t Element = C3DRendererElementGetMeshElement(a2);
      uint64_t Geometry = (__C3DGeometry *)C3DRendererElementGetGeometry(a2);
      uint64_t Material = C3DRendererElementGetMaterial(a2);
      uint64_t v21 = *(void *)(a1 + 256);
      if (!v21) {
        uint64_t v21 = Material;
      }
      uint64_t v55 = v21;
      uint64_t v22 = *(void *)(a2 + 8);
      if (v22)
      {
        if ((*(unsigned char *)(v22 + 221) & 0x10) != 0)
        {
          uint64_t v23 = *(void *)(a2 + 40);
          if (v23) {
            C3DFXTechniqueEnsureThatPassesShouldExecute(v23);
          }
        }
      }
      uint64_t v24 = *(unsigned __int16 *)(a1 + 298);
      uint64_t v25 = *(unsigned __int8 *)(a1 + 4948);
      unsigned int v26 = *(unsigned __int16 *)(a2 + 72);
      char v27 = *(unsigned char *)(a1 + 117);
      char v28 = *(unsigned char *)(a1 + 118);
      if (-[SCNMTLRenderContext reverseZ](v19)) {
        int v29 = -128;
      }
      else {
        int v29 = 0;
      }
      unsigned int v30 = (8 * (v27 & 3)) & 0x98 | (v26 >> 11) & 7 | v29 & 0xFFFFFF9F | (32 * (v28 & 3));
      if (!*(void *)(a1 + 256))
      {
        uint64_t v43 = (const void *)C3DProgramHashCodeCreate(v54, Geometry, Mesh, (uint64_t)MeshElement, (unsigned char *)a4, v55, (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v24);
LABEL_28:
        uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
        C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass(a3, (unsigned int *)a2, v43, v44);
        if (v43) {
          CFRelease(v43);
        }
        return;
      }
      if (!C3DRendererElementIsOpaque(a2)
        || (v27 & 3) != 0
        || v55
        && (uint64_t v31 = C3DRendererElementGetMaterial(a2), (C3DEntityHasShaderModifiers(v31, 0) & 1) != 0))
      {
        __int16 v32 = *(_WORD *)(a2 + 72);
        uint64_t v33 = v24;
LABEL_25:
        *(_WORD *)(a2 + 72) = v32 | 0x400;
        uint64_t v34 = C3DRendererElementGetGeometry(a2);
        uint64_t v35 = C3DRendererElementGetMesh(a2);
        unint64_t v36 = C3DRendererElementGetMeshElement(a2);
        uint64_t v37 = C3DRendererElementGetMaterial(a2);
        unint64_t v38 = (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v33;
        uint64_t v39 = v54;
        uint64_t v40 = (__C3DGeometry *)v34;
        uint64_t v41 = v35;
        uint64_t v42 = v36;
LABEL_26:
        uint64_t v43 = (const void *)C3DProgramHashCodeCreate(v39, v40, v41, (uint64_t)v42, 0, v37, v38);
        goto LABEL_28;
      }
      if (Geometry) {
        unsigned int v45 = C3DEntityHasShaderModifiers((uint64_t)Geometry, 0) ^ 1;
      }
      else {
        unsigned int v45 = 1;
      }
      uint64_t v33 = v24;
      if (v55
        && v45
        && (uint64_t CommonProfile = C3DMaterialGetCommonProfile(v55),
            (uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 15, 0)) != 0))
      {
        BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(EffectSlot);
        __int16 v32 = *(_WORD *)(a2 + 72);
        if (HasImageOrTexture) {
          goto LABEL_25;
        }
      }
      else
      {
        __int16 v32 = *(_WORD *)(a2 + 72);
        if (!v45) {
          goto LABEL_25;
        }
      }
      *(_WORD *)(a2 + 72) = v32 & 0xFBFF;
      uint64_t v49 = C3DRendererElementGetGeometry(a2);
      uint64_t v50 = C3DRendererElementGetMesh(a2);
      uint64_t v42 = C3DRendererElementGetMeshElement(a2);
      unint64_t v38 = (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v33;
      uint64_t v39 = v54;
      uint64_t v40 = (__C3DGeometry *)v49;
      uint64_t v41 = v50;
      uint64_t v37 = v55;
      goto LABEL_26;
    }
    uint64_t v18 = *(void **)(a1 + 240);
    if (!v18 || !C3DFXPassGetOverridingProgramHashCode(0, v18, (unsigned __int16 *)a2)) {
      goto LABEL_10;
    }
  }
}

unint64_t C3D::DrawNodesPass::programHashCodeStoreKey(C3D::DrawNodesPass *this)
{
  int8x16_t v2 = (const char *)(*(uint64_t (**)(C3D::DrawNodesPass *))(*(void *)this + 72))(this);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  unsigned __int16 v4 = *((_WORD *)this + 149);
  uint64_t v5 = *((unsigned __int8 *)this + 4948);
  char v6 = (8 * (*((unsigned char *)this + 117) & 3)) & 0x9F | (32 * (*((unsigned char *)this + 118) & 3));
  if (-[SCNMTLRenderContext reverseZ](RenderContext)) {
    char v7 = 0x80;
  }
  else {
    char v7 = 0;
  }
  unint64_t v8 = 0xC6A4A7935BD1E995
     * ((((unint64_t)((v6 | v7) & 0xF8) << 24) | (v5 << 16) | v4 & 0xFF00 | v4) ^ 0x1A929E4D6F47A654);
  unint64_t v9 = 0xC6A4A7935BD1E995 * (v8 ^ (v8 >> 47));
  unsigned int v10 = strlen(v2);
  unint64_t v11 = (0xC6A4A7935BD1E995 * v10) ^ (v9 >> 47) ^ v9;
  if (v10 >= 8)
  {
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = (unsigned __int8 *)&v2[8 * v12];
    uint64_t v14 = 8 * v12;
    do
    {
      uint64_t v15 = *(void *)v2;
      v2 += 8;
      unint64_t v11 = 0xC6A4A7935BD1E995
          * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v15) ^ ((0xC6A4A7935BD1E995 * v15) >> 47))) ^ v11);
      v14 -= 8;
    }
    while (v14);
    int8x16_t v2 = (const char *)v13;
  }
  switch(v10 & 7)
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 6) << 48;
LABEL_10:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 5) << 40;
LABEL_11:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 4) << 32;
LABEL_12:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 3) << 24;
LABEL_13:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 2) << 16;
LABEL_14:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 1) << 8;
LABEL_15:
      unint64_t v11 = 0xC6A4A7935BD1E995 * (v11 ^ *(unsigned __int8 *)v2);
      break;
    default:
      return (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
  }
  return (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
}

uint64_t C3DEngineContextGetRenderContext(uint64_t a1)
{
  if (!a1)
  {
    int8x16_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 1704);
}

const char *C3D::DrawNodesPass::programHashCodeStoreName(C3D::DrawNodesPass *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (const char **)*((void *)this + 30);
  if (v4) {
    return C3D::CachedFXPassName((void **)this + 669, v4, *(__C3DFXPass **)(*((void *)this + 3) + 16), a4);
  }
  else {
    return "DrawNodeDefault";
  }
}

void C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass(uint64_t a1, unsigned int *a2, const void *a3, uint64_t a4)
{
  uint64_t v7 = *a2;
  uint64_t v8 = (void *)(a1 + 16);
  unsigned int v9 = (*(_DWORD *)(a1 + 44) - 1) & a4;
  unsigned int v10 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 2 * v9);
  if (v10 < 2) {
    goto LABEL_5;
  }
  while ((v10 & 2) == 0 || *(void *)(*v8 + 8 * v9) != a4)
  {
    ++v9;
    BOOL v11 = v10 >= 4;
    v10 >>= 1;
    if (!v11) {
      goto LABEL_5;
    }
  }
  uint64_t v18 = *(void *)(a1 + 24);
  if (!v18 || (uint64_t v12 = *(_DWORD **)(v18 + 8 * v9)) == 0)
  {
LABEL_5:
    uint64_t v12 = (_DWORD *)C3DArrayCreate(8, *(_DWORD *)(a1 + 56));
    CFTypeRef cf = v12;
    C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::insert((uint64_t)v8, a4, &cf);
    if (cf) {
      CFRelease(cf);
    }
    C3DArraySetCount(v12, *(_DWORD *)(a1 + 56));
    ValuesPtr = (void *)C3DArrayGetValuesPtr((uint64_t)v12);
    bzero(ValuesPtr, 8 * *(unsigned int *)(a1 + 56));
  }
  uint64_t v14 = (int *)(a1 + 56);
  if (v7 >= *(_DWORD *)(a1 + 56))
  {
    long long v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass_cold_2(v14, v7, v17);
    }
  }
  else
  {
    ValuePtrAtIndex = (uint64_t *)C3DArrayGetValuePtrAtIndex((uint64_t)v12, v7);
    if ((const void *)*ValuePtrAtIndex != a3)
    {
      C3DProgramHashCodeRelease(*ValuePtrAtIndex);
      if (a3) {
        long long v16 = (void *)CFRetain(a3);
      }
      else {
        long long v16 = 0;
      }
      uint64_t *ValuePtrAtIndex = (uint64_t)v16;
      if (C3DIndexStoreAddIndexForKey(*(void *)(a1 + 48), v16) >= 0xFFFFFFFFLL)
      {
        uint64_t v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass_cold_1(v19);
        }
      }
    }
  }
}

void __InitializeRendererElementWithNode(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, char a5, __C3DGeometry *a6, const void *a7, const void *a8, CFIndex a9, char a10)
{
  __int16 v15 = a3;
  CFIndex v17 = a9;
  char v18 = a10;
  uint64_t ElementInSpanAtIndex = C3DSpanAllocatorGetElementInSpanAtIndex(*(void *)(a1 + 16), a2, a3);
  *(_OWORD *)uint64_t ElementInSpanAtIndex = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 16) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 32) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x380], 8) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 64) = 0u;
  _C3DRendererElementInitialize(ElementInSpanAtIndex);
  *(_DWORD *)uint64_t ElementInSpanAtIndex = ((unsigned __int16)a2 << 12) + (unsigned __int16)(v15 + HIWORD(a2));
  __int16 v20 = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xC7F8 | ((v18 & 7) << 11);
  *(void *)(ElementInSpanAtIndex + _Block_object_dispose(&STACK[0x380], 8) = a4;
  *(_WORD *)(ElementInSpanAtIndex + 72) = v20 & 0xFFF8 | a5 & 7;
  uint64_t v21 = *(__C3DGeometry **)(ElementInSpanAtIndex + 16);
  if (v21 != a6)
  {
    if (v21)
    {
      CFRelease(v21);
      *(void *)(ElementInSpanAtIndex + 16) = 0;
    }
    if (a6) {
      CFTypeRef v22 = CFRetain(a6);
    }
    else {
      CFTypeRef v22 = 0;
    }
    *(void *)(ElementInSpanAtIndex + 16) = v22;
  }
  uint64_t v23 = *(const void **)(ElementInSpanAtIndex + 24);
  if (v23 != a7)
  {
    if (v23)
    {
      CFRelease(v23);
      *(void *)(ElementInSpanAtIndex + 24) = 0;
    }
    if (a7) {
      CFTypeRef v24 = CFRetain(a7);
    }
    else {
      CFTypeRef v24 = 0;
    }
    *(void *)(ElementInSpanAtIndex + 24) = v24;
  }
  uint64_t v25 = *(const void **)(ElementInSpanAtIndex + 32);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(ElementInSpanAtIndex + 32) = 0;
  }
  unsigned int v26 = *(const void **)(ElementInSpanAtIndex + 40);
  if (v26 != a8)
  {
    if (v26)
    {
      CFRelease(v26);
      *(void *)(ElementInSpanAtIndex + 40) = 0;
    }
    if (a8) {
      CFTypeRef v27 = CFRetain(a8);
    }
    else {
      CFTypeRef v27 = 0;
    }
    *(void *)(ElementInSpanAtIndex + 40) = v27;
  }
  if (!a7)
  {
    if (!a6) {
      goto LABEL_69;
    }
    if (C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a6))
    {
      CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberCFIndexType, &a9);
      CFNumberRef v30 = *(CFNumberRef *)(ElementInSpanAtIndex + 48);
      if (v30 != v29)
      {
        if (v30)
        {
          CFRelease(v30);
          *(void *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x380], 8) = 0;
        }
        if (v29) {
          CFTypeRef v31 = CFRetain(v29);
        }
        else {
          CFTypeRef v31 = 0;
        }
        *(void *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x380], 8) = v31;
      }
      CFRelease(v29);
    }
LABEL_47:
    MaterialsCFIndex Count = C3DGeometryGetMaterialsCount((uint64_t)a6);
    if (!MaterialsCount)
    {
      Default = (const void *)C3DMaterialCreateDefault(v36);
      uint64_t v44 = *(const void **)(ElementInSpanAtIndex + 32);
      if (v44 != Default)
      {
        if (v44)
        {
          CFRelease(v44);
          *(void *)(ElementInSpanAtIndex + 32) = 0;
        }
        if (Default) {
          CFTypeRef v45 = CFRetain(Default);
        }
        else {
          CFTypeRef v45 = 0;
        }
        *(void *)(ElementInSpanAtIndex + 32) = v45;
      }
      if (Default) {
        CFRelease(Default);
      }
      goto LABEL_69;
    }
    CFArrayRef v37 = MaterialsCount;
    uint64_t v38 = a9;
    uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)a6);
    if (OverrideMaterial)
    {
      CFArrayRef v40 = (const __CFArray *)OverrideMaterial;
      CFArrayRef v41 = *(const __CFArray **)(ElementInSpanAtIndex + 32);
      if (v41 == v40) {
        goto LABEL_69;
      }
      if (v41)
      {
        CFRelease(v41);
        *(void *)(ElementInSpanAtIndex + 32) = 0;
      }
      CFArrayRef v42 = v40;
    }
    else
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a6, v38 % (uint64_t)v37);
      CFArrayRef v47 = *(const __CFArray **)(ElementInSpanAtIndex + 32);
      if (v47 == MaterialAtIndex) {
        goto LABEL_69;
      }
      if (v47)
      {
        CFRelease(v47);
        *(void *)(ElementInSpanAtIndex + 32) = 0;
      }
      if (!MaterialAtIndex)
      {
        CFTypeRef v48 = 0;
        goto LABEL_64;
      }
      CFArrayRef v42 = MaterialAtIndex;
    }
    CFTypeRef v48 = CFRetain(v42);
LABEL_64:
    *(void *)(ElementInSpanAtIndex + 32) = v48;
    goto LABEL_69;
  }
  if (a6) {
    BOOL EffectiveDataKindForRendering = C3DGeometryGetEffectiveDataKindForRendering(a6);
  }
  else {
    BOOL EffectiveDataKindForRendering = 1;
  }
  uint64_t ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)a7, v17, EffectiveDataKindForRendering);
  uint64_t v33 = *(const void **)(ElementInSpanAtIndex + 48);
  if (v33 != ElementAtIndex)
  {
    if (v33)
    {
      CFRelease(v33);
      *(void *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x380], 8) = 0;
    }
    if (ElementAtIndex) {
      CFTypeRef v34 = CFRetain(ElementAtIndex);
    }
    else {
      CFTypeRef v34 = 0;
    }
    *(void *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x380], 8) = v34;
  }
  if (a6) {
    goto LABEL_47;
  }
LABEL_69:
  C3DRendererElementStoreSyncRendererElement(a1, ElementInSpanAtIndex, -1);
}

void C3DRendererElementStoreSyncRendererElement(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    char v3 = a3;
    if ((*(_WORD *)(a2 + 72) & 0x20) != 0)
    {
      if ((a3 & 4) != 0) {
        C3DIndexStoreRemoveIndexForKey(*(void *)(a1 + 24), (void *)*(int *)(a2 + 64));
      }
      if (v3) {
        C3DIndexStoreRemoveIndexForKey(*(void *)(a1 + 32), *(void **)(a2 + 32));
      }
    }
    _C3DRendererElementSync(a2, v3);
    if ((v3 & 4) != 0) {
      C3DIndexStoreAddIndexForKey(*(void *)(a1 + 24), (void *)*(int *)(a2 + 64));
    }
    if (v3) {
      C3DIndexStoreAddIndexForKey(*(void *)(a1 + 32), *(void **)(a2 + 32));
    }
    *(_WORD *)(a2 + 72) |= 0x20u;
  }
}

uint64_t C3DIndexStoreAddIndexForKey(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
  {
    uint64_t v13 = (char *)Value;
    uint64_t result = *Value;
  }
  else
  {
    uint64_t v13 = C3DAllocatorNew(*(void *)(a1 + 48));
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), key, v13);
    *((void *)v13 + 1) = 0;
    uint64_t result = _getNextFreeIndex(a1);
    *(void *)uint64_t v13 = result;
    ++*(void *)(a1 + 72);
  }
  ++*((void *)v13 + 1);
  return result;
}

uint64_t _getNextFreeIndex(uint64_t a1)
{
  uint64_t FirstIndex = C3DIndexSetGetFirstIndex(*(void *)(a1 + 24));
  if (FirstIndex == -1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      _getNextFreeIndex_cold_1(v4);
    }
  }
  else
  {
    C3DIndexSetRemoveIndex(*(void *)(a1 + 24), FirstIndex);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3 <= FirstIndex) {
      uint64_t v3 = FirstIndex;
    }
    *(void *)(a1 + 32) = v3;
    *(unsigned char *)(a1 + 56) = 0;
  }
  return FirstIndex;
}

uint64_t _C3DRendererElementInitialize(uint64_t result)
{
  *(_WORD *)(result + 72) &= ~0x400u;
  return result;
}

uint64_t C3DGeometryIsAlwaysRendered(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2) {
    uint64_t v3 = C3DMaterialGetTechnique(v2) != 0;
  }
  else {
    uint64_t v3 = 0;
  }
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount >= 1 && (v3 & 1) == 0)
  {
    CFArrayRef v5 = MaterialsCount;
    uint64_t v6 = 1;
    do
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, v6 - 1);
      uint64_t Technique = C3DMaterialGetTechnique((uint64_t)MaterialAtIndex);
      uint64_t v3 = Technique != 0;
      uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
      if (CommonProfile)
      {
        uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 15, 0);
        if (EffectSlot)
        {
          uint64_t v11 = EffectSlot;
          BOOL v12 = C3DEffectSlotHasImageOrTexture(EffectSlot) && C3DEffectSlotGetIntensity(v11) != 0.0;
          if (Technique) {
            uint64_t v3 = 1;
          }
          else {
            uint64_t v3 = v12;
          }
        }
      }
      if (v6 >= (uint64_t)v5) {
        break;
      }
      ++v6;
    }
    while ((v3 & 1) == 0);
  }
  return v3;
}

CFArrayRef C3DGeometryGetMaterialAtIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFArrayRef result = C3DGeometryGetMaterialsCount(a1);
  if (result) {
    return (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a2 % (uint64_t)result);
  }
  return result;
}

CFArrayRef C3DGeometryGetMaterialsCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 80);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

void C3DEnginePipelineGetRenderComponentsForRenderPass(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a3);
  if (!RenderContext)
  {
    if (a2 && C3DFXPassIsOverridingPrograms((uint64_t)a2)) {
      uint64_t OverridingProgramHashCode = (uint64_t)C3DFXPassGetOverridingProgramHashCode(a3, a2, (unsigned __int16 *)a1);
    }
    else {
      uint64_t OverridingProgramHashCode = 0;
    }
    uint64_t MaterialForRenderPass = C3DRendererElementGetMaterialForRenderPass(a1, (uint64_t)a2);
    uint64_t v18 = MaterialForRenderPass;
    if (!MaterialForRenderPass || C3DMaterialGetTechnique(MaterialForRenderPass))
    {
      if (!a2 || (PrograCFIndex m = C3DFXPassGetProgram((uint64_t)a2)) == 0)
      {
        uint64_t Technique = *(void *)(a1 + 40);
        if (v18 && !Technique) {
          uint64_t Technique = C3DMaterialGetTechnique(v18);
        }
        if (Technique) {
          goto LABEL_38;
        }
        uint64_t v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          C3DEnginePipelineGetRenderComponentsForRenderPass_cold_1(v23);
        }
        return;
      }
LABEL_39:
      uint64_t OverridingProgramHashCode = 0;
      if (!a4)
      {
LABEL_41:
        if (a6) {
          *a6 = Program;
        }
        if (a5) {
          *a5 = OverridingProgramHashCode;
        }
        return;
      }
LABEL_40:
      *a4 = v18;
      goto LABEL_41;
    }
    if (!OverridingProgramHashCode)
    {
      uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a3);
      unsigned int PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(a3);
      uint64_t OverridingProgramHashCode = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)a1, a2, PreferredRenderMode);
    }
    uint64_t CommonProfile = C3DMaterialGetCommonProfile(v18);
    if (!CommonProfile)
    {
      CFTypeRef v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        goto LABEL_48;
      }
    }
    goto LABEL_49;
  }
  uint64_t v15 = RenderContext;
  uint64_t v16 = C3DEngineContextGetProgramHashCodeStore(a3);
  if (a2)
  {
    uint64_t v17 = C3DRendererElementGetMaterialForRenderPass(a1, (uint64_t)a2);
  }
  else
  {
    if (C3DRendererElementIsRendererDelegate(a1))
    {
      uint64_t v18 = 0;
      goto LABEL_30;
    }
    if ((*(_WORD *)(a1 + 72) & 0x400) != 0 || !-[SCNMTLRenderContext getCurrentPassMaterial](v15))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      goto LABEL_30;
    }
    uint64_t v17 = -[SCNMTLRenderContext getCurrentPassMaterial](v15);
  }
  uint64_t v18 = v17;
LABEL_30:
  uint64_t v35 = -[SCNMTLRenderContext getCurrentPassHash](v15);
  ProgramHashCodeForRenderuint64_t Element = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(v16, (unsigned __int16 *)a1, a2, v35);
  if (v18)
  {
    uint64_t OverridingProgramHashCode = ProgramHashCodeForRenderElement;
    if (!C3DMaterialGetTechnique(v18))
    {
      uint64_t CommonProfile = C3DMaterialGetCommonProfile(v18);
      if (!CommonProfile)
      {
        CFTypeRef v27 = scn_default_log();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
LABEL_48:
        }
          C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v27, v28, v29, v30, v31, v32, v33, v34);
      }
LABEL_49:
      PrograCFIndex m = C3DEngineContextEvaluateProgramWithHashCode(a3, OverridingProgramHashCode, CommonProfile, a7);
      if (!a4) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
  }
  if (a2)
  {
    PrograCFIndex m = C3DFXPassGetProgram((uint64_t)a2);
    if (Program) {
      goto LABEL_39;
    }
  }
  uint64_t Technique = *(void *)(a1 + 40);
  if (v18 && !Technique) {
    uint64_t Technique = C3DMaterialGetTechnique(v18);
  }
  if (Technique)
  {
LABEL_38:
    PrograCFIndex m = C3DFXTechniqueGetSingleProgram(Technique);
    goto LABEL_39;
  }
  CFArrayRef v37 = scn_default_log();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueAppendPass_cold_3(v37, v38, v39, v40, v41, v42, v43, v44);
  }
}

uint64_t C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(uint64_t a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  if (!a3
    || !C3DFXPassIsOverridingPrograms((uint64_t)a3)
    || (uint64_t result = (uint64_t)C3DFXPassGetOverridingProgramHashCode(0, a3, a2)) == 0)
  {
    uint64_t result = C3DRendererElementGetMaterialForRenderPass((uint64_t)a2, (uint64_t)a3);
    if (result)
    {
      if (C3DMaterialGetTechnique(result)) {
        return 0;
      }
      unsigned int v9 = (*(_DWORD *)(a1 + 44) - 1) & a4;
      unsigned int v10 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 2 * v9);
      if (v10 < 2) {
        return 0;
      }
      uint64_t v11 = *(unsigned int *)a2;
      while ((v10 & 2) == 0 || *(void *)(*(void *)(a1 + 16) + 8 * v9) != a4)
      {
        ++v9;
        BOOL v12 = v10 >= 4;
        v10 >>= 1;
        if (!v12) {
          return 0;
        }
      }
      uint64_t v13 = *(void *)(a1 + 24);
      if (!v13) {
        return 0;
      }
      uint64_t v14 = (uint64_t *)(v13 + 8 * v9);
      uint64_t v15 = C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *((uint64_t)v14);
      if (C3DArrayGetCount(v15) <= v11) {
        return 0;
      }
      else {
        return *(void *)C3DArrayGetValuePtrAtIndex(*v14, v11);
      }
    }
  }
  return result;
}

uint64_t C3DMaterialGetTechnique(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 72);
}

uint64_t C3DArrayGetValuePtrAtIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetCount_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DArrayGetCount(a1) <= a2)
  {
    BOOL v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetValuePtrAtIndex_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return *(void *)(a1 + 16) + *(unsigned int *)(a1 + 32) * a2;
}

uint64_t C3DArrayGetCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t C3DRendererElementGetMaterialForRenderPass(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if ((*(_WORD *)(a1 + 72) & 7) == 1) {
    return 0;
  }
  if (!a2) {
    return *(void *)(a1 + 32);
  }
  uint64_t Material = C3DFXPassGetMaterial(a2);
  __int16 v14 = *(_WORD *)(a1 + 72);
  if ((v14 & 0x400) != 0) {
    return *(void *)(a1 + 32);
  }
  uint64_t v12 = Material;
  if (!Material || (v14 & 8) == 0 && C3DFXPassGetDrawOnlyShadowCaster(a2)) {
    return *(void *)(a1 + 32);
  }
  return v12;
}

uint64_t C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *(uint64_t a1)
{
  if (!*(void *)a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *(v2);
    }
  }
  return *(void *)a1;
}

uint64_t C3DEngineContextGetProgramHashCodeStore(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 176);
}

uint64_t C3DEngineContextEvaluateProgramWithHashCode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  CommonProfileProgramGenerator = C3DEngineContextGetCommonProfileProgramGenerator(a1);

  return (uint64_t)[(SCNCommonProfileProgramGenerator *)CommonProfileProgramGenerator programWithHashCode:a2 engineContext:a1 trackedResource:a3 introspectionDataPtr:a4];
}

SCNCommonProfileProgramGenerator *C3DEngineContextGetCommonProfileProgramGenerator(uint64_t a1)
{
  uint64_t result = *(SCNCommonProfileProgramGenerator **)(a1 + 216);
  if (!result)
  {
    uint64_t result = +[SCNCommonProfileProgramGenerator generatorWithProfile:C3DEngineContextGetRendererContextProfile(a1) allowingHotReload:0];
    *(void *)(a1 + 216) = result;
  }
  return result;
}

const void *C3DRendererElementGetMeshElement(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = *(const void **)(a1 + 48);
  if (result)
  {
    CFTypeID v11 = CFGetTypeID(result);
    if (v11 == C3DMeshElementGetTypeID()) {
      return *(const void **)(a1 + 48);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t C3DMeshElementGetTypeID()
{
  if (C3DMeshElementGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshElementGetTypeID_onceToken, &__block_literal_global_7);
  }
  return C3DMeshElementGetTypeID_typeID;
}

uint64_t C3DRendererElementGetMesh(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

uint64_t C3DProgramHashCodeHasConstantAlpha(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 1) & 1;
}

uint64_t C3DProgramHashCodeIsOpaque(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 2) & 1;
}

uint64_t C3DRendererElementGetRaterizerStates(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return C3DMeshSourceGetMTLVertexFormat(result);
  }
  return result;
}

uint64_t C3DProgramHashCodeNeedTangents(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 4) & 1;
}

uint64_t C3DProgramHashCodeGetHashCode(uint64_t a1)
{
  return *(void *)(a1 + 280);
}

void C3DIndexStoreRemoveIndexForKey(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
  {
    unint64_t v13 = (unint64_t)Value;
    uint64_t v14 = Value[1] - 1;
    Value[1] = v14;
    if (!v14)
    {
      uint64_t v15 = *Value;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), key);
      C3DAllocatorDelete(*(void *)(a1 + 48), v13);
      *(unsigned char *)(a1 + 56) = 0;
      C3DIndexSetAddIndex(*(void *)(a1 + 24), v15);
      if (*(void *)(a1 + 32) == v15)
      {
        uint64_t LastRange = C3DIndexSetGetLastRange(*(void *)(a1 + 24));
        if (LastRange <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = LastRange;
        }
        *(void *)(a1 + 32) = v17 - 1;
      }
      ++*(void *)(a1 + 72);
    }
  }
}

void _insertRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v8 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v8 >= a4)
  {
    _ensureRangeCapacity(a1, v8 + 1);
    uint64_t v10 = (void *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v10 = (void *)(*v10 + 56);
    }
    if (v8 > a4)
    {
      uint64_t v11 = &v10[2 * v8];
      do
      {
        --v8;
        *uint64_t v11 = *(v11 - 1);
        --v11;
      }
      while (v8 > a4);
    }
    uint64_t v12 = &v10[2 * a4];
    *uint64_t v12 = a2;
    v12[1] = a3;
    char v13 = *(unsigned char *)(a1 + 16);
    if ((v13 & 2) == 0)
    {
      *(void *)(*(void *)(a1 + 24) + 4_Block_object_dispose(&STACK[0x380], 8) = 0;
      ++*(void *)(*(void *)(a1 + 24) + 8);
      *(void *)(*(void *)(a1 + 24) + 16) += a3;
      char v13 = *(unsigned char *)(a1 + 16);
    }
    *(unsigned char *)(a1 + 16) = v13 & 0xFE;
  }
  else
  {
    uint64_t v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      _insertRange_cold_1();
    }
  }
}

__n128 _ensureRangeCapacity(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a1 + 16);
  if ((v3 & 2) != 0) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = **(void **)(a1 + 24);
  }
  if (v4 < a2)
  {
    if (a2 == 1)
    {
      *(unsigned char *)(a1 + 16) = v3 | 2;
    }
    else
    {
      uint64_t v5 = 2 * v4;
      if (v5 <= a2) {
        uint64_t v5 = a2;
      }
      if (a2 >= 4) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = 4;
      }
      if ((*(unsigned char *)(a1 + 16) & 2) != 0)
      {
        BOOL v8 = (v3 & 1) == 0;
        if (*(unsigned char *)(a1 + 16)) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = *(void *)(a1 + 32);
        }
        uint64_t v10 = (void *)(a1 + 24);
        __n128 v12 = *(__n128 *)(a1 + 24);
        *(unsigned char *)(a1 + 16) = v3 & 0xFD;
        uint64_t v11 = malloc_type_calloc(16 * v6 + 56, 1uLL, 0xCAE6BB9uLL);
        *(void *)(a1 + 24) = v11;
        v11[6] = 0;
        **(void **)(a1 + 24) = v6;
        *(void *)(*(void *)(a1 + 24) + _Block_object_dispose(&STACK[0x380], 8) = v8;
        *(void *)(*(void *)(a1 + 24) + 16) = v9;
        if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
          uint64_t v10 = (void *)(*v10 + 56);
        }
        __n128 result = v12;
        *(__n128 *)uint64_t v10 = v12;
      }
      else
      {
        *(void *)(a1 + 24) = malloc_type_realloc(*(void **)(a1 + 24), 16 * v6 + 56, 0xA6EDD4FCuLL);
      }
    }
  }
  return result;
}

BOOL C3DProgramHashCodeHasShaderModifiers(uint64_t a1)
{
  return *(void *)(a1 + 16) || *(void *)(a1 + 24) != 0;
}

float C3DEffectCommonProfileGetConstantAlpha(float *a1)
{
  float FloatProperty = C3DEffectCommonProfileGetFloatProperty(a1, 18);
  char v3 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 5);
  uint64_t Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 5);
  if ((v3 & 1) == 0) {
    float FloatProperty = FloatProperty * Color[3];
  }
  char v5 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 2);
  uint64_t v6 = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 2);
  if ((v5 & 1) == 0) {
    return FloatProperty * v6[3];
  }
  return FloatProperty;
}

uint64_t C3DRendererElementStoreGetCapacity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DSpanAllocatorGetCapacity(*(void *)(a1 + 16));
}

uint64_t C3DSpanAllocatorGetCapacity(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 48));
}

void C3DProgramHashCodeStoreSetCapacity(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 56) < a2)
  {
    int v4 = *(_DWORD *)(a1 + 44);
    if (v4 != -15)
    {
      unint64_t v5 = 0;
      do
      {
        if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v5))
        {
          uint64_t v6 = *(void *)(a1 + 24);
          C3DArraySetCount(*(_DWORD **)(v6 + 8 * v5), a2);
          uint64_t ValuesPtr = C3DArrayGetValuesPtr(*(void *)(v6 + 8 * v5));
          bzero((void *)(ValuesPtr + 8 * *(unsigned int *)(a1 + 56)), 8 * (a2 - *(_DWORD *)(a1 + 56)));
          int v4 = *(_DWORD *)(a1 + 44);
        }
        ++v5;
      }
      while (v5 < (v4 + 15));
    }
    *(_DWORD *)(a1 + 56) = a2;
  }
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::insert(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 16);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      uint64_t v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      __int16 v17 = *(_WORD *)(v8 + 2 * v15) | 1;
      *(_WORD *)(v8 + 2 * v15) = v17;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v33 = v15;
        uint64_t v28 = *(void *)a1;
        uint64_t v29 = *(void *)(a1 + 8);
        LOBYTE(v22) = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v18 = v15 - 14;
          }
          else {
            unsigned int v18 = 0;
          }
          unsigned int v19 = v18 - 1;
          if (v18 <= v15) {
            unsigned int v20 = v15;
          }
          else {
            unsigned int v20 = v18;
          }
          char v21 = 1;
          while (1)
          {
            uint64_t v22 = v19 + 1;
            if (v18 <= v22) {
              break;
            }
LABEL_27:
            ++v21;
            unsigned int v19 = v22;
            if (v22 == v20) {
              goto LABEL_32;
            }
          }
          int v23 = 1 << (v19 - v18 + 2);
          char v24 = v21;
          unsigned int v25 = v18;
          while (1)
          {
            uint64_t v26 = v25;
            int v27 = *(unsigned __int16 *)(v8 + 2 * v25);
            if ((v23 & v27) != 0) {
              break;
            }
            unsigned int v25 = v26 + 1;
            int v23 = (unsigned __int16)v23 >> 1;
            --v24;
            if ((int)v26 + 1 > v22) {
              goto LABEL_27;
            }
          }
          if (v22 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v28 = *(void *)a1;
          uint64_t v29 = *(void *)(a1 + 8);
          *(void *)(*(void *)a1 + 8 * v15) = *(void *)(*(void *)a1 + 8 * v22);
          *(void *)(v29 + 8 * v15) = *(void *)(v29 + 8 * v22);
          *(void *)(v29 + 8 * v22) = 0;
          *(_WORD *)(v8 + 2 * v26) = (v27 | (1 << (v15 - v26 + 1))) ^ (1 << v24);
          unsigned int v15 = v22;
          if (v22 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        __int16 v17 = *(_WORD *)(v8 + 2 * v22) | 1;
        uint64_t v33 = v22;
      }
      *(void *)(v29 + 8 * v33) = *a3;
      *a3 = 0;
      *(void *)(v28 + 8 * v33) = a2;
      *(_WORD *)(v8 + 2 * v33) = v17;
      uint64_t result = 1;
      *(_WORD *)(v8 + 2 * v7) |= 1 << (v22 - v7 + 1);
      ++*(_DWORD *)(a1 + 24);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)a1 + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t v30 = *(void *)(a1 + 8);
  uint64_t v31 = *a3;
  *a3 = 0;
  uint64_t result = *(void *)(v30 + 8 * v10);
  *(void *)(v30 + 8 * v10) = v31;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

void C3DSortSystemSyncKeys(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  PointOfView = C3DEngineContextGetPointOfView(a2);
  uint64_t Scene = C3DEngineContextGetScene(a2);
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a2);
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  if (PointOfView)
  {
    uint64_t v13 = RendererElementStore;
    v69.i32[2] = 0;
    v69.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfView);
    __n128 v15 = *(__n128 *)WorldMatrix;
    float32x4_t v16 = WorldMatrix[1];
    float32x4_t v17 = WorldMatrix[3];
    float32x4_t v72 = WorldMatrix[2];
    float32x4_t v73 = v17;
    __n128 v70 = v15;
    float32x4_t v71 = v16;
    *(double *)v18.i64 = C3DVector3Rotate((float32x2_t *)&v70, (float32x4_t)xmmword_20B5CB520);
    float32x4_t v66 = v18;
    C3DMatrix4x4GetTranslation((__n128 *)WorldMatrix, (__n128 *)&v69);
    if (a4 >= 1)
    {
      float32x4_t v19 = v66;
      float32x4_t v20 = vmulq_f32(v66, v69);
      v19.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
      float32x4_t v67 = v19;
      uint64_t v65 = v13;
      while (1)
      {
        unsigned int v21 = *a3++;
        unint64_t v5 = v5 & 0xFFFFFFFF00000000 | v21;
        uint64_t Element = (unsigned int *)C3DRendererElementStoreGetElement(v13, v5);
        ValuePtrAtIndex = (void *)C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 16), *Element);
        char IsOpaque = C3DRendererElementIsOpaque((uint64_t)Element);
        char v25 = IsOpaque;
        if (*ValuePtrAtIndex == -1) {
          break;
        }
        if ((IsOpaque & 1) == 0)
        {
          *ValuePtrAtIndex &= 0xFFFFFFFF00000000;
          goto LABEL_27;
        }
LABEL_40:
        if (!--a4) {
          return;
        }
      }
      uint64_t PriorityIndex = C3DRendererElementStoreGetPriorityIndex(v13, (uint64_t)Element);
      int v27 = C3DRendererElementIsOpaque((uint64_t)Element);
      if (v27 && C3DRendererElementGetMaterial((uint64_t)Element))
      {
        ProgramHashCodeForRenderuint64_t Element = (void *)C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)Element, 0, a5);
        ProgramIndexForRenderuint64_t Element = C3DProgramHashCodeStoreGetProgramIndexForRenderElement(ProgramHashCodeStore, ProgramHashCodeForRenderElement);
        uint64_t v30 = v13;
        uint64_t v31 = ProgramIndexForRenderElement;
        uint64_t MaterialIndex = C3DRendererElementStoreGetMaterialIndex(v30, (uint64_t)Element);
      }
      else
      {
        uint64_t v31 = 0;
        uint64_t MaterialIndex = 0;
      }
      uint64_t v33 = *((void *)Element + 1);
      if (v33) {
        uint64_t v34 = C3DNodeGetLayerIndex(v33) << 61;
      }
      else {
        uint64_t v34 = 0;
      }
      unsigned int v35 = *(unsigned __int16 *)(a1 + 24);
      int v36 = (v35 >> 5) & 0x1F;
      int v37 = v35 & 0x1F;
      int v38 = (60 - (v36 + v37)) & ~((60 - (v36 + v37)) >> 31);
      char v39 = v37;
      if (v27) {
        int v40 = v36;
      }
      else {
        int v40 = 0;
      }
      if (v27) {
        int v41 = v38;
      }
      else {
        int v41 = 0;
      }
      char v42 = 60 - v39;
      unint64_t v43 = (PriorityIndex << (61 - v39)) | v34 | ((unint64_t)(v27 ^ 1u) << (60 - v39));
      char v44 = 60 - v39 - v41;
      if (v41)
      {
        v43 |= (v31 & ~(-1 << v41)) << (v42 - v41);
        char v45 = v44;
      }
      else
      {
        char v45 = v42;
      }
      uint64_t v46 = MaterialIndex << (v45 - v40);
      if (v40) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = 0;
      }
      void *ValuePtrAtIndex = v47 | v43;
      uint64_t v13 = v65;
      if (v25) {
        goto LABEL_40;
      }
LABEL_27:
      Node = (float32x4_t *)C3DRendererElementGetNode((uint64_t)Element);
      uint64_t Mesh = C3DRendererElementGetMesh((uint64_t)Element);
      if (Mesh)
      {
        uint64_t v50 = Mesh;
        Meshuint64_t Element = (float32x4_t *)C3DRendererElementGetMeshElement((uint64_t)Element);
        if (!MeshElement)
        {
          uint64_t v60 = 3212836864;
LABEL_39:
          *ValuePtrAtIndex |= v60;
          goto LABEL_40;
        }
        long long v52 = MeshElement;
        _C3DUpdateMeshElementsBBoxIfNeeded(v50);
        *(double *)v53.i64 = C3DVector3MidVector(v52[11], v52[12]);
        float32x4_t v54 = v53;
        if (!Node) {
          goto LABEL_37;
        }
        float32x4_t v64 = v53;
        uint64_t v55 = C3DNodeGetWorldMatrix(Node);
        __n128 v56 = *(__n128 *)v55;
        float32x4_t v57 = v55[1];
        float32x4_t v58 = v55[3];
        float32x4_t v72 = v55[2];
        float32x4_t v73 = v58;
        __n128 v70 = v56;
        float32x4_t v71 = v57;
        WorldBoundingBox.n128_f64[0] = C3DVector3MultMatrix4x4((float32x4_t *)&v70, v64);
      }
      else
      {
        if ((Element[18] & 7) != 2)
        {
          float32x4_t v54 = (float32x4_t)xmmword_20B5CB530;
          if (!Node)
          {
LABEL_38:
            int8x16_t v61 = (int8x16_t)vmulq_f32(v67, v54);
            *(float32x2_t *)v61.i8 = vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL));
            v61.i32[0] = vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1)).u32[0];
            uint64_t v60 = ((v61.i32[0] >> 31) | 0x80000000) ^ v61.i32[0];
            goto LABEL_39;
          }
          v70.n128_u32[2] = 0;
          v70.n128_u64[0] = 0;
          C3DNodeGetWorldPosition(Node, &v70);
          float32x4_t v54 = (float32x4_t)v70;
LABEL_37:
          v54.i32[3] = 1.0;
          goto LABEL_38;
        }
        __n128 WorldBoundingBox = C3DParticleSystemInstanceGetWorldBoundingBox(*((void *)Element + 6));
      }
      float32x4_t v54 = (float32x4_t)WorldBoundingBox;
      goto LABEL_37;
    }
  }
}

uint64_t C3DRendererElementIsOpaque(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 72) >> 3) & 1;
}

uint64_t C3DIndexStoreGetIndexForKey(uint64_t a1, void *key)
{
  if (!a1)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value) {
    return *(void *)Value;
  }
  else {
    return -1;
  }
}

uint64_t C3DRendererElementStoreGetPriorityIndex(uint64_t a1, uint64_t a2)
{
  return C3DIndexStoreGetOrderedIndexForKey(*(void *)(a1 + 24), (void *)*(int *)(a2 + 64));
}

uint64_t C3DIndexStoreGetOrderedIndexForKey(uint64_t a1, void *key)
{
  *(void *)&void v15[5] = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 56))
  {
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
    uint64_t v5 = *(void **)(a1 + 64);
    if (v5)
    {
      free(v5);
      *(void *)(a1 + 64) = 0;
    }
    if (Count >= 1)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(void *)(a1 + 64) = malloc_type_malloc(8 * v6 + 8, 0x100004000313F17uLL);
      uint64_t v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v7, 0);
      qsort(v7, Count, 8uLL, (int (__cdecl *)(const void *, const void *))_sortKeys);
      uint64_t v8 = 0;
      while (1)
      {
        CFDictionaryRef Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v7[v8]);
        if (!Value) {
          break;
        }
        uint64_t v10 = *Value;
        if (*Value < 0 || v10 > v6) {
          goto LABEL_11;
        }
LABEL_13:
        *(void *)(*(void *)(a1 + 64) + 8 * v10) = v8++;
        if (Count == v8)
        {
          free(v7);
          goto LABEL_15;
        }
      }
      uint64_t v10 = -1;
LABEL_11:
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        C3DIndexStoreGetOrderedIndexForKey_cold_1(v14, v15, v11);
      }
      goto LABEL_13;
    }
LABEL_15:
    *(unsigned char *)(a1 + 56) = 1;
  }
  uint64_t result = C3DIndexStoreGetIndexForKey(a1, key);
  if (result != -1)
  {
    uint64_t v13 = *(void *)(a1 + 64);
    if (v13) {
      return *(void *)(v13 + 8 * result);
    }
  }
  return result;
}

uint64_t C3DRendererElementStoreGetMaterialIndex(uint64_t a1, uint64_t a2)
{
  return C3DIndexStoreGetIndexForKey(*(void *)(a1 + 32), *(void **)(a2 + 32));
}

uint64_t C3DProgramHashCodeStoreGetProgramIndexForRenderElement(uint64_t a1, void *a2)
{
  if (a2) {
    return C3DIndexStoreGetIndexForKey(*(void *)(a1 + 48), a2);
  }
  else {
    return 0;
  }
}

uint64_t _C3DUpdateMeshElementsBBoxIfNeeded(uint64_t result)
{
  if ((*(unsigned char *)(result + 200) & 2) == 0)
  {
    uint64_t v1 = result;
    uint64_t result = (uint64_t)C3DMeshGetElementsCount(result);
    if (result >= 1)
    {
      uint64_t v2 = result;
      CFIndex v3 = 0;
      int32x4_t v28 = vdupq_n_s32(0x7F7FFFFFu);
      do
      {
        uint64_t ElementAtIndex = (float32x4_t *)C3DMeshGetElementAtIndex(v1, v3, 0);
        uint64_t v40 = 0;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v37 = 0u;
        C3DMeshElementGetContent((uint64_t)ElementAtIndex, 0, (uint64_t)&v37);
        if ((void)v37 && (float32x4_t *)C3DMeshElementGetSharedMeshElement((uint64_t)ElementAtIndex) == ElementAtIndex)
        {
          uint64_t result = (uint64_t)C3DMeshGetSourceWithSemanticAtIndex(v1, 0, 0, 0);
          if (result)
          {
            uint64_t result = C3DMeshSourceGetContent(result);
            if (result)
            {
              uint64_t v6 = result;
              uint64_t v7 = v5;
              IndexCFIndex Count = C3DMeshElementGetIndexCount((uint64_t)ElementAtIndex);
              uint64_t v10 = IndexCount;
              v11.i64[0] = 0x80000000800000;
              v11.i64[1] = 0x80000000800000;
              if ((v7 & 0xFF000000000000) == 0x1000000000000)
              {
                switch(BYTE11(v38))
                {
                  case 4u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      float32x4_t v18 = (_DWORD *)(v37 + 4 * *((void *)&v39 + 1));
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        uint64_t v19 = v6 + *v18 * BYTE5(v7);
                        v20.i64[0] = *(void *)v19;
                        v20.i64[1] = *(unsigned int *)(v19 + 8);
                        float32x4_t v12 = vminq_f32(v12, v20);
                        float32x4_t v11 = vmaxq_f32(v11, v20);
                        v18 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                  case 2u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      unsigned int v21 = (unsigned __int16 *)(v37 + 2 * *((void *)&v39 + 1));
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        unint64_t v22 = v6 + BYTE5(v7) * (unint64_t)*v21;
                        v23.i64[0] = *(void *)v22;
                        v23.i64[1] = *(unsigned int *)(v22 + 8);
                        float32x4_t v12 = vminq_f32(v12, v23);
                        float32x4_t v11 = vmaxq_f32(v11, v23);
                        v21 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                  case 1u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      uint64_t v13 = (unsigned __int8 *)(v37 + *((void *)&v39 + 1));
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        unint64_t v14 = v6 + BYTE5(v7) * (unint64_t)*v13;
                        v15.i64[0] = *(void *)v14;
                        v15.i64[1] = *(unsigned int *)(v14 + 8);
                        float32x4_t v12 = vminq_f32(v12, v15);
                        float32x4_t v11 = vmaxq_f32(v11, v15);
                        v13 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                }
              }
              else
              {
                switch(BYTE11(v38))
                {
                  case 4u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      uint64_t v24 = 0;
                      uint64_t v25 = v37;
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        float32x4_t v30 = v12;
                        float32x4_t v34 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ *(_DWORD *)(v25 + 4 * (*((void *)&v39 + 1) + v40 * v24))* BYTE5(v7)), v9, v11.f32[0], v12.f32[0]);
                        float32x4_t v12 = vminq_f32(v30, v9);
                        float32x4_t v11 = vmaxq_f32(v34, v9);
                        ++v24;
                      }
                      while (v10 != v24);
                    }
                    goto LABEL_43;
                  case 2u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      uint64_t v26 = 0;
                      uint64_t v27 = v37;
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        float32x4_t v31 = v12;
                        float32x4_t v35 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ BYTE5(v7)* (unint64_t)*(unsigned __int16 *)(v27+ 2* (*((void *)&v39 + 1)+ v40 * v26))), v9, v11.f32[0], v12.f32[0]);
                        float32x4_t v12 = vminq_f32(v31, v9);
                        float32x4_t v11 = vmaxq_f32(v35, v9);
                        ++v26;
                      }
                      while (v10 != v26);
                    }
                    goto LABEL_43;
                  case 1u:
                    float32x4_t v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      uint64_t v16 = 0;
                      uint64_t v17 = v37;
                      float32x4_t v12 = (float32x4_t)v28;
                      do
                      {
                        float32x4_t v29 = v12;
                        float32x4_t v33 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ BYTE5(v7)* (unint64_t)*(unsigned __int8 *)(v17+ *((void *)&v39 + 1)+ v40 * v16)), v9, v11.f32[0], v12.f32[0]);
                        float32x4_t v12 = vminq_f32(v29, v9);
                        float32x4_t v11 = vmaxq_f32(v33, v9);
                        ++v16;
                      }
                      while (v10 != v16);
                    }
                    goto LABEL_43;
                }
              }
              float32x4_t v12 = (float32x4_t)v28;
LABEL_43:
              float32x4_t v32 = v12;
              float32x4_t v36 = v11;
              ElementAtIndex[11] = v12;
              ElementAtIndex[12] = v11;
              uint64_t result = (uint64_t)C3DMeshGetRenderableElementAtIndexIfNeeded(v1, v3);
              if (result)
              {
                *(float32x4_t *)(result + 176) = v32;
                *(float32x4_t *)(result + 192) = v36;
              }
            }
          }
        }
        else
        {
          ElementAtIndex[11] = 0u;
          ElementAtIndex[12] = 0u;
          uint64_t result = (uint64_t)C3DMeshGetRenderableElementAtIndexIfNeeded(v1, v3);
          if (result)
          {
            *(_OWORD *)(result + 176) = 0u;
            *(_OWORD *)(result + 192) = 0u;
          }
        }
        ++v3;
      }
      while (v3 != v2);
    }
    *(unsigned char *)(v1 + 200) |= 2u;
  }
  return result;
}

double C3DVector3MultMatrix4x4(float32x4_t *a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(a1[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[1], *(float32x2_t *)a2.f32, 1), *a1, a2.f32[0]), a1[2], a2, 2)).u64[0];
  return result;
}

double C3DVector3MidVector(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vaddq_f32(a1, a2);
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(v2, v3).u64[0];
  return result;
}

const void *C3DMeshGetRenderableElementAtIndexIfNeeded(uint64_t a1, CFIndex idx)
{
  CFArrayRef Count = *(const __CFArray **)(a1 + 144);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  if ((uint64_t)Count <= idx) {
    return 0;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 144);

  return CFArrayGetValueAtIndex(v5, idx);
}

const UInt8 *C3DMeshElementGetContent@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = a2;
  uint64_t v6 = *(unsigned __int8 *)(a1 + 130);
  if (a2 < 0 || v6 <= a2)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementGetContent_cold_1(v6, v3, v7);
    }
  }
  int v8 = *(unsigned __int8 *)(a1 + 131);
  if (!*(unsigned char *)(a1 + 131)) {
    v3 *= C3DMeshElementGetIndexCount(a1);
  }
  int Type = C3DMeshElementGetType(a1);
  double result = *(const UInt8 **)(a1 + 96);
  if (result)
  {
    double result = CFDataGetBytePtr((CFDataRef)result);
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    if (Type == 4 && result) {
      float32x4_t v11 = &result[*(_DWORD *)(a1 + 104) * *(unsigned __int8 *)(a1 + 80)];
    }
    else {
      float32x4_t v11 = result;
    }
  }
  else
  {
    float32x4_t v11 = 0;
    *(void *)(a3 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
  }
  *(void *)a3 = v11;
  if (v8) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = 1;
  }
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x380], 8) = *(_DWORD *)(a1 + 104);
  *(void *)(a3 + 16) = *(void *)(a1 + 120);
  *(_WORD *)(a3 + 24) = *(_WORD *)(a1 + 128);
  *(unsigned char *)(a3 + 26) = *(unsigned char *)(a1 + 88);
  *(unsigned char *)(a3 + 27) = *(unsigned char *)(a1 + 80);
  if (Type == 4) {
    uint64_t v13 = result;
  }
  else {
    uint64_t v13 = 0;
  }
  *(void *)(a3 + 32) = v13;
  *(void *)(a3 + 40) = v3;
  *(void *)(a3 + 4_Block_object_dispose(&STACK[0x380], 8) = v12;
  return result;
}

uint64_t C3DSceneGetEnginePipeline(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 120);
}

double C3DVector3Rotate(float32x2_t *a1, float32x4_t a2)
{
  _Q1 = a2;
  *(float32x2_t *)a2.f32 = vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(a1[2], *(float32x2_t *)a2.f32, 1), *a1, a2.f32[0]), a1[4], a2, 2);
  _S2 = a1[5].i32[0];
  __asm { FMLA            S3, S2, V1.S[2] }
  a2.i32[2] = _S3;
  float32x4_t v9 = vmulq_f32(a2, a2);
  float v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  if (v10 != 0.0)
  {
    float32x4_t v11 = vmulq_f32(_Q1, _Q1);
    float v12 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
    float v13 = sqrtf(v10);
    if (v13 != v12) {
      a2.i64[0] = vmulq_n_f32(a2, v12 / v13).u64[0];
    }
  }
  return *(double *)a2.i64;
}

void C3DSortSystemSetCapacity(uint64_t a1, int a2)
{
  LODWORD(v2) = a2;
  uint64_t Capacity = C3DArrayGetCapacity(*(void *)(a1 + 16));
  if (Capacity <= v2) {
    unint64_t v5 = v2;
  }
  else {
    unint64_t v5 = Capacity;
  }
  if (v2 >= v5 >> 1) {
    int64_t v2 = v5;
  }
  else {
    int64_t v2 = v2;
  }
  if (v2 != Capacity)
  {
    uint64_t v6 = Capacity;
    C3DArraySetCapacity(*(void *)(a1 + 16), v2);
    C3DArraySetCount(*(_DWORD **)(a1 + 16), v2);
    BOOL v7 = v2 <= v6;
    int64_t v8 = v2 - v6;
    if (!v7)
    {
      float32x4_t v9 = (void *)(C3DArrayGetValuesPtr(*(void *)(a1 + 16)) + 8 * v6);
      memset(v9, 255, 8 * v8);
    }
  }
}

uint64_t _compareRendererElements(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t ValuesPtr = C3DArrayGetValuesPtr(*(void *)(a1 + 16));
  LODWORD(a2) = C3DRendererElementFlattenedIndexForSpanHandle(*a2, a2[1]);
  int v6 = C3DRendererElementFlattenedIndexForSpanHandle(*a3, a3[1]);
  unint64_t v7 = *(void *)(ValuesPtr + 8 * (int)a2);
  unint64_t v8 = *(void *)(ValuesPtr + 8 * v6);
  BOOL v9 = v7 > v8;
  if (v7 == v8) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = -1;
  }
  if (v9) {
    return 1;
  }
  else {
    return v10;
  }
}

uint64_t C3DRendererElementFlattenedIndexForSpanHandle(int a1, int a2)
{
  return (a2 + (a1 << 12));
}

uint64_t C3DArrayGetValuesPtr(uint64_t a1)
{
  if (!a1)
  {
    int64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

void C3DArraySetCount(_DWORD *a1, unsigned int a2)
{
  if (a1[6] != a2)
  {
    unsigned int v4 = a1[7];
    if (v4 < a2)
    {
      __allocate((uint64_t)a1, a1[8] * v4, a1[8] * a2);
      a1[7] = a2;
    }
    a1[6] = a2;
  }
}

__n128 C3DMatrix4x4GetTranslation(__n128 *a1, __n128 *a2)
{
  __n128 result = a1[3];
  *a2 = result;
  return result;
}

uint64_t C3DLightingSystemGetInfiniteLightSet(uint64_t a1, void *a2, _DWORD *a3)
{
  *a2 = *(void *)(a1 + 576);
  *a3 = *(_DWORD *)(a1 + 584);
  return *(unsigned __int8 *)(a1 + 588);
}

void C3DLightingSystemEndQueries(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v2 = a1 + 116416;
  uint64_t v3 = *(char **)(a1 + 116440);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 588))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 584);
      if (v4 >= 8) {
        unsigned int v4 = 8;
      }
      *(_DWORD *)(a1 + 4 * v4 + 11644_Block_object_dispose(&STACK[0x380], 8) = 666;
    }
    C3DAuthoringEnvironmentUpdateLightingStats(v3, (const void *)(a1 + 116448), 9u);
    if (C3DAuthoringEnvironmentShouldDisplayLightInfluences(*(void *)(v2 + 24)))
    {
      long long v48 = xmmword_20B5CB700;
      long long v49 = xmmword_20B5CB6E0;
      uint64_t v31 = *(unsigned int *)(a1 + 68);
      if (v31)
      {
        for (uint64_t i = 0; i != v31; ++i)
        {
          WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(*(void *)(a1 + 144) + 8 * i));
          uint64_t v9 = *(void *)(a1 + 400);
          int v10 = *(unsigned __int8 *)(v9 + i);
          if (*(unsigned char *)(v9 + i))
          {
            v50[0] = *(_OWORD *)"fff?";
            v50[1] = unk_20B5EE060;
            v50[2] = xmmword_20B5EE070;
            v50[3] = unk_20B5EE080;
            uint64_t v11 = *(void *)(*(void *)(a1 + 208) + 8 * i);
            BOOL v12 = C3DLightSupportsShadowCascades(v11);
            if (!v12)
            {
              uint64_t v14 = 1;
LABEL_14:
              uint64_t v15 = a1 + 1568 * (v10 - 1) + 116768;
              uint64_t v16 = (float *)v50;
              do
              {
                if (v12)
                {
                  v47[0] = *(float32x4_t *)v16;
                  v47[0].i32[2] = 1056964608;
                  char AutomaticallyAdjustsShadowProjection = C3DLightGetAutomaticallyAdjustsShadowProjection(v11);
                  float32x4_t v18 = *(uint64_t **)(v2 + 24);
                  if (AutomaticallyAdjustsShadowProjection) {
                    C3DAuthoringEnvironmentAppendDebugPolyhedron(v18, *(void *)(v15 + 240), 0, v47[0].f32);
                  }
                  else {
                    C3DAuthoringEnvironmentAppendDebugBoundingSphere((uint64_t)v18, *(void *)(v15 + 224), *(void *)(v15 + 232), 0, (long long *)v47);
                  }
                }
                C3DAuthoringEnvironmentAppendDebugFrustum(*(uint64_t **)(v2 + 24), (float32x4_t *)(v15 + 256), 0, v16);
                float32x4_t v19 = *(float32x4_t *)(v15 + 368);
                v47[0] = *(float32x4_t *)(v15 + 352);
                v47[1] = v19;
                C3DAuthoringEnvironmentAppendDebugBoundingBox(*(void *)(v2 + 24), v47, (float32x4_t *)v15, v16);
                v15 += 384;
                v16 += 4;
                --v14;
              }
              while (v14);
              goto LABEL_20;
            }
            ShadowCascadeCFArrayRef Count = C3DLightGetShadowCascadeCount(v11);
            if (ShadowCascadeCount)
            {
              uint64_t v14 = ShadowCascadeCount;
              goto LABEL_14;
            }
          }
LABEL_20:
          int v20 = *(unsigned __int8 *)(*(void *)(a1 + 336) + i);
          int Type = C3DLightGetType(*(void *)(*(void *)(a1 + 208) + 8 * i));
          uint64_t v22 = *(void *)(v2 + 24);
          if (v20) {
            float32x4_t v23 = &v48;
          }
          else {
            float32x4_t v23 = &v49;
          }
          if (Type == 1)
          {
            C3DAuthoringEnvironmentAppendDebugRay(v22, (uint64_t)WorldMatrix, (float *)v23, (float32x4_t)0, (float32x4_t)xmmword_20B5EE030);
          }
          else
          {
            C3DAuthoringEnvironmentAppendDebugSegment(v22, (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_20B5CB820, (float32x4_t)xmmword_20B5CB8E0);
            C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(v2 + 24), (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_20B5CB7D0, (float32x4_t)xmmword_20B5CB8B0);
            C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(v2 + 24), (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_20B5CB520, (float32x4_t)xmmword_20B5CB810);
          }
        }
      }
      v43[0] = MEMORY[0x263EF8330];
      v43[1] = 0x40000000;
      v43[2] = __C3DLightingSystemEndQueries_block_invoke;
      v43[3] = &__block_descriptor_tmp_16_0;
      uint64_t v46 = a1;
      long long v44 = v48;
      long long v45 = v49;
      unsigned int v24 = *(_DWORD *)(a1 + 72);
      if (v24) {
        __C3DLightingSystemEndQueries_block_invoke((uint64_t)v43, v24, v5, v6, *(void *)(a1 + 456));
      }
      uint64_t v36 = MEMORY[0x263EF8330];
      uint64_t v37 = 0x40000000;
      long long v38 = __C3DLightingSystemEndQueries_block_invoke_2;
      long long v39 = &__block_descriptor_tmp_18_0;
      uint64_t v42 = a1;
      long long v40 = v48;
      long long v41 = v49;
      uint64_t v25 = *(unsigned int *)(a1 + 88);
      if (v25)
      {
        uint64_t v26 = 0;
        uint64_t v27 = *(void *)(a1 + 464);
        do
        {
          long long v28 = *(_OWORD *)(v27 + 16 * v26);
          HIDWORD(v2_Block_object_dispose(&STACK[0x380], 8) = sqrtf(*((float *)&v28 + 3));
          if (*(unsigned char *)(*(void *)(v42 + 376) + v26)) {
            float32x4_t v29 = &v40;
          }
          else {
            float32x4_t v29 = &v41;
          }
          C3DAuthoringEnvironmentAppendDebugBoundingSphere(*(void *)(v42 + 116440), *(void *)(v27 + 16 * v26++), *((uint64_t *)&v28 + 1), 0, v29);
        }
        while (v25 != v26);
      }
      v32[0] = MEMORY[0x263EF8330];
      v32[1] = 0x40000000;
      v32[2] = __C3DLightingSystemEndQueries_block_invoke_3;
      v32[3] = &__block_descriptor_tmp_20_3;
      uint64_t v35 = a1;
      long long v33 = v48;
      long long v34 = v49;
      unsigned int v30 = *(_DWORD *)(a1 + 76);
      if (v30) {
        __C3DLightingSystemEndQueries_block_invoke_3((uint64_t)v32, v30, v5, v6, *(void *)(a1 + 472));
      }
    }
  }
  if (*(_DWORD *)(a1 + 80)) {
    C3DLightProbesEndQueries(*(void *)(a1 + 24));
  }
  *(void *)(v2 + 24) = 0;
  *(void *)uint64_t v2 = 0;
}

uint64_t C3DFillModeToMTLFillMode(unsigned int a1)
{
  if (a1 >= 2)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFillModeToMTLFillMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_FillMode[a1];
}

uint64_t C3DEngineContextGetWarmUpAbortHandler(uint64_t a1)
{
  return *(void *)(a1 + 464);
}

uint64_t C3DEngineContextGetRendererContextProfile(uint64_t a1)
{
  if (*(void *)(a1 + 1704))
  {
    uint64_t v1 = *(void *)(a1 + 1704);
    return -[SCNMTLRenderContext profile](v1);
  }
  else
  {
    uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
    if (RendererContextGL)
    {
      return C3DRendererContextGetProfile(RendererContextGL);
    }
    else
    {
      return 1;
    }
  }
}

uint64_t C3DCullModeToMTLCullMode(int a1)
{
  if (a1 >= 3)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCullModeToMTLCullMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_CullMode[a1];
}

uint64_t C3DImageCopyCachedImageOrCreateIfNeededForSource(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DKeyframedAnimationCopy_cold_2(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  Shareduint64_t Instance = C3DResourceCacheGetSharedInstance();
  return C3DResourceCacheCopyResourceOrCreateIfNeededForSource(SharedInstance, a1, 1, a3);
}

uint64_t C3DResourceCacheGetSharedInstance()
{
  if (C3DResourceCacheGetSharedInstance_onceToken != -1) {
    dispatch_once(&C3DResourceCacheGetSharedInstance_onceToken, &__block_literal_global_4_3);
  }
  return _sharedInstance;
}

uint64_t C3DResourceCacheCopyResourceOrCreateIfNeededForSource(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceOrCreateIfNeededForSource_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DResourceCacheCopyResourceOrCreateIfNeededForSource_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  char v36 = 0;
  unsigned int v24 = (void *)_C3DResourceCacheStandardizeSource(a2, &v36);
  double valuePtr = 0.0;
  double v35 = 0.0;
  uint64_t v25 = (const void *)objc_msgSend((id)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v24), "copyWeakRef");
  if (v25)
  {
    if (v36)
    {
      BOOL v26 = SCNHasSpecialResourceBundle();
      double FileTimestampForSourceAtPath = C3DResourceCacheGetFileTimestampForSourceAtPath(v24);
      double v35 = FileTimestampForSourceAtPath;
      if (FileTimestampForSourceAtPath != 0.0)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v24);
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
          double v29 = valuePtr;
        }
        else
        {
          double v29 = 0.0;
        }
        if (v29 == FileTimestampForSourceAtPath) {
          goto LABEL_25;
        }
LABEL_21:
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v24);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v25);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v24);
        CFRelease(v25);
        if (!a4) {
          goto LABEL_22;
        }
        goto LABEL_12;
      }
      if (v26) {
        goto LABEL_21;
      }
    }
LABEL_25:
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    return (uint64_t)v25;
  }
  double FileTimestampForSourceAtPath = 0.0;
  if (!a4)
  {
LABEL_22:
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    return 0;
  }
LABEL_12:
  if (a3)
  {
    unsigned int v30 = (const void *)(*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
    uint64_t v31 = objc_alloc_init(SCNWeakPointer);
    [(SCNWeakPointer *)v31 setWeakRef:v30];
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v24, v31);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v30, v24);

    if (v36)
    {
      if (!v25)
      {
        double FileTimestampForSourceAtPath = C3DResourceCacheGetFileTimestampForSourceAtPath(v24);
        double v35 = FileTimestampForSourceAtPath;
      }
      if (FileTimestampForSourceAtPath != 0.0)
      {
        CFNumberRef v32 = CFNumberCreate(0, kCFNumberDoubleType, &v35);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v24, v32);
        CFRelease(v32);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    return (uint64_t)v30;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

uint64_t _C3DResourceCacheStandardizeSource(void *a1, unsigned char *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFURLGetTypeID())
  {
    if (![a1 query])
    {
      *a2 = 1;
      if ([a1 isFileURL])
      {
        return [a1 relativePath];
      }
      else
      {
        return [a1 path];
      }
    }
LABEL_11:
    *a2 = 0;
    return (uint64_t)a1;
  }
  if (v4 != CFStringGetTypeID()) {
    goto LABEL_11;
  }
  *a2 = 1;

  return [a1 stringByStandardizingPath];
}

uint64_t C3DImageCreateWithMDLTexture(void *a1)
{
  uint64_t v2 = C3DImageCreateWithCGImage((CGImage *)[a1 imageFromTexture]);
  if ([a1 isCube])
  {
    C3DImageChangeImageTypeToCubeMapIfSuitable(v2);
    if (!C3DImageIsCubeMap(v2))
    {
      uint64_t v3 = scn_default_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: Failed to create cubemap from Model I/O texture", v5, 2u);
      }
    }
  }
  return v2;
}

uint64_t C3DImageCreateWithCGImage(CGImage *a1)
{
  uint64_t v2 = C3DImageCreate();
  if (v2)
  {
    *(void *)(v2 + 8_Block_object_dispose(&STACK[0x380], 8) = CGImageRetain(a1);
    *(_DWORD *)(v2 + 96) = 3;
  }
  return v2;
}

uint64_t C3DImageCreate()
{
  if (C3DImageGetTypeID_onceToken != -1) {
    dispatch_once(&C3DImageGetTypeID_onceToken, &__block_literal_global_28);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DImageGetTypeID_typeID, 0x70uLL);
  *(unsigned char *)(result + 116) &= 0xFCu;
  *(_DWORD *)(result + 120) = 1;
  return result;
}

uint64_t C3DResourceCacheCopySourceForResource(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceOrCreateIfNeededForSource_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DResourceCacheCopySourceForResource_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    uint64_t v25 = Value;
    CFRetain(Value);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  }
  else if (a4)
  {
    if (a3)
    {
      char v31 = 0;
      uint64_t v27 = (void *)(*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
      uint64_t v25 = (void *)_C3DResourceCacheStandardizeSource(v27, &v31);
      long long v28 = objc_alloc_init(SCNWeakPointer);
      [(SCNWeakPointer *)v28 setWeakRef:a2];
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v25, v28);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, v25);

      if (v31)
      {
        double FileTimestampForSourceAtPath = C3DResourceCacheGetFileTimestampForSourceAtPath(v25);
        if (FileTimestampForSourceAtPath != 0.0)
        {
          CFNumberRef v29 = CFNumberCreate(0, kCFNumberDoubleType, &FileTimestampForSourceAtPath);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v25, v29);
          CFRelease(v29);
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
      if (v27 != v25)
      {
        CFRetain(v25);
        CFRelease(v27);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
      return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    return 0;
  }
  return (uint64_t)v25;
}

BOOL C3DImageHasTextureRawData(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 80) & 2) != 0 || C3DImageGetTextureRawData(a1) != 0;
}

uint64_t C3DMeshElementGetIndexes(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(unsigned __int8 *)(a1 + 80);
  }
  return *(void *)(a1 + 96);
}

uint64_t C3DMeshElementGetIndexCount(uint64_t a1)
{
  int Type = C3DMeshElementGetType(a1);
  if (Type == 4)
  {
    unint64_t v4 = *(unsigned __int8 *)(a1 + 80);
    uint64_t v3 = *(unsigned int *)(a1 + 104);
    uint64_t v5 = CFDataGetLength(*(CFDataRef *)(a1 + 96)) / v4 - v3;
    uint64_t v6 = *(unsigned __int8 *)(a1 + 130);
    uint64_t v7 = v5 / v6;
    if (v5 % v6)
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        C3DMeshElementGetIndexCount_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
    return v7;
  }
  else
  {
    uint64_t v17 = *(unsigned int *)(a1 + 104);
    return C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount(Type, v17);
  }
}

uint64_t C3DMeshElementGetType(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(char *)(a1 + 88);
}

BOOL C3DGeometryGetEffectiveDataKindForRendering(__C3DGeometry *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return !C3DGeometryOsdGetWantsGPUSubdivision(a1);
}

BOOL C3DGeometryOsdGetWantsGPUSubdivision(__C3DGeometry *a1)
{
  return a1->var10.var0 && a1->var11.var0 == 4 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

uint64_t C3DGeometryGetOverrideMaterial(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t C3DFXMetalProgramGetTypeID()
{
  if (C3DFXMetalProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  }
  return C3DFXMetalProgramGetTypeID_typeID;
}

BOOL C3DGeometryGetWantsHardwareTessellation(__C3DGeometry *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (a1->var11.var0 - 1 < 3) {
    return C3DGeometryMeshElementsSupportsTessellation((uint64_t)a1);
  }
  if (a1->var11.var0) {
    return C3DGeometryOpenSubdivGPUIsActive(a1);
  }
  return 0;
}

uint64_t C3DNodeGetSkinner(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 248);
  if (result) {
    return C3DDeformerStackGetSkinner(result);
  }
  return result;
}

uint64_t C3DMaterialGetColorBufferWriteMask(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 93);
}

uint64_t C3DMeshElementGetPrimitiveRange(uint64_t a1)
{
  if (*(_WORD *)(a1 + 128) == 1) {
    return **(void **)(a1 + 120);
  }
  else {
    return -1;
  }
}

uint64_t C3DMeshElementGetSharedMeshElement(uint64_t result)
{
  if (*(void *)(result + 72)) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t C3DMeshElementGetInstanceCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 68);
}

void SCNMTLRenderCommandEncoder::setFragmentTexture(uint64_t a1, void *a2, unint64_t a3)
{
  if (a2)
  {
    if (([a2 conformsToProtocol:&unk_26C0078D8] & 1) == 0)
    {
      uint64_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }
  uint64_t v14 = a1 + 8 * a3;
  if (*(void **)(v14 + 2224) != a2)
  {
    *(void *)(v14 + 2224) = a2;
    *(void *)(a1 + 8 * (a3 >> 6) + 3424) |= 1 << a3;
  }
}

void C3DNodeSetGeometry(uint64_t a1, __C3DGeometry *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t Geometry = C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    uint64_t v13 = (void *)Geometry;
    C3DGeometryUntrackNode(Geometry, (const void *)a1);
    C3DRemoveSceneRef(v13, *(void *)(a1 + 48));
  }
  uint64_t v14 = *(__C3DGeometry **)(a1 + 240);
  if (v14 != a2)
  {
    if (v14)
    {
      CFRelease(v14);
      *(void *)(a1 + 240) = 0;
    }
    if (a2) {
      CFTypeRef v15 = CFRetain(a2);
    }
    else {
      CFTypeRef v15 = 0;
    }
    *(void *)(a1 + 240) = v15;
  }
  if (a2) {
    C3DGeometryTrackNode((uint64_t)a2, (const void *)a1);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", (const void *)a1, (const __CFDictionary *)@"kMeshKey", 1u);
  }
  if (!a2) {
    goto LABEL_22;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  if (v18) {
    C3DAddSceneRef((uint64_t *)a2, v18);
  }
  CFTypeID v19 = CFGetTypeID(a2);
  if (v19 == C3DFloorGetTypeID())
  {
    int v20 = 4096;
  }
  else
  {
LABEL_22:
    int v20 = 0;
    int v21 = 0;
    int v22 = *(_DWORD *)(a1 + 220);
    if ((v22 & 0x1000) == 0) {
      goto LABEL_24;
    }
  }
  uint64_t v23 = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(v23, @"kC3DNotificationEngineContextInvalidatePasses", *(const void **)(a1 + 48), 0, 1u);
  int v22 = *(_DWORD *)(a1 + 220);
  int v21 = v20;
LABEL_24:
  *(_DWORD *)(a1 + 220) = v22 & 0xFFFFEFFF | v21;
  unsigned int v24 = *(void **)(a1 + 248);
  if (v24) {
    C3DDeformerStackSetBaseGeometry(v24, a2);
  }
  C3DNodeGeometryLODDidUpdate(a1);
  C3DNodeBoundingBoxDidUpdate(a1);
  __UpdateCullingSystemFlags(a1, 0);
  uint64_t v25 = a1;
  do
  {
    *(_DWORD *)(v25 + 220) |= 2u;
    uint64_t v25 = *(void *)(v25 + 64);
  }
  while (v25);
  if (v16) {
    __UpdateCullingHandle(a1, v16);
  }
}

void C3DNodeBoundingBoxDidUpdate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 220) & 4) == 0) {
    __C3DComputeLocalBoundingBox(a1);
  }
  if (*(_DWORD *)(a1 + 216) != -1)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (v10)
    {
      CullingSysteCFIndex m = (void *)C3DSceneGetCullingSystem(v10);
      long long v12 = *(_OWORD *)(a1 + 288);
      v13[0] = *(_OWORD *)(a1 + 272);
      v13[1] = v12;
      if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) & 0x80000000) != 0) {
        C3DCullingSystemUpdateBoundingBox(CullingSystem, *(_DWORD *)(a1 + 216), v13);
      }
    }
  }
}

__n128 __C3DComputeLocalBoundingBox(uint64_t a1)
{
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  *(_OWORD *)(a1 + 28_Block_object_dispose(&STACK[0x380], 8) = xmmword_20B5CB570;
  Deformeruint64_t Stack = C3DNodeGetDeformerStack(a1);
  if (!DeformerStack || !C3DDeformerStackGetLocalBoundingBox(DeformerStack, a1 + 272))
  {
    uint64_t Geometry = (const void *)C3DNodeGetGeometry(a1);
    if (Geometry)
    {
      float32x4_t v8 = 0uLL;
      float32x4_t v7 = 0uLL;
      if (C3DGetBoundingBox(Geometry, 0, (uint64_t)&v8, (uint64_t)&v7))
      {
        v5.i64[0] = 0x3F0000003F000000;
        v5.i64[1] = 0x3F0000003F000000;
        float32x4_t v6 = vmulq_f32(vaddq_f32(v8, v7), v5);
        __n128 result = (__n128)vmulq_f32(vsubq_f32(v7, v8), v5);
        v6.i32[3] = 1.0;
        result.n128_u32[3] = 0;
        *(float32x4_t *)(a1 + 272) = v6;
        *(__n128 *)(a1 + 28_Block_object_dispose(&STACK[0x380], 8) = result;
      }
    }
  }
  return result;
}

uint64_t C3DNodeGetDeformerStack(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 248);
}

uint64_t C3DGetBoundingBox(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!cf)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (uint64_t v17 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t, uint64_t))ClassWithTypeID[15]) != 0)
  {
    return v17(cf, a2, a3, a4);
  }
  else
  {
    return 0;
  }
}

uint64_t _C3DGeometryGetBoundingBox(uint64_t a1, uint64_t a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v6 = *(float32x4_t **)(a1 + 104);
  if (v6)
  {
    *a3 = vsubq_f32(*v6, v6[1]);
    *a4 = vaddq_f32(*(float32x4_t *)*(void *)(a1 + 104), *(float32x4_t *)(*(void *)(a1 + 104) + 16));
    return 1;
  }
  else
  {
    uint64_t result = C3DGeometryGetMesh(a1);
    if (result)
    {
      return C3DMeshGetBoundingBox(result, a3, a4);
    }
  }
  return result;
}

uint64_t C3DGeometryGetMesh(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void (***)(uint64_t))(a1 + 120);
  if (v10) {
    (*v10)(a1);
  }
  return *(void *)(a1 + 64);
}

uint64_t C3DMeshGetBoundingBox(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(_OWORD **)(a1 + 192);
  if (!v14)
  {
    SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
    float32x4_t v33 = 0u;
    if (SourceWithSemanticAtIndex
      && (Content = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex), uint64_t v19 = v17, v17))
    {
      uint64_t v20 = Content;
      float32x4_t v21 = 0uLL;
      if (Content)
      {
        if ((v17 & 0xFF000000000000) == 0x1000000000000)
        {
          uint64_t v22 = 0;
          float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          v21.i64[0] = 0x80000000800000;
          v21.i64[1] = 0x80000000800000;
          do
          {
            uint64_t v24 = Content + v22;
            v25.i64[0] = *(void *)v24;
            v25.i64[1] = *(unsigned int *)(v24 + 8);
            float32x4_t v23 = vminnmq_f32(v23, v25);
            float32x4_t v21 = vmaxnmq_f32(v21, v25);
            v22 += BYTE5(v17);
            --v19;
          }
          while (v19);
        }
        else
        {
          unsigned int v26 = 0;
          int v27 = BYTE4(v17);
          float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          int v28 = BYTE5(v17);
          v21.i64[0] = 0x80000000800000;
          v21.i64[1] = 0x80000000800000;
          do
          {
            float32x4_t v31 = v21;
            float32x4_t v34 = v23;
            *(double *)v18.i64 = C3DConvertFloatingTypeToFloat4(v27, (float *)(v20 + v26), v18, v23.f32[0], v21.f32[0]);
            float32x4_t v23 = vminnmq_f32(v34, v18);
            float32x4_t v21 = vmaxnmq_f32(v31, v18);
            v26 += v28;
            --v19;
          }
          while (v19);
        }
        float32x4_t v33 = v23;
      }
    }
    else
    {
      float32x4_t v21 = 0uLL;
    }
    float32x4_t v32 = v21;
    CFNumberRef v29 = C3DMalloc(0x20uLL);
    *(void *)(a1 + 192) = v29;
    _OWORD *v29 = v33;
    *(float32x4_t *)(*(void *)(a1 + 192) + 16) = v32;
    uint64_t v14 = *(_OWORD **)(a1 + 192);
  }
  *a2 = *v14;
  *a3 = *(_OWORD *)(*(void *)(a1 + 192) + 16);
  return 1;
}

__C3DCullingSystem *__UpdateCullingSystemFlags(uint64_t a1, int a2)
{
  uint64_t result = *(__C3DCullingSystem **)(a1 + 48);
  if (result)
  {
    uint64_t result = (__C3DCullingSystem *)C3DSceneGetCullingSystem((uint64_t)result);
    if (result)
    {
      if (a2)
      {
        v6[0] = MEMORY[0x263EF8330];
        v6[1] = 0x40000000;
        v6[2] = ____UpdateCullingSystemFlags_block_invoke;
        v6[3] = &__block_descriptor_tmp_165;
        v6[4] = result;
        return (__C3DCullingSystem *)C3DNodeApplyHierarchy(a1, (uint64_t)v6);
      }
      else
      {
        unsigned int v5 = *(_DWORD *)(a1 + 216);
        if (v5 != -1)
        {
          return (__C3DCullingSystem *)C3DCullingSystemUpdateFlags(result, v5);
        }
      }
    }
  }
  return result;
}

void C3DNodeGeometryLODDidUpdate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void **)(a1 + 232);
  if (v10) {
    free(v10);
  }
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 220) &= ~0x8000u;
  uint64_t Geometry = C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    CFArrayRef LOD = (const __CFArray *)C3DGeometryGetLOD(Geometry);
    if (LOD)
    {
      CFArrayRef v13 = LOD;
      if (CFArrayGetCount(LOD) >= 1)
      {
        CFIndex Count = CFArrayGetCount(v13);
        uint64_t v15 = Count;
        if (Count >= 0) {
          uint64_t v16 = Count;
        }
        else {
          uint64_t v16 = Count + 1;
        }
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v13, v16 >> 1);
        char v18 = C3DLODGetThresholdType((uint64_t)ValueAtIndex);
        uint64_t v19 = (char *)malloc_type_malloc(12 * v15 + 8, 0x2D81DF56uLL);
        *(void *)(a1 + 232) = v19;
        *(_WORD *)uint64_t v19 = v15;
        v19[2] = v18;
        *(_DWORD *)(*(void *)(a1 + 232) + 4) = 0;
        *(_DWORD *)(a1 + 220) |= 0x8000u;
        if (v15 >= 1)
        {
          CFIndex v20 = 0;
          float32x4_t v21 = (float *)(v19 + 16);
          do
          {
            uint64_t v22 = CFArrayGetValueAtIndex(v13, v20);
            *(v21 - 2) = C3DLODGetThreshold((uint64_t)v22);
            *(void *)(v21 - 1) = 0xFFFFFFFFLL;
            ++v20;
            v21 += 3;
          }
          while (v15 != v20);
        }
      }
    }
  }
  C3DScenePostPipelineEvent(*(void *)(a1 + 48), 2, (const void *)a1, @"kMeshKey");
}

uint64_t C3DGeometryGetLOD(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 96);
}

CFIndex C3DGeometryTrackNode(uint64_t a1, const void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFSetRef Mutable = *(const __CFSet **)(a1 + 88);
  if (!Mutable)
  {
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x380], 8) = Mutable;
  }
  if (CFSetContainsValue(Mutable, a2))
  {
    float32x4_t v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
    }
  }
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 88), a2);
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a1 + 112) & 0xFE | (CFSetGetCount(*(CFSetRef *)(a1 + 88)) > 4);
  CFIndex result = *(void *)(a1 + 96);
  if (result)
  {
    CFIndex result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      CFIndex v30 = result;
      for (CFIndex i = 0; i != v30; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        CFIndex result = C3DLODGetEntity((uint64_t)ValueAtIndex);
        if (result) {
          CFIndex result = C3DGeometryTrackNode(result, a2);
        }
      }
    }
  }
  return result;
}

BOOL C3DMeshElementIsVolatile(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 82) != 0;
}

uint64_t C3DMaterialGetBlendStates(uint64_t a1, int a2, int a3, int a4, float *a5, float a6)
{
  switch(*(unsigned char *)(a1 + 92))
  {
    case 0:
      if (!*(void *)(a1 + 64) && (uint64_t v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
      {
        C3DMaterialGetBlendStates_cold_3(v11, v12, v13, v14, v15, v16, v17, v18);
        if (a5) {
          goto LABEL_7;
        }
      }
      else if (a5)
      {
        goto LABEL_7;
      }
      uint64_t v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        C3DMaterialGetBlendStates_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
      }
LABEL_7:
      if (a2)
      {
        if (a6 >= 1.0) {
          return C3DBlendStatesDefaultReplace();
        }
        uint64_t v27 = a5;
        float v28 = a6;
        goto LABEL_10;
      }
      float v40 = 1.0;
      if (!a3 || !C3DEffectCommonProfileHasConstantAlpha(*(float **)(a1 + 64), &v40)) {
        return C3DBlendStatesDefaultOver();
      }
      if (C3DEffectCommonProfileGetTransparencyMode(*(void *)(a1 + 64)) != 1)
      {
        float v28 = v40 * a6;
        uint64_t v27 = a5;
LABEL_10:
        C3DColor4Make(v27, 0.0, 0.0, 0.0, v28);
        return C3DBlendStatesDefaultConstantAlpha();
      }
      float FloatProperty = C3DEffectCommonProfileGetFloatProperty(*(float **)(a1 + 64), 18);
      uint64_t Color = (float *)C3DEffectCommonProfileGetColor(*(void *)(a1 + 64), 5);
      float v33 = Color[1];
      float v34 = Color[2];
      float v35 = v33 * 0.71516 + *Color * 0.212671 + v34 * 0.072169;
      float v36 = (1.0 - (float)(FloatProperty * *Color)) * a6;
      float v37 = (1.0 - (float)(FloatProperty * v33)) * a6;
      float v38 = (1.0 - (float)(FloatProperty * v34)) * a6;
      float v39 = (1.0 - (float)(FloatProperty * v35)) * a6;
      C3DColor4Make(a5, v36, v37, v38, v39);
      return C3DBlendStatesDefaultConstantColor();
    case 1:
      return C3DBlendStatesDefaultAdditive();
    case 2:
      return C3DBlendStatesDefaultSubtract();
    case 3:
      if (a4)
      {
        return C3DBlendStatesDefaultMultiplicativeSeparate();
      }
      else
      {
        return C3DBlendStatesDefaultMultiplicative();
      }
    case 4:
      return C3DBlendStatesDefaultScreen();
    case 5:
      return C3DBlendStatesDefaultReplace();
    case 6:
      return C3DBlendStatesDefaultMax();
    default:
      CFIndex v30 = scn_default_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        C3DMaterialGetBlendStates_cold_1(v30);
      }
      return C3DBlendStatesDefaultOver();
  }
}

uint64_t C3DBlendStatesNeedsConstantColor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DBlendStatesGetDesc_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t C3DMeshElementTypeToMTLPrimitiveType(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 0:
      uint64_t result = 3;
      break;
    case 1:
      uint64_t result = 4;
      break;
    case 2:
      uint64_t result = 1;
      break;
    case 4:
      uint64_t v3 = scn_default_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
        C3DMeshElementTypeToMTLPrimitiveType_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
      }
      goto LABEL_9;
    case 5:
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        C3DMeshElementTypeToMTLPrimitiveType_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
      }
LABEL_9:
      uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t C3DMeshElementGetMTLBuffer(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

uint64_t C3DBlendStatesDefaultReplace()
{
  if (C3DBlendStatesDefaultReplace_onceToken != -1) {
    dispatch_once(&C3DBlendStatesDefaultReplace_onceToken, &__block_literal_global_27_1);
  }
  return C3DBlendStatesDefaultReplace_states;
}

void C3DCullingSystemUpdateBoundingBox(void *a1, unsigned int a2, _OWORD *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DCullingSystemAdd_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if ((a2 & 0x80000000) != 0) {
      goto LABEL_10;
    }
  }
  else if ((a2 & 0x80000000) != 0)
  {
    goto LABEL_10;
  }
  uint64_t v14 = a1[4];
  if (a2 < (unint64_t)((a1[5] - v14) >> 2))
  {
    uint64_t v15 = *(unsigned int *)(v14 + 4 * a2);
    long long v16 = a3[1];
    uint64_t v17 = (_OWORD *)(a1[8] + 32 * v15);
    _OWORD *v17 = *a3;
    v17[1] = v16;
    if ((*(_WORD *)(a1[11] + 2 * v15) & 0x10) != 0)
    {
      __n128 v23 = (__n128)xmmword_20B5CBCE0;
      __n128 v21 = *(__n128 *)(MEMORY[0x263EF89A8] + 48);
    }
    else
    {
      float32x4_t v25 = *(float32x4_t *)a3;
      int32x4_t v26 = *((int32x4_t *)a3 + 1);
      WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(a1[13] + 8 * v15));
      float32x4_t v19 = WorldMatrix[1];
      float32x4_t v20 = WorldMatrix[2];
      __n128 v21 = (__n128)vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v19, *(float32x2_t *)v25.f32, 1), *WorldMatrix, v25.f32[0]), v20, v25, 2));
      v21.n128_u32[3] = 1.0;
      float32x4_t v22 = (float32x4_t)v26;
      v22.i32[1] = v26.i32[0];
      v22.i32[2] = v26.i32[0];
      __n128 v23 = (__n128)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v22, *WorldMatrix)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), v26), v19))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32(v26, v26), v26), v20)));
    }
    __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)a1, v15, v21, v23);
    return;
  }
LABEL_10:
  uint64_t v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
    C3DCullingSystemUpdateBoundingBox_cold_1(a2, v24);
  }
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBuffer(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = result + 16 * a4;
  if (*(void *)(v4 + 80) == a2)
  {
    uint64_t v6 = *(void *)(v4 + 88);
    uint64_t v5 = (uint64_t *)(v4 + 88);
    if (v6 != a3)
    {
      *uint64_t v5 = a3;
      return [*(id *)(result + 3392) setVertexBufferOffset:a3 atIndex:a4];
    }
  }
  else
  {
    *(void *)(v4 + 80) = a2;
    *(void *)(v4 + 8_Block_object_dispose(&STACK[0x380], 8) = a3;
    return objc_msgSend(*(id *)(result + 3392), "setVertexBuffer:offset:atIndex:", a2);
  }
  return result;
}

uint64_t SCNMTLRenderCommandEncoder::drawIndexedPrimitives(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  SCNMTLRenderCommandEncoder::_bindPendingTextures((SCNMTLRenderCommandEncoder *)a1);
  SCNMTLRenderCommandEncoder::applyChangedStates((SCNMTLRenderCommandEncoder *)a1);
  uint64_t v16 = *(unsigned int *)(a1 + 64);
  unint64_t v17 = v16 * a7;
  uint64_t v18 = v16 * a8;
  float32x4_t v19 = *(void **)(a1 + 3392);
  if (v17 <= 1 && v18 == 0)
  {
    return [v19 drawIndexedPrimitives:a2 indexCount:a3 indexType:a4 indexBuffer:a5 indexBufferOffset:a6];
  }
  else if (v18)
  {
    return objc_msgSend(v19, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:", a2, a3, a4, a5, a6, 0, v18);
  }
  else
  {
    return objc_msgSend(v19, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:", a2, a3, a4, a5, a6);
  }
}

void SCNMTLRenderCommandEncoder::_bindPendingTextures(SCNMTLRenderCommandEncoder *this)
{
  uint64_t v2 = 0;
  *(void *)&v28[5] = *MEMORY[0x263EF8340];
  uint64_t v3 = &this->var15[3];
  do
  {
    uint64_t v4 = &this->var0 + 8 * v2;
    unint64_t v5 = *((void *)v4 + 426);
    if (v5)
    {
      unsigned int v6 = 0;
      uint64_t v7 = 0xFFFFFFFFLL;
      int v8 = 1;
      do
      {
        if (v5)
        {
          if (v7 >= v8 - 1) {
            uint64_t v10 = (v8 - 1);
          }
          else {
            uint64_t v10 = v7;
          }
          if ((v5 & 2) != 0) {
            goto LABEL_21;
          }
          if (v7 >= v6) {
            int v11 = v6;
          }
          else {
            int v11 = v7;
          }
          unsigned int v12 = v8 - v11;
          if ((v8 - v11) < 2) {
            [(id)this->var24[1] setVertexTexture:this->var15[v10 + 3] atIndex:v10];
          }
          else {
            objc_msgSend((id)this->var24[1], "setVertexTextures:withRange:", &v3[v10], v10, (v8 - v11));
          }
          SCNMTLEnsureIOSurfaceBackingBufferValidity((__IOSurface *)this->var24[0], &v3[v10], v12);
        }
        else if (v7 != -1)
        {
          uint64_t v9 = scn_default_log();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v27, v28, v9);
          }
          uint64_t v10 = v7;
          goto LABEL_21;
        }
        uint64_t v10 = 0xFFFFFFFFLL;
LABEL_21:
        ++v6;
        ++v8;
        uint64_t v7 = v10;
        BOOL v13 = v5 >= 2;
        v5 >>= 1;
      }
      while (v13);
    }
    *((void *)v4 + 426) = 0;
    ++v2;
  }
  while (v2 != 2);
  uint64_t v14 = 0;
  uint64_t v15 = &this->var18[3];
  do
  {
    uint64_t v16 = &this->var0 + 8 * v14;
    unint64_t v17 = *((void *)v16 + 428);
    if (v17)
    {
      unsigned int v18 = 0;
      uint64_t v19 = 0xFFFFFFFFLL;
      int v20 = 1;
      do
      {
        if (v17)
        {
          if (v19 >= v20 - 1) {
            uint64_t v22 = (v20 - 1);
          }
          else {
            uint64_t v22 = v19;
          }
          if ((v17 & 2) != 0) {
            goto LABEL_43;
          }
          if (v19 >= v18) {
            int v23 = v18;
          }
          else {
            int v23 = v19;
          }
          unsigned int v24 = v20 - v23;
          if ((v20 - v23) < 2) {
            [(id)this->var24[1] setFragmentTexture:this->var18[v22 + 3] atIndex:v22];
          }
          else {
            objc_msgSend((id)this->var24[1], "setFragmentTextures:withRange:", &v15[v22], v22, (v20 - v23));
          }
          SCNMTLEnsureIOSurfaceBackingBufferValidity((__IOSurface *)this->var24[0], &v15[v22], v24);
        }
        else if (v19 != -1)
        {
          __n128 v21 = scn_default_log();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v25, &v26, v21);
          }
          uint64_t v22 = v19;
          goto LABEL_43;
        }
        uint64_t v22 = 0xFFFFFFFFLL;
LABEL_43:
        ++v18;
        ++v20;
        uint64_t v19 = v22;
        BOOL v13 = v17 >= 2;
        v17 >>= 1;
      }
      while (v13);
    }
    *((void *)v16 + 42_Block_object_dispose(&STACK[0x380], 8) = 0;
    ++v14;
  }
  while (v14 != 2);
}

SCNMTLRenderCommandEncoder *SCNMTLRenderCommandEncoder::applyChangedStates(SCNMTLRenderCommandEncoder *this)
{
  uint64_t v1 = this;
  if (this->var5)
  {
    this->var5 = 0;
    this = (SCNMTLRenderCommandEncoder *)[(id)this->var24[1] setFrontFacingWinding:this->var1];
  }
  if (v1->var7)
  {
    v1->var7 = 0;
    this = (SCNMTLRenderCommandEncoder *)[(id)v1->var24[1] setTriangleFillMode:v1->var3];
  }
  if (v1->var6)
  {
    v1->var6 = 0;
    this = (SCNMTLRenderCommandEncoder *)[(id)v1->var24[1] setCullMode:v1->var2];
  }
  if (v1->var8)
  {
    v1->var8 = 0;
    if ((SCNMTLDeviceSupportsDepthClipMode((void *)[(id)v1->var24[1] device]) & 1) == 0)
    {
      uint64_t v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
        SCNMTLRenderCommandEncoder::applyChangedStates(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
    return (SCNMTLRenderCommandEncoder *)[(id)v1->var24[1] setDepthClipMode:v1->var4];
  }
  return this;
}

uint64_t C3DDynamicBatchingSystemGetCurrentBatchNodes(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 + 24;
  uint64_t result = *(void *)(a1 + 24);
  *a2 = *(void *)(v3 + 8);
  return result;
}

uint64_t C3DBlendStatesDefaultOver()
{
  if (C3DBlendStatesDefaultOver_onceToken != -1) {
    dispatch_once(&C3DBlendStatesDefaultOver_onceToken, &__block_literal_global_19_0);
  }
  return C3DBlendStatesDefaultOver_states;
}

void C3DGeometryUntrackNode(uint64_t a1, const void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFSetRef v20 = *(const __CFSet **)(a1 + 88);
  if (!v20 || !CFSetContainsValue(v20, a2))
  {
    __n128 v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
      C3DGeometryUntrackNode_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
    }
  }
  CFArrayRef v29 = *(const __CFArray **)(a1 + 96);
  if (v29)
  {
    CFIndex Count = CFArrayGetCount(v29);
    if (Count >= 1)
    {
      CFIndex v31 = Count;
      for (CFIndex i = 0; i != v31; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        uint64_t v34 = C3DLODGetEntity((uint64_t)ValueAtIndex);
        if (v34) {
          C3DGeometryUntrackNode(v34, a2);
        }
      }
    }
  }
  float v35 = *(__CFSet **)(a1 + 88);
  if (v35) {
    goto LABEL_20;
  }
  float v36 = scn_default_log();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
    C3DGeometryUntrackNode_cold_1(v36, v37, v38, v39, v40, v41, v42, v43);
  }
  float v35 = *(__CFSet **)(a1 + 88);
  if (v35) {
LABEL_20:
  }
    CFSetRemoveValue(v35, a2);
}

void _C3DArrayCFFinalize(uint64_t a1)
{
}

BOOL SCNMatrix4IsIdentity(SCNMatrix4 *m)
{
  long long v1 = *(_OWORD *)&m->m21;
  v4[0] = *(_OWORD *)&m->m11;
  v4[1] = v1;
  long long v2 = *(_OWORD *)&m->m41;
  _OWORD v4[2] = *(_OWORD *)&m->m31;
  v4[3] = v2;
  return memcmp(v4, &SCNMatrix4Identity, 0x40uLL) == 0;
}

uint64_t C3DMaterialCreateCopy(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCopy_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMaterialCreate();
  C3DMaterialCopy(a1, v10);
  return v10;
}

uint64_t C3DMaterialCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  *(unsigned char *)(a2 + 100) = *(unsigned char *)(a1 + 100);
  *(_DWORD *)(a2 + 8_Block_object_dispose(&STACK[0x380], 8) = *(_DWORD *)(a1 + 88);
  *(unsigned char *)(a2 + 93) = *(unsigned char *)(a1 + 93);
  uint64_t v20 = *(void *)(a1 + 64);
  uint64_t v21 = *(void *)(a2 + 64);
  if (v20)
  {
    C3DEffectCommonProfileCopy(v20, v21);
  }
  else if (v21)
  {
    CFRelease(*(CFTypeRef *)(a2 + 64));
    *(void *)(a2 + 64) = 0;
  }
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
  CFStringRef Name = (const __CFString *)C3DMaterialGetName(a1);
  C3DMaterialSetName(a2, Name);
  return __RasterizerStatesDidChange(a2);
}

CFStringRef C3DMaterialSetName(uint64_t a1, CFStringRef theString)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntitySetName(a1, theString);
}

uint64_t C3DMaterialGetName(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetName(a1);
}

void C3DEffectCommonProfileCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  int LightingModel = C3DEffectCommonProfileGetLightingModel(a1);
  C3DEffectCommonProfileSetLightingModel(a2, LightingModel);
  for (uint64_t i = 0; i != 5; ++i)
  {
    int v22 = byte_20B5ED9E0[i];
    float FloatProperty = C3DEffectCommonProfileGetFloatProperty((float *)a1, v22);
    C3DEffectCommonProfileSetFloatProperty(a2, v22, FloatProperty);
  }
  unsigned __int8 v24 = 0;
  do
  {
    uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, (char)v24, 0);
    if (EffectSlot)
    {
      uint64_t v26 = EffectSlot;
      uint64_t v27 = C3DEffectCommonProfileGetEffectSlot(a2, (char)v24, 1);
      C3DEffectSlotCopy(v26, v27);
    }
    unsigned int v28 = v24++;
  }
  while (v28 < 0x10);
  *(_WORD *)(a2 + 194) = *(_WORD *)(a2 + 194) & 0xFFFE | *(_WORD *)(a1 + 194) & 1;
  *(unsigned char *)(a2 + 193) = *(unsigned char *)(a1 + 193);
  C3DEffectCommonProfileSetTransparencyMode(a2, *(unsigned __int8 *)(a1 + 180));
  *(_WORD *)(a2 + 194) = *(_WORD *)(a2 + 194) & 0xFFEF | *(_WORD *)(a1 + 194) & 0x10;
}

void C3DEffectSlotCopy(uint64_t a1, uint64_t a2)
{
  C3DEffectSlotSetColor(a2, (float *)(a1 + 16));
  uint64_t Image = (const void *)C3DEffectSlotGetImage(a1);
  C3DEffectSlotSetImage(a2, Image);
  uint64_t ImageProxy = (const void *)C3DEffectSlotGetImageProxy(a1);
  C3DEffectSlotSetImageProxy(a2, ImageProxy);
  C3DEffectSlotSetTextureSampler(a2, *(CFTypeRef *)(a1 + 56));
  if (*(void *)(a1 + 64))
  {
    uint64_t v6 = C3DMalloc(0x40uLL);
    *(void *)(a2 + 64) = v6;
    uint64_t v7 = *(_OWORD **)(a1 + 64);
    long long v9 = v7[2];
    long long v8 = v7[3];
    long long v10 = v7[1];
    *uint64_t v6 = *v7;
    v6[1] = v10;
    v6[2] = v9;
    v6[3] = v8;
  }
  uint64_t Texture = (const void *)C3DEffectSlotGetTexture(a1);
  C3DEffectSlotSetTexture(a2, Texture);
  MTLuint64_t Texture = (const void *)C3DEffectSlotGetMTLTexture(a1);
  C3DEffectSlotSetMTLTexture(a2, MTLTexture);
  uint64_t UVSet = C3DEffectSlotGetUVSet(a1);
  C3DEffectSlotSetUVSet(a2, UVSet);
  int TextureComponents = C3DEffectSlotGetTextureComponents(a1);
  C3DEffectSlotSetTextureComponents(a2, TextureComponents);
  float Intensity = C3DEffectSlotGetIntensity(a1);
  C3DEffectSlotSetIntensity(a2, Intensity);
  *(_WORD *)(a2 + 4_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(a2 + 48) & 0xFDFF | *(_WORD *)(a1 + 48) & 0x200;
}

void C3DEffectSlotSetTextureComponents(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned int v12 = *(unsigned __int16 *)(a1 + 48);
  if (((v12 >> 11) & 0xF) != a2)
  {
    *(_WORD *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = v12 & 0x87FF | ((a2 & 0xF) << 11);
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

void C3DEffectSlotSetTexture(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (cf || *(_WORD *)(a1 + 48) == 1)
  {
    *(_WORD *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(a1 + 48) & 0xFF00 | 1;
    CFTypeRef v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 40) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 40) = v13;
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

void C3DEffectSlotSetImageProxy(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (cf || *(_WORD *)(a1 + 48) == 2)
  {
    *(_WORD *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(a1 + 48) & 0xFF00 | 2;
    CFTypeRef v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 40) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 40) = v13;
      uint64_t CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
      if (CommonProfile) {
        *(_WORD *)(CommonProfile + 196) &= 0xE000u;
      }
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

void C3DEffectSlotSetImage(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (cf || !*(_WORD *)(a1 + 48))
  {
    *(_WORD *)(a1 + 48) &= 0xFF00u;
    CFTypeRef v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 40) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 40) = v13;
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

uint64_t C3DEffectSlotGetEffectProperty(uint64_t a1)
{
  return *(char *)(a1 + 50);
}

unint64_t C3DColor4WithCGColor(CGColor *a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DCGColorGetComponentsInColorSpace_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!C3DLinearRenderingIsEnabled() || (a2 & 1) != 0) {
    goto LABEL_20;
  }
  if (C3DWideGamutIsUsed())
  {
    if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
    }
    CFTypeRef v12 = &C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
  }
  else
  {
    if (C3DColorSpaceLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_4);
    }
    CFTypeRef v12 = &C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
  }
  CFTypeRef v13 = (CGColorSpace *)*v12;
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_38);
    }
  }
  else if (C3DGetColorTransformToLinearSRGB_onceToken != -1)
  {
    dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_41);
  }
  if (CGColorGetColorSpace(a1) == v13) {
LABEL_20:
  }
    uint64_t v14 = CGColorRetain(a1);
  else {
    uint64_t v14 = (CGColor *)CGColorTransformConvertColor();
  }
  uint64_t v15 = v14;
  size_t NumberOfComponents = CGColorGetNumberOfComponents(v14);
  Components = CGColorGetComponents(v15);
  if (NumberOfComponents >= 4) {
    goto LABEL_24;
  }
  if (NumberOfComponents == 2)
  {
LABEL_26:
    double v20 = *Components;
    *(float *)&double v20 = *Components;
    float v22 = *(float *)&v20;
    unsigned __int32 v19 = vdup_lane_s32(*(int32x2_t *)&v20, 0).u32[0];
    goto LABEL_27;
  }
  if (NumberOfComponents < 3)
  {
    if (!NumberOfComponents)
    {
      unsigned __int32 v19 = 0;
      float v22 = 0.0;
      goto LABEL_27;
    }
    goto LABEL_26;
  }
LABEL_24:
  float v18 = *Components;
  float v22 = v18;
  unsigned __int32 v19 = vcvt_f32_f64(*(float64x2_t *)(Components + 1)).u32[0];
LABEL_27:
  CGColorRelease(v15);
  return LODWORD(v22) | ((unint64_t)v19 << 32);
}

uint64_t C3DColor4FromRGBCFColor(const void *a1, uint64_t a2)
{
  uint64_t v3 = (void *)scn_NSColorFromCGColorIfApplicable(a1);

  return objc_msgSend(v3, "scn_C3DColorIgnoringColorSpace:success:", a2, 0);
}

uint64_t C3DEffectPropertyGetSemanticForColorIsRawFloatValue(unsigned int a1)
{
  return (a1 < 0x10) & (0x8DA0u >> a1);
}

void C3DEffectSlotSetMTLTexture(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (cf || *(_WORD *)(a1 + 48) == 3)
  {
    *(_WORD *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(a1 + 48) & 0xFE00 | 3;
    CFTypeRef v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 40) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 40) = v13;
    }
    __PostParentDidChangeNotification(a1, 1, 1);
  }
}

void C3DEffectSlotSetIntensity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 72) != a2)
  {
    *(float *)(a1 + 72) = a2;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

void C3DEffectSlotSetUVSet(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 76) != a2)
  {
    *(_DWORD *)(a1 + 76) = a2;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

float C3DEffectSlotGetIntensity(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 72);
}

uint64_t C3DEffectSlotGetUVSet(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(_DWORD *)(a1 + 76);
  if (v10 == -2)
  {
    if (*(unsigned char *)(a1 + 50) == 4) {
      return -1;
    }
    else {
      return 0;
    }
  }
  return v10;
}

uint64_t C3DEffectSlotGetTextureComponents(uint64_t a1)
{
  if (!a1)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 48) >> 11) & 0xF;
}

void C3DEffectCommonProfileSetTransparencyMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 180) != a2)
  {
    *(_WORD *)(a1 + 194) &= ~0x80u;
    *(unsigned char *)(a1 + 180) = a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

void C3DAnimationManagerExecRemoveAnimation(uint64_t a1, void *key, void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  _C3DAnimationManagerRemoveAnimationForKey(a1, key, a3);
}

void _C3DAnimationManagerRemoveAnimationForKey(uint64_t a1, void *key, void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    float v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    CFDictionaryRef v31 = AnimationPerKeyDictionaryForObject;
    CFRetain(AnimationPerKeyDictionaryForObject);
    CFNumberRef Value = CFDictionaryGetValue(v31, a3);
    if (Value)
    {
      float v33 = Value;
      CFRetain(Value);
      C3DAnimationNodeSetOwner((uint64_t)v33, 0);
      _C3DAnimationManagerRemoveAnimationsForKey(a1, key, a3, v31);
      CFRelease(v33);
    }
    CFRelease(v31);
  }
}

const void *_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(uint64_t a1, void *key, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), key);
  if (Value) {
    BOOL v23 = 1;
  }
  else {
    BOOL v23 = a3 == 0;
  }
  if (!v23)
  {
    CFNumberRef Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), key, Value);
    CFRelease(Value);
  }
  return Value;
}

__n128 C3DRasterizerStatesGetDesc@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRasterizerStatesGetDesc_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 16);
  __n128 result = *(__n128 *)(a1 + 28);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

uint64_t C3DComparisonFuncToMTLCompareFunctionReverse(unsigned int a1)
{
  if (a1 >= 8)
  {
    long long v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DComparisonFuncToMTLCompareFunction_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_ComparisonFuncReverse[a1];
}

void sub_20B2872E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

float C3DEffectCommonProfileGetIntensity(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot) {
    return *(float *)(EffectSlot + 72);
  }
  else {
    return 1.0;
  }
}

uint64_t C3DEffectCommonProfileGetColorModulatedByIntensity(uint64_t a1, int a2)
{
  float32x4_t v9 = *(float32x4_t *)C3DEffectCommonProfileGetColor(a1, a2);
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot && C3DEffectSlotHasImageOrTexture(EffectSlot)) {
    C3DColor4Make(v9.f32, 1.0, 1.0, 1.0, 1.0);
  }
  float Intensity = C3DEffectCommonProfileGetIntensity(a1, a2);
  if (Intensity != 1.0)
  {
    if (a2 == 6)
    {
      *(float *)v6.i32 = 1.0 - Intensity;
      *(float32x2_t *)v9.f32 = vmla_n_f32((float32x2_t)vdup_lane_s32(v6, 0), *(float32x2_t *)v9.f32, Intensity);
      float v7 = (float)(1.0 - Intensity) + (float)(Intensity * v9.f32[2]);
    }
    else
    {
      if (a2 == 5)
      {
        float32x4_t v9 = vmulq_n_f32(v9, Intensity);
        return v9.i64[0];
      }
      *(float32x2_t *)v9.f32 = vmul_n_f32(*(float32x2_t *)v9.f32, Intensity);
      float v7 = Intensity * v9.f32[2];
    }
    v9.f32[2] = v7;
  }
  return v9.i64[0];
}

float C3DEffectCommonProfileGetColorLuminanceModulatedByIntensity(uint64_t a1, int a2)
{
  LODWORD(result) = C3DEffectCommonProfileGetColorModulatedByIntensity(a1, a2);
  return result;
}

uint64_t C3DEffectCommonProfileIsUsingAmbientOcclusion(uint64_t a1)
{
  return C3DEffectCommonProfileContainsContentForEffectProperty(a1, 8);
}

uint64_t C3DEntityGetValueStorageModificationCount(void *a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)a1[5];
  if (v2 && (CFNumberRef Value = CFDictionaryGetValue(v2, @"_kvc")) != 0) {
    uint64_t Timestamp = C3DKeyValueStoreGetTimestamp((uint64_t)Value);
  }
  else {
    uint64_t Timestamp = 0;
  }
  CFTypeID v5 = CFGetTypeID(a1);
  if (v5 == C3DMaterialGetTypeID()) {
    return C3DMaterialGetValueStorageModificationCount((uint64_t)a1) + Timestamp;
  }
  return Timestamp;
}

uint64_t C3DMaterialGetValueStorageModificationCount(uint64_t a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 96);
}

CFDictionaryRef C3DEntityEnumerateKeyValuesWithBlock(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"_kvc");
    if (result) {
      return (const __CFDictionary *)C3DKeyValueStoreEnumerate((uint64_t)result, a2);
    }
  }
  return result;
}

uint64_t SCNMTLRenderCommandEncoder::setFragmentBuffer(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = result + 16 * a4;
  if (*(void *)(v4 + 1728) == a2)
  {
    if (*(void *)(v4 + 1736) != a3)
    {
      *(void *)(v4 + 1736) = a3;
      return [*(id *)(result + 3392) setFragmentBufferOffset:a3 atIndex:a4];
    }
  }
  else
  {
    *(void *)(v4 + 172_Block_object_dispose(&STACK[0x380], 8) = a2;
    *(void *)(v4 + 1736) = a3;
    return objc_msgSend(*(id *)(result + 3392), "setFragmentBuffer:offset:atIndex:", a2);
  }
  return result;
}

uint64_t SCNResourceRegistrySetup(uint64_t *a1, int a2)
{
  if (a2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 258;
  }
  uint64_t result = [objc_alloc(MEMORY[0x263F08968]) initWithKeyOptions:v3 valueOptions:0 capacity:100];
  *a1 = result;
  return result;
}

void C3DEntitySetShaderModifiers(CFTypeRef *a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  _C3DEntitySetAttribute(a1, @"kShaderModifiers", a2, 1);
  CFTypeID v12 = CFGetTypeID(a1);
  if (CFTypeIsC3DGeometry(v12))
  {
    _C3DGeometryShadingDidUpdate(a1);
  }
  else if (v12 == C3DMaterialGetTypeID())
  {
    _C3DMaterialShadingDidUpdate(a1);
  }
}

void _C3DMaterialShadingDidUpdate(void *a1)
{
  uint64_t v2 = C3DGetScene(a1);
  C3DScenePostPipelineEvent(v2, 3, a1, 0);

  C3DMaterialTouchValueStorageModificationCount((uint64_t)a1);
}

uint64_t _transposeSkinnerToClone(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if ([a1 skinner])
  {
    uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "skinner"), "skeleton");
    if (v6 && (uint64_t Clone = _findClone(v6, a2, a3)) != 0)
    {
      objc_msgSend((id)objc_msgSend(a1, "skinner"), "setSkeleton:", Clone);
    }
    else
    {
      uint64_t v8 = (void *)[MEMORY[0x263EFF980] array];
      long long v25 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      uint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "skinner"), "bones");
      uint64_t v10 = [v9 countByEnumeratingWithState:&v25 objects:v30 count:16];
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = *(void *)v26;
LABEL_7:
        uint64_t v13 = 0;
        while (1)
        {
          if (*(void *)v26 != v12) {
            objc_enumerationMutation(v9);
          }
          uint64_t v14 = *(void **)(*((void *)&v25 + 1) + 8 * v13);
          if (![v14 name]) {
            break;
          }
          uint64_t v15 = objc_msgSend(a3, "childNodeWithName:", objc_msgSend(v14, "name"));
          if (!v15) {
            break;
          }
          [v8 addObject:v15];
          if (v11 == ++v13)
          {
            uint64_t v11 = [v9 countByEnumeratingWithState:&v25 objects:v30 count:16];
            if (v11) {
              goto LABEL_7;
            }
            goto LABEL_14;
          }
        }
      }
      else
      {
LABEL_14:
        objc_msgSend((id)objc_msgSend(a1, "skinner"), "setBones:", v8);
      }
    }
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v16 = objc_msgSend(a1, "childNodes", 0);
  uint64_t result = [v16 countByEnumeratingWithState:&v21 objects:v29 count:16];
  if (result)
  {
    uint64_t v18 = result;
    uint64_t v19 = *(void *)v22;
    do
    {
      uint64_t v20 = 0;
      do
      {
        if (*(void *)v22 != v19) {
          objc_enumerationMutation(v16);
        }
        _transposeSkinnerToClone(*(void *)(*((void *)&v21 + 1) + 8 * v20++), a2, a3);
      }
      while (v18 != v20);
      uint64_t result = [v16 countByEnumeratingWithState:&v21 objects:v29 count:16];
      uint64_t v18 = result;
    }
    while (result);
  }
  return result;
}

void _copyAnimations(void *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  [a2 _copyAnimationsFrom:a1];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v4 = objc_msgSend(a1, "actionKeys", 0);
  uint64_t v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v13;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend(a2, "runAction:forKey:", objc_msgSend(a1, "actionForKey:", *(void *)(*((void *)&v12 + 1) + 8 * v8)), *(void *)(*((void *)&v12 + 1) + 8 * v8));
        ++v8;
      }
      while (v6 != v8);
      uint64_t v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v6);
  }
  uint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "childNodes"), "count");
  if (objc_msgSend((id)objc_msgSend(a2, "childNodes"), "count") == v9)
  {
    if (v9)
    {
      for (uint64_t i = 0; i != v9; ++i)
        _copyAnimations(objc_msgSend((id)objc_msgSend(a1, "childNodes"), "objectAtIndex:", i), objc_msgSend((id)objc_msgSend(a2, "childNodes"), "objectAtIndex:", i));
    }
  }
  else
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      _copyAnimations_cold_1();
    }
  }
}

void _C3DTransactionBegin(uint64_t a1, float a2)
{
  int v2 = a1;
  uint64_t Stack = C3DTransactionGetStack(a1);
  if (CFArrayGetCount(*(CFArrayRef *)(Stack + 16)) < 1)
  {
    CFStringRef ValueAtIndex = 0;
  }
  else
  {
    CFArrayRef v5 = *(const __CFArray **)(Stack + 16);
    CFIndex Count = CFArrayGetCount(v5);
    CFStringRef ValueAtIndex = (__CFArray **)CFArrayGetValueAtIndex(v5, Count - 1);
  }
  if (C3DTransactionGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTransactionGetTypeID_onceToken, &__block_literal_global_112);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTransactionGetTypeID_typeID, 0x48uLL);
  uint64_t v9 = Instance;
  *(double *)(Instance + 32) = a2;
  if (v2) {
    char v10 = 2;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(Instance + 60) = *(unsigned char *)(Instance + 60) & 0xFD | v10;
  if (ValueAtIndex)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    *(void *)(v9 + 72) = CFRetain(ValueAtIndex);
    CFSetRef Mutable = ValueAtIndex[8];
    if (!Mutable)
    {
      CFSetRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
      ValueAtIndex[8] = Mutable;
    }
    CFArrayAppendValue(Mutable, (const void *)v9);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if ((*((unsigned char *)ValueAtIndex + 60) & 2) == 0)
    {
      *(void *)(v9 + 32) = ValueAtIndex[4];
      *(unsigned char *)(v9 + 60) = *(unsigned char *)(v9 + 60) & 0xFB | *((unsigned char *)ValueAtIndex + 60) & 4;
      long long v12 = *(__CFArray **)(v9 + 24);
      long long v13 = ValueAtIndex[3];
      if (v12 != v13)
      {
        if (v12)
        {
          CFRelease(*(CFTypeRef *)(v9 + 24));
          *(void *)(v9 + 24) = 0;
          long long v13 = ValueAtIndex[3];
        }
        if (v13) {
          long long v13 = (__CFArray *)CFRetain(v13);
        }
        *(void *)(v9 + 24) = v13;
      }
    }
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(Stack + 16), (const void *)v9);

  CFRelease((CFTypeRef)v9);
}

void C3DTransactionSetImmediateMode(int a1)
{
  Current = C3DTransactionGetCurrent();
  if (a1) {
    char v3 = 8;
  }
  else {
    char v3 = 0;
  }
  Current[60] = Current[60] & 0xF7 | v3;
  if (a1) {
    gAtomicTime = CACurrentMediaTime();
  }
}

void C3DTransactionCommit(char a1)
{
  uint64_t Stack = C3DTransactionGetStack();
  CFArrayRef v3 = (const __CFArray *)*((void *)Stack + 2);
  CFIndex Count = CFArrayGetCount(v3);
  CFStringRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(v3, Count - 1);
  if (ValueAtIndex[5] == 0.0)
  {
    uint64_t v7 = (uint64_t)ValueAtIndex;
    CFTimeInterval v8 = CACurrentMediaTime();
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    *(CFTimeInterval *)(v7 + 40) = v8;
    if (a1)
    {
      *(unsigned char *)(v7 + 60) |= 1u;
      C3DTransactionTestForDidComplete(v7);
    }
    else
    {
      appended = C3DCommandQueueAppendNewCommand((char **)Stack + 4);
      *((void *)appended + 4) = CFRetain((CFTypeRef)v7);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    char v10 = (CFArrayRef *)C3DTransactionGetStack();
    CFIndex v11 = CFArrayGetCount(v10[2]);
    if (v11 <= 1)
    {
      long long v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
        C3DTransactionCommit_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
      }
      uint64_t v20 = scn_default_log();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        C3DTransactionCommit_cold_2();
      }
    }
    else
    {
      CFArrayRemoveValueAtIndex(v10[2], v11 - 1);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (CFArrayGetCount(*((CFArrayRef *)Stack + 2)) <= 1 && (a1 & 1) == 0) {
      C3DTransactionFlush();
    }
  }
  else
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      C3DTransactionCommit_cold_1();
    }
  }
}

void C3DTransactionTestForDidComplete(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 60) & 1) != 0 && !*(_DWORD *)(a1 + 56))
  {
    CFArrayRef v10 = *(const __CFArray **)(a1 + 64);
    if (!v10 || !CFArrayGetCount(v10))
    {
      CFRetain((CFTypeRef)a1);
      CFIndex v11 = *(CFArrayRef **)(a1 + 72);
      if (v11)
      {
        CFRetain(*(CFTypeRef *)(a1 + 72));
        if (!v11[8])
        {
          long long v12 = scn_default_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
            C3DTransactionTestForDidComplete_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
          }
        }
        v31.CFIndex length = CFArrayGetCount(v11[8]);
        v31.location = 0;
        FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v11[8], v31, (const void *)a1);
        if (FirstIndexOfValue == -1)
        {
          CFIndex v30 = scn_default_log();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            C3DTransactionTestForDidComplete_cold_1();
          }
        }
        else
        {
          CFIndex v21 = FirstIndexOfValue;
          CFRetain((CFTypeRef)a1);
          CFArrayRemoveValueAtIndex(v11[8], v21);
          if (*(CFArrayRef **)(a1 + 72) != v11)
          {
            long long v22 = scn_default_log();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
              C3DTransactionTestForDidComplete_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
            }
          }
          CFRelease(*(CFTypeRef *)(a1 + 72));
          *(void *)(a1 + 72) = 0;
          CFRelease((CFTypeRef)a1);
        }
        C3DTransactionDidComplete(a1);
        if (!CFArrayGetCount(v11[8])) {
          C3DTransactionTestForDidComplete(v11);
        }
        CFRelease(v11);
      }
      else
      {
        C3DTransactionDidComplete(a1);
      }
      CFRelease((CFTypeRef)a1);
    }
  }
}

void C3DTransactionDidComplete(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef v10 = *(void **)(a1 + 80);
  if (v10) {
    dispatch_async(MEMORY[0x263EF83A0], v10);
  }
}

void C3DTransactionBegin()
{
}

void C3DEntityCopyTo(uint64_t a1, CFTypeRef *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  long long v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  ID = (const void *)C3DEntityGetID(a1);
  C3DEntitySetID((uint64_t)a2, ID);
  CFStringRef Name = (const __CFString *)C3DEntityGetName(a1);
  C3DEntitySetName((uint64_t)a2, Name);
  CFDictionaryRef Attributes = (const __CFDictionary *)C3DEntityGetAttributes(a1);
  _C3DEntitySetAttributes((uint64_t)a2, Attributes);
  _C3DEntitySetAttribute(a2, @"_kvc", 0, 1);
  _C3DEntitySetAttribute(a2, @"kAnimationsKey", 0, 1);
}

void _C3DEntitySetAttribute(CFTypeRef *a1, void *key, const __CFDictionary *a3, int a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DEntityGetAttribute_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (C3DEntityGetAttribute((uint64_t)a1, key) != a3)
  {
    CFSetRef Mutable = (__CFDictionary *)a1[5];
    if (!Mutable)
    {
      CFSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      a1[5] = Mutable;
    }
    if (a3)
    {
      CFDictionarySetValue(Mutable, key, a3);
    }
    else
    {
      CFDictionaryRemoveValue(Mutable, key);
      if (!CFDictionaryGetCount((CFDictionaryRef)a1[5]))
      {
        CFRelease(a1[5]);
        a1[5] = 0;
      }
    }
    if (a4)
    {
      Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)key, 1u);
    }
  }
}

CFTypeRef C3DEntitySetID(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 24) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 24) = result;
  }
  return result;
}

uint64_t C3DEntityGetID(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void _C3DEntitySetAttributes(uint64_t a1, CFDictionaryRef theDict)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(const void **)(a1 + 40);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 40) = 0;
  }
  if (theDict)
  {
    if (CFDictionaryGetCount(theDict)) {
      *(void *)(a1 + 40) = CFDictionaryCreateMutableCopy(0, 0, theDict);
    }
  }
}

uint64_t C3DNodeSetIsGizmo(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 0x20000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFDFFFF | v2;
  return result;
}

uint64_t C3DNodeIsGizmo(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 222) >> 1) & 1;
}

uint64_t _C3DCFArrayApplyBlock(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  ++*a2;
  return (*(uint64_t (**)(void))(v2 + 16))();
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

__n128 __Block_byref_object_copy__4(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

__n128 __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
}

__IOSurface *SCNMTLEnsureIOSurfaceBackingBufferValidity(__IOSurface *result, id *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    uint64_t v5 = a3;
    do
    {
      __n128 result = (__IOSurface *)[*a2 iosurface];
      if (result)
      {
        uint64_t v6 = result;
        IOSurfaceIncrementUseCount(result);
        v7[0] = MEMORY[0x263EF8330];
        v7[1] = 3221225472;
        v7[2] = __SCNMTLEnsureIOSurfaceBackingBufferValidity_block_invoke;
        v7[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v7[4] = v6;
        __n128 result = (__IOSurface *)[(__IOSurface *)v4 addCompletedHandler:v7];
      }
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t CreateProbeArrayResourceIfNeeded(C3D::Pass *a1, uint64_t a2)
{
  float32x4_t v68 = a1;
  uint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v4);
  uint64_t Scene = C3DEngineContextGetScene(v4);
  LightingSysteCFIndex m = C3DSceneGetLightingSystem(Scene);
  uint64_t v7 = *(C3D::RenderGraphResourceManager **)(v3 + 128);
  -[SCNMTLRenderContext device](RenderContext);
  int v8 = SCNMTLDeviceSupportsColorRenderingInPixelFormat();
  -[SCNMTLRenderContext device](RenderContext);
  int IsWritable = SCNMTLPixelFormatIsWritable();
  uint64_t v10 = 115;
  if ((IsWritable & v8) != 0) {
    uint64_t v10 = 93;
  }
  uint64_t v50 = v10;
  if ((-[SCNMTLRenderContext features](RenderContext) & 0x100) != 0) {
    int v11 = 256;
  }
  else {
    int v11 = 128;
  }
  int v51 = v11;
  ReflectionProbesCFIndex Count = C3DLightingSystemGetReflectionProbesCount(LightingSystem);
  if (ReflectionProbesCount
    || (uint64_t v18 = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0)) != 0
    && ((uint64_t v19 = v18, C3DEffectSlotHasImageOrTexture(v18)) || C3DEffectSlotHasPrecomputedLightingEnvironment(v19))
    || C3DEngineContextGetAllowsDefaultLightingEnvironmentFallback(v4))
  {
    uint64_t v47 = a2;
    uint64_t v13 = C3D::RenderGraphResourceManager::get(v7, LightingSystem);
    uint64_t v14 = v13;
    uint64_t v48 = LightingSystem;
    uint64_t v45 = v4;
    if (!v13
      || (uint64_t v15 = v13 + 48, !*(void *)(v14 + 48))
      || [(id)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v15) arrayLength] != ReflectionProbesCount + 1)
    {
      operator new();
    }
    uint64_t v16 = v14;
    unsigned int v17 = ReflectionProbesCount + 1;
    uint64_t v20 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v14 + 48);
    PersistentResource = (C3D::RefCountedResource *)C3D::RenderGraph::createPersistentResource(v3, v20);
    int LightingEnvironmentTimeStamp = C3DSceneGetLightingEnvironmentTimeStamp(Scene);
    if (*(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](v14 + 16, 0) == LightingEnvironmentTimeStamp)
    {
      BOOL HasImageOrTexture = 0;
      uint64_t v24 = a1;
      uint64_t v25 = v47;
      int v26 = v51;
LABEL_31:
      v52[0] = MEMORY[0x263EF8330];
      v52[1] = 3221225472;
      v52[2] = __CreateProbeArrayResourceIfNeeded_block_invoke;
      v52[3] = &__block_descriptor_97_e53_v36__0I8_____C3DNode_12_____C3DLight_20________3___28l;
      int v53 = v26;
      uint64_t v54 = v50;
      BOOL v55 = HasImageOrTexture;
      char v61 = 0;
      uint64_t v56 = v14;
      float32x4_t v57 = v24;
      uint64_t v58 = v25;
      uint64_t v59 = v14;
      uint64_t v60 = PersistentResource;
      C3DLightingSystemEnumerateRadianceProbes(v48, (uint64_t)v52);
      return v16;
    }
    LightingEnvironmentuint64_t EffectSlot = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0);
    uint64_t v28 = LightingEnvironmentEffectSlot;
    if (LightingEnvironmentEffectSlot
      && ((BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(LightingEnvironmentEffectSlot),
           BOOL HasPrecomputedLightingEnvironment = C3DEffectSlotHasPrecomputedLightingEnvironment(v28),
           HasImageOrTexture)
       || HasPrecomputedLightingEnvironment))
    {
      if (!HasImageOrTexture)
      {
        uint64_t v25 = v47;
        goto LABEL_29;
      }
      int v26 = v51;
      LODWORD(v66) = v51;
      *((void *)&v66 + 1) = v50;
      BOOL HasImageOrTexture = 1;
      int v67 = 1;
      uint64_t v25 = v47;
      C3D::ComputeProbeFromEnvironmentTexture(a1, v47, PersistentResource, 0, v28, &v66);
    }
    else
    {
      AllowsDefaultLightingEnvironmentFallbacCFIndex k = C3DEngineContextGetAllowsDefaultLightingEnvironmentFallback(v45);
      if (v17 <= 1 && AllowsDefaultLightingEnvironmentFallback)
      {
        id v31 = (id)[(id)-[SCNMTLRenderContext resourceManager](RenderContext) defaultLightingEnvironmentRadianceTexture];
        float32x4_t v32 = (C3D::RefCountedResource *)C3D::RenderGraph::createPersistentResource(v3, (uint64_t)v31);
        long long v64 = 0uLL;
        uint64_t v65 = 0;
        float v33 = C3D::RenderGraph::createPass<C3D::CopyTextureComputePass,C3D::Pass *&,C3D::CopyTextureComputePass::Parameters>(v3, &v68, (const Parameters *)&v64);
        uint64_t v34 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v33);
        uint64_t v35 = C3D::PassDescriptor::inputAtIndex(v34, 0);
        *(_WORD *)(v35 + 66) |= 0x100u;
        float v36 = (C3D::PassResource *)C3D::Pass::resource(v33);
        C3D::PassResource::setInputAtIndex(v36, v32, 0);
        uint64_t v37 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v33);
        uint64_t v38 = C3D::PassDescriptor::outputAtIndex(v37, 0);
        *(_WORD *)(v38 + 66) |= 0x100u;
        SCNMTLTextureDescFromMTLTexture(*(void **)PersistentResource, (uint64_t)&v64);
        uint64_t v39 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v33);
        uint64_t v40 = C3D::PassDescriptor::outputAtIndex(v39, 0);
        *(_OWORD *)(v40 + 16) = v64;
        *(_DWORD *)(v40 + 32) = v65;
        uint64_t v41 = (C3D::PassResource *)C3D::Pass::resource(v33);
        C3D::PassResource::setOutputAtIndex(v41, PersistentResource, 0);
        uint64_t v42 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v33);
        uint64_t v43 = C3D::PassDescriptor::outputAtIndex(v42, 0);
        uint64_t v25 = v47;
        C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(v47, v43);
        C3D::Pass::addDependency(v68, v33);
        BOOL HasImageOrTexture = 0;
LABEL_29:
        int v26 = v51;
        goto LABEL_30;
      }
      int v26 = v51;
      LODWORD(v62) = v51;
      *((void *)&v62 + 1) = v50;
      int v63 = 0;
      uint64_t v25 = v47;
      C3D::ComputeProbeFromEnvironmentTexture(a1, v47, PersistentResource, 0, v28, &v62);
      BOOL HasImageOrTexture = 0;
    }
LABEL_30:
    *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](v14 + 16, 0) = LightingEnvironmentTimeStamp;
    *(void *)C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](v14 + 32, 0) = 0;
    uint64_t v24 = v68;
    goto LABEL_31;
  }
  return 0;
}

CFDictionaryRef __ShouldForceLighting(uint64_t a1)
{
  uint64_t Scene = C3DEngineContextGetScene(a1);
  LightingEnvironmentuint64_t EffectSlot = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0);
  if (LightingEnvironmentEffectSlot)
  {
    uint64_t v4 = LightingEnvironmentEffectSlot;
    if (C3DEffectSlotHasImageOrTexture(LightingEnvironmentEffectSlot)
      || C3DEffectSlotHasPrecomputedLightingEnvironment(v4))
    {
      return 0;
    }
  }
  if (C3DSceneGetAllowsDefaultLightingEnvironmentFallback(Scene)) {
    return 0;
  }
  uint64_t v6 = (CFTypeRef *)MEMORY[0x263EFFB40];
  if (Scene)
  {
    CFArrayRef Attribute = (const void *)C3DSceneGetAttribute(Scene, @"triggerOptionsForRealtimeViewer");
    if (!Attribute) {
      CFArrayRef Attribute = (const void *)*MEMORY[0x263EFFB38];
    }
    CFTypeRef v8 = *v6;
    int v9 = CFEqual(Attribute, *v6);
    uint64_t v10 = v8;
    if (v9)
    {
      if (!v8) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v10 = (const void *)C3DSceneGetAttribute(Scene, @"defaultLight");
      if (!v10) {
        goto LABEL_16;
      }
    }
    if (CFEqual(v10, v8)) {
      return (const __CFDictionary *)1;
    }
  }
LABEL_16:
  CFDictionaryRef result = C3DEngineContextGetRenderingOptionForKey(a1, @"defaultLight");
  if (result) {
    return (const __CFDictionary *)(CFEqual(result, *v6) != 0);
  }
  return result;
}

void __HandleNodeNotification(_DWORD *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v7 = a3[1];
  if (a2 != 1)
  {
    CFTypeRef v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      __HandleNodeNotification_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      if ((a2 & 0x80000) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  if ((a2 & 0x80000) != 0)
  {
LABEL_4:
    C3DEnginePipelineRemoveNodeFromRendering(v6, (uint64_t)a1);
    C3DEnginePipelineAddNodeToRendering(v6, v7, a1);
  }
LABEL_5:
  if ((a2 & 0x100000) != 0)
  {
    uint64_t v16 = C3DGetScene(a1);
    if (C3DNodeHasCamera((uint64_t)a1)) {
      C3DEngineContextSetDefaultPointOfView(a3[1], 0);
    }
    if (v16 == C3DEngineContextGetScene(a3[1]))
    {
      C3DEnginePipelineAddNodeToRendering(v6, v7, a1);
      return;
    }
  }
  if ((a2 & 0x3F000) == 0) {
    goto LABEL_16;
  }
  if ((a2 & 0x1000) != 0)
  {
    C3DEnginePipelineSyncNodeAttribute(v6, a1, @"kMeshKey", (uint64_t)a3);
    if ((a2 & 0x2000) == 0)
    {
LABEL_12:
      if ((a2 & 0x4000) == 0) {
        goto LABEL_13;
      }
LABEL_20:
      C3DEnginePipelineSyncNodeAttribute(v6, a1, @"kLightKey", (uint64_t)a3);
      if ((a2 & 0x20000) == 0)
      {
LABEL_14:
        if ((a2 & 0x8000) == 0) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      goto LABEL_21;
    }
  }
  else if ((a2 & 0x2000) == 0)
  {
    goto LABEL_12;
  }
  C3DEnginePipelineSyncNodeAttribute(v6, a1, @"kCameraKey", (uint64_t)a3);
  C3DEngineContextSetDefaultPointOfView(a3[1], 0);
  if ((a2 & 0x4000) != 0) {
    goto LABEL_20;
  }
LABEL_13:
  if ((a2 & 0x20000) == 0) {
    goto LABEL_14;
  }
LABEL_21:
  C3DEnginePipelineSyncNodeAttribute(v6, a1, @"kDeformerStackKey", (uint64_t)a3);
  if ((a2 & 0x8000) != 0) {
LABEL_15:
  }
    C3DEnginePipelineSyncNodeAttribute(v6, a1, @"rendererDelegate", (uint64_t)a3);
LABEL_16:
  int v17 = (a2 >> 9) & 4 | (a2 >> 7) & 8;
  if (v17) {
    C3DEnginePipelineUpdateNodeRendererElements(v6, (uint64_t)a1, v17);
  }
}

uint64_t C3DEngineContextGetScene(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

uint64_t C3DNodeHasCamera(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 221) >> 2) & 1;
}

uint64_t __TrackRenderNodeDependencies(uint64_t a1, const void *a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DNodeGetLight((uint64_t)a2)) {
    C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, @"kLightKey");
  }
  if (C3DNodeGetCamera((uint64_t)a2)) {
    C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, @"kCameraKey");
  }
  uint64_t result = C3DNodeGetDeformerStack((uint64_t)a2);
  if (result) {
    return C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, @"kDeformerStackKey");
  }
  return result;
}

CFDictionaryRef C3DNodeGetCamera(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 4) != 0) {
    return C3DEntityGetAttribute(a1, @"kCameraKey");
  }
  else {
    return 0;
  }
}

uint64_t C3DSceneGetLightingEnvironmentEffectSlot(uint64_t a1, int a2)
{
  if (a2 && !*(void *)(a1 + 312))
  {
    uint64_t v3 = C3DEffectSlotCreate(a1, 25);
    *(void *)(a1 + 312) = v3;
    uint64_t v4 = (const void *)C3DTextureSamplerBilinearMipMapClampNoAnisotropy();
    C3DEffectSlotSetTextureSampler(v3, v4);
  }
  return *(void *)(a1 + 312);
}

BOOL C3DEffectSlotHasPrecomputedLightingEnvironment(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEffectSlotGetPrecomputedLightingEnvironment(a1) != 0;
}

uint64_t C3DEffectSlotGetPrecomputedLightingEnvironment(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 48) == 4) {
    return *(void *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]();
    }
  }
  return *(void *)(a1 + 8) + 4 * a2;
}

void *SCNMTLTextureDescToMTLTextureDescriptor(unsigned __int16 *a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F12A50]);
  uint64_t v3 = v2;
  if (*a1 <= 1u) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *a1;
  }
  [v2 setWidth:v4];
  if (a1[1] <= 1u) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = a1[1];
  }
  [v3 setHeight:v5];
  if (a1[2] <= 1u) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = a1[2];
  }
  [v3 setDepth:v6];
  if (a1[3] <= 1u) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = a1[3];
  }
  [v3 setArrayLength:v7];
  if (*((unsigned __int8 *)a1 + 15) <= 1u) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = *((unsigned __int8 *)a1 + 15);
  }
  [v3 setSampleCount:v8];
  [v3 setTextureType:*((unsigned __int8 *)a1 + 8)];
  [v3 setStorageMode:*((unsigned __int8 *)a1 + 9)];
  [v3 setUsage:*((unsigned __int8 *)a1 + 10)];
  [v3 setCpuCacheMode:*((unsigned __int8 *)a1 + 11)];
  [v3 setPixelFormat:a1[6]];
  if (*((unsigned __int8 *)a1 + 14) <= 1u) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = *((unsigned __int8 *)a1 + 14);
  }
  [v3 setMipmapLevelCount:v9];
  return v3;
}

CFTypeRef C3DImageCopyBitmap(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  uint64_t v12 = *(const void **)(a1 + 64);
  if (v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a2 == 0;
  }
  if (!v13)
  {
    C3DImageCacheBitmap(a1);
    uint64_t v12 = *(const void **)(a1 + 64);
  }
  if (v12) {
    CFTypeRef v14 = CFRetain(v12);
  }
  else {
    CFTypeRef v14 = 0;
  }
  pthread_mutex_unlock(&bitmapAccessSharedMutex);
  return v14;
}

uint64_t SCNMTLPixelFormatFromBitmapContextDescription(uint64_t a1, uint64_t a2, CGContextRef context, char a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  CGBitmapInfo BitmapInfo = CGBitmapContextGetBitmapInfo(context);
  CGColorSpaceRef ColorSpace = CGBitmapContextGetColorSpace(context);
  int v10 = BitmapInfo & 0x7000;
  if ((BitmapInfo & 0x1B) == 2)
  {
    int v12 = 0;
    BOOL v11 = v10 == 4096 || v10 == 0x2000;
    if ((BitmapInfo & 0x100) == 0) {
      goto LABEL_8;
    }
LABEL_25:
    if (a2 == 32)
    {
      switch(a1)
      {
        case 1:
          return 55;
        case 4:
          return 125;
        case 2:
          return 105;
      }
    }
    else if (a2 == 16)
    {
      switch(a1)
      {
        case 1:
          return 25;
        case 4:
          return 115;
        case 2:
          return 65;
      }
    }
    goto LABEL_70;
  }
  if ((BitmapInfo & 0x1B) != 1 || (BOOL v11 = 0, v12 = 1, (BitmapInfo & 0x7000) != 0) && v10 != 12288 && v10 != 0x4000)
  {
    int v12 = 0;
    BOOL v11 = 0;
  }
  if ((BitmapInfo & 0x100) != 0) {
    goto LABEL_25;
  }
LABEL_8:
  if (C3DLinearRenderingIsEnabled())
  {
    if (ColorSpace != (CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB()
      && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearSRGB()
      && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearGray())
    {
      uint64_t v13 = C3DColorSpaceLinearDisplayP3();
      if ((a4 & 1) == 0 && ColorSpace != (CGColorSpaceRef)v13)
      {
        if (a2 == 8)
        {
          if (a1 == 1) {
            return 11;
          }
          if (a1 == 2) {
            return 31;
          }
          if (a1 == 4 && v12 == 1) {
            return 71;
          }
          if (a1 == 4 && v11) {
            return 81;
          }
        }
        goto LABEL_70;
      }
    }
    if (a2 == 16)
    {
      if (a1 == 1) {
        return 20;
      }
      if (a1 == 4 && (v12 & 1) != 0) {
        return 110;
      }
      goto LABEL_70;
    }
    if (a2 != 8) {
      goto LABEL_70;
    }
    if (a1 != 1)
    {
      if (a1 == 2) {
        return 30;
      }
      if (a1 == 4 && v12 == 1) {
        return 70;
      }
      if (a1 != 4 || !v11) {
        goto LABEL_70;
      }
      return 80;
    }
    return 10;
  }
  if (a2 != 8) {
    goto LABEL_70;
  }
  if (a1 == 1) {
    return 10;
  }
  if (a1 == 2) {
    return 30;
  }
  if (a1 == 4 && v12 == 1) {
    return 70;
  }
  if (a1 == 4 && v11) {
    return 80;
  }
LABEL_70:
  uint64_t v16 = scn_default_log();
  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    return 70;
  }
  unsigned int v18 = (BitmapInfo >> 12) & 7;
  if (v18 > 4) {
    uint64_t v19 = @"byteOrderUnknown";
  }
  else {
    uint64_t v19 = off_264006330[v18];
  }
  if ((BitmapInfo & 0x1F) > 7) {
    uint64_t v20 = @"alphaUnknown";
  }
  else {
    uint64_t v20 = off_264006358[BitmapInfo & 0x1F];
  }
  uint64_t v21 = @"yes";
  int v22 = 138414082;
  CGContextRef v23 = context;
  __int16 v24 = 1024;
  if ((BitmapInfo & 0x100) == 0) {
    uint64_t v21 = @"no";
  }
  int v25 = a1;
  __int16 v26 = 1024;
  int v27 = a2;
  __int16 v28 = 1024;
  CGBitmapInfo v29 = BitmapInfo;
  __int16 v30 = 2112;
  id v31 = v19;
  __int16 v32 = 2112;
  float v33 = v20;
  __int16 v34 = 2112;
  uint64_t v35 = v21;
  __int16 v36 = 2112;
  CGColorSpaceRef v37 = ColorSpace;
  uint64_t v14 = 70;
  _os_log_error_impl(&dword_20B249000, v16, OS_LOG_TYPE_ERROR, "Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]", (uint8_t *)&v22, 0x46u);
  return v14;
}

uint64_t C3DImageCacheBitmap(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    id v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  if (!*(void *)(a1 + 64)
    && *(_DWORD *)(a1 + 96) != 5
    && (*(unsigned char *)(a1 + 80) & 2) == 0
    && !C3DImageGetTextureRawData(a1))
  {
    kdebug_trace();
    int v10 = C3DImageCopyCGImage(a1);
    if (*(void *)(a1 + 64) && (BOOL v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
    {
      C3DImageCacheBitmap_cold_2(v11, v12, v13, v14, v15, v16, v17, v18);
      if (!v10) {
        goto LABEL_84;
      }
    }
    else if (!v10)
    {
LABEL_84:
      kdebug_trace();
      return pthread_mutex_unlock(&bitmapAccessSharedMutex);
    }
    uint64_t v19 = C3DCreateCGBitmapContextRefFromCGImageRef(v10);
    *(void *)(a1 + 64) = v19;
    if (!v19)
    {
      uint64_t v38 = scn_default_log();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        C3DImageCacheBitmap_cold_1();
      }
      goto LABEL_83;
    }
    if ((*(unsigned char *)(a1 + 116) & 4) != 0)
    {
LABEL_66:
      HasAlphSCNMatrix4 a = C3DImageHasAlpha(a1);
      CGColorSpaceRef ColorSpace = CGBitmapContextGetColorSpace(*(CGContextRef *)(a1 + 64));
      if (ColorSpace != (CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB()
        && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearGray()
        && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearSRGB())
      {
        int v55 = ColorSpace == (CGColorSpaceRef)C3DColorSpaceLinearDisplayP3() ? 0 : HasAlpha;
        if (v55 == 1 && (C3DImageNeedsUnpremultiply(a1) & 1) == 0)
        {
          if (C3DLinearRenderingIsEnabled())
          {
            double v56 = CACurrentMediaTime();
            C3DBitmapFixIncorrectPremultiply(*(CGContext **)(a1 + 64));
            float32x4_t v57 = scn_default_log();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
            {
              int v58 = *(_DWORD *)(a1 + 96);
              if (v58 == 5)
              {
                uint64_t v59 = *(void *)(a1 + 88);
              }
              else if (v58 == 1)
              {
                uint64_t v59 = [*(id *)(a1 + 88) lastPathComponent];
              }
              else
              {
                uint64_t v59 = 0;
              }
              uint64_t v60 = *(void *)(a1 + 104);
              int v62 = 138413058;
              uint64_t v63 = v59;
              __int16 v64 = 1024;
              unsigned int v65 = *(float *)&v60;
              __int16 v66 = 1024;
              unsigned int v67 = *((float *)&v60 + 1);
              __int16 v68 = 2048;
              double v69 = (CACurrentMediaTime() - v56) * 1000.0;
              _os_log_impl(&dword_20B249000, v57, OS_LOG_TYPE_INFO, "Info: FixIncorrectPremultiply %@ time %u x %u : %fms", (uint8_t *)&v62, 0x22u);
            }
          }
        }
      }
LABEL_83:
      CGImageRelease(v10);
      goto LABEL_84;
    }
    uint64_t v20 = v19;
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v10);
    unsigned int v22 = AlphaInfo - 1;
    BOOL v24 = AlphaInfo == kCGImageAlphaOnly || v22 < 4;
    if (v22 > 3)
    {
LABEL_65:
      *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFE | v24 | 4;
      goto LABEL_66;
    }
    DatSCNMatrix4 a = (unsigned __int8 *)CGBitmapContextGetData(v20);
    if (Data)
    {
      __int16 v26 = Data;
      unsigned int Width = CGBitmapContextGetWidth(v20);
      unsigned int Height = CGBitmapContextGetHeight(v20);
      size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(v20);
      size_t v30 = (CGBitmapContextGetBitsPerPixel(v20) / BitsPerComponent * BitsPerComponent) >> 3;
      size_t BytesPerRow = CGBitmapContextGetBytesPerRow(v20);
      if (v30 == 4)
      {
        if (CGImageGetBitmapInfo(v10) == 0x2000) {
          int v32 = 0;
        }
        else {
          int v32 = 3;
        }
        if (Height)
        {
          int v33 = 0;
          unsigned int v34 = 0;
          BOOL v35 = 1;
          while (!Width)
          {
LABEL_31:
            BOOL v24 = 0;
            ++v34;
            v33 += BytesPerRow;
            BOOL v35 = v34 < Height;
            if (v34 == Height) {
              goto LABEL_65;
            }
          }
          int v36 = v33 + v32;
          unsigned int v37 = Width;
          while (v26[v36] >= 0xFEu)
          {
            v36 += 4;
            if (!--v37) {
              goto LABEL_31;
            }
          }
          BOOL v24 = v35;
          goto LABEL_65;
        }
        goto LABEL_64;
      }
      if ((CGBitmapContextGetBitmapInfo(v20) & 0x100) != 0)
      {
        if (v30 == 8)
        {
          if (Height)
          {
            uint64_t v43 = 0;
            long long v44 = (unsigned __int16 *)(v26 + 6);
            while (1)
            {
              uint64_t v45 = v44;
              uint64_t v46 = Width;
              if (Width) {
                break;
              }
LABEL_62:
              BOOL v24 = 0;
              ++v43;
              long long v44 = (unsigned __int16 *)((char *)v44 + BytesPerRow);
              if (v43 == Height) {
                goto LABEL_65;
              }
            }
            while (1)
            {
              unsigned int v48 = *v45;
              v45 += 4;
              unsigned int v47 = v48;
              int v49 = (v48 >> 10) & 0x1F;
              int v50 = v49 == 31 ? 2139095040 : v49;
              BOOL v51 = !v49 || v49 == 31;
              int v52 = v51 ? v50 : (v49 << 23) + 939524096;
              if (COERCE_FLOAT(v52 | (v47 << 16) & 0x80000000 | (v47 >> 7) & 7 | (8 * (v47 & 0x3FF)) & 0x1FFF | ((v47 & 0x3FF) << 13)) < 0.999) {
                goto LABEL_79;
              }
              if (!--v46) {
                goto LABEL_62;
              }
            }
          }
        }
        else if (v30 == 16 && Height)
        {
          uint64_t v39 = 0;
          uint64_t v40 = (float *)(v26 + 12);
          while (1)
          {
            uint64_t v41 = v40;
            uint64_t v42 = Width;
            if (Width) {
              break;
            }
LABEL_45:
            BOOL v24 = 0;
            ++v39;
            uint64_t v40 = (float *)((char *)v40 + BytesPerRow);
            if (v39 == Height) {
              goto LABEL_65;
            }
          }
          while (*v41 >= 0.999)
          {
            v41 += 4;
            if (!--v42) {
              goto LABEL_45;
            }
          }
LABEL_79:
          BOOL v24 = 1;
          goto LABEL_65;
        }
      }
    }
LABEL_64:
    BOOL v24 = 0;
    goto LABEL_65;
  }
  return pthread_mutex_unlock(&bitmapAccessSharedMutex);
}

uint64_t C3DImageGetTextureRawData(uint64_t a1)
{
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  if (!a1)
  {
    id v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 80) & 2) != 0) {
    *(unsigned char *)(a1 + 116) &= ~8u;
  }
  C3DImageGetSize(a1);
  uint64_t v10 = *(void *)(a1 + 72);
  pthread_mutex_unlock(&bitmapAccessSharedMutex);
  return v10;
}

double C3DImageGetSize(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 116) & 8) == 0)
  {
    *(void *)(a1 + 104) = 0;
    if (_mayBeASTC(a1))
    {
      if C3DASTCIsSupported() && (_loadASTC(a1)) {
        goto LABEL_62;
      }
      if ((_mayBeKTX(a1) & 1) == 0)
      {
LABEL_9:
        if ((C3DASTCIsSupported() & 1) == 0 && *(_DWORD *)(a1 + 96) == 1)
        {
          id v2 = *(void **)(a1 + 88);
          if (v2)
          {
            uint64_t v3 = (const void *)objc_msgSend((id)objc_msgSend(v2, "URLByDeletingPathExtension"), "URLByAppendingPathExtension:", @"pvrtc");
            if (C3DFileMayExistAtURL((const __CFURL *)v3))
            {
              uint64_t v4 = *(const void **)(a1 + 88);
              if (v4 != v3)
              {
                if (v4)
                {
                  CFRelease(v4);
                  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x380], 8) = 0;
                }
                if (v3) {
                  CFTypeRef v5 = CFRetain(v3);
                }
                else {
                  CFTypeRef v5 = 0;
                }
                *(void *)(a1 + 8_Block_object_dispose(&STACK[0x380], 8) = v5;
              }
            }
          }
        }
LABEL_20:
        if _mayBePVRTC(a1) && (_loadPVRTC(a1)) {
          goto LABEL_62;
        }
        pthread_mutex_lock(&bitmapAccessSharedMutex);
        uint64_t v6 = *(CGContext **)(a1 + 64);
        if (v6)
        {
          float Width = (float)CGBitmapContextGetWidth(v6);
          size_t Height = CGBitmapContextGetHeight(*(CGContextRef *)(a1 + 64));
          *(float *)&uint64_t v8 = Width;
          *((float *)&v8 + 1) = (float)Height;
          *(void *)(a1 + 104) = v8;
          pthread_mutex_unlock(&bitmapAccessSharedMutex);
          goto LABEL_62;
        }
        pthread_mutex_unlock(&bitmapAccessSharedMutex);
        int v9 = *(_DWORD *)(a1 + 96);
        if (v9 == 1)
        {
          CFURLRef v12 = *(const __CFURL **)(a1 + 88);
          if (v12)
          {
            CGImageSourceRef v11 = C3DCreateImageSourceWithURL(v12);
            goto LABEL_30;
          }
        }
        else if (v9 == 2)
        {
          CFDataRef v10 = *(const __CFData **)(a1 + 88);
          if (v10)
          {
            CGImageSourceRef v11 = CGImageSourceCreateWithData(v10, 0);
LABEL_30:
            uint64_t v13 = v11;
            if (v11)
            {
              CFSetRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
              CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x263F0F600], (const void *)*MEMORY[0x263EFFB38]);
              CFDictionaryRef v15 = CGImageSourceCopyPropertiesAtIndex(v13, 0, Mutable);
              CFRelease(Mutable);
              uint64_t v16 = 0;
              if (v15)
              {
                CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x263F0F4F8]);
                CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x263F0F4F0]);
                CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x263F0F4C8]);
                if (Value && v18)
                {
                  CFNumberRef v20 = v19;
                  uint64_t valuePtr = 0;
                  CFNumberGetValue(Value, kCFNumberFloatType, (char *)&valuePtr + 4);
                  CFNumberGetValue(v18, kCFNumberFloatType, &valuePtr);
                  if (v20)
                  {
                    HIDWORD(v39) = 0;
                    CFNumberGetValue(v20, kCFNumberIntType, (char *)&v39 + 4);
                    BOOL v21 = SHIDWORD(v39) > 4;
                  }
                  else
                  {
                    BOOL v21 = 0;
                  }
                  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x263F0F198]);
                  if (v22)
                  {
                    CFNumberRef v23 = v22;
                    CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x263F0F1A0]);
                    if (v24)
                    {
                      CFNumberRef v25 = v24;
                      uint64_t v39 = 0;
                      CFNumberGetValue(v23, kCFNumberFloatType, (char *)&v39 + 4);
                      CFNumberGetValue(v25, kCFNumberFloatType, &v39);
                      if (*((float *)&v39 + 1) != *(float *)&v39 && *(float *)&v39 > 0.01)
                      {
                        float v26 = *(float *)&v39 / *((float *)&v39 + 1);
                        if (*(float *)&v39 <= *((float *)&v39 + 1)) {
                          float v26 = 1.0;
                        }
                        if (*((float *)&v39 + 1) <= *(float *)&v39) {
                          float v27 = 1.0;
                        }
                        else {
                          float v27 = *((float *)&v39 + 1) / *(float *)&v39;
                        }
                        if (v21) {
                          float v28 = v26;
                        }
                        else {
                          float v28 = v27;
                        }
                        if (!v21) {
                          float v27 = v26;
                        }
                        *(float *)&uint64_t valuePtr = v27 * *(float *)&valuePtr;
                        *((float *)&valuePtr + 1) = v28 * *((float *)&valuePtr + 1);
                      }
                    }
                  }
                  float v29 = *(float *)&valuePtr;
                  if (v21) {
                    *(float *)&uint64_t v30 = *(float *)&valuePtr;
                  }
                  else {
                    *(float *)&uint64_t v30 = *((float *)&valuePtr + 1);
                  }
                  if (v21) {
                    float v29 = *((float *)&valuePtr + 1);
                  }
                  *((float *)&v30 + 1) = v29;
                  uint64_t v38 = v30;
                  CFRelease(v15);
                  uint64_t v16 = v38;
                }
                else
                {
                  CFRelease(v15);
                  uint64_t v16 = 0;
                }
              }
              *(void *)(a1 + 104) = v16;
              CFRelease(v13);
              if (COERCE_FLOAT(*(void *)(a1 + 104)) > 0.0) {
                goto LABEL_62;
              }
            }
          }
        }
        id v31 = C3DImageCopyCGImage(a1);
        if (!v31)
        {
          if ((C3DIsRunningInSCNTool() & 1) == 0)
          {
            int v36 = scn_default_log();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              C3DImageGetSize_cold_1();
            }
          }
          *(unsigned char *)(a1 + 116) |= 0x28u;
          if (C3DImageIsCubeMap(a1)) {
            char v34 = 16;
          }
          else {
            char v34 = 0;
          }
          char v33 = *(unsigned char *)(a1 + 116);
          goto LABEL_63;
        }
        int v32 = v31;
        *(float *)(a1 + 104) = (float)CGImageGetWidth(v31);
        *(float *)(a1 + 10_Block_object_dispose(&STACK[0x380], 8) = (float)CGImageGetHeight(v32);
        CFRelease(v32);
LABEL_62:
        char v33 = *(unsigned char *)(a1 + 116) | 0x28;
        char v34 = 16;
LABEL_63:
        *(unsigned char *)(a1 + 116) = v33 & 0xEF | v34;
        return *(double *)(a1 + 104);
      }
    }
    else if (!_mayBeKTX(a1))
    {
      goto LABEL_20;
    }
    if (_loadKTX(a1)) {
      goto LABEL_62;
    }
    goto LABEL_9;
  }
  return *(double *)(a1 + 104);
}

CGImageRef C3DImageCopyCGImage(uint64_t a1)
{
  v28[1] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    id v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 96) != 3)
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    CGImageSourceRef v11 = *(CGContext **)(a1 + 64);
    if (v11)
    {
LABEL_7:
      uint64_t Image = CGBitmapContextCreateImage(v11);
LABEL_8:
      pthread_mutex_unlock(&bitmapAccessSharedMutex);
      return (CGImageRef)Image;
    }
    CFURLRef URL = (const __CFURL *)C3DImageGetURL(a1);
    if (URL)
    {
      BOOL v24 = 0;
      CFDataRef v14 = (const __CFData *)C3DImageCopyUSDZEmbeddedData(a1, &v24);
      if (v14)
      {
        CFDataRef v15 = v14;
        uint64_t v16 = CGImageSourceCreateWithData(v14, 0);
        CFRelease(v15);
        if (v16)
        {
          uint64_t v27 = *MEMORY[0x263F0F5F8];
          v28[0] = MEMORY[0x263EFFA88];
          uint64_t Image = CGImageSourceCreateImageAtIndex(v16, 0, (CFDictionaryRef)[NSDictionary dictionaryWithObjects:v28 forKeys:&v27 count:1]);
          CFRelease(v16);
          goto LABEL_8;
        }
      }
      if (v24) {
        goto LABEL_34;
      }
      CGImageSourceRef v17 = C3DCreateImageSourceWithURL(URL);
      if (v17)
      {
        CFNumberRef v18 = v17;
LABEL_19:
        uint64_t v25 = *MEMORY[0x263F0F5F8];
        uint64_t v26 = MEMORY[0x263EFFA88];
        uint64_t Image = CGImageSourceCreateImageAtIndex(v18, 0, (CFDictionaryRef)[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1]);
        if (!Image)
        {
          CFNumberRef v20 = scn_default_log();
          BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
          if (URL)
          {
            if (v21) {
              C3DImageCopyCGImage_cold_3(v18, (uint64_t)URL, v20);
            }
          }
          else if (v21)
          {
            C3DImageCopyCGImage_cold_2(v18, v20);
          }
        }
        CFRelease(v18);
        goto LABEL_32;
      }
      CFNumberRef v23 = (CGImage *)SCNFindImageNamedInAppBundle(URL);
      if (v23)
      {
        uint64_t Image = v23;
        CGImageRetain(v23);
        goto LABEL_8;
      }
    }
    else
    {
      DatSCNMatrix4 a = (const __CFData *)C3DImageGetData(a1);
      if (Data)
      {
        CFNumberRef v18 = CGImageSourceCreateWithData(Data, 0);
        if (v18) {
          goto LABEL_19;
        }
        CFNumberRef v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          C3DImageCopyCGImage_cold_1();
        }
      }
    }
    if (*(_DWORD *)(a1 + 96) != 4) {
      goto LABEL_33;
    }
    uint64_t Image = (void *)SCNCopyCGImageFromImage(*(void **)(a1 + 88));
LABEL_32:
    if (Image) {
      goto LABEL_8;
    }
LABEL_33:
    CGImageSourceRef v11 = *(CGContext **)(a1 + 64);
    if (v11) {
      goto LABEL_7;
    }
LABEL_34:
    uint64_t Image = 0;
    goto LABEL_8;
  }
  return CGImageRetain(*(CGImageRef *)(a1 + 88));
}

uint64_t C3DColorSpaceLinearSRGB()
{
  if (C3DColorSpaceLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_4);
  }
  return C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
}

uint64_t C3DColorSpaceLinearGray()
{
  if (C3DColorSpaceLinearGray_onceToken != -1) {
    dispatch_once(&C3DColorSpaceLinearGray_onceToken, &__block_literal_global_10);
  }
  return C3DColorSpaceLinearGray_kC3DColorSpaceLinearGray;
}

uint64_t C3DColorSpaceLinearDisplayP3()
{
  if (C3DColorSpaceLinearDisplayP3_onceToken != -1) {
    dispatch_once(&C3DColorSpaceLinearDisplayP3_onceToken, &__block_literal_global_22);
  }
  return C3DColorSpaceLinearDisplayP3_kC3DColorSpaceLinearDisplayP3;
}

uint64_t C3DColorSpaceExtendedLinearSRGB()
{
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
  }
  return C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
}

uint64_t _mayBePVRTC(uint64_t a1)
{
  if (C3DImageGetData(a1)) {
    return 1;
  }
  uint64_t v3 = copyPathExtension(a1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  BOOL v2 = CFEqual(v3, @"pvr") || CFEqual(v4, @"pvrtc");
  CFRelease(v4);
  return v2;
}

uint64_t _mayBeKTX(uint64_t a1)
{
  if (C3DImageGetData(a1)) {
    return 1;
  }
  uint64_t v3 = copyPathExtension(a1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  BOOL v2 = CFEqual(v3, @"ktx") != 0;
  CFRelease(v4);
  return v2;
}

__CFString *copyPathExtension(uint64_t a1)
{
  CFURLRef URL = (const __CFURL *)C3DImageGetURL(a1);
  if (!URL) {
    return 0;
  }
  CFStringRef v2 = CFURLCopyPathExtension(URL);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(0, 0, v2);
  CFStringLowercase(MutableCopy, 0);
  CFRelease(v3);
  return MutableCopy;
}

uint64_t C3DImageGetURL(uint64_t a1)
{
  if (!a1)
  {
    CFStringRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 96) == 1) {
    return *(void *)(a1 + 88);
  }
  else {
    return 0;
  }
}

uint64_t C3DImageGetData(uint64_t a1)
{
  if (!a1)
  {
    CFStringRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 96) == 2) {
    return *(void *)(a1 + 88);
  }
  else {
    return 0;
  }
}

uint64_t _mayBeASTC(uint64_t a1)
{
  if (C3DImageGetData(a1)) {
    return 1;
  }
  uint64_t v3 = copyPathExtension(a1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  BOOL v2 = CFEqual(v3, @"ast") || CFEqual(v4, @"astc");
  CFRelease(v4);
  return v2;
}

CGContext *C3DCreateCGBitmapContextRefFromCGImageRef(CGImage *a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  unint64_t Width = CGImageGetWidth(a1);
  unint64_t Height = CGImageGetHeight(a1);
  __int16 BitmapInfo = CGImageGetBitmapInfo(a1);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  if (!ColorSpace)
  {
    if ((BitmapInfo & 0x100) == 0)
    {
      C3DWideGamutIsUsed();
      BOOL v9 = 1;
      goto LABEL_9;
    }
LABEL_16:
    size_t v11 = 8 * Width;
    uint32_t v12 = 4353;
    size_t v13 = 16;
    uint64_t v14 = C3DColorSpaceExtendedLinearSRGB();
LABEL_17:
    CFDataRef v15 = (CGColorSpace *)v14;
    goto LABEL_18;
  }
  uint64_t v6 = ColorSpace;
  BaseCGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
  if (BaseColorSpace) {
    uint64_t v6 = BaseColorSpace;
  }
  BOOL IsWideGamutRGB = CGColorSpaceIsWideGamutRGB(v6);
  if ((BitmapInfo & 0x100) != 0 || (C3DWideGamutIsUsed() & IsWideGamutRGB) == 1) {
    goto LABEL_16;
  }
  BOOL v9 = CGColorSpaceGetNumberOfComponents(v6) == 1;
LABEL_9:
  int v10 = BitmapInfo & 0x1F;
  if (BitmapInfo & 0x1F) != 0 || !v9 || (C3DWasLinkedBeforeMajorOSYear2016())
  {
    size_t v11 = 4 * Width;
    if (v10) {
      uint32_t v12 = 16385;
    }
    else {
      uint32_t v12 = 16389;
    }
    size_t v13 = 8;
    uint64_t v14 = C3DColorSpaceSRGB();
    goto LABEL_17;
  }
  size_t v13 = 8;
  CFDataRef v15 = (CGColorSpace *)C3DColorSpaceGray();
  uint32_t v12 = 0;
  size_t v11 = Width;
LABEL_18:
  uint64_t v16 = CGBitmapContextCreate(0, Width, Height, v13, v11, v15, v12);
  CGImageSourceRef v17 = v16;
  if (v16)
  {
    v23.size.width = (double)Width;
    v23.size.height = (double)Height;
    v23.origin.x = 0.0;
    v23.origin.y = 0.0;
    CGContextDrawImage(v16, v23, a1);
  }
  else
  {
    CFNumberRef v18 = scn_default_log();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 138412290;
      BOOL v21 = a1;
      _os_log_impl(&dword_20B249000, v18, OS_LOG_TYPE_DEFAULT, "Warning: Failed to create bitmap context for CG image %@", (uint8_t *)&v20, 0xCu);
    }
  }
  return v17;
}

uint64_t C3DColorSpaceSRGB()
{
  if (C3DColorSpaceSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
  }
  return C3DColorSpaceSRGB_kC3DColorSpaceSRGB;
}

uint64_t C3DImageTypeToMTLTextureType(int a1)
{
  if (a1 >= 8)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageTypeToMTLTextureType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_TextureType[a1];
}

int32x2_t C3DImageGetTextureSize(uint64_t a1)
{
  *(double *)&int32x2_t result = C3DImageGetSize(a1);
  switch(*(_DWORD *)(a1 + 120))
  {
    case 2:
    case 4:
      return vdup_lane_s32(result, 1);
    case 5:
      goto LABEL_6;
    case 6:
      float v3 = *(float *)&result.i32[1] / 3.0;
      goto LABEL_5;
    case 7:
      float v3 = *(float *)&result.i32[1] * 0.25;
LABEL_5:
      *(float *)result.i32 = ceilf(v3);
LABEL_6:
      int32x2_t result = vdup_lane_s32(result, 0);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t C3DImageGetDepth(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 120) != 2) {
    return 1;
  }
  uint32x2_t v1 = vcvt_u32_f32(vrnda_f32(COERCE_FLOAT32X2_T(C3DImageGetSize(a1))));
  if (v1.i32[0] <= (unsigned __int32)v1.i32[1]) {
    return v1.i32[1] / (unsigned __int32)v1.i32[0];
  }
  else {
    return v1.i32[0] / (unsigned __int32)v1.i32[1];
  }
}

uint64_t C3DImageNeedsUnpremultiply(uint64_t a1)
{
  if (!a1)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 116) >> 1) & 1;
}

uint64_t scn_default_log()
{
  if (scn_default_log_once != -1) {
    dispatch_once(&scn_default_log_once, &__block_literal_global_10);
  }
  return scn_default_log_logger;
}

size_t C3DBitmapFixIncorrectPremultiply(CGContext *a1)
{
  unsigned int Width = CGBitmapContextGetWidth(a1);
  int Height = CGBitmapContextGetHeight(a1);
  size_t result = (size_t)CGBitmapContextGetData(a1);
  if (result)
  {
    uint64_t v5 = (int *)result;
    size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(a1);
    size_t result = CGBitmapContextGetBitsPerPixel(a1);
    if (((result / BitsPerComponent * BitsPerComponent) & 0xFFFFFFFFFFFFFFF8) == 0x20)
    {
      size_t result = CGBitmapContextGetBytesPerRow(a1);
      if (Height)
      {
        uint64_t v7 = 0;
        uint32x4_t v8 = (uint32x4_t)xmmword_20B5CCAD0;
        v9.i64[0] = 0xFF000000FFLL;
        v9.i64[1] = 0xFF000000FFLL;
        float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x3E1C096Eu);
        float32x4_t v11 = (float32x4_t)vdupq_n_s32(0xBF12862E);
        float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3F6BC556u);
        float32x4_t v13 = (float32x4_t)vdupq_n_s32(0xBF66EEDE);
        float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3F622C5Fu);
        float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x3EF653C9u);
        float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x3D11FA77u);
        float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x3A5DBC4Du);
        float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3D9E8391u);
        float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3D25AEE6u);
        float32x4_t v20 = (float32x4_t)vdupq_n_s32(0xC5D0CBF7);
        float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x44991F14u);
        float32x4_t v22 = (float32x4_t)vdupq_n_s32(0xC2C877E1);
        float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x40D350C9u);
        float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x3D7A766Bu);
        float32x4_t v25 = (float32x4_t)vdupq_n_s32(0xB9693F28);
        float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x34DD5C9Cu);
        float32x4_t v27 = (float32x4_t)vdupq_n_s32(0xAFC12644);
        float32x4_t v28 = (float32x4_t)vdupq_n_s32(0xBE3FCBA9);
        float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x3F259300u);
        float32x4_t v30 = (float32x4_t)vdupq_n_s32(0xBF7D862E);
        float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x3F9ACD51u);
        float32x4_t v75 = (float32x4_t)vdupq_n_s32(0xBC5C6168);
        float32x4_t v76 = (float32x4_t)vdupq_n_s32(0x3EAB2DE7u);
        float32x4_t v73 = (float32x4_t)vdupq_n_s32(0xB6DEE3CF);
        float32x4_t v74 = (float32x4_t)vdupq_n_s32(0x39E887D3u);
        float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x3D563886u);
        float32x4_t v71 = (float32x4_t)vdupq_n_s32(0x3B808081u);
        float32x4_t v72 = v10;
        do
        {
          uint64_t v33 = Width;
          char v34 = v5;
          if (Width)
          {
            do
            {
              BOOL v35 = (const float *)v34;
              uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v35);
              int v36 = v35 + 1;
              float32x4_t v39 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, v8), v9));
              float32x4_t v38 = vmulq_f32(v39, v71);
              v39.i32[0] = v38.i32[3];
              if (v38.f32[3] <= 0.0) {
                v39.f32[0] = 0.0001;
              }
              float32x4_t v40 = vdivq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
              float32x4_t v41 = vmulq_f32(v40, v40);
              float32x4_t v42 = vmlaq_f32(v15, v14, v40);
              float32x4_t v43 = v14;
              float32x4_t v44 = v13;
              int8x16_t v45 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v17, v16, v40), v41, v42), vmulq_f32(v41, v41), vmlaq_f32(vmlaq_f32(v13, v12, v40), v41, vmlaq_f32(v11, v10, v40)));
              int8x16_t v46 = (int8x16_t)vmulq_f32(v40, v18);
              int32x4_t v47 = vcgeq_f32(v40, v19);
              v47.i32[3] = 0;
              float32x4_t v48 = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v47), v45, v46), v39.f32[0]);
              float32x4_t v49 = vmulq_f32(v48, v48);
              float32x4_t v50 = vmulq_f32(v48, v49);
              v50.i32[3] = 0;
              float32x4_t v51 = vmlaq_f32(vmlaq_f32(v23, v22, v48), v49, vmlaq_f32(v21, v20, v48));
              float32x4_t v52 = vmlaq_f32(vmlaq_f32(v27, v26, v48), v49, vmlaq_f32(v25, v24, v48));
              float32x4_t v53 = vmlaq_f32(vmlaq_f32(v31, v30, v48), v49, vmlaq_f32(v29, v28, v48));
              float32x4_t v54 = vmlaq_f32(vmlaq_f32(v73, v74, v48), v49, vmlaq_f32(v75, v76, v48));
              float32x4_t v55 = vmulq_f32(v49, v49);
              int8x16_t v56 = (int8x16_t)vmlaq_f32(v52, v55, v51);
              int32x4_t v57 = vcgeq_f32(v48, v32);
              v57.i32[3] = 0;
              float32x4_t v58 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v57), (int8x16_t)vmlaq_f32(v54, v55, v53), v56);
              float32x4_t v13 = v44;
              float32x4_t v14 = v43;
              float32x4_t v59 = vrecpeq_f32(v50);
              float32x4_t v60 = vmulq_f32(v59, vrecpsq_f32(v50, v59));
              float32x4_t v10 = v72;
              int8x16_t v61 = (int8x16_t)vmulq_f32(vmulq_f32(v60, vrecpsq_f32(v50, v60)), v58);
              float32x4_t v62 = vmulq_f32(v48, (float32x4_t)vdupq_n_s32(0x414EB852u));
              int32x4_t v63 = vcgeq_f32(v48, (float32x4_t)vdupq_n_s32(0x3B4D2E1Cu));
              v63.i32[3] = 0;
              float32x4_t v64 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v63), v61, (int8x16_t)v62);
              v64.i32[3] = v39.i32[0];
              v62.i64[0] = 0x3F0000003F000000;
              v62.i64[1] = 0x3F0000003F000000;
              int8x16_t v65 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32(v62, (float32x4_t)vdupq_n_s32(0x437F0000u), v64));
              v9.i64[0] = 0xFF000000FFLL;
              v9.i64[1] = 0xFF000000FFLL;
              int8x16_t v66 = vandq_s8(v65, v9);
              __int32 v67 = v66.i32[1];
              __int32 v68 = v66.i32[0];
              *(uint32x2_t *)v66.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL), (uint32x2_t)0x1800000010);
              __int32 v69 = v66.i32[1];
              __int32 v70 = v66.i32[0];
              uint32x4_t v8 = (uint32x4_t)xmmword_20B5CCAD0;
              *char v34 = v68 | (v67 << 8) | v70 | v69;
              char v34 = (int *)v36;
              --v33;
            }
            while (v33);
          }
          ++v7;
          uint64_t v5 = (int *)((char *)v5 + result);
        }
        while (v7 != Height);
      }
    }
  }
  return result;
}

uint64_t C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(uint64_t a1)
{
  if (!*(void *)a1)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v2, v3, v4);
    }
  }
  return *(void *)a1;
}

uint64_t C3D::RenderGraphResourceManager::set(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::insert(a1, a2, &v4);
  uint64_t result = v4;
  uint64_t v4 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_20B28F690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    C3D::RenderGraphResourceManager::set(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::insert(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 16);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v6 + 15;
    if (v12 >= (int)v7 + 496) {
      unsigned int v12 = v7 + 496;
    }
    if (v7 >= v12)
    {
      LODWORD(v14) = v7;
    }
    else
    {
      float32x4_t v13 = (__int16 *)(v8 + 2 * v7);
      LODWORD(v14) = v7;
      while (1)
      {
        __int16 v15 = *v13++;
        if ((v15 & 1) == 0) {
          break;
        }
        LODWORD(v14) = v14 + 1;
        if (v12 == v14) {
          goto LABEL_34;
        }
      }
    }
    if (v14 != v12)
    {
      *(_WORD *)(v8 + 2 * v14) |= 1u;
      if (v14 <= (int)v7 + 14)
      {
        uint64_t v32 = v14;
LABEL_37:
        uint64_t v33 = *(void *)(a1 + 8);
        uint64_t v34 = *a3;
        *a3 = 0;
        *(void *)(v33 + 8 * v32) = v34;
        *(void *)(*(void *)a1 + 8 * v32) = a2;
        uint64_t v35 = *(void *)(a1 + 16);
        *(_WORD *)(v35 + 2 * v32) |= 1u;
        uint64_t result = 1;
        *(_WORD *)(v35 + 2 * v7) |= 1 << (v14 - v7 + 1);
        ++*(_DWORD *)(a1 + 24);
        return result;
      }
      while (1)
      {
        unsigned int v16 = v14;
        unsigned int v17 = v14 - 14;
        if (v14 < 0xF) {
          unsigned int v17 = 0;
        }
        unsigned int v18 = v17 - 1;
        int v19 = v17 <= v14 ? v14 : v17;
        char v20 = 1;
        while (1)
        {
          uint64_t v14 = v18 + 1;
          if (v17 <= v14) {
            break;
          }
LABEL_26:
          ++v20;
          unsigned int v18 = v14;
          if (v14 == v19) {
            goto LABEL_33;
          }
        }
        int v21 = 1 << (v18 - v17 + 2);
        char v22 = v20;
        unsigned int v23 = v17;
        while (1)
        {
          uint64_t v24 = v23;
          if (((unsigned __int16)v21 & *(_WORD *)(v8 + 2 * v23)) != 0) {
            break;
          }
          ++v23;
          LOWORD(v21) = (unsigned __int16)v21 >> 1;
          --v22;
          if ((int)v24 + 1 > v14) {
            goto LABEL_26;
          }
        }
        if (v14 >= v16) {
          break;
        }
        uint64_t v25 = *(void *)(a1 + 8);
        *(void *)(*(void *)a1 + 8 * v16) = *(void *)(*(void *)a1 + 8 * v14);
        uint64_t v26 = *(void *)(v25 + 8 * v14);
        *(void *)(v25 + 8 * v14) = 0;
        *(void *)(v25 + 8 * v16) = v26;
        uint64_t v27 = *(void *)(a1 + 8);
        uint64_t v28 = *(void *)(v27 + 8 * v14);
        *(void *)(v27 + 8 * v14) = 0;
        if (v28) {
          (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
        }
        uint64_t v8 = *(void *)(a1 + 16);
        *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v16 - v24 + 1))) ^ (1 << v22);
        if (v14 <= (int)v7 + 14)
        {
          uint64_t v32 = v14;
          goto LABEL_37;
        }
      }
LABEL_33:
      *(_WORD *)(v8 + 2 * v16) ^= 1u;
    }
LABEL_34:
    C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)a1 + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t v29 = *(void *)(a1 + 8);
  uint64_t v30 = *a3;
  *a3 = 0;
  uint64_t result = *(void *)(v29 + 8 * v10);
  *(void *)(v29 + 8 * v10) = v30;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t C3D::RenderGraphResourceManager::get(C3D::RenderGraphResourceManager *this, uint64_t a2)
{
  unsigned int v2 = (*((_DWORD *)this + 7) - 1) & a2;
  unsigned int v3 = *(unsigned __int16 *)(*((void *)this + 2) + 2 * v2);
  if (v3 < 2) {
    return 0;
  }
  while ((v3 & 2) == 0 || *(void *)(*(void *)this + 8 * v2) != a2)
  {
    ++v2;
    BOOL v4 = v3 >= 4;
    v3 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  uint64_t v6 = *((void *)this + 1);
  if (!v6) {
    return 0;
  }
  uint64_t result = *(void *)(v6 + 8 * v2);
  *(unsigned char *)(result + _Block_object_dispose(&STACK[0x380], 8) = 0;
  return result;
}

uint64_t C3DLightingSystemEnumerateRadianceProbes(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 84);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 176), *(void *)(result + 240), *(void *)(result + 480));
  }
  return result;
}

void C3D::Array<unsigned int,0u,C3D::MallocAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 4);
      int v6 = a2 - v5;
      if (a2 > v5)
      {
        C3D::Array<unsigned int,0u,C3D::MallocAllocator>::GrowCapacityBy((unsigned int *)a1, v6, 0);
        unsigned int v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(void *)(a1 + 8) + 4 * v2), 4 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

void C3D::Array<unsigned int,0u,C3D::MallocAllocator>::GrowCapacityBy(unsigned int *a1, int a2, int a3)
{
  BOOL v4 = (unsigned int *)*((void *)a1 + 1);
  double v5 = 1.5;
  if (a3) {
    double v5 = 1.0;
  }
  unsigned int v6 = (v5 * (double)(a1[1] + a2));
  uint64_t v7 = malloc_type_malloc(4 * v6, 0x74F3E194uLL);
  memcpy(v7, v4, 4 * *a1);
  *((void *)a1 + 1) = v7;
  a1[1] = v6;
  if (v4 != a1 + 4)
  {
    free(v4);
  }
}

uint64_t C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]();
    }
  }
  return *(void *)(a1 + 8) + 8 * a2;
}

uint64_t C3D::RenderGraph::createPersistentResource(uint64_t a1, uint64_t a2)
{
  uint64_t Aligned = C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 40, 8, 0);
  uint64_t result = C3D::RefCountedResource::RefCountedResource(Aligned);
  *(void *)uint64_t result = a2;
  *(_WORD *)(result + 32) = 1;
  *(unsigned char *)(result + 34) |= 1u;
  return result;
}

uint64_t SCNMTLPixelFormatIsWritable()
{
  return 0;
}

uint64_t SCNMTLDeviceSupportsColorRenderingInPixelFormat()
{
  return 0;
}

uint64_t C3DTextureSamplerBilinearMipMapClampNoAnisotropy()
{
  if (C3DTextureSamplerBilinearMipMapClampNoAnisotropy_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerBilinearMipMapClampNoAnisotropy_onceToken, &__block_literal_global_39);
  }
  return C3DTextureSamplerBilinearMipMapClampNoAnisotropy_states;
}

uint64_t C3DSceneGetLightingEnvironmentTimeStamp(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 320);
}

void _C3DIndexSetCFFinalize(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 2) == 0)
  {
    uint32x2_t v1 = *(void **)(a1 + 24);
    if (v1) {
      free(v1);
    }
  }
}

id C3DFXProgramCFFinalize(void *a1)
{
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationProgramWillDie", a1, 0, 1u);
  uint64_t v3 = (const void *)a1[9];
  if (v3)
  {
    CFRelease(v3);
    a1[9] = 0;
  }

  return C3DEntityCFFinalize((uint64_t)a1);
}

uint64_t C3DGeometryCreateCopy(CFTypeRef cf)
{
  if (!cf)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DCreateCopy(cf);
}

uint64_t C3DCreateCopy(CFTypeRef cf)
{
  if (!cf)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696)
  {
    BOOL v11 = (uint64_t (*)(CFTypeRef))ClassWithTypeID[27];
    if (v11) {
      return v11(cf);
    }
  }
  float32x4_t v13 = scn_default_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
    C3DCreateCopy_cold_1((uint64_t)cf, v13);
  }
  return 0;
}

uint64_t _C3DGeometryCreateCopy(uint64_t a1)
{
  uint64_t v2 = C3DGeometryCreate();
  C3DGeometryCopy(a1, v2);
  return v2;
}

void C3DGeometryCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  Mesh_NoValidation = (uint64_t *)C3DGeometryGetMesh_NoValidation(a1);
  C3DGeometrySetMesh(a2, Mesh_NoValidation);
  if (!a1)
  {
    int v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
    }
  }
  CFArrayRef v29 = *(const __CFArray **)(a1 + 80);
  if (!a2)
  {
    uint64_t v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
    }
  }
  CFArrayRef v38 = *(const __CFArray **)(a2 + 80);
  if (v38 != v29)
  {
    if (v38)
    {
      CFRelease(v38);
      *(void *)(a2 + 80) = 0;
    }
    if (v29) {
      *(void *)(a2 + 80) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v29);
    }
  }
  CFArrayRef LOD = (const __CFArray *)C3DGeometryGetLOD(a1);
  C3DGeometrySetLOD(a2, LOD);
  CFStringRef Name = (const __CFString *)C3DGeometryGetName(a1);
  if (Name) {
    C3DGeometrySetName(a2, Name);
  }
  *(_OWORD *)(a2 + 120) = *(_OWORD *)(a1 + 120);
  if (*(void *)(a1 + 104))
  {
    float32x4_t v41 = C3DMalloc(0x20uLL);
    *(void *)(a2 + 104) = v41;
    float32x4_t v42 = *(_OWORD **)(a1 + 104);
    long long v43 = v42[1];
    *float32x4_t v41 = *v42;
    v41[1] = v43;
  }
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
  C3DGeometryCopySubdivision(a1, (__C3DGeometry *)a2);
  long long v44 = *(_OWORD *)(a1 + 184);
  uint64_t v45 = *(void *)(a1 + 200);
  C3DGeometrySetTessellator(a2, (unsigned __int8 *)&v44);
}

void C3DGeometrySetTessellator(uint64_t a1, unsigned __int8 *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  int v12 = *(unsigned __int8 *)(a1 + 184);
  int v13 = *(unsigned __int8 *)(a1 + 196);
  long long v14 = *(_OWORD *)a2;
  *(void *)(a1 + 200) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 184) = v14;
  if (v13 != a2[12])
  {
    uint64_t v15 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v15, 6, (const void *)a1, 0);
  }
  C3DGeometryOpenSubdivGPUParameterDidChange((__C3DGeometry *)a1, v12, *a2, *(unsigned __int8 *)(a1 + 136), *(unsigned __int8 *)(a1 + 136));
}

void C3DGeometrySetLOD(uint64_t a1, const __CFArray *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = C3DGetSceneRef(a1);
  CFArrayRef v13 = *(const __CFArray **)(a1 + 96);
  if (v13)
  {
    if (*(void *)(a1 + 88))
    {
      CFIndex Count = CFArrayGetCount(v13);
      if (Count >= 1)
      {
        CFIndex v15 = Count;
        for (CFIndex i = 0; i != v15; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
          uint64_t v18 = (void *)C3DLODGetEntity((uint64_t)ValueAtIndex);
          if (v18) {
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)__propagateUnTrackingOfNodesToLODs, v18);
          }
        }
      }
    }
  }
  CFArrayRef v19 = *(const __CFArray **)(a1 + 96);
  if (v19 && v12)
  {
    CFIndex v20 = CFArrayGetCount(v19);
    if (v20 >= 1)
    {
      CFIndex v21 = v20;
      for (CFIndex j = 0; j != v21; ++j)
      {
        uint64_t v23 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), j);
        C3DRemoveSceneRef(v23, v12);
      }
    }
    CFArrayRef v19 = *(const __CFArray **)(a1 + 96);
  }
  if (v19 != a2)
  {
    if (v19)
    {
      CFRelease(v19);
      *(void *)(a1 + 96) = 0;
    }
    if (a2) {
      a2 = (const __CFArray *)CFRetain(a2);
    }
    *(void *)(a1 + 96) = a2;
  }
  if (a2 && v12)
  {
    CFIndex v24 = CFArrayGetCount(a2);
    if (v24 >= 1)
    {
      CFIndex v25 = v24;
      for (CFIndex k = 0; k != v25; ++k)
      {
        uint64_t v27 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), k);
        C3DAddSceneRef(v27, v12);
      }
    }
    a2 = *(const __CFArray **)(a1 + 96);
  }
  if (a2)
  {
    if (*(void *)(a1 + 88))
    {
      CFIndex v28 = CFArrayGetCount(a2);
      if (v28 >= 1)
      {
        CFIndex v29 = v28;
        for (CFIndex m = 0; m != v29; ++m)
        {
          uint64_t v31 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), m);
          uint64_t v32 = (void *)C3DLODGetEntity((uint64_t)v31);
          if (v32) {
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)__propagateTrackingOfNodesToLODs, v32);
          }
        }
      }
    }
  }
  CFSetRef v33 = *(const __CFSet **)(a1 + 88);
  if (v33) {
    CFSetApplyFunction(v33, (CFSetApplierFunction)_GeometryLODDidChange, 0);
  }
}

void C3DGeometryOpenSubdivGPUParameterDidChange(__C3DGeometry *a1, int a2, int a3, int a4, int a5)
{
  if ((C3DSubdivisionOsdGPUContextInvalidateIfNeeded(a1) & 1) == 0
    && (a3 == 4 ? (BOOL v10 = a5 == 0) : (BOOL v10 = 1),
        v10 ? (int v11 = 0) : (int v11 = 1),
        a2 == 4 ? (BOOL v12 = a4 == 0) : (BOOL v12 = 1),
        v12 ? (int v13 = 0) : (int v13 = 1),
        v13 == v11))
  {
    if ((a2 == 0) != (a3 != 0)) {
      return;
    }
    int v14 = 6;
  }
  else
  {
    int v14 = 7;
  }
  uint64_t v15 = C3DGetScene(a1);

  C3DScenePostPipelineEvent(v15, v14, a1, 0);
}

uint64_t C3DSubdivisionOsdGPUContextInvalidateIfNeeded(__C3DGeometry *a1)
{
  var6 = (unsigned __int8 *)a1->var10.var6;
  if (!var6) {
    return 0;
  }
  __n128 v5 = 0uLL;
  uint64_t v6 = 0;
  C3DGeometryGetTessellator((uint64_t)a1, &v5);
  if ((v6 & 0x100) != 0)
  {
    var3 = a1->var10.var3;
    if (var3) {
      LODWORD(var3) = a1->var10.var4 != 0;
    }
  }
  else
  {
    LODWORD(var3) = 0;
  }
  if (*((void *)var6 + 3)
    && var6[4] == ((BYTE1(v6) >> 1) & 1)
    && var6[2] == a1->var10.var1
    && var3 == var6[3]
    && *var6 == a1->var10.var0
    && var6[7] == a1->var10.var2.var1
    && var6[8] == a1->var10.var2.var2
    && *((void *)var6 + 2) == ((uint64_t)a1->var10.var4 ^ (uint64_t)a1->var10.var3))
  {
    return 0;
  }
  C3DSubdivisionOsdGPUContextDestroy(a1);
  return 1;
}

uint64_t C3DGeometryGetName(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetName(a1);
}

uint64_t C3DGeometryGetMesh_NoValidation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

__C3DMeshElement *C3DGeometryCopySubdivision(uint64_t a1, __C3DGeometry *a2)
{
  a2->var10.var2.var3 = *(unsigned char *)(a1 + 141);
  *(_DWORD *)&a2->var10.var0 = *(_DWORD *)(a1 + 136);
  a2->var10.var2.var2 = *(unsigned char *)(a1 + 140);
  C3DSubdivisionOsdGPUContextDestroy(a2);
  C3DGeometryDestroySubdivTopologyInfo(a2);
  var5 = a2->var10.var5;
  if (var5)
  {
    CFRelease(var5);
    a2->var10.var5 = 0;
  }
  var4 = a2->var10.var4;
  uint64_t v6 = *(__C3DMeshSource **)(a1 + 152);
  if (var4 != v6)
  {
    if (var4)
    {
      CFRelease(a2->var10.var4);
      a2->var10.var4 = 0;
      uint64_t v6 = *(__C3DMeshSource **)(a1 + 152);
    }
    if (v6) {
      uint64_t v6 = (__C3DMeshSource *)CFRetain(v6);
    }
    a2->var10.var4 = v6;
  }
  var3 = a2->var10.var3;
  uint64_t result = *(__C3DMeshElement **)(a1 + 144);
  if (var3 != result)
  {
    if (var3)
    {
      CFRelease(a2->var10.var3);
      a2->var10.var3 = 0;
      uint64_t result = *(__C3DMeshElement **)(a1 + 144);
    }
    if (result) {
      uint64_t result = (__C3DMeshElement *)CFRetain(result);
    }
    a2->var10.var3 = result;
  }
  return result;
}

void C3DGeometryDestroySubdivTopologyInfo(__C3DGeometry *a1)
{
  var7 = a1->var10.var7;
  if (var7)
  {
    if (*((int *)var7 + 49) >= 1)
    {
      int v3 = 0;
      do
        free(*(void **)(*((void *)var7 + 25) + 16 * v3++ + 8));
      while (*((_DWORD *)var7 + 49) > (int)v3);
    }
    free(*((void **)var7 + 25));
    free(*((void **)var7 + 14));
    free(*((void **)var7 + 15));
    free(*((void **)var7 + 17));
    free(*((void **)var7 + 18));
    free(*((void **)var7 + 20));
    free(*((void **)var7 + 21));
    free(*((void **)var7 + 23));
    uint64_t v4 = (void *)*((void *)var7 + 10);
    if (v4)
    {
      *((void *)var7 + 11) = v4;
      operator delete(v4);
    }
    uint64_t v5 = (void *)*((void *)var7 + 7);
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = (void *)*((void *)var7 + 4);
    if (v6)
    {
      *((void *)var7 + 5) = v6;
      operator delete(v6);
    }
    uint64_t v7 = (void *)*((void *)var7 + 1);
    if (v7)
    {
      *((void *)var7 + 2) = v7;
      operator delete(v7);
    }
    free(a1->var10.var7);
    a1->var10.var7 = 0;
  }
}

void C3DSubdivisionOsdGPUContextDestroy(__C3DGeometry *a1)
{
  var6 = a1->var10.var6;
  if (var6)
  {
    int v3 = (const void *)var6[3];
    if (v3) {
      CFRelease(v3);
    }
    free(var6);
    a1->var10.var6 = 0;
  }
}

CFStringRef C3DGeometrySetName(uint64_t a1, CFStringRef theString)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntitySetName(a1, theString);
}

float32x4_t *C3DNodeGetLastFrameWorldMatrix(float32x4_t *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = a1[3].i64[0];
  if (!v10) {
    return C3DTransformGetMatrixPtr(a1 + 6);
  }
  uint64_t TransformTree = C3DSceneGetTransformTree(v10);
  if (a1[5].i32[2] == -1)
  {
    BOOL v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetWorldMatrix_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return (float32x4_t *)C3DTransformTreeGetLastFrameWorldTransformPtr(TransformTree, a1[5].i32[2]);
}

uint64_t C3DTransformTreeGetLastFrameWorldTransformPtr(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DTransformTreeAddNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 == -1)
  {
    BOOL v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      __C3DTransformTree::remove();
    }
  }
  unint64_t v13 = *(void *)(*(void *)(a1 + 24) + 8 * a2);
  unint64_t v14 = HIDWORD(v13);
  if (HIDWORD(v13) == 0xFFFFFFFF) {
    int v15 = 0;
  }
  else {
    int v15 = -1;
  }
  if (HIDWORD(v13) == 0xFFFFFFFF) {
    LODWORD(v16) = 0;
  }
  else {
    unint64_t v16 = HIDWORD(v13);
  }
  if (*(void *)(*(void *)(a1 + 24) + 8 * a2) == 0xFFFFFFFFLL)
  {
    LODWORD(v13) = v15;
    LODWORD(v14) = v16;
  }
  return *(void *)(*(void *)(a1 + 56) + 80 * (int)v13 + 8) + ((uint64_t)(int)v14 << 6);
}

void __C3DShaderGetStandardUniforms_block_invoke()
{
  C3DShaderGetStandardUniforms_s_standardUniforms = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 20, MEMORY[0x263EFFF88], 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_time", @"float", 0, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseResolution", @"vec2", 1, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_modelTransform", @"mat4", 2, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseModelTransform", @"mat4", 3, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_modelViewTransform", @"mat4", 4, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseModelViewTransform", @"mat4", 5, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_normalTransform", @"mat4", 6, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_modelViewProjectionTransform", @"mat4", 7, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseModelViewProjectionTransform", @"mat4", 8, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_boundingBox", @"mat2x3", 10, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_worldBoundingBox", @"mat2x3", 11, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_viewTransform", @"mat4", 12, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseViewTransform", @"mat4", 13, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_projectionTransform", @"mat4", 14, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_inverseProjectionTransform", @"mat4", 15, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_cameraPosition", @"vec3", 17, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"u_viewToCubeWorld", @"mat4", 16, 0, 1);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.time", @"float", 0, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.invScreenPixelSize", @"float2", 1, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.modelTransform", @"float4x4", 2, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.inverseModelTransform", @"float4x4", 3, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.modelViewTransform", @"float4x4", 4, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.inverseModelViewTransform", @"float4x4", 5, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.normalTransform", @"float4x4", 6, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.modelViewProjectionTransform", @"float4x4", 7, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.inverseModelViewProjectionTransform", @"float4x4", 8, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.boundingBox", @"float2x3", 10, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_node.worldBoundingBox", @"float2x3", 11, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.viewTransform", @"float4x4", 12, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.inverseViewTransform", @"float4x4", 13, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.projectionTransform", @"float4x4", 14, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.inverseProjectionTransform", @"float4x4", 15, 0, 0);
  C3DShaderAddStandardUniform((const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms, @"scn_frame.cameraPosition", @"float3", 17, 0, 0);
  CFDictionaryRef v0 = (const __CFDictionary *)C3DShaderGetStandardUniforms_s_standardUniforms;

  C3DShaderAddStandardUniform(v0, @"scn_frame.viewToCubeWorld", @"float4x4", 16, 0, 0);
}

void C3DShaderAddStandardUniform(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (CFDictionaryGetValue(a1, a2))
  {
    BOOL v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DShaderAddStandardUniform_cold_1((uint64_t)a2, v12);
    }
  }
  unint64_t v13 = C3DMalloc(0x20uLL);
  v13[1] = a4;
  _OWORD v13[2] = a5;
  *unint64_t v13 = a3;
  *((_DWORD *)v13 + 6) = a6;
  CFDictionarySetValue(a1, a2, v13);
}

void *C3DMalloc(size_t a1)
{
  return malloc_type_malloc(a1, 0xDC03DFB5uLL);
}

void C3DNodeSetPosition(uint64_t a1, __n128 a2)
{
  C3DTransformSetPosition((__n128 *)(a1 + 96), a2);

  __C3DNodeTransformDidChange((float32x4_t *)a1);
}

__n128 C3DTransformSetPosition(__n128 *a1, __n128 result)
{
  result.n128_u32[3] = 1.0;
  a1[3] = result;
  return result;
}

void __HandleMaterialDidChangeNotifications(void *key, __int16 a2, uint64_t a3)
{
  context[2] = *MEMORY[0x263EF8340];
  if (a2 == 2)
  {
    if ((a2 & 0x200) != 0)
    {
      CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)a3 + 40), key);
      if (Value)
      {
        CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], Value);
        context[0] = a3;
        context[1] = key;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__ApplyMaterialDidChange, context);
        CFRelease(Copy);
      }
    }
  }
  else
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      __HandleMaterialDidChangeNotifications_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
}

void _C3DTransactionCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[8];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[9];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[10];
  if (v6)
  {
    _Block_release(v6);
  }
}

void *___setupTransactionIfNeeded_block_invoke()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  pthread_key_create((pthread_key_t *)&gTransactionKey, (void (__cdecl *)(void *))C3DTransactionThreadDied);
  memset(&v1, 0, sizeof(v1));
  pthread_rwlockattr_init(&v1);
  pthread_rwlock_init(&gCommandQueueFlushLock, &v1);
  pthread_rwlockattr_destroy(&v1);
  uint64_t result = C3DAllocatorCreate(48, 2048);
  gCommandAllocator = (uint64_t)result;
  return result;
}

void C3DEngineContextSetupWithScene(const void *a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  C3DEngineContextSetScene((uint64_t)a1, a2);
  if (a2)
  {
    if (!C3DSceneGetRootNode((uint64_t)a2))
    {
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
      }
    }
    C3DFXInvalidatePasses((uint64_t)a1);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterAddObserver(SharedInstance, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))_C3DEngineContextInvalidatePasses, @"kC3DNotificationEngineContextInvalidatePasses", a2, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  else
  {
    uint64_t v21 = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterRemoveObserver(v21, a1, @"kC3DNotificationEngineContextInvalidatePasses", 0);
  }
  _setupRendererContextWithSceneOptions((uint64_t)a1);
}

void _setupRendererContextWithSceneOptions(uint64_t a1)
{
  uint64_t Scene = C3DEngineContextGetScene(a1);
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
  if (Scene)
  {
    uint64_t v4 = RendererContextGL;
    if (RendererContextGL)
    {
      CFArrayRef Attribute = (const void *)C3DSceneGetAttribute(Scene, @"triggerOptionsForRealtimeViewer");
      if (!Attribute) {
        CFArrayRef Attribute = (const void *)*MEMORY[0x263EFFB38];
      }
      if (CFEqual(Attribute, (CFTypeRef)*MEMORY[0x263EFFB40]))
      {
        double v6 = COERCE_DOUBLE(vdup_n_s32(0x44800000u));
        C3DRendererContextSetMaxTextureSize(v4, v6);
      }
    }
  }
}

uint64_t C3DFXInvalidatePasses(uint64_t a1)
{
  uint64_t result = C3DEngineContextGetFXContext(a1);
  if (result) {
    *(unsigned char *)(result + 121) &= ~1u;
  }
  return result;
}

uint64_t C3DSceneGetRootNode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

uint64_t C3DSceneCreate()
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (C3DSceneGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSceneGetTypeID_onceToken, &__block_literal_global_66);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DSceneGetTypeID_typeID, 0x1A0uLL);
  uint64_t v1 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 4_Block_object_dispose(&STACK[0x380], 8) = Instance;
    *(void *)(Instance + 72) = C3DAnimationManagerCreate();
    *(void *)(v1 + 80) = C3DConstraintManagerCreate(v1);
    *(void *)(v1 + 96) = C3DModelValueStorageCreate();
    *(void *)(v1 + 12_Block_object_dispose(&STACK[0x380], 8) = C3DLightingSystemCreate(v1);
    *(void *)(v1 + 136) = C3DDynamicBatchingSystemCreate();
    *(void *)(v1 + 192) = 0x3F80000042700000;
    *(_DWORD *)(v1 + 212) = 1065353216;
    if ((C3DWasLinkedBeforeMajorOSYear2017() & 1) == 0) {
      *(_DWORD *)(v1 + 224) = 1065353216;
    }
    *(void *)(v1 + 32_Block_object_dispose(&STACK[0x380], 8) = 0;
    *(_DWORD *)(v1 + 336) = 1065353216;
    C3DColor4Make((float *)(v1 + 352), 1.0, 1.0, 1.0, 1.0);
    *(unsigned char *)(v1 + 36_Block_object_dispose(&STACK[0x380], 8) = 0;
    *(_WORD *)(v1 + 370) = 64;
    *(void *)(v1 + 372) = 0x41000000447A0000;
    *(void *)(v1 + 120) = C3DEnginePipelineCreate(v1);
    uint64_t v2 = (__C3DTransformTree *)C3DTransformTreeCreate(v1);
    *(void *)(v1 + 152) = v2;
    C3DCullingSystemCreate(v2);
    *(void *)(v1 + 144) = v3;
    C3DAnimationManagerSetModelValueStorage(*(void *)(v1 + 72), *(CFTypeRef *)(v1 + 96));
    v5.__sig = 0;
    *(void *)v5.__opaque = 0;
    pthread_mutexattr_init(&v5);
    pthread_mutexattr_settype(&v5, 2);
    pthread_mutex_init((pthread_mutex_t *)(v1 + 232), &v5);
    pthread_mutexattr_destroy(&v5);
  }
  return v1;
}

void __C3DCullingSystem::__C3DCullingSystem(__C3DCullingSystem *this, __C3DTransformTree *a2)
{
  *((void *)this + 2) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 14) = -1;
  *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = 0;
  *((void *)this + 12) = 0;
  int v4 = C3DGetCPUCaps();
  if ((v4 & 0x20) != 0) {
    int v5 = 8;
  }
  else {
    int v5 = 4;
  }
  *((_DWORD *)this + 6) = v5;
  *((_DWORD *)this + 7) = v4;
  __C3DCullingSystem::_allocateData(this, 0x80u);
  uint64_t v6 = (__C3DTransformTree *)*((void *)this + 17);
  if (v6 != a2)
  {
    if (v6)
    {
      CFRelease(v6);
      *((void *)this + 17) = 0;
    }
    if (a2) {
      CFTypeRef v7 = CFRetain(a2);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *((void *)this + 17) = v7;
  }
  if ((*((_DWORD *)this + 7) & 0x20) != 0)
  {
    *((void *)this + 19) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 1_Block_object_dispose(&STACK[0x380], 8) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 22) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 23) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 24) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 20) = C3DParticleManagerGetUpdateQueue();
    *((void *)this + 21) = C3DParticleManagerGetUpdateQueue();
  }
  else
  {
    int v8 = *((_DWORD *)this + 6);
    if (v8 == 4) {
      uint64_t v9 = C3DCullingSystem_AABBRange_x4;
    }
    else {
      uint64_t v9 = (uint64_t (*)(uint64_t, unsigned int, unsigned int))C3DCullingSystem_AABBRange_x1;
    }
    uint64_t v10 = C3DCullingSystem_AABBRange_x8;
    if (v8 == 4) {
      uint64_t v11 = C3DCullingSystem_MergeAABBRange_x4;
    }
    else {
      uint64_t v11 = (double (*)(uint64_t, unsigned int, int))C3DCullingSystem_MergeAABBRange_x1;
    }
    if (v8 == 4) {
      uint64_t v12 = C3DCullingSystem_CullRange_x4<false,false>;
    }
    else {
      uint64_t v12 = C3DCullingSystem_CullRange_x1<false,false>;
    }
    if (v8 == 4) {
      uint64_t v13 = C3DCullingSystem_CullRange_x4<false,true>;
    }
    else {
      uint64_t v13 = (uint64_t (*)(uint64_t))C3DCullingSystem_CullRange_x1<false,true>;
    }
    uint64_t v14 = C3DCullingSystem_CullRange_x1<true,false>;
    if (v8 == 4) {
      uint64_t v14 = C3DCullingSystem_CullRange_x4<true,false>;
    }
    if (v8 != 8) {
      uint64_t v10 = v9;
    }
    *((void *)this + 19) = v10;
    if (v8 == 8) {
      uint64_t v15 = C3DCullingSystem_MergeAABBRange_x8;
    }
    else {
      uint64_t v15 = v11;
    }
    *((void *)this + 1_Block_object_dispose(&STACK[0x380], 8) = v15;
    if (v8 == 8) {
      uint64_t v16 = C3DCullingSystem_CullRange_x8<false,false>;
    }
    else {
      uint64_t v16 = (uint64_t (*)(int32x2_t *, unsigned int, unsigned int))v12;
    }
    if (v8 == 8) {
      uint64_t v17 = C3DCullingSystem_CullRange_x8<false,true>;
    }
    else {
      uint64_t v17 = v13;
    }
    *((void *)this + 22) = v16;
    *((void *)this + 23) = v17;
    if (v8 == 8) {
      uint64_t v18 = C3DCullingSystem_CullRange_x8<true,false>;
    }
    else {
      uint64_t v18 = (uint64_t (*)(int32x2_t *, unsigned int, unsigned int))v14;
    }
    *((void *)this + 24) = v18;
    uint64_t v19 = C3DCullingSystem_RayRange_x8<true>;
    CFIndex v20 = C3DCullingSystem_RayRange_x8<false>;
    if (v8 != 8)
    {
      if (v8 == 4)
      {
        uint64_t v19 = C3DCullingSystem_RayRange_x4<true>;
        CFIndex v20 = C3DCullingSystem_RayRange_x4<false>;
      }
      else
      {
        uint64_t v19 = C3DCullingSystem_RayRange_x1<true>;
        CFIndex v20 = C3DCullingSystem_RayRange_x1<false>;
      }
    }
    *((void *)this + 20) = v20;
    *((void *)this + 21) = v19;
  }
}

void __C3DCullingSystem::_allocateData(__C3DCullingSystem *this, unsigned int a2)
{
  int v4 = *((_DWORD *)this + 5);
  int v5 = *((_DWORD *)this + 6);
  if (v5 == 8) {
    unint64_t v6 = 32;
  }
  else {
    unint64_t v6 = 16;
  }
  if (v5 == 8) {
    int v7 = 192;
  }
  else {
    int v7 = 0;
  }
  if (v5 == 4) {
    int v7 = 96;
  }
  int v8 = v5 - 1;
  if (v5 == 1) {
    int v9 = 32;
  }
  else {
    int v9 = v7;
  }
  int v10 = C3DLog2OfPowerOf2::deBruijnPosition[(125613361 * v5) >> 27];
  size_t v11 = (v9 * (v8 + a2)) >> v10;
  uint64_t v12 = (v4 + 7) >> 3;
  unsigned int v13 = (a2 + 7) >> 3;
  if (*((void *)this + 8))
  {
    size_t v14 = ((v4 + v8) * v9) >> v10;
    *((void *)this + 14) = malloc_type_realloc(*((void **)this + 14), (a2 + 7) >> 3, 0xC64850EDuLL);
    *((void *)this + 12) = _mm_realloc(*((void **)this + 12), v14, v11, v6);
    *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = _mm_realloc(*((void **)this + 8), 32 * *((unsigned int *)this + 5), 32 * a2, v6);
    *((void *)this + 13) = _mm_realloc(*((void **)this + 13), 8 * *((unsigned int *)this + 5), 8 * a2, v6);
    *((void *)this + 9) = _mm_realloc(*((void **)this + 9), 4 * *((unsigned int *)this + 5), 4 * a2, v6);
    *((void *)this + 10) = _mm_realloc(*((void **)this + 10), 4 * *((unsigned int *)this + 5), 4 * a2, v6);
    *((void *)this + 11) = _mm_realloc(*((void **)this + 11), 2 * *((unsigned int *)this + 5), 2 * a2, v6);
  }
  else
  {
    *((void *)this + 14) = malloc_type_malloc((a2 + 7) >> 3, 0xDCA4A6E3uLL);
    memptr = 0;
    int v15 = malloc_type_posix_memalign(&memptr, v6, v11, 0xBA8A1232uLL);
    uint64_t v16 = memptr;
    if (v15) {
      uint64_t v16 = 0;
    }
    *((void *)this + 12) = v16;
    memptr = 0;
    int v17 = malloc_type_posix_memalign(&memptr, v6, 32 * a2, 0xBA8A1232uLL);
    uint64_t v18 = memptr;
    if (v17) {
      uint64_t v18 = 0;
    }
    *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = v18;
    memptr = 0;
    int v19 = malloc_type_posix_memalign(&memptr, v6, 8 * a2, 0xBA8A1232uLL);
    CFIndex v20 = memptr;
    if (v19) {
      CFIndex v20 = 0;
    }
    *((void *)this + 13) = v20;
    memptr = 0;
    int v21 = malloc_type_posix_memalign(&memptr, v6, 4 * a2, 0xBA8A1232uLL);
    uint64_t v22 = memptr;
    if (v21) {
      uint64_t v22 = 0;
    }
    *((void *)this + 9) = v22;
    memptr = 0;
    int v23 = malloc_type_posix_memalign(&memptr, v6, 4 * a2, 0xBA8A1232uLL);
    CFIndex v24 = memptr;
    if (v23) {
      CFIndex v24 = 0;
    }
    *((void *)this + 10) = v24;
    memptr = 0;
    int v25 = malloc_type_posix_memalign(&memptr, v6, 2 * a2, 0xBA8A1232uLL);
    uint64_t v26 = memptr;
    if (v25) {
      uint64_t v26 = 0;
    }
    *((void *)this + 11) = v26;
  }
  size_t v27 = v13 - v12;
  if ((int)v27 >= 1) {
    bzero((void *)(*((void *)this + 14) + v12), v27);
  }
  uint64_t v28 = *((unsigned int *)this + 5);
  unsigned int v29 = a2 - v28;
  if ((int)(a2 - v28) >= 1)
  {
    bzero((void *)(*((void *)this + 13) + 8 * v28), 8 * (a2 - v28));
    bzero((void *)(*((void *)this + 9) + 4 * *((unsigned int *)this + 5)), 4 * v29);
    bzero((void *)(*((void *)this + 10) + 4 * *((unsigned int *)this + 5)), 4 * v29);
    bzero((void *)(*((void *)this + 11) + 2 * *((unsigned int *)this + 5)), 2 * v29);
    uint64_t v30 = *((unsigned int *)this + 5);
    if (v30 < a2)
    {
      __n128 v33 = *(__n128 *)(MEMORY[0x263EF89A8] + 48);
      uint64_t v31 = 32 * v30;
      do
      {
        uint64_t v32 = (__n128 *)(*((void *)this + 8) + v31);
        __n128 *v32 = v33;
        v32[1] = (__n128)xmmword_20B5CB570;
        __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, v30, v33, (__n128)xmmword_20B5CB570);
        LODWORD(v30) = v30 + 1;
        v31 += 32;
      }
      while (a2 != v30);
    }
  }
  *((_DWORD *)this + 5) = a2;
}

uint64_t __C3DCullingSystem::_setWorldAABBAtIndex(uint64_t result, unsigned int a2, __n128 a3, __n128 a4)
{
  int v4 = *(_DWORD *)(result + 24);
  if (v4 == 4)
  {
    uint64_t v5 = *(void *)(result + 96) + 96 * (a2 >> 2);
    *(_DWORD *)(v5 + 4 * (a2 & 3)) = a3.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 4)) = a3.n128_u32[1];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 8)) = a3.n128_u32[2];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 0xC)) = a4.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 0x10)) = a4.n128_u32[1];
    unsigned int v6 = a2 & 3 | 0x14;
    goto LABEL_5;
  }
  if (v4 == 8)
  {
    uint64_t v5 = *(void *)(result + 96) + 192 * (a2 >> 3);
    *(_DWORD *)(v5 + 4 * (a2 & 7)) = a3.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 8)) = a3.n128_u32[1];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x10)) = a3.n128_u32[2];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x18)) = a4.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x20)) = a4.n128_u32[1];
    unsigned int v6 = a2 & 7 | 0x28;
LABEL_5:
    *(_DWORD *)(v5 + 4 * v6) = a4.n128_u32[2];
    return result;
  }
  int v7 = (__n128 *)(*(void *)(result + 96) + 32 * a2);
  __n128 *v7 = a3;
  v7[1] = a4;
  return result;
}

uint64_t C3DTransformTreeCreate(uint64_t a1)
{
  if (C3DTransformTreeGetTypeID(void)::onceToken != -1) {
    dispatch_once(&C3DTransformTreeGetTypeID(void)::onceToken, &__block_literal_global_132);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTransformTreeGetTypeID(void)::typeID, 0x40uLL);
  *(void *)(Instance + 16) = a1;
  *(void *)(Instance + 24) = 0;
  *(void *)(Instance + 32) = 0;
  *(void *)(Instance + 40) = 0;
  *(_DWORD *)(Instance + 4_Block_object_dispose(&STACK[0x380], 8) = -1;
  *(void *)(Instance + 56) = 0;
  *(_DWORD *)(Instance + 64) = 0;
  *(void *)(Instance + 72) = 0;
  __C3DTransformTree::_setLevelCount((__C3DTransformTree *)Instance, 1);
  return Instance;
}

void __C3DTransformTree::_setLevelCount(__C3DTransformTree *this, int a2)
{
  if (*((_DWORD *)this + 16) != a2)
  {
    int v4 = (char *)malloc_type_calloc(0x50uLL, a2, 0xC1404B04uLL);
    uint64_t v5 = v4;
    int v6 = *((_DWORD *)this + 16);
    if (v6 >= a2)
    {
      if (a2 < 1)
      {
        int v20 = 0;
      }
      else
      {
        uint64_t v14 = 0;
        do
        {
          int v15 = &v4[v14];
          uint64_t v16 = (_OWORD *)(*((void *)this + 7) + v14);
          *(_OWORD *)int v15 = *v16;
          long long v17 = v16[1];
          long long v18 = v16[2];
          long long v19 = v16[4];
          *((_OWORD *)v15 + 3) = v16[3];
          *((_OWORD *)v15 + 4) = v19;
          *((_OWORD *)v15 + 1) = v17;
          *((_OWORD *)v15 + 2) = v18;
          v14 += 80;
        }
        while (80 * a2 != v14);
        int v6 = *((_DWORD *)this + 16);
        int v20 = a2;
      }
      if (v20 < v6)
      {
        uint64_t v23 = 80 * v20;
        do
        {
          C3DTransformLevel::deallocateData((void **)(*((void *)this + 7) + v23));
          v23 += 80;
          ++v20;
        }
        while (*((_DWORD *)this + 16) > v20);
      }
    }
    else
    {
      if (v6 < 1)
      {
        LODWORD(v_Block_object_dispose(&STACK[0x380], 8) = 0;
      }
      else
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        do
        {
          int v9 = &v4[v7];
          int v10 = (_OWORD *)(*((void *)this + 7) + v7);
          *(_OWORD *)int v9 = *v10;
          long long v11 = v10[1];
          long long v12 = v10[2];
          long long v13 = v10[4];
          *((_OWORD *)v9 + 3) = v10[3];
          *((_OWORD *)v9 + 4) = v13;
          *((_OWORD *)v9 + 1) = v11;
          *((_OWORD *)v9 + 2) = v12;
          ++v8;
          v7 += 80;
        }
        while (v8 < *((int *)this + 16));
      }
      if ((int)v8 < a2)
      {
        int v21 = (C3DTransformLevel *)&v4[80 * v8];
        unint64_t v22 = a2 - (unint64_t)v8;
        do
        {
          C3DTransformLevel::allocateData(v21, 0x80u);
          int v21 = (C3DTransformLevel *)((char *)v21 + 80);
          --v22;
        }
        while (v22);
      }
    }
    free(*((void **)this + 7));
    *((void *)this + 7) = v5;
    *((_DWORD *)this + 16) = a2;
  }
}

double C3DTransformLevel::allocateData(C3DTransformLevel *this, unsigned int a2)
{
  size_t v4 = (unint64_t)a2 << 6;
  uint64_t v5 = *((int *)this + 19);
  uint64_t v6 = v5 << 6;
  uint64_t v7 = *(void **)this;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = (char *)memptr;
  }
  if (v5) {
    memcpy(v8, v7, v5 << 6);
  }
  size_t v9 = (v4 - v6);
  if ((int)v9 >= 1) {
    bzero(&v8[v6], (v4 - v6));
  }
  if (v7) {
    free(v7);
  }
  *(void *)this = v8;
  int v10 = (void *)*((void *)this + 1);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    long long v11 = 0;
  }
  else {
    long long v11 = (char *)memptr;
  }
  if (v5) {
    memcpy(v11, v10, v5 << 6);
  }
  if ((int)v9 >= 1) {
    bzero(&v11[v6], (v4 - v6));
  }
  if (v10) {
    free(v10);
  }
  *((void *)this + 1) = v11;
  long long v12 = (void *)*((void *)this + 2);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    long long v13 = 0;
  }
  else {
    long long v13 = (char *)memptr;
  }
  if (v5) {
    memcpy(v13, v12, v5 << 6);
  }
  int v14 = 4 * a2;
  if ((int)v9 >= 1) {
    bzero(&v13[v6], v9);
  }
  uint64_t v15 = 4 * v5;
  if (v12) {
    free(v12);
  }
  *((void *)this + 2) = v13;
  uint64_t v16 = (void *)*((void *)this + 3);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    long long v17 = 0;
  }
  else {
    long long v17 = (char *)memptr;
  }
  if (v5) {
    memcpy(v17, v16, 4 * v5);
  }
  int v18 = v14 - v15;
  if (v14 - (int)v15 >= 1) {
    bzero(&v17[v15], (v14 - v15));
  }
  if (v16) {
    free(v16);
  }
  *((void *)this + 3) = v17;
  long long v19 = (void *)*((void *)this + 4);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    int v20 = 0;
  }
  else {
    int v20 = (char *)memptr;
  }
  if (v5) {
    memcpy(v20, v19, 4 * v5);
  }
  if (v18 >= 1) {
    bzero(&v20[v15], (v14 - v15));
  }
  uint64_t v21 = 8 * v5;
  if (v19) {
    free(v19);
  }
  *((void *)this + 4) = v20;
  unint64_t v22 = (void *)*((void *)this + 5);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 8 * a2, 0xBA8A1232uLL)) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (char *)memptr;
  }
  if (v5) {
    memcpy(v23, v22, 8 * v5);
  }
  size_t v24 = 8 * a2 - v21;
  if ((int)v24 >= 1) {
    bzero(&v23[v21], v24);
  }
  if (v22) {
    free(v22);
  }
  *((void *)this + 5) = v23;
  int v25 = (void *)*((void *)this + 6);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = (char *)memptr;
  }
  if (v5) {
    memcpy(v26, v25, 4 * v5);
  }
  if (v18 >= 1) {
    bzero(&v26[v15], (v14 - v15));
  }
  if (v25) {
    free(v25);
  }
  *((void *)this + 6) = v26;
  size_t v27 = (void *)*((void *)this + 7);
  uint64_t v28 = *((int *)this + 19);
  uint64_t v29 = 4 * v28;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = (char *)memptr;
  }
  if (v28) {
    memcpy(v30, v27, 4 * v28);
  }
  size_t v31 = (v14 - v29);
  if ((int)v31 >= 1) {
    bzero(&v30[v29], v31);
  }
  if (v27) {
    free(v27);
  }
  *((void *)this + 7) = v30;
  if ((int)v24 >= 1) {
    bzero((void *)(*((void *)this + 5) + v21), v24);
  }
  uint64_t v32 = a2 - 1;
  uint64_t v33 = *((unsigned int *)this + 19);
  uint64_t v34 = *((void *)this + 3);
  if (v33 < v32)
  {
    do
    {
      *(_DWORD *)(v34 + 4 * v33) = v33 + 1;
      ++v33;
    }
    while (v32 != v33);
  }
  *(_DWORD *)(v34 + 4 * v32) = -1;
  *(void *)&double result = 0x800000007FFFFFFFLL;
  *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = 0x800000007FFFFFFFLL;
  *((_DWORD *)this + 19) = a2;
  return result;
}

uint64_t C3DModelValueStorageCreate()
{
  if (C3DModelValueStorageGetTypeID_onceToken != -1) {
    dispatch_once(&C3DModelValueStorageGetTypeID_onceToken, &__block_literal_global_6_3);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DModelValueStorageGetTypeID_typeID, 0x20uLL);
  if (Instance) {
    *(void *)(Instance + 16) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
  }
  return Instance;
}

uint64_t C3DLightingSystemCreate(uint64_t a1)
{
  if (C3DLightingSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLightingSystemGetTypeID_onceToken, &__block_literal_global_70);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DLightingSystemGetTypeID_typeID, 0x1F910uLL);
  *(void *)(Instance + 16) = a1;
  *(void *)(Instance + 24) = C3DLightProbesSystemCreate();
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  *(void *)(Instance + 32) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, 0);
  *(void *)(Instance + 40) = CFDictionaryCreateMutable(v3, 0, 0, MEMORY[0x263EFFF90]);
  size_t v4 = (const CFSetCallBacks *)MEMORY[0x263EFFFA0];
  *(void *)(Instance + 496) = CFSetCreateMutable(v3, 0, MEMORY[0x263EFFFA0]);
  CFMutableSetRef Mutable = CFSetCreateMutable(v3, 0, v4);
  uint64_t v6 = 0;
  *(void *)(Instance + 48_Block_object_dispose(&STACK[0x380], 8) = Mutable;
  *(_DWORD *)(Instance + 116504) = -1;
  uint64_t v7 = Instance + 117008;
  do
  {
    for (uint64_t i = 0; i != 1536; i += 384)
      *(void *)(v7 + i) = C3DConvexPolyhedronCreate();
    ++v6;
    v7 += 1568;
  }
  while (v6 != 8);
  return Instance;
}

uint64_t C3DConvexPolyhedronCreate()
{
  if (C3DConvexPolyhedronGetTypeID::onceToken != -1) {
    dispatch_once(&C3DConvexPolyhedronGetTypeID::onceToken, &__block_literal_global_18);
  }
  CFTypeID v0 = C3DConvexPolyhedronGetTypeID::typeID;

  return C3DTypeCreateInstance_(v0, 0x90uLL);
}

uint64_t C3DLightProbesSystemCreate()
{
  if (C3DLightProbesSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLightProbesSystemGetTypeID_onceToken, &__block_literal_global_52);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DLightProbesSystemGetTypeID_typeID, 0xF0uLL);
  *(_DWORD *)(result + 232) = 3;
  return result;
}

uint64_t C3DGetCPUCaps()
{
  uint64_t result = C3DGetCPUCaps_cpuCaps;
  if (C3DGetCPUCaps_cpuCaps == -1)
  {
    C3DGetCPUCaps_cpuCaps = 0;
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse2", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 1u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse3", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 2u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.supplementalsse3", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 2u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_1", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 8u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_2", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 0x10u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.avx1_0", &v3, &v2, 0, 0) && v3) {
      C3DGetCPUCaps_cpuCaps |= 0x20u;
    }
    int v3 = 0;
    size_t v2 = 4;
    int v1 = sysctlbyname("hw.optional.fma", &v3, &v2, 0, 0);
    uint64_t result = C3DGetCPUCaps_cpuCaps;
    if (!v1)
    {
      if (v3)
      {
        uint64_t result = C3DGetCPUCaps_cpuCaps | 0x40u;
        C3DGetCPUCaps_cpuCaps |= 0x40u;
      }
    }
  }
  return result;
}

uint64_t C3DDynamicBatchingSystemCreate()
{
  if (C3DDynamicBatchingSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DDynamicBatchingSystemGetTypeID_onceToken, &__block_literal_global_98);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DDynamicBatchingSystemGetTypeID_typeID, 0x20uLL);
  *(void *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  uint64_t Integer = C3DPreferencesGetInteger(4);
  if (Integer) {
    uint64_t v2 = Integer;
  }
  else {
    uint64_t v2 = 1000;
  }
  C3DDynamicBatchingSystemSetMaxBatchSize(Instance, v2);
  return Instance;
}

uint64_t C3DPreferencesGetInteger(int a1)
{
  if (C3DPreferencesGetInteger_onceToken != -1) {
    dispatch_once(&C3DPreferencesGetInteger_onceToken, &__block_literal_global_129);
  }
  return C3DPreferencesGetInteger_prefs[a1];
}

void *C3DDynamicBatchingSystemSetMaxBatchSize(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 32))
  {
    size_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DDynamicBatchingSystemSetMaxBatchSize_cold_1(v4);
    }
  }
  if (a2 <= 1) {
    a2 = 1;
  }
  free(*(void **)(a1 + 24));
  uint64_t result = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 24) = result;
  return result;
}

void C3DCullingSystemCreate(__C3DTransformTree *a1)
{
  if (C3DCullingSystemGetTypeID(void)::onceToken != -1) {
    dispatch_once(&C3DCullingSystemGetTypeID(void)::onceToken, &__block_literal_global_16);
  }
  uint64_t Instance = (__C3DCullingSystem *)C3DTypeCreateInstance_(C3DCullingSystemGetTypeID(void)::typeID, 0xB8uLL);

  __C3DCullingSystem::__C3DCullingSystem(Instance, a1);
}

uint64_t C3DConstraintManagerCreate(uint64_t a1)
{
  if (C3DConstraintManagerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintManagerGetTypeID_onceToken, &__block_literal_global_126);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DConstraintManagerGetTypeID_typeID, 0x18uLL);
  *(void *)(result + 24) = a1;
  return result;
}

CFTypeRef C3DAnimationManagerSetModelValueStorage(uint64_t a1, CFTypeRef cf)
{
  if (!a1 && (size_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  long long v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DAnimationManagerSetModelValueStorage_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t C3DAnimationManagerCreate()
{
  if (C3DAnimationManagerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationManagerGetTypeID_onceToken, &__block_literal_global_19);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DAnimationManagerGetTypeID_typeID, 0xA0uLL);
  if (Instance)
  {
    *(void *)(Instance + 24) = C3DArrayCreate(256, 64);
    *(void *)(Instance + 32) = CFDictionaryCreateMutable(0, 0, 0, 0);
    *(void *)(Instance + 4_Block_object_dispose(&STACK[0x380], 8) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
    *(void *)(Instance + 56) = CFSetCreateMutable(0, 0, MEMORY[0x263EFFFA0]);
    *(void *)(Instance + 80) = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    *(void *)(Instance + 112) = C3DAllocatorCreate(40, 64);
    *(_DWORD *)(Instance + 64) = 0;
  }
  return Instance;
}

uint64_t *C3DEnginePipelineCreate(uint64_t a1)
{
  if (C3DEnginePipelineGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEnginePipelineGetTypeID_onceToken, &__block_literal_global_46);
  }
  uint64_t Instance = (uint64_t *)C3DTypeCreateInstance_(C3DEnginePipelineGetTypeID_typeID, 0x50uLL);
  Instance[5] = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  Instance[6] = (uint64_t)C3DRendererElementStoreCreate();
  Instance[2] = a1;
  if (Instance[3])
  {
    int v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup", v8, 2u);
    }
    size_t v4 = (const void *)Instance[3];
    if (v4)
    {
      CFRelease(v4);
      Instance[3] = 0;
    }
  }
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterAddObserver(SharedInstance, Instance, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))__HandleNodeWillDieNotification, @"kC3DNotificationNodeWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  if (!Instance[4])
  {
    uint64_t v6 = (unsigned char *)C3DEngineNotificationQueueCreate(Instance[2]);
    Instance[4] = (uint64_t)v6;
    C3DEngineNotificationQueueStartObserving(v6);
  }
  return Instance;
}

void *C3DRendererElementStoreCreate()
{
  if (C3DRendererElementStoreGetTypeID_onceToken != -1) {
    dispatch_once(&C3DRendererElementStoreGetTypeID_onceToken, &__block_literal_global_134);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DRendererElementStoreGetTypeID_typeID, 0x18uLL);
  Instance[3] = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  Instance[4] = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  Instance[2] = C3DSpanAllocatorCreate(80, 4096);
  return Instance;
}

void *C3DIndexStoreCreateWithCapacity(uint64_t a1)
{
  if (C3DIndexStoreGetTypeID_onceToken != -1) {
    dispatch_once(&C3DIndexStoreGetTypeID_onceToken, &__block_literal_global_135);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DIndexStoreGetTypeID_typeID, 0x40uLL);
  Instance[2] = CFDictionaryCreateMutable(0, 0, 0, 0);
  Instance[3] = C3DIndexSetCreateMutable();
  Instance[4] = 0;
  Instance[5] = a1;
  Instance[6] = C3DAllocatorCreate(16, 4096);
  C3DIndexSetAddIndexesInRange(Instance[3], 0, a1);
  return Instance;
}

void *C3DAllocatorCreate(uint64_t a1, uint64_t a2)
{
  if (C3DAllocatorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAllocatorGetTypeID_onceToken, &__block_literal_global_136);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DAllocatorGetTypeID_typeID, 0x38uLL);
  Instance[5] = C3DIndexSetCreateMutable();
  Instance[2] = a1;
  Instance[3] = a2;
  return Instance;
}

uint64_t C3DIndexSetCreateMutable()
{
  uint64_t result = C3DIndexSetCreate();
  *(unsigned char *)(result + 16) |= 0xBu;
  return result;
}

uint64_t C3DIndexSetCreate()
{
  if (C3DIndexSetGetTypeID_onceToken != -1) {
    dispatch_once(&C3DIndexSetGetTypeID_onceToken, &__block_literal_global_59);
  }
  CFTypeID v0 = C3DIndexSetGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x18uLL);
}

uint64_t C3DSpanAllocatorCreate(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (C3DSpanAllocatorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSpanAllocatorGetTypeID_onceToken, &__block_literal_global_143);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DSpanAllocatorGetTypeID_typeID, 0x28uLL);
  *(void *)(Instance + 40) = a1;
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x380], 8) = a2;
  *(void *)uint64_t v7 = 0x1000000006;
  size_t v6 = 4;
  if (sysctl(v7, 2u, (void *)(Instance + 32), &v6, 0, 0) < 0) {
    *(_DWORD *)(Instance + 32) = 64;
  }
  return Instance;
}

void C3DEngineNotificationQueueStartObserving(unsigned char *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineNotificationQueueStartObserving_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterAddObserver(SharedInstance, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))__EnqueueNotification, @"kC3DNotificationEntityAttributeDidChange", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  a1[49] = 1;
}

uint64_t C3DEngineNotificationQueueCreate(uint64_t a1)
{
  if (C3DEngineNotificationQueueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEngineNotificationQueueGetTypeID_onceToken, &__block_literal_global_97);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DEngineNotificationQueueGetTypeID_typeID, 0x30uLL);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  *(void *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  *(void *)(Instance + 24) = CFDictionaryCreateMutable(v3, 0, 0, v4);
  *(void *)(Instance + 56) = a1;
  *(_DWORD *)(Instance + 32) = 0;
  return Instance;
}

float C3DSceneGetSSRStride(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 376);
}

uint64_t C3DSceneGetSSRSampleCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int16 *)(a1 + 370);
}

float C3DSceneGetSSRMaxRayDistance(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 372);
}

float C3DSceneGetFogStartDistance(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 328);
}

float C3DSceneGetFogDensityExponent(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 336);
}

uint64_t __ApplyMaterialDidChange(uint64_t a1, uint64_t **a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  long long v12 = *a2;
  if (!*a2)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      __ApplyMaterialDidChange_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  uint64_t Node = C3DRendererElementGetNode(a1);
  if (Node) {
    C3DNodeBoundingBoxDidUpdate(Node);
  }
  return C3DEnginePipelineSyncRendererElement(*v12, a1, 27);
}

uint64_t C3DEnginePipelineSyncRendererElement(uint64_t a1, uint64_t a2, int a3)
{
  C3DRendererElementStoreSyncRendererElement(*(void *)(a1 + 48), a2, a3);
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    v7[0] = MEMORY[0x263EF8330];
    v7[1] = 3221225472;
    int v7[2] = __C3DEnginePipelineSyncRendererElement_block_invoke;
    v7[3] = &__block_descriptor_44_e29_v16__0____C3DEngineContext__8l;
    v7[4] = a2;
    int v8 = a3;
    return C3DSceneEnumerateEngineContexts(result, (uint64_t)v7);
  }
  return result;
}

uint64_t C3DSceneUnlock(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
}

uint64_t C3DSceneEnumerateEngineContexts(uint64_t a1, uint64_t a2)
{
  C3DSceneLock(a1);
  if (*(_WORD *)(a1 + 168))
  {
    if (*(_WORD *)(a1 + 168) == 1)
    {
      (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(a1 + 160));
    }
    else
    {
      unint64_t v4 = 0;
      do
        (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(*(void *)(a1 + 160) + 8 * v4++));
      while (v4 < *(unsigned __int16 *)(a1 + 168));
    }
  }

  return C3DSceneUnlock(a1);
}

void *__C3DEnginePipelineSyncRendererElement_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a2);
  C3DProgramHashCodeStoreInvalidateRendererElement(ProgramHashCodeStore, *(unsigned int **)(a1 + 32));
  SortSysteCFIndex m = C3DEngineContextGetSortSystem(a2);
  uint64_t v6 = *(unsigned int **)(a1 + 32);

  return C3DSortSystemInvalidateKeyForRendererElement(SortSystem, v6);
}

uint64_t C3DEngineContextGetSortSystem(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 184);
}

void *C3DSortSystemInvalidateKeyForRendererElement(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = *a2;
  uint64_t result = (void *)C3DArrayGetCapacity(*(void *)(a1 + 16));
  if ((uint64_t)result > v3)
  {
    uint64_t result = (void *)C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 16), v3);
    *uint64_t result = -1;
  }
  return result;
}

uint64_t C3DArrayGetCapacity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 28);
}

void C3DProgramHashCodeStoreInvalidateRendererElement(uint64_t a1, unsigned int *a2)
{
  if (*(_DWORD *)(a1 + 44) != -15)
  {
    unint64_t v3 = 0;
    uint64_t v4 = *a2;
    do
    {
      if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v3))
      {
        uint64_t v5 = *(void *)(a1 + 24);
        if (C3DArrayGetCount(*(void *)(v5 + 8 * v3)) > v4)
        {
          ValuePtrAtIndex = (void **)C3DArrayGetValuePtrAtIndex(*(void *)(v5 + 8 * v3), v4);
          if (*ValuePtrAtIndex)
          {
            uint64_t v7 = ValuePtrAtIndex;
            C3DIndexStoreRemoveIndexForKey(*(void *)(a1 + 48), *ValuePtrAtIndex);
            void *v7 = 0;
          }
        }
      }
      ++v3;
    }
    while (v3 < (*(_DWORD *)(a1 + 44) + 15));
  }
}

uint64_t C3DSceneLock(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
}

CFIndex C3DEnginePipelineApplyNotificationQueue(uint64_t *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __ApplyMaterialDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *a1;
  uint64_t NotificationQueue = C3DEnginePipelineGetNotificationQueue(*a1);
  uint64_t v12 = NotificationQueue;
  if (NotificationQueue) {
    int v13 = C3DEngineNotificationQueueNeedsFullReset(NotificationQueue);
  }
  else {
    int v13 = 0;
  }
  uint64_t PointOfViewIfAny = C3DEngineContextGetPointOfViewIfAny(a1[1]);
  int v16 = PointOfViewIfAny
     && (CamerSCNMatrix4 a = C3DNodeGetCamera(PointOfViewIfAny)) != 0
     && C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) > 0.0;
  int v17 = *(unsigned __int8 *)(v10 + 58);
  BOOL v18 = v17 != v16;
  if (v17 != v16) {
    *(unsigned char *)(v10 + 5_Block_object_dispose(&STACK[0x380], 8) = v16;
  }
  int v19 = C3DSceneGetFogEndDistance(*(void *)(v10 + 16)) > 0.0;
  if (*(unsigned __int8 *)(v10 + 56) != v19)
  {
    *(unsigned char *)(v10 + 56) = v19;
    BOOL v18 = 1;
  }
  if (!C3DEngineContextIsClusteredShadingEnabled(a1[1])
    || (LightingSysteCFIndex m = (const __CFDictionary *)C3DSceneGetLightingSystem(*(void *)(v10 + 16))) == 0)
  {
    if (!v18) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if ((v18 | C3DLightingSystemGetGlobalLightHashCodeForCaching(LightingSystem, a1[1], v10 + 60))) {
LABEL_20:
  }
    C3DRendererElementStoreApplyForAllRendererElements(*(void *)(v10 + 48), (uint64_t)__ResyncRendererElements, v10);
LABEL_21:
  if (v12)
  {
    C3DEngineNotificationQueueSwapForApplying(v12);
    if (v13)
    {
      __ResyncAllNodes(a1);
    }
    else
    {
      TypeID = (const void *)C3DNodeGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, TypeID, (void (__cdecl *)(const void *, const void *, void *))__HandleNodeNotification, a1);
      unint64_t v22 = (const void *)C3DGeometryGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v22, (void (__cdecl *)(const void *, const void *, void *))__HandleGeometryDidChangeNotifications, a1);
      uint64_t v23 = (const void *)C3DMaterialGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v23, (void (__cdecl *)(const void *, const void *, void *))__HandleMaterialDidChangeNotifications, a1);
      size_t v24 = (const void *)C3DLightGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v24, (void (__cdecl *)(const void *, const void *, void *))__HandleLightDidChangeNotifications, a1);
    }
  }
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(v10);
  unsigned int Capacity = C3DRendererElementStoreGetCapacity(RendererElementStore);
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a1[1]);
  C3DProgramHashCodeStoreSetCapacity(ProgramHashCodeStore, Capacity);
  SortSysteCFIndex m = C3DEngineContextGetSortSystem(a1[1]);
  C3DSortSystemSetCapacity(SortSystem, Capacity);
  return C3DSortSystemPrepare(SortSystem, v10);
}

void C3DEngineNotificationQueueApplyForEntityType(uint64_t a1, const void *a2, void (__cdecl *a3)(const void *, const void *, void *), void *a4)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFDictionaryApplyFunction(Value, a3, a4);
  }
}

CFDictionaryRef __CFTypeIsC3DEntity_block_invoke()
{
  keys[40] = *(void **)MEMORY[0x263EF8340];
  if (CFTypeIsC3DEntity__cfTypeRegistry)
  {
    CFTypeID v0 = scn_default_log();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT)) {
      __CFTypeIsC3DEntity_block_invoke_cold_1(v0, v1, v2, v3, v4, v5, v6, v7);
    }
  }
  keys[0] = (void *)C3DGeometryGetTypeID();
  keys[1] = (void *)C3DMeshGetTypeID();
  keys[2] = (void *)C3DAnimationPlayerGetTypeID();
  keys[3] = (void *)C3DAnimationGroupGetTypeID();
  keys[4] = (void *)C3DAnimationClusterGetTypeID();
  keys[5] = (void *)C3DKeyframedAnimationGetTypeID();
  keys[6] = (void *)C3DMaterialGetTypeID();
  keys[7] = (void *)C3DImageGetTypeID();
  keys[8] = (void *)C3DMeshElementGetTypeID();
  keys[9] = (void *)C3DNodeGetTypeID();
  keys[10] = (void *)C3DCameraGetTypeID();
  keys[11] = (void *)C3DLightGetTypeID();
  keys[12] = (void *)C3DSkinGetTypeID();
  keys[13] = (void *)C3DSkinnerGetTypeID();
  keys[14] = (void *)C3DGenericSourceGetTypeID();
  keys[15] = (void *)C3DMeshSourceGetTypeID();
  keys[16] = (void *)C3DMorphGetTypeID();
  keys[17] = (void *)C3DMorpherGetTypeID();
  keys[18] = (void *)C3DSceneGetTypeID();
  keys[19] = (void *)C3DParametricGeometryGetTypeID();
  keys[20] = (void *)C3DShapeGeometryGetTypeID();
  keys[21] = (void *)C3DTextGeometryGetTypeID();
  keys[22] = (void *)C3DBezierCurveGeometryGetTypeID();
  keys[23] = (void *)C3DFloorGetTypeID();
  keys[24] = (void *)C3DFXTechniqueGetTypeID();
  keys[25] = (void *)C3DFXMetalProgramGetTypeID();
  keys[26] = (void *)C3DFXGLSLProgramGetTypeID();
  keys[27] = (void *)C3DLODGetTypeID();
  keys[28] = (void *)C3DParticleSystemGetTypeID();
  keys[29] = (void *)C3DConstraintIKGetTypeID();
  keys[30] = (void *)C3DConstraintLookAtGetTypeID();
  keys[31] = (void *)C3DConstraintBillboardGetTypeID();
  keys[32] = (void *)C3DConstraintProceduralGetTypeID();
  keys[33] = (void *)C3DConstraintConstantScaleGetTypeID();
  keys[34] = (void *)C3DConstraintDistanceGetTypeID();
  keys[35] = (void *)C3DConstraintAccelerationGetTypeID();
  keys[36] = (void *)C3DConstraintSliderGetTypeID();
  keys[37] = (void *)C3DConstraintReplicatorGetTypeID();
  keys[38] = (void *)C3DConstraintAvoidOccluderGetTypeID();
  TypeID = (void *)C3DKeyValueStoreGetTypeID();
  uint64_t v9 = 0;
  keys[39] = TypeID;
  memset(v12, 0, sizeof(v12));
  int64x2_t v10 = vdupq_n_s64(1uLL);
  do
    v12[v9++] = v10;
  while (v9 != 20);
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)keys, (const void **)v12, 40, 0, 0);
  CFTypeIsC3DEntity__cfTypeRegistry = (uint64_t)result;
  return result;
}

uint64_t C3DImageGetTypeID()
{
  if (C3DImageGetTypeID_onceToken != -1) {
    dispatch_once(&C3DImageGetTypeID_onceToken, &__block_literal_global_28);
  }
  return C3DImageGetTypeID_typeID;
}

uint64_t C3DLightGetTypeID()
{
  if (C3DLightGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLightGetTypeID_onceToken, &__block_literal_global_60);
  }
  return C3DLightGetTypeID_typeID;
}

uint64_t C3DSceneGetTypeID()
{
  if (C3DSceneGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSceneGetTypeID_onceToken, &__block_literal_global_66);
  }
  return C3DSceneGetTypeID_typeID;
}

uint64_t C3DMorpherGetTypeID()
{
  if (C3DMorpherGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMorpherGetTypeID_onceToken, &__block_literal_global_102);
  }
  return C3DMorpherGetTypeID_typeID;
}

uint64_t C3DMorphGetTypeID()
{
  if (C3DMorphGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMorphGetTypeID_onceToken, &__block_literal_global_101);
  }
  return C3DMorphGetTypeID_typeID;
}

uint64_t C3DGenericSourceGetTypeID()
{
  if (C3DGenericSourceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DGenericSourceGetTypeID_onceToken, &__block_literal_global_89);
  }
  return C3DGenericSourceGetTypeID_typeID;
}

uint64_t C3DEngineContextGetPointOfViewIfAny(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

CFIndex C3DSortSystemPrepare(uint64_t a1, uint64_t a2)
{
  uint64_t Count = C3DArrayGetCount(*(void *)(a1 + 16));
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(a2);
  uint64_t PriorityStamp = C3DRendererElementStoreGetPriorityStamp(RendererElementStore);
  if (PriorityStamp != *(void *)(a1 + 32))
  {
    *(void *)(a1 + 32) = PriorityStamp;
    Priorityuint64_t Count = C3DRendererElementStoreGetPriorityCount(RendererElementStore);
    __int16 v8 = 1;
    if (PriorityCount >= 2)
    {
      char v9 = 0;
      do
      {
        ++v9;
        BOOL v10 = PriorityCount > 3;
        PriorityCount >>= 1;
      }
      while (v10);
      __int16 v8 = (v9 + 1) & 0x1F;
    }
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) & 0xFFE0 | v8;
    *(unsigned char *)(a1 + 40) = 1;
  }
  CFIndex result = C3DRendererElementStoreGetMaterialCount(RendererElementStore);
  unsigned int v12 = *(unsigned __int16 *)(a1 + 24);
  if (result >= (uint64_t)(2 << (v12 >> 5)))
  {
    if (result >= 2)
    {
      __int16 v14 = 0;
      do
      {
        ++v14;
        BOOL v10 = result > 3;
        LODWORD(result) = result >> 1;
      }
      while (v10);
      __int16 v13 = (32 * v14 + 32) & 0x3E0;
    }
    else
    {
      __int16 v13 = 32;
    }
    *(_WORD *)(a1 + 24) = v13 | v12 & 0xFC1F;
    *(unsigned char *)(a1 + 40) = 1;
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 40))
  {
LABEL_16:
    uint64_t ValuesPtr = (void *)C3DArrayGetValuesPtr(*(void *)(a1 + 16));
    CFIndex result = (CFIndex)memset(ValuesPtr, 255, 8 * Count);
    *(unsigned char *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t C3DSkinnerGetTypeID()
{
  if (C3DSkinnerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSkinnerGetTypeID_onceToken, &__block_literal_global_86);
  }
  return C3DSkinnerGetTypeID_typeID;
}

uint64_t C3DSkinGetTypeID()
{
  if (C3DSkinGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSkinGetTypeID_onceToken, &__block_literal_global_87);
  }
  return C3DSkinGetTypeID_typeID;
}

uint64_t C3DRendererElementStoreGetPriorityStamp(uint64_t a1)
{
  return C3DGeometryGetOverrideMaterial(*(void *)(a1 + 24));
}

CFIndex C3DRendererElementStoreGetPriorityCount(uint64_t a1)
{
  return C3DIndexStoreGetCount(*(void *)(a1 + 24));
}

CFIndex C3DRendererElementStoreGetMaterialCount(uint64_t a1)
{
  return C3DIndexStoreGetCount(*(void *)(a1 + 32));
}

CFIndex C3DIndexStoreGetCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DIndexStoreGetIndexForKey_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
}

uint64_t C3DParticleSystemGetTypeID()
{
  if (C3DParticleSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParticleSystemGetTypeID_onceToken, &__block_literal_global_78);
  }
  return C3DParticleSystemGetTypeID_typeID;
}

uint64_t C3DMeshSourceGetTypeID()
{
  if (C3DMeshSourceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshSourceGetTypeID_onceToken, &__block_literal_global_17);
  }
  return C3DMeshSourceGetTypeID_typeID;
}

uint64_t C3DMeshGetTypeID()
{
  if (C3DMeshGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshGetTypeID_onceToken, &__block_literal_global_63);
  }
  return C3DMeshGetTypeID_typeID;
}

uint64_t C3DLightingSystemGetGlobalLightHashCodeForCaching(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 0x40000000;
  _OWORD v5[2] = __C3DLightingSystemGetGlobalLightHashCodeForCaching_block_invoke;
  v5[3] = &unk_264008460;
  v5[5] = a3;
  v5[6] = a1;
  v5[4] = &v6;
  C3DLightingSystemEnumerateGlobalLights(a1, a2, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

CFDictionaryRef C3DLightingSystemEnumerateGlobalLights(const __CFDictionary *result, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v5 = result;
  uint64_t v18 = *MEMORY[0x263EF8340];
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  uint64_t v6 = *((unsigned int *)result + 142);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      unint64_t v8 = *((unsigned int *)result + i + 126);
      unsigned int v9 = (v8 & 0xFFFFFFF) - 1;
      BOOL v10 = (char *)result + ((v8 >> 25) & 0x78);
      *((void *)v17 + i) = *(void *)(*((void *)v10 + 17) + 8 * v9);
      *((void *)v16 + i) = *(void *)(*((void *)v10 + 25) + 8 * v9);
    }
    return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  else if (!(*((_DWORD *)result + 19) | *((_DWORD *)result + 18) | *((_DWORD *)result + 22) | *((_DWORD *)result + 23)))
  {
    CFIndex result = __ShouldForceLighting(a2);
    if (result)
    {
      DefaultLightuint64_t Node = C3DEngineContextGetDefaultLightNode(a2);
      CFDictionaryRef Light = C3DNodeGetLight((uint64_t)DefaultLightNode);
      if (C3DEngineContextGetPointOfViewIfAny(a2))
      {
        PointOfView = C3DEngineContextGetPointOfView(a2);
        C3DEngineContextSynchronizeDefaultLight(a2, PointOfView);
      }
      else
      {
        uint64_t DefaultPointOfView = C3DEngineContextGetDefaultPointOfView(a2);
        __int16 v14 = C3DEngineContextGetPointOfView(a2);
        C3DEngineContextSynchronizeDefaultLight(a2, v14);
        if (!DefaultPointOfView) {
          C3DEngineContextSetDefaultPointOfView(a2, 0);
        }
      }
      *((_DWORD *)v5 + 134) = C3DLightGetProgramHashCode((uint64_t)Light);
      return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }
  }
  return result;
}

void C3DLightingSystemBeginQueries(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 116400;
  if (!a2)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemBeginQueries_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  *(void *)(v6 + 16) = a3;
  uint64_t Scene = C3DEngineContextGetScene(a3);
  *(void *)(v6 + 24) = C3DSceneGetEnginePipeline(Scene);
  *(unsigned char *)(v6 + 32) = C3DEngineContextGetBooleanOptionForKey(a3, @"probeRendering");
  long long v16 = *(_OWORD *)(a2 + 48);
  float32x4_t v18 = *(float32x4_t *)a2;
  long long v17 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 11636_Block_object_dispose(&STACK[0x380], 8) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 116384) = v16;
  *(float32x4_t *)(a1 + 116336) = v18;
  *(_OWORD *)(a1 + 116352) = v17;
  v30.i32[2] = 0;
  v30.i64[0] = 0;
  C3DMatrix4x4GetScale((float32x4_t *)a2, &v30);
  float32x4_t v19 = vabsq_f32(v30);
  *(float *)uint64_t v6 = fmaxf(fmaxf(v19.f32[0], v19.f32[2]), v19.f32[1]);
  __CommitLightsUpdate(a1);
  for (uint64_t i = 1; i != 8; ++i)
  {
    uint64_t v21 = *(unsigned int *)(a1 + 4 * i + 64);
    if (v21)
    {
      uint64_t v22 = 0;
      uint64_t v23 = a1 + 8 * i;
      size_t v24 = (void *)(v23 + 136);
      int v25 = (void *)(v23 + 200);
      do
      {
        __updateWorldData((uint64_t *)a1, i, v22, *(float32x4_t **)(*v24 + 8 * v22), *(__n128 **)(*v25 + 8 * v22));
        ++v22;
      }
      while (v21 != v22);
    }
  }
  for (uint64_t j = 0; j != 7; ++j)
    bzero(*(void **)(a1 + 8 * j + 336), *(unsigned int *)(a1 + 4 * j + 68));
  bzero((void *)(a1 + 2664), 0x800uLL);
  bzero((void *)(a1 + 616), 0x800uLL);
  *(_DWORD *)(a1 + 60_Block_object_dispose(&STACK[0x380], 8) = 0;
  uint64_t AuthoringEnvironment = C3DEngineContextGetAuthoringEnvironment(a3, 0);
  *(void *)(v6 + 40) = AuthoringEnvironment;
  if (AuthoringEnvironment)
  {
    char ShouldDisplayLightInfluences = C3DAuthoringEnvironmentShouldDisplayLightInfluences(AuthoringEnvironment);
    uint64_t v29 = *(void *)(v6 + 40);
    *(unsigned char *)(v6 + 84) = ShouldDisplayLightInfluences;
    if (v29)
    {
      *(_DWORD *)(a1 + 116480) = 0;
      *(_OWORD *)(a1 + 11644_Block_object_dispose(&STACK[0x380], 8) = 0u;
      *(_OWORD *)(a1 + 116464) = 0u;
    }
  }
  else
  {
    *(unsigned char *)(v6 + 84) = 0;
  }
  __ComputeAmbientLighting(a1);
  if (C3DLightingSystemGetIrradianceProbesCount(a1)) {
    C3DLightProbesBeginQueries(*(void *)(a1 + 24), a3);
  }
}

void __CommitLightsUpdate(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 488)))
  {
    int HaveChanged = __LightsHaveChanged(a1);
    CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 488));
    if (HaveChanged)
    {
      BOOL IsBlack = C3DColor4IsBlack((float *)(a1 + 48));
      __ComputeAmbientLighting(a1);
      if (IsBlack != C3DColor4IsBlack((float *)(a1 + 48)))
      {
        uint64_t v4 = *(void *)(a1 + 116424);
        if (v4)
        {
          C3DEnginePipelineInvalidateAllProgramHashCode(v4);
        }
      }
    }
  }
}

__n128 C3DLightingSystemGetLightingContext@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x8000000000;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v30 = 0;
  __ComputeAmbientLighting(a1);
  long long v20 = *(_OWORD *)(a1 + 48);
  if (C3DColor4IsBlack((float *)&v20)) {
    __int16 v6 = 0;
  }
  else {
    __int16 v6 = 2;
  }
  *((_WORD *)v22 + 12) = v22[3] & 0xFFFD | v6;
  if (C3DLightingSystemGetIrradianceProbesCount(a1)) {
    __int16 v7 = 16 * (C3DLightProbesSystemGetSphericalHarmonicsOrder(*(void *)(a1 + 24)) & 7);
  }
  else {
    __int16 v7 = 0;
  }
  *((_WORD *)v22 + 12) = v22[3] & 0xFF8F | v7;
  if (C3DEngineContextIsClusteredShadingEnabled(a2))
  {
    *((_WORD *)v22 + 12) = v22[3] & 0xFFFB | (4 * (*(_DWORD *)(a1 + 572) != 0));
    __int16 v8 = C3DLightingSystemGetReflectionProbesCount(a1) != 0;
    *((_WORD *)v22 + 12) = v22[3] & 0xFFF7 | (8 * v8);
  }
  v19[0] = MEMORY[0x263EF8330];
  v19[1] = 0x40000000;
  v19[2] = __C3DLightingSystemGetLightingContext_block_invoke;
  v19[3] = &unk_2640084A8;
  v19[4] = &v21;
  void v19[5] = a1;
  C3DLightingSystemEnumerateGlobalLights((const __CFDictionary *)a1, a2, (uint64_t)v19);
  int v9 = *(_DWORD *)(a1 + 68);
  int v10 = *(_DWORD *)(a1 + 72);
  int v11 = *(_DWORD *)(a1 + 76);
  int v12 = *(_DWORD *)(a1 + 88);
  if (!C3DEngineContextIsClusteredShadingEnabled(a2))
  {
    __ComputeInfiniteLightSet(a1);
    if (!(v10 + v9 + v11 + v12))
    {
      __int16 v13 = *(_DWORD *)(a1 + 584) == 0;
      goto LABEL_16;
    }
LABEL_15:
    __int16 v13 = 0;
    goto LABEL_16;
  }
  if (v10 + v9 + v11 + v12 || *(_DWORD *)(a1 + 584)) {
    goto LABEL_15;
  }
  __int16 v13 = (unsigned __int16)__ShouldForceLighting(a2) ^ 1;
LABEL_16:
  uint64_t v14 = v22;
  *((_WORD *)v22 + 12) = v22[3] & 0xFFFE | v13;
  long long v15 = *(_OWORD *)(v14 + 9);
  long long v16 = *(_OWORD *)(v14 + 13);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v14 + 11);
  *(_OWORD *)(a3 + 80) = v16;
  *(void *)(a3 + 96) = v14[15];
  long long v17 = *(_OWORD *)(v14 + 5);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v14 + 7);
  *(_OWORD *)(a3 + 4_Block_object_dispose(&STACK[0x380], 8) = v15;
  *(_OWORD *)a3 = *(_OWORD *)(v14 + 3);
  *(_OWORD *)(a3 + 16) = v17;
  _Block_object_dispose(&v21, 8);
  return result;
}

BOOL C3DEngineContextIsClusteredShadingEnabled(uint64_t a1)
{
  return *(void *)(a1 + 1704) != 0;
}

double __ComputeAmbientLighting(uint64_t a1)
{
  long long v16 = 0uLL;
  C3DColor4Make((float *)&v16, 0.0, 0.0, 0.0, 1.0);
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 8 * v9;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 200) + v10);
      if (v12)
      {
        C3DLightGetColorModulatedByIntensity(v12, v2, v3, v4, v5, v6, v7, v8);
        v3.f32[0] = v13;
        double v4 = *(double *)&v16;
        *(float32x2_t *)v2.f32 = vadd_f32(*(float32x2_t *)&v16, v14);
        *(void *)&long long v16 = v2.i64[0];
        v2.f32[0] = *((float *)&v16 + 2) + v13;
        *((float *)&v16 + 2) = *((float *)&v16 + 2) + v13;
      }
      v10 += 8;
    }
    while (v11 != v10);
  }
  double result = *(double *)&v16;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = v16;
  return result;
}

uint64_t C3DLightingSystemGetReflectionProbesCount(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemGetIrradianceProbesCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 84);
}

uint64_t C3DLightingSystemGetIrradianceProbesCount(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemGetIrradianceProbesCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 80);
}

uint64_t C3DLODGetTypeID()
{
  if (C3DLODGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLODGetTypeID_onceToken, &__block_literal_global_54);
  }
  return C3DLODGetTypeID_typeID;
}

uint64_t C3DKeyframedAnimationGetTypeID()
{
  if (C3DKeyframedAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DKeyframedAnimationGetTypeID_onceToken, &__block_literal_global_24);
  }
  return C3DKeyframedAnimationGetTypeID_typeID;
}

uint64_t C3DKeyValueStoreGetTypeID()
{
  if (C3DKeyValueStoreGetTypeID_onceToken != -1) {
    dispatch_once(&C3DKeyValueStoreGetTypeID_onceToken, &__block_literal_global);
  }
  return C3DKeyValueStoreGetTypeID_typeID;
}

uint64_t C3DFXTechniqueGetTypeID()
{
  if (C3DFXTechniqueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXTechniqueGetTypeID_onceToken, &__block_literal_global_23);
  }
  return C3DFXTechniqueGetTypeID_typeID;
}

uint64_t C3DFXGLSLProgramGetTypeID()
{
  if (C3DFXGLSLProgramGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXGLSLProgramGetTypeID_onceToken, &__block_literal_global_105);
  }
  return C3DFXGLSLProgramGetTypeID_typeID;
}

void C3DEngineNotificationQueueSwapForApplying(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineNotificationQueueEnqueueEvent_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(int8x16_t *)(a1 + 16) = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  *(unsigned char *)(a1 + 50) = 0;
  *(CFTimeInterval *)(a1 + 40) = CACurrentMediaTime();
}

uint64_t C3DEngineNotificationQueueNeedsFullReset(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 50);
}

CFDictionaryRef C3DEngineContextGetBooleanOptionForKey(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 376);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, key);
    if (result) {
      return (const __CFDictionary *)(CFEqual(result, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0);
    }
  }
  return result;
}

uint64_t C3DConstraintSliderGetTypeID()
{
  if (C3DConstraintSliderGetTypeID::onceToken != -1) {
    dispatch_once(&C3DConstraintSliderGetTypeID::onceToken, &__block_literal_global_41);
  }
  return C3DConstraintSliderGetTypeID::typeID;
}

uint64_t C3DConstraintReplicatorGetTypeID()
{
  if (C3DConstraintReplicatorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintReplicatorGetTypeID_onceToken, &__block_literal_global_36_0);
  }
  return C3DConstraintReplicatorGetTypeID_typeID;
}

uint64_t C3DConstraintProceduralGetTypeID()
{
  if (C3DConstraintProceduralGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintProceduralGetTypeID_onceToken, &__block_literal_global_23);
  }
  return C3DConstraintProceduralGetTypeID_typeID;
}

uint64_t C3DConstraintLookAtGetTypeID()
{
  if (C3DConstraintLookAtGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintLookAtGetTypeID_onceToken, &__block_literal_global_10_2);
  }
  return C3DConstraintLookAtGetTypeID_typeID;
}

uint64_t C3DConstraintIKGetTypeID()
{
  if (C3DConstraintIKGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintIKGetTypeID_onceToken, &__block_literal_global_26);
  }
  return C3DConstraintIKGetTypeID_typeID;
}

uint64_t C3DConstraintDistanceGetTypeID()
{
  if (C3DConstraintDistanceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintDistanceGetTypeID_onceToken, &__block_literal_global_30_1);
  }
  return C3DConstraintDistanceGetTypeID_typeID;
}

uint64_t C3DConstraintConstantScaleGetTypeID()
{
  if (C3DConstraintConstantScaleGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintConstantScaleGetTypeID_onceToken, &__block_literal_global_19);
  }
  return C3DConstraintConstantScaleGetTypeID_typeID;
}

uint64_t C3DConstraintBillboardGetTypeID()
{
  if (C3DConstraintBillboardGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintBillboardGetTypeID_onceToken, &__block_literal_global_14_0);
  }
  return C3DConstraintBillboardGetTypeID_typeID;
}

uint64_t C3DConstraintAvoidOccluderGetTypeID()
{
  if (C3DConstraintAvoidOccluderGetTypeID::onceToken != -1) {
    dispatch_once(&C3DConstraintAvoidOccluderGetTypeID::onceToken, &__block_literal_global_22_1);
  }
  return C3DConstraintAvoidOccluderGetTypeID::typeID;
}

uint64_t C3DConstraintAccelerationGetTypeID()
{
  if (C3DConstraintAccelerationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintAccelerationGetTypeID_onceToken, &__block_literal_global_33_1);
  }
  return C3DConstraintAccelerationGetTypeID_typeID;
}

BOOL C3DCameraHasDepthOfField(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DCameraGetDepthOfFieldIntensity(a1) > 0.0;
}

float C3DCameraGetDepthOfFieldIntensity(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 448);
}

uint64_t C3DCameraGetTypeID()
{
  if (C3DCameraGetTypeID_onceToken != -1) {
    dispatch_once(&C3DCameraGetTypeID_onceToken, &__block_literal_global_61);
  }
  return C3DCameraGetTypeID_typeID;
}

uint64_t C3DAnimationPlayerGetTypeID()
{
  if (C3DAnimationPlayerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationPlayerGetTypeID_onceToken, &__block_literal_global_25);
  }
  return C3DAnimationPlayerGetTypeID_typeID;
}

uint64_t C3DAnimationGroupGetTypeID()
{
  if (C3DAnimationGroupGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationGroupGetTypeID_onceToken, &__block_literal_global_91);
  }
  return C3DAnimationGroupGetTypeID_typeID;
}

uint64_t C3DAnimationClusterGetTypeID()
{
  if (C3DAnimationClusterGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterGetTypeID_onceToken, &__block_literal_global_3);
  }
  return C3DAnimationClusterGetTypeID_typeID;
}

uint64_t C3DNodeGetParent(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

void C3DSceneSetRootNode(uint64_t a1, uint64_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(uint64_t **)(a1 + 64) != a2)
  {
    C3DEnginePipelineReset(*(void *)(a1 + 120));
    uint64_t v12 = *(void **)(a1 + 64);
    if (v12)
    {
      if (C3DGetScene(v12) == a1)
      {
        C3DRemoveSceneRef(*(void **)(a1 + 64), a1);
      }
      else
      {
        float v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v18[0] = 0;
          _os_log_impl(&dword_20B249000, v13, OS_LOG_TYPE_DEFAULT, "Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene", (uint8_t *)v18, 2u);
        }
      }
      long long v15 = *(uint64_t **)(a1 + 64);
      float32x2_t v14 = a2;
      if (v15 == a2) {
        goto LABEL_19;
      }
      if (v15)
      {
        CFRelease(*(CFTypeRef *)(a1 + 64));
        *(void *)(a1 + 64) = 0;
      }
      if (!a2)
      {
        float32x2_t v14 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      float32x2_t v14 = a2;
      if (!a2) {
        goto LABEL_19;
      }
    }
    float32x2_t v14 = (uint64_t *)CFRetain(a2);
LABEL_18:
    *(void *)(a1 + 64) = v14;
LABEL_19:
    long long v16 = *(uint64_t **)(a1 + 384);
    if (v16 != a2)
    {
      if (v16)
      {
        CFRelease(*(CFTypeRef *)(a1 + 384));
        *(void *)(a1 + 384) = 0;
      }
      if (a2) {
        CFTypeRef v17 = CFRetain(a2);
      }
      else {
        CFTypeRef v17 = 0;
      }
      *(void *)(a1 + 384) = v17;
      float32x2_t v14 = *(uint64_t **)(a1 + 64);
    }
    if (v14) {
      C3DAddSceneRef(v14, a1);
    }
  }
}

void C3DEnginePipelineReset(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineReset_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(__CFDictionary **)(a1 + 40);
  if (v10) {
    CFDictionaryRemoveAllValues(v10);
  }
  C3DRendererElementStoreClear(*(uint64_t **)(a1 + 48));
  uint64_t v11 = *(const void **)(a1 + 24);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 24) = 0;
  }
}

void C3DRendererElementStoreClear(uint64_t *a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  C3DSpanAllocatorFree(a1[2]);
  C3DIndexStoreRemoveAllIndexes(a1[3]);
  C3DIndexStoreRemoveAllIndexes(a1[4]);
}

void C3DSpanAllocatorFree(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      __DestructPage(*(void *)(a1 + 16) + v2);
      ++v3;
      v2 += 40;
    }
    while (v3 < *(unsigned int *)(a1 + 24));
  }
  free(*(void **)(a1 + 16));
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
}

void __C3DConstraintGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"influenceFactor", 0x48u, 1, 0);

  C3DModelPathResolverRegisterClassEnd();
}

void __C3DConstraintIKGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintIKGetTypeID_typeID = (uint64_t)v0;
  if (C3DConstraintGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintGetTypeID_onceToken, &__block_literal_global_7_0);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DConstraintGetTypeID_typeID);
  C3DModelPathResolverRegisterProperty(@"targetPosition", 0x90u, 9, 0);

  C3DModelPathResolverRegisterClassEnd();
}

double __C3DGeometryGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DGeometryGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B467F40 = kC3DC3DGeometryContextClassSerializable;
  unk_26B467F50 = *(_OWORD *)&off_26BF71278;
  unk_26B467F00 = kC3DC3DGeometryContextClassBoundingVolumes;
  double result = *(double *)&kC3DC3DGeometryContextClassSceneLink;
  unk_26B467F10 = kC3DC3DGeometryContextClassSceneLink;
  qword_26B467EF8 = (uint64_t)_C3DGeometryCopyInstanceVariables;
  unk_26B467F20 = *(_OWORD *)algn_26BF71250;
  qword_26B467F30 = (uint64_t)off_26BF71260;
  unk_26B467F38 = _C3DGeometrySearchByID;
  qword_26B467F60 = (uint64_t)_C3DGeometryCreateCopy;
  return result;
}

double __C3DTextGeometryGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DTextGeometryGetTypeID_typeID = (uint64_t)v0;
  if (C3DShapeGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DShapeGeometryGetTypeID_onceToken, &__block_literal_global_145);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DShapeGeometryGetTypeID_typeID);
  C3DModelPathResolverRegisterClassEnd();
  *(_OWORD *)&algn_26B469158[8] = kC3DC3DTextGeometryContextClassSerializable;
  *(_OWORD *)&algn_26B469158[24] = *(_OWORD *)&off_26BF71760;
  unk_26B469120 = kC3DC3DTextGeometryContextClassBoundingVolumes;
  xmmword_26B469108 = kC3DC3DTextGeometryContextClassAnimatable;
  double result = *(double *)&kC3DC3DTextGeometryContextClassSceneLink;
  unk_26B469130 = kC3DC3DTextGeometryContextClassSceneLink;
  unk_26B469140 = unk_26BF71738;
  qword_26B469150 = qword_26BF71748;
  qword_26B469180 = (uint64_t)_C3DTextGeometryCreateCopy;
  return result;
}

void __C3DConstraintDistanceGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintDistanceGetTypeID_typeID = (uint64_t)v0;
  if (C3DConstraintGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintGetTypeID_onceToken, &__block_literal_global_7_0);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DConstraintGetTypeID_typeID);
  C3DModelPathResolverRegisterProperty(@"minimumDistance", 0x90u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"maximumDistance", 0x94u, 1, 0);

  C3DModelPathResolverRegisterClassEnd();
}

void __C3DConstraintLookAtGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintLookAtGetTypeID_typeID = (uint64_t)v0;
  if (C3DConstraintGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintGetTypeID_onceToken, &__block_literal_global_7_0);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DConstraintGetTypeID_typeID);
  C3DModelPathResolverRegisterProperty(@"targetOffset", 0xB0u, 10, 0);
  C3DModelPathResolverRegisterProperty(@"worldUp", 0xA0u, 10, 0);
  C3DModelPathResolverRegisterProperty(@"localFront", 0xC0u, 9, 0);

  C3DModelPathResolverRegisterClassEnd();
}

void __C3DConstraintReplicatorGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintReplicatorGetTypeID_typeID = (uint64_t)v0;
  if (C3DConstraintGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintGetTypeID_onceToken, &__block_literal_global_7_0);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DConstraintGetTypeID_typeID);
  C3DModelPathResolverRegisterProperty(@"orientationOffset", 0xC0u, 10, 3);
  C3DModelPathResolverRegisterProperty(@"positionOffset", 0xA0u, 9, 6);
  C3DModelPathResolverRegisterProperty(@"scaleOffset", 0xB0u, 9, 7);

  C3DModelPathResolverRegisterClassEnd();
}

double __C3DAnimationPlayerGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DAnimationPlayerGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"speed", 0x54u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"blendFactor", 0x50u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  double result = *(double *)&kC3DC3DAnimationPlayerContextClassAnimatable;
  xmmword_26B4676C0 = kC3DC3DAnimationPlayerContextClassAnimatable;
  return result;
}

double __C3DNodeGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DNodeGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"hidden", 0xC8u, 3, 0);
  C3DModelPathResolverRegisterProperty(@"opacity", 0xCCu, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B468A20 = kC3DC3DNodeContextClassSerializable;
  unk_26B468A30 = *(_OWORD *)&off_26BF71500;
  unk_26B4689E0 = kC3DC3DNodeContextClassBoundingVolumes;
  xmmword_26B4689C8 = kC3DC3DNodeContextClassAnimatable;
  double result = *(double *)&kC3DC3DNodeContextClassSceneLink;
  unk_26B4689F0 = kC3DC3DNodeContextClassSceneLink;
  qword_26B4689D8 = (uint64_t)_C3DNodeCopyInstanceVariables;
  unk_26B468A00 = *(_OWORD *)off_26BF714D8;
  qword_26B468A10 = qword_26BF714E8;
  unk_26B468A18 = _C3DNodeSearchByID;
  return result;
}

double __C3DMaterialGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DMaterialGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"doubleSided", 0x64u, 3, 0);
  C3DModelPathResolverRegisterProperty(@"cullMode", 0x5Au, 4, 0);
  C3DModelPathResolverRegisterClassEnd();
  double result = *(double *)&kC3DC3DMaterialContextClassSerializable;
  unk_26B4684B0 = kC3DC3DMaterialContextClassSerializable;
  unk_26B4684C0 = *(_OWORD *)&off_26BF71380;
  qword_26B468468 = (uint64_t)_C3DMaterialCopyInstanceVariables;
  qword_26B4684A8 = (uint64_t)_C3DMaterialSearchByID;
  return result;
}

void __C3DConstraintAccelerationGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DConstraintAccelerationGetTypeID_typeID = (uint64_t)v0;
  if (C3DConstraintGetTypeID_onceToken != -1) {
    dispatch_once(&C3DConstraintGetTypeID_onceToken, &__block_literal_global_7_0);
  }
  C3DModelPathResolverRegisterClassBegin(v0, (const void *)C3DConstraintGetTypeID_typeID);
  C3DModelPathResolverRegisterProperty(@"maximumLinearAcceleration", 0x8Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"maximumLinearVelocity", 0x88u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"decelerationDistance", 0x90u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"damping", 0x94u, 1, 0);

  C3DModelPathResolverRegisterClassEnd();
}

double __C3DFloorGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DFloorGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"reflectionFalloffEnd", 0xE0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"reflectionFalloffStart", 0xDCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"reflectivity", 0xD8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"width", 0xECu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"length", 0xF0u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B467D70 = kC3DC3DFloorContextClassSerializable;
  unk_26B467D80 = *(_OWORD *)&off_26BF711F0;
  unk_26B467D30 = kC3DC3DFloorContextClassBoundingVolumes;
  unk_26B467D40 = kC3DC3DFloorContextClassSceneLink;
  qword_26B467D28 = (uint64_t)_C3DFloorCopyInstanceVariables;
  unk_26B467D50 = unk_26BF711C8;
  qword_26B467D60 = qword_26BF711D8;
  unk_26B467D68 = _C3DFloorSearchByID;
  double result = *(double *)&kC3DC3DFloorContextClassAnimatable;
  xmmword_26B467D18 = kC3DC3DFloorContextClassAnimatable;
  return result;
}

double __C3DSceneGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DSceneGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"fogColor", 0x160u, 13, 0);
  C3DModelPathResolverRegisterProperty(@"fogDensityExponent", 0x150u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"fogEndDistance", 0x14Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"fogStartDistance", 0x148u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"wantsScreenSpaceReflection", 0x170u, 3, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceReflectionSampleCount", 0x172u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceReflectionMaximumDistance", 0x174u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceReflectionStride", 0x178u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B468CD8 = kC3DC3DSceneContextClassSerializable;
  unk_26B468CE8 = *(_OWORD *)&off_26BF715C0;
  double result = *(double *)&kC3DC3DSceneContextClassSceneLink;
  unk_26B468CA8 = kC3DC3DSceneContextClassSceneLink;
  unk_26B468CB8 = unk_26BF71598;
  qword_26B468CC8 = qword_26BF715A8;
  unk_26B468CD0 = _C3DSceneSearchByID;
  qword_26B468C90 = (uint64_t)_C3DSceneCopyInstanceVariables;
  return result;
}

double __C3DLightGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DLightGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"attenuationEndDistance", 0x58u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"attenuationFalloffExponent", 0x5Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"attenuationStartDistance", 0x54u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"color", 0x40u, 13, 0);
  C3DModelPathResolverRegisterProperty(@"intensity", 0x60u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"orthographicScale", 0x88u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"shadowBias", 0xC0u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"shadowColor", 0x70u, 13, 0);
  C3DModelPathResolverRegisterProperty(@"shadowRadius", 0x8Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"spotFalloffExponent", 0xF8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"spotInnerAngle", 0xF4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"spotOuterAngle", 0xF0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"temperature", 0x64u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"zFar", 0xB8u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"zNear", 0xB0u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"shadowCascadeDebugFactor", 0x98u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B4683C8 = kC3DC3DLightContextClassSerializable;
  unk_26B4683D8 = *(_OWORD *)&off_26BF71360;
  qword_26B468380 = (uint64_t)_C3DLightCopyInstanceVariables;
  double result = *(double *)&kC3DC3DLightContextClassAnimatable;
  xmmword_26B468370 = kC3DC3DLightContextClassAnimatable;
  qword_26B4683C0 = (uint64_t)_C3DLightSearchByID;
  return result;
}

double __C3DShapeGeometryGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DShapeGeometryGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"chamferRadius", 0xE4u, 7, 0);
  C3DModelPathResolverRegisterProperty(@"extrusionDepth", 0xE0u, 7, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B468DC0 = kC3DC3DShapeGeometryContextClassSerializable;
  unk_26B468DD0 = *(_OWORD *)&off_26BF71628;
  unk_26B468D80 = kC3DC3DShapeGeometryContextClassBoundingVolumes;
  xmmword_26B468D68 = kC3DC3DShapeGeometryContextClassAnimatable;
  double result = *(double *)&kC3DC3DShapeGeometryContextClassSceneLink;
  unk_26B468D90 = kC3DC3DShapeGeometryContextClassSceneLink;
  unk_26B468DA0 = unk_26BF71600;
  qword_26B468DB0 = qword_26BF71610;
  qword_26B468DE0 = (uint64_t)_C3DShapeGeometryCreateCopy;
  return result;
}

double __C3DParametricGeometryGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DParametricGeometryGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"chamferRadius", 0xE4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"chamferSegmentCount", 0x114u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"height", 0xDCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"heightSegmentCount", 0x10Cu, 2, 0);
  C3DModelPathResolverRegisterProperty(@"length", 0xE0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"lengthSegmentCount", 0x110u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"width", 0xD8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"widthSegmentCount", 0x108u, 2, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v2 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v2);
  C3DModelPathResolverRegisterProperty(@"capRadius", 0xE8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"capSegmentCount", 0x120u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"radialSegmentCount", 0x11Cu, 2, 0);
  C3DModelPathResolverRegisterClassEnd();
  unint64_t v3 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v3);
  C3DModelPathResolverRegisterProperty(@"bottomRadius", 0xF0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"topRadius", 0xECu, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v4 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v4);
  C3DModelPathResolverRegisterProperty(@"radialSpan", 0x104u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"radius", 0xE8u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v5 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v5);
  C3DModelPathResolverRegisterProperty(@"cornerRadius", 0xE4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"cornerSegmentCount", 0x114u, 2, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v6 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v6);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v7 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v7);
  C3DModelPathResolverRegisterProperty(@"segmentCount", 0x118u, 2, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v8 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v8);
  C3DModelPathResolverRegisterProperty(@"pipeRadius", 0x100u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"pipeSegmentCount", 0x128u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"ringRadius", 0xFCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"ringSegmentCount", 0x124u, 2, 0);
  C3DModelPathResolverRegisterClassEnd();
  uint64_t v9 = (const void *)C3DGeometryGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, v9);
  C3DModelPathResolverRegisterProperty(@"innerRadius", 0xF4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"outerRadius", 0xF8u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  unk_26B468B08 = kC3DC3DParametricGeometryContextClassSerializable;
  unk_26B468B18 = *(_OWORD *)&off_26BF71568;
  unk_26B468AC8 = kC3DC3DParametricGeometryContextClassBoundingVolumes;
  xmmword_26B468AB0 = kC3DC3DParametricGeometryContextClassAnimatable;
  double result = *(double *)&kC3DC3DParametricGeometryContextClassSceneLink;
  unk_26B468AD8 = kC3DC3DParametricGeometryContextClassSceneLink;
  unk_26B468AE8 = unk_26BF71540;
  qword_26B468AF8 = qword_26BF71550;
  qword_26B468B28 = (uint64_t)_C3DParametricGeometryCreateCopy;
  return result;
}

void C3DModelPathResolverRegisterClassEnd()
{
  _currentClassRegistry = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
}

void C3DModelPathResolverRegisterClassBegin(void *a1, const void *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  int Type = (__CFDictionary *)_C3DModelPathResolverRegistryGetType(a1);
  _currentClassRegistry = (uint64_t)Type;
  if (a2)
  {
    CFDictionaryAddValue(Type, @"superClass", a2);
  }
}

const void *_C3DModelPathResolverRegistryGetType(void *key)
{
  CFDictionaryRef Mutable = (const __CFDictionary *)_modelPathResolverRegistry;
  if (!_modelPathResolverRegistry)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
    _modelPathResolverRegistry = (uint64_t)Mutable;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    CFDictionaryRef Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0);
    CFDictionarySetValue((CFMutableDictionaryRef)_modelPathResolverRegistry, key, Value);
  }
  return Value;
}

uint64_t C3DGeometryGetTypeID()
{
  if (C3DGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  }
  return C3DGeometryGetTypeID_typeID;
}

double __C3DParticleSystemGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DParticleSystemGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"acceleration", 0xA0u, 9, 0);
  C3DModelPathResolverRegisterProperty(@"affectedByGravity", 0x60u, 3, 0);
  C3DModelPathResolverRegisterProperty(@"birthRate", 0x40u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"birthRateVariation", 0x44u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"dampingFactor", 0x17Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"emissionDuration", 0x6Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"emissionDurationVariation", 0x70u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"emittingDirection", 0x80u, 9, 0);
  C3DModelPathResolverRegisterProperty(@"fixedTimeStep", 0x184u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"fresnelExponent", 0x18Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"idleDuration", 0x74u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"idleDurationVariation", 0x78u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceColumnCount", 0x130u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceFrameRate", 0x13Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceFrameRateVariation", 0x140u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceInitialFrame", 0x134u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceInitialFrameVariation", 0x138u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"imageSequenceRowCount", 0x132u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"isLocal", 0x5Fu, 3, 0);
  C3DModelPathResolverRegisterProperty(@"loops", 0x65u, 3, 0);
  C3DModelPathResolverRegisterProperty(@"particleAngle", 0xB4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleAngleVariation", 0xB8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleAngularVelocity", 0xC4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleAngularVelocityVariation", 0xC8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleBounce", 0xD4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleBounceVariation", 0xD8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleCharge", 0xE4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleChargeVariation", 0xE8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleColor", 0x100u, 13, 0);
  C3DModelPathResolverRegisterProperty(@"particleColorVariation", 0x110u, 10, 0);
  C3DModelPathResolverRegisterProperty(@"particleFriction", 0xDCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleFrictionVariation", 0xE0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleGeometries", 0x160u, 5, 0);
  C3DModelPathResolverRegisterProperty(@"particleLifeSpan", 0xCCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleLifeSpanVariation", 0xD0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleMass", 0x174u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleMassVariation", 0x178u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleSize", 0x120u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleSizeVariation", 0x124u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleIntensity", 0x128u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleIntensityVariation", 0x12Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleVelocity", 0xBCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"particleVelocityVariation", 0xC0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"speedFactor", 0x180u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"spreadingAngle", 0xB0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"stretchFactor", 0xF8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"warmupDuration", 0x48u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  double result = *(double *)&kC3DC3DParticleSystemContextClassAnimatable;
  xmmword_26B468B98 = kC3DC3DParticleSystemContextClassAnimatable;
  return result;
}

double __C3DCameraGetTypeID_block_invoke()
{
  CFTypeID v0 = (void *)_CFRuntimeRegisterClass();
  C3DCameraGetTypeID_typeID = (uint64_t)v0;
  TypeID = (const void *)C3DEntityGetTypeID();
  C3DModelPathResolverRegisterClassBegin(v0, TypeID);
  C3DModelPathResolverRegisterProperty(@"fStop", 0x128u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"apertureBladeCount", 0x130u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"aspectRatio", 0x80u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"sensorHeight", 0x12Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"lensShift", 0x58u, 8, 0);
  C3DModelPathResolverRegisterProperty(@"postProjectionTransformTranslation", 0x60u, 8, 0);
  C3DModelPathResolverRegisterProperty(@"postProjectionTransformScale", 0x68u, 8, 0);
  C3DModelPathResolverRegisterProperty(@"averageGray", 0x184u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"bloomBlurRadius", 0x1B8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"bloomIntensity", 0x1A8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"bloomThreshold", 0x1ACu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"bloomIteration", 0x1B0u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"bloomIterationSpread", 0x1B4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"colorFringeStrength", 0x1C4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"colorFringeIntensity", 0x1BCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"contrast", 0x1CCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"grainIntensity", 0x1D0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"grainScale", 0x1D4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureAdaptationBrighteningSpeedFactor", 0x190u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureAdaptationDarkeningSpeedFactor", 0x194u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureAdaptationDuration", 0x18Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureAdaptationHistogramRangeHighProbability", 0x198u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureAdaptationHistogramRangeLowProbability", 0x19Cu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"exposureOffset", 0x188u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"dofIntensity", 0x1C0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"focusDistance", 0x120u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"focalLength", 0x124u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"fieldOfView", 0x78u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"maximumExposure", 0x1A4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"minimumExposure", 0x1A0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"motionBlurIntensity", 0x1D8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"orthographicScale", 0x70u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"projectionTransform", 0x90u, 11, 0);
  C3DModelPathResolverRegisterProperty(@"saturation", 0x1C8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"vignettingIntensity", 0x1E0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"vignettingPower", 0x1DCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"whitePoint", 0x180u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"xFov", 0x110u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"yFov", 0x118u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"zFar", 0x50u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"zNear", 0x48u, 6, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionIntensity", 0x1ECu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionRadius", 0x1F0u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionBias", 0x1F4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionDepthThreshold", 0x1F8u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionNormalThreshold", 0x1FCu, 1, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionSampleCount", 0x200u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"screenSpaceAmbientOcclusionDownSample", 0x204u, 2, 0);
  C3DModelPathResolverRegisterProperty(@"whiteBalanceTemperature", 0x1E4u, 1, 0);
  C3DModelPathResolverRegisterProperty(@"whiteBalanceTint", 0x1E8u, 1, 0);
  C3DModelPathResolverRegisterClassEnd();
  xmmword_26B4677A8 = kC3DC3DCameraContextClassAnimatable;
  double result = *(double *)&kC3DC3DCameraContextClassSerializable;
  unk_26B467800 = kC3DC3DCameraContextClassSerializable;
  unk_26B467810 = *(_OWORD *)&off_26BF71120;
  qword_26B4677B8 = (uint64_t)_C3DCameraCopyInstanceVariables;
  qword_26B4677F8 = (uint64_t)_C3DCameraSearchByID;
  return result;
}

void C3DModelPathResolverRegisterProperty(const void *a1, unsigned int a2, __int16 a3, char a4)
{
  if (!_currentClassRegistry)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DModelPathResolverRegisterProperty_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  long long v16 = malloc_type_malloc(0x10uLL, 0x10000401E18E2A0uLL);
  _OWORD v16[4] = a3;
  *(void *)long long v16 = a2;
  *((unsigned char *)v16 + 10) = a4;
  if (CFDictionaryGetCountOfKey((CFDictionaryRef)_currentClassRegistry, a1))
  {
    CFTypeRef v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      C3DModelPathResolverRegisterProperty_cold_1((uint64_t)a1, v17);
    }
  }
  CFDictionarySetValue((CFMutableDictionaryRef)_currentClassRegistry, a1, v16);
}

void *SCNMTLComputeCommandEncoder::beginEncoding(void *a1, void *a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a1[207])
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      SCNMTLComputeCommandEncoder::beginEncoding(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  bzero(a1, 0x6B0uLL);
  *((_DWORD *)a1 + 420) = a3;
  a1[208] = a2;
  double result = (void *)[a2 computeCommandEncoder];
  a1[207] = result;
  a1[209] = a5;
  if (a4) {
    return (void *)[result setLabel:a4];
  }
  return result;
}

void sub_20B2978E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DEngineContextSetMainClearColor(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 224) = a2;
  *(void *)(result + 232) = a3;
  return result;
}

void *C3DRenderGraphSetWarmupPixelFormat(void *result, unsigned int a2)
{
  *double result = a2;
  return result;
}

void *C3DTransactionSetImmediateModeRestrictedContext(uint64_t a1)
{
  double result = C3DTransactionGetCurrent();
  result[6] = a1;
  return result;
}

uint64_t C3DCullingContextCull(uint64_t a1)
{
  C3DEngineContextGetFrameIndex(*(void *)(a1 + 4736));
  kdebug_trace();
  uint64_t Stats = C3DEngineContextGetStats(*(void *)(a1 + 4736));
  double v3 = CACurrentMediaTime();
  uint64_t v4 = *(void *)(a1 + 4672);
  Rootuint64_t Node = C3DSceneGetRootNode(*(void *)(a1 + 4728));
  if (*(_DWORD *)(a1 + 4624))
  {
    uint64_t v6 = RootNode;
    unint64_t v7 = 0;
    uint64_t v8 = (unsigned __int8 *)(a1 + 4630);
    do
    {
      if (*(unsigned char *)(a1 + 4692))
      {
        if (v4 == v6)
        {
          for (int i = 0; i != 4; ++i)
          {
            if ((*v8 >> i))
            {
              LayerRootuint64_t Node = (float32x4_t *)C3DSceneGetLayerRootNode(*(void *)(a1 + 4728), i);
              if (LayerRootNode) {
                __CullInside((float32x4_t *)a1, v7, LayerRootNode);
              }
            }
          }
        }
        else
        {
          __CullInside((float32x4_t *)a1, 0, *(float32x4_t **)(a1 + 4672));
        }
      }
      else if (v4 == v6)
      {
        CullingSysteCFIndex m = C3DSceneGetCullingSystem(*(void *)(a1 + 4728));
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        v14[0] = MEMORY[0x263EF8330];
        v14[1] = 0x40000000;
        v14[2] = __C3DCullingContextCull_block_invoke;
        v14[3] = &__block_descriptor_tmp_6_6;
        uint8_t v14[4] = a1;
        void v14[5] = v7;
        C3DCullingSystemQueryMake((uint64_t)v14, (uint64_t)&v15);
        long long v15 = *(_OWORD *)(a1 + 4704);
        if (*(unsigned char *)(a1 + 4690)) {
          int v12 = 3;
        }
        else {
          int v12 = 1;
        }
        DWORD1(v16) = v12;
        if (*(unsigned char *)(a1 + 4691)) {
          DWORD1(v16) = v12 | 4;
        }
        if (*(unsigned char *)(a1 + 4689)) {
          LODWORD(v16) = 8;
        }
        DWORD2(v16) = *v8;
        C3DCullingSystemCull(CullingSystem);
      }
      else
      {
        __Cull((float32x4_t *)a1, 0, *(float32x4_t **)(a1 + 4672));
      }
      ++v7;
    }
    while (v7 < *(unsigned int *)(a1 + 4624));
  }
  *(double *)(Stats + 104) = *(double *)(Stats + 104) + CACurrentMediaTime() - v3;
  C3DEngineContextGetFrameIndex(*(void *)(a1 + 4736));
  return kdebug_trace();
}

uint64_t C3DNodeApplyChildren(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 72);
  if (v2)
  {
    uint64_t v4 = 0;
    do
    {
      double result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v2, v4++);
      uint64_t v2 = *(void *)(v2 + 80);
    }
    while (v2);
  }
  return result;
}

uint64_t __CullInside(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t result = C3DCullingContextPushRenderableElementsToVisible(a1, a2, a3);
  if (!result)
  {
    v7[0] = MEMORY[0x263EF8330];
    v7[1] = 0x40000000;
    int v7[2] = ____CullInside_block_invoke;
    v7[3] = &__block_descriptor_tmp_84;
    v7[4] = a1;
    void v7[5] = a2;
    return C3DNodeApplyChildren((uint64_t)a3, (uint64_t)v7);
  }
  return result;
}

uint64_t C3DCullingContextPushRenderableElementsToVisible(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  if (a1[294].i64[1] & a3[13].i64[0] | ((a1[294].i64[0] & a3[13].i64[0]) == 0)) {
    return 0;
  }
  uint64_t v8 = a1 + 293;
  if (a1[293].i8[2])
  {
    if ((a3[13].i8[14] & 0x40) == 0) {
      return 0;
    }
  }
  if (a1[293].i8[3] && (a3[13].i8[14] & 0x40) != 0) {
    return 0;
  }
  __int32 v9 = a3[14].i32[1];
  if (!v9) {
    return 0;
  }
  __int16 v10 = a3[14].i16[0];
  __int16 v11 = a3[14].i16[1];
  if (C3DNodeIsHiddenOrTransparent((uint64_t)a3)) {
    return 1;
  }
  __int32 v12 = a3[13].i32[3];
  if ((v12 & 0x1000) == 0)
  {
    if ((v12 & 0x4000) != 0) {
      goto LABEL_13;
    }
LABEL_22:
    C3DCullingContextForcePushGeometryRenderableElementsToVisible(a1, a2, a3);
    return 0;
  }
  v8[20].i8[0] = 1;
  if (v8->i8[0] || a1[292].i64[1]) {
    return 0;
  }
  if ((a3[13].i32[3] & 0x4000) == 0) {
    goto LABEL_22;
  }
LABEL_13:
  v8[20].i8[0] = 1;
  if ((float32x4_t *)a1[292].i64[0] == a3 || C3DFXPassGetMaterial(a1[291].i64[0])) {
    goto LABEL_22;
  }
  uint64_t v13 = C3DGetScene(a3);
  RegisteredCIFilterTechniqueForuint64_t Node = C3DSceneGetRegisteredCIFilterTechniqueForNode(v13, a3);
  if (RegisteredCIFilterTechniqueForNode)
  {
    Parentuint64_t Technique = C3DFXTechniqueGetParentTechnique((uint64_t)RegisteredCIFilterTechniqueForNode);
    if (!ParentTechnique || C3DFXTechniqueIsBeingRendered(ParentTechnique))
    {
      uint64_t v16 = (uint64_t)&a1[a2 + 307];
      uint64_t v3 = 1;
      C3DHandlesSequenceAppend(v16, v10, v11 + v9 - 1, 1);
      return v3;
    }
    return 1;
  }
  uint64_t v3 = 1;
  if ((C3DCullingContextPushRenderableElementsToVisible_done & 1) == 0)
  {
    C3DCullingContextPushRenderableElementsToVisible_done = 1;
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      __shouldPushRenderableElementsToVisible_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
      return 1;
    }
  }
  return v3;
}

void C3DCullingContextForcePushGeometryRenderableElementsToVisible(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v3 = &a1[a2];
  int8x16_t v65 = v3 + 307;
  __int16 v4 = a3[14].i16[0];
  __int16 v5 = a3[14].i16[1];
  __int32 v6 = a3[13].i32[3];
  int v7 = a3[14].i32[1] + (v6 << 17 >> 31);
  if ((v6 & 0x8000) != 0)
  {
    if (C3DEngineContextIsWarmUp(a1[296].i64[0]))
    {
      __int16 v11 = &a1[a2];
      __int32 v12 = &v11[307].i32[2];
      if ((v11[307].i32[2] + v7) > v11[307].i32[3])
      {
        uint64_t v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
          C3D::ScenePass::_shouldPushNodeToVisible(v13, v14, v15, v16, v17, v18, v19, v20);
        }
      }
      uint64_t v21 = *v12;
      if (v7)
      {
        int v22 = 0;
        uint64_t v23 = (__int16 *)(v65->i64[0] + 4 * v21);
        do
        {
          *uint64_t v23 = v4;
          v23[1] = v5 + v22++;
          v23 += 2;
        }
        while (v7 != v22);
      }
      int v24 = v21 + v7;
      *__int32 v12 = v24;
      long long v25 = (_WORD *)a3[14].i64[1];
      uint64_t v26 = (unsigned __int16)*v25;
      if (*v25)
      {
        uint64_t v27 = 0;
        long long v28 = &v11[307].i32[3];
        do
        {
          uint64_t v29 = a3[14].i64[1] + 12 * v27;
          __int16 v30 = *(_WORD *)(v29 + 12);
          __int16 v31 = *(_WORD *)(v29 + 14);
          int v32 = *(_DWORD *)(v29 + 16);
          if (v24 + v32 > *v28)
          {
            uint64_t v33 = scn_default_log();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
              C3DCullingContextForcePushGeometryRenderableElementsToVisible_cold_2((uint8_t *)&buf, (uint64_t *)((char *)buf.i64 + 4), v33);
            }
          }
          uint64_t v34 = *v12;
          if (v32)
          {
            int v35 = 0;
            uint64_t v36 = (_WORD *)(v65->i64[0] + 4 * v34);
            do
            {
              *uint64_t v36 = v30;
              v36[1] = v31 + v35++;
              v36 += 2;
            }
            while (v32 != v35);
          }
          int v24 = v34 + v32;
          *__int32 v12 = v24;
          ++v27;
        }
        while (v27 != v26);
      }
      return;
    }
    uint64_t v37 = (float *)a3[14].i64[1];
    uint64_t v38 = *(unsigned __int16 *)v37;
    if (*((unsigned char *)v37 + 2))
    {
      memset(&buf, 0, sizeof(buf));
      C3DGetBoundingSphere(a3, 0, (uint64_t)&buf);
      float32x4_t v70 = 0uLL;
      WorldMatrix = C3DNodeGetWorldMatrix(a3);
      C3DSphereXFormMatrix4x4(&buf, WorldMatrix, (uint64_t)&v70);
      float32x4_t v69 = vaddq_f32(vaddq_f32(v70, vmulq_laneq_f32(a1[299], v70, 3)), vmulq_laneq_f32(a1[300], v70, 3));
      v68.i32[2] = 0;
      v68.i64[0] = 0;
      v67.i32[2] = 0;
      v67.i64[0] = 0;
      float32x4_t v66 = v70;
      C3DMatrix4x4Project(a1 + 303, (float32x2_t *)&v66, &v68);
      C3DMatrix4x4Project(a1 + 303, (float32x2_t *)&v69, &v67);
      float32x4_t v40 = vsubq_f32(v68, v67);
      float32x4_t v41 = vmulq_f32(v40, v40);
      float v42 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0])* 0.5;
      __n128 Viewport = C3DEngineContextGetViewport((__n128 *)a1[296].i64[0]);
      LODWORD(v43) = 0;
      Viewport.n128_u32[0] = Viewport.n128_u32[3];
      if (Viewport.n128_f32[2] > Viewport.n128_f32[3]) {
        Viewport.n128_f32[0] = Viewport.n128_f32[2];
      }
      float v45 = Viewport.n128_f32[0] * v42;
      if (v37[2] < v45) {
        goto LABEL_37;
      }
      if (v38 >= 2)
      {
        int8x16_t v46 = v37 + 5;
        uint64_t v43 = 1;
        while (*v46 >= v45)
        {
          ++v43;
          v46 += 3;
          if (v38 == v43)
          {
            LODWORD(v43) = v38;
            goto LABEL_37;
          }
        }
        goto LABEL_37;
      }
    }
    else
    {
      buf.i32[2] = 0;
      buf.i64[0] = 0;
      C3DNodeGetWorldPosition(a3, (__n128 *)&buf);
      LODWORD(v43) = 0;
      float32x4_t v47 = a1[298];
      float32x4_t v48 = vmulq_f32(buf, v47);
      float v49 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1)))).f32[0];
      if (v49 < 0.0) {
        float v49 = 0.0;
      }
      if (v37[2] > v49) {
        goto LABEL_37;
      }
      if (v38 >= 2)
      {
        LODWORD(v43) = v38;
        float32x4_t v50 = v37 + 5;
        uint64_t v51 = 1;
        while (*v50 <= v49)
        {
          ++v51;
          v50 += 3;
          if (v38 == v51) {
            goto LABEL_37;
          }
        }
        LODWORD(v43) = v51;
        goto LABEL_37;
      }
    }
    LODWORD(v43) = 1;
LABEL_37:
    if ((int)v43 >= 1)
    {
      uint64_t v52 = a3[14].i64[1] + 12 * v43;
      __int16 v4 = *(_WORD *)v52;
      __int16 v5 = *(_WORD *)(v52 + 2);
      int v7 = *(_DWORD *)(v52 + 4);
    }
  }
  float32x4_t v53 = &v3[307].i32[2];
  if ((v3[307].i32[2] + v7) > v3[307].i32[3])
  {
    float32x4_t v54 = scn_default_log();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
      C3D::ScenePass::_shouldPushNodeToVisible(v54, v55, v56, v57, v58, v59, v60, v61);
    }
  }
  uint64_t v62 = *v53;
  if (v7)
  {
    int v63 = 0;
    float32x4_t v64 = (__int16 *)(v65->i64[0] + 4 * v62);
    do
    {
      *float32x4_t v64 = v4;
      v64[1] = v5 + v63++;
      v64 += 2;
    }
    while (v7 != v63);
  }
  *float32x4_t v53 = v62 + v7;
}

uint64_t C3DEngineContextGetFrameIndex(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 1704);
  if (result) {
    return -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](result);
  }
  return result;
}

void *SCNMTLBufferPool::allocateAndCopy@<X0>(SCNMTLBufferPool *this@<X0>, const void *a2@<X1>, size_t a3@<X2>, void **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  SCNMTLBufferPool::allocate(this, a3, a4);
  int v7 = *a4;

  return memcpy(v7, a2, a3);
}

unint64_t SCNMTLBufferPool::allocate@<X0>(SCNMTLBufferPool *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t result = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](*(void *)this);
  unint64_t v7 = (a2 + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v8 = *((void *)this + 11);
  uint64_t v9 = v8 + v7;
  if (v8 + v7 > *((void *)this + 10))
  {
    do
    {
      uint64_t v10 = *((void *)this + 4);
      uint64_t v11 = *((unsigned int *)this + 14);
      if (v11 >= ((unint64_t)(*((void *)this + 5) - v10) >> 4))
      {
        unint64_t v14 = 0;
        do
          v14 += *((void *)this + 1);
        while (v7 > v14);
        uint64_t v15 = -[SCNMTLResourceManager newConstantBufferWithLength:options:](*(void *)this, v14, 16 * *((void *)this + 3));
        uint64_t v16 = v15;
        *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = v15;
        unint64_t v18 = *((void *)this + 5);
        unint64_t v17 = *((void *)this + 6);
        if (v18 >= v17)
        {
          uint64_t v20 = *((void *)this + 4);
          uint64_t v21 = (uint64_t)(v18 - v20) >> 4;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 60) {
            abort();
          }
          uint64_t v23 = v17 - v20;
          if (v23 >> 3 > v22) {
            unint64_t v22 = v23 >> 3;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24) {
            long long v25 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)this + 48, v24);
          }
          else {
            long long v25 = 0;
          }
          uint64_t v26 = &v25[16 * v21];
          *(void *)uint64_t v26 = v16;
          *((_DWORD *)v26 + 2) = 1;
          long long v28 = (char *)*((void *)this + 4);
          uint64_t v27 = (char *)*((void *)this + 5);
          uint64_t v29 = v26;
          if (v27 != v28)
          {
            do
            {
              *((_OWORD *)v29 - 1) = *((_OWORD *)v27 - 1);
              v29 -= 16;
              v27 -= 16;
            }
            while (v27 != v28);
            uint64_t v27 = (char *)*((void *)this + 4);
          }
          uint64_t v19 = v26 + 16;
          *((void *)this + 4) = v29;
          *((void *)this + 5) = v26 + 16;
          *((void *)this + 6) = &v25[16 * v24];
          if (v27) {
            operator delete(v27);
          }
        }
        else
        {
          *(void *)unint64_t v18 = v15;
          *(_DWORD *)(v18 + _Block_object_dispose(&STACK[0x380], 8) = 1;
          uint64_t v19 = (char *)(v18 + 16);
        }
        *((void *)this + 5) = v19;
        LODWORD(v11) = *((_DWORD *)this + 14);
        uint64_t v13 = (void *)*((void *)this + 8);
      }
      else
      {
        uint64_t v12 = v10 + 16 * v11;
        uint64_t v13 = *(void **)v12;
        *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = *(void *)v12;
        ++*(_DWORD *)(v12 + 8);
      }
      *((_DWORD *)this + 14) = v11 + 1;
      *((void *)this + 11) = 0;
      *((void *)this + 9) = [v13 contents];
      unint64_t result = [*((id *)this + 8) length];
      *((void *)this + 10) = result;
      uint64_t v8 = *((void *)this + 11);
      uint64_t v9 = v8 + v7;
    }
    while (v8 + v7 > result);
  }
  a3[2] = v8;
  uint64_t v30 = *((void *)this + 8);
  *a3 = *((void *)this + 9) + v8;
  a3[1] = v30;
  *((void *)this + 11) = v9;
  return result;
}

uint64_t C3DSceneGetLayerRootNode(uint64_t a1, int a2)
{
  if (!a1)
  {
    __int16 v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 >= 4)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DSceneSetLayerRootNode_cold_1();
    }
  }
  return *(void *)(a1 + 8 * a2 + 384);
}

CFSetRef C3DEngineContextApplyModifiers(uint64_t a1, uint64_t a2)
{
  uint64_t Stats = C3DEngineContextGetStats(a1);
  CFSetRef result = (const __CFSet *)C3DEnginePipelineGetNodesForKey(a2, @"kDeformerStackKey", 0);
  if (result)
  {
    CFSetRef v6 = result;
    uint64_t v7 = *(void *)(a1 + 1704);
    if (v7) {
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v7);
    }
    kdebug_trace();
    double v8 = CACurrentMediaTime();
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    v14[2] = __C3DEngineContextApplyModifiers_block_invoke;
    v14[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    uint8_t v14[4] = a1;
    C3DCFSetApplyBlock(v6, (uint64_t)v14);
    *(double *)(Stats + 144) = *(double *)(Stats + 144) + CACurrentMediaTime() - v8;
    uint64_t v9 = *(void *)(a1 + 1704);
    if (v9) {
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v9);
    }
    kdebug_trace();
    uint64_t v10 = *(void *)(a1 + 1704);
    if (v10) {
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v10);
    }
    kdebug_trace();
    double v11 = CACurrentMediaTime();
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    _OWORD v13[2] = __C3DEngineContextApplyModifiers_block_invoke_2;
    v13[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    v13[4] = a1;
    C3DCFSetApplyBlock(v6, (uint64_t)v13);
    *(double *)(Stats + 136) = *(double *)(Stats + 136) + CACurrentMediaTime() - v11;
    uint64_t v12 = *(void *)(a1 + 1704);
    if (v12) {
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v12);
    }
    return (const __CFSet *)kdebug_trace();
  }
  return result;
}

uint64_t C3DEngineContextGetStats(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 1696);
}

const void *__C3DEnginePipelineGetNodesForKey(uint64_t a1, void *key, int a3, int a4)
{
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 24);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    *(void *)(a1 + 24) = Mutable;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(Mutable, key);
  if (Value) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = a3 == 0;
  }
  if (!v10)
  {
    CFDictionaryRef Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), key, Value);
    CFRelease(Value);
  }
  if (Value) {
    BOOL v11 = a4 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11 && CFEqual(key, @"kDeformerStackKey"))
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    _OWORD v13[2] = ____C3DEnginePipelineGetNodesForKey_block_invoke;
    v13[3] = &unk_264007168;
    v13[4] = &v14;
    void v13[5] = Value;
    C3DCFSetApplyBlock((const __CFSet *)Value, (uint64_t)v13);
    if (v15[3]) {
      CFDictionaryRef Value = (const void *)v15[3];
    }
    _Block_object_dispose(&v14, 8);
  }
  return Value;
}

void sub_20B2990F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const void *C3DEnginePipelineGetNodesForKey(uint64_t a1, void *a2, int a3)
{
  return __C3DEnginePipelineGetNodesForKey(a1, a2, a3, 1);
}

void C3DEngineContextSetViewport(__n128 a1, __n128 *a2)
{
  a2[15] = a1;
  if (a2[8].n128_u64[1]) {
    C3DRendererContextSetViewport(a1);
  }
}

uint64_t C3DEngineContextSetDrawableSize(uint64_t result, double a2)
{
  *(double *)(result + 352) = a2;
  return result;
}

uint64_t C3DEngineContextGetPreferredRenderMode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 213);
}

void sub_20B299A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double SCNMTLBufferPool::reset(SCNMTLBufferPool *this)
{
  *((_DWORD *)this + 14) = 0;
  double result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  return result;
}

void SCNMTLTexturePool::reset(SCNMTLTexturePool *this)
{
  uint64_t v3 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3);
  if (v3 == v2)
  {
    uint64_t v3 = *((void *)this + 3);
  }
  else
  {
    do
    {
      unsigned int v4 = *(_DWORD *)(v3 + 28);
      *(_DWORD *)(v3 + 2_Block_object_dispose(&STACK[0x380], 8) = v4 + 1;
      if (v4 < 0x65)
      {
        v3 += 32;
      }
      else
      {

        uint64_t v5 = *((void *)this + 3);
        uint64_t v6 = v5 - (v3 + 32);
        if (v5 != v3 + 32) {
          memmove((void *)v3, (const void *)(v3 + 32), v5 - (v3 + 32));
        }
        uint64_t v2 = v3 + v6;
        *((void *)this + 3) = v3 + v6;
      }
    }
    while (v3 != v2);
    uint64_t v2 = *((void *)this + 2);
  }
  *((_DWORD *)this + 10) = (unint64_t)(v3 - v2) >> 5;
}

void __C3DMeshDeindex(CFArrayRef *a1, __CFArray **a2, __CFArray **a3, unsigned int **a4, unsigned int *a5, unsigned int **a6)
{
  BOOL v10 = a2;
  uint64_t v259 = *MEMORY[0x263EF8340];
  *a2 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  CFIndex Count = CFArrayGetCount(a1[8]);
  v221 = (__C3DMesh *)a1;
  CFIndex v215 = CFArrayGetCount(a1[12]);
  CFAllocatorRef v237 = (CFAllocatorRef)Count;
  if (Count < 1)
  {
    LOBYTE(v17) = 0;
    goto LABEL_11;
  }
  BOOL v13 = 0;
  uint64_t v14 = 0;
  CFAllocatorRef v15 = 0;
  while (1)
  {
    uint64_t ChannelForSourceAtIndex = C3DMeshGetChannelForSourceAtIndex((uint64_t)v221, (uint64_t)v15);
    uint64_t v17 = ChannelForSourceAtIndex;
    if (v15) {
      break;
    }
LABEL_6:
    CFAllocatorRef v15 = (const __CFAllocator *)((char *)v15 + 1);
    BOOL v13 = (uint64_t)v15 >= (uint64_t)v237;
    uint64_t v14 = v17;
    if (v237 == v15) {
      goto LABEL_11;
    }
  }
  if (v14 == ChannelForSourceAtIndex)
  {
    uint64_t v17 = v14;
    goto LABEL_6;
  }
  if (v13 || v215 < 1)
  {
    LOBYTE(v17) = v14;
    goto LABEL_11;
  }
  uint64_t ElementAtIndex = C3DMeshGetElementAtIndex((int)v221, 0);
  v204 = a5;
  v205 = a6;
  v203 = a4;
  if (!C3DMeshElementGetAllChannelsDefineSameTopology(ElementAtIndex)) {
    goto LABEL_43;
  }
  float v42 = a3;
  *(void *)&long long v41 = 134218496;
  long long v236 = v41;
  uint64_t v43 = 1;
  do
  {
    CFIndex v44 = v43;
    IndicesChannelCFIndex Count = C3DMeshElementGetIndicesChannelCount(ElementAtIndex);
    if (IndicesChannelCount >= 2
      && (__C3DMeshDeindex(__C3DMesh *,__CFArray **,__CFArray **,unsigned int **,unsigned int *,unsigned int **)::done & 1) == 0)
    {
      unsigned int v46 = IndicesChannelCount;
      __C3DMeshDeindex(__C3DMesh *,__CFArray **,__CFArray **,unsigned int **,unsigned int *,unsigned int **)::done = 1;
      float32x4_t v47 = scn_default_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float32x4_t buf = v236;
        *(void *)&uint8_t buf[4] = ElementAtIndex;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v221;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v251) = v46;
        _os_log_error_impl(&dword_20B249000, v47, OS_LOG_TYPE_ERROR, "Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology", buf, 0x1Cu);
      }
    }
    if (v215 == v44) {
      break;
    }
    uint64_t ElementAtIndex = C3DMeshGetElementAtIndex((int)v221, v44);
    int AllChannelsDefineSameTopology = C3DMeshElementGetAllChannelsDefineSameTopology(ElementAtIndex);
    uint64_t v43 = v44 + 1;
  }
  while (AllChannelsDefineSameTopology);
  LOBYTE(v17) = v14;
  a3 = v42;
  if (v44 >= v215)
  {
LABEL_11:
    ElementsCFIndex Count = C3DMeshGetElementsCount((uint64_t)v221);
    LODWORD(v19) = ElementsCount;
    if (ElementsCount)
    {
      CFIndex v20 = 0;
      uint64_t v21 = ElementsCount;
      while (1)
      {
        uint64_t v22 = C3DMeshGetElementAtIndex((int)v221, v20);
        unsigned int v23 = C3DMeshElementGetIndicesChannelCount(v22);
        if (v23 <= v17)
        {
          uint64_t v26 = scn_default_log();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            __C3DMeshDeindex(v17, v22, v26);
          }
          return;
        }
        if (v23 >= 2) {
          break;
        }
        if (v21 == ++v20) {
          goto LABEL_16;
        }
      }
      v207 = v10;
      v208 = a3;
      CFAllocatorRef v237 = (CFAllocatorRef)*MEMORY[0x263EFFB08];
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v237, v19, MEMORY[0x263EFFF70]);
      MutableCFSetRef Copy = Mutable;
      CFIndex v28 = 0;
      uint64_t v235 = v17;
      int64_t v233 = *MEMORY[0x263EFFB18];
      size_t v234 = (size_t)&buf[16];
      if (v19 <= 1) {
        uint64_t v19 = 1;
      }
      else {
        uint64_t v19 = v19;
      }
      *(void *)&long long v236 = Mutable;
      v232 = (void *)v19;
      do
      {
        uint64_t v29 = (CFDataRef *)C3DMeshGetElementAtIndex((int)v221, v28);
        if (C3DMeshElementGetIndicesChannelCount((uint64_t)v29) == 1)
        {
          CFArrayAppendValue(MutableCopy, v29);
        }
        else
        {
          int Type = C3DMeshElementGetType((uint64_t)v29);
          PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)v29);
          uint64_t BytesPerIndex = C3DMeshElementGetBytesPerIndex((uint64_t)v29);
          IndexCFIndex Count = C3DMeshElementGetIndexCount((uint64_t)v29);
          if (Type == 4)
          {
            unint64_t v34 = BytesPerIndex * (unint64_t)(IndexCount + PrimitiveCount);
            int v35 = malloc_type_malloc(v34, 0x88C313D8uLL);
            int v36 = PrimitiveCount;
            BytePtr = CFDataGetBytePtr(v29[12]);
            memcpy(v35, BytePtr, PrimitiveCount * (unint64_t)BytesPerIndex);
          }
          else
          {
            unint64_t v34 = IndexCount * (unint64_t)BytesPerIndex;
            int v35 = malloc_type_malloc(v34, 0xE8BBA66CuLL);
            int v36 = PrimitiveCount;
            PrimitiveCFIndex Count = 0;
          }
          v257[0] = 0;
          v257[1] = v257;
          v257[2] = 0x2000000000;
          int v258 = 0;
          uint64_t v245 = 0;
          long long v243 = 0u;
          __n128 v244 = 0u;
          long long v242 = 0u;
          C3DMeshElementGetContent((uint64_t)v29, v235, (uint64_t)&v242);
          long long v238 = v242;
          long long v239 = v243;
          __n128 v240 = v244;
          uint64_t v241 = v245;
          *(void *)float32x4_t buf = MEMORY[0x263EF8330];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL40__C3DMeshCopyDeindexedElementsForChannelP9__C3DMeshh_block_invoke;
          v251 = &unk_26400B4A0;
          unsigned int v256 = PrimitiveCount;
          v252 = v257;
          v253 = v35;
          uint64_t v254 = BytesPerIndex;
          unint64_t v255 = v34;
          C3DIndicesContentEnumeratePrimitives((uint64_t *)&v238, (uint64_t)buf, v244);
          CFDataRef v38 = CFDataCreateWithBytesNoCopy(v237, (const UInt8 *)v35, v34, (CFAllocatorRef)v233);
          float32x4_t v39 = (const void *)C3DMeshElementCreate();
          C3DMeshElementInit((uint64_t)v39, Type, v36, v38, BytesPerIndex);
          MutableCFSetRef Copy = (__CFArray *)v236;
          CFArrayAppendValue((CFMutableArrayRef)v236, v39);
          CFRelease(v38);
          CFRelease(v39);
          _Block_object_dispose(v257, 8);
          uint64_t v19 = (uint64_t)v232;
        }
        ++v28;
      }
      while (v19 != v28);
      BOOL v10 = v207;
      a3 = v208;
      if (!MutableCopy) {
        return;
      }
    }
    else
    {
LABEL_16:
      CFArrayRef v24 = (const __CFArray *)*((void *)v221 + 12);
      CFAllocatorRef v237 = (CFAllocatorRef)*MEMORY[0x263EFFB08];
      MutableCFSetRef Copy = CFArrayCreateMutableCopy(v237, 0, v24);
      if (!MutableCopy) {
        return;
      }
    }
    NSObject *v10 = CFArrayCreateMutableCopy(v237, 0, *((CFArrayRef *)v221 + 8));
    *a3 = MutableCopy;
  }
  else
  {
LABEL_43:
    v207 = v10;
    v208 = a3;
    CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    float32x4_t v50 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
    CFAllocatorRef v51 = v237;
    CFMutableArrayRef v201 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], (CFIndex)v237, MEMORY[0x263EFFF70]);
    CFAllocatorRef v213 = v49;
    CFArrayRef v212 = CFArrayCreateMutable(v49, v215, v50);
    v202 = &v199;
    MEMORY[0x270FA5388](v212);
    uint64_t v52 = &(&v199)[-8 * (void)v51];
    unsigned __int8 v53 = 0;
    size_t v218 = 0;
    CFAllocatorRef v54 = 0;
    v206 = v52;
    do
    {
      uint64_t v55 = v221;
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)v221 + 8), (CFIndex)v54);
      uint64_t Accessor = C3DMeshSourceGetAccessor();
      unsigned __int8 v58 = C3DMeshGetChannelForSourceAtIndex((uint64_t)v55, (uint64_t)v54);
      unsigned int v59 = C3DSourceAccessorGetCount(Accessor);
      int ComponentsValueType = C3DSourceAccessorGetComponentsValueType(Accessor);
      ComponentsCountPerCFDictionaryRef Value = C3DSourceAccessorGetComponentsCountPerValue(Accessor);
      uint64_t v62 = C3DSizeOfBaseType(ComponentsValueType);
      if (ComponentsValueType == 15 && ComponentsCountPerValue == 3)
      {
        uint64_t v64 = 4 * C3DSizeOfBaseType(15);
        ComponentsCountPerCFDictionaryRef Value = 4;
      }
      else
      {
        uint64_t v64 = v62 * ComponentsCountPerValue;
      }
      *uint64_t v52 = ValueAtIndex;
      v52[1] = (void *)Accessor;
      *((unsigned char *)v52 + 16) = v58;
      v52[3] = (void *)v64;
      *((_WORD *)v52 + 16) = ComponentsValueType;
      v52[5] = (void *)ComponentsCountPerValue;
      *((_DWORD *)v52 + 14) = 0;
      *((_DWORD *)v52 + 15) = v59;
      v52[6] = malloc_type_malloc(v64 * v59, 0x2C204862uLL);
      SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      if (Semantic) {
        size_t v66 = v218;
      }
      else {
        size_t v66 = v59;
      }
      size_t v218 = v66;
      if (!Semantic) {
        unsigned __int8 v53 = v58;
      }
      CFAllocatorRef v54 = (const __CFAllocator *)((char *)v54 + 1);
      v52 += 8;
    }
    while (v237 != v54);
    long long v242 = 0uLL;
    *(void *)&long long v243 = 0;
    v230 = malloc_type_calloc(v218, 4uLL, 0x100004052888210uLL);
    *((void *)&v238 + 1) = 0;
    *(void *)&long long v239 = 0;
    *(void *)&long long v238 = (char *)&v238 + 8;
    CFAllocatorRef v68 = v213;
    if (v215 < 1) {
      goto LABEL_135;
    }
    CFIndex v69 = 0;
    int v227 = 0;
    v228 = &v249;
    uint64_t v229 = v53;
    v226 = &v243;
    v199 = (void *)((char *)v257 + 4);
    v200 = &v247;
    CFAllocatorRef v211 = (CFAllocatorRef)*MEMORY[0x263EFFB18];
    v222 = (unsigned __int8 *)(v206 + 2);
    v231 = (char **)(v206 + 6);
    *(void *)&long long v67 = 134218498;
    long long v210 = v67;
    *(void *)&long long v67 = 67109632;
    long long v209 = v67;
    do
    {
      CFIndex v216 = v69;
      uint64_t v70 = C3DMeshGetElementAtIndex((int)v221, v69);
      int v217 = C3DMeshElementGetType(v70);
      uint64_t v71 = C3DMeshElementGetPrimitiveCount(v70);
      LODWORD(v236) = C3DMeshElementGetBytesPerIndex(v70);
      uint64_t v72 = C3DMeshElementGetIndexCount(v70);
      uint64_t v224 = v71;
      if (v71 < 1)
      {
        v225 = 0;
        uint64_t v74 = v71;
      }
      else
      {
        uint64_t v73 = 0;
        v225 = 0;
        uint64_t v74 = v71;
        do
        {
          uint64_t VertexCountForPrimitiveAtIndex = C3DMeshElementGetVertexCountForPrimitiveAtIndex(v70, v73);
          if (VertexCountForPrimitiveAtIndex >= 1)
          {
            uint64_t v76 = VertexCountForPrimitiveAtIndex;
            uint64_t v77 = v72;
            uint64_t v78 = 0;
            while (2)
            {
              CFAllocatorRef v79 = v237;
              float v80 = v222;
              do
              {
                unsigned int Index = C3DMeshElementGetIndex(v70, v73, v78, *v80);
                if (C3DSourceAccessorGetCount(*((void *)v80 - 1)) <= Index)
                {
                  uint64_t v82 = scn_default_log();
                  if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v85 = *((void *)v80 - 2);
                    int v86 = C3DMeshSourceGetSemantic(v85);
                    float32x4_t v87 = C3DMeshSourceSemanticToSemanticString(v86);
                    *(_DWORD *)float32x4_t buf = v210;
                    *(void *)&uint8_t buf[4] = v85;
                    *(_WORD *)&buf[12] = 2112;
                    *(void *)&buf[14] = v87;
                    *(_WORD *)&buf[22] = 1024;
                    LODWORD(v251) = Index;
                    _os_log_error_impl(&dword_20B249000, v82, OS_LOG_TYPE_ERROR, "Error: Deindexer issue - source %p (%@) has no original data at index %u", buf, 0x1Cu);
                  }
                  uint64_t v83 = scn_default_log();
                  if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)float32x4_t buf = v209;
                    *(_DWORD *)&uint8_t buf[4] = v73;
                    *(_WORD *)&buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v216;
                    *(_WORD *)&buf[14] = 2048;
                    *(void *)&buf[16] = v70;
                    _os_log_error_impl(&dword_20B249000, v83, OS_LOG_TYPE_ERROR, "Error: Deindexer issue - will discard face #%u of element at index %d (%p)", buf, 0x18u);
                  }
                  uint64_t v71 = v224;
                  float v84 = v225;
                  if (!v225) {
                    float v84 = (unsigned __int8 *)malloc_type_calloc(v224, 1uLL, 0x100004077774924uLL);
                  }
                  --v74;
                  uint64_t v72 = v77 - v76;
                  v225 = v84;
                  v84[v73] = 1;
                  goto LABEL_74;
                }
                v80 += 64;
                CFAllocatorRef v79 = (CFAllocatorRef)((char *)v79 - 1);
              }
              while (v79);
              if (++v78 != v76) {
                continue;
              }
              break;
            }
            uint64_t v72 = v77;
            uint64_t v71 = v224;
          }
LABEL_74:
          ++v73;
        }
        while (v73 != v71);
      }
      size_t v234 = v236;
      if (v217 == 4)
      {
        int64_t v233 = (v72 + v74) * v236;
        BOOL v88 = (char *)malloc_type_malloc(v233, 0xEE2BE34uLL);
        size_t v89 = v234;
        unsigned int v90 = v88;
        size_t v91 = v74 * v234;
        if (v225)
        {
          *(void *)&long long v236 = v74 * v234;
          unsigned int v92 = v88;
          if (v71 < 1)
          {
            uint64_t v94 = 0;
          }
          else
          {
            uint64_t v93 = 0;
            uint64_t v94 = 0;
            uint64_t v95 = v225;
            uint64_t v96 = v71;
            do
            {
              if (!*v95++)
              {
                float32x4_t v98 = CFDataGetBytePtr(*(CFDataRef *)(v70 + 96));
                memcpy(&v92[v94], &v98[v93], v234);
                size_t v89 = v234;
                v94 += v234;
              }
              v93 += v89;
              --v96;
            }
            while (v96);
          }
          unsigned int v90 = v92;
          if (v94 != (void)v236)
          {
            int32x4_t v100 = scn_default_log();
            if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
              __C3DMeshDeindex((uint8_t *)v257, v199, v100);
            }
          }
        }
        else
        {
          float32x4_t v99 = CFDataGetBytePtr(*(CFDataRef *)(v70 + 96));
          memcpy(v90, v99, v91);
        }
        uint64_t v219 = v74;
      }
      else
      {
        int64_t v233 = v72 * v236;
        unsigned int v90 = malloc_type_malloc(v233, 0xB984662AuLL);
        uint64_t v219 = 0;
      }
      uint64_t v214 = v72;
      if (v71 < 1)
      {
        uint64_t v102 = 0;
        float32x4_t v103 = v225;
      }
      else
      {
        uint64_t v101 = 0;
        uint64_t v102 = 0;
        float32x4_t v103 = v225;
        uint64_t v220 = v74;
        v232 = v90;
        do
        {
          if (!v103 || !v103[v101])
          {
            *(void *)&long long v236 = C3DMeshElementGetVertexCountForPrimitiveAtIndex(v70, v101);
            uint64_t v223 = v102;
            if ((uint64_t)v236 >= 1)
            {
              uint64_t v104 = 0;
              uint64_t v235 = v102 + v219;
              do
              {
                int v105 = v239;
                *(void *)float32x4_t buf = v70;
                *(void *)&buf[8] = v101;
                *(void *)&buf[16] = v104;
                LODWORD(v251) = v239;
                uint64_t v106 = std::__tree<std::__value_type<__C3DMeshDeindexerKey,unsigned int>,std::__map_value_compare<__C3DMeshDeindexerKey,std::__value_type<__C3DMeshDeindexerKey,unsigned int>,__C3DMeshDeindexerKeyComparator,true>,std::allocator<std::__value_type<__C3DMeshDeindexerKey,unsigned int>>>::__emplace_unique_key_args<__C3DMeshDeindexerKey,std::pair<__C3DMeshDeindexerKey,unsigned int>>((uint64_t **)&v238, (uint64_t *)buf, (uint64_t)buf);
                uint64_t v108 = v107;
                __writeIndexInBuffer((unsigned __int8 *)v90, v235 + v104, *((_DWORD *)v106 + 14), v234, v233);
                CFAllocatorRef v109 = v237;
                uint64_t v110 = v231;
                if (v108)
                {
                  do
                  {
                    uint64_t v112 = *((unsigned int *)v110 + 2);
                    int v111 = *((_DWORD *)v110 + 3);
                    if (v111 == v112)
                    {
                      uint64_t v113 = (2 * v111);
                      *((_DWORD *)v110 + 3) = v113;
                      size_t v114 = (size_t)*(v110 - 3);
                      __int16 v115 = (char *)malloc_type_realloc(*v110, v114 * v113, 0x3B803E7AuLL);
                      *uint64_t v110 = v115;
                    }
                    else
                    {
                      __int16 v115 = *v110;
                      size_t v114 = (size_t)*(v110 - 3);
                    }
                    __int16 v116 = &v115[v114 * v112];
                    unsigned int v117 = C3DMeshElementGetIndex(v70, v101, v104, *((unsigned __int8 *)v110 - 32));
                    ValuePtrAtunsigned int Index = C3DSourceAccessorGetValuePtrAtIndex(*(v110 - 5), v117);
                    memcpy(v116, ValuePtrAtIndex, v114);
                    if (v112 != v105)
                    {
                      unsigned int v119 = scn_default_log();
                      if (os_log_type_enabled(v119, OS_LOG_TYPE_FAULT)) {
                        __C3DMeshDeindex(v248, v228, v119);
                      }
                    }
                    *((_DWORD *)v110 + 2) = v112 + 1;
                    v110 += 8;
                    CFAllocatorRef v109 = (CFAllocatorRef)((char *)v109 - 1);
                  }
                  while (v109);
                  int v120 = C3DMeshElementGetIndex(v70, v101, v104, v229);
                  int v121 = v120;
                  uint64_t v122 = (char *)*((void *)&v242 + 1);
                  if (*((void *)&v242 + 1) >= (unint64_t)v243)
                  {
                    __int16 v124 = (char *)v242;
                    uint64_t v125 = (uint64_t)(*((void *)&v242 + 1) - v242) >> 2;
                    unint64_t v126 = v125 + 1;
                    unsigned int v90 = v232;
                    if ((unint64_t)(v125 + 1) >> 62) {
LABEL_181:
                    }
                      abort();
                    uint64_t v127 = v243 - v242;
                    if ((uint64_t)(v243 - v242) >> 1 > v126) {
                      unint64_t v126 = v127 >> 1;
                    }
                    if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v128 = 0x3FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v128 = v126;
                    }
                    if (v128)
                    {
                      int v129 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v226, v128);
                      uint64_t v122 = (char *)*((void *)&v242 + 1);
                      __int16 v124 = (char *)v242;
                    }
                    else
                    {
                      int v129 = 0;
                    }
                    uint64_t v130 = &v129[4 * v125];
                    *(_DWORD *)uint64_t v130 = v121;
                    unsigned int v123 = v130 + 4;
                    while (v122 != v124)
                    {
                      int v131 = *((_DWORD *)v122 - 1);
                      v122 -= 4;
                      *((_DWORD *)v130 - 1) = v131;
                      v130 -= 4;
                    }
                    *(void *)&long long v242 = v130;
                    *((void *)&v242 + 1) = v123;
                    *(void *)&long long v243 = &v129[4 * v128];
                    if (v124) {
                      operator delete(v124);
                    }
                  }
                  else
                  {
                    **((_DWORD **)&v242 + 1) = v120;
                    unsigned int v123 = v122 + 4;
                    unsigned int v90 = v232;
                  }
                  *((void *)&v242 + 1) = v123;
                  if (!v230[v121]) {
                    v230[v121] = (unint64_t)((unint64_t)v123 - v242) >> 2;
                  }
                }
                else
                {
                  int v227 = 1;
                  unsigned int v90 = v232;
                }
                ++v104;
              }
              while (v104 != (void)v236);
            }
            uint64_t v102 = v236 + v223;
            LODWORD(v74) = v220;
            float32x4_t v103 = v225;
          }
          ++v101;
        }
        while (v101 != v224);
      }
      free(v103);
      if (v102 != v214)
      {
        int8x16_t v132 = scn_default_log();
        if (os_log_type_enabled(v132, OS_LOG_TYPE_FAULT)) {
          __C3DMeshDeindex(v246, v200, v132);
        }
      }
      CFAllocatorRef v68 = v213;
      CFDataRef v133 = CFDataCreateWithBytesNoCopy(v213, (const UInt8 *)v90, v233, v211);
      CFStringRef v134 = (const void *)C3DMeshElementCreate();
      C3DMeshElementInit((uint64_t)v134, v217, v74, v133, v234);
      CFArrayAppendValue(v212, v134);
      CFRelease(v134);
      CFRelease(v133);
      CFIndex v69 = v216 + 1;
    }
    while (v216 + 1 != v215);
    if ((v227 & 1) == 0)
    {
LABEL_135:
      char v136 = scn_default_log();
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)float32x4_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v221;
        _os_log_impl(&dword_20B249000, v136, OS_LOG_TYPE_DEFAULT, "Warning: Mesh %p has multiple channels but deindexing didn't have any effect", buf, 0xCu);
      }
    }
    char v137 = v230;
    size_t v138 = v218;
    if (v218)
    {
      uint64_t v139 = 0;
      char v140 = 0;
      int v141 = 0;
      uint64_t v235 = (uint64_t)&v243;
      v142 = (char **)(v206 + 6);
      *(void *)&long long v135 = 67109376;
      long long v236 = v135;
      do
      {
        int v143 = v137[v139];
        if (v143)
        {
          int v144 = v143 - 1;
        }
        else
        {
          int v145 = scn_default_log();
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)float32x4_t buf = v236;
            *(_DWORD *)&uint8_t buf[4] = v139;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v138;
            _os_log_impl(&dword_20B249000, v145, OS_LOG_TYPE_DEFAULT, "Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element", buf, 0xEu);
          }
          CFAllocatorRef v146 = v237;
          v147 = v142;
          if (v140)
          {
            char v140 = 1;
            int v144 = v141;
            CFAllocatorRef v68 = v213;
          }
          else
          {
            do
            {
              uint64_t v149 = *((unsigned int *)v147 + 2);
              int v148 = *((_DWORD *)v147 + 3);
              if (v148 == v149)
              {
                uint64_t v150 = (v148 + 1);
                *((_DWORD *)v147 + 3) = v150;
                size_t v151 = (size_t)*(v147 - 3);
                v152 = (char *)malloc_type_realloc(*v147, v151 * v150, 0x32DBE2BDuLL);
                NSObject *v147 = v152;
              }
              else
              {
                v152 = *v147;
                size_t v151 = (size_t)*(v147 - 3);
              }
              bzero(&v152[v151 * v149], v151);
              *((_DWORD *)v147 + 2) = v149 + 1;
              v147 += 8;
              CFAllocatorRef v146 = (CFAllocatorRef)((char *)v146 - 1);
            }
            while (v146);
            v153 = (char *)*((void *)&v242 + 1);
            if (*((void *)&v242 + 1) >= (unint64_t)v243)
            {
              v155 = (char *)v242;
              uint64_t v156 = (uint64_t)(*((void *)&v242 + 1) - v242) >> 2;
              unint64_t v157 = v156 + 1;
              if ((unint64_t)(v156 + 1) >> 62) {
                goto LABEL_181;
              }
              uint64_t v158 = v243 - v242;
              if ((uint64_t)(v243 - v242) >> 1 > v157) {
                unint64_t v157 = v158 >> 1;
              }
              if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v159 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v159 = v157;
              }
              CFAllocatorRef v68 = v213;
              if (v159)
              {
                int v160 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v235, v159);
                v153 = (char *)*((void *)&v242 + 1);
                v155 = (char *)v242;
              }
              else
              {
                int v160 = 0;
              }
              v161 = &v160[4 * v156];
              *(_DWORD *)v161 = v139;
              v154 = v161 + 4;
              while (v153 != v155)
              {
                int v162 = *((_DWORD *)v153 - 1);
                v153 -= 4;
                *((_DWORD *)v161 - 1) = v162;
                v161 -= 4;
              }
              *(void *)&long long v242 = v161;
              *((void *)&v242 + 1) = v154;
              *(void *)&long long v243 = &v160[4 * v159];
              if (v155) {
                operator delete(v155);
              }
            }
            else
            {
              **((_DWORD **)&v242 + 1) = v139;
              v154 = v153 + 4;
              CFAllocatorRef v68 = v213;
            }
            *((void *)&v242 + 1) = v154;
            int v144 = ((unint64_t)((unint64_t)v154 - v242) >> 2) - 1;
            char v140 = 1;
            int v141 = v144;
          }
          size_t v138 = v218;
        }
        char v137 = v230;
        v230[v139++] = v144;
      }
      while (v139 != v138);
    }
    *(void *)&long long v236 = (*((void *)&v242 + 1) - (void)v242) >> 2;
    size_t v163 = (*((void *)&v242 + 1) - v242) & 0x3FFFFFFFCLL;
    v164 = malloc_type_malloc(v163, 0xB700A5C4uLL);
    memcpy(v164, (const void *)v242, v163);
    v165 = (__int16 *)(v206 + 4);
    CFAllocatorRef v166 = v237;
    long long v167 = v201;
    do
    {
      uint64_t v168 = *((unsigned int *)v165 + 6);
      __int16 v169 = C3DMeshSourceGetSemantic(*((void *)v165 - 4));
      uint64_t v170 = *((void *)v165 - 1);
      CFDataRef v171 = CFDataCreate(v68, *((const UInt8 **)v165 + 2), v170 * v168);
      long long v172 = (const void *)C3DMeshSourceCreateWithData(v169, v171, *v165, *((void *)v165 + 1), v168, v170, 0);
      CFArrayAppendValue(v167, v172);
      CFRelease(v172);
      CFRelease(v171);
      v165 += 32;
      CFAllocatorRef v166 = (CFAllocatorRef)((char *)v166 - 1);
    }
    while (v166);
    long long v173 = (void **)(v206 + 6);
    CFAllocatorRef v174 = v237;
    long long v175 = v203;
    do
    {
      long long v176 = *v173;
      v173 += 8;
      free(v176);
      CFAllocatorRef v174 = (CFAllocatorRef)((char *)v174 - 1);
    }
    while (v174);
    CFAllocatorRef v177 = (const __CFAllocator *)CFArrayGetCount(v167);
    v179 = v207;
    long long v178 = v208;
    v180 = v204;
    v181 = v230;
    if (v237 != v177)
    {
      uint64_t v182 = scn_default_log();
      if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT)) {
        __C3DMeshDeindex(v182, v183, v184, v185, v186, v187, v188, v189);
      }
    }
    CFIndex v190 = CFArrayGetCount(v212);
    if (v215 != v190)
    {
      v191 = scn_default_log();
      if (os_log_type_enabled(v191, OS_LOG_TYPE_FAULT)) {
        __C3DMeshDeindex(v191, v192, v193, v194, v195, v196, v197, v198);
      }
    }
    *v179 = v167;
    *long long v178 = v212;
    *long long v175 = (unsigned int *)v164;
    unsigned int *v180 = v236;
    *v205 = v181;
    std::__tree<char>::destroy((uint64_t)&v238, *((void **)&v238 + 1));
    if ((void)v242)
    {
      *((void *)&v242 + 1) = v242;
      operator delete((void *)v242);
    }
  }
}

uint64_t C3DMeshGetChannelForSourceAtIndex(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 104))
  {
    unsigned int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshGetChannelForSourceAtIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return *(unsigned __int8 *)(*(void *)(a1 + 104) + a2);
}

uint64_t C3DMeshElementGetIndicesChannelCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 130);
}

void C3DNodeGeometryDidUpdate(uint64_t *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  C3DNodeBoundingBoxDidUpdate((uint64_t)a1);
  C3DScenePostPipelineEvent(a1[6], 2, a1, @"kMeshKey");
}

uint64_t _C3DStackAllocatorCFFinalize(uint64_t a1)
{
  return __destroyChuncks(a1, 0);
}

void _C3DPostSceneDidChangeNotifications(void *object, CFNotificationCenterRef center)
{
  if (center) {
    CFNotificationCenterPostNotificationWithOptions(center, @"kC3DSceneDidUpdateNotification", object, 0, 4uLL);
  }
}

id _C3DFXMetalProgramCFFinalize(void *a1)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = (const void *)a1[v2 + 10];
    if (v5) {
      CFRelease(v5);
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  uint64_t v6 = (const void *)a1[17];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[12];
  if (v7)
  {
    CFRelease(v7);
    a1[12] = 0;
  }
  uint64_t v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  uint64_t v9 = (const void *)a1[14];
  if (v9)
  {
    CFRelease(v9);
    a1[14] = 0;
  }
  uint64_t v10 = (const void *)a1[15];
  if (v10)
  {
    CFRelease(v10);
    a1[15] = 0;
  }
  uint64_t v11 = (const void *)a1[16];
  if (v11)
  {
    CFRelease(v11);
    a1[16] = 0;
  }
  uint64_t v12 = (const void *)a1[19];
  if (v12)
  {
    CFRelease(v12);
    a1[19] = 0;
  }
  BOOL v13 = (const void *)a1[20];
  if (v13)
  {
    CFRelease(v13);
    a1[20] = 0;
  }

  return C3DFXProgramCFFinalize(a1);
}

uint64_t C3DShaderModifierGetFlags(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(__int16 *)(a1 + 92);
}

CFIndex CFStringToStringDictionaryHash(uint64_t a1, uint64_t a2)
{
  CFIndex result = CFStringUpdateHash(a1);
  if (a2)
  {
    return CFStringUpdateHash(a2);
  }
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

uint64_t _C3DUnlockScenesAndBumpStateStamps(uint64_t a1)
{
  C3DSceneBumpStateStamp(a1);

  return C3DSceneUnlock(a1);
}

void C3DSceneBumpStateStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(_DWORD *)(a1 + 300);
}

void *__InjectModifiers(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  if (C3DShaderModifierGetEntryPoint(*a3) != a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __InjectModifiers_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t Declaration = C3DShaderModifierGetDeclaration(v5);
  if (Declaration) {
    [*(id *)(a1 + 32) appendString:Declaration];
  }
  uint64_t Code = C3DShaderModifierGetCode(v5);
  if (Code)
  {
    *(void *)(a1 + 8 * a2 + 4_Block_object_dispose(&STACK[0x380], 8) = Code;
  }
  else
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      __InjectModifiers_cold_1();
    }
  }
  CFDictionaryRef Defines = (const __CFDictionary *)C3DShaderModifierGetDefines(v5);
  if (Defines) {
    CFDictionaryApplyFunction(Defines, (CFDictionaryApplierFunction)__appendDictionary_1, *(void **)(a1 + 8));
  }
  CFIndex result = (void *)C3DShaderModifierGetStandardUniformsUsed(v5);
  if (result)
  {
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = ____InjectModifiers_block_invoke;
    v19[3] = &__block_descriptor_40_e25_v32__0__NSString_8_16_B24l;
    v19[4] = a1;
    return (void *)[result enumerateKeysAndObjectsUsingBlock:v19];
  }
  return result;
}

uint64_t C3DShaderModifierGetDefines(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

uint64_t C3DShaderModifierGetStandardUniformsUsed(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

uint64_t C3DShaderModifierGetDeclaration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

uint64_t C3DShaderModifierGetCode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

uint64_t __dispatchShaderModifiers(uint64_t a1, uint64_t a2)
{
  uint64_t result = C3DShaderModifierGetEntryPoint(a1);
  if (result == *(_DWORD *)(a2 + 24))
  {
    uint64_t result = C3DShaderModifierGetLanguage(a1);
    if (result == *(_DWORD *)(a2 + 28))
    {
      if (*(void *)a2)
      {
        uint64_t v5 = *(void *)(a2 + 16);
        if (v5 < *(void *)(a2 + 8))
        {
          *(void *)(*(void *)a2 + 8 * v5) = a1;
          *(void *)(a2 + 16) = v5 + 1;
        }
      }
    }
  }
  return result;
}

uint64_t ____createHashCode_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = C3DShaderModifierGetEntryPoint(a3);
  if (result == *(_DWORD *)(a1 + 40))
  {
    uint64_t v6 = *(CC_SHA256_CTX **)(a1 + 32);
    return C3DShaderModifierUpdateHashCode(a3, v6);
  }
  return result;
}

uint64_t C3DShaderModifierGetEntryPoint(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 88);
}

uint64_t C3DShaderModifierGetLanguage(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 100);
}

void _transactionsDidFlush(uint64_t a1)
{
  *(unsigned char *)(a1 + 60) |= 1u;
  C3DTransactionTestForDidComplete(a1);
}

void C3DNodeSetScale(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetScale((uint64_t)&a1[6], a2);

  __C3DNodeTransformDidChange(a1);
}

void C3DTransformSetScale(uint64_t a1, __n128 a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 92);
  if ((v3 & 4) == 0)
  {
    __n128 v23 = a2;
    if ((v3 & 8) == 0)
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        C3DTransformSetScale_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    if ((*(unsigned char *)(a1 + 92) & 4) != 0)
    {
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
        C3DTransformSetScale_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
      }
    }
    float32x4_t v20 = *(float32x4_t *)(a1 + 16);
    v24[0] = *(float32x4_t *)a1;
    v24[1] = v20;
    float32x4_t v21 = *(float32x4_t *)(a1 + 48);
    void v24[2] = *(float32x4_t *)(a1 + 32);
    v24[3] = v21;
    *(double *)&long long v22 = C3DMatrix4x4GetRotation(v24);
    *(_OWORD *)(a1 + 64) = v22;
    unsigned int v3 = *(_DWORD *)(a1 + 92) & 0xFFFFFFF8 | 4;
    a2 = v23;
  }
  *(_DWORD *)(a1 + 92) = v3 & 0xFFFFFFF7;
  *(_DWORD *)(a1 + 8_Block_object_dispose(&STACK[0x380], 8) = a2.n128_u32[2];
  *(void *)(a1 + 80) = a2.n128_u64[0];
}

uint64_t __C3DShouldCollectGeneratedShaders_block_invoke()
{
  uint64_t result = objc_msgSend((id)objc_msgSend(MEMORY[0x263EFFA40], "standardUserDefaults"), "BOOLForKey:", @"com.apple.sceneKit.traceResources");
  C3DShouldCollectGeneratedShaders::traceResources = result;
  return result;
}

void __SCNRenderThread_start__(void *a1)
{
  uint64_t v1 = a1;
  if (__SCNRenderThread_start___once != -1) {
    dispatch_once(&__SCNRenderThread_start___once, &__block_literal_global_47);
  }
  uint64_t v2 = pthread_setspecific(__SCNRenderThread_start___block_key, v1);
  unsigned int v3 = (void *)MEMORY[0x210535ED0](v2);
  v1[2](v1);
  pthread_exit(0);
}

uint64_t C3DTransactionIsImmediate(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 60) >> 3) & 1;
}

double C3DTransactionGetDuration()
{
  return *((double *)C3DTransactionGetCurrent() + 4);
}

uint64_t C3DTransactionGetDisableActions()
{
  return (*((unsigned __int8 *)C3DTransactionGetCurrent() + 60) >> 2) & 1;
}

id *C3DEntityGetObjCWrapper(id *result)
{
  if (result) {
    return (id *)objc_loadWeak(result + 2);
  }
  return result;
}

uint64_t C3DEngineContextGetAuthoringEnvironment(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = *(void *)(a1 + 144);
  if (result) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a2 == 0;
  }
  if (!v13)
  {
    uint64_t result = C3DAuthoringEnvironmentCreate(a1);
    *(void *)(a1 + 144) = result;
  }
  return result;
}

const void *SCNCopyValueFromObjCValue(void *a1)
{
  int v2 = SCNObjCEncodedTypeToC3DBaseType((const char *)[a1 objCType]);
  if (!v2) {
    return 0;
  }
  int v3 = v2;
  uint64_t v4 = (const void *)C3DValueCreate(v2, 1);
  uint64_t Bytes = C3DValueGetBytes((uint64_t)v4);
  if ((SCNWriteValueToTypedBytes(a1, Bytes, v3) & 1) == 0)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      SCNCopyValueFromObjCValue_cold_1((uint64_t)a1, v6);
    }
    CFRelease(v4);
    return 0;
  }
  return v4;
}

uint64_t SCNWriteValueToTypedBytes(void *a1, uint64_t a2, int a3)
{
  uint64_t result = 0;
  switch(a3)
  {
    case 1:
    case 7:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          return 0;
        }
      }
      [a1 floatValue];
      *(_DWORD *)a2 = v6;
      return 1;
    case 2:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          return 0;
        }
      }
      *(_DWORD *)a2 = [a1 intValue];
      return 1;
    case 3:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          return 0;
        }
      }
      char v18 = [a1 BOOLValue];
      goto LABEL_35;
    case 4:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        return 0;
      }
      char v18 = [a1 charValue];
      goto LABEL_35;
    case 5:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        return 0;
      }
      uint64_t v11 = [a1 pointerValue];
      goto LABEL_39;
    case 6:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          return 0;
        }
      }
      [a1 doubleValue];
      *(void *)a2 = v12;
      return 1;
    case 8:
    case 18:
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        long long v20 = 0uLL;
        CFStringScanCGFloats((char *)a1, (uint64_t)&v20, 2);
        goto LABEL_31;
      }
      [a1 CGPointValue];
      *(float *)&double v13 = v13;
      *(float *)&double v14 = v14;
      *(_DWORD *)a2 = LODWORD(v13);
      *(_DWORD *)(a2 + 4) = LODWORD(v14);
      return 1;
    case 9:
    case 19:
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        long long v20 = 0uLL;
        CFStringScanFloats((const char *)a1, (int *)&v20, 3);
        *(void *)a2 = v20;
        *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = DWORD2(v20);
      }
      else
      {
        [a1 SCNVector3Value];
        *(_DWORD *)a2 = v15;
        *(_DWORD *)(a2 + 4) = v16;
        *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = v17;
      }
      return 1;
    case 10:
    case 20:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_30;
      }
      [a1 SCNVector4Value];
      DWORD1(v10) = v7;
      *((void *)&v10 + 1) = __PAIR64__(v9, v8);
      goto LABEL_32;
    case 11:
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      if (a1) {
        objc_msgSend(a1, "SCNMatrix4Value", v20, v21, v22, v23);
      }
      C3DMatrix4x4FromSCNMatrix4((_OWORD *)a2, (uint64_t)&v20);
      return 1;
    case 13:
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
LABEL_30:
        long long v20 = 0uLL;
        CFStringScanFloats((const char *)a1, (int *)&v20, 4);
LABEL_31:
        long long v10 = v20;
LABEL_32:
        *(_OWORD *)a2 = v10;
      }
      else
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v11 = objc_msgSend(a1, "scn_C3DColorIgnoringColorSpace:success:", 0, 0);
          *(void *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = v19;
LABEL_39:
          *(void *)a2 = v11;
        }
      }
      return 1;
    case 16:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        return 0;
      }
      char v18 = [a1 unsignedCharValue];
LABEL_35:
      *(unsigned char *)a2 = v18;
      return 1;
    default:
      return result;
  }
}

uint64_t SCNObjCEncodedTypeToC3DBaseType(const char *a1)
{
  if (!strcmp(a1, "f")) {
    return 1;
  }
  if (!strcmp(a1, "i") || !strcmp(a1, "I") || !strcmp(a1, "q") || !strcmp(a1, "Q")) {
    return 2;
  }
  if (!strcmp(a1, "s") || !strcmp(a1, "S")) {
    return 14;
  }
  if (!strcmp(a1, "B")) {
    return 3;
  }
  if (!strcmp(a1, "c") || !strcmp(a1, "C")) {
    return 4;
  }
  if (!strcmp(a1, "d")) {
    return 6;
  }
  if (!strcmp(a1, "{SCNMatrix4=ffffffffffffffff}") || !strcmp(a1, "{CATransform3D=dddddddddddddddd}")) {
    return 11;
  }
  if (!strcmp(a1, "{CGPoint=dd}")) {
    return 8;
  }
  if (!strcmp(a1, "{SCNVector4=ffff}") || !strcmp(a1, "{CGRect={CGPoint=dd}{CGSize=dd}}")) {
    return 10;
  }
  if (!strcmp(a1, "{SCNVector3=fff}")) {
    return 9;
  }
  if (!strcmp(a1, "{_SCNVector4=dddd}")) {
    return 10;
  }
  if (!strcmp(a1, "{_SCNVector3=ddd}")) {
    return 9;
  }
  if (*a1 == 64) {
    return 5;
  }
  else {
    return 0;
  }
}

uint64_t SCNCopyValueFromObjCProperty(void *a1, void *a2)
{
  uint64_t v4 = (objc_class *)objc_opt_class();
  unsigned int v5 = SCNBaseTypeOfObjCProperty(v4, a2);
  if (!v5) {
    return 0;
  }
  int v6 = v5;
  uint64_t v7 = [a1 valueForKey:a2];
  if (v7)
  {
    unsigned int v8 = (void *)v7;
    unsigned int v9 = (const void *)C3DValueCreate(v6, 1);
    uint64_t Bytes = C3DValueGetBytes((uint64_t)v9);
    if (SCNWriteValueToTypedBytes(v8, Bytes, v6)) {
      return (uint64_t)v9;
    }
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      SCNCopyValueFromObjCProperty_cold_1((uint64_t)a2, (uint64_t)a1, v11);
    }
    CFRelease(v9);
    return 0;
  }

  return C3DValueCreateDefault(v6);
}

void sub_20B29E940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void C3DEntitySetValueForKey(uint64_t a1, void *a2, __int16 *a3)
{
  if (!a1 && (int v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  double v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DEntitySetValueForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDictionaryRef KeyValueStore = _C3DEntityGetKeyValueStore(a1, 1);
  C3DKeyValueStoreSetValueForKey((uint64_t)KeyValueStore, a2, a3);
}

CFDictionaryRef _C3DEntityGetKeyValueStore(uint64_t a1, int a2)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v4, @"_kvc");
    if (Value) {
      return Value;
    }
  }
  else
  {
    CFDictionaryRef Value = 0;
  }
  if (a2)
  {
    CFDictionaryRef Value = (const __CFDictionary *)C3DKeyValueStoreCreate();
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"_kvc", Value, 1);
    CFRelease(Value);
  }
  return Value;
}

uint64_t C3DKeyValueStoreSetupModelTargetWithKey(CFDictionaryRef *a1, CFArrayRef theArray, int a3, uint64_t a4)
{
  int Count = CFArrayGetCount(theArray);
  CFIndex v9 = a3;
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  CFDictionaryRef Value = (char *)CFDictionaryGetValue(a1[8], ValueAtIndex);
  uint64_t v12 = Value;
  if (Value)
  {
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 == C3DEffectSlotGetTypeID()
      && C3DModelPathResolveCommonProfileProperty(v12, theArray, a3 + 1, Count, a4, 0))
    {
      C3DModelTargetSetTarget(a4, a1);
      return 1;
    }
  }
  if (a3 + 1 < Count)
  {
    int v14 = Count - a3;
    CFIndex v15 = Count - a3;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, v14, MEMORY[0x263EFFF70]);
    v22.location = v9;
    v22.CFIndex length = v15;
    CFArrayAppendArray(Mutable, theArray, v22);
    uint64_t v17 = (__CFString *)CFStringCreateByCombiningStrings(0, Mutable, @".");
    uint64_t v18 = v17;
    CFRelease(Mutable);
    uint64_t v19 = (char *)CFDictionaryGetValue(a1[8], v17);
    if (v19) {
      uint64_t v12 = v19;
    }
  }
  if (v12)
  {
    CFTypeID v20 = CFGetTypeID(v12);
    if (v20 == C3DValueGetTypeID())
    {
      C3DModelTargetSetTarget(a4, a1);
      *(_WORD *)(a4 + 32) = C3DValueGetType((uint64_t)v12);
      *(unsigned char *)(a4 + 34) = C3DValueGetTypeSemantic((uint64_t)v12);
      *(void *)(a4 + 24) = C3DValueGetBytes((uint64_t)v12);
      return 1;
    }
  }
  return 0;
}

void C3DKeyValueStoreSetValueForKey(uint64_t a1, void *key, __int16 *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), key);
    ++*(_DWORD *)(a1 + 72);
    return;
  }
  ++*(_DWORD *)(a1 + 72);
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), key);
  CFTypeID v7 = CFGetTypeID(a3);
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == C3DValueGetTypeID()) {
      CFIndex v9 = Value;
    }
    else {
      CFIndex v9 = 0;
    }
    if (v7 == C3DValueGetTypeID())
    {
      if (v9)
      {
        if (v9[8] != a3[8])
        {
          uint64_t v10 = scn_default_log();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            uint64_t v11 = C3DBaseTypeStringDescription((__int16)v9[8]);
            uint64_t v12 = C3DBaseTypeStringDescription(a3[8]);
            int v15 = 138412802;
            uint64_t v16 = key;
            __int16 v17 = 2112;
            uint64_t v18 = v11;
            __int16 v19 = 2112;
            CFTypeID v20 = v12;
            _os_log_error_impl(&dword_20B249000, v10, OS_LOG_TYPE_ERROR, "Error: type for key %@ is switching from %@ to %@, this will lead to improper animation", (uint8_t *)&v15, 0x20u);
          }
        }
        goto LABEL_14;
      }
LABEL_13:
      CFDictionaryRef Value = (_WORD *)C3DValueCreate(11, 1);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), key, Value);
      CFRelease(Value);
LABEL_14:
      uint64_t Bytes = (void *)C3DValueGetBytes((uint64_t)Value);
      C3DValueCopyTo((uint64_t)a3, Bytes);
      Value[8] = C3DValueGetType((uint64_t)a3);
      return;
    }
  }
  else if (v7 == C3DValueGetTypeID())
  {
    goto LABEL_13;
  }
  int v14 = *(__CFDictionary **)(a1 + 64);

  CFDictionarySetValue(v14, key, a3);
}

uint64_t C3DValueGetTypeID()
{
  if (C3DValueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DValueGetTypeID_onceToken, &__block_literal_global_93);
  }
  return C3DValueGetTypeID_typeID;
}

uint64_t C3DValueGetType(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(__int16 *)(a1 + 16);
}

size_t C3DValueCopyTo(uint64_t a1, void *a2)
{
  size_t Length = C3DValueGetLength(a1);
  uint64_t Bytes = (const void *)C3DValueGetBytes(a1);
  memcpy(a2, Bytes, Length);
  return Length;
}

uint64_t C3DValueGetBytes(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

uint64_t C3DEffectSlotGetTypeID()
{
  if (C3DEffectSlotGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEffectSlotGetTypeID_onceToken, &__block_literal_global_34);
  }
  return C3DEffectSlotGetTypeID_typeID;
}

uint64_t C3DKeyValueStoreEnumerateBySortingKeys(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void **)(a1 + 64);
  if ((unint64_t)[v3 count] > 1)
  {
    uint64_t v5 = objc_msgSend((id)objc_msgSend(v3, "allKeys"), "sortedArrayUsingSelector:", sel_compare_);
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = [v5 countByEnumeratingWithState:&v9 objects:v14 count:16];
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(void *)v10;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v10 != v7) {
            objc_enumerationMutation(v5);
          }
          (*(void (**)(uint64_t, void, uint64_t))(a2 + 16))(a2, *(void *)(*((void *)&v9 + 1) + 8 * v8), [v3 objectForKeyedSubscript:*(void *)(*((void *)&v9 + 1) + 8 * v8)]);
          ++v8;
        }
        while (v6 != v8);
        uint64_t result = [v5 countByEnumeratingWithState:&v9 objects:v14 count:16];
        uint64_t v6 = result;
      }
      while (result);
    }
  }
  else
  {
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    _OWORD v13[2] = __C3DKeyValueStoreEnumerateBySortingKeys_block_invoke;
    v13[3] = &unk_264004058;
    v13[4] = a2;
    return [v3 enumerateKeysAndObjectsUsingBlock:v13];
  }
  return result;
}

uint64_t C3DValueGetTypeSemantic(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(char *)(a1 + 18);
}

uint64_t C3DKeyValueStoreCreate()
{
  if (C3DKeyValueStoreGetTypeID_onceToken != -1) {
    dispatch_once(&C3DKeyValueStoreGetTypeID_onceToken, &__block_literal_global);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DKeyValueStoreGetTypeID_typeID, 0x40uLL);
  *(void *)(Instance + 64) = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  return Instance;
}

void C3D::RenderGraph::allocateResources(C3D::RenderGraph *this)
{
  *(void *)((char *)&v133[2] + 4) = *MEMORY[0x263EF8340];
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 1));
  uint64_t v99 = -[SCNMTLRenderContext frameTexturePool](RenderContext);
  int v105 = (uint64_t *)this;
  uint64_t v2 = *((void *)this + 12);
  if (!v2) {
    return;
  }
  while (1)
  {
    uint64_t v98 = v2;
    unsigned int v96 = *(_DWORD *)(v2 + 8);
    if (v96) {
      break;
    }
LABEL_141:
    uint64_t v2 = *(void *)(v98 + 24);
    if (!v2) {
      return;
    }
  }
  unsigned int v3 = 0;
  int v97 = 0;
  while (1)
  {
    uint64_t v4 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v98, v3);
    uint64_t v106 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v105[3], *v4);
    int v5 = *(_DWORD *)C3D::Pass::descriptor(*(C3D::Pass **)v106);
    uint64_t v6 = *(void *)(v98 + 24);
    int v101 = v5;
    if (v6 && ((uint64_t v7 = *(void *)(v6 + 24), v5 == 2) ? (v8 = v7 == 0) : (v8 = 0), v8))
    {
      uint64_t v92 = -[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext);
      LOBYTE(v103) = 0;
      if (v96 - 1 == v3)
      {
        BYTE4(v103) = 0;
        BOOL v102 = 0;
        if (v92)
        {
          BYTE4(v103) = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture") != 0;
          LOBYTE(v103) = objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "depthAttachment"), "texture") != 0;
          BOOL v102 = objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "stencilAttachment"), "texture") != 0;
        }
      }
      else
      {
        BYTE4(v103) = 0;
        BOOL v102 = 0;
      }
    }
    else
    {
      uint64_t v103 = 0;
      BOOL v102 = 0;
    }
    uint64_t v9 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
    int v10 = C3D::PassResource::outputCount(v9);
    if (v10 != C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)v106 + 32)))
    {
      long long v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::allocateResources(v132, v133, v11);
      }
    }
    uint64_t StackAllocator = C3DEngineContextGetStackAllocator(v105[1]);
    C3DStackAllocatorPushFrame(StackAllocator);
    C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v112, StackAllocator);
    if (C3D::PassDescriptor::inputCount((C3D::PassDescriptor *)(*(void *)v106 + 32)))
    {
      unsigned int v12 = 0;
      do
      {
        uint64_t v13 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v106, v12);
        if ((*(_WORD *)(v13 + 66) & 0x80) != 0)
        {
          uint64_t v14 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v106, v12);
          if ((*(_WORD *)(v14 + 66) & 8) != 0)
          {
            uint64_t v15 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            if (C3D::PassResource::outputAtIndex(v15, (unsigned __int16)v12))
            {
              uint64_t v16 = scn_default_log();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
              {
                uint64_t v24 = (***(uint64_t (****)(void))v106)();
                uint64_t v25 = *(void *)(v14 + 8);
                *(_DWORD *)float32x4_t buf = 136315906;
                *(void *)&uint8_t buf[4] = "resOutput == nullptr";
                __int16 v126 = 2080;
                uint64_t v127 = v24;
                __int16 v128 = 1024;
                unsigned int v129 = v12;
                __int16 v130 = 2080;
                uint64_t v131 = v25;
                _os_log_fault_impl(&dword_20B249000, v16, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Readwrite pass %s has an initialised output at index %d:%s should be null", buf, 0x26u);
              }
            }
            int v111 = 0;
            __int16 v17 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            int v111 = (C3D::RefCountedResource *)C3D::PassResource::inputAtIndex(v17, (unsigned __int16)v12);
            if (!v111)
            {
              uint64_t v18 = scn_default_log();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
              {
                uint64_t v26 = (***(uint64_t (****)(void))v106)();
                uint64_t v27 = *(void *)(v13 + 8);
                *(_DWORD *)float32x4_t buf = 136315906;
                *(void *)&uint8_t buf[4] = "resInput";
                __int16 v126 = 2080;
                uint64_t v127 = v26;
                __int16 v128 = 1024;
                unsigned int v129 = v12;
                __int16 v130 = 2080;
                uint64_t v131 = v27;
                _os_log_fault_impl(&dword_20B249000, v18, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Readwrite pass %s has an uninitialised input at index %d:%s should be null", buf, 0x26u);
              }
            }
            __int16 v19 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            C3D::PassResource::setOutputAtIndex(v19, v111, (unsigned __int16)v12);
            ++*((unsigned char *)v111 + 33);
            CFTypeID v20 = (_OWORD *)C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)v106 + 32), (unsigned __int16)v12);
            *(_OWORD *)uint64_t v14 = *v20;
            long long v21 = v20[1];
            long long v22 = v20[2];
            long long v23 = v20[4];
            *(_OWORD *)(v14 + 4_Block_object_dispose(&STACK[0x380], 8) = v20[3];
            *(_OWORD *)(v14 + 64) = v23;
            *(_OWORD *)(v14 + 16) = v21;
            *(_OWORD *)(v14 + 32) = v22;
            C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v112, &v111);
          }
        }
        ++v12;
      }
      while (v12 < C3D::PassDescriptor::inputCount((C3D::PassDescriptor *)(*(void *)v106 + 32)));
    }
    uint64_t v28 = *(unsigned int *)(v106 + 40);
    if (v28)
    {
      uint64_t v29 = *(unsigned int **)(v106 + 48);
      uint64_t v30 = 4 * v28;
      do
      {
        uint64_t v104 = v30;
        unsigned int v31 = *v29;
        unsigned int v32 = BYTE2(*v29);
        uint64_t v33 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)v106 + 32), v32);
        unint64_t v34 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v105[3], v31 & 0x7FFF);
        int v35 = (unsigned __int8 *)C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v34 + 32), HIBYTE(v31));
        uint64_t v36 = (uint64_t)v35;
        int v37 = v35[64];
        char v38 = BYTE4(v103);
        if (v37 != 1) {
          char v38 = 0;
        }
        if (v35[65]) {
          char v39 = 0;
        }
        else {
          char v39 = v38;
        }
        char v40 = v103;
        if (v37 != 2) {
          char v40 = 0;
        }
        BOOL v8 = v37 == 3;
        BOOL v41 = v102;
        if (!v8) {
          BOOL v41 = 0;
        }
        if ((v39 & 1) == 0 && (v40 & 1) == 0 && !v41)
        {
          unsigned int v42 = *(unsigned __int8 *)(v33 + 31);
          if (v42 <= 1) {
            unsigned int v42 = 1;
          }
          unsigned int v43 = v35[31];
          if (v43 <= 1) {
            unsigned int v43 = 1;
          }
          BOOL v45 = *(unsigned char *)v33 == 1 && v42 != v43;
          unsigned int v46 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
          uint64_t v47 = C3D::PassResource::outputAtIndex(v46, BYTE2(v31));
          if (v47)
          {
            float32x4_t v48 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            uint64_t v49 = C3D::PassResource::inputAtIndex(v48, HIBYTE(v31));
            if (v49)
            {
              if (v49 != v47)
              {
                float32x4_t v50 = scn_default_log();
                if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
                  C3D::RenderGraph::allocateResources(v123, &v124, v50);
                }
              }
            }
            else
            {
              uint64_t v55 = (C3D::PassResource *)C3D::Pass::resource(*v34);
              C3D::PassResource::setInputAtIndex(v55, (C3D::RefCountedResource *)v47, HIBYTE(v31));
            }
            if ((*(_WORD *)(v33 + 66) & 0x100) == 0) {
              ++*(unsigned char *)(v47 + 33);
            }
            if (v45 && !*(void *)(v47 + 24))
            {
              *(_DWORD *)(v36 + 32) = 1;
              long long v109 = *(_OWORD *)(v36 + 16);
              int v110 = *(_DWORD *)(v36 + 32);
              *(void *)(v47 + 24) = SCNMTLTexturePool::allocate(v99, &v109, 0, 0);
            }
            LOBYTE(v107) = 0;
            *(void *)float32x4_t buf = 0;
            C3D::RenderGraph::lastNodeUsingResourceAtIndex((uint64_t)v105, (unsigned char *)v33, v31 & 0x7FFF, HIBYTE(v31), (C3D::Pass ***)buf, (uint64_t *)&v111, (BOOL *)&v107, &v108[1]);
            if (*(void *)buf && *(C3D::Pass ***)buf != v34) {
              C3D::RenderGraph::propagateReadWriteResources((uint64_t)v105, *(C3D::Pass ***)buf, v31 & 0x7FFF, HIBYTE(v31), (C3D::RefCountedResource *)v47);
            }
          }
          else if ((*(_WORD *)(v33 + 66) & 0x80) != 0)
          {
            uint64_t v56 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            uint64_t v57 = (C3D::RefCountedResource *)C3D::PassResource::inputAtIndex(v56, BYTE2(v31));
            if (!v57)
            {
              unsigned __int8 v58 = scn_default_log();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::allocateResources(v121, &v122, v58);
              }
            }
            unsigned int v59 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            C3D::PassResource::setOutputAtIndex(v59, v57, BYTE2(v31));
            uint64_t v60 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            C3D::PassResource::setInputAtIndex(v60, v57, HIBYTE(v31));
          }
          else
          {
            *(_WORD *)uint64_t v108 = 0;
            int v111 = 0;
            unsigned __int8 v107 = 0;
            C3D::RenderGraph::lastNodeUsingResourceAtIndex((uint64_t)v105, (unsigned char *)v33, v31 & 0x7FFF, HIBYTE(v31), (C3D::Pass ***)&v111, (uint64_t *)&v107, &v108[1], v108);
            if (v101 == 2)
            {
              CFAllocatorRef v51 = *(C3D::Pass **)v106;
              RenderMode = (unsigned char *)C3D::RenderPass::getRenderMode(*(C3D::RenderPass **)v106);
              unsigned __int8 v53 = v107;
              if (*RenderMode == 1 && SCNMTLTextureTypeIsArray(*((unsigned __int8 *)v107 + 24))) {
                __int16 v54 = *(_WORD *)(C3D::Pass::descriptor(v51) + 6);
              }
              else {
                __int16 v54 = 0;
              }
              *((_WORD *)v53 + 11) = v54;
            }
            BOOL v61 = v108[0];
            C3D::RenderGraph::computeResourceUsageForOutputDescriptor((uint64_t)v105, (const C3D::Pass **)v106, (C3D::PassIODescriptor *)v33, v36, v108[0]);
            buf[0] = BYTE2(v31);
            if (*(unsigned __int16 *)(C3D::Pass::descriptor(*(C3D::Pass **)v106) + 6) > 1u) {
              int v62 = 0;
            }
            else {
              int v62 = C3D::__deduceMemoryLess((uint64_t)v105, v106, StackAllocator, buf, 1);
            }
            Resource = (C3D::RefCountedResource *)C3D::RenderGraph::createResource((C3D::RenderGraph *)v105, (C3D::PassIODescriptor *)v33, v107, v108[1], v61, v62);
            uint64_t v64 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
            C3D::PassResource::setOutputAtIndex(v64, Resource, BYTE2(v31));
            int8x16_t v65 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            C3D::PassResource::setInputAtIndex(v65, Resource, HIBYTE(v31));
            if (v111 && v111 != (C3D::RefCountedResource *)v34) {
              C3D::RenderGraph::propagateReadWriteResources((uint64_t)v105, (C3D::Pass **)v111, v31 & 0x7FFF, HIBYTE(v31), Resource);
            }
            if ((*(_WORD *)(v33 + 66) & 8) != 0)
            {
              size_t v66 = scn_default_log();
              if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
              {
                uint64_t v67 = (***(uint64_t (****)(void))v106)();
                uint64_t v68 = *(void *)(v33 + 8);
                *(_DWORD *)float32x4_t buf = 136315906;
                *(void *)&uint8_t buf[4] = "!outputResDesc.usedInternally";
                __int16 v126 = 2080;
                uint64_t v127 = v67;
                __int16 v128 = 1024;
                unsigned int v129 = v32;
                __int16 v130 = 2080;
                uint64_t v131 = v68;
                _os_log_fault_impl(&dword_20B249000, v66, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s resource at index %d:%s should not be tagged as \"usedInternally\"", buf, 0x26u);
              }
            }
          }
        }
        ++v29;
        uint64_t v30 = v104 - 4;
      }
      while (v104 != 4);
    }
    if (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)v106 + 32))) {
      break;
    }
LABEL_112:
    (*(void (**)(void))(**(void **)v106 + 16))();
    if (v113)
    {
      uint64_t v82 = v114;
      uint64_t v83 = 8 * v113;
      do
      {
        uint64_t v84 = *v82;
        char v85 = *(unsigned char *)(*v82 + 33) - 1;
        *(unsigned char *)(*v82 + 33) = v85;
        if (v85 < 0)
        {
          int v86 = scn_default_log();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
            C3D::RenderGraph::allocateResources(v119, &v120, v86);
          }
          char v85 = *(unsigned char *)(v84 + 33);
        }
        if (!v85 && (*(unsigned char *)(v84 + 34) & 1) == 0)
        {
          int v87 = *(unsigned __int8 *)(v84 + 32);
          if (v87 == 2)
          {
            if (!*(void *)(v84 + 8))
            {
              size_t v91 = scn_default_log();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::allocateResources(v115, &v116, v91);
              }
            }
            *(void *)uint64_t v84 = 0;
            *(void *)(v84 + _Block_object_dispose(&STACK[0x380], 8) = 0;
            *(void *)(v84 + 16) = 0;
          }
          else if (v87 == 1)
          {
            if (!*(void *)v84)
            {
              BOOL v88 = scn_default_log();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::allocateResources(v117, &v118, v88);
              }
            }
            char v89 = *(unsigned char *)(v84 + 34);
            if ((v89 & 2) == 0)
            {
              SCNMTLTexturePool::free(v99, *(void *)v84);
              char v89 = *(unsigned char *)(v84 + 34);
            }
            if ((v89 & 4) == 0)
            {
              uint64_t v90 = *(void *)(v84 + 24);
              if (v90) {
                SCNMTLTexturePool::free(v99, v90);
              }
            }
          }
        }
        ++v82;
        v83 -= 8;
      }
      while (v83);
    }
    C3DStackAllocatorPopFrame(StackAllocator);
    C3D::RenderGraph::freeConsumedResources((uint64_t)v105, v106, v99);
    unsigned int v3 = (unsigned __int16)++v97;
    if (v96 <= (unsigned __int16)v97) {
      goto LABEL_141;
    }
  }
  int v69 = 0;
  while (1)
  {
    uint64_t v70 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)v106 + 32), (unsigned __int16)v69);
    uint64_t v71 = v70;
    int v72 = *(unsigned __int8 *)(v70 + 64);
    char v73 = BYTE4(v103);
    if (v72 != 1) {
      char v73 = 0;
    }
    if (*(unsigned char *)(v70 + 65)) {
      char v74 = 0;
    }
    else {
      char v74 = v73;
    }
    char v75 = v103;
    if (v72 != 2) {
      char v75 = 0;
    }
    BOOL v8 = v72 == 3;
    BOOL v76 = v102;
    if (!v8) {
      BOOL v76 = 0;
    }
    if ((v74 & 1) != 0 || (v75 & 1) != 0 || v76) {
      goto LABEL_111;
    }
    if (v101 == 2)
    {
      uint64_t v77 = *(C3D::Pass **)v106;
      if (*(unsigned char *)C3D::RenderPass::getRenderMode(*(C3D::RenderPass **)v106) == 1
        && SCNMTLTextureTypeIsArray(*(unsigned __int8 *)(v71 + 24)))
      {
        __int16 v78 = *(_WORD *)(C3D::Pass::descriptor(v77) + 6);
      }
      else
      {
        __int16 v78 = 0;
      }
      *(_WORD *)(v71 + 22) = v78;
    }
    if ((*(_WORD *)(v71 + 66) & 0x108) != 8) {
      goto LABEL_111;
    }
    CFAllocatorRef v79 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
    if (C3D::PassResource::outputAtIndex(v79, (unsigned __int16)v69))
    {
      if ((*(_WORD *)(v71 + 66) & 0x80) == 0) {
        break;
      }
    }
    *(void *)float32x4_t buf = 0;
    C3D::RenderGraph::computeResourceUsageForOutputDescriptor((uint64_t)v105, (const C3D::Pass **)v106, (C3D::PassIODescriptor *)v71, 0, 0);
    LOBYTE(v111) = v69;
    if (*(unsigned __int16 *)(C3D::Pass::descriptor(*(C3D::Pass **)v106) + 6) > 1u) {
      int v80 = 0;
    }
    else {
      int v80 = C3D::__deduceMemoryLess((uint64_t)v105, v106, StackAllocator, (char *)&v111, 1);
    }
    *(void *)float32x4_t buf = C3D::RenderGraph::createResource((C3D::RenderGraph *)v105, (C3D::PassIODescriptor *)v71, 0, 0, 0, v80);
    uint64_t v81 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v106);
    C3D::PassResource::setOutputAtIndex(v81, *(C3D::RefCountedResource **)buf, (unsigned __int16)v69);
    C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v112, buf);
LABEL_111:
    if (++v69 >= C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)v106 + 32))) {
      goto LABEL_112;
    }
  }
  uint64_t v93 = scn_default_log();
  if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
    C3D::RenderGraph::allocateResources(v71, v69, v93);
  }
  uint64_t v94 = scn_default_log();
  if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)) {
    C3D::RenderGraph::allocateResources();
  }
}

uint64_t C3D::Pass::resource(C3D::Pass *this)
{
  return (uint64_t)this + 80;
}

uint64_t C3D::PassResource::outputAtIndex(C3D::PassResource *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 9) <= a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::PassResource::outputAtIndex();
    }
  }
  return *(void *)(*((void *)this + 1) + 8 * a2);
}

uint64_t C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 8);
      int v7 = 136315906;
      BOOL v8 = "i < size()";
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v6;
      _os_log_fault_impl(&dword_20B249000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(void *)(a1 + 16) + 2 * a2;
}

uint64_t C3D::RenderPass::getRenderMode(C3D::RenderPass *this)
{
  return (uint64_t)this + 117;
}

void C3DStackAllocatorPushFrame(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 576);
  if (v1 == 31)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      C3DStackAllocatorPushFrame_cold_1(v2);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 576) = v1 + 1;
    uint64_t v3 = *(void *)(a1 + 16);
    int v4 = *(_DWORD *)(v3 + 12);
    uint64_t v5 = a1 + 16 * v1;
    *(void *)(v5 + 64) = v3;
    *(_DWORD *)(v5 + 72) = v4;
  }
}

uint64_t C3DStackAllocatorPopFrame(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 576))
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DStackAllocatorPopFrame_cold_1(v2);
    }
  }
  unsigned int v3 = *(_DWORD *)(a1 + 576) - 1;
  *(_DWORD *)(a1 + 576) = v3;
  uint64_t v4 = a1 + 16 * v3;
  uint64_t v7 = *(void *)(v4 + 64);
  uint64_t v5 = v4 + 64;
  uint64_t v6 = v7;
  int v8 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v7 + 12) = v8;
  uint64_t v9 = a1 + 24;
  if (v8) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v6 == v9;
  }
  if (v10) {
    __int16 v11 = (vm_address_t *)v6;
  }
  else {
    __int16 v11 = *(vm_address_t **)(v6 + 16);
  }
  uint64_t result = __destroyChuncks(a1, (uint64_t)v11);
  if (v6 == v9 && *(unsigned int *)(a1 + 56) > v11[1])
  {
    MEMORY[0x2105366D0](*MEMORY[0x263EF8960], *v11);
    uint64_t result = __allocateChunk(v11, *(unsigned int *)(a1 + 56));
  }
  *(void *)uint64_t v5 = 0;
  *(_DWORD *)(v5 + _Block_object_dispose(&STACK[0x380], 8) = 0;
  return result;
}

uint64_t __destroyChuncks(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 16);
  if (v4 != a2)
  {
    uint64_t v5 = result + 24;
    uint64_t v6 = (unsigned int *)MEMORY[0x263EF8960];
    do
    {
      uint64_t v7 = *(void *)(v4 + 16);
      uint64_t result = MEMORY[0x2105366D0](*v6, *(void *)v4, *(unsigned int *)(v4 + 8));
      if (v4 != v5) {
        uint64_t result = MEMORY[0x210534FE0](v4, 0x1030C40D5FA72FALL);
      }
      uint64_t v4 = v7;
    }
    while (v7 != a2);
  }
  *(void *)(v3 + 16) = a2;
  return result;
}

uint64_t C3D::PassResource::outputCount(C3D::PassResource *this)
{
  return *((unsigned __int16 *)this + 9);
}

uint64_t C3D::__deduceMemoryLess(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v38 = a3;
  uint64_t v39 = 0;
  char v40 = (char *)&v41;
  if (!a3)
  {
    BOOL v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  uint64_t Aligned = (char *)C3DStackAllocatorAllocateAligned(v38, (16 * (HIDWORD(v39) + a5)), 8, 0);
  memcpy(Aligned, v40, 16 * v39);
  char v40 = Aligned;
  HIDWORD(v39) += a5;
  int v19 = v39;
  if (a5 >= 1)
  {
    uint64_t v20 = a5;
    do
    {
      char v22 = *a4++;
      char v21 = v22;
      long long v23 = v40;
      if ((v19 + 1) > HIDWORD(v39))
      {
        uint64_t v24 = (char *)C3DStackAllocatorAllocateAligned(v38, 16 * ((double)(HIDWORD(v39) + 1) * 1.5), 8, 0);
        memcpy(v24, v40, 16 * v39);
        char v40 = v24;
        HIDWORD(v39) = ((double)(HIDWORD(v39) + 1) * 1.5);
        long long v23 = v24;
        int v19 = v39;
      }
      uint64_t v25 = &v23[16 * v19];
      *(void *)uint64_t v25 = a2;
      v25[8] = v21;
      int v19 = v39 + 1;
      LODWORD(v39) = v39 + 1;
      --v20;
    }
    while (v20);
  }
  if (!v19) {
    return 1;
  }
  while (1)
  {
    uint64_t v26 = &v40[16 * v19];
    uint64_t v27 = *((void *)v26 - 2);
    int v28 = *(v26 - 8);
    LODWORD(v39) = v39 - 1;
    unsigned int v29 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)v27 + 32), v28)
                             + 31);
    C3D::RenderGraph::GraphNode::successorsAtIndex(v27, v28, a3, &v35);
    if (v36) {
      break;
    }
LABEL_15:
    int v19 = v39;
    if (!v39) {
      return 1;
    }
  }
  uint64_t v30 = v37;
  uint64_t v31 = 4 * v36;
  while (1)
  {
    uint64_t v32 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *(_DWORD *)v30 & 0x7FFF);
    uint64_t v33 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)v32 + 32), *(unsigned __int8 *)(v30 + 3));
    if (v29 < 2 || *(unsigned __int8 *)(v33 + 31) >= 2u) {
      return 0;
    }
    v30 += 4;
    v31 -= 4;
    if (!v31) {
      goto LABEL_15;
    }
  }
}

void C3D::PassResource::setOutputAtIndex(C3D::PassResource *this, C3D::RefCountedResource *a2, unsigned int a3)
{
  if (*((unsigned __int16 *)this + 9) <= a3)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3D::PassResource::outputAtIndex();
    }
  }
  *(void *)(*((void *)this + 1) + 8 * a3) = a2;
}

uint64_t C3D::RenderGraph::computeResourceUsageForOutputDescriptor(uint64_t this, const C3D::Pass **a2, C3D::PassIODescriptor *a3, uint64_t a4, int a5)
{
  if (a5)
  {
    LOBYTE(v7) = 0;
    *((unsigned char *)a3 + 26) = 0;
    goto LABEL_10;
  }
  int v8 = a2;
  uint64_t v9 = (uint64_t *)this;
  BOOL v10 = *a2;
  if ((*((_WORD *)a3 + 33) & 8) != 0)
  {
    this = C3D::RenderGraph::outputTextureUsageForPass((C3D::RenderGraph *)this, v10, a3);
    *((unsigned char *)a3 + 26) = this;
    LOBYTE(v7) = this;
    if (!a4) {
      return this;
    }
    goto LABEL_10;
  }
  uint64_t v11 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
  if (C3D::PassDescriptor::outputCount(v11))
  {
    unsigned __int16 v12 = 0;
    LOBYTE(v13) = 0;
    do
    {
      uint64_t v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
      if ((C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v14, v12) == a3) {
        break;
      }
      LOBYTE(v13) = v13 + 1;
      uint64_t v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
      unsigned __int16 v12 = v13;
    }
    while (C3D::PassDescriptor::outputCount(v15) > v13);
  }
  else
  {
    LOBYTE(v13) = 0;
  }
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(v9[1]);
  uint64_t v7 = 0;
LABEL_14:
  uint64_t v17 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
  uint64_t v18 = (const C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v17, v13);
  uint64_t v19 = C3D::RenderGraph::outputTextureUsageForPass((C3D::RenderGraph *)v9, *v8, v18);
  this = (uint64_t)C3D::RenderGraph::GraphNode::successorsAtIndex((uint64_t)v8, v13, StackAllocator, &v26);
  v7 |= v19;
  if (v27)
  {
    uint64_t v20 = v28;
    char v21 = &v28[v27];
    do
    {
      while (1)
      {
        unsigned int v13 = HIBYTE(*v20);
        int v8 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v9[3], *v20 & 0x7FFF);
        char v22 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
        this = C3D::PassDescriptor::inputAtIndex(v22, v13);
        if ((*(_WORD *)(this + 66) & 0x80) == 0) {
          break;
        }
        if (++v20 == v21) {
          goto LABEL_14;
        }
      }
      if (v9[21])
      {
        uint64_t v23 = 7;
      }
      else
      {
        uint64_t v24 = *v8;
        uint64_t v25 = *(unsigned __int8 *)(this + 26);
        this = C3D::Pass::descriptor(v24);
        uint64_t v23 = v25 | ((*(_DWORD *)this - 1) < 4);
      }
      v7 |= v23;
      ++v20;
    }
    while (v20 != v21);
  }
  *((unsigned char *)a3 + 26) = v7;
  if (a4) {
LABEL_10:
  }
    *(unsigned char *)(a4 + 26) = v7;
  return this;
}

void C3D::RenderGraph::freeConsumedResources(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&v28[5] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  if (v3)
  {
    uint64_t v6 = *(unsigned int **)(a2 + 24);
    uint64_t v7 = 4 * v3;
    do
    {
      unsigned int v8 = *v6;
      uint64_t v9 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *v6 & 0x7FFF);
      unsigned int v10 = HIBYTE(v8);
      uint64_t v11 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)*v9 + 32), v10);
      if ((*(_WORD *)(v11 + 66) & 0x100) == 0)
      {
        unsigned __int16 v12 = (unsigned __int8 *)v11;
        unsigned int v13 = (C3D::PassResource *)C3D::Pass::resource(*v9);
        uint64_t v14 = C3D::PassResource::outputAtIndex(v13, v10);
        if (v14)
        {
          uint64_t v15 = v14;
          if ((*(unsigned char *)(v14 + 34) & 1) == 0)
          {
            char v16 = *(unsigned char *)(v14 + 33) - 1;
            *(unsigned char *)(v14 + 33) = v16;
            if (v16 < 0)
            {
              uint64_t v17 = scn_default_log();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::allocateResources(v27, v28, v17);
              }
              char v16 = *(unsigned char *)(v15 + 33);
            }
            if (!v16)
            {
              int v18 = *v12;
              if (v18 == 2)
              {
                if (!*(void *)(v15 + 8))
                {
                  char v22 = scn_default_log();
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
                    C3D::RenderGraph::allocateResources(v23, &v24, v22);
                  }
                }
                *(void *)uint64_t v15 = 0;
                *(void *)(v15 + _Block_object_dispose(&STACK[0x380], 8) = 0;
                *(void *)(v15 + 16) = 0;
              }
              else if (v18 == 1)
              {
                char v19 = *(unsigned char *)(v15 + 34);
                if ((v19 & 1) == 0)
                {
                  if ((*(unsigned char *)(v15 + 34) & 2) == 0)
                  {
                    if (!*(void *)v15)
                    {
                      uint64_t v20 = scn_default_log();
                      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
                        C3D::RenderGraph::allocateResources(v25, &v26, v20);
                      }
                    }
                    SCNMTLTexturePool::free(a3, *(void *)v15);
                    char v19 = *(unsigned char *)(v15 + 34);
                  }
                  if ((v19 & 4) == 0)
                  {
                    uint64_t v21 = *(void *)(v15 + 24);
                    if (v21) {
                      SCNMTLTexturePool::free(a3, v21);
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v6;
      v7 -= 4;
    }
    while (v7);
  }
}

uint64_t C3D::RenderGraph::createResource(C3D::RenderGraph *this, C3D::PassIODescriptor *a2, C3D::PassIODescriptor *a3, char a4, int a5, int a6)
{
  uint64_t RenderContext = (SCNMTLRenderContext *)C3DEngineContextGetRenderContext(*((void *)this + 1));
  unsigned int v13 = (SCNMTLBufferPool *)-[SCNMTLRenderContext frameConstantBufferPool]((uint64_t)RenderContext);
  uint64_t v14 = -[SCNMTLRenderContext frameTexturePool]((uint64_t)RenderContext);
  C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::emplace_back(*((void *)this + 18));
  uint64_t v15 = C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(*((void *)this + 18));
  int v16 = *(unsigned __int8 *)a2;
  *(unsigned char *)(v15 + 32) = v16;
  if (a6)
  {
    uint64_t v17 = (void *)-[SCNMTLRenderContext device]((uint64_t)RenderContext);
    if (SCNMTLDeviceSupportsMemorylessStorage(v17)) {
      *((unsigned char *)a2 + 25) = 3;
    }
    int v16 = *(unsigned __int8 *)a2;
  }
  if (v16 == 2)
  {
    SCNMTLBufferPool::allocate(v13, *((void *)a2 + 2), &v117);
    *(_OWORD *)uint64_t v15 = v117;
    *(void *)(v15 + 16) = v118;
    if (!*(void *)(v15 + 8))
    {
      int v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v18, v19, v20, v21, v22, v23, v24, v25);
      }
    }
    goto LABEL_28;
  }
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    *((_DWORD *)a2 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    int v116 = 0;
    long long v115 = *((_OWORD *)a2 + 1);
    uint64_t v26 = SCNMTLTexturePool::allocate(v14, &v115, 0, 0);
    *(void *)uint64_t v15 = v26;
    if (!v26)
    {
      int v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v27, v28, v29, v30, v31, v32, v33, v34);
      }
    }
    goto LABEL_28;
  }
  if ((a4 & 1) == 0)
  {
    if (*((unsigned char *)a2 + 64) != 1)
    {
      BOOL v45 = scn_default_log();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v45, v46, v47, v48, v49, v50, v51, v52);
      }
    }
    *(void *)uint64_t v15 = 0;
    char v44 = *(unsigned char *)(v15 + 34) | 2;
    goto LABEL_27;
  }
  if (a5)
  {
    if (!*((void *)this + 21)) {
      *((unsigned char *)a2 + 26) = 4;
    }
    *((_DWORD *)a2 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    int v114 = 0;
    long long v113 = *((_OWORD *)a2 + 1);
    uint64_t v35 = SCNMTLTexturePool::allocate(v14, &v113, 0, 0);
    *(void *)uint64_t v15 = v35;
    if (!v35)
    {
      unsigned int v36 = scn_default_log();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v36, v37, v38, v39, v40, v41, v42, v43);
      }
    }
    if (*((unsigned char *)a2 + 64) == 1)
    {
      *(void *)(v15 + 24) = 0;
      char v44 = *(unsigned char *)(v15 + 34) | 4;
LABEL_27:
      *(unsigned char *)(v15 + 34) = v44;
      goto LABEL_28;
    }
    if (*((unsigned __int8 *)a3 + 31) >= 2u)
    {
      size_t v91 = scn_default_log();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v91, v92, v93, v94, v95, v96, v97, v98);
      }
    }
    if (SCNMTLTextureTypeIsMultisampled(*((unsigned __int8 *)a3 + 24)))
    {
      uint64_t v99 = scn_default_log();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v99, v100, v101, v102, v103, v104, v105, v106);
      }
    }
    *((_DWORD *)a3 + _Block_object_dispose(&STACK[0x380], 8) = 1;
    long long v111 = *((_OWORD *)a3 + 1);
    int v112 = *((_DWORD *)a3 + 8);
    *(void *)(v15 + 24) = SCNMTLTexturePool::allocate(v14, &v111, 0, 0);
  }
  else
  {
    *((_DWORD *)a2 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    int v110 = 0;
    long long v109 = *((_OWORD *)a2 + 1);
    uint64_t v73 = SCNMTLTexturePool::allocate(v14, &v109, 0, 0);
    *(void *)uint64_t v15 = v73;
    if (!v73)
    {
      char v74 = scn_default_log();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v74, v75, v76, v77, v78, v79, v80, v81);
      }
    }
    *((_DWORD *)a3 + _Block_object_dispose(&STACK[0x380], 8) = 1;
    int v108 = 1;
    long long v107 = *((_OWORD *)a3 + 1);
    uint64_t v82 = SCNMTLTexturePool::allocate(v14, &v107, 0, 0);
    *(void *)(v15 + 24) = v82;
    if (!v82)
    {
      uint64_t v83 = scn_default_log();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
        C3D::RenderGraph::createResource(v83, v84, v85, v86, v87, v88, v89, v90);
      }
    }
  }
LABEL_28:
  __int16 v53 = *((_WORD *)a2 + 33);
  if ((v53 & 0x10) != 0)
  {
    uint64_t v54 = *((void *)this + 17);
    uint64_t v55 = (const char *)*((void *)a2 + 1);
    unsigned int v56 = strlen(v55);
    unint64_t v57 = 0xC6A4A7935BD1E995 * v56;
    if (v56 >= 8)
    {
      uint64_t v58 = v56 >> 3;
      unsigned int v59 = (unsigned __int8 *)&v55[8 * v58];
      uint64_t v60 = 8 * v58;
      do
      {
        uint64_t v61 = *(void *)v55;
        v55 += 8;
        unint64_t v57 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v61) ^ ((0xC6A4A7935BD1E995 * v61) >> 47))) ^ v57);
        v60 -= 8;
      }
      while (v60);
      uint64_t v55 = (const char *)v59;
    }
    switch(v56 & 7)
    {
      case 1u:
        goto LABEL_40;
      case 2u:
        goto LABEL_39;
      case 3u:
        goto LABEL_38;
      case 4u:
        goto LABEL_37;
      case 5u:
        goto LABEL_36;
      case 6u:
        goto LABEL_35;
      case 7u:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 6) << 48;
LABEL_35:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 5) << 40;
LABEL_36:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 4) << 32;
LABEL_37:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 3) << 24;
LABEL_38:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 2) << 16;
LABEL_39:
        v57 ^= (unint64_t)*((unsigned __int8 *)v55 + 1) << 8;
LABEL_40:
        unint64_t v57 = 0xC6A4A7935BD1E995 * (v57 ^ *(unsigned __int8 *)v55);
        break;
      default:
        break;
    }
    unint64_t v62 = (0xC6A4A7935BD1E995 * (v57 ^ (v57 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v57 ^ (v57 >> 47))) >> 47);
    *(void *)&long long v117 = C3D::RefCountedResource::textureOrFinal((C3D::RefCountedResource *)v15, RenderContext);
    C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(v54, v62, &v117);
    __int16 v53 = *((_WORD *)a2 + 33);
  }
  if ((v53 & 0x20) != 0)
  {
    uint64_t v63 = *((void *)this + 17);
    uint64_t v64 = (const char *)*((void *)a2 + 1);
    unsigned int v65 = strlen(v64);
    unint64_t v66 = 0xC6A4A7935BD1E995 * v65;
    if (v65 >= 8)
    {
      uint64_t v67 = v65 >> 3;
      uint64_t v68 = (unsigned __int8 *)&v64[8 * v67];
      uint64_t v69 = 8 * v67;
      do
      {
        uint64_t v70 = *(void *)v64;
        v64 += 8;
        unint64_t v66 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v70) ^ ((0xC6A4A7935BD1E995 * v70) >> 47))) ^ v66);
        v69 -= 8;
      }
      while (v69);
      uint64_t v64 = (const char *)v68;
    }
    switch(v65 & 7)
    {
      case 1u:
        goto LABEL_54;
      case 2u:
        goto LABEL_53;
      case 3u:
        goto LABEL_52;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_50;
      case 6u:
        goto LABEL_49;
      case 7u:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 6) << 48;
LABEL_49:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 5) << 40;
LABEL_50:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 4) << 32;
LABEL_51:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 3) << 24;
LABEL_52:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 2) << 16;
LABEL_53:
        v66 ^= (unint64_t)*((unsigned __int8 *)v64 + 1) << 8;
LABEL_54:
        unint64_t v66 = 0xC6A4A7935BD1E995 * (v66 ^ *(unsigned __int8 *)v64);
        break;
      default:
        break;
    }
    unint64_t v71 = (0xC6A4A7935BD1E995 * (v66 ^ (v66 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v66 ^ (v66 >> 47))) >> 47);
    *(void *)&long long v117 = C3D::RefCountedResource::resolveTextureOrFinal((C3D::RefCountedResource *)v15, RenderContext);
    C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(v63, v71, &v117);
  }
  return v15;
}

uint64_t C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16) + 40 * *(unsigned int *)(a1 + 8) - 40;
}

uint64_t C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::emplace_back(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 12);
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v2 + 1 > v3)
  {
    unsigned int v5 = ((double)(v3 + 1) * 1.5);
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)a1, 40 * v5, 8, 0);
    memcpy(Aligned, v4, 40 * *(unsigned int *)(a1 + 8));
    *(void *)(a1 + 16) = Aligned;
    *(_DWORD *)(a1 + 12) = v5;
    uint64_t v4 = Aligned;
    unsigned int v2 = *(_DWORD *)(a1 + 8);
  }
  uint64_t result = C3D::RefCountedResource::RefCountedResource((uint64_t)v4 + 40 * v2);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t C3D::RefCountedResource::RefCountedResource(uint64_t this)
{
  *(unsigned char *)(this + 34) &= 0xF8u;
  *(_WORD *)(this + 32) = 256;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)this = 0;
  *(void *)(this + _Block_object_dispose(&STACK[0x380], 8) = 0;
  return this;
}

uint64_t SCNMTLTexturePool::allocate(uint64_t a1, long long *a2, void *a3, int a4)
{
  uint64_t v4 = a3;
  unint64_t v7 = *(unsigned int *)(a1 + 40);
  if (v7)
  {
    uint64_t v8 = *(long long **)(a1 + 16);
    uint64_t v9 = &v8[2 * v7];
    uint64_t v10 = 32 * v7;
    while (1)
    {
      BOOL v11 = *(void *)a2 == *((void *)v8 + 1) && *((void *)a2 + 1) == *((void *)v8 + 2);
      BOOL v12 = v11 && *((_DWORD *)a2 + 4) == (unint64_t)*((unsigned int *)v8 + 6);
      if (v12 && (!a4 || *((_DWORD *)v8 + 7) >= 3u)) {
        break;
      }
      v8 += 2;
      v10 -= 32;
      if (!v10) {
        goto LABEL_14;
      }
    }
    uint64_t v13 = *(void *)v8;
    *((_DWORD *)v8 + 7) = 0;
    if (v10 != 32)
    {
      unint64_t v7 = (unint64_t)(v9 - 2);
      long long v25 = *v8;
      long long v24 = v8[1];
      long long v26 = *(v9 - 1);
      long long *v8 = *(v9 - 2);
      v8[1] = v26;
      *(_OWORD *)unint64_t v7 = v25;
      *(_OWORD *)(v7 + 16) = v24;
      LODWORD(v7) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v7 - 1;
  }
  else
  {
LABEL_14:
    if (!a3)
    {
      long long v35 = *a2;
      int v36 = *((_DWORD *)a2 + 4);
      uint64_t v4 = SCNMTLTextureDescToMTLTextureDescriptor((unsigned __int16 *)&v35);
    }
    uint64_t v13 = [*(id *)(a1 + 8) newTextureWithDescriptor:v4];
    long long v33 = *a2;
    unsigned int v34 = *((_DWORD *)a2 + 4);
    if (v13)
    {
      unint64_t v14 = *(void *)(a1 + 32);
      unint64_t v15 = *(void *)(a1 + 24);
      if (v15 >= v14)
      {
        uint64_t v18 = *(void *)(a1 + 16);
        uint64_t v19 = (uint64_t)(v15 - v18) >> 5;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 59) {
          abort();
        }
        uint64_t v21 = v14 - v18;
        if (v21 >> 4 > v20) {
          unint64_t v20 = v21 >> 4;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22) {
          uint64_t v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(a1 + 32, v22);
        }
        else {
          uint64_t v23 = 0;
        }
        int v27 = &v23[32 * v19];
        uint64_t v28 = &v23[32 * v22];
        *(void *)int v27 = v13;
        *(_OWORD *)(v27 + _Block_object_dispose(&STACK[0x380], 8) = v33;
        *((_DWORD *)v27 + 6) = v34;
        *((_DWORD *)v27 + 7) = 0;
        int v16 = v27 + 32;
        uint64_t v30 = *(char **)(a1 + 16);
        uint64_t v29 = *(char **)(a1 + 24);
        if (v29 != v30)
        {
          do
          {
            long long v31 = *((_OWORD *)v29 - 1);
            *((_OWORD *)v27 - 2) = *((_OWORD *)v29 - 2);
            *((_OWORD *)v27 - 1) = v31;
            v27 -= 32;
            v29 -= 32;
          }
          while (v29 != v30);
          uint64_t v29 = *(char **)(a1 + 16);
        }
        *(void *)(a1 + 16) = v27;
        *(void *)(a1 + 24) = v16;
        *(void *)(a1 + 32) = v28;
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *(void *)unint64_t v15 = v13;
        *(_OWORD *)(v15 + _Block_object_dispose(&STACK[0x380], 8) = v33;
        *(void *)(v15 + 24) = v34;
        int v16 = (char *)(v15 + 32);
      }
      *(void *)(a1 + 24) = v16;
    }
    else
    {
      uint64_t v17 = scn_default_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        SCNMTLTexturePool::allocate((uint64_t)v4, v17);
      }
    }
  }
  return v13;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a2);
}

uint64_t SCNMTLDeviceSupportsMemorylessStorage(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsMemorylessRenderTargets];
  }
  else
  {
    return [a1 supportsFeatureSet:5];
  }
}

void SCNMTLTexturePool::free(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_OWORD **)(a1 + 24);
  unint64_t v4 = *(unsigned int *)(a1 + 40);
  unsigned int v5 = (_OWORD *)(*(void *)(a1 + 16) + 32 * v4);
  if (v5 == v3)
  {
LABEL_5:
    unint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      SCNMTLTexturePool::free(a2, v7);
    }
  }
  else
  {
    uint64_t v6 = 0;
    while (*(void *)&v5[v6] != a2)
    {
      v6 += 2;
      if (&v5[v6] == v3) {
        goto LABEL_5;
      }
    }
    if (v6 * 16)
    {
      unint64_t v4 = (unint64_t)&v5[v6];
      long long v9 = v5[v6];
      long long v8 = v5[v6 + 1];
      long long v10 = v5[1];
      *(_OWORD *)unint64_t v4 = *v5;
      *(_OWORD *)(v4 + 16) = v10;
      *unsigned int v5 = v9;
      v5[1] = v8;
      LODWORD(v4) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v4 + 1;
  }
}

uint64_t SCNMTLDeviceSupportedSampleCountForSampleCount(void *a1, uint64_t a2)
{
  if (a2 < 2) {
    return 1;
  }
  uint64_t v13 = v3;
  uint64_t v14 = v2;
  uint64_t v15 = v4;
  uint64_t v16 = v5;
  unsigned int v7 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
  unsigned int v9 = (v8 | HIWORD(v8)) + 1;
  if (v9 >= 2)
  {
    while ((objc_msgSend(a1, "supportsTextureSampleCount:", v9, v13, v14, v15, v16) & 1) == 0)
    {
      unsigned int v11 = v9 >> 1;
      BOOL v12 = v9 > 3;
      v9 >>= 1;
      if (!v12) {
        return v11;
      }
    }
  }
  return v9;
}

void C3DNotifyMetalIsUsed()
{
  gMetalIsUsed = 1;
}

void C3DEngineContextSetRenderingOptionForKey(uint64_t a1, __CFString *key, void *value)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!*(void *)(a1 + 376)) {
    *(void *)(a1 + 376) = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  }
  if (@"debugRendering" == key)
  {
    *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x380], 8) = 1;
    C3DFXInvalidatePasses(a1);
  }
  uint64_t v14 = *(__CFDictionary **)(a1 + 376);
  if (value) {
    CFDictionarySetValue(v14, key, value);
  }
  else {
    CFDictionaryRemoveValue(v14, key);
  }
}

uint64_t C3DEngineContextGetRenderCallbacks(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 56;
}

void C3DEngineContextSetUserInfo(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 12_Block_object_dispose(&STACK[0x380], 8) = a2;
}

void C3DEngineContextSetRenderContext(uint64_t a1, CFTypeRef cf)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf) {
      goto LABEL_4;
    }
  }
  else if (cf)
  {
LABEL_4:
    CFTypeRef v12 = CFRetain(cf);
    goto LABEL_7;
  }
  CFTypeRef v12 = 0;
LABEL_7:
  *(void *)(a1 + 1704) = v12;
  *(_DWORD *)(a1 + 1712) = -[SCNMTLRenderContext features]((uint64_t)cf);
  *(_WORD *)(a1 + 214) = 3;
  if (-[SCNMTLRenderContext reverseZ]((uint64_t)cf)) {
    *(_WORD *)(a1 + 214) |= 8u;
  }
  *(void *)(a1 + 1696) = -[SCNMTLResourceManager commandQueue]((uint64_t)cf);
  __InstallFXContext(a1);
}

void __InstallFXContext(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 160);
  if (v2)
  {
    C3DFXContextCleanup(v2, a1);
    C3DEngineContextSetFXContext(a1, 0);
  }
  uint64_t v3 = C3DFXContextCreate();
  C3DEngineContextSetFXContext(a1, v3);
  if (C3DEngineContextGetScene(a1)) {
    C3DFXContextSceneDidChange((uint64_t)v3, a1);
  }

  CFRelease(v3);
}

void *C3DFXContextCreate()
{
  if (C3DFXContextGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXContextGetTypeID_onceToken, &__block_literal_global_103);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DFXContextGetTypeID_typeID, 0x130uLL);
  Instance[30] = C3DFramebufferRegistryCreate();
  uint64_t v1 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  Instance[35] = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
  Instance[37] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v1);
  uint64_t v2 = C3DAllocatorCreate(5136, 16);
  Instance[26] = v2;
  C3DAllocatorSetKeepLastPageAllocated((uint64_t)v2, 1);
  return Instance;
}

void *C3DFramebufferRegistryCreate()
{
  if (C3DFramebufferRegistryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFramebufferRegistryGetTypeID_onceToken, &__block_literal_global_69);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DFramebufferRegistryGetTypeID_typeID, 0x48uLL);
  if (Instance)
  {
    uint64_t v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
    Instance[6] = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
    Instance[2] = CFDictionaryCreateMutable(0, 0, 0, v1);
    Instance[3] = CFDictionaryCreateMutable(0, 0, 0, v1);
    uint64_t v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
    Instance[9] = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], v1);
    Instance[4] = CFDictionaryCreateMutable(0, 0, v2, 0);
  }
  return Instance;
}

CFTypeRef C3DEngineContextSetFXContext(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 160);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 160) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 160) = result;
  }
  return result;
}

void C3DEngineContextSetClearsOnDraw(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 210) = a2;
}

uint64_t C3DAllocatorSetKeepLastPageAllocated(uint64_t result, char a2)
{
  *(unsigned char *)(result + 64) = a2;
  return result;
}

void sub_20B2A28E4(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10A0C400A278675);
  _Unwind_Resume(a1);
}

void SCNMTLBufferPool::SCNMTLBufferPool(SCNMTLBufferPool *this, SCNMTLResourceManager *a2, NSString *a3, uint64_t a4, MTLStorageMode a5)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = a5;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 2) = a3;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
}

void sub_20B2A2978(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DUseOneCommandQueuePerDevice()
{
  if (C3DUseOneCommandQueuePerDevice_onceToken != -1) {
    dispatch_once(&C3DUseOneCommandQueuePerDevice_onceToken, &__block_literal_global_251);
  }
  return C3DUseOneCommandQueuePerDevice_useOneCommandQueuePerDevice;
}

void SCNMTLTexturePool::SCNMTLTexturePool(SCNMTLTexturePool *this, SCNMTLRenderContext *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = -[SCNMTLRenderContext resourceManager]((uint64_t)a2);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
}

uint64_t SCNMTLDeviceSupportsVertexAmplification(void *a1)
{
  uint64_t result = C3DSceneSourceGetSceneCount();
  if (result)
  {
    return [a1 supportsVertexAmplificationCount:2];
  }
  return result;
}

uint64_t SCNMTLDeviceSupportsTextureSwizzle(void *a1)
{
  uint64_t result = C3DSceneSourceGetSceneCount();
  if (result)
  {
    return [a1 supportsTextureSwizzle];
  }
  return result;
}

uint64_t SCNMTLDeviceSupportsTessellation(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsTessellation];
  }
  else
  {
    return [a1 supportsFeatureSet:7];
  }
}

uint64_t SCNMTLDeviceSupportsStencilResolve(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsMSAAStencilResolve];
  }
  else
  {
    return [a1 supportsFeatureSet:16];
  }
}

uint64_t SCNMTLDeviceSupportsProgrammableBlending(void *a1)
{
  if (!C3DSceneSourceGetSceneCount()) {
    return 1;
  }

  return [a1 supportsProgrammableBlending];
}

uint64_t SCNMTLDeviceSupportsNonUniformThreadgroupSize(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsNonUniformThreadgroupSize];
  }
  else
  {
    return [a1 supportsFeatureSet:11];
  }
}

uint64_t SCNMTLDeviceSupportsMultipleViewports(void *a1)
{
  if (C3DSceneSourceGetSceneCount()) {
    return (unint64_t)[a1 maxViewportCount] > 1;
  }

  return [a1 supportsFeatureSet:16];
}

uint64_t C3DSceneSourceGetSceneCount()
{
  return 1;
}

uint64_t SCNMTLDeviceSupportsLayeredRendering(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsLayeredRendering];
  }
  else
  {
    return [a1 supportsFeatureSet:16];
  }
}

uint64_t SCNMTLDeviceSupportsDepthResolve(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsMSAADepthResolve];
  }
  else
  {
    return [a1 supportsFeatureSet:4];
  }
}

uint64_t SCNMTLDeviceSupportsDepthClipMode(void *a1)
{
  if (!C3DSceneSourceGetSceneCount()) {
    return 1;
  }

  return [a1 supportsDepthClipMode];
}

uint64_t SCNMTLDeviceSupportsDepth24UnormStencil8()
{
  return 0;
}

uint64_t SCNMTLDeviceSupportsCubeMapWrite(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsReadWriteTextureCubeArguments];
  }
  else
  {
    return [a1 supportsFeatureSet:11];
  }
}

uint64_t SCNMTLDeviceSupportsCubeMapTextureArrays(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsTextureCubeArray];
  }
  else
  {
    return [a1 supportsFeatureSet:11];
  }
}

uint64_t SCNMTLDeviceSupportsBaseInstance(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
  {
    return [a1 supportsBaseVertexInstanceDrawing];
  }
  else if ([a1 supportsFeatureSet:10])
  {
    return 1;
  }
  else
  {
    return [a1 supportsFeatureSet:11];
  }
}

uint64_t C3DReverseZIsSupported()
{
  if (C3DReverseZIsSupported_onceToken != -1) {
    dispatch_once(&C3DReverseZIsSupported_onceToken, &__block_literal_global_236);
  }
  return C3DReverseZIsSupported_useReverseZ;
}

uint64_t SCNSampleCountForAntialiasingMode(unint64_t a1)
{
  int v1 = a1;
  if (a1 < 3) {
    return qword_20B5CCA90[a1];
  }
  uint64_t v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    SCNSampleCountForAntialiasingMode_cold_1(v1, v3);
  }
  return 1;
}

uint64_t C3DEngineContextGetRendererContextGL(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 136);
}

void C3D::MainPass::compile(C3D::MainPass *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,long long a28,uint64_t a29,float a30,float a31,float a32,float a33,float a34,float a35,int8x8_t a36,float a37,int a38,float a39,int a40,float a41,float a42,float a43,float a44,float a45,float a46,float a47,float a48,float a49,uint64_t a50,float32x2_t a51,float a52,int a53,int a54,unsigned int a55,unsigned int a56,unint64_t a57,float a58,int a59,float a60,float a61,float a62,long long a63)
{
  C3D::ScenePass::compile(this);
  uint64_t v69 = *((void *)this + 681);
  if (v69)
  {
    uint64_t v70 = *((void *)this + 2);
    C3D::PostProcessPassesComputeUniforms(v70, v69, this, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, a17, a18, a19,
      a20,
      a21,
      a22,
      a23,
      a24,
      a25,
      a26,
      a27,
      a28,
      a29,
      a30,
      a31,
      a32,
      a33,
      a34,
      a35,
      a36,
      a37,
      a38,
      a39,
      a40,
      a41,
      a42,
      a43,
      a44,
      a45,
      a46,
      a47,
      a48,
      a49,
      a50,
      a51,
      a52,
      a53,
      a54,
      a55,
      a56,
      a57,
      a58,
      a59,
      a60,
      a61,
      a62,
      a63);
  }
}

void C3D::PassResource::setInputAtIndex(C3D::PassResource *this, C3D::RefCountedResource *a2, unsigned int a3)
{
  if (*((unsigned __int16 *)this + 8) <= a3)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3D::PassResource::inputAtIndex();
    }
  }
  *(void *)(*(void *)this + 8 * a3) = a2;
}

uint64_t C3D::RenderGraph::lastNodeUsingResourceAtIndex(uint64_t result, unsigned char *a2, unsigned int a3, unsigned int a4, C3D::Pass ***a5, uint64_t *a6, BOOL *a7, BOOL *a8)
{
  if (*a2 == 1)
  {
    uint64_t v12 = result;
    uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(result + 8));
    uint64_t v14 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v12 + 24), a3);
    if (C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v14 + 32)) <= a4)
    {
      uint64_t v15 = 0;
      LOBYTE(v16) = a4;
    }
    else
    {
      uint64_t v15 = 0;
      LOBYTE(v16) = a4;
      do
      {
        if ((*(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(*v14, v16) + 66) & 0x80) == 0) {
          break;
        }
        C3D::RenderGraph::GraphNode::successorsAtIndex((uint64_t)v14, v16, StackAllocator, &v26);
        if (!v27) {
          break;
        }
        unsigned int v16 = HIBYTE(*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v26, 0));
        uint64_t v17 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v26, 0);
        uint64_t v14 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v12 + 24), *v17 & 0x7FFF);
        uint64_t v15 = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v14 + 32), v16);
      }
      while (C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v14 + 32)) > v16);
    }
    uint64_t result = C3D::PassDescriptor::inputCount((C3D::Pass *)((char *)*v14 + 32));
    if (result > v16)
    {
      unsigned int v18 = v16;
      int v19 = a2[31];
      uint64_t result = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v14 + 32), v18);
      *a7 = v19 != *(unsigned __int8 *)(result + 31);
    }
    BOOL v21 = *((_DWORD *)*v14 + 8) == 5 && a2[64] == 1;
    *a8 = v21;
    *a5 = v14;
    if (!v15)
    {
      uint64_t v22 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v12 + 24), a3);
      uint64_t result = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)v22 + 32), a4);
      uint64_t v15 = result;
    }
    *a6 = v15;
  }
  return result;
}

uint64_t C3D::RenderGraph::outputTextureUsageForPass(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::PassIODescriptor *a3)
{
  if (*((void *)this + 21)) {
    return 7;
  }
  uint64_t v4 = *((unsigned __int8 *)a3 + 26);
  int v5 = *(_DWORD *)C3D::Pass::descriptor(a2);
  uint64_t v6 = v4 | 4;
  if (v5 != 2) {
    uint64_t v6 = v4;
  }
  if (v5 == 3) {
    return v4 | 2;
  }
  else {
    return v6;
  }
}

uint64_t C3DEngineContextSetInterfaceOrientation(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36_Block_object_dispose(&STACK[0x380], 8) = a2;
  return result;
}

void __C3DMetalIsSupported_block_invoke()
{
  id v3 = MTLCreateSystemDefaultDevice();
  C3DMetalIsSupported_supported = v3 != 0;
  char v0 = [v3 supportsFeatureSet:1];
  kASTCIsSupported |= v0;
  char v1 = [v3 supportsFeatureSet:3];
  kASTCIsSupported |= v1;
  char v2 = [v3 supportsFeatureSet:4];
  kASTCIsSupported |= v2;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2014_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = dyld_program_sdk_at_least();
    char v1 = result ^ 1;
  }
  C3DWasLinkedBeforeMajorOSYear2014_linkedBeforeMajorOSYear2014 = v1;
  return result;
}

BOOL __C3DUseOneCommandQueuePerDevice_block_invoke()
{
  BOOL result = C3DPreferencesGetBool(18);
  C3DUseOneCommandQueuePerDevice_useOneCommandQueuePerDevice = result;
  return result;
}

void __C3DStandardShadersUseFunctionConstants_block_invoke()
{
  BOOL Bool = C3DPreferencesGetBool(11);
  C3DStandardShadersUseFunctionConstants_enableFunctionConstants = Bool;
  if (Bool)
  {
    if (C3DMetalIsSupported_onceToken != -1) {
      dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
    }
    BOOL v1 = C3DMetalIsSupported_supported != 0;
  }
  else
  {
    BOOL v1 = 0;
  }
  C3DStandardShadersUseFunctionConstants_enableFunctionConstants = v1;
}

void __scn_default_log_block_invoke()
{
  scn_default_log_logger = (uint64_t)os_log_create("com.apple.scenekit", "SceneKit");
  if (C3DPreferencesGetBool(17))
  {
    char v0 = scn_default_log_logger;
    if (os_log_type_enabled((os_log_t)scn_default_log_logger, OS_LOG_TYPE_DEBUG)) {
      __scn_default_log_block_invoke_cold_1(v0);
    }
  }
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2015_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = dyld_program_sdk_at_least();
    char v1 = result ^ 1;
  }
  C3DWasLinkedBeforeMajorOSYear2015_linkedBeforeMajorOSYear2015 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2016_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = dyld_program_sdk_at_least();
    char v1 = result ^ 1;
  }
  C3DWasLinkedBeforeMajorOSYear2016_linkedBeforeMajorOSYear2016 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2017_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if (result)
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2017_linkedBeforeMajorOSYear2017 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2018_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if (result & 1) != 0 || (uint64_t result = C3DPreferencesGetBool(15), (result))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2018_linkedBeforeMajorOSYear2018 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2019_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if ((result & 1) != 0
      || (uint64_t result = C3DPreferencesGetBool(15), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(14), (result & 1) != 0))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2019_linkedBeforeMajorOSYear2019 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2023_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if ((result & 1) != 0
      || (uint64_t result = C3DPreferencesGetBool(15), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(14), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(13), (result & 1) != 0))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2023_linkedBeforeMajorOSYear2023 = v1;
  return result;
}

BOOL __C3DReverseZIsSupported_block_invoke()
{
  int v0 = C3DWasLinkedBeforeMajorOSYear2019() ^ 1;
  if (!C3DReverseZIsSupported_useReverseZ) {
    LOBYTE(v0) = 0;
  }
  C3DReverseZIsSupported_useReverseZ = v0;
  if (C3DMetalIsSupported_onceToken != -1) {
    dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
  }
  if (C3DMetalIsSupported_supported) {
    BOOL v1 = C3DReverseZIsSupported_useReverseZ == 0;
  }
  else {
    BOOL v1 = 1;
  }
  char v2 = !v1;
  C3DReverseZIsSupported_useReverseZ = v2;
  BOOL result = C3DPreferencesGetBool(19);
  char v4 = !result;
  if (!C3DReverseZIsSupported_useReverseZ) {
    char v4 = 0;
  }
  C3DReverseZIsSupported_useReverseZ = v4;
  return result;
}

uint64_t __C3DWideGamutIsUsed_block_invoke()
{
  if (C3DWasLinkedBeforeMajorOSYear2019())
  {
    char v0 = C3DWasLinkedBeforeMajorOSYear2016();
    C3DWideGamutIsUsed_useWideGamut = v0 ^ 1;
    if (v0) {
      goto LABEL_13;
    }
    BOOL Bool = C3DPreferencesGetBool(7);
    C3DWideGamutIsUsed_useWideGamut = !Bool;
    if (Bool) {
      goto LABEL_13;
    }
    char IsSet = C3DGetInfoPlistFlagIsSet(@"SCNDisableWideGamut", 0);
    uint64_t result = 0;
    C3DWideGamutIsUsed_useWideGamut = IsSet ^ 1;
    if (IsSet) {
      goto LABEL_14;
    }
    goto LABEL_9;
  }
  C3DWideGamutIsUsed_useWideGamut = 0;
  C3DWideGamutIsUsed_useWideGamut = C3DPreferencesGetBool(8);
  if (C3DWideGamutIsUsed_useWideGamut)
  {
    C3DWideGamutIsUsed_useWideGamut = 1;
    goto LABEL_9;
  }
  char v4 = C3DGetInfoPlistFlagIsSet(@"SCNEnableWideGamut", 0);
  uint64_t result = 0;
  C3DWideGamutIsUsed_useWideGamut = v4;
  if (v4)
  {
LABEL_9:
    if (C3DMetalIsSupported_onceToken != -1) {
      dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
    }
    C3DWideGamutIsUsed_useWideGamut = C3DMetalIsSupported_supported;
    if (C3DMetalIsSupported_supported)
    {
      uint64_t result = MGGetBoolAnswer();
      goto LABEL_14;
    }
LABEL_13:
    uint64_t result = 0;
  }
LABEL_14:
  C3DWideGamutIsUsed_useWideGamut = result;
  return result;
}

uint64_t __SCNMetalLanguageVersion_block_invoke()
{
  uint64_t result = C3DWasLinkedBeforeMajorOSYear2019();
  if (result)
  {
    uint64_t v1 = 0x20000;
  }
  else
  {
    uint64_t v1 = 131073;
    uint64_t result = C3DWasLinkedBeforeMajorOSYear2020();
    if ((result & 1) == 0)
    {
      uint64_t result = C3DWasLinkedBeforeMajorOSYear2021();
      if (result) {
        uint64_t v1 = 131075;
      }
      else {
        uint64_t v1 = 0x20000;
      }
    }
  }
  SCNMetalLanguageVersion_languageVersion = v1;
  return result;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2019()
{
  if (C3DWasLinkedBeforeMajorOSYear2019_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2019_onceToken, &__block_literal_global_12);
  }
  return C3DWasLinkedBeforeMajorOSYear2019_linkedBeforeMajorOSYear2019;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2021()
{
  if (C3DWasLinkedBeforeMajorOSYear2021_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2021_onceToken, &__block_literal_global_16_1);
  }
  return C3DWasLinkedBeforeMajorOSYear2021_linkedBeforeMajorOSYear2021;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2020()
{
  if (C3DWasLinkedBeforeMajorOSYear2020_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2020_onceToken, &__block_literal_global_14);
  }
  return C3DWasLinkedBeforeMajorOSYear2020_linkedBeforeMajorOSYear2020;
}

void __C3DLinearRenderingIsEnabled_block_invoke()
{
  char v0 = _gC3DEnableLinearRendering;
  if (_gC3DEnableLinearRendering)
  {
    char v1 = C3DWasLinkedBeforeMajorOSYear2016();
    _gC3DEnableLinearRendering = v1 ^ 1;
    if ((v1 & 1) != 0 || (BOOL v2 = C3DPreferencesGetBool(6), _gC3DEnableLinearRendering = !v2, v2))
    {
      char v0 = 0;
    }
    else
    {
      BOOL Bool = C3DPreferencesGetBool(0);
      char v0 = 0;
      _gC3DEnableLinearRendering = !Bool;
      if (!Bool)
      {
        char IsSet = C3DGetInfoPlistFlagIsSet(@"SCNDisableLinearSpaceRendering", 0);
        char v0 = 0;
        _gC3DEnableLinearRendering = IsSet ^ 1;
        if ((IsSet & 1) == 0)
        {
          if (C3DMetalIsSupported_onceToken != -1) {
            dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
          }
          char v0 = C3DMetalIsSupported_supported != 0;
        }
      }
    }
  }
  _gC3DEnableLinearRendering = v0;
}

void *C3DEngineContextCleanup(uint64_t a1)
{
  if (!a1)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(void *)(a1 + 216) = 0;
  C3DEngineContextSetPointOfView(a1, 0);
  uint64_t result = (void *)C3DEngineContextGetRendererContextGL(a1);
  if (result)
  {
    uint64_t result = (void *)C3DEngineContextGetFXContext(a1);
    if (result)
    {
      C3DFXContextCleanup(result, a1);
      return C3DEngineContextSetFXContext(a1, 0);
    }
  }
  return result;
}

uint64_t SCNMTLBlitCommandEncoder::endEncoding(SCNMTLBlitCommandEncoder *this)
{
  if (!this->_encoder)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::endEncoding(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = [(MTLBlitCommandEncoder *)this->_encoder endEncoding];
  this->_encoder = 0;
  this->_commandBuffer = 0;
  return result;
}

unint64_t _setupMetalBackingLayer(void *a1, int a2)
{
  if (a2) {
    char v3 = 32;
  }
  else {
    char v3 = 0;
  }
  [a1 setPixelFormat:C3DMetalFramebufferPixelFormat(v3)];
  [a1 setFramebufferOnly:1];
  unint64_t result = [a1 maximumDrawableCount];
  if (result >= 3)
  {
    return [a1 setFenceEnabled:1];
  }
  return result;
}

id SCNUIKitSourceSetCurrentViewEvent(id result)
{
  if ((id)gCurrentSCNViewEvent != result)
  {
    char v1 = result;

    unint64_t result = v1;
    gCurrentSCNViewEvent = (uint64_t)result;
  }
  return result;
}

uint64_t SCNGetPerformanceStatisticsEnabled()
{
  if (SCNGetPerformanceStatisticsEnabled::onceToken != -1) {
    dispatch_once(&SCNGetPerformanceStatisticsEnabled::onceToken, &__block_literal_global_49);
  }
}

void C3DNotificationCenterAddObserver(uint64_t a1, const void *a2, void (__cdecl *a3)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef), const __CFString *a4, const void *a5, CFNotificationSuspensionBehavior a6)
{
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();

  CFNotificationCenterAddObserver(LocalCenter, a2, a3, a4, a5, a6);
}

uint64_t C3DMetalIsSupported()
{
  if (C3DMetalIsSupported_onceToken != -1) {
    dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
  }
  return C3DMetalIsSupported_supported;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2015()
{
  if (C3DWasLinkedBeforeMajorOSYear2015_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2015_onceToken, &__block_literal_global_4_2);
  }
  return C3DWasLinkedBeforeMajorOSYear2015_linkedBeforeMajorOSYear2015;
}

uint64_t C3DGetInfoPlistFlagIsSet(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F086E0], "mainBundle"), "infoDictionary"), "objectForKeyedSubscript:", a1);
  if (!v3) {
    return a2;
  }
  uint64_t v4 = (void *)v3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return a2;
  }

  return [v4 BOOLValue];
}

uint64_t C3DGetShaderCacheLibraryURL()
{
  return kShaderCacheLibraryURL;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2022_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if ((result & 1) != 0
      || (uint64_t result = C3DPreferencesGetBool(15), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(14), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(13), (result & 1) != 0))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2022_linkedBeforeMajorOSYear2022 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2020_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if ((result & 1) != 0
      || (uint64_t result = C3DPreferencesGetBool(15), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(14), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(13), (result & 1) != 0))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2020_linkedBeforeMajorOSYear2020 = v1;
  return result;
}

uint64_t __C3DWasLinkedBeforeMajorOSYear2021_block_invoke()
{
  uint64_t result = C3DPreferencesGetBool(12);
  if (result)
  {
    char v1 = 0;
  }
  else
  {
    uint64_t result = C3DPreferencesGetBool(16);
    if ((result & 1) != 0
      || (uint64_t result = C3DPreferencesGetBool(15), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(14), (result & 1) != 0)
      || (uint64_t result = C3DPreferencesGetBool(13), (result & 1) != 0))
    {
      char v1 = 1;
    }
    else
    {
      uint64_t result = dyld_program_sdk_at_least();
      char v1 = result ^ 1;
    }
  }
  C3DWasLinkedBeforeMajorOSYear2021_linkedBeforeMajorOSYear2021 = v1;
  return result;
}

BOOL C3DPreferencesGetBool(int a1)
{
  if (C3DPreferencesGetInteger_onceToken != -1) {
    dispatch_once(&C3DPreferencesGetInteger_onceToken, &__block_literal_global_129);
  }
  return C3DPreferencesGetInteger_prefs[a1] != 0;
}

uint64_t C3DShaderModifierUpdateHashCode(uint64_t a1, CC_SHA256_CTX *c)
{
  return CC_SHA256_Update(c, (const void *)(a1 + 104), 0x20u);
}

C3D::Pass *C3DLoadBuiltInPasses(uint64_t a1)
{
  return C3D::RenderGraph::createPass<C3D::FinalPass,decltype(nullptr)>(a1);
}

C3D::Pass *C3D::RenderGraph::createPass<C3D::FinalPass,decltype(nullptr)>(uint64_t a1)
{
  uint64_t Aligned = (C3D::Pass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 176, 16, 0);
  C3D::Pass::Pass(Aligned, (RenderGraph *)a1, 0);
  *uint64_t v3 = &unk_26BF6E8E0;
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::Pass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::MainPass *C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(uint64_t a1, C3D::Pass **a2)
{
  uint64_t Aligned = (C3D::MainPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5456, 16, 0);
  C3D::MainPass::MainPass(Aligned, (C3D::RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::MainPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::DrawNodesPass *C3D::MainPass::MainPass(C3D::MainPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  *(_DWORD *)&v10.var0 = 16843009;
  *(_WORD *)&v10.var4 = 1;
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  long long v6 = xmmword_20B5CBBE0;
  char v7 = 1;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t result = C3D::ScenePass::ScenePass(this, a2, a3, &v10, (const Parameters *)v4);
  *(void *)uint64_t result = &unk_26BF6E850;
  *((void *)result + 681) = 0;
  *((unsigned char *)result + 5365) = 1;
  return result;
}

C3D::DrawNodesPass *C3D::ScenePass::ScenePass(C3D::ScenePass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4, const Parameters *a5)
{
  uint64_t result = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, a5);
  *(void *)uint64_t result = &unk_26BF6E9E0;
  int v7 = *(_DWORD *)&a4->var0;
  *((_WORD *)result + 2682) = *(_WORD *)&a4->var4;
  *((_DWORD *)result + 1340) = v7;
  *((void *)result + 671) = 0;
  *((void *)result + 673) = 0;
  *((void *)result + 672) = 0;
  *((void *)result + 680) = result;
  return result;
}

C3D::DrawNodesPass *C3D::DrawNodesPass::DrawNodesPass(C3D::DrawNodesPass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  long long v6 = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)long long v6 = &unk_26BF6CF90;
  *((_OWORD *)v6 + 15) = *(_OWORD *)&a4->var0;
  long long v7 = *(_OWORD *)&a4[1].var6;
  long long v8 = *(_OWORD *)&a4[3].var2;
  long long v9 = *(_OWORD *)&a4[4].var8;
  *((void *)v6 + 3_Block_object_dispose(&STACK[0x380], 8) = *(void *)&a4[6].var4;
  *((_OWORD *)v6 + 17) = v8;
  *((_OWORD *)v6 + 1_Block_object_dispose(&STACK[0x380], 8) = v9;
  *((_OWORD *)v6 + 16) = v7;
  bzero((char *)v6 + 320, 0x13B0uLL);
  return this;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, unsigned int a2, unsigned int a3)
{
  uint64_t v4 = *((void *)this + 3);
  unsigned int v5 = *(_DWORD *)(v4 + 8);
  if (v5 <= a2) {
    C3D::RenderGraph::addDependency();
  }
  if (v5 <= a3) {
    C3D::RenderGraph::addDependency();
  }
  long long v8 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v4, a2);
  long long v9 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), a3);
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 1));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v19, StackAllocator);
  C3D::RenderGraph::matchingPortForNodes((uint64_t)this, (uint64_t)v8, v9, (uint64_t)&v19);
  if (v20)
  {
    uint64_t v11 = v21;
    uint64_t v12 = &v21[2 * v20];
    do
    {
      C3D::RenderGraph::addDependency(this, a2, a3, *v11, v11[1]);
      v11 += 2;
    }
    while (v11 != v12);
  }
  else
  {
    uint64_t v13 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
    int v14 = C3D::PassDescriptor::inputCount(v13);
    uint64_t v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v9);
    int v16 = C3D::PassDescriptor::outputCount(v15);
    if (v14 == 1) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = 255;
    }
    if (v16 == 1) {
      uint64_t v18 = 0;
    }
    else {
      uint64_t v18 = 255;
    }
    C3D::RenderGraph::addDependency(this, a2, a3, v17, v18);
  }
}

uint64_t C3D::RenderGraph::matchingPortForNodes(uint64_t a1, uint64_t a2, C3D::Pass **a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  int v38 = *(_DWORD *)(a4 + 8);
  uint64_t v39 = *(C3D::Pass **)a2;
  int v36 = *a3;
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(a1 + 8));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v41, StackAllocator);
  uint64_t v7 = *(unsigned int *)(a2 + 16);
  if (v7)
  {
    long long v8 = *(_DWORD **)(a2 + 24);
    uint64_t v9 = 4 * v7;
    do
    {
      if ((~*v8 & 0xFF0000) != 0)
      {
        LOBYTE(v40) = BYTE2(*v8);
        C3D::Array<unsigned char,16u,C3D::StackAllocator>::push_back<unsigned char>(&v41, &v40);
      }
      ++v8;
      v9 -= 4;
    }
    while (v9);
  }
  Parameters v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v36);
  uint64_t result = C3D::PassDescriptor::outputCount(v10);
  unsigned __int8 v35 = result;
  if (!(_BYTE)result) {
    return result;
  }
  unsigned __int16 v12 = 0;
  char v37 = 0;
  unsigned __int8 v13 = 0;
  do
  {
    int v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v36);
    uint64_t v15 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v14, v12);
    int v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    uint64_t result = C3D::PassDescriptor::inputCount(v16);
    uint64_t v17 = result;
    if (!(_BYTE)result) {
      goto LABEL_42;
    }
    uint64_t v18 = 0;
    unsigned __int8 v19 = 0;
    while (1)
    {
      int v20 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
      BOOL v21 = (const C3D::PassIODescriptor *)C3D::PassDescriptor::inputAtIndex(v20, v18);
      uint64_t v22 = __s;
      uint64_t v23 = __n;
      long long v24 = (char *)__s + __n;
      long long v25 = (char *)memchr(__s, (char)v19, __n);
      uint64_t v26 = v25 ? v25 : v24;
      BOOL v27 = v26 - v22 == v23;
      uint64_t result = C3D::PassIODescriptor::isMatching(v15, v21);
      if ((v27 & result) == 1) {
        break;
      }
LABEL_39:
      ++v19;
      if (++v18 == v17) {
        goto LABEL_42;
      }
    }
    if (v38)
    {
      if (!*(_DWORD *)(a4 + 8)) {
        goto LABEL_34;
      }
      unint64_t v28 = 0;
      do
      {
        if (*(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28) == v19
          || (uint64_t result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28),
              *(unsigned __int8 *)(result + 1) == v13))
        {
          uint64_t result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28);
          *(unsigned char *)uint64_t result = v19;
          *(unsigned char *)(result + 1) = v13;
          goto LABEL_39;
        }
        ++v28;
        unint64_t v29 = *(unsigned int *)(a4 + 8);
      }
      while (v28 < v29);
      if (!v29) {
        goto LABEL_34;
      }
      unint64_t v30 = 0;
      char v31 = 0;
      do
      {
        uint64_t result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
        if (*(unsigned __int8 *)result == 255)
        {
          uint64_t result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
          if (*(unsigned __int8 *)(result + 1) == 255)
          {
            uint64_t result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
            *(unsigned char *)uint64_t result = v19;
            *(unsigned char *)(result + 1) = v13;
            char v31 = 1;
            char v37 = 1;
          }
        }
        ++v30;
      }
      while (v30 < *(unsigned int *)(a4 + 8));
      if ((v31 & 1) == 0)
      {
LABEL_34:
        if (v37)
        {
          LOBYTE(v40) = v19;
          HIBYTE(v40) = v13;
          uint64_t result = (uint64_t)C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>((_DWORD *)a4, &v40);
        }
      }
      goto LABEL_39;
    }
    uint64_t v32 = *(unsigned int *)(a4 + 8);
    if (v32)
    {
      uint64_t v33 = 2 * v32;
      unsigned int v34 = *(unsigned __int8 **)(a4 + 16);
      while (*v34 != v19 && v34[1] != v13)
      {
        v34 += 2;
        v33 -= 2;
        if (!v33) {
          goto LABEL_41;
        }
      }
    }
    else
    {
      unsigned int v34 = *(unsigned __int8 **)(a4 + 16);
    }
    if (v34 != (unsigned __int8 *)(*(void *)(a4 + 16) + 2 * v32)) {
      goto LABEL_39;
    }
LABEL_41:
    LOBYTE(v40) = v19;
    HIBYTE(v40) = v13;
    uint64_t result = (uint64_t)C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>((_DWORD *)a4, &v40);
LABEL_42:
    unsigned __int16 v12 = ++v13;
  }
  while (v13 < v35);
  return result;
}

BOOL C3D::PassIODescriptor::isMatching(C3D::PassIODescriptor *this, const C3D::PassIODescriptor *a2)
{
  if (*(unsigned __int8 *)this != *(unsigned __int8 *)a2) {
    return 0;
  }
  if (*((unsigned __int8 *)this + 64) != *((unsigned __int8 *)a2 + 64)) {
    return 0;
  }
  uint64_t v4 = (const char *)*((void *)this + 1);
  if (v4)
  {
    unsigned int v5 = (const char *)*((void *)a2 + 1);
    if (v5)
    {
      if (strcmp(v4, v5)) {
        return 0;
      }
    }
  }

  return C3D::PassIODescriptor::isPartiallyCompatible(this, a2);
}

_DWORD *C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(_DWORD *result, _WORD *a2)
{
  uint64_t v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  long long v6 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = C3DStackAllocatorAllocateAligned(*(void *)result, 2 * v7, 1, 0);
    uint64_t result = memcpy(Aligned, v6, 2 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v7;
    long long v6 = Aligned;
    unsigned int v4 = v3[2];
  }
  *((_WORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

void C3D::RenderGraph::validate(C3D::RenderGraph *this)
{
  uint64_t v118 = *MEMORY[0x263EF8340];
  for (uint64_t i = *((void *)this + 12); i; uint64_t i = *(void *)(v89 + 24))
  {
    uint64_t v89 = i;
    uint64_t v3 = *(unsigned int *)(i + 8);
    if (v3)
    {
      unsigned int v4 = *(unsigned __int16 **)(i + 16);
      uint64_t v90 = &v4[v3];
      do
      {
        size_t v91 = v4;
        uint64_t v5 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v4);
        long long v6 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
        if (C3D::PassDescriptor::inputCount(v6))
        {
          unint64_t v7 = 0;
          do
          {
            long long v8 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
            uint64_t v9 = C3D::PassDescriptor::inputAtIndex(v8, (unsigned __int16)v7);
            if ((*(_WORD *)(v9 + 66) & 0x80) != 0)
            {
              Parameters v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
              uint64_t v11 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v10, (unsigned __int16)v7);
              if (*(_DWORD *)C3D::Pass::descriptor(*(C3D::Pass **)v5) == 2 && (*(_WORD *)(v9 + 66) & 3) != 1)
              {
                if ((C3D::RenderGraph::validate(void)::done & 1) == 0)
                {
                  C3D::RenderGraph::validate(void)::done = 1;
                  unsigned __int16 v12 = scn_default_log();
                  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v21 = (***(uint64_t (****)(void))v5)();
                    uint64_t v22 = *(void *)(v9 + 8);
                    *(_DWORD *)uint64_t v96 = 136315650;
                    *(void *)&v96[4] = v21;
                    *(_WORD *)&v96[12] = 2048;
                    *(void *)&v96[14] = v7;
                    *(_WORD *)&v96[22] = 2080;
                    *(void *)&v96[24] = v22;
                    _os_log_error_impl(&dword_20B249000, v12, OS_LOG_TYPE_ERROR, "Error: ReadWrite pass %s require input %zu:%s with load mode set to \"Load\", forcing it.", v96, 0x20u);
                  }
                }
                *(_WORD *)(v9 + 66) = *(_WORD *)(v9 + 66) & 0xFFFC | 1;
              }
              if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v9, (const PassIODescriptor *)v11))
              {
                unsigned __int8 v13 = scn_default_log();
                if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
                  C3D::RenderGraph::validate((uint64_t)v117, v5);
                }
                int v14 = scn_default_log();
                if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
                {
                  C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v9, (std::string *)v96);
                  int v17 = v96[23];
                  uint64_t v18 = *(unsigned char **)v96;
                  C3D::PassIODescriptor::description(v11, &__p);
                  unsigned __int8 v19 = v96;
                  if (v17 < 0) {
                    unsigned __int8 v19 = v18;
                  }
                  p_p = &__p;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  *(_DWORD *)float32x4_t buf = 136315394;
                  int v114 = v19;
                  __int16 v115 = 2080;
                  int v116 = p_p;
                  _os_log_error_impl(&dword_20B249000, v14, OS_LOG_TYPE_ERROR, "Error: Input %s doesn't match output %s.", buf, 0x16u);
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p.__r_.__value_.__l.__data_);
                  }
                  if ((v96[23] & 0x80000000) != 0) {
                    operator delete(*(void **)v96);
                  }
                }
                uint64_t v15 = scn_default_log();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
                  C3D::RenderGraph::resolvePartialCompatibility(v111, &v112, v15);
                }
              }
            }
            int v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
            ++v7;
          }
          while (v7 < C3D::PassDescriptor::inputCount(v16));
        }
        uint64_t v23 = *(unsigned int *)(v5 + 40);
        if (v23)
        {
          long long v24 = *(unsigned int **)(v5 + 48);
          uint64_t v25 = 4 * v23;
          do
          {
            uint64_t v26 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v24 & 0x7FFF);
            if (HIBYTE(*v24) == 255 || (*v24 & 0xFF0000) == 0xFF0000)
            {
              BOOL v27 = scn_default_log();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                uint64_t v48 = (**(uint64_t (***)(void))*v26)();
                uint64_t v49 = (***(uint64_t (****)(void))v5)();
                *(_DWORD *)uint64_t v96 = 136315394;
                *(void *)&v96[4] = v48;
                *(_WORD *)&v96[12] = 2080;
                *(void *)&v96[14] = v49;
                _os_log_error_impl(&dword_20B249000, v27, OS_LOG_TYPE_ERROR, "Error: Unresolved dependency between %s and %s\n", v96, 0x16u);
              }
              unint64_t v28 = scn_default_log();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v109, &v110, v28);
              }
            }
            unint64_t v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
            uint64_t v30 = C3D::PassDescriptor::outputAtIndex(v29, *((unsigned __int8 *)v24 + 2));
            char v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v26);
            uint64_t v32 = C3D::PassDescriptor::inputAtIndex(v31, *((unsigned __int8 *)v24 + 3));
            if (*(unsigned char *)v30 == 1 && *(unsigned char *)(v30 + 31) == 1)
            {
              uint64_t v33 = scn_default_log();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                int v64 = *(unsigned __int8 *)(v30 + 31);
                uint64_t v65 = (***(uint64_t (****)(void))v5)();
                int v66 = *((unsigned __int8 *)v24 + 2);
                uint64_t v67 = *(void *)(v30 + 8);
                *(_DWORD *)uint64_t v96 = 67109890;
                *(_DWORD *)&v96[4] = v64;
                *(_WORD *)&v96[8] = 2080;
                *(void *)&v96[10] = v65;
                *(_WORD *)&v96[18] = 1024;
                *(_DWORD *)&v96[20] = v66;
                *(_WORD *)&v96[24] = 2080;
                *(void *)&v96[26] = v67;
                _os_log_error_impl(&dword_20B249000, v33, OS_LOG_TYPE_ERROR, "Error: Invalid output texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0", v96, 0x22u);
              }
              unsigned int v34 = scn_default_log();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v107, &v108, v34);
              }
            }
            if (*(unsigned char *)v32 == 1 && *(unsigned char *)(v32 + 31) == 1)
            {
              unsigned __int8 v35 = scn_default_log();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              {
                int v68 = *(unsigned __int8 *)(v32 + 31);
                uint64_t v69 = (**(uint64_t (***)(void))*v26)();
                int v70 = *((unsigned __int8 *)v24 + 3);
                uint64_t v71 = *(void *)(v32 + 8);
                *(_DWORD *)uint64_t v96 = 67109890;
                *(_DWORD *)&v96[4] = v68;
                *(_WORD *)&v96[8] = 2080;
                *(void *)&v96[10] = v69;
                *(_WORD *)&v96[18] = 1024;
                *(_DWORD *)&v96[20] = v70;
                *(_WORD *)&v96[24] = 2080;
                *(void *)&v96[26] = v71;
                _os_log_error_impl(&dword_20B249000, v35, OS_LOG_TYPE_ERROR, "Error: Invalid input texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0", v96, 0x22u);
              }
              int v36 = scn_default_log();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v105, &v106, v36);
              }
            }
            if (!C3D::PassIODescriptor::isValid((C3D::PassIODescriptor *)v30))
            {
              char v37 = scn_default_log();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
                C3D::RenderGraph::validate((uint64_t)v104, v5);
              }
              int v38 = scn_default_log();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                int v50 = *((unsigned __int8 *)v24 + 3);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v30, (std::string *)v96);
                uint64_t v51 = v96;
                if (v96[23] < 0) {
                  uint64_t v51 = *(unsigned char **)v96;
                }
                LODWORD(__p.__r_.__value_.__l.__data_) = 67109378;
                HIDWORD(__p.__r_.__value_.__r.__words[0]) = v50;
                LOWORD(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v51;
                _os_log_error_impl(&dword_20B249000, v38, OS_LOG_TYPE_ERROR, "Error: Invalid output parameters for port %d: %s", (uint8_t *)&__p, 0x12u);
                if ((v96[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v96);
                }
              }
              uint64_t v39 = scn_default_log();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v102, &v103, v39);
              }
            }
            if (!C3D::PassIODescriptor::isValid((C3D::PassIODescriptor *)v32))
            {
              __int16 v40 = scn_default_log();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
                C3D::RenderGraph::validate((uint64_t)v101, (uint64_t)v26);
              }
              uint64_t v41 = scn_default_log();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                int v52 = *((unsigned __int8 *)v24 + 2);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v32, (std::string *)v96);
                __int16 v53 = v96;
                if (v96[23] < 0) {
                  __int16 v53 = *(unsigned char **)v96;
                }
                LODWORD(__p.__r_.__value_.__l.__data_) = 67109378;
                HIDWORD(__p.__r_.__value_.__r.__words[0]) = v52;
                LOWORD(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v53;
                _os_log_error_impl(&dword_20B249000, v41, OS_LOG_TYPE_ERROR, "Error: Buffer input parameters for port %d: %s", (uint8_t *)&__p, 0x12u);
                if ((v96[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v96);
                }
              }
              uint64_t v42 = scn_default_log();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v99, &v100, v42);
              }
            }
            if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v30, (const PassIODescriptor *)v32))
            {
              uint64_t v43 = scn_default_log();
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                uint64_t v54 = (***(uint64_t (****)(void))v5)();
                uint64_t v55 = (**(uint64_t (***)(void))*v26)();
                *(_DWORD *)uint64_t v96 = 136315394;
                *(void *)&v96[4] = v54;
                *(_WORD *)&v96[12] = 2080;
                *(void *)&v96[14] = v55;
                _os_log_error_impl(&dword_20B249000, v43, OS_LOG_TYPE_ERROR, "Error: Compatibility mismatch between %s and %s\n", v96, 0x16u);
              }
              uint64_t v44 = scn_default_log();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                unsigned int v56 = *v24;
                int v57 = BYTE2(*v24);
                *(_DWORD *)uint64_t v96 = 67109376;
                *(_DWORD *)&v96[4] = v57;
                *(_WORD *)&v96[8] = 1024;
                *(_DWORD *)&v96[10] = HIBYTE(v56);
                _os_log_error_impl(&dword_20B249000, v44, OS_LOG_TYPE_ERROR, "Error: Output buffer parameters for port %d isn't compatible with input port %d\n", v96, 0xEu);
              }
              BOOL v45 = scn_default_log();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                uint64_t v58 = (***(uint64_t (****)(void))v5)();
                int v59 = *((unsigned __int8 *)v24 + 3);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v30, &__p);
                uint64_t v60 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)uint64_t v96 = 136315650;
                *(void *)&v96[4] = v58;
                *(_WORD *)&v96[12] = 1024;
                *(_DWORD *)&v96[14] = v59;
                *(_WORD *)&v96[18] = 2080;
                *(void *)&v96[20] = v60;
                _os_log_error_impl(&dword_20B249000, v45, OS_LOG_TYPE_ERROR, "Error: Output descriptor of pass %s at port %d: %s", v96, 0x1Cu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
              }
              uint64_t v46 = scn_default_log();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              {
                uint64_t v61 = (**(uint64_t (***)(void))*v26)();
                int v62 = *((unsigned __int8 *)v24 + 2);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v32, &__p);
                double v63 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  double v63 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)uint64_t v96 = 136315650;
                *(void *)&v96[4] = v61;
                *(_WORD *)&v96[12] = 1024;
                *(_DWORD *)&v96[14] = v62;
                *(_WORD *)&v96[18] = 2080;
                *(void *)&v96[20] = v63;
                _os_log_error_impl(&dword_20B249000, v46, OS_LOG_TYPE_ERROR, "Error: Input descriptor of pass %s at port %d: %s", v96, 0x1Cu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
              }
              uint64_t v47 = scn_default_log();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v97, &v98, v47);
              }
            }
            ++v24;
            v25 -= 4;
          }
          while (v25);
        }
        uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 1));
        C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(v96, StackAllocator);
        uint64_t v73 = *(unsigned int *)(v5 + 16);
        if (v73)
        {
          char v74 = *(int **)(v5 + 24);
          uint64_t v75 = 4 * v73;
          do
          {
            uint64_t v76 = (uint64_t (****)(void))C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v74 & 0x7FFF);
            int v77 = *v74;
            buf[0] = BYTE2(*v74);
            buf[1] = HIBYTE(v77);
            C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(v96, buf);
            if (HIBYTE(*v74) == 255 || (*v74 & 0xFF0000) == 0xFF0000)
            {
              uint64_t v78 = scn_default_log();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                std::string::size_type v80 = (***(uint64_t (****)(void))v5)();
                std::string::size_type v81 = (***v76)();
                LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v80;
                WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v81;
                _os_log_error_impl(&dword_20B249000, v78, OS_LOG_TYPE_ERROR, "Error: Unresolved dependency between %s and %s\n", (uint8_t *)&__p, 0x16u);
              }
              uint64_t v79 = scn_default_log();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::validate(v94, &v95, v79);
              }
            }
            ++v74;
            v75 -= 4;
          }
          while (v75);
        }
        unint64_t v82 = 126 - 2 * __clz(*(unsigned int *)&v96[8]);
        if (*(_DWORD *)&v96[8]) {
          uint64_t v83 = v82;
        }
        else {
          uint64_t v83 = 0;
        }
        std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(*(unsigned __int8 **)&v96[16], (unsigned __int8 *)(*(void *)&v96[16] + 2 * *(unsigned int *)&v96[8]), v83, 1);
        uint64_t v84 = *(unsigned int *)&v96[8];
        if (*(_DWORD *)&v96[8])
        {
          std::string::size_type v85 = 0;
          do
          {
            if (v85)
            {
              int v86 = *(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v96, v85);
              if (v86 == *(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v96, (int)v85 - 1))
              {
                uint64_t v87 = scn_default_log();
                if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v88 = (***(uint64_t (****)(void))v5)();
                  LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
                  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"index == 0 || inputPorts[index].a != inputPorts[index - 1].a";
                  WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
                  *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v85;
                  HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
                  uint64_t v93 = v88;
                  _os_log_fault_impl(&dword_20B249000, v87, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Multiple dependencies on the same input %zu on %s", (uint8_t *)&__p, 0x20u);
                }
              }
            }
            ++v85;
          }
          while (v84 != v85);
        }
        unsigned int v4 = v91 + 1;
      }
      while (v91 + 1 != v90);
    }
  }
}

void sub_20B2A7C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a48 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DEngineContextGetStackAllocator(uint64_t a1)
{
  if (!a1)
  {
    BOOL v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 168);
}

void *C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0x1000000000;
  a1[2] = a1 + 3;
  if (!a2)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return a1;
}

unsigned __int8 *std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(unsigned __int8 *result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (a2 - v10) >> 1;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(a2 - 2) < *v10)
                {
                  __int16 v41 = *(_WORD *)v10;
                  *(_WORD *)uint64_t v10 = *((_WORD *)a2 - 1);
                  *((_WORD *)a2 - 1) = v41;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v10, v10 + 2, (_WORD *)a2 - 1);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v10, v10 + 2, (__int16 *)v10 + 2, (__int16 *)a2 - 1);
                break;
              case 5uLL:
                uint64_t v42 = v10 + 4;
                uint64_t v43 = v10 + 6;
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v10, v10 + 2, (__int16 *)v10 + 2, (__int16 *)v10 + 3);
                if (*(a2 - 2) < v10[6])
                {
                  __int16 v44 = *(_WORD *)v43;
                  *(_WORD *)uint64_t v43 = *((_WORD *)a2 - 1);
                  *((_WORD *)a2 - 1) = v44;
                  if (*v43 < *v42)
                  {
                    __int16 v45 = *(_WORD *)v42;
                    __int16 v46 = *(_WORD *)v43;
                    *(_WORD *)uint64_t v42 = *(_WORD *)v43;
                    *(_WORD *)uint64_t v43 = v45;
                    if (v10[2] > v46)
                    {
                      __int16 v47 = *((_WORD *)v10 + 1);
                      *((_WORD *)v10 + 1) = v46;
                      *((_WORD *)v10 + 2) = v47;
                      if (*v10 > v46)
                      {
                        __int16 v48 = *(_WORD *)v10;
                        *(_WORD *)uint64_t v10 = v46;
                        *((_WORD *)v10 + 1) = v48;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 47)
          {
            uint64_t v49 = v10 + 2;
            BOOL v51 = v10 == a2 || v49 == a2;
            if (a4)
            {
              if (!v51)
              {
                uint64_t v52 = 0;
                __int16 v53 = v10;
                do
                {
                  unsigned int v54 = v53[2];
                  unsigned int v55 = *v53;
                  __int16 v53 = v49;
                  if (v54 < v55)
                  {
                    __int16 v56 = *(_WORD *)v49;
                    uint64_t v57 = v52;
                    while (1)
                    {
                      *(_WORD *)&v10[v57 + 2] = *(_WORD *)&v10[v57];
                      if (!v57) {
                        break;
                      }
                      unsigned int v58 = v10[v57 - 2];
                      v57 -= 2;
                      if (v58 <= v56)
                      {
                        int v59 = &v10[v57 + 2];
                        goto LABEL_83;
                      }
                    }
                    int v59 = v10;
LABEL_83:
                    *(_WORD *)int v59 = v56;
                  }
                  uint64_t v49 = v53 + 2;
                  v52 += 2;
                }
                while (v53 + 2 != a2);
              }
            }
            else if (!v51)
            {
              do
              {
                unsigned int v88 = v9[2];
                unsigned int v89 = *v9;
                uint64_t v9 = v49;
                if (v88 < v89)
                {
                  __int16 v90 = *(_WORD *)v49;
                  do
                  {
                    size_t v91 = v49;
                    __int16 v92 = *((_WORD *)v49 - 1);
                    v49 -= 2;
                    _WORD *v91 = v92;
                  }
                  while (*((unsigned __int8 *)v91 - 4) > v90);
                  *(_WORD *)uint64_t v49 = v90;
                }
                uint64_t v49 = v9 + 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v60 = (v12 - 2) >> 1;
              int64_t v61 = v60;
              do
              {
                int64_t v62 = v61;
                if (v60 >= v61)
                {
                  uint64_t v63 = (2 * v61) | 1;
                  int v64 = &v10[2 * v63];
                  if (2 * v62 + 2 < (uint64_t)v12)
                  {
                    unsigned int v67 = *v64;
                    unsigned int v65 = v64[2];
                    BOOL v66 = v67 >= v65;
                    if (v67 <= v65) {
                      unsigned int v67 = v64[2];
                    }
                    if (!v66)
                    {
                      v64 += 2;
                      uint64_t v63 = 2 * v62 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v67 = *v64;
                  }
                  int v68 = &v10[2 * v62];
                  if (v67 >= *v68)
                  {
                    __int16 v69 = *(_WORD *)v68;
                    do
                    {
                      int v70 = v68;
                      int v68 = v64;
                      *(_WORD *)int v70 = *(_WORD *)v64;
                      if (v60 < v63) {
                        break;
                      }
                      uint64_t v71 = (2 * v63) | 1;
                      int v64 = &v10[2 * v71];
                      uint64_t v63 = 2 * v63 + 2;
                      if (v63 < (uint64_t)v12)
                      {
                        unsigned int v74 = *v64;
                        uint64_t result = v64 + 2;
                        unsigned int v72 = v64[2];
                        BOOL v73 = v74 >= v72;
                        if (v74 <= v72) {
                          unsigned int v74 = v64[2];
                        }
                        if (v73) {
                          uint64_t v63 = v71;
                        }
                        else {
                          v64 += 2;
                        }
                      }
                      else
                      {
                        unsigned int v74 = *v64;
                        uint64_t v63 = v71;
                      }
                    }
                    while (v74 >= v69);
                    *(_WORD *)int v68 = v69;
                  }
                }
                int64_t v61 = v62 - 1;
              }
              while (v62);
              uint64_t v75 = (unint64_t)v11 >> 1;
              do
              {
                uint64_t v76 = 0;
                __int16 v77 = *(_WORD *)v10;
                uint64_t v78 = v10;
                do
                {
                  uint64_t v79 = 2 * v76 + 2;
                  std::string::size_type v80 = &v78[v79];
                  uint64_t v81 = (2 * v76) | 1;
                  if (v79 < v75 && *v80 < v80[2])
                  {
                    v80 += 2;
                    uint64_t v81 = 2 * v76 + 2;
                  }
                  *(_WORD *)uint64_t v78 = *(_WORD *)v80;
                  uint64_t v78 = v80;
                  uint64_t v76 = v81;
                }
                while (v81 <= (uint64_t)((unint64_t)(v75 - 2) >> 1));
                a2 -= 2;
                if (v80 == a2)
                {
                  *(_WORD *)std::string::size_type v80 = v77;
                }
                else
                {
                  *(_WORD *)std::string::size_type v80 = *(_WORD *)a2;
                  *(_WORD *)a2 = v77;
                  uint64_t v82 = v80 - v10 + 2;
                  if (v82 >= 3)
                  {
                    unint64_t v83 = (((unint64_t)v82 >> 1) - 2) >> 1;
                    uint64_t v84 = &v10[2 * v83];
                    if (*v84 < *v80)
                    {
                      __int16 v85 = *(_WORD *)v80;
                      do
                      {
                        int v86 = v80;
                        std::string::size_type v80 = v84;
                        *(_WORD *)int v86 = *(_WORD *)v84;
                        if (!v83) {
                          break;
                        }
                        unint64_t v83 = (v83 - 1) >> 1;
                        uint64_t v84 = &v10[2 * v83];
                      }
                      while (*v84 < v85);
                      *(_WORD *)std::string::size_type v80 = v85;
                    }
                  }
                }
              }
              while (v75-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          int v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x101)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v9, &v9[2 * (v12 >> 1)], (_WORD *)a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v9 + 2, v14 - 2, (_WORD *)a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v9 + 4, &v9[2 * v13 + 2], (_WORD *)a2 - 3);
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v14 - 2, v14, &v9[2 * v13 + 2]);
            __int16 v15 = *(_WORD *)v9;
            *(_WORD *)uint64_t v9 = *(_WORD *)v14;
            *(_WORD *)int v14 = v15;
          }
          else
          {
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(&v9[2 * (v12 >> 1)], v9, (_WORD *)a2 - 1);
          }
          --a3;
          if ((a4 & 1) != 0 || *(v9 - 2) < *v9) {
            break;
          }
          __int16 v31 = *(_WORD *)v9;
          unsigned int v32 = *(_WORD *)v9;
          if (*(a2 - 2) <= v32)
          {
            unsigned int v34 = v9 + 2;
            do
            {
              uint64_t v10 = v34;
              if (v34 >= a2) {
                break;
              }
              v34 += 2;
            }
            while (*v10 <= v32);
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              unsigned int v33 = v10[2];
              v10 += 2;
            }
            while (v33 <= v32);
          }
          unsigned __int8 v35 = a2;
          if (v10 < a2)
          {
            unsigned __int8 v35 = a2;
            do
            {
              unsigned int v36 = *(v35 - 2);
              v35 -= 2;
            }
            while (v36 > v32);
          }
          while (v10 < v35)
          {
            __int16 v37 = *(_WORD *)v10;
            *(_WORD *)uint64_t v10 = *(_WORD *)v35;
            *(_WORD *)unsigned __int8 v35 = v37;
            do
            {
              unsigned int v38 = v10[2];
              v10 += 2;
            }
            while (v38 <= v32);
            do
            {
              unsigned int v39 = *(v35 - 2);
              v35 -= 2;
            }
            while (v39 > v32);
          }
          __int16 v40 = v10 - 2;
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9) {
            *(_WORD *)uint64_t v9 = *(_WORD *)v40;
          }
          a4 = 0;
          *(_WORD *)__int16 v40 = v31;
        }
        uint64_t v16 = 0;
        __int16 v17 = *(_WORD *)v9;
        unsigned int v18 = *(_WORD *)v9;
        do
        {
          unsigned int v19 = v9[v16 + 2];
          v16 += 2;
        }
        while (v19 < v18);
        int v20 = &v9[v16];
        uint64_t v21 = a2;
        if (v16 == 2)
        {
          uint64_t v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            unsigned int v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (v23 >= v18);
        }
        else
        {
          do
          {
            unsigned int v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (v22 >= v18);
        }
        if (v20 >= v21)
        {
          unint64_t v29 = v20 - 2;
        }
        else
        {
          long long v24 = &v9[v16];
          uint64_t v25 = v21;
          do
          {
            __int16 v26 = *(_WORD *)v24;
            *(_WORD *)long long v24 = *(_WORD *)v25;
            *(_WORD *)uint64_t v25 = v26;
            do
            {
              unsigned int v27 = v24[2];
              v24 += 2;
            }
            while (v27 < v18);
            do
            {
              unsigned int v28 = *(v25 - 2);
              v25 -= 2;
            }
            while (v28 >= v18);
          }
          while (v24 < v25);
          unint64_t v29 = v24 - 2;
        }
        if (v29 != v9) {
          *(_WORD *)uint64_t v9 = *(_WORD *)v29;
        }
        *(_WORD *)unint64_t v29 = v17;
        if (v20 >= v21) {
          break;
        }
LABEL_33:
        uint64_t result = (unsigned __int8 *)std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(v9, v29, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v29 + 2;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v9, v29);
      uint64_t v10 = v29 + 2;
      uint64_t result = (unsigned __int8 *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v29 + 2, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_33;
      }
    }
    a2 = v29;
    if (!v30) {
      continue;
    }
    return result;
  }
}

BOOL C3D::PassIODescriptor::isValid(C3D::PassIODescriptor *this)
{
  if (!*((_WORD *)this + 14)) {
    return 0;
  }
  if (*((unsigned __int16 *)this + 11) < 2u
    || (BOOL result = SCNMTLTextureTypeIsArray(*((unsigned __int8 *)this + 24)), result))
  {
    if (*((unsigned __int8 *)this + 31) >= 2u)
    {
      uint64_t v3 = *((unsigned __int8 *)this + 24);
      return SCNMTLTextureTypeIsMultisampled(v3);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void C3D::RenderGraph::resolvePartialCompatibility(C3D::RenderGraph *this)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    while (1)
    {
      uint64_t v3 = *(unsigned int *)(v2 + 8);
      if (v3) {
        break;
      }
LABEL_74:
      uint64_t v2 = *(void *)(v2 + 24);
      if (!v2) {
        goto LABEL_75;
      }
    }
    BOOL v4 = *(unsigned __int16 **)(v2 + 16);
    std::string::size_type v80 = &v4[v3];
    while (1)
    {
      uint64_t v5 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v4);
      uint64_t v6 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
      unsigned int v7 = C3D::PassDescriptor::inputCount(v6);
      uint64_t v8 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
      int v9 = C3D::PassDescriptor::outputCount(v8);
      uint64_t v10 = v7;
      if (v7)
      {
        uint64_t v11 = 0;
        do
        {
          if ((*(_WORD *)(C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v11) + 66) & 0x80) != 0)
          {
            uint64_t v12 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, v11);
            uint64_t v13 = v12;
            if (v2 == *((void *)this + 12) && (*(_WORD *)(v12 + 66) & 0x100) == 0)
            {
              int v14 = scn_default_log();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
                C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v95, v5);
              }
              __int16 v15 = scn_default_log();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::resolvePartialCompatibility(v93, &v94, v15);
              }
            }
            *(_WORD *)(v13 + 66) |= 0x80u;
          }
          ++v11;
        }
        while (v10 != v11);
      }
      if (v9) {
        break;
      }
LABEL_50:
      if (v10)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          uint64_t v37 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, i);
          if ((*(_WORD *)(v37 + 66) & 0x80) != 0)
          {
            unsigned int v38 = (__int16 *)(v37 + 16);
            unsigned int v39 = (__int16 *)(C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, i) + 16);
            C3D::PropagateMissingTextureParameters(v38, v39);
            C3D::PropagateMissingTextureParameters(v39, v38);
          }
        }
        unsigned __int8 v40 = 0;
        do
        {
          uint64_t v41 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v40);
          if ((*(_WORD *)(v41 + 66) & 4) != 0)
          {
            uint64_t v42 = (unsigned __int8 *)v41;
            uint64_t v43 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
            if (C3D::PassDescriptor::outputCount(v43) == 1)
            {
              __int16 v44 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
              __int16 v45 = (__int16 *)C3D::PassDescriptor::outputAtIndex(v44, 0);
            }
            else
            {
              if (!**((unsigned char **)v42 + 1))
              {
                __int16 v46 = scn_default_log();
                if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
                  C3D::RenderGraph::resolvePartialCompatibility(v88, &v89, v46);
                }
              }
              __int16 v45 = (__int16 *)C3D::Pass::outputBufferParameterNamed(*(C3D::Pass **)v5, *((const char **)v42 + 1));
              if (!v45) {
                C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v87, (uint64_t *)v42 + 1);
              }
            }
            if (*v42 != *(unsigned __int8 *)v45)
            {
              __int16 v47 = scn_default_log();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
                C3D::RenderGraph::resolvePartialCompatibility(v85, &v86, v47);
              }
            }
            C3D::PropagateMissingTextureParameters((__int16 *)v42 + 8, v45 + 8);
          }
          ++v40;
        }
        while (v10 > v40);
      }
      uint64_t v48 = *(unsigned int *)(v5 + 40);
      if (v48)
      {
        uint64_t v49 = *(unsigned int **)(v5 + 48);
        uint64_t v50 = 4 * v48;
        do
        {
          unsigned int v51 = *v49;
          uint64_t v52 = (C3D::PassIODescriptor *)C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, BYTE2(*v49));
          __int16 v53 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v51 & 0x7FFF);
          unsigned int v54 = (const PassIODescriptor *)C3D::Pass::inputBufferParameterAtIndex(*v53, HIBYTE(v51));
          if (!C3D::PassIODescriptor::isCompatible(v52, v54))
          {
            unsigned int v55 = (__int16 *)((char *)v52 + 16);
            __int16 v56 = (__int16 *)((char *)v54 + 16);
            C3D::PropagateMissingTextureParameters(v55, v56);
            C3D::PropagateMissingTextureParameters(v56, v55);
          }
          ++v49;
          v50 -= 4;
        }
        while (v50);
      }
      if (++v4 == v80) {
        goto LABEL_74;
      }
    }
    for (uint64_t j = 0; j != v9; ++j)
    {
      if ((*(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, j) + 66) & 0x80) != 0)
      {
        uint64_t v17 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, j);
        uint64_t v18 = v17;
        if (v2 == *((void *)this + 12) && (*(_WORD *)(v17 + 66) & 0x100) == 0)
        {
          unsigned int v19 = scn_default_log();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v92, v5);
          }
          int v20 = scn_default_log();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
            C3D::RenderGraph::resolvePartialCompatibility(v90, &v91, v20);
          }
        }
        *(_WORD *)(v18 + 66) |= 0x80u;
      }
    }
    int v21 = 0;
    while (1)
    {
      uint64_t v22 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, v21);
      uint64_t v23 = *(unsigned int *)(v5 + 40);
      if (v23)
      {
        uint64_t v24 = *(void *)(v5 + 48);
        uint64_t v25 = 4 * v23 - 4;
        do
        {
          int v26 = *(unsigned __int8 *)(v24 + 2);
          BOOL v27 = v26 == v21;
          BOOL v28 = v26 == v21 || v25 == 0;
          v25 -= 4;
          v24 += 4;
        }
        while (!v28);
        BOOL v30 = (_WORD *)(v22 + 66);
        __int16 v29 = *(_WORD *)(v22 + 66);
        if ((v29 & 8) == 0) {
          goto LABEL_39;
        }
        if (v26 == v21)
        {
          __int16 v31 = v29 & 0xFFF7;
          goto LABEL_48;
        }
      }
      else
      {
        BOOL v30 = (_WORD *)(v22 + 66);
        __int16 v29 = *(_WORD *)(v22 + 66);
        if ((v29 & 8) == 0)
        {
          BOOL v27 = 0;
LABEL_39:
          if (v27 || (v29 & 0x80) == 0) {
            goto LABEL_49;
          }
          __int16 v31 = v29 | 8;
LABEL_48:
          *BOOL v30 = v31;
          goto LABEL_49;
        }
      }
      if ((v29 & 0x80) != 0)
      {
        uint64_t v32 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v21);
        uint64_t v33 = *(unsigned int *)(v5 + 16);
        if (v33)
        {
          uint64_t v34 = *(void *)(v5 + 24);
          uint64_t v35 = 4 * v33;
          while (*(unsigned __int8 *)(v34 + 2) != v21)
          {
            v34 += 4;
            v35 -= 4;
            if (!v35) {
              goto LABEL_47;
            }
          }
          goto LABEL_49;
        }
LABEL_47:
        *(_WORD *)(v32 + 66) &= ~0x80u;
        __int16 v31 = *v30 & 0xFF7C | 2;
        goto LABEL_48;
      }
LABEL_49:
      if (++v21 == v9) {
        goto LABEL_50;
      }
    }
  }
LABEL_75:
  for (uint64_t k = *((void *)this + 13); k; uint64_t k = *(void *)(k + 32))
  {
    uint64_t v58 = *(unsigned int *)(k + 8);
    if (v58)
    {
      int v59 = *(unsigned __int16 **)(k + 16);
      int64_t v60 = &v59[v58];
      do
      {
        uint64_t v61 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v59);
        int64_t v62 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
        unsigned __int8 v63 = C3D::PassDescriptor::inputCount(v62);
        if (v63)
        {
          unsigned __int8 v64 = v63;
          unsigned __int8 v65 = 0;
          do
          {
            uint64_t v66 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v61, v65);
            if ((*(_WORD *)(v66 + 66) & 4) != 0)
            {
              unsigned int v67 = (unsigned __int8 *)v66;
              int v68 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
              if (C3D::PassDescriptor::outputCount(v68) == 1)
              {
                __int16 v69 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
                int v70 = (__int16 *)C3D::PassDescriptor::outputAtIndex(v69, 0);
              }
              else
              {
                if (!**((unsigned char **)v67 + 1))
                {
                  uint64_t v71 = scn_default_log();
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
                    C3D::RenderGraph::resolvePartialCompatibility(v83, &v84, v71);
                  }
                }
                int v70 = (__int16 *)C3D::Pass::outputBufferParameterNamed(*(C3D::Pass **)v61, *((const char **)v67 + 1));
                if (!v70) {
                  C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v87, (uint64_t *)v67 + 1);
                }
              }
              if (*v67 != *(unsigned __int8 *)v70)
              {
                unsigned int v72 = scn_default_log();
                if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
                  C3D::RenderGraph::resolvePartialCompatibility(v81, &v82, v72);
                }
              }
              C3D::PropagateMissingTextureParameters(v70 + 8, (__int16 *)v67 + 8);
            }
            ++v65;
          }
          while (v65 < v64);
        }
        uint64_t v73 = *(unsigned int *)(v61 + 16);
        if (v73)
        {
          unsigned int v74 = *(unsigned int **)(v61 + 24);
          uint64_t v75 = 4 * v73;
          do
          {
            unsigned int v76 = *v74;
            __int16 v77 = (__int16 *)C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v61, BYTE2(*v74));
            uint64_t v78 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v76 & 0x7FFF);
            uint64_t v79 = C3D::Pass::outputBufferParameterAtIndex(*v78, HIBYTE(v76));
            if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v77, (const PassIODescriptor *)v79)) {
              C3D::PropagateMissingTextureParameters(v77 + 8, (__int16 *)(v79 + 16));
            }
            ++v74;
            v75 -= 4;
          }
          while (v75);
        }
        ++v59;
      }
      while (v59 != v60);
    }
  }
}

uint64_t C3D::PassDescriptor::inputCount(C3D::PassDescriptor *this)
{
  return *((unsigned __int16 *)this + 20);
}

uint64_t C3D::Pass::inputBufferParameterAtIndex(C3D::Pass *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 36) <= a2)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::inputBufferParameterAtIndex(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)this + 32), a2);
}

uint64_t C3D::PassDescriptor::inputAtIndex(C3D::PassDescriptor *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 20) <= a2)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::PassDescriptor::inputAtIndex();
    }
  }
  return *((void *)this + 3) + 80 * a2;
}

uint64_t C3D::Pass::outputBufferParameterAtIndex(C3D::Pass *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 37) <= a2)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::outputBufferParameterAtIndex(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)this + 32), a2);
}

BOOL C3D::PassIODescriptor::isCompatible(C3D::PassIODescriptor *this, const PassIODescriptor *a2)
{
  if (*((unsigned __int16 *)this + 8) != *((unsigned __int16 *)a2 + 8)
    || *((unsigned __int16 *)this + 9) != *((unsigned __int16 *)a2 + 9)
    || *((unsigned __int16 *)this + 10) != *((unsigned __int16 *)a2 + 10)
    || *((unsigned __int16 *)this + 11) != *((unsigned __int16 *)a2 + 11))
  {
    return 0;
  }
  int v2 = *((unsigned __int8 *)this + 24);
  int v3 = *((unsigned __int8 *)a2 + 24);
  if (v2 == v3 || v2 == 4 && v3 == 2 || (uint64_t v4 = 0, v2 == 8) && v3 == 3)
  {
    if (*((unsigned __int8 *)this + 25) == *((unsigned __int8 *)a2 + 25)
      && *((unsigned __int8 *)this + 27) == *((unsigned __int8 *)a2 + 27)
      && *((unsigned __int16 *)this + 14) == *((unsigned __int16 *)a2 + 14))
    {
      return *((unsigned __int8 *)this + 30) == *((unsigned __int8 *)a2 + 30);
    }
    return 0;
  }
  return v4;
}

__int16 *C3D::PropagateMissingTextureParameters(__int16 *result, __int16 *a2)
{
  __int16 v2 = *a2;
  if (!*a2) {
    __int16 v2 = *result;
  }
  *a2 = v2;
  __int16 v3 = a2[1];
  if (!v3) {
    __int16 v3 = result[1];
  }
  a2[1] = v3;
  __int16 v4 = a2[2];
  if (!v4) {
    __int16 v4 = result[2];
  }
  a2[2] = v4;
  unsigned int v5 = (unsigned __int16)a2[3];
  if (v5 <= (unsigned __int16)result[3]) {
    LOWORD(v5) = result[3];
  }
  a2[3] = v5;
  char v6 = *((unsigned char *)a2 + 8);
  if (!v6) {
    char v6 = *((unsigned char *)result + 8);
  }
  *((unsigned char *)a2 + _Block_object_dispose(&STACK[0x380], 8) = v6;
  char v7 = *((unsigned char *)a2 + 9);
  if (!v7) {
    char v7 = *((unsigned char *)result + 9);
  }
  *((unsigned char *)a2 + 9) = v7;
  char v8 = *((unsigned char *)a2 + 10);
  if (!v8) {
    char v8 = *((unsigned char *)result + 10);
  }
  *((unsigned char *)a2 + 10) = v8;
  char v9 = *((unsigned char *)a2 + 11);
  if (!v9) {
    char v9 = *((unsigned char *)result + 11);
  }
  *((unsigned char *)a2 + 11) = v9;
  __int16 v10 = a2[6];
  if (!v10) {
    __int16 v10 = result[6];
  }
  a2[6] = v10;
  unsigned int v11 = *((unsigned __int8 *)a2 + 14);
  if (v11 <= *((unsigned __int8 *)result + 14)) {
    LOBYTE(v11) = *((unsigned char *)result + 14);
  }
  *((unsigned char *)a2 + 14) = v11;
  return result;
}

void C3D::RenderGraph::removeInvalidPasses(C3D::RenderGraph *this)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v37 = (_DWORD *)((char *)this + 32);
  C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::resize((uint64_t)this + 32, 0);
  *((_DWORD *)this + 11) = 0;
  *((void *)this + 6) = (char *)this + 56;
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 1));
  uint64_t v42 = StackAllocator;
  C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate((uint64_t)&v42, 32);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v40, StackAllocator);
  uint64_t v3 = *((void *)this + 3);
  int v4 = *(unsigned __int16 *)(v3 + 8);
  if (*(_WORD *)(v3 + 8))
  {
    unsigned int v5 = 0;
    do
    {
      *(void *)float32x4_t buf = 0;
      *(void *)float32x4_t buf = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v5);
      if (*(_DWORD *)C3D::Pass::descriptor(**(C3D::Pass ***)buf) == 5) {
        C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v40, buf);
      }
      ++v5;
    }
    while (v4 != v5);
  }
  if (!v41) {
    goto LABEL_34;
  }
  do
  {
    uint64_t v6 = *(void *)C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::back((uint64_t)&v40);
    C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back((uint64_t)&v40);
    *(void *)float32x4_t buf = *(void *)v6;
    C3D::Hash<C3D::Pass *,C3D::StackAllocator>::insert((uint64_t)&v42, *(uint64_t *)buf, buf);
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v39, *((void **)this + 2), *(_DWORD *)(v6 + 16));
    uint64_t v7 = *(unsigned int *)(v6 + 16);
    if (!v7) {
      continue;
    }
    char v8 = 0;
    char v9 = *(unsigned int **)(v6 + 24);
    __int16 v10 = (int *)&v9[v7];
    do
    {
      unsigned int v38 = 0;
      unsigned int v11 = (void *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v9 & 0x7FFF);
      unsigned int v38 = (uint64_t (****)(void))v11;
      int v12 = *v9 & 0xFF0000;
      if (HIBYTE(*v9) == 255 || v12 == 16711680)
      {
        BOOL v16 = HIBYTE(*v9) == 255;
        uint64_t v17 = scn_default_log();
        BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
        if (v16)
        {
          if (v12 == 16711680)
          {
            if (v18)
            {
              uint64_t v19 = (***(uint64_t (****)(void))v6)();
              uint64_t v20 = (***v38)();
              uint64_t v21 = (***v38)();
              *(_DWORD *)float32x4_t buf = 136315650;
              *(void *)&uint8_t buf[4] = v19;
              __int16 v48 = 2080;
              *(void *)uint64_t v49 = v20;
              *(_WORD *)&v49[8] = 2080;
              *(void *)&v49[10] = v21;
              _os_log_error_impl(&dword_20B249000, v17, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency with pass %s. Pass %s will be ignored", buf, 0x20u);
            }
            goto LABEL_26;
          }
          if (v18)
          {
            uint64_t v28 = (***(uint64_t (****)(void))v6)();
            int v29 = *((unsigned __int8 *)v9 + 2);
            uint64_t v30 = (***v38)();
            uint64_t v31 = (***v38)();
            *(_DWORD *)float32x4_t buf = 136315906;
            *(void *)&uint8_t buf[4] = v28;
            __int16 v48 = 1024;
            *(_DWORD *)uint64_t v49 = v29;
            *(_WORD *)&v49[4] = 2080;
            *(void *)&v49[6] = v30;
            *(_WORD *)&v49[14] = 2080;
            *(void *)&v49[16] = v31;
            _os_log_error_impl(&dword_20B249000, v17, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency from output port %d of pass %s. Pass %s will be ignored", buf, 0x26u);
          }
        }
        else if (v18)
        {
          uint64_t v24 = (***(uint64_t (****)(void))v6)();
          int v25 = *((unsigned __int8 *)v9 + 3);
          uint64_t v26 = (***v38)();
          uint64_t v27 = (***v38)();
          *(_DWORD *)float32x4_t buf = 136315906;
          *(void *)&uint8_t buf[4] = v24;
          __int16 v48 = 1024;
          *(_DWORD *)uint64_t v49 = v25;
          *(_WORD *)&v49[4] = 2080;
          *(void *)&v49[6] = v26;
          *(_WORD *)&v49[14] = 2080;
          *(void *)&v49[16] = v27;
          _os_log_error_impl(&dword_20B249000, v17, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency on input port %d with pass %s. Pass %s will be ignored", buf, 0x26u);
        }
        unsigned int v22 = *v9;
        uint64_t v23 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v9 & 0x7FFF);
        C3D::RenderGraph::logDependencyInputMismatch((uint64_t)this, v6, v23, BYTE2(v22), HIBYTE(v22));
LABEL_26:
        char v8 = 1;
        goto LABEL_27;
      }
      unsigned int v13 = (v46 - 1) & *v11;
      unsigned int v14 = *(unsigned __int16 *)(v45 + 2 * v13);
      if (v14 < 2) {
        goto LABEL_15;
      }
      while ((v14 & 2) == 0 || *(void *)(v43 + 8 * v13) != *v11)
      {
        ++v13;
        BOOL v15 = v14 >= 4;
        v14 >>= 1;
        if (!v15) {
          goto LABEL_15;
        }
      }
      if (!v44)
      {
LABEL_15:
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(v39, v9);
        C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v40, &v38);
      }
LABEL_27:
      ++v9;
    }
    while (v9 != (unsigned int *)v10);
    if (v8) {
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v6 + 8, (uint64_t)v39);
    }
  }
  while (v41);
LABEL_34:
  if (v4)
  {
    for (unsigned int i = 0; i != v4; ++i)
    {
      uint64_t v33 = (void *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), i);
      unsigned int v34 = (v46 - 1) & *v33;
      unsigned int v35 = *(unsigned __int16 *)(v45 + 2 * v34);
      if (v35 < 2) {
        goto LABEL_40;
      }
      while ((v35 & 2) == 0 || *(void *)(v43 + 8 * v34) != *v33)
      {
        ++v34;
        BOOL v15 = v35 >= 4;
        v35 >>= 1;
        if (!v15) {
          goto LABEL_40;
        }
      }
      if (!v44)
      {
LABEL_40:
        unsigned int v36 = scn_default_log();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          C3D::RenderGraph::removeInvalidPasses((uint64_t)buf, (uint64_t)v33);
        }
        C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::push_back<C3D::Pass *&>(v37, v33);
      }
    }
  }
}

C3D::ScratchAllocator *C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array(C3D::ScratchAllocator *a1, void *a2, int a3)
{
  uint64_t v6 = C3D::ScratchAllocator::ScratchAllocator(a1, a2);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = (char *)v6 + 24;
  if (!a2)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  BOOL v15 = (const void *)*((void *)a1 + 2);
  int v16 = *((_DWORD *)a1 + 3) + a3;
  uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)a1, (4 * v16), 4, 0);
  memcpy(Aligned, v15, 4 * *((unsigned int *)a1 + 2));
  *((void *)a1 + 2) = Aligned;
  *((_DWORD *)a1 + 3) = v16;
  return a1;
}

void C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(void *a1, int a2)
{
  if ((a2 & (a2 - 1)) != 0) {
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  }
  *((_DWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = 0;
  *((_DWORD *)a1 + 9) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  a1[3] = C3DScratchAllocatorAllocateAligned(*a1, (2 * (a2 + 15)), 4, 0);
  size_t v5 = 8 * v3;
  a1[1] = C3DScratchAllocatorAllocateAligned(*a1, v5 & 0xFFFFFFF8, 8, 0);
  a1[2] = C3DScratchAllocatorAllocateAligned(*a1, v5 & 0xFFFFFFF8, 8, 0);
  memset((void *)a1[1], 255, v5);
  uint64_t v6 = (void *)a1[3];

  bzero(v6, v4);
}

uint64_t C3DScratchAllocator::Allocate(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 1;
  uint64_t v5 = -a3;
  uint64_t v6 = a1;
  while (1)
  {
    uint64_t v7 = v6[1];
    uint64_t v8 = v6[2];
    uint64_t v9 = *v6 + v8;
    unint64_t v10 = ((v4 + v9) & v5) - v9 + a2;
    if (v10 <= v7 - v8) {
      break;
    }
    v3 += v7;
    uint64_t v6 = (void *)v6[3];
    if (!v6)
    {
      if (a1[4]) {
        operator new();
      }
      C3DScratchAllocator::Allocate();
    }
  }
  v6[2] = v10 + v8;
  return (v4 + v9) & v5;
}

_DWORD *C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(_DWORD *result, void *a2)
{
  uint64_t v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  unsigned int v6 = v4 + 1;
  uint64_t v7 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v8 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = C3DStackAllocatorAllocateAligned(*(void *)result, 8 * v8, 8, 0);
    BOOL result = memcpy(Aligned, v7, 8 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v8;
    unsigned int v4 = v3[2];
    unsigned int v6 = v4 + 1;
    uint64_t v7 = Aligned;
  }
  *((void *)v7 + v4) = *a2;
  void v3[2] = v6;
  return result;
}

void C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    __int16 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  --*(_DWORD *)(a1 + 8);
}

uint64_t C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::back(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    __int16 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 8) - 8;
}

uint64_t C3D::Hash<C3D::Pass *,C3D::StackAllocator>::insert(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      uint64_t v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          *(void *)(v26 + 8 * v15) = *(void *)(v26 + 8 * v21);
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      *(void *)(*(void *)(a1 + 16) + 8 * v21) = *a3;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v28 = *(void *)(a1 + 24);
      *(_WORD *)(v28 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v28 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 8 * v10) = *a3;
  return result;
}

void C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      uint64_t v5 = *(char **)(a1 + 16);
      if (*(_DWORD *)(a1 + 12) < a2)
      {
        unsigned int v6 = ((double)a2 * 1.5);
        uint64_t Aligned = (char *)C3DScratchAllocatorAllocateAligned(*(void *)a1, 8 * v6, 8, 0);
        memcpy(Aligned, v5, 8 * *(unsigned int *)(a1 + 8));
        *(void *)(a1 + 16) = Aligned;
        *(_DWORD *)(a1 + 12) = v6;
        uint64_t v5 = Aligned;
        unsigned int v2 = *(_DWORD *)(a1 + 8);
      }
      bzero(&v5[8 * v2], 8 * (a2 - v2));
    }
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x380], 8) = a2;
  }
}

void C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate(uint64_t a1, int a2)
{
  if ((a2 & (a2 - 1)) != 0) {
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  *(void *)(a1 + 24) = C3DStackAllocatorAllocateAligned(*(void *)a1, (2 * (a2 + 15)), 4, 0);
  size_t v5 = 8 * v3;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x380], 8) = C3DStackAllocatorAllocateAligned(*(void *)a1, v5 & 0xFFFFFFF8, 8, 0);
  *(void *)(a1 + 16) = C3DStackAllocatorAllocateAligned(*(void *)a1, v5 & 0xFFFFFFF8, 8, 0);
  memset(*(void **)(a1 + 8), 255, v5);
  unsigned int v6 = *(void **)(a1 + 24);

  bzero(v6, v4);
}

void *C3DStackAllocatorAllocateAligned(uint64_t a1, size_t a2, uint64_t a3, int a4)
{
  if (!*(_DWORD *)(a1 + 576))
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DStackAllocatorAllocateAligned_cold_2(v8);
    }
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v10 = *(unsigned int *)(v9 + 12);
    uint64_t v11 = *(void *)v9 + v10;
    unsigned int v12 = (void *)((a3 - 1 + v11) & -a3);
    if ((unint64_t)v12 + a2 - v11 <= (*(_DWORD *)(v9 + 8) - v10)) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 16);
    if (!v9)
    {
      if (*(void *)(a1 + 16)) {
        operator new();
      }
      C3DStackAllocatorAllocateAligned_cold_1();
    }
  }
  *(_DWORD *)(v9 + 12) = a2 + v12 - *(_DWORD *)v9;
  if (a4 == 2)
  {
    memset(v12, 255, a2);
  }
  else if (a4 == 1)
  {
    bzero(v12, a2);
  }
  return v12;
}

BOOL C3D::RenderGraph::sort(C3D::RenderGraph *this)
{
  uint64_t Aligned = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*((void *)this + 2), 40, 8, 0);
  unsigned int v3 = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(Aligned, *((void **)this + 2));
  *((void *)v3 + 3) = 0;
  *((void *)v3 + 4) = 0;
  *((void *)this + 12) = v3;
  if (*(_DWORD *)(*((void *)this + 3) + 8) >= 0x7FFFu) {
    C3D::RenderGraph::sort();
  }
  C3D::RenderGraph::clearAllDirtyBits((uint64_t)this, 1);
  unsigned int v4 = *(unsigned __int16 *)(*((void *)this + 3) + 8);
  LOWORD(v64[0]) = 0;
  if (v4)
  {
    unsigned int v5 = 0;
    do
    {
      uint64_t v6 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v5);
      if (!*(_DWORD *)(v6 + 16))
      {
        uint64_t v7 = *((void *)this + 6);
        uint64_t v8 = *((unsigned int *)this + 10);
        if (v8)
        {
          uint64_t v9 = 8 * v8;
          uint64_t v10 = (void *)*((void *)this + 6);
          while (*v10 != *(void *)v6)
          {
            ++v10;
            v9 -= 8;
            if (!v9)
            {
              uint64_t v10 = (void *)(v7 + 8 * v8);
              break;
            }
          }
        }
        else
        {
          uint64_t v10 = (void *)*((void *)this + 6);
        }
        if (v8 == ((uint64_t)v10 - v7) >> 3) {
          C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>(*((_DWORD **)this + 12), v64);
        }
      }
      ++LOWORD(v64[0]);
      unsigned int v5 = LOWORD(v64[0]);
    }
    while (v4 > LOWORD(v64[0]));
  }
  uint64_t v11 = *((void *)this + 12);
  if (!*(_DWORD *)(v11 + 8))
  {
    unsigned int v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3D::RenderGraph::sort(v12, v13, v14, v15, v16, v17, v18, v19);
    }
    uint64_t v11 = *((void *)this + 12);
    if (!v11)
    {
      *((void *)this + 13) = 0;
      return 1;
    }
  }
  uint64_t v20 = v11;
  do
  {
    uint64_t v21 = v20;
    if (v11 != v20)
    {
      *(void *)(v11 + 24) = v20;
      *(void *)(v20 + 32) = v11;
    }
    uint64_t v22 = *(unsigned int *)(v20 + 8);
    if (!v22) {
      break;
    }
    uint64_t v20 = 0;
    char v23 = *(unsigned __int16 **)(v21 + 16);
    unsigned int v24 = &v23[v22];
    do
    {
      unsigned int v25 = *v23;
      uint64_t v26 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v25);
      uint64_t v27 = *(unsigned int *)(v26 + 40);
      if (v27)
      {
        uint64_t v28 = *(_DWORD **)(v26 + 48);
        int v29 = &v28[v27];
        do
        {
          uint64_t v30 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v28 & 0x7FFF);
          uint64_t v31 = *(unsigned int *)(v30 + 16);
          if (v31)
          {
            int v32 = 0;
            uint64_t v33 = *(_DWORD **)(v30 + 24);
            uint64_t v34 = 4 * v31;
            do
            {
              if ((*v33 & 0x8000) != 0)
              {
                ++v32;
              }
              else if ((*v33 & 0x7FFF) == v25)
              {
                ++v32;
                *v33 |= 0x8000u;
              }
              ++v33;
              v34 -= 4;
            }
            while (v34);
          }
          else
          {
            int v32 = 0;
          }
          uint64_t v35 = *((void *)this + 6);
          uint64_t v36 = *((unsigned int *)this + 10);
          if (v36)
          {
            uint64_t v37 = 8 * v36;
            unsigned int v38 = (void *)*((void *)this + 6);
            while (*v38 != *(void *)v30)
            {
              ++v38;
              v37 -= 8;
              if (!v37)
              {
                unsigned int v38 = (void *)(v35 + 8 * v36);
                break;
              }
            }
          }
          else
          {
            unsigned int v38 = (void *)*((void *)this + 6);
          }
          if (v36 == ((uint64_t)v38 - v35) >> 3 && v32 == v31)
          {
            if (!v20)
            {
              uint64_t v20 = C3DScratchAllocatorAllocateAligned(*((void *)this + 2), 40, 8, 0);
              unsigned int v39 = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v20, *((void **)this + 2));
              *((void *)v39 + 3) = 0;
              *((void *)v39 + 4) = 0;
            }
            int v40 = *v28 & 0x7FFF;
            LOWORD(v64[0]) = *v28 & 0x7FFF;
            uint64_t v41 = *(void *)(v20 + 16);
            uint64_t v42 = *(unsigned int *)(v20 + 8);
            if (v42)
            {
              uint64_t v43 = 2 * v42;
              uint64_t v44 = *(unsigned __int16 **)(v20 + 16);
              while (*v44 != v40)
              {
                ++v44;
                v43 -= 2;
                if (!v43)
                {
                  uint64_t v44 = (unsigned __int16 *)(v41 + 2 * v42);
                  break;
                }
              }
            }
            else
            {
              uint64_t v44 = *(unsigned __int16 **)(v20 + 16);
            }
            if (v42 == ((uint64_t)v44 - v41) >> 1) {
              C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>((_DWORD *)v20, v64);
            }
          }
          ++v28;
        }
        while (v28 != v29);
      }
      ++v23;
    }
    while (v23 != v24);
    uint64_t v11 = v21;
  }
  while (v20);
  uint64_t v45 = *((void *)this + 12);
  *((void *)this + 13) = v21;
  if (!v45) {
    return 1;
  }
  while (1)
  {
    uint64_t v46 = *(unsigned int *)(v45 + 8);
    if (v46) {
      break;
    }
LABEL_74:
    uint64_t v45 = *(void *)(v45 + 24);
    BOOL result = 1;
    if (!v45) {
      return result;
    }
  }
  __int16 v47 = *(unsigned __int16 **)(v45 + 16);
  __int16 v48 = &v47[v46];
  while (1)
  {
    uint64_t v49 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v47);
    uint64_t v50 = v49;
    uint64_t v51 = *(unsigned int *)(v49 + 16);
    if (v51) {
      break;
    }
LABEL_62:
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v64, *((void **)this + 2), *(_DWORD *)(v49 + 40));
    uint64_t v54 = *(unsigned int *)(v50 + 40);
    if (v54)
    {
      unsigned int v55 = *(_DWORD **)(v50 + 48);
      __int16 v56 = &v55[v54];
      do
      {
        uint64_t v57 = (void *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v55 & 0x7FFF);
        uint64_t v58 = *((void *)this + 6);
        uint64_t v59 = *((unsigned int *)this + 10);
        if (v59)
        {
          uint64_t v60 = 8 * v59;
          uint64_t v61 = (void *)*((void *)this + 6);
          while (*v61 != *v57)
          {
            ++v61;
            v60 -= 8;
            if (!v60)
            {
              uint64_t v61 = (void *)(v58 + 8 * v59);
              break;
            }
          }
        }
        else
        {
          uint64_t v61 = (void *)*((void *)this + 6);
        }
        if (v59 == ((uint64_t)v61 - v58) >> 3) {
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(v64, v55);
        }
        ++v55;
      }
      while (v55 != v56);
    }
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v50 + 32, (uint64_t)v64);
    if (++v47 == v48) {
      goto LABEL_74;
    }
  }
  uint64_t v52 = *(_DWORD **)(v49 + 24);
  uint64_t v53 = 4 * v51;
  while ((*v52 & 0x8000) != 0)
  {
    ++v52;
    v53 -= 4;
    if (!v53) {
      goto LABEL_62;
    }
  }
  C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v52 & 0x7FFF);
  if (C3D::RenderGraph::sort(void)::done) {
    return 0;
  }
  C3D::RenderGraph::sort(void)::done = 1;
  unsigned __int8 v63 = scn_default_log();
  BOOL result = os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3D::RenderGraph::sort();
    return 0;
  }
  return result;
}

uint64_t C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    unsigned int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 8);
      int v7 = 136315906;
      uint64_t v8 = "i < size()";
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v6;
      _os_log_fault_impl(&dword_20B249000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(void *)(a1 + 16) + 56 * a2;
}

_DWORD *C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>(_DWORD *result, _WORD *a2)
{
  unsigned int v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  unsigned int v6 = v4 + 1;
  int v7 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v8 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)result, 2 * v8, 2, 0);
    BOOL result = memcpy(Aligned, v7, 2 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v8;
    unsigned int v4 = v3[2];
    unsigned int v6 = v4 + 1;
    int v7 = Aligned;
  }
  *((_WORD *)v7 + v4) = *a2;
  void v3[2] = v6;
  return result;
}

uint64_t C3D::RenderGraph::addPass(C3D::RenderGraph *this, C3D::Pass *a2)
{
  if (!a2)
  {
    unsigned int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::RenderGraph::addPass(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *((void *)this + 3);
  uint64_t v13 = *(unsigned int *)(v12 + 8);
  *((_DWORD *)a2 + 26) = v13;
  *((void *)a2 + 3) = this;
  int v14 = (void *)*((void *)this + 2);
  uint64_t v16 = a2;
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)&v17, v14);
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)&v18, v14);
  C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::GraphNode>(v12, &v16);
  if (v13 >= 0x7FFF) {
    C3D::RenderGraph::addPass();
  }
  return v13;
}

C3D::ScratchAllocator *C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(C3D::ScratchAllocator *a1, void *a2)
{
  unsigned int v4 = C3D::ScratchAllocator::ScratchAllocator(a1, a2);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = (char *)v4 + 24;
  if (!a2)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  return a1;
}

C3D::ScratchAllocator *C3D::ScratchAllocator::ScratchAllocator(C3D::ScratchAllocator *this, void *a2)
{
  *(void *)this = a2;
  if (!a2)
  {
    unsigned int v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3D::ScratchAllocator::ScratchAllocator(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return this;
}

void *C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::GraphNode>(uint64_t a1, void *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 + 1 > *(_DWORD *)(a1 + 12))
  {
    C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::GrowCapacityBy(a1, 1, 0);
    unsigned int v4 = *(_DWORD *)(a1 + 8);
  }
  BOOL result = C3D::RenderGraph::GraphNode::GraphNode((void *)(*(void *)(a1 + 16) + 56 * v4), a2);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void *C3D::RenderGraph::GraphNode::GraphNode(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[3] = a1 + 4;
  C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  a1[4] = a2[4];
  a1[6] = a1 + 7;
  C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=((uint64_t)(a1 + 4), (uint64_t)(a2 + 4));
  return a1;
}

uint64_t C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    if (!*(void *)a1)
    {
      unsigned int v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    int v12 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x380], 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = v12;
    if (*(void *)(a1 + 16) != a1 + 24) {
      *(void *)(a1 + 16) = a1 + 24;
    }
    uint64_t v13 = *(const void **)(a2 + 16);
    if (v13 == (const void *)(a2 + 24))
    {
      if (v12)
      {
        int v14 = scn_default_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v14, v15, v16, v17, v18, v19, v20, v21);
        }
      }
      if (*(_DWORD *)(a2 + 12))
      {
        uint64_t v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v22, v23, v24, v25, v26, v27, v28, v29);
        }
      }
      memcpy((void *)(a1 + 24), v13, 4 * *(unsigned int *)(a2 + 8));
    }
    else
    {
      *(void *)(a1 + 16) = v13;
    }
    *(void *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = 0;
    *(void *)(a2 + 16) = a2 + 24;
  }
  return a1;
}

void *C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::GrowCapacityBy(uint64_t a1, int a2, int a3)
{
  double v4 = 1.5;
  if (a3) {
    double v4 = 1.0;
  }
  unsigned int v5 = (v4 * (double)(*(_DWORD *)(a1 + 12) + a2));
  BOOL result = (void *)C3DScratchAllocatorAllocateAligned(*(void *)a1, 56 * v5, 8, 0);
  uint64_t v7 = result;
  if (*(_DWORD *)(a1 + 8))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      BOOL result = C3D::RenderGraph::GraphNode::GraphNode(&v7[v8], (void *)(*(void *)(a1 + 16) + v8 * 8));
      ++v9;
      v8 += 7;
    }
    while (v9 < *(unsigned int *)(a1 + 8));
  }
  *(void *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 12) = v5;
  return result;
}

uint64_t C3D::RenderGraph::clearAllDirtyBits(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 24);
  unsigned int v3 = *(_DWORD *)(v2 + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)(v2 + 16);
    uint64_t v5 = v4 + 56 * v3;
    do
    {
      unsigned int v6 = 1;
      do
      {
        if ((v6 & a2) != 0)
        {
          if (v6 == 1) {
            uint64_t v7 = v4 + 8;
          }
          else {
            uint64_t v7 = v4 + 32;
          }
          uint64_t v8 = *(unsigned int *)(v7 + 8);
          if (v8)
          {
            unint64_t v9 = *(_DWORD **)(v7 + 16);
            uint64_t v10 = 4 * v8;
            do
            {
              *v9++ &= ~0x8000u;
              v10 -= 4;
            }
            while (v10);
          }
        }
      }
      while (v6++ < 2);
      v4 += 56;
    }
    while (v4 != v5);
  }
  return result;
}

C3D::RenderPass *C3D::RenderPass::RenderPass(C3D::RenderPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  C3D::Pass::Pass(this, a2, a3);
  *(void *)uint64_t v4 = &unk_26BF6C9F0;
  *(_WORD *)(v4 + 112) = 256;
  *(_DWORD *)(v4 + 224) = 0;
  *(void *)(v4 + 114) = 0;
  *(_DWORD *)(v4 + 32) = 2;
  memset_pattern16((void *)(v4 + 128), &unk_20B5EFD80, 0x60uLL);
  return this;
}

double C3D::Pass::Pass(C3D::Pass *this, RenderGraph *a2, C3D::Pass *a3)
{
  *(void *)this = &unk_26BF6E700;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = *((void *)a2 + 1);
  *((void *)this + 3) = a2;
  *(void *)&double result = 0x1000000010000;
  *(void *)((char *)this + 36) = 0x1000000010000;
  *((_DWORD *)this + 11) = 1;
  *((unsigned char *)this + 4_Block_object_dispose(&STACK[0x380], 8) = 1;
  *((_DWORD *)this + 1_Block_object_dispose(&STACK[0x380], 8) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 26) = -1;
  return result;
}

uint64_t C3D::RenderGraph::isMainPass(C3D::RenderGraph *this, uint64_t a2)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 64))(result) == a2;
  }
  return result;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)this + 3);
  unsigned int v7 = *(_DWORD *)(v6 + 8);
  if (v7 <= a2) {
    C3D::RenderGraph::addDependency();
  }
  if (v7 <= a3) {
    C3D::RenderGraph::addDependency();
  }
  __int16 v11 = a2;
  uint64_t v12 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v6, a2);
  uint64_t v13 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), a3);
  if (a4 != 255)
  {
    int v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v12);
    if (C3D::PassDescriptor::inputCount(v14) <= a4) {
      C3D::RenderGraph::addDependency();
    }
  }
  if (a5 == 255) {
    goto LABEL_9;
  }
  uint64_t v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v13);
  if (C3D::PassDescriptor::outputCount(v15) <= a5) {
    C3D::RenderGraph::addDependency();
  }
  if (a4 == 255
    || (uint64_t v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v12),
        uint64_t v17 = (C3D::PassIODescriptor *)C3D::PassDescriptor::inputAtIndex(v16, a4),
        uint64_t v18 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v13),
        uint64_t v19 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v18, a5),
        C3D::PassIODescriptor::isPartiallyCompatible(v19, v17)))
  {
LABEL_9:
    *(_DWORD *)float32x4_t buf = a3 & 0x7FFF | (a4 << 16) | (a5 << 24);
    uint64_t v20 = *(void *)(v12 + 24);
    uint64_t v21 = *(unsigned int *)(v12 + 16);
    if (v21)
    {
      uint64_t v22 = 4 * v21;
      uint64_t v23 = *(_DWORD **)(v12 + 24);
      while ((*v23 & 0xFFFF7FFF) != (a3 & 0x7FFF | (a4 << 16) | (a5 << 24)))
      {
        ++v23;
        v22 -= 4;
        if (!v22)
        {
          uint64_t v23 = (_DWORD *)(v20 + 4 * v21);
          break;
        }
      }
    }
    else
    {
      uint64_t v23 = *(_DWORD **)(v12 + 24);
    }
    if (v21 == ((uint64_t)v23 - v20) >> 2) {
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>((_DWORD *)(v12 + 8), buf);
    }
    *(_DWORD *)float32x4_t buf = v11 & 0x7FFF | (a5 << 16) | (a4 << 24);
    uint64_t v24 = *(void *)(v13 + 48);
    uint64_t v25 = *(unsigned int *)(v13 + 40);
    if (v25)
    {
      uint64_t v26 = 4 * v25;
      uint64_t v27 = *(_DWORD **)(v13 + 48);
      while ((*v27 & 0xFFFF7FFF) != (v11 & 0x7FFF | (a5 << 16) | (a4 << 24)))
      {
        ++v27;
        v26 -= 4;
        if (!v26)
        {
          uint64_t v27 = (_DWORD *)(v24 + 4 * v25);
          break;
        }
      }
    }
    else
    {
      uint64_t v27 = *(_DWORD **)(v13 + 48);
    }
    if (v25 == ((uint64_t)v27 - v24) >> 2) {
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>((_DWORD *)(v13 + 32), buf);
    }
  }
  else
  {
    uint64_t v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      C3D::RenderGraph::addDependency(v13, (void (****)(void))v12);
    }
    uint64_t v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      C3D::RenderGraph::addDependency(a4, a5, v29);
    }
    uint64_t v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v32 = (***(uint64_t (****)(void))v13)();
      C3D::PassIODescriptor::description(v19, &__p);
      uint64_t v33 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)float32x4_t buf = 136315650;
      uint64_t v38 = v32;
      __int16 v39 = 1024;
      int v40 = a5;
      __int16 v41 = 2080;
      uint64_t v42 = v33;
      _os_log_error_impl(&dword_20B249000, v30, OS_LOG_TYPE_ERROR, "Error: Output descriptor of pass %s at port %d: %s", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = (***(uint64_t (****)(void))v12)();
      C3D::PassIODescriptor::description(v17, &__p);
      uint64_t v35 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)float32x4_t buf = 136315650;
      uint64_t v38 = v34;
      __int16 v39 = 1024;
      int v40 = a4;
      __int16 v41 = 2080;
      uint64_t v42 = v35;
      _os_log_error_impl(&dword_20B249000, v31, OS_LOG_TYPE_ERROR, "Error: Input descriptor of pass %s at port %d: %s", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
}

_DWORD *C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(_DWORD *result, _DWORD *a2)
{
  unsigned int v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  uint64_t v6 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)result, 4 * v7, 4, 0);
    uint64_t result = memcpy(Aligned, v6, 4 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v7;
    uint64_t v6 = Aligned;
    unsigned int v4 = v3[2];
  }
  *((_DWORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

BOOL C3D::PassIODescriptor::isPartiallyCompatible(C3D::PassIODescriptor *this, const C3D::PassIODescriptor *a2)
{
  if (*((_WORD *)this + 8))
  {
    if (*((_WORD *)a2 + 8) && *((unsigned __int16 *)this + 8) != *((unsigned __int16 *)a2 + 8)) {
      return 0;
    }
  }
  if (*((_WORD *)this + 9))
  {
    if (*((_WORD *)a2 + 9) && *((unsigned __int16 *)this + 9) != *((unsigned __int16 *)a2 + 9)) {
      return 0;
    }
  }
  if (*((_WORD *)this + 10)
    && *((_WORD *)a2 + 10)
    && *((unsigned __int16 *)this + 10) != *((unsigned __int16 *)a2 + 10))
  {
    return 0;
  }
  int v4 = *((unsigned __int8 *)this + 24);
  if (!*((unsigned char *)this + 24)
    || (int v5 = *((unsigned __int8 *)a2 + 24), !*((unsigned char *)a2 + 24))
    || v4 == v5
    || v4 == 4 && v5 == 2
    || (uint64_t v6 = 0, v4 == 8) && v5 == 3)
  {
    if (*((unsigned char *)this + 25)
      && *((unsigned char *)a2 + 25)
      && *((unsigned __int8 *)this + 25) != *((unsigned __int8 *)a2 + 25)
      || *((unsigned char *)this + 27)
      && *((unsigned char *)a2 + 27)
      && *((unsigned __int8 *)this + 27) != *((unsigned __int8 *)a2 + 27)
      || *((_WORD *)this + 14)
      && *((_WORD *)a2 + 14)
      && *((unsigned __int16 *)this + 14) != *((unsigned __int16 *)a2 + 14))
    {
      return 0;
    }
    uint64_t v6 = *((unsigned __int8 *)this + 30);
    if (v6 != 1)
    {
      int v8 = *((unsigned __int8 *)a2 + 30);
      return v8 == 1 || v6 == v8;
    }
  }
  return v6;
}

void C3D::RenderGraph::execute(C3D::RenderGraph *this)
{
  v2.n128_f64[0] = MEMORY[0x270FA5388](this);
  uint64_t v3 = v1;
  *(void *)((char *)&v148[2] + 4) = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(v1 + 210) && *(unsigned char *)(v1 + 211))
  {
    if (*(unsigned char *)(v1 + 212)) {
      C3D::RenderGraph::logFrame((C3D::RenderGraph *)v1);
    }
    uint64_t RenderContext = (SCNMTLRenderContext *)C3DEngineContextGetRenderContext(*(void *)(v3 + 8));
    uint64_t v127 = (void *)-[SCNMTLRenderContext currentCommandBuffer]((uint64_t)RenderContext);
    uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(v3 + 8));
    C3DStackAllocatorPushFrame(StackAllocator);
    v136._encoder = 0;
    v136._bufferPool = 0;
    v135._encoder = 0;
    v135._commandBuffer = 0;
    if (*(void *)(v3 + 168)) {
      operator new();
    }
    uint64_t v7 = *(void *)(v3 + 96);
    uint64_t v134 = v7;
    if (!v7)
    {
LABEL_208:
      *(void *)(v3 + 120) = 0;
      C3DStackAllocatorPopFrame(StackAllocator);
      return;
    }
    *(void *)&long long v6 = 136315394;
    long long v117 = v6;
    while (1)
    {
      unsigned __int16 v133 = 0;
      int v8 = (_DWORD *)(v7 + 8);
      if (*(_DWORD *)(v7 + 8)) {
        break;
      }
LABEL_207:
      uint64_t v7 = *(void *)(v7 + 24);
      uint64_t v134 = v7;
      if (!v7) {
        goto LABEL_208;
      }
    }
    unsigned int v9 = 0;
    unsigned __int16 v10 = 0;
    while (1)
    {
      __int16 v11 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v7, v9);
      uint64_t v12 = (_DWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v3 + 24), *v11);
      uint64_t v13 = *(C3D::Pass **)v12;
      *(void *)(v3 + 120) = *(void *)v12;
      switch(*(_DWORD *)C3D::Pass::descriptor(v13))
      {
        case 1:
          uint64_t v14 = C3D::Pass::descriptor(v13);
          unsigned int v15 = *(unsigned __int16 *)(v14 + 6);
          if (*(_WORD *)(v14 + 6))
          {
            unsigned int v16 = 0;
            do
            {
              *(void *)float32x4_t buf = v127;
              *(_WORD *)&buf[8] = v16;
              (*(void (**)(C3D::Pass *, unsigned char *))(*(void *)v13 + 56))(v13, buf);
              ++v16;
            }
            while (v16 < v15);
          }
          goto LABEL_166;
        case 2:
          int v119 = *(unsigned __int8 *)C3D::RenderPass::getRenderMode(v13);
          uint64_t v18 = *(void **)(v3 + 152);
          uint64_t v19 = *(void *)(v7 + 24);
          int v20 = v19
             && !*(void *)(v19 + 24)
             && -[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext)
             && *v8 - 1 == v9;
          for (uint64_t i = 0; i != 8; ++i)
          {
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments", v117), "objectAtIndexedSubscript:", i), "setTexture:", 0);
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", i), "setResolveTexture:", 0);
          }
          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", 0);
          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setResolveTexture:", 0);
          objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", 0);
          if (v119 == 1) {
            uint64_t v22 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6);
          }
          else {
            uint64_t v22 = 0;
          }
          [v18 setRenderTargetArrayLength:v22];
          if (v13 == *(C3D::Pass **)(v3 + 112)) {
            uint64_t v28 = [(id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext) rasterizationRateMap];
          }
          else {
            uint64_t v28 = 0;
          }
          [v18 setRasterizationRateMap:v28];
          uint64_t v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
          if (C3D::PassDescriptor::outputCount(v29))
          {
            char v120 = 0;
            int v30 = 0;
            while (1)
            {
              uint64_t v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
              uint64_t v32 = C3D::PassDescriptor::outputAtIndex(v31, (unsigned __int16)v30);
              if (*(unsigned char *)v32 == 1)
              {
                uint64_t v33 = *(void *)(v32 + 8);
                unsigned int v34 = *(unsigned __int8 *)(v32 + 31);
                *(_OWORD *)__s1 = *(_OWORD *)(v32 + 48);
                uint64_t v35 = *(unsigned __int8 *)(v32 + 65);
                __int16 v124 = *(_WORD *)(v32 + 66);
                uint64_t v36 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
                int v37 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v36, (unsigned __int16)v30) + 64);
                switch(v37)
                {
                  case 3:
                    if (v20
                      && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"), "texture"))
                    {
                      __int16 v39 = (void *)[(id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext) stencilAttachment];
                      [v18 setStencilAttachment:v39];
                      if (v34 <= 1 && [v39 resolveTexture])
                      {
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", objc_msgSend(v39, "resolveTexture"));
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setResolveTexture:", 0);
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", 1);
                      }
LABEL_87:
                      if (C3DEngineContextHasFeatures(*(void *)(v3 + 8), 0x4000))
                      {
                        uint64_t v46 = (void *)-[SCNMTLRenderContext device]((uint64_t)RenderContext);
                        if (SCNMTLDeviceSupportsStencilResolve(v46))
                        {
                          if (-[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext)) {
                            objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStencilResolveFilter:", 1);
                          }
                        }
                      }
                      break;
                    }
                    uint64_t v42 = (C3D::PassResource *)C3D::Pass::resource(v13);
                    uint64_t v43 = C3D::PassResource::outputAtIndex(v42, (unsigned __int16)v30);
                    if (v43)
                    {
                      if ((v124 & 8) != 0 && !*(void *)(v3 + 168)) {
                        uint64_t v44 = 0;
                      }
                      else {
                        uint64_t v44 = C3D::__deduceStoreAction(v3, (void *)[v18 stencilAttachment], 3, (unint64_t)v12, StackAllocator, v30);
                      }
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", v44);
                      if (objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "storeAction") == 2
                        || objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "storeAction") == 3)
                      {
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setResolveTexture:", *(void *)(v43 + 24));
                      }
                      if (*(unsigned char *)(v43 + 32) != 1)
                      {
                        uint64_t v45 = scn_default_log();
                        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
                          C3D::RenderGraph::execute(v143, &v144, v45);
                        }
                      }
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setLoadAction:", v124 & 3);
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", *(void *)v43);
                      goto LABEL_87;
                    }
                    break;
                  case 2:
                    if (v20
                      && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "depthAttachment"), "texture"))
                    {
                      int v40 = (void *)[(id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext) depthAttachment];
                      [v18 setDepthAttachment:v40];
                      if (v34 <= 1 && [v40 resolveTexture])
                      {
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", objc_msgSend(v40, "resolveTexture"));
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setResolveTexture:", 0);
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setStoreAction:", 1);
                      }
LABEL_101:
                      char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*(void *)(v3 + 8));
                      if (C3DEngineContextHasFeatures(*(void *)(v3 + 8), 4)
                        && -[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext))
                      {
                        if ((CoordinatesSystemOptions & 8) != 0) {
                          uint64_t v54 = 2;
                        }
                        else {
                          uint64_t v54 = 1;
                        }
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setDepthResolveFilter:", v54);
                      }
                      unsigned int v55 = (void *)[v18 depthAttachment];
                      if ((CoordinatesSystemOptions & 8) != 0) {
                        [v55 setClearDepth:0.0];
                      }
                      else {
                        [v55 setClearDepth:1.0];
                      }
                      break;
                    }
                    __int16 v47 = (C3D::PassResource *)C3D::Pass::resource(v13);
                    uint64_t v48 = C3D::PassResource::outputAtIndex(v47, (unsigned __int16)v30);
                    uint64_t v49 = v48;
                    if (v48)
                    {
                      if (*(unsigned char *)(v48 + 32) != 1)
                      {
                        uint64_t v50 = scn_default_log();
                        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
                          C3D::RenderGraph::execute(v145, &v146, v50);
                        }
                      }
                      uint64_t v51 = (void *)[v18 depthAttachment];
                      objc_msgSend(v51, "setTexture:", C3D::Pass::outputTextureAtIndex(v13, (unsigned __int16)v30));
                      [v51 setLoadAction:v124 & 3];
                      if ((v124 & 8) != 0 && !*(void *)(v3 + 168)) {
                        uint64_t v52 = 0;
                      }
                      else {
                        uint64_t v52 = C3D::__deduceStoreAction(v3, v51, 2, (unint64_t)v12, StackAllocator, v30);
                      }
                      [v51 setStoreAction:v52];
                      if ([v51 storeAction] == 2 || objc_msgSend(v51, "storeAction") == 3) {
                        [v51 setResolveTexture:*(void *)(v49 + 24)];
                      }
                      goto LABEL_101;
                    }
                    break;
                  case 1:
                    if (v35 == 255)
                    {
                      uint64_t v38 = scn_default_log();
                      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)float32x4_t buf = v117;
                        *(void *)&uint8_t buf[4] = "attachmentID < 255";
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v33;
                        _os_log_fault_impl(&dword_20B249000, v38, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Attachment ID not set for %s", buf, 0x16u);
                      }
                    }
                    else
                    {
                      if (v35) {
                        int v56 = 0;
                      }
                      else {
                        int v56 = v20;
                      }
                      if (v56 == 1)
                      {
                        uint64_t v57 = objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "colorAttachments"), "objectAtIndexedSubscript:", 0);
                        objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "setObject:atIndexedSubscript:", v57, 0);
                        if (v34 <= 1 && [v57 resolveTexture])
                        {
                          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", objc_msgSend(v57, "resolveTexture"));
                          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setResolveTexture:", 0);
                          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setStoreAction:", 1);
                        }
                        break;
                      }
                    }
                    uint64_t v58 = (C3D::PassResource *)C3D::Pass::resource(v13);
                    uint64_t v59 = C3D::PassResource::outputAtIndex(v58, (unsigned __int16)v30);
                    uint64_t v60 = (C3D::RefCountedResource *)v59;
                    if (v59)
                    {
                      if (*(unsigned char *)(v59 + 32) != 1)
                      {
                        uint64_t v61 = scn_default_log();
                        if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
                          C3D::RenderGraph::execute(v147, v148, v61);
                        }
                      }
                      int64_t v62 = objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", v35);
                      objc_msgSend(v62, "setTexture:", C3D::Pass::outputTextureAtIndex(v13, (unsigned __int16)v30));
                      BOOL v63 = [v62 texture] == 0;
                      objc_msgSend(v62, "setStoreAction:", C3D::__deduceStoreAction(v3, v62, 1, (unint64_t)v12, StackAllocator, v30));
                      if ([v62 storeAction] == 2 || objc_msgSend(v62, "storeAction") == 3)
                      {
                        objc_msgSend(v62, "setResolveTexture:", C3D::RefCountedResource::resolveTextureOrFinal(v60, RenderContext));
                        uint64_t v64 = objc_msgSend((id)objc_msgSend(v62, "resolveTexture"), "width");
                        LODWORD(v64) = v64 == objc_msgSend((id)objc_msgSend(v62, "texture"), "width");
                        unsigned __int8 v65 = (void *)[v62 resolveTexture];
                        if (!v64
                          || ((uint64_t v66 = [v65 height],
                               BOOL v67 = v66 != objc_msgSend((id)objc_msgSend(v62, "texture"), "height"),
                               ![v62 resolveTexture])
                            ? (char v68 = 1)
                            : (char v68 = v67),
                              (v68 & 1) != 0))
                        {
                          *(void *)(v3 + 120) = 0;
                          C3DStackAllocatorPopFrame(StackAllocator);
                          return;
                        }
                      }
                      [v62 setLoadAction:v124 & 3];
                      v120 |= v63;
                      if ([v62 loadAction] == 2)
                      {
                        if ((v124 & 0x40) == 0) {
                          *(__n128 *)__s1 = C3DEngineContextGetViewBackgroundColor(*(void *)(v3 + 8));
                        }
                        objc_msgSend(v62, "setClearColor:", *(float *)__s1, *((float *)__s1 + 1), *(float *)&__s1[1], *((float *)&__s1[1] + 1));
                      }
                    }
                    break;
                  default:
                    __int16 v41 = scn_default_log();
                    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
                      C3D::__renderSlice(v141, v142, v41);
                    }
                    break;
                }
              }
              __int16 v69 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
              if (++v30 >= C3D::PassDescriptor::outputCount(v69)) {
                goto LABEL_137;
              }
            }
          }
          char v120 = 0;
LABEL_137:
          if (v20
            && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"), "texture"))
          {
            objc_msgSend(v18, "setStencilAttachment:", objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"));
          }
          unsigned int v70 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 10);
          if (v70 <= 1) {
            __int16 v71 = 1;
          }
          else {
            __int16 v71 = v70;
          }
          unsigned int v72 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 8);
          __int16 v73 = *(_WORD *)(C3D::Pass::descriptor(v13) + 6);
          uint64_t v74 = C3D::Pass::descriptor(v13);
          if (v119) {
            __int16 v75 = 1;
          }
          else {
            __int16 v75 = v73;
          }
          unsigned __int16 v125 = v72 + v71;
          if (!(v120 & 1 | (v72 >= (unsigned __int16)(v72 + v71))))
          {
            __s1SCNMatrix4 a = *(unsigned __int16 *)(v74 + 4);
            unsigned __int16 v76 = __s1a + v75;
            do
            {
              unsigned __int16 v77 = __s1a;
              if (__s1a < v76)
              {
                do
                {
                  if (v20
                    && ((-[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext) & 1) != 0
                     || -[SCNMTLRenderContext enableARMode]((uint64_t)RenderContext)))
                  {
                    RenderPassDescriptorForEye = (void *)C3DEngineContextGetRenderPassDescriptorForEye(*(void *)(v3 + 8), v77);
                    uint64_t v79 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "colorAttachments"), "objectAtIndexedSubscript:", 0), "resolveTexture");
                    if (!v79) {
                      uint64_t v79 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture");
                    }
                    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", v79);
                    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 0);
                    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setStoreAction:", 1);
                    if (objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "texture")
                      || objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "resolveTexture"))
                    {
                      uint64_t v80 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "depthAttachment"), "resolveTexture");
                      if (!v80) {
                        uint64_t v80 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "depthAttachment"), "texture");
                      }
                      objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", v80);
                      objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setLoadAction:", 0);
                      objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setStoreAction:", 1);
                    }
                    if (objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "texture")
                      || objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "resolveTexture"))
                    {
                      uint64_t v81 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "stencilAttachment"), "resolveTexture");
                      if (!v81) {
                        uint64_t v81 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "stencilAttachment"), "texture");
                      }
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", v81);
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setLoadAction:", 0);
                      objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", 1);
                    }
                  }
                  v129[0] = &v137;
                  v129[1] = v18;
                  unsigned __int16 v130 = v77;
                  __int16 v131 = v72;
                  int v132 = 0;
                  C3D::__renderSlice((void *)v3, v13, &v133, v12, &v134, (uint64_t)v129, v20, (uint64_t *)(v3 + 160));
                  ++v77;
                }
                while (v77 < v76);
              }
              LOWORD(v72) = v72 + 1;
            }
            while ((unsigned __int16)v72 < v125);
          }
LABEL_166:
          if (*(void *)(v3 + 168))
          {
            uint64_t v82 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
            int v83 = C3D::PassResource::outputCount(v82);
            uint64_t v84 = v133;
            if (v83)
            {
              uint64_t v85 = 0;
              uint64_t v126 = v133;
              while (2)
              {
                uint64_t v86 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
                uint64_t v87 = C3D::PassResource::outputAtIndex(v86, (unsigned __int16)v85);
                if (!v87) {
                  goto LABEL_200;
                }
                if (!*(void *)(v3 + 184)) {
                  *(void *)(v3 + 184) = C3D::RenderGraph::graphDescription((C3D::RenderGraph *)v3);
                }
                unsigned int v88 = 0;
                uint64_t v89 = v3 + 96;
                while (1)
                {
                  uint64_t v90 = *(void *)v89;
                  uint64_t v91 = *(unsigned int *)(*(void *)v89 + 8);
                  if (v91) {
                    break;
                  }
LABEL_177:
                  uint64_t v89 = v90 + 24;
                  ++v88;
                }
                __int16 v92 = *(unsigned __int16 **)(v90 + 16);
                uint64_t v93 = 2 * v91;
                while (1)
                {
                  uint64_t v94 = (uint64_t *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v3 + 24), *v92);
                  Primitiveint Count = C3DMeshElementGetPrimitiveCount(*v94);
                  if (PrimitiveCount != C3DMeshElementGetPrimitiveCount(*(void *)v12)) {
                    break;
                  }
                  ++v92;
                  v93 -= 2;
                  if (!v93) {
                    goto LABEL_177;
                  }
                }
                uint64_t v96 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(v3 + 184), "objectForKeyedSubscript:", @"stages"), "objectAtIndex:", v88), "objectAtIndex:", v84), "objectForKey:", @"outputs"), "objectAtIndex:", v85);
                if (!v96)
                {
                  uint64_t v97 = scn_default_log();
                  if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)float32x4_t buf = 136315650;
                    *(void *)&uint8_t buf[4] = "outputDesc";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v85;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v88;
                    _os_log_fault_impl(&dword_20B249000, v97, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Missing output at index %d for stage %d", buf, 0x18u);
                  }
                }
                if (*(unsigned char *)(v87 + 32) != 1) {
                  goto LABEL_200;
                }
                uint64_t v98 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v12, v85);
                *(_OWORD *)float32x4_t buf = *(_OWORD *)(v98 + 16);
                *(_DWORD *)&buf[16] = *(_DWORD *)(v98 + 32);
                uint64_t v99 = (MTLTexture *)([*(id *)v87 sampleCount] == 1
                                   ? C3D::RefCountedResource::textureOrFinal((C3D::RefCountedResource *)v87, RenderContext): C3D::RefCountedResource::resolveTextureOrFinal((C3D::RefCountedResource *)v87, RenderContext));
                uint64_t v100 = v99;
                uint64_t v101 = (void *)-[SCNMTLRenderContext resourceManager]((uint64_t)RenderContext);
                Shareduint64_t Texture = C3D::CreateSharedTexture(v100, (long long *)buf, v127, v101);
                if (!SharedTexture) {
                  goto LABEL_200;
                }
                uint64_t v103 = (const char *)(***(uint64_t (****)(void))v12)();
                if (v103) {
                  uint64_t v104 = strdup(v103);
                }
                else {
                  uint64_t v104 = 0;
                }
                LODWORD(v105) = MEMORY[0];
                uint64_t v106 = (void *)MEMORY[8];
                if ((MEMORY[0] + 1) <= MEMORY[4])
                {
                  long long v109 = (char *)MEMORY[8];
                  if (!v104) {
                    goto LABEL_196;
                  }
                }
                else
                {
                  __s1SCNMatrix4 b = v104;
                  unsigned int v107 = ((double)(MEMORY[4] + 1) * 1.5);
                  uint64_t v108 = (char *)malloc_type_malloc(32 * v107, 0x74F3E194uLL);
                  long long v109 = v108;
                  unint64_t v105 = MEMORY[0];
                  if (MEMORY[0])
                  {
                    uint64_t v110 = 0;
                    unint64_t v111 = 0;
                    do
                    {
                      uint64_t v112 = &v108[v110];
                      uint64_t v113 = MEMORY[8] + v110;
                      *(_OWORD *)uint64_t v112 = *(_OWORD *)(MEMORY[8] + v110);
                      *((void *)v112 + 2) = *(void *)(v113 + 16);
                      *((_DWORD *)v112 + 6) = *(_DWORD *)(v113 + 24);
                      *(void *)uint64_t v113 = 0;
                      *(void *)(v113 + _Block_object_dispose(&STACK[0x380], 8) = 0;
                      *(void *)(v113 + 16) = 0;
                      *(_DWORD *)(v113 + 24) = -1;
                      ++v111;
                      v110 += 32;
                    }
                    while (v111 < v105);
                  }
                  MEMORY[8] = v108;
                  MEMORY[4] = v107;
                  if (v106 != (void *)16)
                  {
                    free(v106);
                    LODWORD(v105) = MEMORY[0];
                    long long v109 = (char *)MEMORY[8];
                  }
                  uint64_t v104 = __s1b;
                  if (!__s1b)
                  {
LABEL_196:
                    int v114 = 0;
                    goto LABEL_199;
                  }
                }
                int v114 = strdup(v104);
LABEL_199:
                __int16 v115 = &v109[32 * v105];
                *(void *)__int16 v115 = v114;
                *((void *)v115 + 1) = v96;
                *((void *)v115 + 2) = SharedTexture;
                *((_DWORD *)v115 + 6) = v85;
                MEMORY[0] = v105 + 1;
                free(v104);
                uint64_t v84 = v126;
LABEL_200:
                int v116 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
                if (++v85 >= (unint64_t)C3D::PassResource::outputCount(v116)) {
                  break;
                }
                continue;
              }
            }
          }
          else
          {
            LOWORD(v84) = v133;
          }
          unsigned __int16 v10 = v84 + 1;
          unsigned __int16 v133 = v84 + 1;
          unsigned int v9 = (unsigned __int16)(v84 + 1);
          uint64_t v7 = v134;
          int v8 = (_DWORD *)(v134 + 8);
          if (*(_DWORD *)(v134 + 8) <= v9) {
            goto LABEL_207;
          }
          break;
        case 3:
          if (v127 && !v136._encoder)
          {
            int v23 = -[SCNMTLRenderContext features]((uint64_t)RenderContext);
            SCNMTLComputeCommandEncoder::beginEncoding(&v136, v127, v23, 0, 0);
          }
          if (*(_WORD *)(C3D::Pass::descriptor(v13) + 6))
          {
            unsigned int v24 = 0;
            do
            {
              *(void *)float32x4_t buf = &v136;
              *(_WORD *)&buf[8] = v24;
              (*(void (**)(C3D::Pass *, unsigned char *))(*(void *)v13 + 40))(v13, buf);
              ++v24;
            }
            while (v24 < *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6));
          }
          PassInStage = (C3D::Pass *)C3D::__nextPassInStage(*(void *)(v3 + 24), v7, v10);
          if (v127 && (*(void *)(v3 + 168) || !PassInStage || *(_DWORD *)C3D::Pass::descriptor(PassInStage) != 3)) {
            SCNMTLComputeCommandEncoder::endEncoding(&v136);
          }
          goto LABEL_166;
        case 4:
          if (v127 && !v135._encoder) {
            SCNMTLBlitCommandEncoder::beginEncoding(&v135, v127, 0);
          }
          if (*(_WORD *)(C3D::Pass::descriptor(v13) + 6))
          {
            unsigned int v26 = 0;
            do
            {
              *(void *)float32x4_t buf = &v135;
              *(_WORD *)&buf[8] = v26;
              (*(void (**)(C3D::Pass *, unsigned char *))(*(void *)v13 + 48))(v13, buf);
              ++v26;
            }
            while (v26 < *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6));
          }
          uint64_t v27 = (C3D::Pass *)C3D::__nextPassInStage(*(void *)(v3 + 24), v7, v10);
          if (v127 && (!v27 || *(_DWORD *)C3D::Pass::descriptor(v27) != 4)) {
            SCNMTLBlitCommandEncoder::endEncoding(&v135);
          }
          goto LABEL_166;
        case 5:
          (*(void (**)(C3D::Pass *))(*(void *)v13 + 24))(v13);
          goto LABEL_166;
        default:
          uint64_t v17 = scn_default_log();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
            C3D::RenderGraph::execute(v139, &v140, v17);
          }
          goto LABEL_166;
      }
    }
  }
  uint64_t v4 = *(void *)(v1 + 168);
  if (v4)
  {
    id v5 = *(id *)(v3 + 184);
    if (v5
      || (id v5 = C3D::RenderGraph::graphDescription((C3D::RenderGraph *)v3),
          *(void *)(v3 + 184) = v5,
          (uint64_t v4 = *(void *)(v3 + 168)) != 0))
    {
      (*(void (**)(uint64_t, id, __n128))(v4 + 16))(v4, v5, v2);

      *(void *)(v3 + 16_Block_object_dispose(&STACK[0x380], 8) = 0;
      *(void *)(v3 + 184) = 0;
    }
  }
}

void sub_20B2AC3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
}

uint64_t C3D::Pass::descriptor(C3D::Pass *this)
{
  return (uint64_t)this + 32;
}

void *C3D::Pass::outputTextureAtIndex(C3D::Pass *this, unsigned int a2)
{
  uint64_t RenderContext = (void *)C3DEngineContextGetRenderContext(*((void *)this + 2));
  id v5 = (void **)C3D::PassResource::outputAtIndex((C3D::Pass *)((char *)this + 80), a2);
  if (v5)
  {
    long long v6 = v5;
    uint64_t v7 = *v5;
    uint64_t v8 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)this + 32), a2);
    if (v7
      && (*(unsigned __int8 *)(v8 + 31) <= 1u ? (uint64_t v9 = 1) : (uint64_t v9 = *(unsigned __int8 *)(v8 + 31)),
          [v7 sampleCount] != v9))
    {
      if ((*((unsigned char *)v6 + 34) & 4) == 0) {
        return v6[3];
      }
    }
    else if ((*((unsigned char *)v6 + 34) & 2) == 0)
    {
      return *v6;
    }
    return -[SCNMTLRenderContext _finalRenderTexture](RenderContext);
  }
  else
  {
    __int16 v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::outputTextureAtIndex(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    return 0;
  }
}

void *C3D::RefCountedResource::resolveTextureOrFinal(C3D::RefCountedResource *this, SCNMTLRenderContext *a2)
{
  if ((*((unsigned char *)this + 34) & 4) != 0) {
    return -[SCNMTLRenderContext _finalRenderTexture](a2);
  }
  else {
    return (void *)*((void *)this + 3);
  }
}

uint64_t C3D::__deduceStoreAction(uint64_t a1, void *a2, int a3, unint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  if (!SCNMTLTextureTypeIsMultisampled(objc_msgSend((id)objc_msgSend(a2, "texture"), "textureType"))) {
    return 1;
  }
  if (a3 == 2 && !C3DEngineContextHasFeatures(*(void *)(a1 + 8), 4)) {
    return 0;
  }
  uint64_t v38 = a5;
  uint64_t v39 = 0;
  int v40 = (char *)&v41;
  if (!a5)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t Aligned = (char *)C3DStackAllocatorAllocateAligned(v38, (16 * (HIDWORD(v39) + 10)), 8, 0);
  memcpy(Aligned, v40, 16 * v39);
  int v40 = Aligned;
  HIDWORD(v39) += 10;
  v36.n128_u64[0] = a4;
  v36.n128_u8[8] = a6;
  C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>((uint64_t)&v38, &v36);
  uint64_t v21 = v39;
  if (v39)
  {
    char v22 = 0;
    char v23 = 0;
    do
    {
      unsigned int v24 = &v40[16 * v21];
      uint64_t v25 = *((void *)v24 - 2);
      int v26 = *(v24 - 8);
      LODWORD(v39) = v39 - 1;
      C3D::RenderGraph::GraphNode::successorsAtIndex(v25, v26, a5, &v36);
      if (v36.n128_u32[2])
      {
        uint64_t v27 = v37;
        uint64_t v28 = 4 * v36.n128_u32[2];
        while (1)
        {
          uint64_t v29 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *(_DWORD *)v27 & 0x7FFF);
          uint64_t v30 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)v29 + 32), *(unsigned __int8 *)(v27 + 3));
          unsigned int v31 = *(unsigned __int8 *)(v30 + 31);
          v23 |= v31 > 1;
          v22 |= v31 < 2;
          if (v23 & 1) != 0 && (v22) {
            break;
          }
          if ((*(_WORD *)(v30 + 66) & 0x80) != 0)
          {
            v35.n128_u64[0] = v29;
            v35.n128_u8[8] = *(unsigned char *)(v27 + 3);
            C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>((uint64_t)&v38, &v35);
          }
          v27 += 4;
          v28 -= 4;
          if (!v28) {
            goto LABEL_18;
          }
        }
        char v23 = 1;
        char v22 = 1;
      }
LABEL_18:
      uint64_t v21 = v39;
    }
    while (v39);
  }
  else
  {
    char v23 = 0;
    char v22 = 0;
  }
  uint64_t v33 = v23 & (objc_msgSend((id)objc_msgSend(a2, "texture"), "storageMode") != 3);
  uint64_t v34 = 2;
  if ((v22 & 1 & v33) != 0) {
    uint64_t v34 = 3;
  }
  if (v22) {
    return v34;
  }
  else {
    return v33;
  }
}

BOOL SCNMTLTextureTypeIsMultisampled(uint64_t a1)
{
  return a1 == 4 || a1 == 8;
}

__n128 C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>(uint64_t a1, __n128 *a2)
{
  int v4 = *(_DWORD *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 12);
  long long v6 = *(__n128 **)(a1 + 16);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = (__n128 *)C3DStackAllocatorAllocateAligned(*(void *)a1, 16 * v7, 8, 0);
    memcpy(Aligned, v6, 16 * *(unsigned int *)(a1 + 8));
    *(void *)(a1 + 16) = Aligned;
    *(_DWORD *)(a1 + 12) = v7;
    long long v6 = Aligned;
    int v4 = *(_DWORD *)(a1 + 8);
  }
  __n128 result = *a2;
  v6[v4] = *a2;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void C3D::__renderSlice(void *a1, C3D::Pass *a2, _WORD *a3, _DWORD *a4, uint64_t *a5, uint64_t a6, int a7, uint64_t *a8)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  uint64_t v10 = a1[1];
  uint64_t RenderContext = (id *)C3DEngineContextGetRenderContext(v10);
  uint64_t v12 = *(void *)a6;
  __int16 v11 = *(void **)(a6 + 8);
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(v10);
  uint64_t v13 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a2);
  uint64_t v102 = (unsigned __int8 *)a2;
  if (C3D::PassDescriptor::outputCount(v13))
  {
    unsigned int v14 = 0;
    do
    {
      uint64_t v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a2);
      if (*(unsigned char *)C3D::PassDescriptor::outputAtIndex(v15, (unsigned __int16)v14) == 1)
      {
        uint64_t v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
        uint64_t v17 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v16, (unsigned __int16)v14) + 24);
        if (SCNMTLTextureTypeIsArray(v17) || SCNMTLTextureTypeIsCube(v17))
        {
          int v18 = *(unsigned __int16 *)(a6 + 16);
          LODWORD(v19) = v18;
        }
        else
        {
          LODWORD(v19) = 0;
          int v18 = *(unsigned __int16 *)(a6 + 16);
        }
        if (v18) {
          BOOL v20 = v102[120] != 0;
        }
        else {
          BOOL v20 = 0;
        }
        uint64_t v21 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
        int v22 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v21, (unsigned __int16)v14) + 64);
        switch(v22)
        {
          case 3:
            BOOL v25 = objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "resolveTexture") == 0;
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (v25) {
              uint64_t v19 = 0;
            }
            else {
              uint64_t v19 = v19;
            }
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setResolveSlice:", v19);
            if (v20 && objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "loadAction") == 2) {
              objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setLoadAction:", 0);
            }
            break;
          case 2:
            BOOL v26 = objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "resolveTexture") == 0;
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (v26) {
              uint64_t v19 = 0;
            }
            else {
              uint64_t v19 = v19;
            }
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setResolveSlice:", v19);
            if (v20 && objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "loadAction") == 2) {
              objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setLoadAction:", 0);
            }
            break;
          case 1:
            char v23 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
            uint64_t v24 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v23, (unsigned __int16)v14) + 65);
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "resolveTexture"))
            {
              uint64_t v19 = v19;
            }
            else
            {
              uint64_t v19 = 0;
            }
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setResolveSlice:", v19);
            if (v20
              && objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "loadAction") == 2)
            {
              objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setLoadAction:", 0);
            }
            break;
          default:
            uint64_t v27 = scn_default_log();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              C3D::__renderSlice(buf, v112, v27);
            }
            break;
        }
      }
      uint64_t v28 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
      ++v14;
      a2 = (C3D::Pass *)v102;
    }
    while (v14 < C3D::PassDescriptor::outputCount(v28));
  }
  uint64_t v94 = objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "texture");
  uint64_t v29 = -[SCNMTLRenderContext frameConstantBufferPool]((uint64_t)RenderContext);
  uint64_t v30 = (void *)-[SCNMTLRenderContext currentCommandBuffer]((uint64_t)RenderContext);
  if (-[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext))
  {
    if (a7)
    {
      uint64_t v31 = -[SCNMTLRenderContext clientCommandBuffer]((uint64_t)RenderContext);
      if (v31) {
        uint64_t v30 = (void *)v31;
      }
      uint64_t v32 = -[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext);
      SCNMTLRenderCommandEncoder::useCommandEncoder((char *)v12, (uint64_t)v30, v32, v29);
    }
    else
    {
      uint64_t v34 = (void *)*a8;
      if (!*a8)
      {
        uint64_t v34 = (void *)[(id)-[SCNMTLRenderContext commandQueue]((uint64_t)RenderContext) commandBuffer];
        *a8 = (uint64_t)v34;
      }
      SCNMTLRenderCommandEncoder::useCommandEncoder((char *)v12, *a8, [v34 renderCommandEncoderWithDescriptor:v11], v29);
    }
  }
  else
  {
    if (-[SCNMTLRenderContext commandBufferStatusMonitor](RenderContext)) {
      uint64_t v33 = [NSString stringWithUTF8String:(**(uint64_t (***)(unsigned __int8 *))v102)(v102)];
    }
    else {
      uint64_t v33 = 0;
    }
    bzero((void *)v12, 0xD70uLL);
    *(_DWORD *)(v12 + 64) = 1;
    *(unsigned char *)(v12 + 72) = 1;
    *(void *)(v12 + 3384) = v30;
    __n128 v35 = (void *)[v30 renderCommandEncoderWithDescriptor:v11];
    *(void *)(v12 + 3392) = v35;
    *(void *)(v12 + 3400) = v29;
    if (v33) {
      [v35 setLabel:v33];
    }
    *(_OWORD *)(v12 + 24) = 0u;
    *(_OWORD *)(v12 + _Block_object_dispose(&STACK[0x380], 8) = 0u;
  }
  uint64_t v36 = *(unsigned __int8 *)(a6 + 16);
  __int16 v37 = *(_WORD *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 6);
  uint64_t v38 = v102[117];
  uint64_t v39 = v102[118];
  uint64_t v40 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v102 + 64))(v102);
  uint64_t v41 = a1[14];
  if (v41)
  {
    BOOL v42 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 64))(v41) != v40;
    uint64_t v43 = 0x100000000;
    if (v42) {
      uint64_t v43 = 0;
    }
  }
  else
  {
    uint64_t v43 = 0;
  }
  -[SCNMTLRenderContext beginRenderPass:renderEncoder:parameters:]((uint64_t)RenderContext, v11, v12, v43 | (v39 << 24) | (v38 << 16) | ((unint64_t)v37 << 8) | v36);
  C3D::__setupRenderEncoder((uint64_t)RenderContext, (C3D::RenderPass *)v102, a6, v12);
  C3D::RenderPass::setStates(v102, (void *)a6);
  (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v102 + 32))(v102, a6);
  uint64_t v45 = 0;
  uint64_t v46 = *a5;
  while (1)
  {
    uint64_t v47 = *(void *)(v46 + 24);
    if (!v47) {
      goto LABEL_120;
    }
    uint64_t v48 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v47, 0);
    uint64_t v49 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v48);
    if (v94) {
      goto LABEL_121;
    }
    uint64_t v45 = (unsigned __int8 **)v49;
    uint64_t v50 = (uint64_t)a4;
    if (a4[10]) {
      break;
    }
LABEL_64:
    if (*(_DWORD *)(*a5 + 8) - 1 != (unsigned __int16)*a3) {
      goto LABEL_121;
    }
    if (*((_DWORD *)*v45 + 8) != 2) {
      goto LABEL_121;
    }
    int v55 = *(unsigned __int16 *)(a6 + 16);
    if (*(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 6) - 1 != v55
      && !*(unsigned char *)C3D::RenderPass::getRenderMode((C3D::RenderPass *)v102))
    {
      goto LABEL_121;
    }
    int v56 = *(unsigned __int16 *)(a6 + 18);
    int v57 = *(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 8);
    if (v57 + *(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 10) - 1 != v56) {
      goto LABEL_121;
    }
    if (!C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32))) {
      goto LABEL_121;
    }
    unsigned __int16 v58 = 0;
    int v59 = 0;
    int v60 = 0;
    do
    {
      __int16 v61 = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*v45 + 32), v58) + 66);
      unsigned int v62 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
      v60 += (v61 & 0x80) >> 7;
      unsigned __int16 v58 = ++v59;
    }
    while (v62 > v59);
    if (!(_BYTE)v60) {
      goto LABEL_121;
    }
    if (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)a4 + 32)) < v60) {
      goto LABEL_121;
    }
    unsigned int v63 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
    if (v63 > C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)a4 + 32))) {
      goto LABEL_121;
    }
    if (a4[10])
    {
      unsigned int v64 = 0;
      int v65 = 0;
      do
      {
        uint64_t v66 = (unsigned int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)(a4 + 8), v64);
        unsigned int v67 = *v66;
        if ((unsigned __int8 **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v66 & 0x7FFF) == v45&& (*(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a4 + 32), BYTE2(v67))+ 66) & 0x80) != 0&& (*(_WORD *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*v45 + 32), HIBYTE(v67)) + 66) & 0x80) == 0)
        {
          goto LABEL_121;
        }
        unsigned int v64 = ++v65;
      }
      while (a4[10] > v65);
    }
    if (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32)))
    {
      unsigned int v68 = 0;
      unsigned __int8 v98 = 0;
      while (1)
      {
        uint64_t v69 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*v45 + 32), (unsigned __int16)v68);
        __int16 v70 = *(_WORD *)(v69 + 66);
        if ((v70 & 0x80) != 0)
        {
          uint64_t v73 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*v45 + 32), (unsigned __int16)v68);
          uint64_t v74 = *(void *)a4;
          C3D::RenderGraph::GraphNode::predecessorsAtIndex((uint64_t)v45, v68, StackAllocator, &v104);
          uint64_t v75 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v104, 0);
          unsigned __int16 v76 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(v74 + 32), *(unsigned __int8 *)(v75 + 3));
          if (*((unsigned char *)v76 + 31) == 1)
          {
            unsigned __int16 v77 = scn_default_log();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
              C3D::__renderSlice(v109, &v110, v77);
            }
          }
          if (*(unsigned char *)(v73 + 31) == 1)
          {
            uint64_t v78 = scn_default_log();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
              C3D::__renderSlice(v107, &v108, v78);
            }
          }
          int v79 = *((unsigned __int8 *)v76 + 31);
          int v80 = *(unsigned __int8 *)(v73 + 31);
          if (!C3D::PassIODescriptor::isPartiallyCompatible(v76, (const C3D::PassIODescriptor *)v73)
            || *(unsigned __int8 *)(v73 + 65) != *((unsigned __int8 *)v76 + 65))
          {
            goto LABEL_108;
          }
          char v72 = 0;
          if ((*(_WORD *)(v73 + 66) & 3) != 1 || v79 != v80) {
            goto LABEL_109;
          }
          ++v98;
        }
        else if ((v70 & 3) == 2 {
               && C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)a4 + 32)))
        }
        {
          int v71 = 0;
          while (*(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a4 + 32), v71)+ 64) != *(unsigned __int8 *)(v69 + 64)|| *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a4 + 32), v71)+ 65) != *(unsigned __int8 *)(v69 + 65))
          {
            if (++v71 >= C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)a4 + 32))) {
              goto LABEL_90;
            }
          }
          char v72 = 1;
        }
        else
        {
LABEL_90:
          char v72 = 0;
        }
        unsigned int v81 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
        ++v68;
        char v82 = v72 ^ 1;
        if (v68 >= v81) {
          char v82 = 0;
        }
        if ((v82 & 1) == 0) {
          goto LABEL_109;
        }
      }
    }
    unsigned __int8 v98 = 0;
LABEL_108:
    char v72 = 0;
LABEL_109:
    if ((v72 & 1) != 0 || v98 != v60) {
      goto LABEL_121;
    }
    int v83 = (C3D::Pass *)*v45;
    a1[15] = *v45;
    unsigned int v84 = *(unsigned __int16 *)(C3D::Pass::descriptor(v83) + 10);
    if (v84 <= 1) {
      __int16 v85 = 1;
    }
    else {
      __int16 v85 = v84;
    }
    unsigned int v86 = *(unsigned __int16 *)(C3D::Pass::descriptor(v83) + 8);
    __int16 v87 = *(_WORD *)(C3D::Pass::descriptor(v83) + 6);
    uint64_t v88 = C3D::Pass::descriptor(v83);
    unsigned __int16 v89 = v86 + v85;
    if (v86 < v89)
    {
      unsigned int v90 = *(unsigned __int16 *)(v88 + 4);
      unsigned __int16 v91 = v90 + v87;
      do
      {
        unsigned int v92 = v90;
        if (v90 < v91)
        {
          do
          {
            *(_WORD *)(a6 + 16) = v92;
            *(_WORD *)(a6 + 1_Block_object_dispose(&STACK[0x380], 8) = v86;
            C3D::__setupRenderEncoder((uint64_t)RenderContext, v83, a6, v12);
            C3D::RenderPass::setStates(*v45, (void *)a6);
            (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)*v45 + 32))(*v45, a6);
            ++v92;
          }
          while ((unsigned __int16)v92 < v91);
        }
        ++v86;
      }
      while ((unsigned __int16)v86 < v89);
    }
    uint64_t v46 = *(void *)(*a5 + 24);
    *a5 = v46;
    *a3 = 0;
LABEL_120:
    if (!v45) {
      goto LABEL_121;
    }
  }
  unsigned __int8 v51 = 0;
  while (1)
  {
    C3D::RenderGraph::GraphNode::successorsAtIndex(v50, v51, StackAllocator, &v104);
    if (v105) {
      break;
    }
LABEL_63:
    ++v51;
    uint64_t v50 = (uint64_t)a4;
    if (a4[10] <= v51) {
      goto LABEL_64;
    }
  }
  uint64_t v52 = v106;
  uint64_t v53 = 4 * v105;
  while (1)
  {
    uint64_t v54 = *v45;
    if (v54 != *(unsigned __int8 **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v52 & 0x7FFF))break; {
    ++v52;
    }
    v53 -= 4;
    if (!v53) {
      goto LABEL_63;
    }
  }
LABEL_121:
  if (*(void *)(v12 + 3392)
    && (!-[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext) || (a7 & 1) == 0))
  {
    double v44 = SCNMTLRenderCommandEncoder::endEncoding((SCNMTLRenderCommandEncoder *)v12);
  }
  if (a7 && *a8)
  {
    objc_msgSend((id)*a8, "commit", v44);
    *a8 = 0;
  }
  -[SCNMTLRenderContext endRenderPass]((uint64_t)RenderContext);
}

unint64_t C3D::RenderPass::hashName(C3D::RenderPass *this)
{
  unint64_t v2 = C3D::Pass::hashName(this);
  uint64_t v3 = (C3D::RenderPass *)((char *)this + 32);
  if (C3D::PassDescriptor::outputCount(v3))
  {
    unsigned int v4 = 0;
    do
    {
      uint64_t v5 = C3D::PassDescriptor::outputAtIndex(v3, v4);
      if (*(unsigned char *)v5 == 1 && *(unsigned __int8 *)(v5 + 65) != 255)
      {
        uint64_t v6 = *(unsigned __int8 *)(v5 + 31);
        unint64_t v7 = 0xC6A4A7935BD1E995 * (v2 ^ 0x8D494F26B7A3D32ALL ^ *(unsigned __int16 *)(v5 + 28));
        unint64_t v2 = (0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) >> 47);
        if (v6 >= 2)
        {
          unint64_t v8 = 0xC6A4A7935BD1E995
             * ((0xC6A4A7935BD1E995 * (v2 ^ v6 ^ 0xC6A4A7935BD1E995)) ^ ((0xC6A4A7935BD1E995
                                                                            * (v2 ^ v6 ^ 0xC6A4A7935BD1E995)) >> 47));
          unint64_t v2 = v8 ^ (v8 >> 47);
        }
      }
      ++v4;
    }
    while (v4 < C3D::PassDescriptor::outputCount(v3));
  }
  return v2;
}

uint64_t C3D::PassDescriptor::outputAtIndex(C3D::PassDescriptor *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 21) <= a2)
  {
    unsigned int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::PassDescriptor::outputAtIndex();
    }
  }
  return *((void *)this + 4) + 80 * a2;
}

uint64_t C3D::PassDescriptor::outputCount(C3D::PassDescriptor *this)
{
  return *((unsigned __int16 *)this + 21);
}

unint64_t C3D::Pass::hashName(C3D::Pass *this)
{
  unint64_t v2 = (unsigned __int8 *)(**(uint64_t (***)(C3D::Pass *))this)(this);
  uint64_t v3 = (const char *)(**(uint64_t (***)(C3D::Pass *))this)(this);
  unsigned int v4 = strlen(v3);
  unint64_t v5 = 0xC6A4A7935BD1E995 * v4;
  if (v4 >= 8)
  {
    uint64_t v6 = v4 >> 3;
    unint64_t v7 = &v2[8 * v6];
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *(void *)v2;
      v2 += 8;
      unint64_t v5 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v9) ^ ((0xC6A4A7935BD1E995 * v9) >> 47))) ^ v5);
      v8 -= 8;
    }
    while (v8);
    unint64_t v2 = v7;
  }
  switch(v4 & 7)
  {
    case 1u:
      goto LABEL_12;
    case 2u:
      goto LABEL_11;
    case 3u:
      goto LABEL_10;
    case 4u:
      goto LABEL_9;
    case 5u:
      goto LABEL_8;
    case 6u:
      goto LABEL_7;
    case 7u:
      v5 ^= (unint64_t)v2[6] << 48;
LABEL_7:
      v5 ^= (unint64_t)v2[5] << 40;
LABEL_8:
      v5 ^= (unint64_t)v2[4] << 32;
LABEL_9:
      v5 ^= (unint64_t)v2[3] << 24;
LABEL_10:
      v5 ^= (unint64_t)v2[2] << 16;
LABEL_11:
      v5 ^= (unint64_t)v2[1] << 8;
LABEL_12:
      unint64_t v5 = 0xC6A4A7935BD1E995 * (v5 ^ *v2);
      break;
    default:
      return (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
  }
  return (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
}

const char *C3D::MainPass::name(C3D::MainPass *this)
{
  return "MainPass";
}

BOOL SCNMTLTextureTypeIsCube(uint64_t a1)
{
  return (unint64_t)(a1 - 5) < 2;
}

BOOL SCNMTLTextureTypeIsArray(uint64_t a1)
{
  return a1 == 6 || (a1 & 0xFFFFFFFFFFFFFFFDLL) == 1;
}

unsigned __int8 *C3D::RenderPass::setStates(unsigned __int8 *result, void *a2)
{
  unint64_t v2 = (unsigned char *)*a2;
  int v3 = result[112];
  *(unsigned char *)*a2 = result[112] != 0;
  if (v3)
  {
    uint64_t v4 = *((void *)v2 + 1);
    uint64_t v5 = *((void *)&xmmword_20B5CD570 + v4);
    if (v4 != v5)
    {
      *((void *)v2 + 1) = v5;
      v2[40] = 1;
      uint64_t v4 = v5;
    }
    uint64_t v6 = *((void *)&xmmword_20B5CD570 + result[113]);
  }
  else
  {
    uint64_t v6 = result[113];
    uint64_t v4 = *((void *)v2 + 1);
  }
  if (v4 != v6)
  {
    *((void *)v2 + 1) = v6;
    v2[40] = 1;
  }
  if (!v2[74])
  {
    uint64_t v7 = result[114];
    if (*((void *)v2 + 3) != v7)
    {
      *((void *)v2 + 3) = v7;
      v2[42] = 1;
    }
  }
  uint64_t v8 = result[115];
  if (*((void *)v2 + 4) != v8)
  {
    *((void *)v2 + 4) = v8;
    v2[43] = 1;
  }
  if (!v2[73])
  {
    uint64_t v9 = result[116];
    if (*((void *)v2 + 2) != v9)
    {
      *((void *)v2 + 2) = v9;
      v2[41] = 1;
    }
  }
  return result;
}

double C3D::ScenePass::execute(uint64_t a1, void **a2)
{
  RenderCallbacks = (void (**)(void))C3DEngineContextGetRenderCallbacks(*(void *)(a1 + 16));
  uint64_t v5 = RenderCallbacks;
  if (*(unsigned char *)(a1 + 5365)) {
    BOOL v6 = RenderCallbacks == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && *RenderCallbacks)
  {
    (*RenderCallbacks)(*(void *)(a1 + 16));
    uint64_t v7 = (char *)*a2;
    int v8 = *((_DWORD *)*a2 + 16);
    uint64_t v9 = (long long *)((char *)*a2 + 3384);
    uint64_t v10 = *((void *)*a2 + 425);
    long long v18 = *v9;
    bzero(*a2, 0xD70uLL);
    *((_DWORD *)v7 + 16) = 1;
    v7[72] = 1;
    *uint64_t v9 = v18;
    *((void *)v7 + 425) = v10;
    *((_WORD *)v7 + 20) = 257;
    v7[42] = 1;
    *(_OWORD *)(v7 + _Block_object_dispose(&STACK[0x380], 8) = 0u;
    *(_OWORD *)(v7 + 24) = 0u;
    *((_DWORD *)*a2 + 16) = v8;
    C3D::RenderPass::setStates((unsigned __int8 *)a1, a2);
  }
  if (*(void *)(a1 + 5384))
  {
    uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(a1 + 16));
    uint64_t v12 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*(void *)(a1 + 5384) + 48);
    -[SCNMTLRenderContext _setReflectionProbeArrayTexture:](RenderContext, v12);
  }
  C3D::DrawNodesPass::execute((uint64_t *)a1, (uint64_t)a2);
  if (*(unsigned char *)(a1 + 5365)) {
    BOOL v14 = v5 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    uint64_t v15 = v5[1];
    if (v15)
    {
      v15(*(void *)(a1 + 16));
      uint64_t v16 = (char *)*a2;
      uint64_t v17 = *((void *)v16 + 425);
      long long v19 = *(_OWORD *)(v16 + 3384);
      bzero(v16, 0xD70uLL);
      *((_DWORD *)v16 + 16) = 1;
      v16[72] = 1;
      *(_OWORD *)(v16 + 3384) = v19;
      *((void *)v16 + 425) = v17;
      *((_WORD *)v16 + 20) = 257;
      v16[42] = 1;
      double result = 0.0;
      *(_OWORD *)(v16 + _Block_object_dispose(&STACK[0x380], 8) = 0u;
      *(_OWORD *)(v16 + 24) = 0u;
    }
  }
  return result;
}

uint64_t _willRenderSceneEngineContextCallback(uint64_t a1)
{
  uint64_t result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    int v3 = (void *)result;
    uint64_t Scene = (id *)C3DEngineContextGetScene(a1);
    ObjCWrapper = C3DEntityGetObjCWrapper(Scene);
    return [v3 _willRenderScene:ObjCWrapper];
  }
  return result;
}

uint64_t C3DEngineContextGetUserInfo(uint64_t a1)
{
  if (!a1)
  {
    unint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 128);
}

uint64_t _didRenderSceneEngineContextCallback(uint64_t a1)
{
  uint64_t result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t Scene = (id *)C3DEngineContextGetScene(a1);
    ObjCWrapper = C3DEntityGetObjCWrapper(Scene);
    return [v3 _didRenderScene:ObjCWrapper];
  }
  return result;
}

void C3D::__setupRenderEncoder(uint64_t a1, C3D::RenderPass *this, uint64_t a3, uint64_t a4)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  int v8 = *(unsigned __int8 *)C3D::RenderPass::getRenderMode(this);
  switch(v8)
  {
    case 2:
      uint64_t v23 = C3D::Pass::descriptor(this);
      uint64_t v24 = *(unsigned __int8 *)(v23 + 6);
      int v25 = *((unsigned __int8 *)this + 118);
      if (v25 == 1)
      {
        *(_DWORD *)(a4 + 64) = v24;
      }
      else if (v25 == 2)
      {
        uint64_t v23 = SCNMTLRenderCommandEncoder::setVertexAmplificationCount(a4, v24, 2);
      }
      else
      {
        __n128 v35 = scn_default_log();
        uint64_t v23 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if (v23) {
          C3D::__setupRenderEncoder();
        }
      }
      if (*((unsigned char *)this + 121))
      {
        MEMORY[0x270FA5388](v23);
        __int16 v37 = (_OWORD *)&v104.f32[-4 * v36];
        v38.f32[0] = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        if (v24)
        {
          uint64_t v39 = 0;
          uint64_t v40 = v37 + 1;
          __asm { FMOV            V1.4S, #-1.0 }
          float32x4_t v107 = _Q1;
          _Q1.i64[1] = 0x3FF0000000000000;
          long long v106 = xmmword_20B5CC130;
          _Q1.i64[0] = 136315650;
          v38.f32[0] = 1.0 / v38.f32[0];
          float32x4_t v104 = _Q1;
          float32x4_t v105 = v38;
          do
          {
            float32x4_t v42 = *((float32x4_t *)this + v39 + 8);
            if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v42, v107))) & 0x80000000) == 0)
            {
              __n128 v108 = *((__n128 *)this + v39 + 8);
              uint64_t v43 = scn_default_log();
              BOOL v44 = os_log_type_enabled(v43, OS_LOG_TYPE_FAULT);
              float32x4_t v42 = (float32x4_t)v108;
              if (v44)
              {
                uint64_t v45 = (**(uint64_t (***)(C3D::RenderPass *))this)(this);
                *(_DWORD *)float32x4_t buf = v104.i32[0];
                *(void *)&uint8_t buf[4] = "simd_all(viewport != -1)";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v45;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = v39;
                _os_log_fault_impl(&dword_20B249000, v43, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d", buf, 0x1Cu);
                float32x4_t v42 = (float32x4_t)v108;
              }
            }
            float32x4_t v38 = vmulq_n_f32(v42, v105.f32[0]);
            *(v40 - 1) = vcvtq_f64_f32(*(float32x2_t *)v38.f32);
            *uint64_t v40 = vcvt_hight_f64_f32(v38);
            v38.i64[0] = v106;
            v40[1] = v106;
            ++v39;
            v40 += 3;
          }
          while (v24 != v39);
        }
        objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v37, v24, *(double *)v38.i64, *(_OWORD *)&v104);
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1)) {
          break;
        }
        *(double *)v46.i64 = MEMORY[0x270FA5388](0);
        if (v24)
        {
          uint64_t v47 = (uint64x2_t *)(&v104 - 2 * v24 + 1);
          uint64_t v48 = (float64x2_t *)(v37 + 1);
          uint64_t v49 = v24;
          do
          {
            uint64x2_t v50 = vcvtq_u64_f64(v48[-1]);
            float64x2_t v51 = *v48;
            v48 += 3;
            uint64x2_t v46 = vcvtq_u64_f64(v51);
            v47[-1] = v50;
            uint64x2_t *v47 = v46;
            v47 += 2;
            --v49;
          }
          while (v49);
        }
        uint64_t v52 = *(void **)(a4 + 3392);
LABEL_60:
        objc_msgSend(v52, "setScissorRects:count:", *(double *)v46.i64);
        break;
      }
      if (!*((unsigned char *)this + 120)) {
        break;
      }
      uint64_t v53 = v24;
      MEMORY[0x270FA5388](v23);
      int v55 = (_OWORD *)&v104.f32[-4 * v54];
      float v56 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
      uint64_t v57 = -[SCNMTLRenderContext engineContext](a1);
      if (v24)
      {
        uint64_t v59 = v57;
        uint64_t v60 = 0;
        __int16 v61 = (float32x4_t *)(v55 + 2);
        v58.f32[0] = 1.0 / v56;
        float32x4_t v107 = v58;
        __n128 v108 = (__n128)xmmword_20B5CC130;
        do
        {
          ViewportAtunsigned int Index = C3DEngineContextGetViewportAtIndex(v59, v60);
          float32x4_t v63 = vmulq_n_f32((float32x4_t)ViewportAtIndex, v107.f32[0]);
          v61[-2] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v63.f32);
          v61[-1] = (float32x4_t)vcvt_hight_f64_f32(v63);
          *__int16 v61 = (float32x4_t)v108;
          v61 += 3;
          ++v60;
        }
        while (v53 != v60);
      }
      [*(id *)(a4 + 3392) setViewports:v55 count:v53];
      if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1)) {
        break;
      }
      *(double *)v64.i64 = MEMORY[0x270FA5388](0);
      if (v53)
      {
        int v65 = (uint64x2_t *)(&v104 - 2 * v53 + 1);
        uint64_t v66 = (float64x2_t *)(v55 + 1);
        uint64_t v67 = v53;
        do
        {
          uint64x2_t v68 = vcvtq_u64_f64(v66[-1]);
          float64x2_t v69 = *v66;
          v66 += 3;
          uint64x2_t v64 = vcvtq_u64_f64(v69);
          v65[-1] = v68;
          *int v65 = v64;
          v65 += 2;
          --v67;
        }
        while (v67);
      }
      __int16 v70 = *(void **)(a4 + 3392);
LABEL_71:
      objc_msgSend(v70, "setScissorRects:count:", *(double *)v64.i64);
      break;
    case 1:
      uint64_t v26 = [*(id *)(a3 + 8) renderTargetArrayLength];
      uint64_t v27 = v26;
      int v28 = *((unsigned __int8 *)this + 118);
      if (v28 == 1)
      {
        *(_DWORD *)(a4 + 64) = v26;
      }
      else if (v28 == 2)
      {
        uint64_t v26 = SCNMTLRenderCommandEncoder::setVertexAmplificationCount(a4, v26, 1);
      }
      else
      {
        int v71 = scn_default_log();
        uint64_t v26 = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
        if (v26) {
          C3D::__setupRenderEncoder();
        }
      }
      if (*((unsigned char *)this + 121))
      {
        MEMORY[0x270FA5388](v26);
        uint64_t v73 = (_OWORD *)&v104.f32[-4 * v72];
        v74.f32[0] = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        uint64_t v75 = v27;
        if ((_BYTE)v27)
        {
          uint64_t v76 = 0;
          unsigned __int16 v77 = v73 + 1;
          __asm { FMOV            V1.4S, #-1.0 }
          float32x4_t v107 = _Q1;
          _Q1.i64[1] = 0x3FF0000000000000;
          long long v106 = xmmword_20B5CC130;
          _Q1.i64[0] = 136315650;
          v74.f32[0] = 1.0 / v74.f32[0];
          float32x4_t v104 = _Q1;
          float32x4_t v105 = v74;
          do
          {
            float32x4_t v79 = *((float32x4_t *)this + v76 + 8);
            if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v79, v107))) & 0x80000000) == 0)
            {
              __n128 v108 = *((__n128 *)this + v76 + 8);
              int v80 = scn_default_log();
              BOOL v81 = os_log_type_enabled(v80, OS_LOG_TYPE_FAULT);
              float32x4_t v79 = (float32x4_t)v108;
              if (v81)
              {
                uint64_t v83 = (**(uint64_t (***)(C3D::RenderPass *))this)(this);
                *(_DWORD *)float32x4_t buf = v104.i32[0];
                *(void *)&uint8_t buf[4] = "simd_all(viewport != -1)";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v83;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = v76;
                _os_log_fault_impl(&dword_20B249000, v80, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d", buf, 0x1Cu);
                float32x4_t v79 = (float32x4_t)v108;
              }
            }
            float32x4_t v82 = vmulq_n_f32(v79, v105.f32[0]);
            *(v77 - 1) = vcvtq_f64_f32(*(float32x2_t *)v82.f32);
            *unsigned __int16 v77 = vcvt_hight_f64_f32(v82);
            v77[1] = v106;
            ++v76;
            v77 += 3;
          }
          while (v27 != v76);
        }
        objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v73, v27, *(_OWORD *)&v104);
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1)) {
          break;
        }
        *(double *)v46.i64 = MEMORY[0x270FA5388](0);
        if ((_BYTE)v27)
        {
          unsigned int v84 = (uint64x2_t *)(&v104 - 2 * v27 + 1);
          __int16 v85 = (float64x2_t *)(v73 + 1);
          do
          {
            uint64x2_t v86 = vcvtq_u64_f64(v85[-1]);
            float64x2_t v87 = *v85;
            v85 += 3;
            uint64x2_t v46 = vcvtq_u64_f64(v87);
            v84[-1] = v86;
            *unsigned int v84 = v46;
            v84 += 2;
            --v75;
          }
          while (v75);
        }
        uint64_t v52 = *(void **)(a4 + 3392);
        goto LABEL_60;
      }
      if (!*((unsigned char *)this + 120)) {
        break;
      }
      MEMORY[0x270FA5388](v26);
      unsigned __int16 v89 = (_OWORD *)&v104.f32[-4 * v88];
      float v90 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
      uint64_t v91 = -[SCNMTLRenderContext engineContext](a1);
      uint64_t v93 = v27;
      if ((_BYTE)v27)
      {
        uint64_t v94 = v91;
        uint64_t v95 = 0;
        uint64_t v96 = (float32x4_t *)(v89 + 2);
        v92.f32[0] = 1.0 / v90;
        float32x4_t v107 = v92;
        __n128 v108 = (__n128)xmmword_20B5CC130;
        do
        {
          __n128 v97 = C3DEngineContextGetViewportAtIndex(v94, v95);
          float32x4_t v98 = vmulq_n_f32((float32x4_t)v97, v107.f32[0]);
          v96[-2] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v98.f32);
          v96[-1] = (float32x4_t)vcvt_hight_f64_f32(v98);
          *uint64_t v96 = (float32x4_t)v108;
          v96 += 3;
          ++v95;
        }
        while (v27 != v95);
      }
      [*(id *)(a4 + 3392) setViewports:v89 count:v27];
      if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1)) {
        break;
      }
      *(double *)v64.i64 = MEMORY[0x270FA5388](0);
      if ((_BYTE)v27)
      {
        uint64_t v99 = (uint64x2_t *)(&v104 - 2 * v27 + 1);
        uint64_t v100 = (float64x2_t *)(v89 + 1);
        do
        {
          uint64x2_t v101 = vcvtq_u64_f64(v100[-1]);
          float64x2_t v102 = *v100;
          v100 += 3;
          uint64x2_t v64 = vcvtq_u64_f64(v102);
          v99[-1] = v101;
          *uint64_t v99 = v64;
          v99 += 2;
          --v93;
        }
        while (v93);
      }
      __int16 v70 = *(void **)(a4 + 3392);
      goto LABEL_71;
    case 0:
      if (*(unsigned char *)(a4 + 72) != 1)
      {
        *(unsigned char *)(a4 + 72) = 1;
        [*(id *)(a4 + 3392) setVertexAmplificationCount:1 viewMappings:0];
      }
      if (*((unsigned char *)this + 121))
      {
        __asm { FMOV            V0.4S, #-1.0 }
        __n128 v108 = *((__n128 *)this + *(unsigned __int16 *)(a3 + 16) + 8);
        if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32((float32x4_t)v108, _Q0))) & 0x80000000) == 0)
        {
          BOOL v14 = scn_default_log();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
            C3D::__setupRenderEncoder((uint64_t)this, (unsigned __int16 *)(a3 + 16), v14);
          }
        }
        *(float *)v15.i32 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        uint64_t v16 = *(void **)(a4 + 3392);
        float32x4_t v107 = vdivq_f32((float32x4_t)v108, (float32x4_t)vdupq_lane_s32(v15, 0));
        __n128 v108 = (__n128)vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL);
        *(float64x2_t *)float32x4_t buf = vcvtq_f64_f32(*(float32x2_t *)v107.f32);
        *(float64x2_t *)&buf[16] = vcvt_hight_f64_f32(v107);
        long long v110 = xmmword_20B5CC130;
        [v16 setViewport:buf];
        *(_DWORD *)(a4 + 64) = 1;
        uint64_t v17 = *(void **)(a4 + 3392);
        uint32x2_t v18 = vcvt_u32_f32(*(float32x2_t *)v107.f32);
        *(void *)&long long v19 = v18.u32[0];
        *((void *)&v19 + 1) = v18.u32[1];
        long long v20 = v19;
        uint32x2_t v21 = vcvt_u32_f32((float32x2_t)v108.n128_u64[0]);
      }
      else
      {
        if (!*((unsigned char *)this + 120)) {
          break;
        }
        uint64_t v29 = -[SCNMTLRenderContext engineContext](a1);
        __n128 v108 = C3DEngineContextGetViewportAtIndex(v29, *(unsigned __int16 *)(a3 + 16));
        uint64_t v30 = -[SCNMTLRenderContext engineContext](a1);
        float32x2_t v31 = vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v108, (int8x16_t)v108, 8uLL), C3DEngineContextGetSuperSamplingFactor(v30));
        uint64_t v32 = *(void **)(a4 + 3392);
        *(float64x2_t *)float32x4_t buf = vcvtq_f64_f32((float32x2_t)v108.n128_u64[0]);
        *(float64x2_t *)&buf[16] = vcvtq_f64_f32(v31);
        long long v110 = xmmword_20B5CC130;
        [v32 setViewport:buf];
        *(_DWORD *)(a4 + 64) = 1;
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1)) {
          break;
        }
        uint32x2_t v33 = vcvt_u32_f32((float32x2_t)v108.n128_u64[0]);
        uint32x2_t v21 = vcvt_u32_f32(v31);
        uint64_t v17 = *(void **)(a4 + 3392);
        *(void *)&long long v34 = v33.u32[0];
        *((void *)&v34 + 1) = v33.u32[1];
        long long v20 = v34;
      }
      *(void *)&long long v22 = v21.u32[0];
      *((void *)&v22 + 1) = v21.u32[1];
      *(_OWORD *)float32x4_t buf = v20;
      *(_OWORD *)&buf[16] = v22;
      [v17 setScissorRect:buf];
      break;
  }
  int v103 = *((_DWORD *)this + 56);
  if (*(_DWORD *)(a4 + 68) != v103)
  {
    *(_DWORD *)(a4 + 6_Block_object_dispose(&STACK[0x380], 8) = v103;
    objc_msgSend(*(id *)(a4 + 3392), "setStencilReferenceValue:");
  }
}

void C3D::DrawNodesPass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t Scene = C3DEngineContextGetScene(a1[2]);
  Rootuint64_t Node = (const void *)C3DSceneGetRootNode(Scene);
  CFRetain(RootNode);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a1[2]);
  uint64_t v7 = (*(uint64_t (**)(uint64_t *))(*a1 + 80))(a1);
  -[SCNMTLRenderContext setCurrentPassHash:](RenderContext, v7);
  -[SCNMTLRenderContext setCurrentPassMaterial:](RenderContext, a1[32]);
  if (!C3DSceneGetEnginePipeline(Scene))
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  C3DEngineContextSetMatrix4x4(a1[2], 0, (uint64_t)&a1[8 * (unint64_t)*(unsigned __int16 *)(a2 + 16) + 474]);
  C3DEngineContextSetMatrix4x4(a1[2], 1, (uint64_t)&a1[8 * (unint64_t)*(unsigned __int16 *)(a2 + 16) + 426]);
  C3D::DrawNodesPass::_renderEye((C3D::DrawNodesPass *)a1);
  if (*((unsigned char *)a1 + 4948))
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    uint32x2_t v18 = a1 + 522;
    do
    {
      long long v19 = (_OWORD *)(a1[668] + v16 * 8);
      long long v20 = *(_OWORD *)&v18[v16];
      long long v21 = *(_OWORD *)&v18[v16 + 2];
      long long v22 = *(_OWORD *)&v18[v16 + 6];
      v19[3] = *(_OWORD *)&v18[v16 + 4];
      v19[4] = v22;
      v19[1] = v20;
      v19[2] = v21;
      if (C3DEngineContextIsTemporalAntialiasingEnabled(a1[2]))
      {
        float32x2_t TAAJitter = C3DEngineContextGetTAAJitter((float32x2_t *)a1[2], 0);
        float32x2_t v24 = C3DEngineContextGetTAAJitter((float32x2_t *)a1[2], 1);
        int v25 = (int8x16_t *)(a1[668] + v16 * 8);
        int8x16_t v26 = v25[4];
        *(float32x2_t *)v27.i8 = vadd_f32(vsub_f32(v24, TAAJitter), *(float32x2_t *)v26.i8);
        v27.i64[1] = vextq_s8(v26, v26, 8uLL).u64[0];
        uint8_t v25[4] = v27;
      }
      ++v17;
      v16 += 8;
    }
    while (v17 < *((unsigned __int8 *)a1 + 4948));
  }
  CFRelease(RootNode);
}

__n128 C3DEngineContextSetMatrix4x4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 384 * a2;
  __n128 result = *(__n128 *)a3;
  long long v5 = *(_OWORD *)(a3 + 16);
  long long v6 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v3 + 512) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v3 + 52_Block_object_dispose(&STACK[0x380], 8) = v6;
  *(__n128 *)(v3 + 480) = result;
  *(_OWORD *)(v3 + 496) = v5;
  return result;
}

double C3D::DrawNodesPass::_renderEye(C3D::DrawNodesPass *this)
{
  MEMORY[0x270FA5388](this);
  unsigned __int8 v2 = v1;
  uint64_t v4 = v3;
  long long v5 = (char *)(v3 + 4948);
  uint64_t Scene = C3DEngineContextGetScene(*(void *)(v3 + 16));
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(v4 + 16));
  bzero(v36, 0x1410uLL);
  v36[0] = *(void *)(v4 + 240);
  char v37 = *v5;
  unsigned __int8 v38 = v2;
  char v39 = *(unsigned char *)(v4 + 302);
  __int16 v40 = *(_WORD *)(v4 + 117);
  memcpy(v41, (const void *)(v4 + 320), sizeof(v41));
  if (*(unsigned char *)(v4 + 303))
  {
    uint64_t v9 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v4);
    if ((*(_WORD *)(C3D::PassDescriptor::outputAtIndex(v9, 0) + 66) & 0x40) == 0)
    {
      Backgrounduint64_t EffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0);
      if (BackgroundEffectSlot) {
        C3DEngineContextRenderBackgroundMap(*(void *)(v4 + 16), BackgroundEffectSlot, (uint64_t)v36);
      }
    }
  }
  uint64_t Stats = C3DEngineContextGetStats(*(void *)(v4 + 16));
  if (v5[68]) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v2;
  }
  uint64_t v13 = v4 + 16 * v12;
  size_t v14 = *(unsigned int *)(v13 + 5240);
  uint64_t v15 = *(unsigned int **)(v13 + 5232);
  if (!v15)
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3D::DrawNodesPass::_renderEye(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  double v24 = CACurrentMediaTime();
  SortSysteCFIndex m = (void *)C3DEngineContextGetSortSystem(*(void *)(v4 + 16));
  uint64_t v26 = *(void *)(v4 + 16);
  uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 80))(v4);
  C3DSortSystemSyncKeys((uint64_t)SortSystem, v26, v15, v14, v27);
  C3DSortSystemSort(SortSystem, *(void *)(v4 + 16), v15, v14);
  *(double *)(Stats + 152) = *(double *)(Stats + 152) + CACurrentMediaTime() - v24;
  if (C3DEngineContextGetMaxDrawingCommand(*(void *)(v4 + 16)))
  {
    uint64_t v28 = C3DEngineContextGetStats(*(void *)(v4 + 16));
    unsigned int v29 = C3DEngineContextGetMaxDrawingCommand(*(void *)(v4 + 16)) + ~*(_DWORD *)(v28 + 12);
    if (v14 >= v29) {
      LODWORD(v14) = v29;
    }
  }
  double v30 = CACurrentMediaTime();
  uint64_t v31 = *(void *)(v4 + 16);
  v33[0] = EnginePipeline;
  v33[1] = v31;
  char v34 = *(unsigned char *)(v4 + 296);
  char v35 = *(unsigned char *)(v4 + 301);
  v33[3] = v4;
  v33[4] = 0;
  v33[2] = v36;
  -[SCNMTLRenderContext processRendererElements:count:engineIterationContext:](RenderContext, (unint64_t)v15, v14, (uint64_t)v33);
  double result = *(double *)(Stats + 152) + CACurrentMediaTime() - v30;
  *(double *)(Stats + 152) = result;
  return result;
}

uint64_t C3DSceneGetBackgroundEffectSlot(uint64_t a1, int a2)
{
  if (a2 && !*(void *)(a1 + 304))
  {
    uint64_t v3 = C3DEffectSlotCreate(a1, 24);
    *(void *)(a1 + 304) = v3;
    uint64_t v4 = (const void *)C3DTextureSamplerBilinearMipMapClampNoAnisotropy();
    C3DEffectSlotSetTextureSampler(v3, v4);
  }
  return *(void *)(a1 + 304);
}

double SCNMTLRenderCommandEncoder::endEncoding(SCNMTLRenderCommandEncoder *this)
{
  if (!this->var24[1])
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLRenderCommandEncoder::endEncoding(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  [(id)this->var24[1] endEncoding];
  double result = 0.0;
  *(_OWORD *)this->var24 = 0u;
  return result;
}

void C3DSortSystemSort(void *a1, int a2, void *__base, size_t __nel)
{
}

BOOL C3DEngineContextHasFeatures(uint64_t a1, int a2)
{
  return (a2 & ~*(_DWORD *)(a1 + 1712)) == 0;
}

__n128 C3DEngineContextGetViewBackgroundColor(uint64_t a1)
{
  float32x4_t v6 = *(float32x4_t *)(a1 + 224);
  uint64_t Scene = C3DEngineContextGetScene(a1);
  if (Scene
    && (Backgrounduint64_t EffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0)) != 0
    && (ColorIfApplicable = (float32x4_t *)C3DEffectSlotGetColorIfApplicable(BackgroundEffectSlot)) != 0)
  {
    float32x4_t v5 = vmulq_laneq_f32(*ColorIfApplicable, *ColorIfApplicable, 3);
    v5.i32[3] = HIDWORD(*(unsigned long long *)ColorIfApplicable);
    result.n128_u64[0] = vaddq_f32(v5, vmulq_n_f32(v6, 1.0 - v5.f32[3])).u64[0];
  }
  else
  {
    return (__n128)v6;
  }
  return result;
}

void sub_20B2AED60(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void SCNMTLClusterSystem::SCNMTLClusterSystem(SCNMTLClusterSystem *this)
{
  *(_OWORD *)this = xmmword_20B5EDBD0;
  *((void *)this + 2) = 0x4000000040;
  *((_OWORD *)this + 2) = xmmword_20B5EDBE0;
  *((void *)this + 7) = 0;
  *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = 0;
  *((void *)this + 6) = 0;
}

void __EnqueueNotification(int a1, uint64_t a2, CFTypeRef cf1, void *a4, const void *a5)
{
  if (CFEqual(cf1, @"kC3DNotificationEntityAttributeDidChange"))
  {
    uint64_t v8 = C3DGetScene(a4);
    uint64_t v9 = *(void *)(a2 + 56);
    if (v8 == v9 && v9 != 0)
    {
      C3DEngineNotificationQueueEnqueueEvent(a2, 2, a4, a5);
    }
  }
  else
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      __EnqueueNotification_cold_1(v11);
    }
  }
}

uint64_t __C3DPBROpacityIsEnabled_block_invoke()
{
  uint64_t result = C3DWasLinkedBeforeMajorOSYear2023();
  C3DPBROpacityIsEnabled_usePBROpacity = result ^ 1;
  return result;
}

uint64_t ___Z32C3DProgramHashCodeStoreGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DProgramHashCodeStoreGetTypeID(void)::typeID = result;
  return result;
}

uint64_t ___Z26C3DStackAllocatorGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DStackAllocatorGetTypeID(void)::typeID = result;
  return result;
}

uint64_t ___Z25C3DTransformTreeGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DTransformTreeGetTypeID(void)::typeID = result;
  return result;
}

uint64_t ___Z25C3DCullingSystemGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DCullingSystemGetTypeID(void)::typeID = result;
  return result;
}

uint64_t __C3DTransactionGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DTransactionGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DSpanAllocatorGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DSpanAllocatorGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DSortSystemGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DSortSystemGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DShaderModifierGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DShaderModifierGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DResourceCacheGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DResourceCacheGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DRendererElementStoreGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DRendererElementStoreGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DRendererElementStateGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DRendererElementStateGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DRasterizerStatesGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DRasterizerStatesGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DProgramHashCodeGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DProgramHashCodeGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DNotificationCenterGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DNotificationCenterGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DModelValueStorageGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DModelValueStorageGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DModelTargetGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DModelTargetGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DLightingSystemGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DLightingSystemGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DLightProbesSystemGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DLightProbesSystemGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DIndexStoreGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DIndexStoreGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DIndexSetGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DIndexSetGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DFramebufferRegistryGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFramebufferRegistryGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DFXContextGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXContextGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DEnginePipelineGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DEnginePipelineGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DEngineNotificationQueueGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DEngineNotificationQueueGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DEngineContextGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DEngineContextGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DDynamicBatchingSystemGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DDynamicBatchingSystemGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DConvexPolyhedronGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConvexPolyhedronGetTypeID::typeID = result;
  return result;
}

uint64_t __C3DConstraintSliderGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintSliderGetTypeID::typeID = result;
  return result;
}

uint64_t __C3DConstraintProceduralGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintProceduralGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DConstraintManagerGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintManagerGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DConstraintConstantScaleGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintConstantScaleGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DConstraintBillboardGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintBillboardGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DConstraintAvoidOccluderGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DConstraintAvoidOccluderGetTypeID::typeID = result;
  return result;
}

uint64_t __C3DBlendStatesGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DBlendStatesGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DArrayGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DArrayGetTypeID_typeID = result;
  return result;
}

uint64_t __C3DAllocatorGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DAllocatorGetTypeID_typeID = result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceSRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002D8]);
  C3DColorSpaceSRGB_kC3DColorSpaceSRGB = (uint64_t)result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceLinearSRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002C8]);
  C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB = (uint64_t)result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceLinearGray_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002B8]);
  C3DColorSpaceLinearGray_kC3DColorSpaceLinearGray = (uint64_t)result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceLinearDisplayP3_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002B0]);
  C3DColorSpaceLinearDisplayP3_kC3DColorSpaceLinearDisplayP3 = (uint64_t)result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceExtendedSRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00238]);
  C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB = (uint64_t)result;
  return result;
}

CGColorSpaceRef __C3DColorSpaceExtendedLinearSRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00230]);
  C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB = (uint64_t)result;
  return result;
}

void _C3DSortSystemCFFinalize(uint64_t a1)
{
  unsigned __int8 v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

void _C3DRendererElementStateCFFinalize(uint64_t a1)
{
  unsigned __int8 v2 = *(const void **)(a1 + 328);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 32_Block_object_dispose(&STACK[0x380], 8) = 0;
  }
  *(void *)(a1 + 336) = 0;
}

uint64_t C3DCameraGetProjectionInfosPtr(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 64;
}

uint64_t C3DCameraUsesLegacyFov(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 64) >> 4) & 1;
}

float C3DCameraGetWhiteBalanceTint(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 488);
}

float C3DCameraGetWhiteBalanceTemperature(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 484);
}

float C3DCameraGetVignettingPower(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 476);
}

float C3DCameraGetSaturation(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 456);
}

uint64_t C3DCameraGetGrainIsColored(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 4) & 1;
}

float C3DCameraGetGrainIntensity(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 464);
}

float C3DCameraGetContrast(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 460);
}

float C3DCameraGetColorFringeStrength(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 452);
}

float C3DCameraGetBloomIterationSpread(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 436);
}

uint64_t C3DCameraGetBloomIteration(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(_DWORD *)(a1 + 432);
  if (v10 <= 1) {
    return 1;
  }
  else {
    return v10;
  }
}

void *C3D::PostProcessPassesCreateIfNeeded(C3D *this, C3D::RenderGraph *a2, C3D::MainPass *a3, C3D::Pass **a4)
{
  uint64_t v96 = a2;
  uint64_t v8 = *((void *)this + 1);
  uint64_t v7 = *((void *)this + 2);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v8);
  CGColorSpaceRef result = C3DEngineContextGetPointOfView(v8);
  if (result)
  {
    CGColorSpaceRef result = C3DNodeGetCamera((uint64_t)result);
    if (result)
    {
      uint64_t v11 = (uint64_t)result;
      uint64_t Aligned = C3DScratchAllocatorAllocateAligned(v7, 72, 8, 0);
      *(_OWORD *)uint64_t Aligned = 0u;
      *(_OWORD *)(Aligned + 16) = 0u;
      *(_OWORD *)(Aligned + 32) = 0u;
      *(_OWORD *)(Aligned + 4_Block_object_dispose(&STACK[0x380], 8) = 0u;
      *(void *)(Aligned + 64) = 0;
      uint64_t v95 = Aligned;
      uint64_t v13 = (float32x2_t *)(*(uint64_t (**)(C3D::RenderGraph *))(*(void *)a2 + 88))(a2);
      BOOL v14 = -[SCNMTLRenderContext contentScaleFactor](RenderContext) <= 1.0;
      float v15 = 0.0;
      if (!v14) {
        float v15 = 1.0;
      }
      *(float *)uint64_t Aligned = v15 + 1.0;
      ColorGradinguint64_t EffectSlot = C3DCameraGetColorGradingEffectSlot(v11, 0);
      char WantsHDR = C3DCameraGetWantsHDR(v11);
      *(unsigned char *)(Aligned + _Block_object_dispose(&STACK[0x380], 8) = WantsHDR;
      if (WantsHDR)
      {
        *(unsigned char *)(Aligned + 9) = C3DCameraGetWantsExposureAdaptation(v11);
        uint64_t v18 = (unsigned char *)(Aligned + 9);
        char v19 = *(unsigned char *)(Aligned + 8);
        if (v19) {
          char v19 = C3DCameraGetBloomIntensity(v11) > 0.0;
        }
      }
      else
      {
        char v19 = 0;
        *(unsigned char *)(Aligned + 9) = 0;
        uint64_t v18 = (unsigned char *)(Aligned + 9);
      }
      *(unsigned char *)(Aligned + 10) = v19;
      *(unsigned char *)(Aligned + 11) = C3DCameraGetMotionBlurIntensity(v11) > 0.0;
      if (C3DCameraGetDepthOfFieldIntensity(v11) <= 0.0) {
        char v20 = 0;
      }
      else {
        char v20 = C3DWasLinkedBeforeMajorOSYear2017() ^ 1;
      }
      *(unsigned char *)(Aligned + 12) = v20;
      BOOL v21 = C3DCameraGetColorFringeStrength(v11) > 0.0 && C3DCameraGetColorFringeIntensity(v11) != 0.0;
      *(unsigned char *)(Aligned + 13) = v21;
      *(unsigned char *)(Aligned + 14) = C3DCameraGetSaturation(v11) != 1.0;
      *(unsigned char *)(Aligned + 15) = C3DCameraGetContrast(v11) != 0.0;
      BOOL v22 = C3DCameraGetVignettingPower(v11) > 0.0 && C3DCameraGetVignettingIntensity(v11) > 0.0;
      *(unsigned char *)(Aligned + 16) = v22;
      BOOL v23 = ColorGradingEffectSlot
         && C3DEffectSlotHasImageOrTexture(ColorGradingEffectSlot)
         && C3DEffectSlotGetIntensity(ColorGradingEffectSlot) > 0.0;
      *(unsigned char *)(Aligned + 17) = v23;
      int BloomIteration = C3DCameraGetBloomIteration(v11);
      float v25 = fmax((double)(float)((float)(v13[1].f32[0] * 0.5) / *(float *)Aligned), (double)(float)((float)(v13[1].f32[1] * 0.5) / *(float *)Aligned));
      int v26 = (int)(float)(floorf(log2f(v25)) + 1.0);
      if (BloomIteration < v26) {
        int v26 = BloomIteration;
      }
      *(_DWORD *)(Aligned + 24) = v26;
      float v27 = fmaxf(C3DCameraGetBloomIterationSpread(v11), 0.0);
      float v28 = v27 + 1.0;
      _NF = v27 < 10.0;
      float v30 = 11.0;
      if (_NF) {
        float v30 = v28;
      }
      *(float *)(Aligned + 2_Block_object_dispose(&STACK[0x380], 8) = v30;
      *(unsigned char *)(Aligned + 1_Block_object_dispose(&STACK[0x380], 8) = C3DCameraGetGrainIntensity(v11) > 0.0;
      *(unsigned char *)(Aligned + 19) = C3DCameraGetGrainIsColored(v11);
      *(unsigned char *)(Aligned + 21) = -[SCNMTLRenderContext enableARMode](RenderContext);
      BOOL v31 = C3DCameraGetWhiteBalanceTemperature(v11) != 0.0 || C3DCameraGetWhiteBalanceTint(v11) != 0.0;
      *(unsigned char *)(Aligned + 22) = v31;
      if ((C3DEngineContextIsTemporalAntialiasingEnabled(v8) & 1) != 0
        || *(unsigned char *)(Aligned + 8)
        || *v18
        || *(unsigned char *)(Aligned + 10)
        || *(unsigned char *)(Aligned + 12)
        || *(unsigned char *)(Aligned + 13)
        || *(unsigned char *)(Aligned + 14)
        || *(unsigned char *)(Aligned + 15)
        || *(unsigned char *)(Aligned + 16)
        || *(unsigned char *)(Aligned + 17)
        || *(unsigned char *)(Aligned + 18)
        || *(unsigned char *)(Aligned + 22))
      {
        int v32 = 1;
      }
      else
      {
        if (!*(unsigned char *)(Aligned + 11) && !*(unsigned char *)(Aligned + 21)) {
          return 0;
        }
        int v32 = 0;
      }
      Pass = (C3D::Pass *)C3D::ScenePass::lastPass(a2);
      uint64_t StackAllocator = C3DEngineContextGetStackAllocator(v8);
      C3D::RenderGraph::getSuccessors((uint64_t)this, (uint64_t)Pass, StackAllocator, (uint64_t)v92);
      if (v32)
      {
        char v35 = C3D::RenderGraph::createPass<C3D::CompositePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
        C3D::Pass::addDependency(v35, Pass);
        uint64_t v36 = (unsigned char *)v95;
        if (*(unsigned char *)(v95 + 8))
        {
          char v37 = C3D::RenderGraph::createPass<C3D::HDRAverageLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          C3D::Pass::addDependency(v35, v37);
          uint64_t v36 = (unsigned char *)v95;
        }
        else
        {
          char v37 = 0;
        }
        if (v36[9])
        {
          unsigned __int8 v38 = C3D::RenderGraph::createPass<C3D::HDRFrameLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          char v39 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>((uint64_t)this, &v96);
          C3D::Pass::addDependency(v38, Pass);
          C3D::Pass::addDependency(v39, v38);
          C3D::Pass::addDependency(v37, v39);
          uint64_t v36 = (unsigned char *)v95;
        }
        uint64_t v91 = 0;
        if (v36[10] || v36[12])
        {
          __int16 v40 = C3D::RenderGraph::createPass<C3D::DownSampleBloomCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          uint64_t v41 = v40;
          uint64_t v91 = v40;
          float32x4_t v42 = Pass;
          if (v96 != Pass)
          {
            C3D::Pass::addDependency(v40, Pass);
            float32x4_t v42 = v96;
          }
          C3D::Pass::addDependency(v41, v42);
          uint64_t v36 = (unsigned char *)v95;
          if (*(unsigned char *)(v95 + 10))
          {
            C3D::Pass::addDependency(v41, v37);
            uint64_t v36 = (unsigned char *)v95;
            if (*(unsigned char *)(v95 + 10))
            {
              uint64_t v88 = a3;
              float BloomBlurRadius = C3DCameraGetBloomBlurRadius(v11);
              *(float *)float v90 = BloomBlurRadius / (float)(*(float *)v95 + *(float *)v95);
              float v44 = *(float *)v90;
              uint8_t v90[4] = 0;
              *(void *)&v90[6] = 0;
              uint64_t v45 = C3D::RenderGraph::createPass<C3D::GaussianBlurPass,C3D::MainPass *&,C3D::GaussianBlurPass::Parameters>((uint64_t)this, &v96, (const Parameters *)v90);
              uint64x2_t v46 = (const float *)v95;
              float32x2_t v47 = vld1_dup_f32(v46);
              float32x2_t v48 = vdiv_f32(vmul_f32(v13[1], (float32x2_t)0x3F0000003F000000), v47);
              __asm { FMOV            V1.2S, #1.0 }
              uint32x2_t v89 = vcvt_u32_f32(vmaxnm_f32(v48, _D1));
              uint64_t v53 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v45);
              uint64_t v54 = C3D::PassDescriptor::inputAtIndex(v53, 0);
              *(void *)(v54 + _Block_object_dispose(&STACK[0x380], 8) = "Bloom";
              *(_WORD *)(v54 + 1_Block_object_dispose(&STACK[0x380], 8) = v89.i16[2];
              *(_WORD *)(v54 + 16) = v89.i16[0];
              *(_DWORD *)(v54 + 20) = 0;
              *(_DWORD *)(v54 + 24) = 514;
              *(void *)(v54 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
              *(unsigned char *)(v54 + 30) = *(_DWORD *)(v95 + 24);
              int v55 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v45);
              uint64_t v56 = C3D::PassDescriptor::outputAtIndex(v55, 0);
              long long v58 = *(_OWORD *)(v54 + 16);
              long long v57 = *(_OWORD *)(v54 + 32);
              long long v59 = *(_OWORD *)(v54 + 48);
              *(_OWORD *)(v56 + 64) = *(_OWORD *)(v54 + 64);
              *(_OWORD *)uint64_t v56 = *(_OWORD *)v54;
              *(_OWORD *)(v56 + 16) = v58;
              *(_OWORD *)(v56 + 32) = v57;
              *(_OWORD *)(v56 + 4_Block_object_dispose(&STACK[0x380], 8) = v59;
              *(unsigned char *)(v56 + 65) = 0;
              *(float *)float v90 = v44;
              uint8_t v90[4] = 1;
              *(void *)&v90[6] = 0;
              uint64_t v60 = C3D::RenderGraph::createPass<C3D::GaussianBlurPass,C3D::MainPass *&,C3D::GaussianBlurPass::Parameters>((uint64_t)this, &v96, (const Parameters *)v90);
              *(void *)float v90 = v60;
              __int16 v61 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v60);
              unsigned int v62 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v61, 0);
              _OWORD *v62 = *(_OWORD *)v54;
              long long v63 = *(_OWORD *)(v54 + 64);
              long long v65 = *(_OWORD *)(v54 + 16);
              long long v64 = *(_OWORD *)(v54 + 32);
              v62[3] = *(_OWORD *)(v54 + 48);
              v62[4] = v63;
              v62[1] = v65;
              v62[2] = v64;
              uint64_t v66 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v60);
              uint64_t v67 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v66, 0);
              _OWORD *v67 = *(_OWORD *)v56;
              long long v68 = *(_OWORD *)(v56 + 64);
              long long v70 = *(_OWORD *)(v56 + 16);
              long long v69 = *(_OWORD *)(v56 + 32);
              v67[3] = *(_OWORD *)(v56 + 48);
              v67[4] = v68;
              v67[1] = v70;
              v67[2] = v69;
              C3D::Pass::addDependency(v45, v41);
              C3D::Pass::addDependency(v60, v45);
              if (*(int *)(v95 + 24) >= 2)
              {
                int v71 = C3D::RenderGraph::createPass<C3D::BloomDownSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v91, &v95);
                C3D::Pass::addDependency(v71, v60);
                uint64_t v60 = C3D::RenderGraph::createPass<C3D::BloomUpSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>((uint64_t)this, (C3D::Pass **)v90, &v95);
                C3D::Pass::addDependency(v60, v71);
              }
              a3 = v88;
              C3D::Pass::addDependency(v35, v60);
              uint64_t v36 = (unsigned char *)v95;
            }
          }
        }
        if (v36[12])
        {
          DofSampleint Count = C3DCameraGetDofSampleCount(v11);
          if (DofSampleCount <= 4) {
            int v73 = 4;
          }
          else {
            int v73 = DofSampleCount;
          }
          float v74 = sqrtf((float)v73);
          int v75 = (int)v74 * (int)v74;
          if (v75 >= 256) {
            int v75 = 256;
          }
          *(_DWORD *)(v95 + 4) = v75 - 1;
          uint64_t v76 = C3D::RenderGraph::createPass<C3D::DOFDownsampleCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          unsigned __int16 v77 = C3D::RenderGraph::createPass<C3D::DOFBlurCoCXPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          uint64_t v78 = C3D::RenderGraph::createPass<C3D::DOFBlurCoCYPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          float32x4_t v79 = C3D::RenderGraph::createPass<C3D::DOFFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          C3D::Pass::addDependency(v76, v91);
          C3D::Pass::addDependency(v77, v76);
          C3D::Pass::addDependency(v78, v77);
          C3D::Pass::addDependency(v79, v78);
          C3D::Pass::addDependency(v79, v91);
          C3D::Pass::addDependency(v35, v79);
        }
      }
      else
      {
        char v35 = 0;
      }
      if (*(unsigned char *)(v95 + 11) && *(_DWORD *)(C3D::DrawNodesPass::getCullingContext(v96) + 4920))
      {
        int v80 = C3D::RenderGraph::createPass<C3D::MBTileMaxPass,C3D::MainPass *&>((uint64_t)this, &v96);
        v90[0] = 0;
        BOOL v81 = C3D::RenderGraph::createPass<C3D::MBNeighborMaxPass,C3D::MainPass *&,BOOL>((uint64_t)this, &v96, v90);
        v90[0] = 1;
        float32x4_t v82 = C3D::RenderGraph::createPass<C3D::MBNeighborMaxPass,C3D::MainPass *&,BOOL>((uint64_t)this, &v96, v90);
        uint64_t v83 = C3D::RenderGraph::createPass<C3D::MBFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
        C3D::Pass::addDependency(v80, v96);
        C3D::Pass::addDependency(v81, v80);
        C3D::Pass::addDependency(v82, v81);
        C3D::Pass::addDependency(v83, v82);
        if (v32) {
          C3D::Pass::addDependency(v83, v35);
        }
        unsigned int v84 = Pass;
        if (v96 != Pass)
        {
          C3D::Pass::addDependency(v83, Pass);
          unsigned int v84 = v96;
        }
        C3D::Pass::addDependency(v83, v84);
      }
      else
      {
        uint64_t v83 = v35;
      }
      if (v93)
      {
        __int16 v85 = v94;
        uint64_t v86 = 8 * v93;
        do
        {
          float64x2_t v87 = *v85++;
          C3D::RenderGraph::removeDependency(this, v87, Pass);
          C3D::RenderGraph::addDependency(this, v87, v83);
          v86 -= 8;
        }
        while (v86);
      }
      if (a3) {
        *(void *)a3 = v83;
      }
      return (void *)v95;
    }
  }
  return result;
}

uint64_t C3D::MainPass::setup(C3D::MainPass *this)
{
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  PointOfView = C3DEngineContextGetPointOfView(*((void *)this + 2));
  if (!PointOfView)
  {
    if ((C3DEngineContextIsTemporalAntialiasingEnabled(*((void *)this + 2)) & 1) == 0) {
      goto LABEL_9;
    }
LABEL_7:
    int v5 = 1;
    goto LABEL_8;
  }
  CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)PointOfView);
  if (C3DEngineContextIsTemporalAntialiasingEnabled(*((void *)this + 2))) {
    goto LABEL_7;
  }
  if (!Camera)
  {
LABEL_9:
    int v5 = 0;
    goto LABEL_10;
  }
  int v5 = 0;
  if (C3DCameraGetMotionBlurIntensity((uint64_t)Camera) > 0.0) {
LABEL_8:
  }
    *((_WORD *)this + 149) |= 8u;
LABEL_10:
  C3D::Pass::parentColorDesc(*((C3D::Pass **)this + 1), (uint64_t)&v37);
  if (v38 == 2)
  {
    BOOL v6 = 1;
  }
  else
  {
    C3D::Pass::parentColorDesc(*((C3D::Pass **)this + 1), (uint64_t)v36);
    BOOL v6 = v36[8] == 4;
  }
  int v7 = C3DSceneGetWantsSSR(Scene) & v6;
  if (v7 == 1) {
    *((_WORD *)this + 149) |= 0x106u;
  }
  if (v6
    && (uint64_t RenderCallbacks = C3DEngineContextGetRenderCallbacks(*((void *)this + 2))) != 0
    && (uint64_t v9 = *(unsigned int (**)(void))(RenderCallbacks + 40)) != 0
    && v9(*((void *)this + 2)))
  {
    uint64_t v10 = *((void *)this + 3);
    char v37 = this;
    uint64_t v11 = C3D::RenderGraph::createPass<C3D::MainPassCustomPostProcessPass,C3D::MainPass *>(v10, &v37);
    uint64_t v12 = v11;
    uint64_t v13 = (C3D::Pass *)*((void *)this + 680);
    if (v13 != this) {
      C3D::Pass::addDependency(v11, v13);
    }
    C3D::Pass::addDependency(v12, this);
    *((void *)this + 680) = v12;
    if (*((unsigned char *)v12 + 240)) {
      *((_WORD *)this + 149) |= 0x80u;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  *((unsigned char *)this + 119) = 1;
  *((unsigned char *)this + 306) = C3DEngineContextGetViewpointCoordinateSpace(*((void *)this + 2));
  C3D::ScenePass::setup(this);
  if (v12)
  {
    BOOL v35 = v6;
    int v16 = v7;
    int v17 = v5;
    uint64_t v18 = *((void *)v12 + 31);
    int v19 = *((unsigned __int8 *)v12 + 240);
    uint64_t v20 = C3D::Pass::outputBufferParameterNamed(this, "COLOR");
    if (v19)
    {
      uint64_t v21 = C3D::Pass::outputBufferParameterNamed(this, "COLOR1");
      uint64_t v22 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR");
      uint64_t v23 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR1");
      BOOL v24 = v21 != 0;
      if (v21 && v18)
      {
        *(_WORD *)(v21 + 2_Block_object_dispose(&STACK[0x380], 8) = v18;
        BOOL v24 = 1;
      }
    }
    else
    {
      uint64_t v22 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR");
      BOOL v24 = 0;
      uint64_t v23 = 0;
      uint64_t v21 = 0;
    }
    int v5 = v17;
    int v7 = v16;
    BOOL v6 = v35;
    *(unsigned char *)(v22 + 31) = 0;
    *(unsigned char *)(v22 + 24) = SCNMTLTextureTypeNonMultisampledEquivalent(*(unsigned __int8 *)(v20 + 24));
    if (v23)
    {
      *(unsigned char *)(v23 + 31) = 0;
      *(unsigned char *)(v23 + 24) = SCNMTLTextureTypeNonMultisampledEquivalent(*(unsigned __int8 *)(v21 + 24));
    }
    if (*((unsigned char *)v12 + 272))
    {
      long long v25 = *((_OWORD *)v12 + 16);
      *(_WORD *)(v20 + 66) |= 0x40u;
      *(_OWORD *)(v20 + 4_Block_object_dispose(&STACK[0x380], 8) = v25;
      if (v24)
      {
        *(_WORD *)(v21 + 66) |= 0x40u;
        *(_OWORD *)(v21 + 4_Block_object_dispose(&STACK[0x380], 8) = v25;
      }
      *((unsigned char *)this + 303) = 0;
    }
  }
  if (v7) {
    *((void *)this + 680) = C3D::SSRPassesCreateIfNeeded(*((C3D **)this + 3), this, v14);
  }
  if (v5)
  {
    *((_WORD *)this + 149) |= 8u;
    uint64_t v26 = *((void *)this + 3);
    char v37 = this;
    float v27 = C3D::RenderGraph::createPass<C3D::TemporalAAPass,C3D::MainPass *>(v26, &v37);
    float v28 = v27;
    unsigned int v29 = (C3D::Pass *)*((void *)this + 680);
    if (v29 != this) {
      C3D::Pass::addDependency(v27, v29);
    }
    C3D::Pass::addDependency(v28, this);
    *((void *)this + 680) = v28;
  }
  *((void *)this + 681) = 0;
  if (v6)
  {
    char v37 = 0;
    IfNeeded = C3D::PostProcessPassesCreateIfNeeded(*((C3D **)this + 3), this, (C3D::MainPass *)&v37, v15);
    *((void *)this + 681) = IfNeeded;
    BOOL v31 = v37;
    if (!v37) {
      BOOL v31 = (C3D::Pass *)*((void *)this + 680);
    }
    *((void *)this + 680) = v31;
    if (IfNeeded)
    {
      if (IfNeeded[12]) {
        __int16 v32 = 0;
      }
      else {
        __int16 v32 = 8 * (IfNeeded[10] == 0);
      }
    }
    else
    {
      __int16 v32 = 8;
    }
    uint64_t result = C3D::PassDescriptor::outputAtIndex((C3D::MainPass *)((char *)this + 32), 1u);
    __int16 v34 = *(_WORD *)(result + 66) & 0xFFF7 | v32;
  }
  else
  {
    uint64_t result = C3D::PassDescriptor::outputAtIndex((C3D::MainPass *)((char *)this + 32), 1u);
    __int16 v34 = *(_WORD *)(result + 66) | 8;
  }
  *(_WORD *)(result + 66) = v34;
  return result;
}

uint64_t C3DEngineContextIsTemporalAntialiasingEnabled(uint64_t a1)
{
  return *(unsigned char *)(a1 + 1864) & 1;
}

uint64_t C3DSceneGetWantsSSR(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 368);
}

uint64_t _wantsMainPassCustomPostProcessEncodingEngineContextCallback(uint64_t a1)
{
  uint64_t UserInfo = C3DEngineContextGetUserInfo(a1);
  if (!UserInfo) {
    return 0;
  }
  if ((*(_WORD *)(UserInfo + 292) & 0x200) == 0)
  {
    if ((*(_WORD *)(UserInfo + 296) & 0x200) == 0) {
      return 0;
    }
    uint64_t UserInfo = *(void *)(UserInfo + 344);
  }

  return [(id)UserInfo _wantsCustomMainPassPostProcessForRenderer:UserInfo];
}

void C3D::ScenePass::setup(C3D::ScenePass *this)
{
  uint64_t v116 = *MEMORY[0x263EF8340];
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  PointOfView = C3DEngineContextGetPointOfView(*((void *)this + 2));
  if (PointOfView) {
    CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)PointOfView);
  }
  else {
    CamerSCNMatrix4 a = 0;
  }
  uint64_t v5 = (_OWORD *)(*(uint64_t (**)(void))(**((void **)this + 1) + 88))(*((void *)this + 1));
  long long v7 = v5[1];
  long long v6 = v5[2];
  *((_OWORD *)this + 337) = *v5;
  *((_OWORD *)this + 33_Block_object_dispose(&STACK[0x380], 8) = v7;
  *((_OWORD *)this + 339) = v6;
  *((unsigned char *)this + 296) = 1;
  *((unsigned char *)this + 303) = 1;
  if (Camera)
  {
    if (C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) > 0.0) {
      *((_WORD *)this + 149) |= 0x10u;
    }
    BOOL v8 = C3DCameraGetARGrainTexture((uint64_t)Camera) != 0;
    int WantsHDR = C3DCameraGetWantsHDR((uint64_t)Camera);
  }
  else
  {
    BOOL v8 = 0;
    int WantsHDR = 0;
  }
  unsigned __int16 v10 = vaddv_s16((int16x4_t)vand_s8((int8x8_t)vshl_u16((uint16x4_t)vdup_n_s16(*((unsigned __int16 *)this + 149)), (uint16x4_t)0xFFF9FFF8FFFDFFFELL), (int8x8_t)0x1000100010001))+ ((*((_WORD *)this + 149) >> 1) & 1)+ 2;
  C3D::Pass::setOutputCount(this, v10);
  uint64_t v11 = (C3D::ScenePass *)((char *)this + 32);
  uint64_t v12 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0);
  *(void *)(v12 + _Block_object_dispose(&STACK[0x380], 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)buf);
  *(_OWORD *)(v12 + 16) = *(_OWORD *)buf;
  *(_DWORD *)(v12 + 32) = v115;
  *(unsigned char *)(v12 + 65) = 0;
  *(_WORD *)(v12 + 66) = *(_WORD *)(v12 + 66) & 0xFFFC | 2;
  if (WantsHDR)
  {
    *((void *)this + 677) = 115;
    *(_WORD *)(v12 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
  }
  if (v8 || -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext))
  {
    if (-[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext))
    {
      *(_WORD *)(v12 + 66) |= 0x40u;
      *(void *)(v12 + 4_Block_object_dispose(&STACK[0x380], 8) = 0;
      *(void *)(v12 + 56) = 0;
      *((unsigned char *)this + 303) = 0;
    }
    uint64_t v13 = -[SCNMTLRenderContext sampleCount](RenderContext);
    unsigned int v14 = *(unsigned __int16 *)(v12 + 28);
    if (v14 == 554)
    {
      BOOL v15 = v13 <= 1;
      unsigned int v14 = 550;
      int v16 = 115;
    }
    else
    {
      if (v14 != 555)
      {
LABEL_22:
        *((void *)this + 677) = v14;
        goto LABEL_23;
      }
      BOOL v15 = v13 <= 1;
      unsigned int v14 = 551;
      int v16 = 553;
    }
    if (!v15) {
      unsigned int v14 = v16;
    }
    *(_WORD *)(v12 + 2_Block_object_dispose(&STACK[0x380], 8) = v14;
    goto LABEL_22;
  }
LABEL_23:
  uint64_t v17 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 1u);
  *(unsigned char *)(v17 + 64) = 2;
  *(void *)(v17 + _Block_object_dispose(&STACK[0x380], 8) = "DEPTH";
  C3D::Pass::parentDepthDesc(this, (uint64_t)buf);
  *(_OWORD *)(v17 + 16) = *(_OWORD *)buf;
  *(_DWORD *)(v17 + 32) = v115;
  *(_WORD *)(v17 + 66) = *(_WORD *)(v17 + 66) & 0xFFF4 | 0xA;
  __int16 v18 = *((_WORD *)this + 149);
  if ((v18 & 2) != 0)
  {
    uint64_t v20 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 2u);
    *(void *)(v20 + _Block_object_dispose(&STACK[0x380], 8) = "Normals";
    *(_WORD *)(v20 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
    *(_WORD *)(v20 + 1_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
    *(_WORD *)(v20 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
    *(unsigned char *)(v20 + 65) = 2;
    *(_WORD *)(v20 + 66) = *(_WORD *)(v20 + 66) & 0xFFFC | 2;
    __int16 v18 = *((_WORD *)this + 149);
    unsigned int v19 = 3;
    if ((v18 & 8) == 0)
    {
LABEL_25:
      if ((v18 & 4) == 0) {
        goto LABEL_26;
      }
      goto LABEL_31;
    }
  }
  else
  {
    unsigned int v19 = 2;
    if ((v18 & 8) == 0) {
      goto LABEL_25;
    }
  }
  uint64_t v21 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(void *)(v21 + _Block_object_dispose(&STACK[0x380], 8) = "VELOCITY";
  *(unsigned char *)(v21 + 65) = 3;
  *(_WORD *)(v21 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
  *(_WORD *)(v21 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v21 + 1_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v21 + 66) = *(_WORD *)(v21 + 66) & 0xFFBC | 0x42;
  *(_OWORD *)(v21 + 4_Block_object_dispose(&STACK[0x380], 8) = xmmword_20B5EE5B0;
  __int16 v18 = *((_WORD *)this + 149);
  if ((v18 & 4) == 0)
  {
LABEL_26:
    if ((v18 & 0x100) == 0) {
      goto LABEL_27;
    }
    goto LABEL_32;
  }
LABEL_31:
  uint64_t v22 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(void *)(v22 + _Block_object_dispose(&STACK[0x380], 8) = "ReflectanceRoughness";
  *(_WORD *)(v22 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v22 + 1_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v22 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
  *(unsigned char *)(v22 + 65) = 4;
  *(_WORD *)(v22 + 66) = *(_WORD *)(v22 + 66) & 0xFFFC | 2;
  __int16 v18 = *((_WORD *)this + 149);
  if ((v18 & 0x100) == 0)
  {
LABEL_27:
    if ((v18 & 0x80) == 0) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
LABEL_32:
  uint64_t v23 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(void *)(v23 + _Block_object_dispose(&STACK[0x380], 8) = "Radiance";
  *(_WORD *)(v23 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v23 + 1_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v23 + 2_Block_object_dispose(&STACK[0x380], 8) = 115;
  *(unsigned char *)(v23 + 65) = 5;
  *(_WORD *)(v23 + 66) = *(_WORD *)(v23 + 66) & 0xFFFC | 2;
  if ((*((_WORD *)this + 149) & 0x80) != 0)
  {
LABEL_33:
    uint64_t v24 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
    *(void *)(v24 + _Block_object_dispose(&STACK[0x380], 8) = "COLOR1";
    *(_WORD *)(v24 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
    *(_WORD *)(v24 + 1_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
    *(_WORD *)(v24 + 2_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 28);
    *(unsigned char *)(v24 + 65) = 1;
    *(_WORD *)(v24 + 66) = *(_WORD *)(v24 + 66) & 0xFFFC | 2;
  }
LABEL_34:
  if (-[SCNMTLRenderContext sampleCount](RenderContext) >= 2)
  {
    uint64_t v25 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 24);
    if (!SCNMTLTextureTypeIsMultisampled(v25))
    {
      char v26 = SCNMTLTextureTypeMultisampledEquivalent(v25);
      LOWORD(v27) = 0;
      do
      {
        *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), (unsigned __int16)v27) + 24) = v26;
        char v28 = -[SCNMTLRenderContext sampleCount](RenderContext);
        *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), (unsigned __int16)v27) + 31) = v28;
        unsigned int v27 = (v27 + 1);
      }
      while (v27 < v10);
    }
  }
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 2));
  C3DStackAllocatorPushFrame(StackAllocator);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v113, StackAllocator);
  *((void *)this + 671) = v113;
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v112, StackAllocator);
  *((void *)this + 672) = v112;
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(&v110, StackAllocator);
  uint64_t v106 = 0;
  float32x4_t v107 = &v106;
  uint64_t v108 = 0x2020000000;
  long long v109 = &v110;
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v105, StackAllocator);
  v104[0] = 0;
  v104[1] = v104;
  v104[2] = 0x2020000000;
  v104[3] = v105;
  if (*(unsigned char *)(v12 + 24) == 5)
  {
    char v30 = -[SCNMTLRenderContext features](RenderContext);
    *((unsigned char *)this + 117) = (v30 & 0x20) != 0;
    if ((v30 & 0x20) != 0) {
      char PreferredMultiVertexOutputStreamGenerator = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((void *)this + 2));
    }
    else {
      char PreferredMultiVertexOutputStreamGenerator = 0;
    }
    *((unsigned char *)this + 11_Block_object_dispose(&STACK[0x380], 8) = PreferredMultiVertexOutputStreamGenerator;
    *((_WORD *)this + 19) = 6;
  }
  else if (C3DEngineContextGetEyeCount(*((void *)this + 2)) > 1 {
         || -[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext))
  }
  {
    *((_WORD *)this + 19) = C3DEngineContextGetEyeCount(*((void *)this + 2));
    int PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(*((void *)this + 2));
    *((unsigned char *)this + 117) = PreferredRenderMode;
    if (PreferredRenderMode) {
      LOBYTE(PreferredRenderMode) = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((void *)this + 2));
    }
    *((unsigned char *)this + 11_Block_object_dispose(&STACK[0x380], 8) = PreferredRenderMode;
    *((unsigned char *)this + 120) = 1;
  }
  C3D::DrawNodesPass::setup(this);
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  LightingSysteCFIndex m = (const __CFDictionary *)C3DSceneGetLightingSystem(Scene);
  float v35 = *((double *)this + 633);
  float v36 = *((double *)this + 634);
  C3DLightingSystemSetMainRenderingFrustums((uint64_t)LightingSystem, (_OWORD *)this + 21, v35, v36, *((unsigned __int8 *)this + 4948), (long long *)this + 57, (long long *)this + 189);
  uint64_t v100 = 0;
  uint64x2_t v101 = &v100;
  uint64_t v102 = 0x2020000000;
  uint64_t v103 = 0;
  C3D::RenderGraph::getSuccessors(*((void *)this + 3), (uint64_t)this, StackAllocator, (uint64_t)v97);
  uint64_t v37 = *((void *)this + 2);
  v96[0] = MEMORY[0x263EF8330];
  v96[1] = 3221225472;
  v96[2] = ___ZN3C3D9ScenePass5setupEv_block_invoke;
  v96[3] = &unk_264009648;
  v96[4] = &v100;
  v96[5] = &v106;
  v96[6] = v104;
  v96[7] = this;
  C3DLightingSystemEnumerateGlobalLights(LightingSystem, v37, (uint64_t)v96);
  *((void *)this + 673) = CreateProbeArrayResourceIfNeeded(this, v107[3]);
  uint64_t v39 = v101[3];
  if (v39)
  {
    *((void *)this + 680) = v39;
    if (v98)
    {
      __int16 v40 = v99;
      uint64_t v41 = 8 * v98;
      do
      {
        float32x4_t v42 = *v40;
        C3D::RenderGraph::removeDependency(*((C3D::RenderGraph **)this + 3), *v40, this);
        C3D::RenderGraph::addDependency(*((C3D::RenderGraph **)this + 3), v42, (const C3D::Pass *)v101[3]);
        ++v40;
        v41 -= 8;
      }
      while (v41);
    }
  }
  if (C3D::SSAOPassesCreateIfNeeded(*((C3D **)this + 3), this, v38))
  {
    uint64_t v43 = (*(uint64_t (**)(C3D::ScenePass *))(*(void *)this + 88))(this);
    C3D::PassIODescriptor::PassIODescriptor((uint64_t)buf, *(void *)(v43 + 32));
    *(void *)&buf[8] = "SSAO-Final";
    C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, (uint64_t)buf);
  }
  uint64_t v44 = *((void *)this + 671);
  uint64_t v45 = *(unsigned int *)(v44 + 8);
  if (v45)
  {
    uint64x2_t v46 = *(C3D::FloorPass ***)(v44 + 16);
    uint64_t v47 = 8 * v45;
    do
    {
      float32x2_t v48 = *v46;
      uint64_t v49 = C3D::FloorPass::mirrorNode(*v46);
      uint64_t Floor = C3DNodeGetFloor(v49);
      if (C3DFloorGetReflectivity(Floor) > 0.0)
      {
        C3D::Pass::addDependency(this, *((C3D::Pass **)v48 + 680));
        float64x2_t v51 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*((C3D::Pass **)v48 + 680));
        uint64_t v52 = C3D::PassDescriptor::outputAtIndex(v51, 0);
        C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v52);
        *(unsigned char *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 24) = 2;
        *(unsigned char *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 31) = 0;
        if (C3DFloorGetReflectionFalloffEnd(Floor) != 0.0)
        {
          uint64_t v53 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v48);
          uint64_t v54 = C3D::PassDescriptor::outputAtIndex(v53, 1u);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v54);
          *(unsigned char *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 24) = 2;
          *(unsigned char *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 31) = 0;
        }
      }
      ++v46;
      v47 -= 8;
    }
    while (v47);
  }
  uint64_t v55 = *((void *)this + 672);
  unsigned int v56 = *(_DWORD *)(v55 + 8);
  if (v56 >= 2)
  {
    unsigned int v57 = 0;
    unsigned int v58 = v56 >> 1;
    unsigned int v59 = v56 - 1;
    do
    {
      uint64_t v60 = (uint64_t *)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](*((void *)this + 672), v57);
      __int16 v61 = (uint64_t *)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](*((void *)this + 672), v59);
      uint64_t v62 = *v60;
      uint64_t *v60 = *v61;
      *__int16 v61 = v62;
      ++v57;
      --v59;
    }
    while (v58 != v57);
    uint64_t v55 = *((void *)this + 672);
    unsigned int v56 = *(_DWORD *)(v55 + 8);
  }
  if (v56)
  {
    long long v63 = 0;
    long long v64 = 0;
    long long v65 = *(C3D ***)(v55 + 16);
    uint64_t v66 = 8 * v56;
    do
    {
      uint64_t v67 = *v65;
      uint64_t v94 = this;
      uint64_t v95 = v67;
      long long v68 = (C3D::Pass **)C3D::RenderGraph::createPass<C3D::CIFilterPass,C3D::ScenePass *,__C3DNode *&>(*((void *)this + 3), &v94, (__C3DNode **)&v95);
      if (v64)
      {
        if (C3DNodeIsAncestor((uint64_t)v64, (uint64_t)v95))
        {
          if (!v63)
          {
            long long v69 = scn_default_log();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT)) {
              C3D::ScenePass::setup(buf, &buf[4], v69);
            }
          }
          C3D::Pass::addDependency(v68[16], (C3D::Pass *)v63);
          C3D::Pass::addDependency(v68[16], v63[16]);
        }
        else
        {
          C3D::Pass::addDependency(this, (C3D::Pass *)v63);
          C3D::Pass::addDependency(this, v63[16]);
          long long v70 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v63);
          uint64_t v71 = C3D::PassDescriptor::outputAtIndex(v70, 0);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v71);
          uint64_t v72 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v63[16]);
          uint64_t v73 = C3D::PassDescriptor::outputAtIndex(v72, 1u);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v73);
        }
      }
      uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
      uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
      RendererElementunint64_t Span = C3DNodeGetRendererElementSpan((uint64_t)v95);
      uint64_t ElementInSpanAtIndex = C3DRendererElementStoreGetElementInSpanAtIndex(RendererElementStore, RendererElementSpan, (HIDWORD(RendererElementSpan) - 1));
      uint64_t v79 = *(void *)(ElementInSpanAtIndex + 40);
      if (!v79 || C3DFXTechniqueGetPassCount(v79) != 1)
      {
        CIFilterQuadBlenduint64_t Technique = (const void *)C3D::CreateCIFilterQuadBlendTechnique(v95, *((__C3DNode **)this + 2), v77);
        BOOL v81 = *(const void **)(ElementInSpanAtIndex + 40);
        if (v81 != CIFilterQuadBlendTechnique)
        {
          if (v81)
          {
            CFRelease(v81);
            *(void *)(ElementInSpanAtIndex + 40) = 0;
          }
          if (CIFilterQuadBlendTechnique) {
            CFTypeRef v82 = CFRetain(CIFilterQuadBlendTechnique);
          }
          else {
            CFTypeRef v82 = 0;
          }
          *(void *)(ElementInSpanAtIndex + 40) = v82;
        }
        CFRelease(CIFilterQuadBlendTechnique);
      }
      long long v64 = v95;
      ++v65;
      long long v63 = v68;
      v66 -= 8;
    }
    while (v66);
    if (v95)
    {
      C3D::Pass::addDependency(this, (C3D::Pass *)v68);
      C3D::Pass::addDependency(this, v68[16]);
      uint64_t v83 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v68);
      uint64_t v84 = C3D::PassDescriptor::outputAtIndex(v83, 0);
      C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v84);
      __int16 v85 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v68[16]);
      uint64_t v86 = C3D::PassDescriptor::outputAtIndex(v85, 1u);
      C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v86);
    }
  }
  int v87 = (unsigned __int16)v111;
  C3D::Pass::setInputCount(this, (unsigned __int16)v111);
  if (v87)
  {
    for (unsigned int i = 0; i != v87; ++i)
    {
      uint32x2_t v89 = (_OWORD *)C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::operator[]((uint64_t)&v110, i);
      float v90 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v11, (unsigned __int16)i);
      _OWORD *v90 = *v89;
      long long v91 = v89[1];
      long long v92 = v89[2];
      long long v93 = v89[4];
      v90[3] = v89[3];
      uint8_t v90[4] = v93;
      v90[1] = v91;
      v90[2] = v92;
    }
  }
  C3DStackAllocatorPopFrame(StackAllocator);
  _Block_object_dispose(&v100, 8);
  _Block_object_dispose(v104, 8);
  _Block_object_dispose(&v106, 8);
}

void sub_20B2B1AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void *C3D::RenderGraph::GraphNode::successorsAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(a4, a3);
  uint64_t v8 = *(unsigned int *)(a1 + 40);
  if (v8)
  {
    uint64_t v9 = *(int **)(a1 + 48);
    uint64_t v10 = 4 * v8;
    do
    {
      int v11 = *v9;
      if (a2 == BYTE2(v11)) {
        uint64_t result = C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(a4, &v11);
      }
      ++v9;
      v10 -= 4;
    }
    while (v10);
  }
  return result;
}

void *C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  a1[2] = a1 + 3;
  if (!a2)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return a1;
}

_DWORD *C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(_DWORD *result, _DWORD *a2)
{
  uint64_t v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  uint64_t v6 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    uint64_t Aligned = C3DStackAllocatorAllocateAligned(*(void *)result, 4 * v7, 4, 0);
    uint64_t result = memcpy(Aligned, v6, 4 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v7;
    uint64_t v6 = Aligned;
    unsigned int v4 = v3[2];
  }
  *((_DWORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

float C3D::Pass::parentColorDesc@<S0>(C3D::Pass *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (*(uint64_t (**)(C3D::Pass *))(*(void *)this + 88))(this);
  LODWORD(result) = HIDWORD(*(_OWORD *)v3);
  *(_WORD *)a2 = (int)COERCE_FLOAT(*(void *)(v3 + 8));
  *(_WORD *)(a2 + 2) = (int)result;
  *(_DWORD *)(a2 + 4) = 0;
  uint64_t v5 = *(void *)(v3 + 24);
  *(unsigned char *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = *(void *)(v3 + 32);
  *(_WORD *)(a2 + 9) = 2;
  *(unsigned char *)(a2 + 11) = 0;
  *(_DWORD *)(a2 + 12) = (unsigned __int16)v5;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}

uint64_t C3D::FinalPass::drawableInfo(C3D::FinalPass *this)
{
  return (uint64_t)this + 128;
}

uint64_t C3D::ScenePass::drawableInfo(C3D::ScenePass *this)
{
  return (uint64_t)this + 5392;
}

uint64_t C3DCameraGetWantsHDR(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 1) & 1;
}

uint64_t C3DCameraGetARGrainTexture(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 544);
}

float C3D::Pass::parentDepthDesc@<S0>(C3D::Pass *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (*(uint64_t (**)(C3D::Pass *))(*(void *)this + 88))(this);
  long long v4 = *(_OWORD *)v3;
  *(_WORD *)a2 = (int)COERCE_FLOAT(*(void *)(v3 + 8));
  float result = *((float *)&v4 + 3);
  *(_WORD *)(a2 + 2) = (int)*((float *)&v4 + 3);
  *(_DWORD *)(a2 + 4) = 0;
  *(unsigned char *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = *(void *)(v3 + 32);
  *(_WORD *)(a2 + 9) = 2;
  *(unsigned char *)(a2 + 11) = 0;
  *(void *)(a2 + 12) = 252;
  return result;
}

void *C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  a1[2] = a1 + 4;
  if (!a2)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return a1;
}

void C3D::Pass::setOutputCount(C3D::Pass *this, unsigned int a2)
{
  *((_WORD *)this + 37) = a2;
  *((_WORD *)this + 49) = a2;
  if (a2)
  {
    uint64_t v4 = *(void *)(*((void *)this + 3) + 16);
    uint64_t v5 = a2;
    uint64_t v6 = (*(uint64_t (**)(C3D::Pass *))(*(void *)this + 88))(this);
    *((void *)this + _Block_object_dispose(&STACK[0x380], 8) = C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(v4, v5, (uint64_t *)(v6 + 32));
    size_t v7 = 8 * a2;
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)(*((void *)this + 3) + 16), v7, 8, 0);
    bzero(Aligned, v7);
    *((void *)this + 11) = Aligned;
    size_t v9 = 8 * *((unsigned __int16 *)this + 49);
    bzero(Aligned, v9);
  }
}

uint64_t C3D::SSAOPassesCreateIfNeeded(C3D *this, C3D::RenderGraph *a2, C3D::DrawNodesPass *a3)
{
  uint64_t v22 = a2;
  uint64_t Aligned = C3DScratchAllocatorAllocateAligned(*((void *)this + 2), 24, 8, 0);
  *(void *)(Aligned + _Block_object_dispose(&STACK[0x380], 8) = 0;
  *(void *)(Aligned + 16) = 0;
  *(void *)uint64_t Aligned = 0;
  uint64_t v21 = Aligned;
  uint64_t v6 = *((void *)this + 1);
  PointOfView = C3DEngineContextGetPointOfView(v6);
  if (!PointOfView) {
    return 0;
  }
  CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)PointOfView);
  if (!Camera) {
    return 0;
  }
  uint64_t v9 = (uint64_t)Camera;
  if (C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) <= 0.0) {
    return 0;
  }
  if (C3DCameraGetScreenSpaceAmbientOcclusionDownSample(v9) >= 4) {
    int v10 = 4;
  }
  else {
    int v10 = 2;
  }
  *(_DWORD *)(Aligned + _Block_object_dispose(&STACK[0x380], 8) = C3DCameraGetScreenSpaceAmbientOcclusionSampleCount(v9);
  *(_DWORD *)(Aligned + 12) = v10;
  *(unsigned char *)(Aligned + 16) = C3DCameraGetUsesOrthographicProjection(v9);
  *(void *)uint64_t Aligned = a2;
  *(unsigned char *)(Aligned + 17) = C3DEngineContextGetPreferredRenderMode(v6) != 0;
  int v11 = C3D::RenderGraph::createPass<C3D::SSAODepthNormalPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v22, &v21);
  uint64_t v12 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>((uint64_t)this, &v22);
  uint64_t v13 = C3D::RenderGraph::createPass<C3D::SSAOMinMaxOffsetPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v22, &v21);
  unsigned int v14 = C3D::RenderGraph::createPass<C3D::SSAORaytracePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v22, &v21);
  char v20 = 0;
  BOOL v15 = C3D::RenderGraph::createPass<C3D::SSAOBlurPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&,BOOL>((uint64_t)this, &v22, &v21, &v20);
  uint64_t v16 = 1;
  char v20 = 1;
  uint64_t v17 = C3D::RenderGraph::createPass<C3D::SSAOBlurPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&,BOOL>((uint64_t)this, &v22, &v21, &v20);
  __int16 v18 = C3D::RenderGraph::createPass<C3D::SSAOUpSamplePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v22, &v21);
  C3D::Pass::addDependency(v12, v11);
  C3D::Pass::addDependency(v13, v11);
  C3D::Pass::addDependency(v14, v12);
  C3D::Pass::addDependency(v14, v13);
  C3D::Pass::addDependency(v15, v14);
  C3D::Pass::addDependency(v17, v15);
  C3D::Pass::addDependency(v18, v17);
  C3D::Pass::addDependency(v18, v11);
  C3D::Pass::addDependency(v22, v18);
  return v16;
}

float C3DCameraGetScreenSpaceAmbientOcclusionIntensity(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 492);
}

void C3D::DrawNodesPass::setup(C3D::DrawNodesPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  if (-[SCNMTLRenderContext disableLinearRendering](RenderContext)) {
    *((_WORD *)this + 149) |= 1u;
  }
  uint64_t v3 = (*(uint64_t (**)(C3D::DrawNodesPass *))(*(void *)this + 64))(this);
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * (v3 ^ 0xD2066E14D2E75C53)) ^ 0x73)) ^ ((0xC6A4A7935BD1E995
                                                                                                 * ((0xC6A4A7935BD1E995 * (v3 ^ 0xD2066E14D2E75C53)) ^ 0x73)) >> 47));
  uint64_t v5 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v4 ^ (v4 >> 47));
  *((void *)this + 66_Block_object_dispose(&STACK[0x380], 8) = v5;
  if (!v5) {
    operator new();
  }
  if (!C3D::PassDescriptor::outputCount((C3D::DrawNodesPass *)((char *)this + 32)))
  {
    C3D::Pass::setOutputCount(this, 2u);
    uint64_t v6 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 0);
    *(void *)(v6 + _Block_object_dispose(&STACK[0x380], 8) = "COLOR";
    C3D::Pass::parentColorDesc(this, (uint64_t)&v35);
    *(_OWORD *)(v6 + 16) = v35;
    *(_DWORD *)(v6 + 32) = v36;
    *(unsigned char *)(v6 + 65) = 0;
    *(_WORD *)(v6 + 66) = *(_WORD *)(v6 + 66) & 0xFFFC | 2;
    uint64_t v7 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 1u);
    *(unsigned char *)(v7 + 64) = 2;
    *(void *)(v7 + _Block_object_dispose(&STACK[0x380], 8) = "DEPTH";
    C3D::Pass::parentDepthDesc(this, (uint64_t)&v35);
    *(_OWORD *)(v7 + 16) = v35;
    *(_DWORD *)(v7 + 32) = v36;
    *(_WORD *)(v7 + 66) = *(_WORD *)(v7 + 66) & 0xFFF4 | 0xA;
  }
  uint64_t v8 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 0);
  if (*(unsigned __int8 *)(v8 + 64) - 1 >= 2)
  {
    uint64_t v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
      C3D::DrawNodesPass::setup(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  if (SCNMTLTextureTypeIsCube(*(unsigned __int8 *)(v8 + 24)))
  {
    *((unsigned char *)this + 302) = 1;
    char v17 = -[SCNMTLRenderContext features](RenderContext);
    *((unsigned char *)this + 117) = (v17 & 0x20) != 0;
    if ((v17 & 0x20) != 0) {
      char PreferredMultiVertexOutputStreamGenerator = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((void *)this + 2));
    }
    else {
      char PreferredMultiVertexOutputStreamGenerator = 0;
    }
    *((unsigned char *)this + 11_Block_object_dispose(&STACK[0x380], 8) = PreferredMultiVertexOutputStreamGenerator;
    *((_WORD *)this + 19) = 6;
  }
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  __n128 v20 = C3D::DrawNodesPass::_setupCullingContext((__n128 *)this);
  unint64_t v21 = *((void *)this + 34);
  if (v21)
  {
    uint64_t v22 = *(unsigned int *)(v21 + 8);
    if (v22)
    {
      uint64_t v23 = *(float32x4_t ***)(v21 + 16);
      uint64_t v24 = &v23[v22];
      LODWORD(v21) = *((unsigned __int16 *)this + 19);
      do
      {
        if (v21)
        {
          unint64_t v25 = 0;
          char v26 = *v23;
          do
          {
            if ((*(unsigned int (**)(C3D::DrawNodesPass *, float32x4_t *, unint64_t, __n128))(*(void *)this + 120))(this, v26, v25, v20))
            {
              C3DCullingContextForcePushGeometryRenderableElementsToVisible((float32x4_t *)this + 20, v25, v26);
            }
            ++v25;
            unint64_t v21 = *((unsigned __int16 *)this + 19);
          }
          while (v25 < v21);
        }
        ++v23;
      }
      while (v23 != v24);
    }
  }
  else
  {
    C3DCullingContextCull((uint64_t)this + 320);
    ParticleManager = C3DSceneGetParticleManager(Scene, 0);
    if (*(unsigned char *)(C3D::Pass::descriptor(this) + 12))
    {
      uint64_t Stats = C3DEngineContextGetStats(*((void *)this + 2));
      double v29 = CACurrentMediaTime();
      LightingSysteCFIndex m = C3DSceneGetLightingSystem(Scene);
      unsigned int v31 = *((unsigned __int16 *)this + 19);
      if (*((_WORD *)this + 19))
      {
        uint64_t v32 = LightingSystem;
        unint64_t v33 = 0;
        __int16 v34 = (char *)this + 3408;
        do
        {
          if (ParticleManager)
          {
            C3DLightingSystemBeginQueries(v32, (uint64_t)v34, *((void *)this + 2));
            C3DParticleManagerCull((uint64_t)ParticleManager, (uint64_t)this + 320, *((void *)this + 2), v33, *((unsigned __int8 *)this + 117), *((unsigned __int8 *)this + 118));
            C3DLightingSystemEndQueries(v32);
            unsigned int v31 = *((unsigned __int16 *)this + 19);
          }
          ++v33;
          v34 += 64;
        }
        while (v33 < v31);
      }
      *(double *)(Stats + 120) = *(double *)(Stats + 120) + CACurrentMediaTime() - v29;
    }
  }
}

void *C3DSceneGetParticleManager(uint64_t a1, int a2)
{
  if (!a1)
  {
    unint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float result = *(void **)(a1 + 88);
  if (result) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a2 == 0;
  }
  if (!v13)
  {
    float result = C3DParticleManagerCreate(a1);
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x380], 8) = result;
  }
  return result;
}

__n128 C3D::DrawNodesPass::_setupCullingContext(__n128 *this)
{
  unsigned __int8 v2 = &this[309].n128_u8[4];
  uint64_t RenderContext = C3DEngineContextGetRenderContext(this[1].n128_i64[0]);
  uint64_t Scene = C3DEngineContextGetScene(this[1].n128_i64[0]);
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  if (!this[18].n128_u8[12] && -[SCNMTLRenderContext textureTarget](RenderContext)) {
    this[18].n128_u8[14] = (unint64_t)([(id)-[SCNMTLRenderContext textureTarget](RenderContext) textureType]- 5) < 2;
  }
  v2[66] = 0;
  uint64_t v6 = this[1].n128_i64[0];
  this[316].n128_u64[0] = v6;
  BOOL v7 = (C3DEngineContextIsWarmUp(v6) & 1) != 0 || this[17].n128_u64[0] || this[19].n128_u8[0] != 0;
  v2[64] = v7;
  this[20].n128_u64[0] = EnginePipeline;
  this[315].n128_u64[1] = Scene;
  *unsigned __int8 v2 = this[2].n128_u8[6];
  v2[3] = this[7].n128_u8[5];
  uint64_t RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  Elementint Count = C3DRendererElementStoreGetElementCount(RendererElementStore);
  if (this[2].n128_u16[3])
  {
    unsigned __int32 v10 = ElementCount;
    unint64_t v11 = 0;
    size_t v12 = 4 * ElementCount;
    BOOL v13 = &this[327].n128_u32[3];
    do
    {
      uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)(this[1].n128_u64[1] + 16), v12, 2, 0);
      bzero(Aligned, v12);
      *(void *)(v13 - 3) = Aligned;
      *(v13 - 1) = 0;
      *BOOL v13 = v10;
      ++v11;
      unint64_t v15 = this[2].n128_u16[3];
      v13 += 4;
    }
    while (v11 < v15);
    BOOL v16 = v15 == 2;
  }
  else
  {
    BOOL v16 = 0;
  }
  BOOL v17 = 0;
  v2[4] = this[18].n128_u8[14];
  this[311].n128_u64[0] = this[15].n128_u64[0];
  this[311].n128_u64[1] = (unint64_t)this;
  this[333].n128_u64[1] = (unint64_t)C3D::drawNodesPassShouldPushRenderableElementsToVisible;
  v2[65] = this[18].n128_u8[8];
  v2[380] = 0;
  v2[2] = this[2].n128_u32[3];
  if (v16) {
    BOOL v17 = this[7].n128_u8[5] == 2;
  }
  v2[68] = v17;
  v2[69] = this[19].n128_u8[2];
  unint64_t v18 = this[16].n128_u64[1];
  this[312].n128_u64[0] = v18;
  if (!v18)
  {
    if (!Scene)
    {
      unsigned int v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        C3DSceneCreateHitTestResultsWithSegment_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
      }
    }
    this[312].n128_u64[0] = C3DSceneGetRootNode(Scene);
  }
  v2[60] = this[18].n128_u8[13];
  uint64_t v27 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)&this[2], 0);
  if (this[7].n128_u8[9])
  {
    ViewportAtunsigned int Index = this[8];
  }
  else if (this[7].n128_u8[8] || this[19].n128_u8[1])
  {
    ViewportAtunsigned int Index = C3DEngineContextGetViewportAtIndex(this[1].n128_i64[0], 0);
  }
  else
  {
    v41.i32[0] = *(unsigned __int16 *)(v27 + 16);
    v41.i32[1] = *(unsigned __int16 *)(v27 + 18);
    float32x2_t v42 = vcvt_f32_u32(v41);
    ViewportAtIndex.n128_u64[0] = 0;
    *(float32x2_t *)&ViewportAtIndex.n128_i8[8] = v42;
  }
  this[310] = ViewportAtIndex;
  uint64_t v29 = this[15].n128_i64[1];
  PointOfViewForCulling = (float32x4_t *)v29;
  if (v29
    || (PointOfViewForCulling = C3DEngineContextGetPointOfViewForCulling(this[1].n128_i64[0]),
        (uint64_t v29 = this[15].n128_i64[1]) != 0))
  {
    v2[61] = this[18].n128_u8[12];
  }
  else
  {
    PointOfView = C3DEngineContextGetPointOfView(this[1].n128_i64[0]);
    this[15].n128_u64[1] = (unint64_t)PointOfView;
    v2[61] = this[18].n128_u8[12];
    if (!PointOfView)
    {
      C3DCullingContextSetupMatricesToIdentity((uint64_t)&this[20]);
      goto LABEL_28;
    }
    uint64_t v29 = (uint64_t)PointOfView;
  }
  C3D::DrawNodesPass::_setupPointOfView(this, v29, (uint64_t)PointOfViewForCulling, (uint64_t)&this[310]);
LABEL_28:
  this[315].n128_u64[0] = C3DEngineContextGetAuthoringEnvironment(this[1].n128_i64[0], 0);
  this[314].n128_u64[0] = this[17].n128_u64[1];
  this[314].n128_u64[0] &= C3DGetPovCategoryMask((uint64_t)PointOfViewForCulling);
  this[314].n128_u64[1] = this[18].n128_u64[0];
  *((_WORD *)v2 + 31) = 0;
  uint64_t v31 = this[15].n128_i64[1];
  if (v31)
  {
    CFDictionaryRef Light = C3DNodeGetLight(v31);
    if (Light)
    {
      if (C3DLightGetType((uint64_t)Light) == 4) {
        *((_WORD *)v2 + 31) = 256;
      }
    }
  }
  result.n128_f64[0] = C3DCullingContextSetupLOD((uint64_t)&this[20], (__n128 *)this[1].n128_u64[0]);
  if (*v2)
  {
    uint64_t v34 = 0;
    unint64_t v35 = 0;
    do
    {
      unint64_t v36 = this[334].n128_u64[0] + v34 * 16;
      uint64_t v37 = &this[v34 + 285];
      __n128 result = *(__n128 *)(v36 + 16);
      __n128 v38 = *(__n128 *)(v36 + 32);
      __n128 v39 = *(__n128 *)(v36 + 64);
      v37[2] = *(__n128 *)(v36 + 48);
      v37[3] = v39;
      *uint64_t v37 = result;
      v37[1] = v38;
      ++v35;
      v34 += 4;
    }
    while (v35 < *v2);
  }
  return result;
}

uint64_t C3DEngineContextIsWarmUp(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 461);
}

float32x4_t *C3DEngineContextGetPointOfViewForCulling(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  __n128 result = *(float32x4_t **)(a1 + 32);
  if (!result) {
    return C3DEngineContextGetPointOfView(a1);
  }
  return result;
}

float32x4_t *C3DEngineContextGetPointOfView(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t DefaultPointOfView = *(float32x4_t **)(a1 + 24);
  if (!DefaultPointOfView)
  {
    uint64_t DefaultPointOfView = (float32x4_t *)C3DEngineContextGetDefaultPointOfView(a1);
    if (!DefaultPointOfView)
    {
      uint64_t Scene = C3DEngineContextGetScene(a1);
      if (Scene && (size_t v12 = (__n128 *)Scene, (RootNode = C3DSceneGetRootNode(Scene)) != 0))
      {
        CFArrayRef v14 = C3DNodeCopyNodesWithAttribute(RootNode, @"kCameraKey", 1);
        CFArrayRef v15 = v14;
        if (v14 && CFArrayGetCount(v14) >= 1)
        {
          uint64_t DefaultPointOfView = (float32x4_t *)CFArrayGetValueAtIndex(v15, 0);
          C3DEngineContextSetPointOfView(a1, DefaultPointOfView);
          if (!*(void *)(a1 + 24))
          {
            BOOL v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
              C3DEngineContextGetPointOfView_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
            }
          }
LABEL_21:
          CFRelease(v15);
          return DefaultPointOfView;
        }
        CFDictionaryRef RenderingOptionForKey = C3DEngineContextGetRenderingOptionForKey(a1, @"defaultCamera");
        if (RenderingOptionForKey && !CFEqual(RenderingOptionForKey, (CFTypeRef)*MEMORY[0x263EFFB40]))
        {
          uint64_t DefaultPointOfView = 0;
        }
        else
        {
          uint64_t DefaultPointOfView = (float32x4_t *)C3DEngineContextGetDefaultPointOfView(a1);
          if (!DefaultPointOfView)
          {
            uint64_t DefaultPointOfView = C3DCreateDefaultCameraNode(v12, 0);
            if (DefaultPointOfView)
            {
              C3DEngineContextSetDefaultPointOfView(a1, DefaultPointOfView);
              CFRelease(DefaultPointOfView);
            }
          }
        }
        if (v15) {
          goto LABEL_21;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return DefaultPointOfView;
}

uint64_t C3DCameraGetCategoryBitMask(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 528);
}

void C3D::FinalPass::setup(C3D::FinalPass *this)
{
  *((_DWORD *)this + _Block_object_dispose(&STACK[0x380], 8) = 5;
  unsigned __int8 v2 = (C3D::FinalPass *)((char *)this + 32);
  *((_OWORD *)this + _Block_object_dispose(&STACK[0x380], 8) = xmmword_20B5CBCA0;
  *((void *)this + 20) = 2;
  uint64_t v3 = *((void *)this + 2);
  *((void *)v2 + 15) = **((void **)v2 - 1);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
  if (-[SCNMTLRenderContext textureTarget](RenderContext))
  {
    uint64_t v5 = (void *)-[SCNMTLRenderContext textureTarget](RenderContext);
    *((float *)this + 36) = (float)(unint64_t)[v5 width];
    *((float *)this + 37) = (float)(unint64_t)[v5 height];
    *((void *)this + 20) = [v5 textureType];
    *((float *)this + 34) = (float)(unint64_t)[v5 width];
    *((float *)this + 35) = (float)(unint64_t)[v5 height];
  }
  else
  {
    if (!-[SCNMTLRenderContext layerTarget](RenderContext)) {
      goto LABEL_6;
    }
    [(id)-[SCNMTLRenderContext layerTarget](RenderContext) drawableSize];
    *(float *)&double v6 = v6;
    *((float *)this + 36) = floorf(*(float *)&v6);
    [(id)-[SCNMTLRenderContext layerTarget](RenderContext) drawableSize];
    float v8 = v7;
    *((float *)this + 37) = floorf(v8);
    *((float32x4_t *)this + _Block_object_dispose(&STACK[0x380], 8) = vrndmq_f32((float32x4_t)C3DEngineContextGetViewport((__n128 *)*((void *)this + 2)));
    uint64_t v5 = (void *)-[SCNMTLRenderContext layerTarget](RenderContext);
  }
  *((void *)this + 19) = [v5 pixelFormat];
LABEL_6:
  long long v106 = *((_OWORD *)this + 8);
  float SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(*((void *)this + 2));
  int8x16_t v10 = *((int8x16_t *)this + 8);
  v10.u64[1] = (unint64_t)vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), SuperSamplingFactor);
  int8x16_t v107 = v10;
  *((int8x16_t *)this + _Block_object_dispose(&STACK[0x380], 8) = v10;
  C3D::Pass::setInputCount(this, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex(v2, 0) + _Block_object_dispose(&STACK[0x380], 8) = "COLOR";
  long long v117 = 0;
  uint64_t v118 = 0;
  uint64_t v11 = C3D::RenderGraph::finalTechnique(*((C3D::RenderGraph **)this + 3));
  if (!v11)
  {
    uint64_t v60 = *((void *)this + 3);
    *(void *)&long long v108 = this;
    __int16 v61 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v60, (C3D::Pass **)&v108);
    long long v117 = v61;
    goto LABEL_45;
  }
  uint64_t v12 = v11;
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 2));
  C3DStackAllocatorPushFrame(StackAllocator);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v114, StackAllocator);
  CFArrayRef v14 = C3D::FinalPass::_createCustomTechniquePassesIfNeeded((uint64_t *)this, v12, &v114, &v118);
  uint64_t v105 = StackAllocator;
  if (v118)
  {
    if ((*(unsigned char *)(v12 + 88) & 8) == 0)
    {
      uint64_t v15 = *((void *)this + 3);
      *(void *)&long long v108 = this;
      long long v117 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v15, (C3D::Pass **)&v108);
      uint64_t v16 = *((void *)this + 3);
      long long v108 = 0uLL;
      long long v109 = "DEPTH";
      __int16 v110 = 512;
      uint64_t Pass = C3D::ScenePass::lastPass(v117);
      int v112 = 1;
      char v113 = 0;
      uint64_t v17 = C3D::RenderGraph::search(v16, (uint64_t)&v108);
      if (!v17)
      {
        uint64_t v18 = scn_default_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          C3D::FinalPass::setup(v18, v19, v20, v21, v22, v23, v24, v25);
        }
      }
      uint64_t v26 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
      uint64_t v27 = C3D::Pass::outputBufferParameterNamed(v26, "COLOR");
      if (!v27)
      {
        char v28 = scn_default_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
          C3D::FinalPass::setup(v28, v29, v30, v31, v32, v33, v34, v35);
        }
      }
      uint64_t v36 = C3D::Pass::outputBufferParameterNamed(v17, "DEPTH");
      if (!v36)
      {
        uint64_t v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          C3D::FinalPass::setup(v37, v38, v39, v40, v41, v42, v43, v44);
        }
      }
      if (v115)
      {
        uint64_t v104 = RenderContext;
        uint64_t v45 = v116;
        uint64x2_t v46 = &v116[v115];
        do
        {
          uint64_t v47 = *v45;
          float32x2_t v48 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v45);
          if (C3D::PassDescriptor::inputCount(v48))
          {
            unsigned __int8 v49 = 0;
            do
            {
              if (*(unsigned char *)(C3D::Pass::inputBufferParameterAtIndex(v47, v49) + 64) == 1)
              {
                uint64_t v50 = C3D::Pass::inputBufferParameterNamed(v47, "COLOR");
                if (v27 && v50) {
                  *(_WORD *)(v50 + 2_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(v27 + 28);
                }
                float64x2_t v51 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
                C3D::Pass::addDependency(v47, v51);
              }
              ++v49;
              uint64_t v52 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v47);
            }
            while (C3D::PassDescriptor::inputCount(v52) > v49);
          }
          ++v45;
        }
        while (v45 != v46);
        uint64_t RenderContext = v104;
        if (v115)
        {
          uint64_t v53 = v116;
          uint64_t v54 = &v116[v115];
          do
          {
            uint64_t v55 = *v53;
            unsigned int v56 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v53);
            if (C3D::PassDescriptor::inputCount(v56))
            {
              unsigned __int8 v57 = 0;
              do
              {
                if (*(unsigned char *)(C3D::Pass::inputBufferParameterAtIndex(v55, v57) + 64) == 2)
                {
                  uint64_t v58 = C3D::Pass::inputBufferParameterNamed(v55, "DEPTH");
                  if (v36 && v58) {
                    *(_WORD *)(v58 + 2_Block_object_dispose(&STACK[0x380], 8) = *(_WORD *)(v36 + 28);
                  }
                  C3D::Pass::addDependency(v55, v17);
                }
                ++v57;
                unsigned int v59 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v55);
              }
              while (C3D::PassDescriptor::inputCount(v59) > v57);
            }
            ++v53;
          }
          while (v53 != v54);
        }
      }
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v62 = *((void *)this + 3);
    *(void *)&long long v108 = this;
    CFArrayRef v14 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v62, (C3D::Pass **)&v108);
  }
  long long v117 = v14;
LABEL_44:
  C3DStackAllocatorPopFrame(v105);
  __int16 v61 = v117;
LABEL_45:
  *(void *)(*((void *)this + 3) + 112) = v61;
  *((_OWORD *)this + _Block_object_dispose(&STACK[0x380], 8) = v106;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v108);
  uint64_t v63 = C3D::PassDescriptor::inputAtIndex(v2, 0);
  *(_OWORD *)(v63 + 16) = v108;
  *(_DWORD *)(v63 + 32) = v109;
  C3D::PassDescriptor::inputAtIndex(v2, 0);
  long long v64 = this;
  if (C3DEngineContextGetUpdateMainFramebuffer(*((void *)this + 2)))
  {
    uint64_t UserInfo = (void *)C3DEngineContextGetUserInfo(*((void *)this + 2));
    if (UserInfo
      && (uint64_t v66 = UserInfo,
          BOOL v67 = [UserInfo overlaySKScene] != 0,
          LODWORD(UserInfo) = [v66 showsStatistics],
          v67)
      || (long long v64 = this, UserInfo))
    {
      uint64_t v68 = *((void *)this + 3);
      *(void *)&long long v108 = this;
      long long v64 = C3D::RenderGraph::createPass<C3D::OverlayPass,C3D::FinalPass *>(v68, (C3D::Pass **)&v108);
      C3D::Pass::addDependency(this, v64);
    }
    if (C3DEngineContextGetSuperSamplingFactor(*((void *)this + 2)) > 1.0)
    {
      uint64_t v69 = *((void *)this + 3);
      *(void *)&long long v108 = this;
      long long v70 = C3D::RenderGraph::createPass<C3D::DownsamplePass,C3D::FinalPass *>(v69, (C3D::Pass **)&v108);
      C3D::Pass::addDependency(v64, v70);
      long long v64 = v70;
    }
  }
  *((int8x16_t *)this + _Block_object_dispose(&STACK[0x380], 8) = v107;
  if (C3DEngineContextIsJitteringEnabled(*((void *)this + 2)))
  {
    uint64_t v71 = *((void *)this + 3);
    *(void *)&long long v108 = this;
    uint64_t v72 = C3D::RenderGraph::createPass<C3D::JitteringPass,C3D::FinalPass *>(v71, (C3D::Pass **)&v108);
    if (C3DEngineContextGetUpdateMainFramebuffer(*((void *)this + 2)))
    {
      __int16 v73 = *(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(v72, 1u) + 28);
      *(_WORD *)(C3D::Pass::inputBufferParameterAtIndex(this, 0) + 2_Block_object_dispose(&STACK[0x380], 8) = v73;
    }
    else
    {
      uint64_t v74 = C3D::Pass::outputBufferParameterAtIndex(v72, 0);
      uint64_t v75 = C3D::Pass::inputBufferParameterAtIndex(this, 0);
      int v76 = *(_DWORD *)(v74 + 32);
      *(_OWORD *)(v75 + 16) = *(_OWORD *)(v74 + 16);
      *(_DWORD *)(v75 + 32) = v76;
    }
    C3D::Pass::addDependency(v64, v72);
  }
  else
  {
    uint64_t v72 = v64;
  }
  if (!-[SCNMTLRenderContext showsAuthoringEnvironment](RenderContext))
  {
    int v80 = 0;
    uint64_t v79 = 0;
    BOOL v81 = 0;
    goto LABEL_68;
  }
  uint64_t AuthoringEnvironment = (void *)C3DEngineContextGetAuthoringEnvironment(*((void *)this + 2), 0);
  if (C3DAuthoringEnvironmentHasSelectedNodes(AuthoringEnvironment))
  {
    uint64_t v78 = *((void *)this + 3);
    *(void *)&long long v108 = this;
    uint64_t v79 = C3D::RenderGraph::createPass<C3D::ManipulatorPass,C3D::FinalPass *>(v78, (C3D::Pass **)&v108);
    C3D::Pass::addDependency(v72, v79);
    uint64_t v72 = v79;
    if (!AuthoringEnvironment) {
      goto LABEL_65;
    }
  }
  else
  {
    uint64_t v79 = 0;
    if (!AuthoringEnvironment) {
      goto LABEL_65;
    }
  }
  if ((objc_msgSend(AuthoringEnvironment, "authoringDisplayMask", v104) & 0x100) != 0)
  {
    uint64_t v82 = *((void *)this + 3);
    *(void *)&long long v108 = this;
    BOOL v81 = C3D::RenderGraph::createPass<C3D::GridPass,C3D::FinalPass *>(v82, (C3D::Pass **)&v108);
    C3D::Pass::addDependency(v72, v81);
    uint64_t v72 = v81;
    goto LABEL_67;
  }
LABEL_65:
  BOOL v81 = 0;
LABEL_67:
  uint64_t v83 = *((void *)this + 3);
  *(void *)&long long v108 = this;
  int v80 = C3D::RenderGraph::createPass<C3D::AuthoringPass,C3D::FinalPass *>(v83, (C3D::Pass **)&v108);
  C3D::Pass::addDependency(v72, v80);
  uint64_t v72 = v80;
LABEL_68:
  if (-[SCNMTLRenderContext enableARMode](RenderContext))
  {
    if (!v117)
    {
      uint64_t v84 = 0;
      goto LABEL_82;
    }
  }
  else
  {
    int v85 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
    uint64_t v84 = v117;
    if (!v85 || !v117)
    {
LABEL_82:
      if (v80)
      {
        uint64_t v86 = 0;
LABEL_84:
        C3D::AuthoringPass::setMainScenePass((uint64_t)v80, v84);
        uint64_t v91 = C3DEngineContextGetStackAllocator(*((void *)this + 2));
        C3DStackAllocatorPushFrame(v91);
        if (v86) {
          goto LABEL_88;
        }
        uint64_t v92 = *((void *)this + 3);
        long long v108 = 0uLL;
        long long v109 = "COLOR";
        __int16 v110 = 256;
        long long v93 = v118;
        if (!v118) {
          long long v93 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
        }
        uint64_t Pass = (uint64_t)v93;
        int v112 = 1;
        char v113 = 0;
        uint64_t v86 = C3D::RenderGraph::search(v92, (uint64_t)&v108);
        if (v86)
        {
LABEL_88:
          uint64_t v94 = (const C3D::PassIODescriptor *)C3D::Pass::outputBufferParameterNamed(v86, "COLOR");
          if (v117)
          {
            if (v94)
            {
              C3D::AuthoringPass::setColorInput(v80, v94);
              C3D::Pass::addDependency(v80, v86);
              if (v79)
              {
                if (v81) {
                  uint64_t v95 = v81;
                }
                else {
                  uint64_t v95 = v80;
                }
                uint64_t v96 = (const C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)v95 + 32), 0);
                C3D::ManipulatorPass::setColorInput(v79, v96);
              }
            }
          }
        }
        uint64_t v97 = *((void *)this + 3);
        long long v108 = 0uLL;
        long long v109 = "DEPTH";
        __int16 v110 = 512;
        unsigned int v98 = v118;
        if (!v118) {
          unsigned int v98 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
        }
        uint64_t Pass = (uint64_t)v98;
        int v112 = 1;
        char v113 = 0;
        uint64_t v99 = C3D::RenderGraph::search(v97, (uint64_t)&v108);
        if (v99)
        {
          uint64_t v100 = v99;
          if (v81) {
            C3D::Pass::addDependency(v81, v99);
          }
          uint64x2_t v101 = (C3D::Pass *)*((void *)v80 + 671);
          if (v101)
          {
            if (v100 != v86)
            {
              C3D::Pass::addDependency(v101, v86);
              uint64x2_t v101 = (C3D::Pass *)*((void *)v80 + 671);
            }
            C3D::Pass::addDependency(v101, v100);
          }
          if (v100 != v86) {
            C3D::Pass::addDependency(v80, v100);
          }
        }
        else if ((C3D::FinalPass::setup(void)::done & 1) == 0)
        {
          C3D::FinalPass::setup(void)::done = 1;
          uint64_t v102 = scn_default_log();
          if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR)) {
            C3D::FinalPass::setup(v102);
          }
        }
        C3DStackAllocatorPopFrame(v91);
        return;
      }
      goto LABEL_111;
    }
  }
  uint64_t v86 = C3D::RenderGraph::createPass<C3D::CompositeARPass,C3D::ScenePass *&>(*((void *)this + 3), &v117);
  uint64_t v87 = *((void *)this + 3);
  long long v108 = 0uLL;
  long long v109 = "COLOR";
  __int16 v110 = 256;
  uint64_t v88 = v118;
  if (!v118) {
    uint64_t v88 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
  }
  uint64_t Pass = (uint64_t)v88;
  int v112 = 1;
  char v113 = 0;
  uint32x2_t v89 = C3D::RenderGraph::search(v87, (uint64_t)&v108);
  C3D::Pass::addDependency(v86, v89);
  if (-[SCNMTLRenderContext enableARMode](RenderContext))
  {
    float v90 = C3D::RenderGraph::createPass<C3D::DrawBackgroundPass,C3D::ScenePass *&>(*((void *)this + 3), &v117);
    C3D::Pass::addDependency(v86, v90);
  }
  if (v89 != v117 && -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext)) {
    C3D::Pass::addDependency(v86, v117);
  }
  if (v80)
  {
    uint64_t v84 = v117;
    goto LABEL_84;
  }
  C3D::Pass::addDependency(v72, v86);
  uint64_t v72 = v86;
LABEL_111:
  uint64_t v103 = v118;
  if (!v118) {
    uint64_t v103 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
  }
  C3D::Pass::addDependency(v72, v103);
}

float C3DEngineContextGetSuperSamplingFactor(uint64_t a1)
{
  return *(float *)(a1 + 204);
}

void C3D::Pass::setInputCount(C3D::Pass *this, unsigned int a2)
{
  *((_WORD *)this + 36) = a2;
  *((_WORD *)this + 4_Block_object_dispose(&STACK[0x380], 8) = a2;
  if (a2)
  {
    uint64_t v4 = *(void *)(*((void *)this + 3) + 16);
    uint64_t v5 = a2;
    uint64_t v6 = (*(uint64_t (**)(C3D::Pass *))(*(void *)this + 88))(this);
    *((void *)this + 7) = C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(v4, v5, (uint64_t *)(v6 + 32));
    size_t v7 = 8 * a2;
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)(*((void *)this + 3) + 16), v7, 8, 0);
    bzero(Aligned, v7);
    *((void *)this + 10) = Aligned;
    size_t v9 = 8 * *((unsigned __int16 *)this + 48);
    bzero(Aligned, v9);
  }
}

uint64_t C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t result = C3DScratchAllocatorAllocateAligned(a1, 80 * a2, 16, 0);
  if (v4)
  {
    uint64_t v6 = (_WORD *)(result + 66);
    do
    {
      uint64_t v7 = *a3;
      *((unsigned char *)v6 - 66) = 1;
      *(void *)(v6 - 29) = 0;
      *(void *)(v6 - 5) = 0;
      *(void *)(v6 - 9) = 0;
      *(v6 - 1) = 1;
      *v6 &= 0xFE00u;
      *(void *)(v6 - 25) = 0x1000100000000;
      *((unsigned char *)v6 - 42) = v7;
      *(_WORD *)((char *)v6 - 41) = 2;
      *((unsigned char *)v6 - 39) = 0;
      *(void *)(v6 - 19) = 0x10000;
      v6 += 40;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t C3DEngineContextIsJitteringEnabled(uint64_t a1)
{
  return *(unsigned char *)(a1 + 1716) & 1;
}

uint64_t C3D::ScenePass::lastPass(C3D::ScenePass *this)
{
  return *((void *)this + 680);
}

void C3D::Pass::addDependency(C3D::Pass *this, C3D::Pass *a2)
{
  if (this == a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::addDependency(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!*((void *)this + 3))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::addDependency(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  C3D::RenderGraph::addDependency(*((C3D::RenderGraph **)this + 3), this, a2);
}

uint64_t C3D::RenderGraph::finalTechnique(C3D::RenderGraph *this)
{
  if (!*((unsigned char *)this + 208))
  {
    unsigned __int8 v2 = (const void *)*((void *)this + 25);
    if (v2)
    {
      CFRelease(v2);
      *((void *)this + 25) = 0;
    }
    PointOfView = C3DEngineContextGetPointOfView(*((void *)this + 1));
    if (PointOfView && (CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)PointOfView)) != 0) {
      uint64_t Technique = (const void *)C3DCameraGetTechnique((uint64_t)Camera);
    }
    else {
      uint64_t Technique = 0;
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 10, MEMORY[0x263EFFF70]);
    uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 1));
    LightingSysteCFIndex m = C3DSceneGetLightingSystem(Scene);
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = ___ZN3C3D11RenderGraph14finalTechniqueEv_block_invoke;
    v15[3] = &__block_descriptor_40_e21_v16__0____C3DLight__8l;
    v15[4] = Mutable;
    C3DLightingSystemEnumerateLightsWithTechnique(LightingSystem, (uint64_t)v15);
    if (Technique) {
      CFArrayAppendValue(Mutable, Technique);
    }
    uint64_t v9 = (const void *)*((void *)this + 24);
    if (v9) {
      CFArrayAppendValue(Mutable, v9);
    }
    if (CFArrayGetCount(Mutable))
    {
      CFTypeRef v10 = C3DFXTechniqueCreateBySequencingTechniques(Mutable, 0);
      CFTypeRef v11 = (CFTypeRef)*((void *)this + 25);
      if (v11 != v10)
      {
        if (v11)
        {
          CFRelease(v11);
          *((void *)this + 25) = 0;
        }
        if (v10) {
          CFTypeRef v12 = CFRetain(v10);
        }
        else {
          CFTypeRef v12 = 0;
        }
        *((void *)this + 25) = v12;
      }
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      uint64_t v13 = (const void *)*((void *)this + 25);
      if (v13)
      {
        CFRelease(v13);
        *((void *)this + 25) = 0;
      }
    }
    CFRelease(Mutable);
    *((unsigned char *)this + 20_Block_object_dispose(&STACK[0x380], 8) = 1;
  }
  return *((void *)this + 25);
}

uint64_t C3DSceneGetLightingSystem(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 128);
}

uint64_t C3DCameraGetTechnique(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 536);
}

uint64_t C3D::RenderGraph::getSuccessors@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array((void *)a4, a3);
  Primitiveint Count = C3DMeshElementGetPrimitiveCount(a2);
  uint64_t result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), PrimitiveCount);
  uint64_t v9 = *(unsigned int *)(result + 40);
  if (v9)
  {
    CFTypeRef v10 = *(_DWORD **)(result + 48);
    CFTypeRef v11 = &v10[v9];
    do
    {
      uint64_t result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *v10 & 0x7FFF);
      uint64_t v12 = *(void *)(a4 + 16);
      uint64_t v13 = *(unsigned int *)(a4 + 8);
      if (v13)
      {
        uint64_t v14 = 8 * v13;
        uint64_t v15 = *(void **)(a4 + 16);
        while (*v15 != *(void *)result)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            uint64_t v15 = (void *)(v12 + 8 * v13);
            break;
          }
        }
      }
      else
      {
        uint64_t v15 = *(void **)(a4 + 16);
      }
      if (v13 == ((uint64_t)v15 - v12) >> 3) {
        uint64_t result = (uint64_t)C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>((_DWORD *)a4, (void *)result);
      }
      ++v10;
    }
    while (v10 != v11);
  }
  return result;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::Pass *a3)
{
  if (C3DMeshElementGetPrimitiveCount((uint64_t)a2) == -1) {
    C3D::RenderGraph::addDependency();
  }
  if (C3DMeshElementGetPrimitiveCount((uint64_t)a3) == -1) {
    C3D::RenderGraph::addDependency();
  }
  Primitiveint Count = C3DMeshElementGetPrimitiveCount((uint64_t)a2);
  unsigned int v7 = C3DMeshElementGetPrimitiveCount((uint64_t)a3);

  C3D::RenderGraph::addDependency(this, PrimitiveCount, v7);
}

uint64_t SCNMTLTextureTypeMultisampledEquivalent(uint64_t a1)
{
  uint64_t v1 = 4;
  if (a1 != 2) {
    uint64_t v1 = a1;
  }
  if (a1 == 3) {
    return 8;
  }
  else {
    return v1;
  }
}

uint64_t C3DRendererElementStoreGetElementCount(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DSpanAllocatorGetCount(*(void *)(a1 + 16));
}

uint64_t C3DSpanAllocatorGetCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

double C3DProjectionInfosGetZNear(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 8);
}

double C3DProjectionInfosGetZFar(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 16);
}

double C3DProjectionInfosGetOrthographicScale(uint64_t a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 48);
}

uint64_t C3DProjectionInfosGetOrtho(unsigned char *a1)
{
  if (!a1)
  {
    unsigned __int8 v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *a1 & 1;
}

CFMutableArrayRef C3DNodeCopyNodesWithAttribute(uint64_t a1, __CFString *a2, char a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeCopyNodesWithAttribute_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFMutableArrayRef v23 = Mutable;
  if (@"kMeshKey" == a2)
  {
    uint64_t v24 = v30;
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 0x40000000;
    v30[2] = __C3DNodeCopyNodesWithAttribute_block_invoke;
    v30[3] = &__block_descriptor_tmp_30_0;
    uint8_t v30[4] = Mutable;
LABEL_11:
    uint64_t v25 = v24 + 5;
    goto LABEL_12;
  }
  if (@"kDeformerStackKey" == a2)
  {
    uint64_t v24 = v29;
    v29[0] = MEMORY[0x263EF8330];
    v29[1] = 0x40000000;
    v29[2] = __C3DNodeCopyNodesWithAttribute_block_invoke_2;
    v29[3] = &__block_descriptor_tmp_31_2;
    v29[4] = Mutable;
    goto LABEL_11;
  }
  uint64_t v24 = v27;
  v27[0] = MEMORY[0x263EF8330];
  v27[1] = 0x40000000;
  v27[2] = __C3DNodeCopyNodesWithAttribute_block_invoke_3;
  v27[3] = &__block_descriptor_tmp_32;
  uint8_t v27[4] = a2;
  v27[5] = Mutable;
  uint64_t v25 = &v28;
LABEL_12:
  *(unsigned char *)uint64_t v25 = a3;
  C3DNodeApplyHierarchy(a1, (uint64_t)v24);
  return v23;
}

uint64_t C3DLightingSystemSetMainRenderingFrustums(uint64_t result, _OWORD *a2, float a3, float a4, uint64_t a5, long long *a6, long long *a7)
{
  long long v7 = a2[1];
  *(_OWORD *)(result + 116512) = *a2;
  *(_OWORD *)(result + 11652_Block_object_dispose(&STACK[0x380], 8) = v7;
  long long v8 = a2[2];
  long long v9 = a2[3];
  long long v10 = a2[5];
  *(_OWORD *)(result + 116576) = a2[4];
  *(_OWORD *)(result + 116592) = v10;
  *(_OWORD *)(result + 116544) = v8;
  *(_OWORD *)(result + 116560) = v9;
  long long v11 = *a7;
  long long v12 = a7[1];
  long long v13 = a7[3];
  *(_OWORD *)(result + 116720) = a7[2];
  *(_OWORD *)(result + 116736) = v13;
  *(_OWORD *)(result + 11668_Block_object_dispose(&STACK[0x380], 8) = v11;
  *(_OWORD *)(result + 116704) = v12;
  long long v14 = *a6;
  long long v15 = a6[1];
  long long v16 = a6[3];
  *(_OWORD *)(result + 116640) = a6[2];
  *(_OWORD *)(result + 116656) = v16;
  *(_OWORD *)(result + 11660_Block_object_dispose(&STACK[0x380], 8) = v14;
  *(_OWORD *)(result + 116624) = v15;
  *(float *)(result + 116672) = a3;
  *(float *)(result + 116676) = a4;
  return result;
}

void C3DLightingSystemEnumerateLightsWithTechnique(uint64_t a1, uint64_t a2)
{
  CFSetRef v2 = *(const __CFSet **)(a1 + 116496);
  if (v2)
  {
    uint64_t context = a2;
    CFSetApplyFunction(v2, (CFSetApplierFunction)__lightsWithTechniqueEnumerator, &context);
  }
}

uint64_t C3DGetPovCategoryMask(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  CamerSCNMatrix4 a = C3DNodeGetCamera(a1);
  if (!Camera) {
    return -1;
  }

  return C3DCameraGetCategoryBitMask((uint64_t)Camera);
}

uint64_t C3DEngineContextGetViewpointCoordinateSpace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1632);
}

uint64_t C3DEngineContextGetUpdateMainFramebuffer(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1724);
}

uint64_t C3DEngineContextGetEyeCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 212);
}

uint64_t C3DEngineContextGetDefaultPointOfView(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

float C3DCameraGetWhitePoint(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 384);
}

uint64_t C3DCameraGetWantsExposureAdaptation(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 2) & 1;
}

float C3DCameraGetVignettingIntensity(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 480);
}

float C3DCameraGetSensorSize(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 300);
}

uint64_t C3DCameraGetScreenSpaceAmbientOcclusionSampleCount(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 512);
}

float C3DCameraGetScreenSpaceAmbientOcclusionRadius(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 496);
}

float C3DCameraGetScreenSpaceAmbientOcclusionNormalThreshold(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 508);
}

uint64_t C3DCameraGetScreenSpaceAmbientOcclusionDownSample(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 516);
}

float C3DCameraGetScreenSpaceAmbientOcclusionDepthThreshold(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 504);
}

float C3DCameraGetScreenSpaceAmbientOcclusionBias(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 500);
}

double C3DCameraGetPostProjectionTransformTranslation(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 96);
}

double C3DCameraGetPostProjectionTransformScale(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 104);
}

float C3DCameraGetMinimumExposure(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 416);
}

float C3DCameraGetMaximumExposure(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 420);
}

double C3DCameraGetLensShift(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 88);
}

float C3DCameraGetGrainScale(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 468);
}

uint64_t C3DCameraGetFovIsHorizontal(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 5) & 1;
}

float C3DCameraGetFov(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 120);
}

float C3DCameraGetFocusDistance(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 288);
}

float C3DCameraGetFocalLength(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 292);
}

float C3DCameraGetFStop(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 296);
}

float C3DCameraGetExposureOffset(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 392);
}

uint64_t C3DCameraGetExposureAdaptationMode(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 313);
}

float C3DCameraGetExposureAdaptationHistogramRangeLowProbability(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 412);
}

float C3DCameraGetExposureAdaptationHistogramRangeHighProbability(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 408);
}

float C3DCameraGetExposureAdaptationDuration(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 396);
}

float C3DCameraGetExposureAdaptationDarkeningSpeedFactor(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 404);
}

float C3DCameraGetExposureAdaptationBrighteningSpeedFactor(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 400);
}

uint64_t C3DCameraGetDofSampleCount(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 308);
}

uint64_t C3DCameraGetColorGradingEffectSlot(uint64_t a1, int a2)
{
  uint64_t result = *(void *)(a1 + 520);
  if (a2)
  {
    if (!result)
    {
      uint64_t result = C3DEffectSlotCreate(a1, 26);
      *(void *)(a1 + 520) = result;
    }
  }
  return result;
}

float C3DCameraGetColorFringeIntensity(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 444);
}

float C3DCameraGetBloomThreshold(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 428);
}

float C3DCameraGetBloomIntensity(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 424);
}

float C3DCameraGetBloomBlurRadius(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 440);
}

uint64_t C3DCameraGetBladeCount(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 304);
}

float C3DCameraGetAverageGray(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 388);
}

float C3DCameraGetAspectRatio(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 128);
}

float C3DCameraGetARGrainSlice(uint64_t a1)
{
  if (!a1)
  {
    CFSetRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 552);
}

void sub_20B2B4D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_20B2B4FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2022()
{
  if (C3DWasLinkedBeforeMajorOSYear2022_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2022_onceToken, &__block_literal_global_18);
  }
  return C3DWasLinkedBeforeMajorOSYear2022_linkedBeforeMajorOSYear2022;
}

void _dispatchAutoFlush(uint64_t a1)
{
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16)))
  {
    CFSetRef v2 = objc_alloc_init(C3DEngineNotificationQueueTransientWrapper);
    [(C3DEngineNotificationQueueTransientWrapper *)v2 setEngineNotificationQueue:a1];
    dispatch_time_t v3 = dispatch_time(0, 1000000000);
    v4[0] = MEMORY[0x263EF8330];
    v4[1] = 3221225472;
    _OWORD v4[2] = ___dispatchAutoFlush_block_invoke;
    v4[3] = &unk_2640093B8;
    _OWORD v4[4] = v2;
    v4[5] = a1;
    dispatch_after(v3, MEMORY[0x263EF83A0], v4);
  }
}

dispatch_queue_t ___commitImplicitTransaction_block_invoke()
{
  char v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INTERACTIVE, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.scenekit.main-thread-implicit-transaction-flush", v1);
  _commitImplicitTransaction_queue = (uint64_t)result;
  return result;
}

uint64_t __C3DValueGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DValueGetTypeID_typeID = result;
  qword_26B4693D0 = (uint64_t)_C3DValueCopyInstanceVariables;
  return result;
}

double __C3DKeyValueStoreGetTypeID_block_invoke()
{
  C3DKeyValueStoreGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DKeyValueStoreContextClassAnimatable;
  xmmword_26B4680B8 = kC3DC3DKeyValueStoreContextClassAnimatable;
  return result;
}

uint64_t __C3DFXTechniqueGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXTechniqueGetTypeID_typeID = result;
  qword_26B467C40 = (uint64_t)_C3DFXTechniqueCopyInstanceVariables;
  return result;
}

uint64_t __C3DFXMetalProgramGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXMetalProgramGetTypeID_typeID = result;
  qword_26B467B58 = (uint64_t)_C3DFXMetalProgramCopyInstanceVariables;
  return result;
}

uint64_t __C3DFXGLSLProgramGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXGLSLProgramGetTypeID_typeID = result;
  qword_26B467A70 = (uint64_t)_C3DFXGLSLProgramCopyInstanceVariables;
  return result;
}

void _C3DProgramHashCodeStoreCFFinalize(void *a1)
{
  C3DProgramHashCodeStoreClear((uint64_t)a1);
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::~Hash((uint64_t)(a1 + 2));
  CFSetRef v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
    a1[6] = 0;
  }
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::~Hash(uint64_t a1)
{
  return a1;
}

void SCNMTLClusterSystem::~SCNMTLClusterSystem(SCNMTLClusterSystem *this)
{
  for (uint64_t i = 0; i != 56; i += 8)
  {
    dispatch_time_t v3 = (char *)this + i;
    uint64_t v4 = *(const void **)((char *)this + i + 72);
    if (v4)
    {
      CFRelease(v4);
      *((void *)v3 + 9) = 0;
    }
    uint64_t v5 = (const void *)*((void *)v3 + 16);
    if (v5)
    {
      CFRelease(v5);
      *((void *)v3 + 16) = 0;
    }
  }
}

double __C3DTimingFunctionGetTypeID_block_invoke()
{
  C3DTimingFunctionGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DTimingFunctionContextClassSerializable;
  unk_26B469330 = kC3DC3DTimingFunctionContextClassSerializable;
  unk_26B469340 = *(_OWORD *)off_26BF717A0;
  return result;
}

double __C3DKeyframedAnimationGetTypeID_block_invoke()
{
  C3DKeyframedAnimationGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DKeyframedAnimationContextClassSerializable;
  unk_26B4681F8 = kC3DC3DKeyframedAnimationContextClassSerializable;
  unk_26B468208 = *(_OWORD *)&off_26BF712E8;
  return result;
}

double __C3DAnimationManagerGetTypeID_block_invoke()
{
  C3DAnimationManagerGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DAnimationManagerContextClassSerializable;
  unk_26B467630 = kC3DC3DAnimationManagerContextClassSerializable;
  unk_26B467640 = *(_OWORD *)&off_26BF710B0;
  return result;
}

double __C3DAnimationGroupGetTypeID_block_invoke()
{
  C3DAnimationGroupGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DAnimationGroupContextClassSerializable;
  unk_26B467548 = kC3DC3DAnimationGroupContextClassSerializable;
  unk_26B467558 = *(_OWORD *)&off_26BF71090;
  return result;
}

double __C3DAnimationClusterGetTypeID_block_invoke()
{
  C3DAnimationClusterGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DAnimationClusterContextClassSerializable;
  unk_26B467460 = kC3DC3DAnimationClusterContextClassSerializable;
  unk_26B467470 = *(_OWORD *)&off_26BF71060;
  return result;
}

void _C3DEngineContextCFFinalize(uint64_t a1)
{
  if (a1)
  {
    C3DRenderGraphDelete(*(C3D::RenderGraph **)(a1 + 1728));
    C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterRemoveObserver(SharedInstance, (const void *)a1, @"kC3DNotificationEngineContextInvalidatePasses", 0);
    uint64_t v3 = *(void *)(a1 + 152);
    if (v3)
    {
      uint64_t v4 = *(const void **)(a1 + 136);
      if (v4) {
        _C3DResourceManagerUninstallRendererContext(v3, v4);
      }
    }
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5) {
      C3DSceneUnregisterEngineContext(v5, a1);
    }
    uint64_t v6 = *(const void **)(a1 + 144);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 144) = 0;
    }
    uint64_t v7 = *(const void **)(a1 + 160);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 160) = 0;
    }
    uint64_t v8 = *(const void **)(a1 + 136);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 136) = 0;
    }
    uint64_t v9 = *(const void **)(a1 + 152);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 152) = 0;
    }
    long long v10 = *(const void **)(a1 + 16);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 16) = 0;
    }
    long long v11 = *(const void **)(a1 + 24);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 24) = 0;
    }
    long long v12 = *(const void **)(a1 + 32);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 32) = 0;
    }
    long long v13 = *(const void **)(a1 + 40);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 40) = 0;
    }
    long long v14 = *(const void **)(a1 + 376);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(a1 + 376) = 0;
    }
    long long v15 = *(const void **)(a1 + 48);
    if (v15)
    {
      CFRelease(v15);
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x380], 8) = 0;
    }
    long long v16 = *(const void **)(a1 + 392);
    if (v16)
    {
      CFRelease(v16);
      *(void *)(a1 + 392) = 0;
    }
    uint64_t v17 = *(const void **)(a1 + 1640);
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a1 + 1640) = 0;
    }
    uint64_t v18 = *(const void **)(a1 + 1704);
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 1704) = 0;
    }
    uint64_t v19 = *(const void **)(a1 + 192);
    if (v19)
    {
      CFRelease(v19);
      *(void *)(a1 + 192) = 0;
    }
    uint64_t v20 = *(const void **)(a1 + 176);
    if (v20)
    {
      CFRelease(v20);
      *(void *)(a1 + 176) = 0;
    }
    uint64_t v21 = *(const void **)(a1 + 184);
    if (v21)
    {
      CFRelease(v21);
      *(void *)(a1 + 184) = 0;
    }
    uint64_t v22 = *(const void **)(a1 + 168);
    if (v22)
    {
      CFRelease(v22);
      *(void *)(a1 + 16_Block_object_dispose(&STACK[0x380], 8) = 0;
    }
    uint64_t v23 = 0;
    uint64_t v24 = a1 + 1648;
    do
    {
      uint64_t v25 = *(const void **)(v24 + v23);
      if (v25)
      {
        CFRelease(v25);
        *(void *)(v24 + v23) = 0;
      }
      v23 += 8;
    }
    while (v23 != 48);
    *(void *)(a1 + 1696) = 0;
  }
}

C3D::RenderGraph *C3DRenderGraphDelete(C3D::RenderGraph *result)
{
  if (result)
  {
    C3D::RenderGraph::~RenderGraph(result);
    JUMPOUT(0x210534FE0);
  }
  return result;
}

void C3D::RenderGraph::~RenderGraph(C3D::RenderGraph *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    uint64_t v3 = C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::~Hash(v2);
    MEMORY[0x210534FE0](v3, 0x1030C408C11463FLL);
  }

  C3DScratchAllocatorDelete(*((C3DScratchAllocator **)this + 2));
  uint64_t v4 = (const void *)*((void *)this + 24);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 24) = 0;
  }
  uint64_t v5 = (const void *)*((void *)this + 25);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 25) = 0;
  }
}

uint64_t C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::~Hash(uint64_t a1)
{
  return a1;
}

uint64_t C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_destroy_values(uint64_t result, __int16 *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v4 = (uint64_t *)result;
    uint64_t v5 = a3;
    do
    {
      __int16 v6 = *a2++;
      if (v6)
      {
        double result = *v4;
        *uint64_t v4 = 0;
        if (result) {
          double result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
      }
      ++v4;
      --v5;
    }
    while (v5);
  }
  return result;
}

void C3D::DrawNodesPassResource::~DrawNodesPassResource(C3D::DrawNodesPassResource *this)
{
}

void C3D::ProbeArrayResource::~ProbeArrayResource(C3D::ProbeArrayResource *this)
{
  *(void *)this = &unk_26BF6DC10;
  uint64_t v3 = (char *)this + 48;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {

  }
  uint64_t v4 = (char *)*((void *)this + 5);
  if (v4 != v3) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 3);
  if (v5 != (char *)this + 32) {
    free(v5);
  }

  JUMPOUT(0x210534FE0);
}

{
  void *v2;
  char *v3;
  char *v4;
  char *v5;

  *(void *)this = &unk_26BF6DC10;
  uint64_t v3 = (char *)this + 48;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {

  }
  uint64_t v4 = (char *)*((void *)this + 5);
  if (v4 != v3) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 3);
  if (v5 != (char *)this + 32) {
    free(v5);
  }
}

C3DScratchAllocator *C3DScratchAllocatorDelete(C3DScratchAllocator *result)
{
  if (result)
  {
    uint64_t v1 = result;
    C3DScratchAllocator::ClearToCapacity(result, 0);
    MEMORY[0x2105366D0](*MEMORY[0x263EF8960], *(void *)v1, *((void *)v1 + 1));
    JUMPOUT(0x210534FE0);
  }
  return result;
}

void C3DNotificationCenterRemoveObserver(uint64_t a1, const void *a2, const __CFString *a3, const void *a4)
{
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();

  CFNotificationCenterRemoveObserver(LocalCenter, a2, a3, a4);
}

uint64_t C3DEngineContextRenderWithRenderGraph(uint64_t a1)
{
  uint64_t v1 = *(C3D::RenderGraph **)(a1 + 1728);
  C3DRenderGraphReset(v1);
  C3DLoadBuiltInPasses((uint64_t)v1);
  C3DRenderGraphSetup(v1);
  C3DRenderGraphCompile(v1);

  return C3DRenderGraphExecute(v1);
}

uint64_t C3D::RenderGraph::setup(C3D::RenderGraph *this)
{
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 1));
  C3DStackAllocatorPushFrame(StackAllocator);
  *((unsigned char *)this + 209) = 1;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 1));
  if (*((void *)this + 21)) {
    [(id)-[SCNMTLRenderContext layerTarget](RenderContext) setFramebufferOnly:0];
  }
  uint64_t v4 = *(unsigned int *)(*((void *)this + 3) + 8);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      __int16 v6 = (void *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), i);
      (*(void (**)(void))(*(void *)*v6 + 8))(*v6);
    }
  }
  C3D::RenderGraph::resolvePartialDependencies(this);
  C3D::RenderGraph::removeInvalidPasses(this);
  BOOL v7 = C3D::RenderGraph::sort(this);
  *((unsigned char *)this + 211) = v7;
  if (v7)
  {
    C3D::RenderGraph::resolvePartialCompatibility(this);
    C3D::RenderGraph::validate(this);
  }
  *((unsigned char *)this + 209) = 0;

  return C3DStackAllocatorPopFrame(StackAllocator);
}

void C3D::RenderGraph::reset(C3D::RenderGraph *this)
{
  if (!*((unsigned char *)this + 210)) {
    C3D::RenderGraph::checkResources((uint64_t)this);
  }
  C3D::RenderGraphResourceManager::purgeIfNeeded(*((C3D::RenderGraphResourceManager **)this + 16));
  uint64_t v3 = *((void *)this + 2);
  uint64_t v2 = (uint64_t *)((char *)this + 16);
  C3DScratchAllocatorReset(v3);
  uint64_t Aligned = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*v2, 24, 8, 0);
  v2[1] = (uint64_t)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(Aligned, (void *)*v2);
  v2[15] = (uint64_t)C3D::ScratchAllocate<C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>,void *&>(*v2, (void **)v2);
  uint64_t v5 = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*v2, 24, 8, 0);
  v2[16] = (uint64_t)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(v5, (void *)*v2);

  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(v2 + 5, 32);
}

void C3DScratchAllocator::ClearToCapacity(C3DScratchAllocator *this, unint64_t a2)
{
  *((void *)this + 2) = 0;
  uint64_t v4 = (void *)*((void *)this + 3);
  uint64_t v5 = (unsigned int *)MEMORY[0x263EF8960];
  if (v4)
  {
    do
    {
      __int16 v6 = (void *)v4[3];
      MEMORY[0x2105366D0](*v5, *v4, v4[1]);
      MEMORY[0x210534FE0](v4, 0x10A0C4064A2AE3FLL);
      uint64_t v4 = v6;
    }
    while (v6);
  }
  *((void *)this + 3) = 0;
  *((void *)this + 4) = this;
  if (*((void *)this + 1) < a2)
  {
    MEMORY[0x2105366D0](*v5, *(void *)this);
    VMAllocateChunk((vm_address_t *)this, a2);
  }
}

void C3D::RenderGraphResourceManager::purgeIfNeeded(C3D::RenderGraphResourceManager *this)
{
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = v20;
  int v1 = *((_DWORD *)this + 7);
  if (v1 != -15)
  {
    unint64_t v3 = 0;
    do
    {
      if (*(_WORD *)(*((void *)this + 2) + 2 * v3))
      {
        uint64_t v4 = *(void *)this;
        uint64_t v5 = *(void *)(*((void *)this + 1) + 8 * v3);
        unsigned int v6 = *(unsigned __int8 *)(v5 + 8);
        *(unsigned char *)(v5 + _Block_object_dispose(&STACK[0x380], 8) = v6 + 1;
        if (v6 >= 0xA)
        {
          C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>((uint64_t)&v18, (void *)(v4 + 8 * v3));
          int v1 = *((_DWORD *)this + 7);
        }
      }
      ++v3;
    }
    while (v3 < (v1 + 15));
    BOOL v7 = (char *)v19;
    if (v18)
    {
      uint64_t v8 = (char *)v19 + 8 * v18;
      do
      {
        uint64_t v9 = (*((_DWORD *)this + 7) - 1) & *(void *)v7;
        uint64_t v10 = *((void *)this + 2);
        unsigned int v11 = *(unsigned __int16 *)(v10 + 2 * v9);
        if (v11 >= 2)
        {
          int v12 = 1;
          unsigned int v13 = *(unsigned __int16 *)(v10 + 2 * v9);
          while (1)
          {
            if ((v13 & 2) != 0)
            {
              uint64_t v14 = (v9 + v12 - 1);
              if (*(void *)v7 == *(void *)(*(void *)this + 8 * v14)) {
                break;
              }
            }
            ++v12;
            BOOL v15 = v13 > 3;
            v13 >>= 1;
            if (!v15) {
              goto LABEL_18;
            }
          }
          *(_WORD *)(v10 + 2 * v9) = v11 ^ (1 << v12);
          *(_WORD *)(v10 + 2 * v14) ^= 1u;
          uint64_t v16 = *((void *)this + 1);
          uint64_t v17 = *(void *)(v16 + 8 * v14);
          *(void *)(v16 + 8 * v14) = 0;
          if (v17) {
            (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
          }
          --*((_DWORD *)this + 6);
        }
LABEL_18:
        v7 += 8;
      }
      while (v7 != v8);
      BOOL v7 = (char *)v19;
    }
    if (v7 != v20) {
      free(v7);
    }
  }
}

void sub_20B2B5F94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10 != v10) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

void *C3D::ScratchAllocate<C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>,void *&>(uint64_t a1, void **a2)
{
  uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(a1, 40, 8, 0);
  C3D::ScratchAllocator::ScratchAllocator((C3D::ScratchAllocator *)&v5, *a2);
  *uint64_t Aligned = v5;
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(Aligned, 32);
  return Aligned;
}

void C3D::RenderGraph::resolvePartialDependencies(C3D::RenderGraph *this)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*((void *)this + 1));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v41, StackAllocator);
  int v37 = *(unsigned __int16 *)(*((void *)this + 3) + 8);
  if (*(_WORD *)(*((void *)this + 3) + 8))
  {
    unsigned int v3 = 0;
    while (1)
    {
      uint64_t v4 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v3);
      C3D::Array<C3D::RenderGraph::Link,16u,C3D::StackAllocator>::resize((uint64_t)&v41, 0);
      int v43 = 16;
      uint64_t v44 = (int *)&v45;
      if (*(_DWORD *)(v4 + 40))
      {
        unint64_t v5 = 0;
        do
        {
          unsigned int v6 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v4 + 32, v5);
          if (HIBYTE(*v6) == 255 || (*v6 & 0xFF0000) == 0xFF0000)
          {
            C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(&v41, v6);
            BOOL v7 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v4 + 32, v5);
            uint64_t v8 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v4 + 32, *(_DWORD *)(v4 + 40) - 1);
            int v9 = *v7;
            int *v7 = *v8;
            int *v8 = v9;
            C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(v4 + 32, *(_DWORD *)(v4 + 40) - 1);
          }
          else
          {
            ++v5;
          }
        }
        while (v5 < *(unsigned int *)(v4 + 40));
      }
      if (v42)
      {
        std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *,false>((unint64_t)v44, &v44[v42], 126 - 2 * __clz(v42), 1);
        if (v42) {
          break;
        }
      }
LABEL_41:
      if (++v3 == v37) {
        return;
      }
    }
    uint64_t v10 = 0;
    while (1)
    {
      unsigned int v11 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, v10);
      int v12 = v11;
      if (!v10) {
        break;
      }
      unsigned int v13 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, (int)v10 - 1);
      int v14 = *v12;
      if (((*v12 ^ *v13) & 0x7FFF) != 0) {
        goto LABEL_17;
      }
LABEL_23:
      if (++v10 >= (unint64_t)v42)
      {
        if (v42)
        {
          for (unint64_t i = 0; i < v42; ++i)
          {
            uint64_t v21 = *((void *)this + 3);
            uint64_t v22 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, i);
            uint64_t v23 = (const C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v21, *v22 & 0x7FFF);
            C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v38, StackAllocator);
            if (i < v42)
            {
              unint64_t v24 = i;
              do
              {
                uint64_t v25 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, v24);
                uint64_t v26 = v25;
                if (v24)
                {
                  int v27 = *v25;
                  if (((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, (int)v24 - 1) ^ v27) & 0x7FFF) != 0)break; {
                }
                  }
                int v28 = *v26;
                buf[0] = HIBYTE(*v26);
                buf[1] = BYTE2(v28);
                C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(&v38, buf);
                ++v24;
              }
              while (v24 < v42);
            }
            C3D::RenderGraph::matchingPortForNodes((uint64_t)this, (uint64_t)v23, (C3D::Pass **)v4, (uint64_t)&v38);
            uint64_t v29 = v39;
            if (v39) {
              goto LABEL_35;
            }
            uint64_t v30 = scn_default_log();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
            {
              uint64_t v35 = (***(uint64_t (****)(void))v4)();
              uint64_t v36 = (**(uint64_t (***)(void))*v23)();
              *(_DWORD *)float32x4_t buf = 136315650;
              uint64_t v47 = "!portsPairs.empty()";
              __int16 v48 = 2080;
              uint64_t v49 = v35;
              __int16 v50 = 2080;
              uint64_t v51 = v36;
              _os_log_fault_impl(&dword_20B249000, v30, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Unable to resolve dependency between %s and %s", buf, 0x20u);
            }
            uint64_t v29 = v39;
            if (v39)
            {
LABEL_35:
              uint64_t v31 = v40;
              uint64_t v32 = &v40[2 * v29];
              do
              {
                uint64_t v33 = *v31;
                if (v33 != 255)
                {
                  uint64_t v34 = v31[1];
                  if (v34 != 255) {
                    C3D::RenderGraph::addDependency(this, *v23, *(const C3D::Pass **)v4, v33, v34);
                  }
                }
                v31 += 2;
              }
              while (v31 != v32);
            }
          }
        }
        goto LABEL_41;
      }
    }
    int v14 = *v11;
LABEL_17:
    uint64_t v15 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), v14 & 0x7FFF);
    if (*(_DWORD *)(v15 + 16))
    {
      unint64_t v16 = 0;
      do
      {
        while ((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, v16) & 0x7FFF) == v3)
        {
          uint64_t v17 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, v16);
          uint64_t v18 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, *(_DWORD *)(v15 + 16) - 1);
          int v19 = *v17;
          int *v17 = *v18;
          *uint64_t v18 = v19;
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(v15 + 8, *(_DWORD *)(v15 + 16) - 1);
          if (*(_DWORD *)(v15 + 16) <= v16) {
            goto LABEL_23;
          }
        }
        ++v16;
      }
      while (v16 < *(unsigned int *)(v15 + 16));
    }
    goto LABEL_23;
  }
}

void C3D::Array<C3D::RenderGraph::Link,16u,C3D::StackAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      unint64_t v5 = *(char **)(a1 + 16);
      if (*(_DWORD *)(a1 + 12) < a2)
      {
        unsigned int v6 = ((double)a2 * 1.5);
        uint64_t Aligned = (char *)C3DStackAllocatorAllocateAligned(*(void *)a1, 4 * v6, 4, 0);
        memcpy(Aligned, v5, 4 * *(unsigned int *)(a1 + 8));
        *(void *)(a1 + 16) = Aligned;
        *(_DWORD *)(a1 + 12) = v6;
        unint64_t v5 = Aligned;
        unsigned int v2 = *(_DWORD *)(a1 + 8);
      }
      bzero(&v5[4 * v2], 4 * (a2 - v2));
    }
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x380], 8) = a2;
  }
}

uint64_t C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 8);
      int v7 = 136315906;
      uint64_t v8 = "i < size()";
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v6;
      _os_log_fault_impl(&dword_20B249000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(void *)(a1 + 16) + 4 * a2;
}

uint64_t C3D::RenderGraph::checkResources(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 96);
  if (v1)
  {
    uint64_t v2 = this;
    do
    {
      uint64_t v3 = *(unsigned int *)(v1 + 8);
      if (v3)
      {
        uint64_t v4 = *(unsigned __int16 **)(v1 + 16);
        unint64_t v5 = &v4[v3];
        do
        {
          int v6 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(v2 + 24), *v4);
          int v7 = (C3D::PassResource *)C3D::Pass::resource(*v6);
          this = C3D::PassResource::outputCount(v7);
          if (this)
          {
            unsigned int v8 = 0;
            do
            {
              __int16 v9 = (C3D::PassResource *)C3D::Pass::resource(*v6);
              C3D::PassResource::outputAtIndex(v9, (unsigned __int16)v8++);
              uint64_t v10 = (C3D::PassResource *)C3D::Pass::resource(*v6);
              this = C3D::PassResource::outputCount(v10);
            }
            while (v8 < this);
          }
          ++v4;
        }
        while (v4 != v5);
      }
      uint64_t v1 = *(void *)(v1 + 24);
    }
    while (v1);
  }
  return this;
}

void C3DScratchAllocator::Reset(C3DScratchAllocator *this)
{
  LODWORD(v1) = *((_DWORD *)this + 2);
  for (uint64_t i = *((void *)this + 3); i; uint64_t i = *(void *)(i + 24))
    uint64_t v1 = *(void *)(i + 8) + v1;
  C3DScratchAllocator::ClearToCapacity(this, v1);
}

void C3DRenderGraphCompile(C3D::RenderGraph *this)
{
  if (*((unsigned char *)this + 211)) {
    C3D::RenderGraph::allocateResources(this);
  }
}

void SCNMTLBufferPool::~SCNMTLBufferPool(SCNMTLBufferPool *this)
{
  uint64_t v2 = (id *)*((void *)this + 4);
  if (v2 != *((id **)this + 5))
  {
    do
    {

      v2 += 2;
    }
    while (v2 != *((id **)this + 5));
    uint64_t v2 = (id *)*((void *)this + 4);
  }
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
}

void sub_20B2B6B0C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 32);
  if (v3)
  {
    *(void *)(v1 + 40) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void SCNMTLTexturePool::~SCNMTLTexturePool(SCNMTLTexturePool *this)
{
  uint64_t v2 = (id *)*((void *)this + 2);
  uint64_t v3 = (id *)*((void *)this + 3);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {

      }
      v2 += 4;
    }
    while (v2 != v3);
    uint64_t v2 = (id *)*((void *)this + 2);
  }
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

void sub_20B2B6B94(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(void *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

dispatch_queue_t __C3DProgramHashCodeCreate_block_invoke()
{
  s_ProgramHashCodeDictionary = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.scenekit.programHashCodeQueue", 0);
  s_ProgramHashCodeDictionaryQueue = (uint64_t)result;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

double __C3DEntityGetTypeID_block_invoke()
{
  C3DEntityGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DEntityContextClassSceneLink;
  unk_26B4694D0 = kC3DC3DEntityContextClassSceneLink;
  unk_26B4694E0 = *(_OWORD *)off_26BF71180;
  qword_26B4694F0 = qword_26BF71190;
  return result;
}

uint64_t __C3DGetColorTransformToSRGB_block_invoke()
{
  if (C3DColorSpaceSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
  }
  uint64_t result = MEMORY[0x210534520](C3DColorSpaceSRGB_kC3DColorSpaceSRGB, 0);
  C3DGetColorTransformToSRGB_colorTransforCFIndex m = result;
  return result;
}

uint64_t __C3DGetColorTransformToLinearSRGB_block_invoke()
{
  if (C3DColorSpaceLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_4);
  }
  uint64_t result = MEMORY[0x210534520](C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB, 0);
  C3DGetColorTransformToLinearSRGB_colorTransforCFIndex m = result;
  return result;
}

uint64_t __C3DGetColorTransformToExtendedSRGB_block_invoke()
{
  if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
  }
  uint64_t result = MEMORY[0x210534520](C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB, 0);
  C3DGetColorTransformToExtendedSRGB_colorTransforCFIndex m = result;
  return result;
}

double __C3DEffectSlotGetTypeID_block_invoke()
{
  C3DEffectSlotGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DEffectSlotContextClassAnimatable;
  xmmword_26B467978 = kC3DC3DEffectSlotContextClassAnimatable;
  qword_26B467988 = (uint64_t)_C3DEffectSlotCopyInstanceVariables;
  return result;
}

double __C3DTextureSamplerGetTypeID_block_invoke()
{
  C3DTextureSamplerGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DTextureSamplerContextClassSerializable;
  unk_26B469248 = kC3DC3DTextureSamplerContextClassSerializable;
  unk_26B469258 = *(_OWORD *)&off_26BF71780;
  qword_26B469200 = (uint64_t)_C3DTextureSamplerCopyInstanceVariables;
  return result;
}

double __C3DSourceAccessorGetTypeID_block_invoke()
{
  C3DSourceAccessorGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DSourceAccessorContextClassSerializable;
  unk_26B469078 = kC3DC3DSourceAccessorContextClassSerializable;
  unk_26B469088 = *(_OWORD *)&off_26BF716F8;
  qword_26B469030 = (uint64_t)_C3DSourceAccessorCopyInstanceVariables;
  return result;
}

CFMutableSetRef __C3DRasterizerStatesCreate_block_invoke()
{
  long long v0 = *(_OWORD *)(MEMORY[0x263EFFFA0] + 16);
  *(_OWORD *)&v2.version = *MEMORY[0x263EFFFA0];
  *(_OWORD *)&v2.release = v0;
  *(_OWORD *)&v2.equal = *(_OWORD *)(MEMORY[0x263EFFFA0] + 32);
  v2.retain = 0;
  v2.release = 0;
  CFMutableSetRef result = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, &v2);
  s_RasterizerStatesRegistry = (uint64_t)result;
  return result;
}

double __C3DMeshSourceGetTypeID_block_invoke()
{
  C3DMeshSourceGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DMeshSourceContextClassSerializable;
  unk_26B468768 = kC3DC3DMeshSourceContextClassSerializable;
  unk_26B468778 = *(_OWORD *)&off_26BF71408;
  qword_26B468720 = (uint64_t)_C3DMeshSourceCopyInstanceVariables;
  return result;
}

double __C3DMeshElementGetTypeID_block_invoke()
{
  C3DMeshElementGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DMeshElementContextClassSerializable;
  unk_26B468680 = kC3DC3DMeshElementContextClassSerializable;
  unk_26B468690 = *(_OWORD *)&off_26BF713E8;
  qword_26B468638 = (uint64_t)_C3DMeshElementCopyInstanceVariables;
  return result;
}

double __C3DImageGetTypeID_block_invoke()
{
  C3DImageGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DImageContextClassSerializable;
  unk_26B468028 = kC3DC3DImageContextClassSerializable;
  unk_26B468038 = *(_OWORD *)&off_26BF71298;
  qword_26B467FE0 = (uint64_t)_C3DImageCopyInstanceVariables;
  return result;
}

double __C3DTextureSamplerBilinearMipMapClampNoAnisotropy_block_invoke()
{
  uint64_t v0 = C3DTextureSamplerCreate();
  C3DTextureSamplerBilinearMipMapClampNoAnisotropy_states = v0;
  *(void *)(v0 + 32) = 0x100000002;
  *(void *)&double result = 0x100000001;
  *(_OWORD *)(v0 + 16) = xmmword_20B5CCF10;
  *(_DWORD *)(v0 + 72) = 2;
  *(_DWORD *)(v0 + 64) = 1065353216;
  *(void *)(v0 + 80) = ((unint64_t)*(unsigned __int8 *)(v0 + 68) << 16) | 0x10006893;
  return result;
}

const void *_C3DNodeEnumerateAttributeEntities(uint64_t a1, const void *a2, uint64_t a3)
{
  double result = CFTypeIsC3DEntity(a2);
  if (result)
  {
    int v6 = *(uint64_t (**)(uint64_t, const void *))(a3 + 16);
    return (const void *)v6(a3, a2);
  }
  return result;
}

double __C3DLODGetTypeID_block_invoke()
{
  C3DLODGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DLODContextClassSceneLink;
  unk_26B4682B0 = kC3DC3DLODContextClassSceneLink;
  unk_26B4682C0 = unk_26BF71308;
  qword_26B4682D0 = qword_26BF71318;
  qword_26B468298 = (uint64_t)_C3DLODCopyInstanceVariables;
  return result;
}

void _C3DIndexStoreCFFinalize(void *a1)
{
  CFSetCallBacks v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[6];
  if (v4)
  {
    CFRelease(v4);
    a1[6] = 0;
  }
  unint64_t v5 = (void *)a1[8];

  free(v5);
}

double __C3DGenericSourceGetTypeID_block_invoke()
{
  C3DGenericSourceGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B467E58 = kC3DC3DGenericSourceContextClassSerializable;
  unk_26B467E68 = *(_OWORD *)&off_26BF71220;
  qword_26B467E50 = (uint64_t)_C3DGenericSourceSearchByID;
  double result = *(double *)&kC3DC3DGenericSourceContextClassAnimatable;
  xmmword_26B467E00 = kC3DC3DGenericSourceContextClassAnimatable;
  return result;
}

double __C3DEffectCommonProfileGetTypeID_block_invoke()
{
  C3DEffectCommonProfileGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B4678E8 = kC3DC3DEffectCommonProfileContextClassSerializable;
  unk_26B4678F8 = *(_OWORD *)&off_26BF71150;
  qword_26B4678A0 = (uint64_t)_C3DEffectCommonProfileCopyInstanceVariables;
  double result = *(double *)&kC3DC3DEffectCommonProfileContextClassAnimatable;
  xmmword_26B467890 = kC3DC3DEffectCommonProfileContextClassAnimatable;
  return result;
}

uint64_t C3DShaderModifierGetArguments(uint64_t a1)
{
  if (!a1)
  {
    CFSetCallBacks v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 56);
}

uint64_t __C3DBlendStatesDefaultReplace_block_invoke()
{
  uint64_t v1 = 0x10000010000;
  uint64_t result = C3DBlendStatesCreate((uint64_t)&v1, 1);
  C3DBlendStatesDefaultReplace_states = result;
  return result;
}

uint64_t __C3DBlendStatesDefaultOver_block_invoke()
{
  uint64_t v1 = 0x5010005010001;
  uint64_t result = C3DBlendStatesCreate((uint64_t)&v1, 1);
  C3DBlendStatesDefaultOver_states = result;
  return result;
}

uint64_t C3DBlendStatesCreate(uint64_t a1, uint64_t a2)
{
  if (C3DBlendStatesGetTypeID_onceToken != -1) {
    dispatch_once(&C3DBlendStatesGetTypeID_onceToken, &__block_literal_global_141);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DBlendStatesGetTypeID_typeID, 0x30uLL);
  if (a2 > 3) {
    return 0;
  }
  *(void *)(result + 4_Block_object_dispose(&STACK[0x380], 8) = a2;
  if (a2 < 1)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    int v6 = 0;
    uint64_t v7 = (__int8 *)(a1 + 2);
    uint64_t v8 = (void *)(result + 16);
    do
    {
      void *v8 = *(void *)(v7 - 2);
      if (*(v7 - 2))
      {
        v5.i8[0] = *v7;
        v5.i8[4] = v7[1];
        int8x16_t v9 = v5;
        v9.i8[1] = v5.i8[4];
        v9.i8[8] = *v7;
        v9.i8[9] = v5.i8[4];
        *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v9, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
        v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
        v6 |= v5.i32[0];
        if (*(v7 - 1))
        {
          v5.i8[0] = v7[3];
          v5.i8[4] = v7[4];
          int8x16_t v10 = v5;
          v10.i8[1] = v5.i8[4];
          v10.i8[8] = v5.i8[0];
          v10.i8[9] = v5.i8[4];
          *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v10, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
          v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
          v6 |= v5.i32[0];
        }
      }
      v7 += 8;
      ++v8;
      --a2;
    }
    while (a2);
  }
  *(unsigned char *)(result + 56) = v6 & 1;
  return result;
}

SCNMatrix4 *__cdecl SCNMatrix4Mult(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *a, SCNMatrix4 *b)
{
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  long long v4 = *(_OWORD *)&a->m21;
  long long v12 = *(_OWORD *)&a->m11;
  long long v13 = v4;
  long long v5 = *(_OWORD *)&a->m41;
  long long v14 = *(_OWORD *)&a->m31;
  long long v15 = v5;
  float32x4_t v6 = *(float32x4_t *)&b->m21;
  v11[0] = *(float32x4_t *)&b->m11;
  v11[1] = v6;
  float32x4_t v7 = *(float32x4_t *)&b->m41;
  void v11[2] = *(float32x4_t *)&b->m31;
  v11[3] = v7;
  C3DMatrix4x4Mult((uint64_t)&v12, v11, &v12);
  long long v9 = v13;
  *(_OWORD *)&retstr->m11 = v12;
  *(_OWORD *)&retstr->m21 = v9;
  long long v10 = v15;
  *(_OWORD *)&retstr->m31 = v14;
  *(_OWORD *)&retstr->m41 = v10;
  return result;
}

double C3DMatrix4x4Mult(uint64_t a1, float32x4_t *a2, _OWORD *a3)
{
  uint64_t v3 = 0;
  float32x4_t v4 = *a2;
  float32x4_t v5 = a2[1];
  float32x4_t v6 = a2[2];
  float32x4_t v7 = a2[3];
  long long v8 = *(_OWORD *)(a1 + 48);
  _OWORD v13[2] = *(_OWORD *)(a1 + 32);
  v13[3] = v8;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  do
  {
    *(long long *)((char *)&v14 + v3 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v4, COERCE_FLOAT(v13[v3])), v5, *(float32x2_t *)&v13[v3], 1), v6, (float32x4_t)v13[v3], 2), v7, (float32x4_t)v13[v3], 3);
    ++v3;
  }
  while (v3 != 4);
  double result = *(double *)&v14;
  long long v10 = v15;
  long long v11 = v16;
  long long v12 = v17;
  *a3 = v14;
  a3[1] = v10;
  a3[2] = v11;
  a3[3] = v12;
  return result;
}

void __SCNGetPerformanceStatisticsEnabled_block_invoke()
{
  uint64_t v0 = getenv("SCN_ENABLE_COLLECTION");
  if (v0)
  {
    if (!strcmp(v0, "YES"))
    {
      if (SCNInitializeForDebugging(void)::onceToken != -1)
      {
        dispatch_once(&SCNInitializeForDebugging(void)::onceToken, &__block_literal_global_97);
      }
    }
  }
}

void ___ZN16CPP3DAudioEngine9GetEngineEv_block_invoke()
{
}

void sub_20B2B7BFC(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10A0C40AC8DBCBCLL);
  _Unwind_Resume(a1);
}

void CPP3DAudioEngine::CPP3DAudioEngine(CPP3DAudioEngine *this)
{
  *(void *)this = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((void *)this + 4) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 5) = (char *)this + 48;
  *((void *)this + 7) = 0;
  *((void *)this + 1) = objc_alloc_init(MEMORY[0x263F08AE0]);
}

void sub_20B2B7C90(_Unwind_Exception *a1)
{
  std::__tree<char>::destroy(v2, *v4);
  std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::destroy(v1, *v3);
  _Unwind_Resume(a1);
}

double __C3DSkinnerGetTypeID_block_invoke()
{
  C3DSkinnerGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B468F90 = kC3DC3DSkinnerContextClassSerializable;
  unk_26B468FA0 = *(_OWORD *)&off_26BF716D8;
  double result = *(double *)&kC3DC3DSkinnerContextClassSceneLink;
  *(_OWORD *)&algn_26B468F50[16] = kC3DC3DSkinnerContextClassSceneLink;
  qword_26B468F48 = (uint64_t)_C3DSkinnerCopyInstanceVariables;
  *(_OWORD *)&algn_26B468F50[32] = *(_OWORD *)&off_26BF716B0;
  qword_26B468F80 = qword_26BF716C0;
  unk_26B468F88 = _C3DSkinnerSearchByID;
  return result;
}

double __C3DSkinGetTypeID_block_invoke()
{
  C3DSkinGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B468EA8 = kC3DC3DSkinContextClassSerializable;
  unk_26B468EB8 = *(_OWORD *)&off_26BF71690;
  qword_26B468E60 = (uint64_t)_C3DSkinCopyInstanceVariables;
  double result = *(double *)&kC3DC3DSkinContextClassSceneLink;
  unk_26B468E78 = kC3DC3DSkinContextClassSceneLink;
  unk_26B468E88 = unk_26BF71668;
  qword_26B468E98 = qword_26BF71678;
  unk_26B468EA0 = _C3DSkinSearchByID;
  return result;
}

double __C3DMorpherGetTypeID_block_invoke()
{
  C3DMorpherGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B468938 = kC3DC3DMorpherContextClassSerializable;
  unk_26B468948 = *(_OWORD *)&off_26BF71498;
  double result = *(double *)&kC3DC3DMorpherContextClassSceneLink;
  unk_26B468908 = kC3DC3DMorpherContextClassSceneLink;
  unk_26B468918 = *(_OWORD *)algn_26BF71470;
  qword_26B468928 = qword_26BF71480;
  unk_26B468930 = _C3DMorpherSearchByID;
  qword_26B4688F0 = (uint64_t)_C3DMorpherCopyInstanceVariables;
  return result;
}

double __C3DMeshGetTypeID_block_invoke()
{
  C3DMeshGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B468598 = kC3DC3DMeshContextClassSerializable;
  unk_26B4685A8 = *(_OWORD *)&off_26BF713C8;
  qword_26B468550 = (uint64_t)_C3DMeshCopyInstanceVariables;
  double result = *(double *)&kC3DC3DMeshContextClassSceneLink;
  unk_26B468568 = kC3DC3DMeshContextClassSceneLink;
  unk_26B468578 = unk_26BF713A0;
  qword_26B468588 = qword_26BF713B0;
  unk_26B468590 = _C3DMeshSearchByID;
  return result;
}

double __C3DBezierCurveGeometryGetTypeID_block_invoke()
{
  uint64_t v0 = _CFRuntimeRegisterClass();
  xmmword_26B466F80 = kC3DC3DBezierCurveGeometryContextClassAnimatable;
  unk_26B466F98 = kC3DC3DBezierCurveGeometryContextClassBoundingVolumes;
  double result = *(double *)&kC3DC3DBezierCurveGeometryContextClassSceneLink;
  unk_26B466FA8 = kC3DC3DBezierCurveGeometryContextClassSceneLink;
  C3DBezierCurveGeometryGetTypeID_typeID = v0;
  unk_26B466FB8 = unk_26BF691F8;
  qword_26B466FC8 = qword_26BF69208;
  qword_26B466FF8 = (uint64_t)_C3DBezierCurveGeometryCreateCopy;
  return result;
}

void _C3DFramebufferRegistryCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
    a1[6] = 0;
  }
  uint64_t v3 = (const void *)a1[2];
  if (v3)
  {
    CFRelease(v3);
    a1[2] = 0;
  }
  float32x4_t v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  float32x4_t v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  float32x4_t v6 = (const void *)a1[9];
  if (v6)
  {
    CFRelease(v6);
    a1[9] = 0;
  }
  float32x4_t v7 = (const void *)a1[4];
  if (v7)
  {
    CFRelease(v7);
    a1[4] = 0;
  }
}

uint64_t __C3DNotificationCenterGetSharedInstance_block_invoke()
{
  uint64_t result = C3DNotificationCenterCreate();
  C3DNotificationCenterGetSharedInstance_shareduint64_t Instance = result;
  return result;
}

uint64_t C3DNotificationCenterCreate()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  if (C3DNotificationCenterGetTypeID_onceToken != -1) {
    dispatch_once(&C3DNotificationCenterGetTypeID_onceToken, &__block_literal_global_107);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DNotificationCenterGetTypeID_typeID, 0x48uLL);
  *(void *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  v2.__sig = 0;
  *(void *)v2.__opaque = 0;
  pthread_mutexattr_init(&v2);
  pthread_mutexattr_settype(&v2, 2);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 24), &v2);
  pthread_mutexattr_destroy(&v2);
  return Instance;
}

void C3D::Array<void const*,0u,C3D::MallocAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 4);
      int v6 = a2 - v5;
      if (a2 > v5)
      {
        C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::GrowCapacityBy((unsigned int *)a1, v6, 0);
        unsigned int v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(void *)(a1 + 8) + 8 * v2), 8 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

void C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::GrowCapacityBy(unsigned int *a1, int a2, int a3)
{
  float32x4_t v4 = (unsigned int *)*((void *)a1 + 1);
  double v5 = 1.5;
  if (a3) {
    double v5 = 1.0;
  }
  unsigned int v6 = (v5 * (double)(a1[1] + a2));
  float32x4_t v7 = malloc_type_malloc(8 * v6, 0x74F3E194uLL);
  memcpy(v7, v4, 8 * *a1);
  *((void *)a1 + 1) = v7;
  a1[1] = v6;
  if (v4 != a1 + 4)
  {
    free(v4);
  }
}

double __C3DMorphGetTypeID_block_invoke()
{
  C3DMorphGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B468850 = kC3DC3DMorphContextClassSerializable;
  unk_26B468860 = *(_OWORD *)&off_26BF71450;
  qword_26B468848 = (uint64_t)_C3DMorphSearchByID;
  double result = *(double *)&kC3DC3DMorphContextClassSceneLink;
  *(_OWORD *)&algn_26B468810[16] = kC3DC3DMorphContextClassSceneLink;
  qword_26B468808 = (uint64_t)_C3DMorphCopyInstanceVariables;
  *(_OWORD *)&algn_26B468810[32] = unk_26BF71428;
  qword_26B468840 = qword_26BF71438;
  qword_26B468878 = (uint64_t)_C3DMorphGenericSourceDidChange;
  return result;
}

CFDictionaryRef __C3DGetFramebufferPropertiesToDefines_block_invoke()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  long long v1 = xmmword_26400AC28;
  *(_OWORD *)keys = xmmword_26400AC18;
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)keys, (const void **)&v1, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  C3DGetFramebufferPropertiesToDefines_s_diCC_SHA256_CTX c = (uint64_t)result;
  return result;
}

id C3DAudioManagerGetAudioEngine(char a1)
{
  if (a1)
  {
    if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1) {
      dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
    }
    long long v1 = (id *)gCPP3DAudioEngineInstance;
    return CPP3DAudioEngine::GetAVEngine(v1);
  }
  else if (gCPP3DAudioEngineInstance)
  {
    if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1) {
      dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
    }
    return *(id *)gCPP3DAudioEngineInstance;
  }
  else
  {
    return 0;
  }
}

uint64_t __C3DResourceCacheGetSharedInstance_block_invoke()
{
  uint64_t result = C3DResourceCacheCreate();
  _shareduint64_t Instance = result;
  return result;
}

uint64_t C3DResourceCacheCreate()
{
  if (C3DResourceCacheGetTypeID_onceToken != -1) {
    dispatch_once(&C3DResourceCacheGetTypeID_onceToken, &__block_literal_global_90);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DResourceCacheGetTypeID_typeID, 0x20uLL);
  if (!Instance)
  {
    long long v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DResourceCacheCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  long long v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  long long v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  *(void *)(Instance + 16) = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  *(void *)(Instance + 24) = CFDictionaryCreateMutable(0, 0, 0, 0);
  *(void *)(Instance + 32) = CFDictionaryCreateMutable(0, 0, v9, v10);
  *(_DWORD *)(Instance + 40) = 0;
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, (const void *)Instance, (CFNotificationCallback)_C3DResourceCacheResourceWillDie, @"kC3DNotificationImageWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  long long v12 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(v12, (const void *)Instance, (CFNotificationCallback)_C3DResourceCacheResourceWillDie, @"kC3DNotificationImageProxyWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  return Instance;
}

CFDictionaryRef __C3DGetGeometryPropertiesToDefines_block_invoke()
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  *(_OWORD *)keys = xmmword_26400AB88;
  long long v4 = *(_OWORD *)&off_26400AB98;
  uint64_t v6 = @"_geometry.clipDistance3";
  long long v5 = xmmword_26400ABA8;
  v1[0] = xmmword_26400ABC0;
  v1[1] = *(_OWORD *)&off_26400ABD0;
  v1[2] = xmmword_26400ABE0;
  uint64_t v2 = @"USE_CLIP_DISTANCE3";
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)keys, (const void **)v1, 7, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  C3DGetGeometryPropertiesToDefines_s_diCC_SHA256_CTX c = (uint64_t)result;
  return result;
}

void _C3DFXContextCFFinalize(uint64_t a1)
{
  C3DFXContextRemoveAllPassInstances((void *)a1);
  __releaseBuiltinTechniques((void *)a1);
  uint64_t v2 = *(const void **)(a1 + 240);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    uint64_t v4 = C3DGetScene(*(void **)(a1 + 24));
    C3DRemoveSceneRef(v3, v4);
    long long v5 = *(const void **)(a1 + 24);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 24) = 0;
    }
  }
  uint64_t v6 = *(const void **)(a1 + 280);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 280) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 296);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 296) = 0;
  }
  uint64_t v8 = *(const void **)(a1 + 72);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 72) = 0;
  }
  long long v9 = *(const void **)(a1 + 40);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 40) = 0;
  }
  long long v10 = *(const void **)(a1 + 208);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 20_Block_object_dispose(&STACK[0x380], 8) = 0;
  }
  free(*(void **)(a1 + 200));
  if (*(uint64_t *)(a1 + 96) >= 1)
  {
    uint64_t v11 = 0;
    do
      CFRelease(*(CFTypeRef *)(*(void *)(a1 + 80) + 8 * v11++));
    while (v11 < *(void *)(a1 + 96));
  }
  long long v12 = *(void **)(a1 + 80);
  if (v12)
  {
    free(v12);
  }
}

void __releaseBuiltinTechniques(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  if (C3DWasLinkedBeforeMajorOSYear2017())
  {
    uint64_t v4 = (const void *)a1[6];
    if (v4)
    {
      CFRelease(v4);
      a1[6] = 0;
    }
  }
  long long v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  uint64_t v6 = (const void *)a1[11];
  if (v6)
  {
    CFRelease(v6);
    a1[11] = 0;
  }
}

void C3DFXContextRemoveAllPassInstances(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXContextSetPostProcessTechnique_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((uint64_t)a1[27] >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      for (uint64_t i = 32; i != 80; i += 8)
      {
        long long v12 = *(const void **)(*(void *)(a1[25] + 8 * v10) + i);
        if (v12)
        {
          C3DFXContextReleaseCullingData((uint64_t)a1, v12);
          *(void *)(*(void *)(a1[25] + 8 * v10) + i) = 0;
        }
      }
      C3DAllocatorDelete(a1[26], *(void *)(a1[25] + 8 * v10++));
    }
    while (v10 < a1[27]);
  }
  a1[27] = 0;
}

SCNMatrix4 *__cdecl SCNMatrix4MakeRotation(SCNMatrix4 *__return_ptr retstr, float angle, float x, float y, float z)
{
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  float32x4_t v12 = 0u;
  long long v13 = 0u;
  float32x4_t v11 = *(float32x4_t *)&x;
  C3DMatrix4x4MakeAxisAngleRotation(&v12, &v11, (float)-angle);
  long long v9 = v13;
  *(float32x4_t *)&retstr->m11 = v12;
  *(_OWORD *)&retstr->m21 = v9;
  long long v10 = v15;
  *(_OWORD *)&retstr->m31 = v14;
  *(_OWORD *)&retstr->m41 = v10;
  return result;
}

void C3DMatrix4x4MakeAxisAngleRotation(float32x4_t *a1, float32x4_t *a2, double a3)
{
  float32x4_t v4 = *a2;
  float32x4_t v6 = *(float32x4_t *)MEMORY[0x263EF89A8];
  float32x4_t v5 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v7 = vmulq_f32(v4, v4);
  float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  float32x4_t v8 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  float v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0];
  if (v10 != 0.0)
  {
    float v11 = a3;
    float v12 = v10;
    float32x2_t v13 = vrsqrte_f32((float32x2_t)LODWORD(v10));
    long long v25 = *MEMORY[0x263EF89A8];
    long long v26 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
    float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v12), vmul_f32(v13, v13)));
    float32x4_t v24 = vmulq_n_f32(v4, vmul_f32(v14, vrsqrts_f32((float32x2_t)LODWORD(v12), vmul_f32(v14, v14))).f32[0]);
    float32x4_t v28 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
    long long v27 = *(_OWORD *)(MEMORY[0x263EF89A8] + 32);
    __float2 v16 = __sincosf_stret(v11);
    *(float *)v15.i32 = v16.__cosval;
    float32x4_t v8 = v28;
    float32x4_t v17 = vmulq_n_f32(v24, 1.0 - v16.__cosval);
    float32x4_t v18 = vmulq_f32((float32x4_t)vzip1q_s32((int32x4_t)v24, (int32x4_t)v24), (float32x4_t)vzip2q_s32((int32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 0xCuLL), (int32x4_t)v17));
    float32x4_t v19 = vmlaq_f32((float32x4_t)vdupq_lane_s32(v15, 0), v17, v24);
    int8x16_t v20 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_n_f32(v24, v16.__sinval));
    float32x4_t v21 = (float32x4_t)vextq_s8(v20, v20, 0xCuLL);
    float32x4_t v22 = vsubq_f32(v18, v21);
    float32x4_t v23 = vaddq_f32(v21, v18);
    v18.i64[0] = __PAIR64__(v19.u32[1], v23.u32[0]);
    v9.i64[0] = __PAIR64__(v23.u32[2], v22.u32[1]);
    v9.i64[1] = __PAIR64__(HIDWORD(v27), v19.u32[2]);
    v19.i32[1] = v22.i32[0];
    v19.i64[1] = __PAIR64__(HIDWORD(v25), v23.u32[1]);
    v18.i64[1] = __PAIR64__(HIDWORD(v26), v22.u32[2]);
    float32x4_t v6 = v19;
    float32x4_t v5 = v18;
  }
  *a1 = v6;
  a1[1] = v5;
  a1[2] = v9;
  a1[3] = v8;
}

void __C3DGetTexturePropertiesToDefines_block_invoke()
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(_OWORD *)keys = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)values = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 100);
  for (uint64_t i = 0; i != 8; ++i)
  {
    CFStringRef v3 = off_26400AB28[i];
    keys[i] = (void *)CFStringCreateWithFormat(v0, 0, @"u_%@Texture", v3);
    CFStringReplaceAll(Mutable, v3);
    CFStringUppercase(Mutable, 0);
    values[i] = (void *)CFStringCreateWithFormat(v0, 0, @"USE_%@_MAP", Mutable);
  }
  CFRelease(Mutable);
  CFDictionaryRef v4 = CFDictionaryCreate(v0, (const void **)keys, (const void **)values, 8, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v5 = 0;
  C3DGetTexturePropertiesToDefines_s_diCC_SHA256_CTX c = (uint64_t)v4;
  do
  {
    CFRelease(keys[v5]);
    CFRelease(values[v5++]);
  }
  while (v5 != 8);
}

void __C3DGetSurfacePropertiesToDefines_block_invoke()
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  *(_OWORD *)keys = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  *(_OWORD *)values = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v21 = 0;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 100);
  for (uint64_t i = 0; i != 31; ++i)
  {
    CFStringRef v3 = off_26400AA10[i];
    keys[i] = (void *)CFStringCreateWithFormat(v0, 0, @"_surface.%@", v3);
    CFStringReplaceAll(Mutable, v3);
    CFStringUppercase(Mutable, 0);
    values[i] = (void *)CFStringCreateWithFormat(v0, 0, @"USE_%@", Mutable);
  }
  CFRelease(Mutable);
  CFDictionaryRef v4 = CFDictionaryCreate(v0, (const void **)keys, (const void **)values, 31, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v5 = 0;
  C3DGetSurfacePropertiesToDefines_s_diCC_SHA256_CTX c = (uint64_t)v4;
  do
  {
    CFRelease(keys[v5]);
    CFRelease(values[v5++]);
  }
  while (v5 != 31);
}

uint64_t C3D::DrawNodesPass::_setupPointOfView(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1[631])
  {
    long long v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3D::DrawNodesPass::_setupPointOfView(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  (*(void (**)(void *))(*a1 + 104))(a1);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a1 + 96))(a1, a2, a3, a4);
  C3DCullingContextSetupCullingMatricesAndPlanes((uint64_t)(a1 + 40), (float32x2_t *)a1[2], a2, a3, *((unsigned __int8 *)a1 + 119));
  return (*(uint64_t (**)(void *))(*a1 + 112))(a1);
}

void C3D::DrawNodesPass::_setupPointOfViewMatrices(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  if (*(unsigned char *)(a1 + 302))
  {
    char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*(void *)(a1 + 16));
    if ((C3DNodeGetProjectionInfos((uint64_t)a2, (uint64_t)v70) & 1) == 0)
    {
      float32x4_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        C3D::DrawNodesPass::_setupPointOfViewMatrices(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    double v15 = v71;
    double v14 = v72;
    *(double *)(a1 + 5064) = v71;
    *(double *)(a1 + 5072) = v14;
    *(unsigned char *)(a1 + 5015) = (v70[0] & 0x20) != 0;
    if (CoordinatesSystemOptions)
    {
      if (v14 > v15) {
        double v28 = v14;
      }
      else {
        double v28 = v15 + 1.0;
      }
      double v29 = __tanpi(0.25);
      if (v29 == 0.0) {
        double v30 = 1.0;
      }
      else {
        double v30 = 1.0 / v29;
      }
      *(float *)&unsigned int v31 = v30;
      float32x4_t v20 = (float32x4_t)v31;
      v21.i32[0] = 0;
      v21.i64[1] = 0;
      v21.i32[1] = v31;
      v23.i64[0] = 0;
      *(float *)&unsigned int v32 = v28 / (v15 - v28);
      v23.i64[1] = __PAIR64__(-1.0, v32);
      *(void *)&long long v25 = 0;
      *(float *)&unsigned int v33 = v15 * v28 / (v15 - v28);
      *((void *)&v25 + 1) = v33;
      if ((CoordinatesSystemOptions & 8) != 0)
      {
        unint64_t v34 = 0;
        float32x4_t v73 = v20;
        float32x4_t v74 = v21;
        float32x4_t v75 = v23;
        long long v76 = v25;
        do
        {
          *(float32x4_t *)((char *)&v77 + v34) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v34))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)&v73.f32[v34 / 4], 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v73 + v34), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v73 + v34), 3);
          v34 += 16;
        }
        while (v34 != 64);
        float32x4_t v20 = v77;
        float32x4_t v21 = v78;
        float32x4_t v23 = v79;
        long long v25 = v80;
      }
    }
    else
    {
      if (v14 > v15) {
        double v16 = v14;
      }
      else {
        double v16 = v15 + 1.0;
      }
      double v17 = __tanpi(0.25);
      if (v17 == 0.0) {
        double v18 = 1.0;
      }
      else {
        double v18 = 1.0 / v17;
      }
      *(float *)&unsigned int v19 = v18;
      *(void *)&long long v25 = 0;
      float32x4_t v20 = (float32x4_t)v19;
      v21.i32[0] = 0;
      v21.i64[1] = 0;
      v21.i32[1] = v19;
      v23.i64[0] = 0;
      *(float *)&unsigned int v22 = (v15 + v16) / (v15 - v16);
      v23.i64[1] = __PAIR64__(-1.0, v22);
      *(float *)&unsigned int v24 = (v15 + v15) * v16 / (v15 - v16);
      *((void *)&v25 + 1) = v24;
    }
    *(float32x4_t *)(a1 + 3792) = v20;
    *(float32x4_t *)(a1 + 380_Block_object_dispose(&STACK[0x380], 8) = v21;
    *(float32x4_t *)(a1 + 3824) = v23;
    *(_OWORD *)(a1 + 3840) = v25;
    float32x4_t v68 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
    float32x4_t v69 = *(float32x4_t *)MEMORY[0x263EF89A8];
    long long v66 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
    float32x4_t v67 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
    WorldMatrix = C3DNodeGetWorldMatrix(a2);
    unint64_t v36 = 0;
    float32x4_t v37 = *WorldMatrix;
    float32x4_t v38 = WorldMatrix[1];
    float32x4_t v39 = WorldMatrix[2];
    float32x4_t v40 = WorldMatrix[3];
    float32x4_t v41 = vnegq_f32(v69);
    float32x4_t v73 = v67;
    float32x4_t v74 = v68;
    float32x4_t v75 = v41;
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v36) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v36))), v38, *(float32x2_t *)&v73.f32[v36 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v36), 2), v40, *(float32x4_t *)((char *)&v73 + v36), 3);
      v36 += 16;
    }
    while (v36 != 64);
    unint64_t v42 = 0;
    float32x4_t v43 = v78;
    float32x4_t v44 = v79;
    long long v45 = v80;
    *(float32x4_t *)(a1 + 3024) = v77;
    *(float32x4_t *)(a1 + 3040) = v43;
    *(float32x4_t *)(a1 + 3056) = v44;
    *(_OWORD *)(a1 + 3072) = v45;
    float32x4_t v46 = vnegq_f32(v67);
    float32x4_t v73 = v46;
    float32x4_t v74 = v68;
    float32x4_t v75 = v69;
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v42) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v42))), v38, *(float32x2_t *)&v73.f32[v42 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v42), 2), v40, *(float32x4_t *)((char *)&v73 + v42), 3);
      v42 += 16;
    }
    while (v42 != 64);
    unint64_t v47 = 0;
    float32x4_t v48 = v78;
    float32x4_t v49 = v79;
    long long v50 = v80;
    *(float32x4_t *)(a1 + 308_Block_object_dispose(&STACK[0x380], 8) = v77;
    *(float32x4_t *)(a1 + 3104) = v48;
    *(float32x4_t *)(a1 + 3120) = v49;
    *(_OWORD *)(a1 + 3136) = v50;
    float32x4_t v73 = v69;
    float32x4_t v74 = v67;
    float32x4_t v75 = vnegq_f32(v68);
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v47) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v47))), v38, *(float32x2_t *)&v73.f32[v47 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v47), 2), v40, *(float32x4_t *)((char *)&v73 + v47), 3);
      v47 += 16;
    }
    while (v47 != 64);
    unint64_t v51 = 0;
    float32x4_t v52 = v78;
    float32x4_t v53 = v79;
    long long v54 = v80;
    *(float32x4_t *)(a1 + 3152) = v77;
    *(float32x4_t *)(a1 + 316_Block_object_dispose(&STACK[0x380], 8) = v52;
    *(float32x4_t *)(a1 + 3184) = v53;
    *(_OWORD *)(a1 + 3200) = v54;
    float32x4_t v73 = v69;
    float32x4_t v74 = v46;
    float32x4_t v75 = v68;
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v51) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v51))), v38, *(float32x2_t *)&v73.f32[v51 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v51), 2), v40, *(float32x4_t *)((char *)&v73 + v51), 3);
      v51 += 16;
    }
    while (v51 != 64);
    unint64_t v55 = 0;
    float32x4_t v56 = v78;
    float32x4_t v57 = v79;
    long long v58 = v80;
    *(float32x4_t *)(a1 + 3216) = v77;
    *(float32x4_t *)(a1 + 3232) = v56;
    *(float32x4_t *)(a1 + 324_Block_object_dispose(&STACK[0x380], 8) = v57;
    *(_OWORD *)(a1 + 3264) = v58;
    float32x4_t v73 = v69;
    float32x4_t v74 = v68;
    float32x4_t v75 = v67;
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v55) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v55))), v38, *(float32x2_t *)&v73.f32[v55 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v55), 2), v40, *(float32x4_t *)((char *)&v73 + v55), 3);
      v55 += 16;
    }
    while (v55 != 64);
    unint64_t v59 = 0;
    float32x4_t v60 = v78;
    float32x4_t v61 = v79;
    long long v62 = v80;
    *(float32x4_t *)(a1 + 3280) = v77;
    *(float32x4_t *)(a1 + 3296) = v60;
    *(float32x4_t *)(a1 + 3312) = v61;
    *(_OWORD *)(a1 + 332_Block_object_dispose(&STACK[0x380], 8) = v62;
    float32x4_t v73 = v41;
    float32x4_t v74 = v68;
    float32x4_t v75 = v46;
    long long v76 = v66;
    do
    {
      *(float32x4_t *)((char *)&v77 + v59) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)((char *)&v73 + v59))), v38, *(float32x2_t *)&v73.f32[v59 / 4], 1), v39, *(float32x4_t *)((char *)&v73 + v59), 2), v40, *(float32x4_t *)((char *)&v73 + v59), 3);
      v59 += 16;
    }
    while (v59 != 64);
    float32x4_t v63 = v78;
    float32x4_t v64 = v79;
    long long v65 = v80;
    *(float32x4_t *)(a1 + 3344) = v77;
    *(float32x4_t *)(a1 + 3360) = v63;
    *(float32x4_t *)(a1 + 3376) = v64;
    *(_OWORD *)(a1 + 3392) = v65;
    C3DCullingContextSetupViewAndViewProjMatricesForCubemapRendering(a1 + 320);
  }
  else
  {
    uint64_t v26 = a1 + 320;
    uint64_t v27 = *(void *)(a1 + 16);
    C3DCullingContextSetupPointOfViewMatrices(v26, v27, a2, a3);
  }
}

__n128 C3DCullingContextSetupPointOfViewMatrices(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4)
{
  uint64_t v8 = (unsigned __int8 *)(a1 + 4628);
  int v9 = *(unsigned __int8 *)(a1 + 4697);
  char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(a2);
  if (v8[68]) {
    BOOL v11 = 0;
  }
  else {
    BOOL v11 = v9 == 2;
  }
  if (!v11)
  {
    Eyeint Count = C3DEngineContextGetEyeCount(a2);
    unsigned __int8 *v8 = EyeCount;
    if (v9)
    {
      if (v9 == 1)
      {
        memset(&v113, 0, sizeof(v113));
        C3DNodeComputeWorldMatrix(a3, (uint64_t)&v113);
        simd_float4x4 v129 = __invert_f4(v113);
        simd_float4 v111 = v129.columns[1];
        simd_float4 v112 = v129.columns[0];
        simd_float4 v109 = v129.columns[3];
        simd_float4 v110 = v129.columns[2];
        if (*v8)
        {
          unint64_t v13 = 0;
          do
          {
            EyeMatrix4x4 = (simd_float4 *)C3DEngineContextGetEyeMatrix4x4(a2, 0, v13);
            simd_float4 v16 = *EyeMatrix4x4;
            simd_float4 v15 = EyeMatrix4x4[1];
            simd_float4 v17 = EyeMatrix4x4[2];
            simd_float4 v18 = EyeMatrix4x4[3];
            if ((CoordinatesSystemOptions & 8) != 0)
            {
              unint64_t v20 = 0;
              simd_float4 v125 = *EyeMatrix4x4;
              simd_float4 v126 = v15;
              simd_float4 v127 = v17;
              simd_float4 v128 = v18;
              memset(&v114, 0, sizeof(v114));
              do
              {
                v114.columns[v20 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v20 * 4))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)&v125.f32[v20], 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v125 + v20 * 4), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v125 + v20 * 4), 3);
                v20 += 4;
              }
              while (v20 != 16);
              unsigned int v19 = (simd_float4 *)(a1 + (v13 << 6));
              simd_float4 v16 = v114.columns[0];
              simd_float4 v15 = v114.columns[1];
              simd_float4 v17 = v114.columns[2];
              simd_float4 v18 = v114.columns[3];
            }
            else
            {
              unsigned int v19 = (simd_float4 *)(a1 + (v13 << 6));
            }
            v19[217] = v16;
            float32x4_t v21 = (_OWORD *)(a1 + (v13 << 6));
            v21[218] = v15;
            v21[219] = v17;
            v21[220] = v18;
            unsigned int v22 = (float32x4_t *)C3DEngineContextGetEyeMatrix4x4(a2, 1, v13);
            unint64_t v23 = 0;
            float32x4_t v24 = *v22;
            float32x4_t v25 = v22[1];
            float32x4_t v26 = v22[2];
            float32x4_t v27 = v22[3];
            simd_float4 v125 = v112;
            simd_float4 v126 = v111;
            simd_float4 v127 = v110;
            simd_float4 v128 = v109;
            memset(&v114, 0, sizeof(v114));
            do
            {
              v114.columns[v23 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v23 * 4))), v25, *(float32x2_t *)&v125.f32[v23], 1), v26, *(float32x4_t *)((char *)&v125 + v23 * 4), 2), v27, *(float32x4_t *)((char *)&v125 + v23 * 4), 3);
              v23 += 4;
            }
            while (v23 != 16);
            simd_float4x4 v130 = v114;
            uint64_t v28 = a1 + (v13 << 6);
            *(simd_float4 *)(v28 + 308_Block_object_dispose(&STACK[0x380], 8) = v114.columns[0];
            *(simd_float4 *)(v28 + 3104) = v130.columns[1];
            *(simd_float4 *)(v28 + 3120) = v130.columns[2];
            *(simd_float4 *)(v28 + 3136) = v130.columns[3];
            *(simd_float4x4 *)(v28 + 2704) = __invert_f4(v130);
            long long v29 = *(_OWORD *)(v28 + 2720);
            *(_OWORD *)(v28 + 592) = *(_OWORD *)(v28 + 2704);
            *(_OWORD *)(v28 + 60_Block_object_dispose(&STACK[0x380], 8) = v29;
            long long v30 = *(_OWORD *)(v28 + 2752);
            *(_OWORD *)(v28 + 624) = *(_OWORD *)(v28 + 2736);
            *(_OWORD *)(v28 + 640) = v30;
            long long v31 = *(_OWORD *)(v28 + 3472);
            long long v32 = *(_OWORD *)(v28 + 3488);
            long long v33 = *(_OWORD *)(v28 + 3504);
            *(_OWORD *)(v28 + 140_Block_object_dispose(&STACK[0x380], 8) = *(_OWORD *)(v28 + 3520);
            *(_OWORD *)(v28 + 1392) = v33;
            *(_OWORD *)(v28 + 1376) = v32;
            *(_OWORD *)(v28 + 1360) = v31;
            ++v13;
          }
          while (v13 < *v8);
        }
LABEL_54:
        *(__n128 *)(a1 + 4640) = C3DEngineContextGetViewportAtIndex(a2, 0);
        LODWORD(v99) = *(_DWORD *)(a1 + 3512);
        double v100 = *(float *)&v99;
        float v101 = *(float *)(a1 + 3528);
        double v102 = v101;
        if (*(float *)(a1 + 3516) == 0.0)
        {
          double v103 = (v102 + -1.0) / v100;
          double v104 = (v102 + 1.0) / v100;
          *(float *)&double v104 = v104;
          double v105 = -(1.0 - v102) / v100;
          if (v101 < -1.0) {
            double v106 = v105;
          }
          else {
            double v106 = v103;
          }
          *(float *)&double v105 = v101 / *(float *)&v99;
          if (v101 < -1.0) {
            double v105 = v104;
          }
        }
        else
        {
          BOOL v107 = v101 < -2.0;
          *(float *)&double v99 = v101 / *(float *)&v99;
          double v108 = v102 / (v100 + 1.0);
          double v105 = v102 / (v100 + -1.0);
          *(float *)&double v105 = v105;
          double v106 = v108;
          if (!v107) {
            double v105 = v99;
          }
        }
        *(float *)&double v106 = v106;
        __n128 result = (__n128)vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(*(float32x2_t *)&v105, *(float32x2_t *)&v106), 0), (int8x8_t)vrev64_s32((int32x2_t)__PAIR64__(LODWORD(v106), LODWORD(v105))), (int8x8_t)__PAIR64__(LODWORD(v106), LODWORD(v105))));
        *(__n128 *)(v8 + 116) = result;
        return result;
      }
      if (!v8[68])
      {
        uint64_t v91 = scn_default_log();
        if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
          C3DCullingContextSetupPointOfViewMatrices_cold_3(v91, v92, v93, v94, v95, v96, v97, v98);
        }
        goto LABEL_54;
      }
    }
    if (EyeCount)
    {
      unint64_t v74 = 0;
      do
      {
        float32x4_t v75 = (_OWORD *)C3DEngineContextGetEyeMatrix4x4(a2, 1, v74);
        uint64_t v76 = a1 + (v74 << 6);
        long long v77 = v75[2];
        long long v78 = v75[3];
        long long v79 = v75[1];
        *(_OWORD *)(v76 + 308_Block_object_dispose(&STACK[0x380], 8) = *v75;
        *(_OWORD *)(v76 + 3136) = v78;
        *(_OWORD *)(v76 + 3120) = v77;
        *(_OWORD *)(v76 + 3104) = v79;
        long long v80 = (simd_float4 *)C3DEngineContextGetEyeMatrix4x4(a2, 0, v74);
        simd_float4 v81 = v80[1];
        simd_float4 v82 = v80[2];
        simd_float4 v83 = v80[3];
        if ((CoordinatesSystemOptions & 8) != 0)
        {
          unint64_t v84 = 0;
          simd_float4 v125 = *v80;
          simd_float4 v126 = v81;
          simd_float4 v127 = v82;
          simd_float4 v128 = v83;
          memset(&v114, 0, sizeof(v114));
          do
          {
            v114.columns[v84 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v84 * 4))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)&v125.f32[v84], 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v125 + v84 * 4), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v125 + v84 * 4), 3);
            v84 += 4;
          }
          while (v84 != 16);
          simd_float4 v81 = v114.columns[1];
          simd_float4 v82 = v114.columns[2];
          simd_float4 v83 = v114.columns[3];
          *(simd_float4 *)(a1 + (v74 << 6) + 3472) = v114.columns[0];
        }
        else
        {
          *(simd_float4 *)(v76 + 3472) = *v80;
        }
        uint64_t v85 = a1 + (v74 << 6);
        *(simd_float4 *)(v85 + 348_Block_object_dispose(&STACK[0x380], 8) = v81;
        *(simd_float4 *)(v85 + 3504) = v82;
        *(simd_float4 *)(v85 + 3520) = v83;
        *(simd_float4x4 *)(v85 + 2704) = __invert_f4(*(simd_float4x4 *)(v76 + 3088));
        long long v86 = *(_OWORD *)(v85 + 2720);
        *(_OWORD *)(v85 + 592) = *(_OWORD *)(v85 + 2704);
        *(_OWORD *)(v85 + 60_Block_object_dispose(&STACK[0x380], 8) = v86;
        long long v87 = *(_OWORD *)(v85 + 2752);
        *(_OWORD *)(v85 + 624) = *(_OWORD *)(v85 + 2736);
        *(_OWORD *)(v85 + 640) = v87;
        long long v88 = *(_OWORD *)(v85 + 3472);
        long long v89 = *(_OWORD *)(v85 + 3488);
        long long v90 = *(_OWORD *)(v85 + 3504);
        *(_OWORD *)(v85 + 140_Block_object_dispose(&STACK[0x380], 8) = *(_OWORD *)(v85 + 3520);
        *(_OWORD *)(v85 + 1392) = v90;
        *(_OWORD *)(v85 + 1376) = v89;
        *(_OWORD *)(v85 + 1360) = v88;
        ++v74;
      }
      while (v74 < *v8);
    }
    goto LABEL_54;
  }
  long long v123 = 0u;
  long long v124 = 0u;
  long long v121 = 0u;
  long long v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  memset(&v114, 0, sizeof(v114));
  if ((C3DNodeGetProjectionInfos((uint64_t)a3, (uint64_t)&v114) & 1) == 0)
  {
    unint64_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      C3DCullingContextSetupLOD_cold_1(v34, v35, v36, v37, v38, v39, v40, v41);
    }
  }
  if ((v114.columns[0].i8[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange(a2)) {
    C3DAdjustZRangeOfProjectionInfos((uint64_t)&v114, a3, a1 + 4640, *(void *)(a1 + 4728));
  }
  unint64_t v42 = &v114.columns[0].i64[1];
  if (v8[66]) {
    float32x4_t v43 = (uint64_t *)(v8 + 116);
  }
  else {
    float32x4_t v43 = &v114.columns[0].i64[1];
  }
  if (!v8[66]) {
    unint64_t v42 = (uint64_t *)(v8 + 116);
  }
  *(_OWORD *)unint64_t v42 = *(_OWORD *)v43;
  v8[67] = (v114.columns[0].i8[0] & 0x20) != 0;
  float32x4_t v44 = (_OWORD *)(a1 + 3472);
  Matrix = C3DProjectionInfosGetMatrix((char *)&v114, a1 + 4640, CoordinatesSystemOptions);
  long long v46 = *((_OWORD *)Matrix + 2);
  long long v47 = *((_OWORD *)Matrix + 3);
  long long v48 = *((_OWORD *)Matrix + 1);
  *(_OWORD *)(a1 + 3472) = *(_OWORD *)Matrix;
  *(_OWORD *)(a1 + 3520) = v47;
  *(_OWORD *)(a1 + 3504) = v46;
  *(_OWORD *)(a1 + 348_Block_object_dispose(&STACK[0x380], 8) = v48;
  float32x4_t v49 = (_OWORD *)(a1 + 2704);
  C3DNodeComputeWorldMatrix(a3, a1 + 2704);
  if (a3 == a4)
  {
    long long v63 = *(_OWORD *)(a1 + 2720);
    *(_OWORD *)(a1 + 592) = *v49;
    *(_OWORD *)(a1 + 60_Block_object_dispose(&STACK[0x380], 8) = v63;
    long long v64 = *(_OWORD *)(a1 + 2752);
    *(_OWORD *)(a1 + 624) = *(_OWORD *)(a1 + 2736);
    *(_OWORD *)(a1 + 640) = v64;
    long long v65 = *(_OWORD *)(a1 + 3488);
    *(_OWORD *)(a1 + 1360) = *v44;
    *(_OWORD *)(a1 + 1376) = v65;
    __n128 result = *(__n128 *)(a1 + 3504);
    long long v66 = *(_OWORD *)(a1 + 3520);
    *(__n128 *)(a1 + 1392) = result;
    *(_OWORD *)(a1 + 140_Block_object_dispose(&STACK[0x380], 8) = v66;
  }
  else
  {
    if ((C3DNodeGetProjectionInfos((uint64_t)a4, (uint64_t)&v114) & 1) == 0)
    {
      long long v50 = scn_default_log();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
        C3DCullingContextSetupLOD_cold_1(v50, v51, v52, v53, v54, v55, v56, v57);
      }
    }
    if ((v114.columns[0].i8[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange(a2)) {
      C3DAdjustZRangeOfProjectionInfos((uint64_t)&v114, a3, a1 + 4640, *(void *)(a1 + 4728));
    }
    *(simd_float4 *)(v8 + 116) = *(simd_float4 *)((char *)v114.columns + 8);
    long long v58 = C3DProjectionInfosGetMatrix((char *)&v114, a1 + 4640, CoordinatesSystemOptions);
    long long v59 = *((_OWORD *)v58 + 2);
    long long v60 = *((_OWORD *)v58 + 3);
    long long v61 = *((_OWORD *)v58 + 1);
    *(_OWORD *)(a1 + 1360) = *(_OWORD *)v58;
    *(_OWORD *)(a1 + 140_Block_object_dispose(&STACK[0x380], 8) = v60;
    *(_OWORD *)(a1 + 1392) = v59;
    *(_OWORD *)(a1 + 1376) = v61;
    result.n128_u64[0] = C3DNodeComputeWorldMatrix(a4, a1 + 592).n128_u64[0];
  }
  if (*v8 >= 2u)
  {
    uint64_t v67 = a1 + 2768;
    unint64_t v68 = 1;
    do
    {
      long long v69 = *v44;
      long long v70 = *(_OWORD *)(a1 + 3488);
      long long v71 = *(_OWORD *)(a1 + 3520);
      *(_OWORD *)(v67 + 800) = *(_OWORD *)(a1 + 3504);
      *(_OWORD *)(v67 + 816) = v71;
      *(_OWORD *)(v67 + 76_Block_object_dispose(&STACK[0x380], 8) = v69;
      *(_OWORD *)(v67 + 784) = v70;
      __n128 result = *(__n128 *)v49;
      long long v72 = *(_OWORD *)(a1 + 2720);
      long long v73 = *(_OWORD *)(a1 + 2752);
      *(_OWORD *)(v67 + 32) = *(_OWORD *)(a1 + 2736);
      *(_OWORD *)(v67 + 4_Block_object_dispose(&STACK[0x380], 8) = v73;
      *(__n128 *)uint64_t v67 = result;
      *(_OWORD *)(v67 + 16) = v72;
      v67 += 64;
      ++v68;
    }
    while (v68 < *v8);
  }
  return result;
}

__n128 C3DNodeComputeWorldMatrix(float32x4_t *a1, uint64_t a2)
{
  if (!a2)
  {
    CFDictionaryRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DNodeComputeWorldMatrix_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  WorldMatrix = C3DNodeGetWorldMatrix(a1);
  __n128 result = (__n128)WorldMatrix[2];
  float32x4_t v14 = WorldMatrix[3];
  float32x4_t v16 = *WorldMatrix;
  float32x4_t v15 = WorldMatrix[1];
  *(__n128 *)(a2 + 32) = result;
  *(float32x4_t *)(a2 + 4_Block_object_dispose(&STACK[0x380], 8) = v14;
  *(float32x4_t *)a2 = v16;
  *(float32x4_t *)(a2 + 16) = v15;
  return result;
}

double C3DCullingContextSetupLOD(uint64_t a1, __n128 *a2)
{
  PointOfViewForCulling = C3DEngineContextGetPointOfViewForCulling((uint64_t)a2);
  if (PointOfViewForCulling)
  {
    uint64_t v6 = PointOfViewForCulling;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfViewForCulling);
    float32x4_t v8 = WorldMatrix[2];
    float32x4_t v9 = WorldMatrix[3];
    float32x4_t v10 = vnegq_f32(v8);
    float32x4_t v11 = vmulq_f32(v9, v10);
    v10.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
    float32x4_t v12 = *WorldMatrix;
    float32x4_t v13 = WorldMatrix[1];
    *(float32x4_t *)(a1 + 476_Block_object_dispose(&STACK[0x380], 8) = v10;
    *(float32x4_t *)(a1 + 4784) = v12;
    *(float32x4_t *)(a1 + 4800) = v13;
    *(float32x4_t *)(a1 + 4816) = v8;
    *(float32x4_t *)(a1 + 4832) = v9;
    __n128 Viewport = C3DEngineContextGetViewport(a2);
    memset(v32, 0, sizeof(v32));
    if ((C3DNodeGetProjectionInfos((uint64_t)v6, (uint64_t)v32) & 1) == 0)
    {
      float32x4_t v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        C3DCullingContextSetupLOD_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
      }
    }
    if ((v32[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange((uint64_t)a2)) {
      C3DAdjustZRangeOfProjectionInfos((uint64_t)v32, v6, (uint64_t)&Viewport, *(void *)(a1 + 4728));
    }
    if (*(unsigned char *)(a1 + 4694)) {
      *(_OWORD *)((char *)v32 + _Block_object_dispose(&STACK[0x380], 8) = *(_OWORD *)(a1 + 4744);
    }
    char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a2);
    Matrix = C3DProjectionInfosGetMatrix((char *)v32, (uint64_t)&Viewport, CoordinatesSystemOptions);
    float32x4_t v30 = *((float32x4_t *)Matrix + 1);
    float32x4_t v31 = *(float32x4_t *)Matrix;
    float32x4_t v28 = *((float32x4_t *)Matrix + 3);
    float32x4_t v29 = *((float32x4_t *)Matrix + 2);
    simd_float4x4 v39 = __invert_f4(*(simd_float4x4 *)(a1 + 4784));
    uint64_t v24 = 0;
    simd_float4x4 v34 = v39;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    do
    {
      *(long long *)((char *)&v35 + v24 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v31, COERCE_FLOAT(*(_OWORD *)&v34.columns[v24])), v30, *(float32x2_t *)v34.columns[v24].f32, 1), v29, (float32x4_t)v34.columns[v24], 2), v28, (float32x4_t)v34.columns[v24], 3);
      ++v24;
    }
    while (v24 != 4);
    double result = *(double *)&v35;
    long long v25 = v36;
    long long v26 = v37;
    long long v27 = v38;
    *(_OWORD *)(a1 + 484_Block_object_dispose(&STACK[0x380], 8) = v35;
    *(_OWORD *)(a1 + 4864) = v25;
    *(_OWORD *)(a1 + 4880) = v26;
    *(_OWORD *)(a1 + 4896) = v27;
  }
  return result;
}

char *C3DProjectionInfosGetMatrix(char *a1, uint64_t a2, char a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  char v14 = *a1;
  if ((*a1 & 8) == 0)
  {
    if ((*a1 & 1) == 0)
    {
      if ((*a1 & 0x10) != 0)
      {
        double v44 = *((double *)a1 + 26);
        double v45 = 1.0;
        if (a2)
        {
          LODWORD(v46) = HIDWORD(*(_OWORD *)a2);
          if (v46 != 0.0) {
            double v45 = (float)(COERCE_FLOAT(*(void *)(a2 + 8)) / v46);
          }
        }
        if (v44 == 0.0 && *((double *)a1 + 27) == 0.0) {
          double v48 = 60.0;
        }
        else {
          double v48 = *((double *)a1 + 27);
        }
        if (v44 != 0.0 && v48 != 0.0)
        {
          double v49 = tan(v44 / 180.0 * 3.14159265);
          if (v49 / tan(v48 / 180.0 * 3.14159265) > v45) {
            double v48 = 0.0;
          }
          else {
            double v44 = 0.0;
          }
        }
        double v50 = *((double *)a1 + 1);
        if (*((double *)a1 + 2) > v50) {
          double v51 = *((double *)a1 + 2);
        }
        else {
          double v51 = v50 + 1.0;
        }
        if (v48 == 0.0) {
          double v52 = v44;
        }
        else {
          double v52 = v48;
        }
        double v53 = __tanpi(v52 / 360.0);
        if (v53 == 0.0) {
          double v54 = 1.0;
        }
        else {
          double v54 = 1.0 / v53;
        }
        if (v44 == 0.0) {
          double v55 = v48;
        }
        else {
          double v55 = v44;
        }
        double v56 = __tanpi(v55 / 360.0);
        if (v56 == 0.0) {
          double v57 = 1.0;
        }
        else {
          double v57 = 1.0 / v56;
        }
        float v58 = v57;
        LODWORD(v60) = 0;
        *((void *)&v60 + 1) = 0;
        float v59 = v54;
        *((float *)&v60 + 1) = v59;
        double v61 = v50 - v51;
        if (a3)
        {
          v31.f64[0] = 0.0;
          *(float *)&unsigned int v71 = v51 / (v50 - v51);
          *(void *)&v31.f64[1] = __PAIR64__(-1.0, v71);
        }
        else
        {
          *(float *)&unsigned int v62 = (v50 + v51) / (v50 - v51);
          v31.f64[0] = 0.0;
          *(void *)&v31.f64[1] = __PAIR64__(-1.0, v62);
          double v51 = v51 + v51;
        }
        *(float *)&unsigned int v72 = v50 * v51 / v61;
        *(void *)&_Q1 = 0;
        *((void *)&_Q1 + 1) = v72;
        *((_OWORD *)a1 + 5) = LODWORD(v58);
        *((_OWORD *)a1 + 6) = v60;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = _Q1;
        if (v44 == 0.0)
        {
          double v74 = v58 / v45;
          goto LABEL_89;
        }
        double v89 = v45 * v59;
LABEL_92:
        float v97 = v89;
        *((float *)a1 + 25) = v97;
        if ((a3 & 8) == 0) {
          goto LABEL_96;
        }
        goto LABEL_93;
      }
      if (a2
        && (float32x2_t v15 = *(float32x2_t *)(a1 + 24),
            uint32x2_t v16 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v15)),
            (vpmax_u32(v16, v16).u32[0] & 0x80000000) != 0))
      {
        float v17 = *((float *)a1 + 14) / 180.0 * 3.14159265 * 0.5;
        double v18 = *((double *)a1 + 1);
        float v19 = v18 * tanf(v17);
        float32x2_t v20 = vdiv_f32(vadd_f32(v15, v15), *(float32x2_t *)(a2 + 8));
        double v21 = *((double *)a1 + 2);
        if (v21 <= v18) {
          double v21 = v18 + 1.0;
        }
        __asm { FMOV            V4.2S, #1.0 }
        float64x2_t v26 = vcvtq_f64_f32(vmul_n_f32(vadd_f32(v20, _D4), -v19));
        float64x2_t v31 = vcvtq_f64_f32(vmul_n_f32(vsub_f32(_D4, v20), v19));
        float64x2_t v27 = vsubq_f64(v31, v26);
        float v28 = (v18 + v18) / v27.f64[0];
        LODWORD(v30) = 0;
        *((void *)&v30 + 1) = 0;
        float v29 = (v18 + v18) / v27.f64[1];
        *((float *)&v30 + 1) = v29;
        *(float32x2_t *)&v31.f64[0] = vcvt_f32_f64(vdivq_f64(vaddq_f64(v31, v26), v27));
        if (a3)
        {
          double v33 = v18 - v21;
          double v34 = v21 / (v18 - v21);
        }
        else
        {
          double v32 = v18 + v21;
          double v33 = v18 - v21;
          double v18 = v18 + v18;
          double v34 = v32 / v33;
        }
        *(float *)&unsigned int v90 = v34;
        *(void *)&v31.f64[1] = __PAIR64__(-1.0, v90);
        *(float *)&unsigned int v91 = v18 * v21 / v33;
        *(void *)&_Q1 = 0;
        *((void *)&_Q1 + 1) = v91;
        *((_OWORD *)a1 + 5) = LODWORD(v28);
        *((_OWORD *)a1 + 6) = v30;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = _Q1;
        double v92 = *((double *)a1 + 8);
      }
      else
      {
        double v64 = *((double *)a1 + 1);
        if (*((double *)a1 + 2) > v64) {
          double v65 = *((double *)a1 + 2);
        }
        else {
          double v65 = v64 + 1.0;
        }
        double v66 = __tanpi(*((float *)a1 + 14) / 360.0);
        if (v66 == 0.0) {
          double v67 = 1.0;
        }
        else {
          double v67 = 1.0 / v66;
        }
        float v28 = v67;
        LODWORD(v6_Block_object_dispose(&STACK[0x380], 8) = 0;
        *((void *)&v68 + 1) = 0;
        *((float *)&v68 + 1) = v28;
        double v69 = v64 - v65;
        if (a3)
        {
          v31.f64[0] = 0.0;
          *(float *)&unsigned int v93 = v65 / (v64 - v65);
          *(void *)&v31.f64[1] = __PAIR64__(-1.0, v93);
        }
        else
        {
          *(float *)&unsigned int v70 = (v64 + v65) / (v64 - v65);
          v31.f64[0] = 0.0;
          *(void *)&v31.f64[1] = __PAIR64__(-1.0, v70);
          double v64 = v64 + v64;
        }
        *(float *)&unsigned int v94 = v64 * v65 / v69;
        *(void *)&_Q1 = 0;
        *((void *)&_Q1 + 1) = v94;
        *((_OWORD *)a1 + 5) = LODWORD(v28);
        *((_OWORD *)a1 + 6) = v68;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = _Q1;
        double v92 = *((double *)a1 + 8);
        float v29 = v28;
        if (!a2) {
          goto LABEL_87;
        }
      }
      LODWORD(v95) = HIDWORD(*(_OWORD *)a2);
      if (v95 != 0.0) {
        double v92 = (float)(COERCE_FLOAT(*(void *)(a2 + 8)) / v95);
      }
LABEL_87:
      if ((v14 & 0x20) == 0)
      {
        double v74 = v28 / v92;
LABEL_89:
        float v96 = v74;
        *((float *)a1 + 20) = v96;
        if ((a3 & 8) == 0) {
          goto LABEL_96;
        }
        goto LABEL_93;
      }
      double v89 = v92 * v29;
      goto LABEL_92;
    }
    double v37 = *((double *)a1 + 6);
    if (!a2)
    {
      double v63 = *((double *)a1 + 6);
      goto LABEL_72;
    }
    LODWORD(v3_Block_object_dispose(&STACK[0x380], 8) = HIDWORD(*(_OWORD *)a2);
    if (v38 == 0.0)
    {
      float v39 = 1.0;
      if (C3DWasLinkedBeforeMajorOSYear2017()) {
        goto LABEL_70;
      }
    }
    else
    {
      float v39 = COERCE_FLOAT(*(void *)(a2 + 8)) / v38;
      if (C3DWasLinkedBeforeMajorOSYear2017())
      {
        if (v39 <= 1.0)
        {
LABEL_70:
          double v75 = v39;
          goto LABEL_71;
        }
        double v75 = v39;
LABEL_69:
        double v63 = v37;
        double v37 = v37 * v75;
        goto LABEL_72;
      }
    }
    double v75 = v39;
    if ((*a1 & 0x20) != 0)
    {
LABEL_71:
      double v63 = v37 / v75;
LABEL_72:
      double v76 = *((double *)a1 + 1);
      if (*((double *)a1 + 2) > v76) {
        double v77 = *((double *)a1 + 2);
      }
      else {
        double v77 = v76 + 1.0;
      }
      *(float *)&unsigned int v78 = 2.0 / (v37 + v37);
      v31.f64[0] = 0.0;
      HIDWORD(v31.f64[1]) = 0;
      long long v79 = v78;
      float v80 = 2.0 / (v63 + v63);
      LODWORD(v81) = 0;
      *((void *)&v81 + 1) = 0;
      *((float *)&v81 + 1) = v80;
      double v82 = v76 - v77;
      float v84 = -(v63 - v63) / (v63 + v63);
      if (a3)
      {
        float v87 = 1.0 / v82;
        *(float *)&v31.f64[1] = v87;
        double v86 = v76 / v82;
      }
      else
      {
        float v85 = 2.0 / v82;
        *(float *)&v31.f64[1] = v85;
        double v86 = (v76 + v77) / v82;
      }
      float v88 = v86;
      __asm { FMOV            V1.4S, #1.0 }
      *(float *)&unsigned int v83 = -(v37 - v37) / (v37 + v37);
      *(void *)&_Q1 = __PAIR64__(LODWORD(v84), v83);
      *((float *)&_Q1 + 2) = v88;
      *((_OWORD *)a1 + 5) = v79;
      *((_OWORD *)a1 + 6) = v81;
      *((float64x2_t *)a1 + 7) = v31;
      *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = _Q1;
      if ((a3 & 8) == 0)
      {
LABEL_96:
        v101.i64[0] = *((void *)a1 + 4);
        float32x2_t v102 = *(float32x2_t *)(a1 + 40);
        uint32x2_t v103 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)v101.f32));
        if ((vpmax_u32(v103, v103).u32[0] & 0x80000000) != 0) {
          goto LABEL_98;
        }
        __asm { FMOV            V3.2S, #1.0 }
        uint32x2_t v105 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v102, _D3));
        if ((vpmax_u32(v105, v105).u32[0] & 0x80000000) != 0)
        {
LABEL_98:
          uint64_t v106 = 0;
          v107.i32[0] = 0;
          v107.i32[3] = 0;
          *(uint64_t *)((char *)v107.i64 + 4) = HIDWORD(*((void *)a1 + 5));
          v101.i32[2] = 0;
          v101.i32[3] = 1.0;
          long long v108 = *((_OWORD *)a1 + 6);
          long long v113 = *((_OWORD *)a1 + 5);
          long long v114 = v108;
          float64x2_t v115 = v31;
          long long v116 = _Q1;
          long long v117 = 0u;
          long long v118 = 0u;
          float64x2_t v119 = 0u;
          long long v120 = 0u;
          do
          {
            *(long long *)((char *)&v117 + v106) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v102.u32[0], COERCE_FLOAT(*(long long *)((char *)&v113 + v106))), v107, *(float32x2_t *)((char *)&v113 + v106), 1), (float32x4_t)xmmword_20B5CB520, *(float32x4_t *)((char *)&v113 + v106), 2), v101, *(float32x4_t *)((char *)&v113 + v106), 3);
            v106 += 16;
          }
          while (v106 != 64);
LABEL_100:
          long long v109 = v118;
          float64x2_t v110 = v119;
          long long v111 = v120;
          *((_OWORD *)a1 + 5) = v117;
          *((_OWORD *)a1 + 6) = v109;
          *((float64x2_t *)a1 + 7) = v110;
          *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = v111;
          return a1 + 80;
        }
        return a1 + 80;
      }
LABEL_93:
      uint64_t v98 = 0;
      long long v99 = *((_OWORD *)a1 + 6);
      long long v113 = *((_OWORD *)a1 + 5);
      long long v114 = v99;
      float64x2_t v115 = v31;
      long long v116 = _Q1;
      long long v117 = 0u;
      long long v118 = 0u;
      float64x2_t v119 = 0u;
      long long v120 = 0u;
      do
      {
        *(long long *)((char *)&v117 + v9_Block_object_dispose(&STACK[0x380], 8) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(long long *)((char *)&v113 + v98))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)((char *)&v113 + v98), 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v113 + v98), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v113 + v98), 3);
        v98 += 16;
      }
      while (v98 != 64);
      long long v100 = v118;
      float64x2_t v31 = v119;
      _Q1 = v120;
      *((_OWORD *)a1 + 5) = v117;
      *((_OWORD *)a1 + 6) = v100;
      *((float64x2_t *)a1 + 7) = v31;
      *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = _Q1;
      goto LABEL_96;
    }
    goto LABEL_69;
  }
  if ((a3 & 8) != 0)
  {
    uint64_t v40 = 0;
    long long v41 = *((_OWORD *)a1 + 10);
    float64x2_t v42 = *((float64x2_t *)a1 + 11);
    long long v43 = *((_OWORD *)a1 + 12);
    long long v113 = *((_OWORD *)a1 + 9);
    long long v114 = v41;
    float64x2_t v115 = v42;
    long long v116 = v43;
    long long v117 = 0u;
    long long v118 = 0u;
    float64x2_t v119 = 0u;
    long long v120 = 0u;
    do
    {
      *(long long *)((char *)&v117 + v40) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(long long *)((char *)&v113 + v40))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)((char *)&v113 + v40), 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v113 + v40), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v113 + v40), 3);
      v40 += 16;
    }
    while (v40 != 64);
    goto LABEL_100;
  }
  long long v35 = *((_OWORD *)a1 + 10);
  *((_OWORD *)a1 + 5) = *((_OWORD *)a1 + 9);
  *((_OWORD *)a1 + 6) = v35;
  long long v36 = *((_OWORD *)a1 + 12);
  *((_OWORD *)a1 + 7) = *((_OWORD *)a1 + 11);
  *((_OWORD *)a1 + _Block_object_dispose(&STACK[0x380], 8) = v36;
  return a1 + 80;
}

uint64_t C3DNodeGetProjectionInfos(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    CFDictionaryRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetProjectionInfos_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CamerSCNMatrix4 a = C3DNodeGetCamera(a1);
  if (Camera)
  {
    ProjectionInfosPtr = (_OWORD *)C3DCameraGetProjectionInfosPtr((uint64_t)Camera);
    long long v14 = ProjectionInfosPtr[1];
    *(_OWORD *)a2 = *ProjectionInfosPtr;
    *(_OWORD *)(a2 + 16) = v14;
    long long v15 = ProjectionInfosPtr[5];
    long long v17 = ProjectionInfosPtr[2];
    long long v16 = ProjectionInfosPtr[3];
    *(_OWORD *)(a2 + 64) = ProjectionInfosPtr[4];
    *(_OWORD *)(a2 + 80) = v15;
    *(_OWORD *)(a2 + 32) = v17;
    *(_OWORD *)(a2 + 4_Block_object_dispose(&STACK[0x380], 8) = v16;
    long long v18 = ProjectionInfosPtr[9];
    long long v20 = ProjectionInfosPtr[6];
    long long v19 = ProjectionInfosPtr[7];
    *(_OWORD *)(a2 + 12_Block_object_dispose(&STACK[0x380], 8) = ProjectionInfosPtr[8];
    *(_OWORD *)(a2 + 144) = v18;
    *(_OWORD *)(a2 + 96) = v20;
    *(_OWORD *)(a2 + 112) = v19;
    long long v21 = ProjectionInfosPtr[13];
    long long v23 = ProjectionInfosPtr[10];
    long long v22 = ProjectionInfosPtr[11];
    *(_OWORD *)(a2 + 192) = ProjectionInfosPtr[12];
    *(_OWORD *)(a2 + 20_Block_object_dispose(&STACK[0x380], 8) = v21;
    *(_OWORD *)(a2 + 160) = v23;
    *(_OWORD *)(a2 + 176) = v22;
    if ((*(unsigned char *)a2 & 8) != 0)
    {
      float v24 = *(float *)(a2 + 184);
      double v25 = v24;
      float v26 = *(float *)(a2 + 200);
      double v27 = v26;
      if (*(float *)(a2 + 188) == 0.0)
      {
        double v28 = (v27 + -1.0) / v25;
        double v29 = (v27 + 1.0) / v25;
        *(float *)&double v29 = v29;
        double v30 = -(1.0 - v27) / v25;
        if (v26 < -1.0) {
          double v31 = v30;
        }
        else {
          double v31 = v28;
        }
        *(float *)&double v30 = v26 / v24;
        if (v26 < -1.0) {
          double v30 = v29;
        }
      }
      else
      {
        BOOL v33 = v26 < -2.0;
        *(float *)&long long v21 = v26 / v24;
        double v34 = v27 / (v25 + 1.0);
        double v30 = v27 / (v25 + -1.0);
        *(float *)&double v30 = v30;
        double v31 = v34;
        if (!v33) {
          double v30 = *(double *)&v21;
        }
      }
      *(float *)&long long v21 = v31;
      *(float64x2_t *)(a2 + _Block_object_dispose(&STACK[0x380], 8) = vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(*(float32x2_t *)&v30, *(float32x2_t *)&v21), 0), (int8x8_t)vrev64_s32((int32x2_t)__PAIR64__(v21, LODWORD(v30))), (int8x8_t)__PAIR64__(v21, LODWORD(v30))));
    }
    return 1;
  }
  else
  {
    uint64_t result = (uint64_t)C3DNodeGetLight(a1);
    if (result) {
      return C3DLightGetProjectionInfo(result, a2);
    }
  }
  return result;
}

uint64_t C3DEngineContextGetAutoAdjustZRange(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 209);
}

void C3DCullingContextSetupCullingMatricesAndPlanes(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9 = (unsigned __int8 *)(a1 + 4628);
  unsigned int CoordinatesSystemOptions = (unsigned __int16)C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a2);
  BOOL v178 = v9[3] == 1 && v9[4] != 0;
  uint64_t v179 = a4;
  if (*v9)
  {
    unint64_t v11 = 0;
    do
    {
      if (v9[3] && !v9[4])
      {
        uint64_t v15 = a1 + (v11 << 6);
        uint64_t v13 = (simd_float4x4 *)(v15 + 2704);
        long long v14 = (simd_float4x4 *)(v15 + 3088);
      }
      else
      {
        uint64_t v12 = a1 + (v11 << 6);
        uint64_t v13 = (simd_float4x4 *)(v12 + 3088);
        long long v14 = (simd_float4x4 *)(v12 + 2704);
      }
      *uint64_t v13 = __invert_f4(*v14);
      if (a5)
      {
        if (C3DEngineContextIsJitteringEnabled((uint64_t)a2))
        {
          int JitteringStep = C3DEngineContextGetJitteringStep((uint64_t)a2);
          float32x4_t v183 = 0u;
          float32x4_t v184 = 0u;
          float32x4_t v181 = 0u;
          float32x4_t v182 = 0u;
          C3DEngineContextComputeJitterMatrix((uint64_t)a2, JitteringStep, &v181);
          uint64_t v17 = 0;
          long long v18 = (simd_float4 *)(a1 + (v11 << 6));
          simd_float4 v19 = v18[217];
          simd_float4 v20 = v18[218];
          simd_float4 v21 = v18[219];
          simd_float4 v22 = v18[220];
          long long v23 = (int32x4_t *)&v18[217];
          float32x4_t v24 = v181;
          float32x4_t v25 = v182;
          float32x4_t v26 = v183;
          float32x4_t v27 = v184;
          v185.columns[0] = v19;
          v185.columns[1] = v20;
          v185.columns[2] = v21;
          v185.columns[3] = v22;
          int32x4_t v186 = 0u;
          int32x4_t v187 = 0u;
          int32x4_t v188 = 0u;
          int32x4_t v189 = 0u;
          do
          {
            *(float32x4_t *)((char *)&v186 + v17 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)&v185.columns[v17])), v25, *(float32x2_t *)v185.columns[v17].f32, 1), v26, (float32x4_t)v185.columns[v17], 2), v27, (float32x4_t)v185.columns[v17], 3);
            ++v17;
          }
          while (v17 != 4);
          int32x4_t v28 = v187;
          int32x4_t v29 = v188;
          int32x4_t v30 = v189;
          *long long v23 = v186;
          v23[1] = v28;
          void v23[2] = v29;
          v23[3] = v30;
        }
        if (C3DEngineContextIsTemporalAntialiasingEnabled((uint64_t)a2))
        {
          float32x2_t TAAJitter = C3DEngineContextGetTAAJitter(a2, 0);
          double v32 = (int8x16_t *)(a1 + (v11 << 6));
          int8x16_t v33 = v32[220];
          *(float32x2_t *)v34.i8 = vadd_f32(TAAJitter, *(float32x2_t *)v33.i8);
          v34.i64[1] = vextq_s8(v33, v33, 8uLL).u64[0];
          v32[220] = v34;
        }
      }
      uint64_t v35 = 0;
      long long v36 = (_OWORD *)(a1 + (v11 << 6));
      float32x4_t v37 = *((float32x4_t *)v36 + 217);
      float32x4_t v38 = *((float32x4_t *)v36 + 218);
      float32x4_t v39 = *((float32x4_t *)v36 + 219);
      float32x4_t v40 = *((float32x4_t *)v36 + 220);
      simd_float4 v41 = *((simd_float4 *)v36 + 194);
      simd_float4 v42 = *((simd_float4 *)v36 + 195);
      simd_float4 v43 = *((simd_float4 *)v36 + 196);
      v185.columns[0] = (simd_float4)v36[193];
      v185.columns[1] = v41;
      v185.columns[2] = v42;
      v185.columns[3] = v43;
      int32x4_t v186 = 0u;
      int32x4_t v187 = 0u;
      int32x4_t v188 = 0u;
      int32x4_t v189 = 0u;
      do
      {
        *(float32x4_t *)((char *)&v186 + v35 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)&v185.columns[v35])), v38, *(float32x2_t *)v185.columns[v35].f32, 1), v39, (float32x4_t)v185.columns[v35], 2), v40, (float32x4_t)v185.columns[v35], 3);
        ++v35;
      }
      while (v35 != 4);
      double v44 = (_OWORD *)(a1 + (v11 << 6));
      int32x4_t v45 = v186;
      int32x4_t v46 = v187;
      int32x4_t v48 = v188;
      int32x4_t v47 = v189;
      v44[241] = v186;
      v44[242] = v46;
      v44[243] = v48;
      v44[244] = v47;
      uint64_t v49 = a1 + 96 * v11;
      v50.f32[0] = *(float *)&v45.i32[3] - *(float *)v45.i32;
      v50.f32[1] = *(float *)&v46.i32[3] - *(float *)v46.i32;
      v50.f32[2] = *(float *)&v48.i32[3] - *(float *)v48.i32;
      v50.f32[3] = *(float *)&v47.i32[3] - *(float *)v47.i32;
      float32x4_t v51 = vmulq_f32(v50, v50);
      v51.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v51, 2), vadd_f32(*(float32x2_t *)v51.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v51.f32, 1))).u32[0];
      float32x2_t v52 = vrsqrte_f32((float32x2_t)v51.u32[0]);
      float32x2_t v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v52, v52)));
      float32x4_t v54 = vmulq_n_f32(v50, vmul_f32(v53, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v53, v53))).f32[0]);
      v51.f32[0] = *(float *)&v45.i32[3] + *(float *)v45.i32;
      v51.f32[1] = *(float *)&v46.i32[3] + *(float *)v46.i32;
      v51.f32[2] = *(float *)&v48.i32[3] + *(float *)v48.i32;
      v51.f32[3] = *(float *)&v47.i32[3] + *(float *)v47.i32;
      int32x4_t v55 = (int32x4_t)vmulq_f32(v51, v51);
      v55.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v55, 2), vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v55.i8, 1))).u32[0];
      *(float32x4_t *)(v49 + 212_Block_object_dispose(&STACK[0x380], 8) = v54;
      *(float32x2_t *)v54.f32 = vrsqrte_f32((float32x2_t)v55.u32[0]);
      *(float32x2_t *)v54.f32 = vmul_f32(*(float32x2_t *)v54.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v54.f32, *(float32x2_t *)v54.f32)));
      *(float32x4_t *)(v49 + 2144) = vmulq_n_f32(v51, vmul_f32(*(float32x2_t *)v54.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v54.f32, *(float32x2_t *)v54.f32))).f32[0]);
      v51.f32[0] = *(float *)&v45.i32[3] + *(float *)&v45.i32[1];
      v51.f32[1] = *(float *)&v46.i32[3] + *(float *)&v46.i32[1];
      v51.f32[2] = *(float *)&v48.i32[3] + *(float *)&v48.i32[1];
      v51.f32[3] = *(float *)&v47.i32[3] + *(float *)&v47.i32[1];
      int32x4_t v56 = (int32x4_t)vmulq_f32(v51, v51);
      v56.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v56, 2), vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v56.i8, 1))).u32[0];
      float32x2_t v57 = vrsqrte_f32((float32x2_t)v56.u32[0]);
      float32x2_t v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v57, v57)));
      v54.f32[0] = *(float *)&v45.i32[3] - *(float *)&v45.i32[1];
      v54.f32[1] = *(float *)&v46.i32[3] - *(float *)&v46.i32[1];
      v54.f32[2] = *(float *)&v48.i32[3] - *(float *)&v48.i32[1];
      v54.f32[3] = *(float *)&v47.i32[3] - *(float *)&v47.i32[1];
      int32x4_t v59 = (int32x4_t)vmulq_f32(v54, v54);
      v59.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v59, 2), vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v59.i8, 1))).u32[0];
      *(float32x4_t *)(v49 + 2160) = vmulq_n_f32(v51, vmul_f32(v58, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v58, v58))).f32[0]);
      *(float32x2_t *)v51.f32 = vrsqrte_f32((float32x2_t)v59.u32[0]);
      *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v51.f32, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v51.f32)));
      *(float32x4_t *)(v49 + 2176) = vmulq_n_f32(v54, vmul_f32(*(float32x2_t *)v51.f32, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v51.f32))).f32[0]);
      v60.f32[0] = *(float *)&v45.i32[3] - *(float *)&v45.i32[2];
      v60.f32[1] = *(float *)&v46.i32[3] - *(float *)&v46.i32[2];
      v60.f32[2] = *(float *)&v48.i32[3] - *(float *)&v48.i32[2];
      v60.f32[3] = *(float *)&v47.i32[3] - *(float *)&v47.i32[2];
      int32x4_t v61 = (int32x4_t)vmulq_f32(v60, v60);
      v61.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v61, 2), vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1))).u32[0];
      float32x2_t v62 = vrsqrte_f32((float32x2_t)v61.u32[0]);
      float32x2_t v63 = vmul_f32(v62, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v62, v62)));
      *(float32x4_t *)(v49 + 2192) = vmulq_n_f32(v60, vmul_f32(v63, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v63, v63))).f32[0]);
      if (CoordinatesSystemOptions)
      {
        v64.i64[0] = vzip2q_s32(v45, v46).u64[0];
        v64.i64[1] = __PAIR64__(v47.u32[2], v48.u32[2]);
      }
      else
      {
        v64.f32[0] = *(float *)&v45.i32[3] + *(float *)&v45.i32[2];
        v64.f32[1] = *(float *)&v46.i32[3] + *(float *)&v46.i32[2];
        v64.f32[2] = *(float *)&v48.i32[3] + *(float *)&v48.i32[2];
        v64.f32[3] = *(float *)&v47.i32[3] + *(float *)&v47.i32[2];
      }
      double v65 = (_OWORD *)(v49 + 2208);
      int32x4_t v66 = (int32x4_t)vmulq_f32(v64, v64);
      if ((CoordinatesSystemOptions & 8) != 0)
      {
        double v67 = (_OWORD *)(v49 + 2192);
        *double v65 = *v67;
        unsigned __int32 v68 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v66, 2), vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1))).u32[0];
        float32x2_t v69 = vrsqrte_f32((float32x2_t)v68);
        float32x2_t v70 = vmul_f32(v69, vrsqrts_f32((float32x2_t)v68, vmul_f32(v69, v69)));
        unsigned __int32 v71 = vmul_f32(v70, vrsqrts_f32((float32x2_t)v68, vmul_f32(v70, v70))).u32[0];
        double v65 = v67;
      }
      else
      {
        unsigned __int32 v72 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v66, 2), vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1))).u32[0];
        float32x2_t v73 = vrsqrte_f32((float32x2_t)v72);
        float32x2_t v74 = vmul_f32(v73, vrsqrts_f32((float32x2_t)v72, vmul_f32(v73, v73)));
        unsigned __int32 v71 = vmul_f32(v74, vrsqrts_f32((float32x2_t)v72, vmul_f32(v74, v74))).u32[0];
      }
      *double v65 = vmulq_n_f32(v64, *(float *)&v71);
      ++v11;
      unint64_t v75 = *v9;
    }
    while (v11 < v75);
    int v77 = v9[68];
    double v76 = v9 + 68;
    uint64_t v78 = a3;
    if (v77)
    {
      if (v75 == 2)
      {
LABEL_33:
        LODWORD(v75) = 1;
        *(_DWORD *)(a1 + 4624) = 1;
        int v88 = *v76;
        goto LABEL_39;
      }
LABEL_30:
      float v80 = scn_default_log();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
        C3DCullingContextSetupCullingMatricesAndPlanes_cold_1(v80, v81, v82, v83, v84, v85, v86, v87);
      }
      uint64_t v78 = a3;
      goto LABEL_33;
    }
  }
  else
  {
    int v79 = v9[68];
    double v76 = v9 + 68;
    LODWORD(v75) = v79;
    if (v79) {
      goto LABEL_30;
    }
    uint64_t v78 = a3;
  }
  int v88 = v178;
  if (v178)
  {
    int v88 = 0;
    LODWORD(v75) = 1;
  }
  *(_DWORD *)(a1 + 4624) = v75;
LABEL_39:
  if (v75 + v88)
  {
    unint64_t v89 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    unsigned int v176 = HIDWORD(_Q0);
    int v177 = (CoordinatesSystemOptions >> 3) & 1;
    do
    {
      if (v78 == a4)
      {
        if (!v178)
        {
          int v162 = (_OWORD *)(a1 + (v89 << 6));
          long long v163 = v162[194];
          v162[61] = v162[193];
          v162[62] = v163;
          long long v164 = v162[196];
          v162[63] = v162[195];
          v162[64] = v164;
          v162[85] = v162[217];
          v162[86] = v162[218];
          v162[87] = v162[219];
          v162[88] = v162[220];
          long long v165 = v162[241];
          long long v166 = v162[242];
          long long v167 = v162[243];
          v162[112] = v162[244];
          v162[111] = v167;
          v162[110] = v166;
          v162[109] = v165;
          goto LABEL_52;
        }
        uint64_t v101 = 0;
        simd_float4 v102 = *(simd_float4 *)(a1 + 3024);
        simd_float4 v103 = *(simd_float4 *)(a1 + 3040);
        simd_float4 v104 = *(simd_float4 *)(a1 + 3072);
        uint32x2_t v105 = (simd_float4 *)(a1 + (v89 << 6));
        v105[39] = *(simd_float4 *)(a1 + 3056);
        v105[40] = v104;
        v105[37] = v102;
        v105[38] = v103;
        simd_float4 v106 = *(simd_float4 *)(a1 + 3456);
        simd_float4 v108 = *(simd_float4 *)(a1 + 3408);
        simd_float4 v107 = *(simd_float4 *)(a1 + 3424);
        v105[63] = *(simd_float4 *)(a1 + 3440);
        v105[64] = v106;
        v105[61] = v108;
        v105[62] = v107;
        float v109 = *(double *)(a1 + 4752);
        double v110 = (float)-v109;
        double v111 = v109;
        if (v109 > 0.0) {
          double v112 = v109;
        }
        else {
          double v112 = v110 + 1.0;
        }
        *(float *)&unsigned int v113 = 2.0 / (v111 - v110);
        float32x4_t v114 = (float32x4_t)v113;
        v115.i32[0] = 0;
        v115.i64[1] = 0;
        v115.i32[1] = v113;
        double v116 = v110 - v112;
        *(float *)&unsigned int v117 = 1.0 / (v110 - v112);
        v118.i64[0] = 0;
        v118.i64[1] = v117;
        float32_t v119 = -(v110 + v111) / (v111 - v110);
        double v120 = v110 / v116;
        v122.f32[0] = v119;
        v122.f32[1] = v119;
        *(float *)&unsigned int v121 = v120;
        v122.i64[1] = __PAIR64__(v176, v121);
        v105[85] = (simd_float4)v114.u32[0];
        v105[86] = (simd_float4)v115.u64[0];
        v105[87] = (simd_float4)v118;
        v105[88] = (simd_float4)v122;
        simd_float4 v123 = v105[62];
        simd_float4 v124 = v105[63];
        simd_float4 v125 = v105[64];
        v185.columns[0] = v105[61];
        v185.columns[1] = v123;
        v185.columns[2] = v124;
        v185.columns[3] = v125;
        int32x4_t v186 = 0u;
        int32x4_t v187 = 0u;
        int32x4_t v188 = 0u;
        int32x4_t v189 = 0u;
        do
        {
          *(float32x4_t *)((char *)&v186 + v101 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v114, COERCE_FLOAT(*(_OWORD *)&v185.columns[v101])), v115, *(float32x2_t *)v185.columns[v101].f32, 1), v118, (float32x4_t)v185.columns[v101], 2), v122, (float32x4_t)v185.columns[v101], 3);
          ++v101;
        }
        while (v101 != 4);
      }
      else
      {
        uint64_t v95 = a1 + (v89 << 6);
        simd_float4x4 v190 = __invert_f4(*(simd_float4x4 *)(v95 + 592));
        uint64_t v96 = 0;
        *(simd_float4x4 *)(v95 + 976) = v190;
        float32x4_t v97 = *(float32x4_t *)(v95 + 1360);
        float32x4_t v98 = *(float32x4_t *)(v95 + 1376);
        float32x4_t v99 = *(float32x4_t *)(v95 + 1392);
        float32x4_t v100 = *(float32x4_t *)(v95 + 1408);
        simd_float4x4 v185 = v190;
        int32x4_t v186 = 0u;
        int32x4_t v187 = 0u;
        int32x4_t v188 = 0u;
        int32x4_t v189 = 0u;
        do
        {
          *(float32x4_t *)((char *)&v186 + v96 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v97, COERCE_FLOAT(*(_OWORD *)&v185.columns[v96])), v98, *(float32x2_t *)v185.columns[v96].f32, 1), v99, (float32x4_t)v185.columns[v96], 2), v100, (float32x4_t)v185.columns[v96], 3);
          ++v96;
        }
        while (v96 != 4);
      }
      simd_float4 v126 = (_OWORD *)(a1 + (v89 << 6));
      int32x4_t v127 = v187;
      int32x4_t v128 = v188;
      int32x4_t v129 = v189;
      v126[109] = v186;
      v126[110] = v127;
      v126[111] = v128;
      v126[112] = v129;
LABEL_52:
      if (*v76)
      {
        if (v89)
        {
          uint64_t v130 = a1 + 3856 + ((v89 - 1) << 6);
          uint64_t v131 = a1 + 96 * (v89 - 1);
          scn_frustum_extract_from_twos_viewProjs(v131 + 2128, CoordinatesSystemOptions & 1, v177, *(float32x4_t *)v130, *(__n128 *)(v130 + 16), *(__n128 *)(v130 + 32), *(__n128 *)(v130 + 48), *(__n128 *)(a1 + 3856 + (v89 << 6)), *(__n128 *)(a1 + 3856 + (v89 << 6) + 16), *(__n128 *)(a1 + 3856 + (v89 << 6) + 32), *(__n128 *)(a1 + 3856 + (v89 << 6) + 48));
          uint64_t v132 = a1 + 1744 + ((v89 - 1) << 6);
          uint64_t v133 = v131 + 16;
          a4 = v179;
          uint64_t v78 = a3;
          scn_frustum_extract_from_twos_viewProjs(v133, CoordinatesSystemOptions & 1, v177, *(float32x4_t *)v132, *(__n128 *)(v132 + 16), *(__n128 *)(v132 + 32), *(__n128 *)(v132 + 48), *(__n128 *)(a1 + 1744 + (v89 << 6)), *(__n128 *)(a1 + 1744 + (v89 << 6) + 16), *(__n128 *)(a1 + 1744 + (v89 << 6) + 32), *(__n128 *)(a1 + 1744 + (v89 << 6) + 48));
        }
      }
      else
      {
        uint64_t v134 = a1 + (v89 << 6);
        SCNMTLBlitCommandEncoder v135 = (float32x4_t *)(a1 + 96 * v89);
        int32x4_t v136 = *(int32x4_t *)(v134 + 1744);
        int32x4_t v137 = *(int32x4_t *)(v134 + 1760);
        long long v138 = *(_OWORD *)(v134 + 1776);
        long long v139 = *(_OWORD *)(v134 + 1792);
        v140.f32[0] = *(float *)&v136.i32[3] - *(float *)v136.i32;
        v140.f32[1] = *(float *)&v137.i32[3] - *(float *)v137.i32;
        v140.f32[2] = *((float *)&v138 + 3) - *(float *)&v138;
        v140.f32[3] = *((float *)&v139 + 3) - *(float *)&v139;
        int32x4_t v141 = (int32x4_t)vmulq_f32(v140, v140);
        v141.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v141, 2), vadd_f32(*(float32x2_t *)v141.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v141.i8, 1))).u32[0];
        float32x2_t v142 = vrsqrte_f32((float32x2_t)v141.u32[0]);
        float32x2_t v143 = vmul_f32(v142, vrsqrts_f32((float32x2_t)v141.u32[0], vmul_f32(v142, v142)));
        LODWORD(v144) = vmul_f32(v143, vrsqrts_f32((float32x2_t)v141.u32[0], vmul_f32(v143, v143))).u32[0];
        float v145 = COERCE_FLOAT(*(void *)(v134 + 1752));
        v146.f32[0] = *(float *)&v136.i32[3] - v145;
        float v147 = COERCE_FLOAT(*(void *)(v134 + 1768));
        float v148 = COERCE_FLOAT(*(void *)(v134 + 1784));
        float v149 = COERCE_FLOAT(*(void *)(v134 + 1800));
        v146.f32[1] = *(float *)&v137.i32[3] - v147;
        v146.f32[2] = *((float *)&v138 + 3) - v148;
        v146.f32[3] = *((float *)&v139 + 3) - v149;
        float32x4_t v150 = vmulq_f32(v146, v146);
        v150.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v150, 2), vadd_f32(*(float32x2_t *)v150.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v150.f32, 1))).u32[0];
        float32x4_t v151 = vmulq_n_f32(v140, v144);
        float32x2_t v152 = vrsqrte_f32((float32x2_t)v150.u32[0]);
        float32x2_t v153 = vmul_f32(v152, vrsqrts_f32((float32x2_t)v150.u32[0], vmul_f32(v152, v152)));
        v135[5] = vmulq_n_f32(v146, vmul_f32(v153, vrsqrts_f32((float32x2_t)v150.u32[0], vmul_f32(v153, v153))).f32[0]);
        f32 = (_OWORD *)v135[5].f32;
        *(f32 - 4) = v151;
        v151.f32[0] = *(float *)&v136.i32[3] + *(float *)v136.i32;
        v151.f32[1] = *(float *)&v137.i32[3] + *(float *)v137.i32;
        v151.f32[2] = *((float *)&v138 + 3) + *(float *)&v138;
        v151.f32[3] = *((float *)&v139 + 3) + *(float *)&v139;
        int32x4_t v155 = (int32x4_t)vmulq_f32(v151, v151);
        v155.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v155, 2), vadd_f32(*(float32x2_t *)v155.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v155.i8, 1))).u32[0];
        *(float32x2_t *)v146.f32 = vrsqrte_f32((float32x2_t)v155.u32[0]);
        *(float32x2_t *)v146.f32 = vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v155.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32)));
        v150.f32[0] = *(float *)&v136.i32[3] + *(float *)&v136.i32[1];
        v150.f32[1] = *(float *)&v137.i32[3] + *(float *)&v137.i32[1];
        v150.f32[2] = *((float *)&v138 + 3) + *((float *)&v138 + 1);
        v150.f32[3] = *((float *)&v139 + 3) + *((float *)&v139 + 1);
        float32x4_t v156 = vmulq_n_f32(v151, vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v155.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32))).f32[0]);
        int32x4_t v157 = (int32x4_t)vmulq_f32(v150, v150);
        v157.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v157, 2), vadd_f32(*(float32x2_t *)v157.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v157.i8, 1))).u32[0];
        float32x2_t v158 = vrsqrte_f32((float32x2_t)v157.u32[0]);
        float32x2_t v159 = vmul_f32(v158, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v158, v158)));
        *(f32 - 3) = v156;
        *(f32 - 2) = vmulq_n_f32(v150, vmul_f32(v159, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v159, v159))).f32[0]);
        v156.f32[0] = *(float *)&v136.i32[3] - *(float *)&v136.i32[1];
        v156.f32[1] = *(float *)&v137.i32[3] - *(float *)&v137.i32[1];
        v156.f32[2] = *((float *)&v138 + 3) - *((float *)&v138 + 1);
        v156.f32[3] = *((float *)&v139 + 3) - *((float *)&v139 + 1);
        int32x4_t v160 = (int32x4_t)vmulq_f32(v156, v156);
        v160.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v160, 2), vadd_f32(*(float32x2_t *)v160.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v160.i8, 1))).u32[0];
        *(float32x2_t *)v146.f32 = vrsqrte_f32((float32x2_t)v160.u32[0]);
        *(float32x2_t *)v146.f32 = vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v160.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32)));
        *(f32 - 1) = vmulq_n_f32(v156, vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v160.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32))).f32[0]);
        if (CoordinatesSystemOptions)
        {
          v161.i64[0] = vzip2q_s32(v136, v137).u64[0];
          v161.i64[1] = __PAIR64__(DWORD2(v139), DWORD2(v138));
        }
        else
        {
          v161.f32[0] = *(float *)&v136.i32[3] + v145;
          v161.f32[1] = *(float *)&v137.i32[3] + v147;
          v161.f32[2] = *((float *)&v138 + 3) + v148;
          v161.f32[3] = *((float *)&v139 + 3) + v149;
        }
        uint64_t v168 = f32 + 1;
        if ((CoordinatesSystemOptions & 8) != 0)
        {
          *uint64_t v168 = *f32;
          int32x4_t v169 = (int32x4_t)vmulq_f32(v161, v161);
          v169.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v169, 2), vadd_f32(*(float32x2_t *)v169.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v169.i8, 1))).u32[0];
          float32x2_t v170 = vrsqrte_f32((float32x2_t)v169.u32[0]);
          float32x2_t v171 = vmul_f32(v170, vrsqrts_f32((float32x2_t)v169.u32[0], vmul_f32(v170, v170)));
          unsigned __int32 v172 = vmul_f32(v171, vrsqrts_f32((float32x2_t)v169.u32[0], vmul_f32(v171, v171))).u32[0];
          uint64_t v168 = f32;
        }
        else
        {
          int32x4_t v173 = (int32x4_t)vmulq_f32(v161, v161);
          v173.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v173, 2), vadd_f32(*(float32x2_t *)v173.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v173.i8, 1))).u32[0];
          float32x2_t v174 = vrsqrte_f32((float32x2_t)v173.u32[0]);
          float32x2_t v175 = vmul_f32(v174, vrsqrts_f32((float32x2_t)v173.u32[0], vmul_f32(v174, v174)));
          unsigned __int32 v172 = vmul_f32(v175, vrsqrts_f32((float32x2_t)v173.u32[0], vmul_f32(v175, v175))).u32[0];
        }
        *uint64_t v168 = vmulq_n_f32(v161, *(float *)&v172);
      }
      ++v89;
    }
    while (v89 < *(_DWORD *)(a1 + 4624) + *v76);
  }
}

__n128 C3DEngineContextGetViewport(__n128 *a1)
{
  return a1[15];
}

void sub_20B2BBC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

double C3DEngineContextGetSystemTime(uint64_t a1)
{
  return *(double *)(a1 + 440);
}

float C3DCameraGetMotionBlurIntensity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 472);
}

uint64_t C3DSceneGetFogColor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 352;
}

uint64_t SCNMTLClusterSystem::compute(uint64_t a1)
{
  double v1 = MEMORY[0x270FA5388](a1);
  uint64_t v3 = v2;
  uint64_t v165 = v4;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  float v10 = v9;
  *(double *)v198.i64 = v1;
  uint64_t v12 = v11;
  *(void *)((char *)&v318[2] + 4) = *MEMORY[0x263EF8340];
  *((_OWORD *)v13 + 24) = 0u;
  *((_OWORD *)v13 + 25) = 0u;
  *((_OWORD *)v13 + 22) = 0u;
  *((_OWORD *)v13 + 23) = 0u;
  *((_OWORD *)v13 + 20) = 0u;
  *((_OWORD *)v13 + 21) = 0u;
  *((_OWORD *)v13 + 1_Block_object_dispose(&STACK[0x380], 8) = 0u;
  *((_OWORD *)v13 + 19) = 0u;
  *((_OWORD *)v13 + 16) = 0u;
  *((_OWORD *)v13 + 17) = 0u;
  *((_OWORD *)v13 + 14) = 0u;
  *((_OWORD *)v13 + 15) = 0u;
  *((_OWORD *)v13 + 12) = 0u;
  *((_OWORD *)v13 + 13) = 0u;
  *((_OWORD *)v13 + 10) = 0u;
  *((_OWORD *)v13 + 11) = 0u;
  *((_OWORD *)v13 + _Block_object_dispose(&STACK[0x380], 8) = 0u;
  *((_OWORD *)v13 + 9) = 0u;
  *((_OWORD *)v13 + 6) = 0u;
  *((_OWORD *)v13 + 7) = 0u;
  *((_OWORD *)v13 + 4) = 0u;
  *((_OWORD *)v13 + 5) = 0u;
  *((_OWORD *)v13 + 2) = 0u;
  *((_OWORD *)v13 + 3) = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *((_OWORD *)v13 + 1) = 0u;
  uint64_t v14 = *((void *)v7 + 592);
  uint64_t v15 = *((void *)v7 + 266);
  uint64_t v16 = *((void *)v7 + 267);
  uint64_t v17 = *((void *)v7 + 268);
  uint64_t v18 = *((void *)v7 + 269);
  uint64_t v19 = *((void *)v7 + 270);
  uint64_t v20 = *((void *)v7 + 271);
  uint64_t v21 = *((void *)v8 + 272);
  uint64_t v22 = *((void *)v8 + 273);
  uint64_t v23 = *((void *)v8 + 274);
  uint64_t v24 = *((void *)v8 + 275);
  uint64_t v25 = *((void *)v8 + 276);
  uint64_t v26 = *((void *)v8 + 277);
  uint64_t v245 = v8;
  uint64_t v246 = v14;
  uint64_t v247 = v5;
  v248 = v2;
  int v249 = v312;
  v250 = v311;
  v251 = v310;
  uint64_t v214 = v21;
  uint64_t v215 = v16;
  uint64_t v234 = v16;
  uint64_t v217 = v15;
  uint64_t v233 = v15;
  uint64_t v201 = v18;
  uint64_t v205 = v17;
  uint64_t v236 = v18;
  uint64_t v235 = v17;
  uint64_t v27 = v20;
  uint64_t v238 = v20;
  uint64_t v28 = v19;
  uint64_t v237 = v19;
  uint64_t v211 = v23;
  uint64_t v212 = v22;
  uint64_t v240 = v22;
  uint64_t v239 = v21;
  uint64_t v209 = v24;
  uint64_t v242 = v24;
  uint64_t v241 = v23;
  uint64_t v244 = v26;
  uint64_t v243 = v25;
  long long v167 = v13;
  _addLightsInFrustum(v19);
  uint64_t result = C3DLightingSystemHasLocalLights(v6);
  if (result)
  {
    uint64_t StackAllocator = C3DEngineContextGetStackAllocator(v14);
    C3DStackAllocatorPushFrame(StackAllocator);
    float32x4_t v31 = vcvtq_f32_u32(*v12);
    uint64_t v32 = v12[1].i64[0];
    if (v32)
    {
      float v33 = (float)v32 * v10;
      int8x16_t v34 = v167;
      v167[20] = v33;
      v36.i32[1] = v198.i32[1];
      v35.f32[0] = (float)v198.u32[0] / v33;
      v35.i32[1] = v31.i32[1];
      v35.i64[1] = v31.i64[1];
      v36.i32[0] = (float)(v33 * ceilf(v35.f32[0]));
      float32x4_t v31 = v35;
    }
    else
    {
      int8x16_t v34 = v167;
      uint32x2_t v36 = *(uint32x2_t *)v198.f32;
    }
    if (HIDWORD(v32))
    {
      float v37 = (float)HIDWORD(v32) * v10;
      v38.i32[0] = v31.i32[0];
      v38.f32[1] = (float)v36.u32[1] / v37;
      v34[21] = v37;
      v38.i64[1] = v31.i64[1];
      v36.i32[1] = (float)(v37 * ceilf(v38.f32[1]));
      float32x4_t v31 = v38;
    }
    *(uint32x2_t *)v30.f32 = vcvt_u32_f32(vrndp_f32(*(float32x2_t *)v31.f32));
    float32x4_t v39 = v30;
    v39.i32[2] = v31.f32[2];
    float32x4_t v170 = v39;
    __asm { FMOV            V1.4S, #1.0 }
    float32x4_t v199 = vdivq_f32(_Q1, v31);
    _Q1.f32[0] = v8[593];
    double v45 = v8[594];
    *(float *)&double v45 = v45;
    *(float32x2_t *)&long long v46 = vdiv_f32(vcvt_f32_u32(*(uint32x2_t *)v30.f32), vcvt_f32_u32(v36));
    *(float *)&double v45 = _Q1.f32[0] - *(float *)&v45;
    _Q1.f32[0] = vmuls_lane_f32(_Q1.f32[0], v31, 2);
    v31.i32[0] = vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL).u32[0];
    v31.i32[1] = _Q1.i32[0];
    *((float32x2_t *)&v46 + 1) = vdiv_f32(*(float32x2_t *)v31.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v45, 0));
    *((float32x4_t *)v34 + 3) = v199;
    *((_OWORD *)v34 + 4) = v46;
    unsigned int v169 = v31.f32[2];
    __int32 v174 = v30.i32[1];
    float32x4_t v193 = v30;
    __int32 v191 = v30.i32[0];
    int v177 = *((_DWORD *)v34 + 27);
    if (v177) {
      int v47 = 8;
    }
    else {
      int v47 = 4;
    }
    int v164 = v47;
    if (v177) {
      char v48 = 3;
    }
    else {
      char v48 = 2;
    }
    size_t v49 = (v30.i32[1] * v31.f32[2] * v30.i32[0]) << v48;
    SCNMTLBufferPool::allocate(v3, v49, &v261);
    *(float32x4_t *)int8x16_t v34 = v261;
    *((void *)v34 + 2) = v262.i64[0];
    uint64_t v176 = *(void *)v34;
    bzero(*(void **)v34, v49);
    bzero(&v277, 0xA60uLL);
    float32x4_t v261 = v170;
    float32x4_t v262 = v199;
    uint64_t v264 = v215;
    uint64_t v263 = v217;
    uint64_t v266 = v201;
    uint64_t v265 = v205;
    uint64_t v268 = v27;
    uint64_t v267 = v28;
    uint64_t v270 = v212;
    uint64_t v269 = v214;
    uint64_t v272 = v209;
    uint64_t v271 = v211;
    uint64_t v274 = v26;
    uint64_t v273 = v25;
    v275 = (int32x4_t *)v312;
    v276 = v311;
    v277 = v310;
    *(void *)v309 = StackAllocator;
    uint64_t v50 = *((void *)v34 + 11);
    uint64_t v197 = v50;
    unsigned int v51 = HIDWORD(v50);
    unsigned int v279 = (HIDWORD(v50) + 3) >> 2;
    if ((HIDWORD(v50) + 3) >= 4)
    {
      uint64_t Aligned = C3DStackAllocatorAllocateAligned(StackAllocator, (unint64_t)((HIDWORD(v50) + 3) >> 2) << 6, 16, 0);
      scn_sphere_x4_fill((uint64_t)Aligned, v275, v51);
      unsigned int v281 = (v279 + 1) >> 1;
      v280 = C3DStackAllocatorAllocateAligned(StackAllocator, v281, 16, 0);
    }
    uint64_t v52 = *((void *)v34 + 12);
    uint64_t v195 = v52;
    unsigned int v53 = HIDWORD(v52);
    unsigned int v283 = (HIDWORD(v52) + 3) >> 2;
    if ((HIDWORD(v52) + 3) >= 4)
    {
      v282 = C3DStackAllocatorAllocateAligned(StackAllocator, (unint64_t)((HIDWORD(v52) + 3) >> 2) << 7, 16, 0);
      scn_cone_x4_fill((uint64_t)v282, v311, v53);
      unsigned int v285 = (v283 + 1) >> 1;
      v284 = C3DStackAllocatorAllocateAligned(StackAllocator, v285, 16, 0);
    }
    uint64_t v54 = 0;
    HIDWORD(v56) = HIDWORD(v195);
    HIDWORD(v55) = HIDWORD(v197);
    LODWORD(v55) = 0;
    LODWORD(v56) = (v51 + 31) >> 5;
    uint64_t v301 = v55;
    uint64_t v302 = v56;
    uint64_t v57 = *((void *)v34 + 13);
    char v200 = v57;
    LODWORD(v57) = ((v53 + 31) >> 5) + v56;
    uint64_t v303 = v57;
    unsigned int v308 = v57 + ((HIDWORD(v57) + 31) >> 5);
    size_t v58 = 4 * v308;
    do
    {
      float32x4_t v219 = v170;
      v304[v54] = C3DStackAllocatorAllocateZero(StackAllocator, (*(_DWORD *)((unint64_t)&v219 & 0xFFFFFFFFFFFFFFF3 | (4 * (v54 & 3))) * v58));
      v306 = C3DStackAllocatorAllocate(StackAllocator, v58);
      v307 = (int *)C3DStackAllocatorAllocate(StackAllocator, v58);
      __computeLightsFlagsForAxis(&v261, v54++);
    }
    while (v54 != 3);
    scn_plane_intersect_3_planes(v25, v26, v28, v27, v205, v201, &v293);
    scn_plane_intersect_3_planes(v25, v26, v217, v215, v28, v27, &v294);
    scn_plane_intersect_3_planes(v25, v26, v205, v201, v214, v212, &v295);
    scn_plane_intersect_3_planes(v25, v26, v214, v212, v217, v215, &v296);
    scn_plane_intersect_3_planes(v211, v209, v28, v27, v205, v201, &v297);
    scn_plane_intersect_3_planes(v211, v209, v217, v215, v28, v27, &v298);
    scn_plane_intersect_3_planes(v211, v209, v205, v201, v214, v212, &v299);
    scn_plane_intersect_3_planes(v211, v209, v214, v212, v217, v215, v300);
    int v59 = v191;
    if (v169)
    {
      unsigned __int32 v175 = 0;
      v60.i64[1] = v193.i64[1];
      *(int32x2_t *)v60.f32 = vceqz_s32(*(int32x2_t *)v193.f32);
      uint64_t v210 = *((void *)v167 + 14);
      char v213 = v195;
      __int8 v168 = v60.i8[4];
      __int8 v173 = v60.i8[0];
      do
      {
        if (v308)
        {
          if (*(_DWORD *)(v305 + 4 * v308 * v175)) {
            goto LABEL_27;
          }
          uint64_t v61 = 1;
          do
          {
            unint64_t v62 = v61;
            if (v308 == v61) {
              break;
            }
          }
          while (!*(_DWORD *)(v305 + 4 * v308 * v175 + 4 * v61++));
          if (v62 < v308)
          {
LABEL_27:
            float32x4_t v60 = __computeFrustumExtrema(&v261, 0, 0, v175, &v253, (uint32x4_t)v60);
            if ((v168 & 1) == 0)
            {
              unsigned int v190 = 0;
              float32x4_t v186 = v253;
              float32x4_t v187 = v254;
              float32x4_t v184 = v258;
              float32x4_t v185 = vsubq_f32(v254, v253);
              float32x4_t v181 = v255;
              float32x4_t v182 = vsubq_f32(v258, v257);
              float32x4_t v178 = v260;
              float32x4_t v183 = v257;
              float32x4_t v179 = v259;
              float32x4_t v180 = v256;
              float32x4_t v60 = vsubq_f32(v259, v257);
              float32x4_t v171 = v60;
              float32x4_t v172 = vsubq_f32(v255, v253);
              do
              {
                uint64_t v64 = v308;
                if (v308)
                {
                  int v65 = 0;
                  int32x4_t v66 = v307;
                  double v67 = (int *)(v305 + 4 * v175 * v308);
                  unsigned __int32 v68 = (int *)(v304[1] + 4 * v308 * v190);
                  do
                  {
                    int v70 = *v68++;
                    int v69 = v70;
                    int v71 = *v67++;
                    int v72 = v71 & v69;
                    *v66++ = v72;
                    v65 |= v72;
                    --v64;
                  }
                  while (v64);
                  if (v65 && (v173 & 1) == 0)
                  {
                    unsigned int v73 = 0;
                    float32x4_t v60 = vmulq_n_f32(v171, (float)v190);
                    float32x4_t v188 = v60;
                    float32x4_t v189 = vmulq_n_f32(v172, (float)v190);
                    int v74 = (v190 + v175 * v174) * v59;
                    do
                    {
                      uint64_t v75 = v308;
                      if (v308)
                      {
                        int v76 = 0;
                        int v77 = v306;
                        uint64_t v78 = v307;
                        int v79 = (int *)(v304[0] + 4 * v308 * v73);
                        float v80 = v306;
                        do
                        {
                          int v82 = *v78++;
                          int v81 = v82;
                          int v83 = *v79++;
                          int v84 = v83 & v81;
                          *v80++ = v84;
                          v76 |= v84;
                          --v75;
                        }
                        while (v75);
                        if (v76)
                        {
                          unsigned int v192 = v74;
                          unsigned int v194 = v73;
                          float32x4_t v85 = vmlaq_n_f32(v189, v185, (float)v73);
                          float32x4_t v86 = vmlaq_n_f32(v188, v182, (float)v73);
                          float32x4_t v87 = vaddq_f32(v186, v85);
                          v252[0] = v87;
                          v252[1] = vaddq_f32(v187, v85);
                          v252[2] = vaddq_f32(v181, v85);
                          v252[3] = vaddq_f32(v85, v180);
                          v252[4] = vaddq_f32(v183, v86);
                          v252[5] = vaddq_f32(v184, v86);
                          v252[6] = vaddq_f32(v179, v86);
                          v252[7] = vaddq_f32(v86, v178);
                          v87.i32[3] = 0;
                          uint64_t v88 = 1;
                          float32x4_t v89 = v87;
                          do
                          {
                            float32x4_t v90 = (float32x4_t)v252[v88];
                            v90.i32[3] = 0;
                            float32x4_t v87 = vminq_f32(v87, v90);
                            float32x4_t v89 = vmaxq_f32(v89, v90);
                            ++v88;
                          }
                          while (v88 != 8);
                          v91.i64[0] = 0x3F0000003F000000;
                          v91.i64[1] = 0x3F0000003F000000;
                          int32x4_t v94 = (int32x4_t)vmulq_f32(vaddq_f32(v89, v87), v91);
                          float32x4_t v92 = vmulq_f32(vsubq_f32(v89, v87), v91);
                          float32x4_t v93 = vmulq_f32(v92, v92);
                          v94.i32[3] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 2), vaddq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v93.f32, 1))).f32[0]);
                          float v216 = *(float *)&v94.i32[3];
                          float32x4_t v218 = (float32x4_t)v94;
                          unsigned int v290 = 0;
                          unsigned int v95 = HIDWORD(v303);
                          if ((HIDWORD(v303) + 31) >= 0x20)
                          {
                            uint64_t v100 = 0;
                            v202 = &v77[v303];
                            uint64_t v196 = (HIDWORD(v303) + 31) >> 5;
                            float32x4_t v206 = (float32x4_t)vdupq_laneq_s32(v94, 3);
                            while (1)
                            {
                              unsigned int v101 = v202[v100];
                              if (v101) {
                                break;
                              }
LABEL_54:
                              if (++v100 == v196) {
                                goto LABEL_42;
                              }
                            }
                            int v102 = 32 * v100;
                            while (1)
                            {
                              unsigned int v103 = __clz(__rbit32(v101));
                              int v104 = v103 | v102;
                              if ((v103 | v102) >= v95)
                              {
                                uint32x2_t v105 = scn_default_log();
                                if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT)) {
                                  SCNMTLClusterSystem::compute(v313, &v314, v105);
                                }
                              }
                              simd_float4 v106 = (float32x4_t *)&v310[5 * v104];
                              float32x4_t v107 = v106[4];
                              float32x4_t v108 = vsubq_f32(v218, *v106);
                              int32x4_t v109 = (int32x4_t)vmulq_f32(v106[1], v108);
                              int32x4_t v110 = (int32x4_t)vmulq_f32(v108, v106[2]);
                              int32x4_t v111 = (int32x4_t)vmulq_f32(v108, v106[3]);
                              int32x4_t v112 = vzip1q_s32(v109, v111);
                              int32x4_t v113 = vzip2q_s32(v109, v111);
                              float32x4_t v114 = (float32x4_t)vtrn2q_s32(v109, v110);
                              v114.i32[2] = v111.i32[1];
                              float32x4_t v115 = vabsq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v113, vdupq_laneq_s32(v110, 2)), vaddq_f32((float32x4_t)vzip1q_s32(v112, v110), v114)));
                              float32x4_t v116 = vsubq_f32(v115, v107);
                              v116.i32[3] = 0;
                              float32x4_t v117 = vmaxnmq_f32(v116, (float32x4_t)0);
                              float32x4_t v118 = vmulq_f32(v117, v117);
                              int32x2_t v119 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 2), vaddq_f32(v118, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v118.f32, 1))).u64[0];
                              if (*(float *)v119.i32 <= (float)(v216 * v216))
                              {
                                uint64_t v120 = v290++;
                                v286[v120] = v104 + v200;
                                if (*(float *)(v210 + ((unint64_t)(v104 + v200) << 8)) >= 1.0)
                                {
                                  *(float *)v119.i32 = fmaxf(fmaxf(v107.f32[0], v107.f32[2]), v107.f32[1]) * 0.090909;
                                  uint32x4_t v121 = (uint32x4_t)vcgeq_f32(vsubq_f32(vsubq_f32(v107, (float32x4_t)vdupq_lane_s32(v119, 0)), v115), v206);
                                  v121.i32[3] = v121.i32[2];
                                  if ((vminvq_u32(v121) & 0x80000000) != 0) {
                                    break;
                                  }
                                }
                              }
                              v101 &= ~(1 << v103);
                              if (!v101) {
                                goto LABEL_54;
                              }
                            }
                          }
LABEL_42:
                          uint64_t v96 = &v286[v290];
                          unsigned int v288 = 0;
                          float32x4_t v97 = v306;
                          unsigned int v98 = HIDWORD(v301);
                          if ((HIDWORD(v301) + 31) >= 0x20)
                          {
                            uint64_t v122 = 0;
                            uint64_t v203 = (HIDWORD(v301) + 31) >> 5;
                            v207 = (char *)&v306[v301];
                            do
                            {
                              unsigned int v123 = *(_DWORD *)&v207[4 * v122];
                              if (v123)
                              {
                                int v124 = 32 * v122;
                                do
                                {
                                  unsigned int v125 = __clz(__rbit32(v123));
                                  int v126 = v125 | v124;
                                  if ((v125 | v124) >= v98)
                                  {
                                    int32x4_t v127 = scn_default_log();
                                    if (os_log_type_enabled(v127, OS_LOG_TYPE_FAULT)) {
                                      SCNMTLClusterSystem::compute(v315, &v316, v127);
                                    }
                                  }
                                  float v128 = v216 + COERCE_FLOAT(HIDWORD(v312[v126]));
                                  float32x4_t v129 = vsubq_f32((float32x4_t)v312[v126], v218);
                                  float32x4_t v130 = vmulq_f32(v129, v129);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 2), vaddq_f32(v130, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v130.f32, 1))).f32[0] <= (float)(v128 * v128))
                                  {
                                    uint64_t v131 = v288++;
                                    v96[v131] = v197 + v126;
                                  }
                                  v123 &= ~(1 << v125);
                                }
                                while (v123);
                              }
                              ++v122;
                            }
                            while (v122 != v203);
                            unsigned int v99 = v288;
                            float32x4_t v97 = v306;
                            int v59 = v191;
                          }
                          else
                          {
                            unsigned int v99 = 0;
                            int v59 = v191;
                          }
                          unsigned int v289 = 0;
                          unsigned int v132 = HIDWORD(v302);
                          if ((HIDWORD(v302) + 31) >= 0x20)
                          {
                            uint64_t v134 = 0;
                            SCNMTLBlitCommandEncoder v135 = &v96[v99];
                            v204 = &v97[v302];
                            uint64_t v208 = (HIDWORD(v302) + 31) >> 5;
                            do
                            {
                              unsigned int v136 = v204[v134];
                              if (v136)
                              {
                                int v137 = 32 * v134;
                                do
                                {
                                  unsigned int v138 = __clz(__rbit32(v136));
                                  int v139 = v138 | v137;
                                  if ((v138 | v137) >= v132)
                                  {
                                    float32x4_t v140 = scn_default_log();
                                    if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT)) {
                                      SCNMTLClusterSystem::compute(v317, v318, v140);
                                    }
                                  }
                                  int32x4_t v141 = (float32x4_t *)&v311[3 * v139];
                                  float v142 = v141[2].f32[0];
                                  float32x4_t v143 = vsubq_f32(v218, *v141);
                                  float32x4_t v144 = vmulq_f32(v143, v143);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v144, 2), vaddq_f32(v144, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v144.f32, 1))).f32[0] <= (float)((float)(v216 + v142) * (float)(v216 + v142)))
                                  {
                                    float v145 = v141[2].f32[2];
                                    float32x4_t v146 = vmulq_f32(v143, v141[1]);
                                    LODWORD(_S3) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v146, 2), vaddq_f32(v146, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v146.f32, 1))).u32[0];
                                    __asm { FMLS            S1, S3, V3.S[0] }
                                    float v149 = sqrtf(_S1);
                                    float v150 = v141[2].f32[3] * v145;
                                    float v151 = vmlas_n_f32(-(float)(v145 * v149), v150, _S3);
                                    if (v151 >= 0.0
                                      || (float v152 = (float)(v145 * _S3) + (float)(v150 * v149),
                                          float v153 = fminf(fmaxf(v152, 0.0), v142),
                                          (float)((float)(v151 * v151)
                                                + (float)((float)(v152 - v153) * (float)(v152 - v153))) <= (float)(v216 * v216)))
                                    {
                                      uint64_t v154 = v289++;
                                      v135[v154] = v139 + v213;
                                    }
                                  }
                                  v136 &= ~(1 << v138);
                                }
                                while (v136);
                              }
                              ++v134;
                            }
                            while (v134 != v208);
                            unsigned int v133 = v289;
                            unsigned int v99 = v288;
                            int v59 = v191;
                          }
                          else
                          {
                            unsigned int v133 = 0;
                          }
                          unsigned int v73 = v194;
                          int v74 = v192;
                          unsigned int v155 = v133 + v99;
                          unsigned int v287 = v290 + v155;
                          if (v290 + v155)
                          {
                            __int16 appended = __appendUnoptimized(*(uint64_t *)v309, v291, v286, v290 + v155);
                            v60.i32[3] = 0;
                            v60.i16[0] = appended;
                            v60.i16[1] = v288 | (unsigned __int16)((_WORD)v289 << 8);
                            *(uint64_t *)((char *)v60.i64 + 4) = v290;
                          }
                          else
                          {
                            float32x4_t v60 = 0uLL;
                          }
                          if (v177)
                          {
                            *(void *)(v176 + 8 * v192) = v60.i64[0];
                          }
                          else
                          {
                            float32x4_t v60 = (float32x4_t)vmovl_u16(*(uint16x4_t *)v60.f32);
                            int32x4_t v157 = (_WORD *)(v176 + 4 * v192);
                            v157[1] = v60.i16[2];
                            *int32x4_t v157 = v60.i16[0];
                          }
                        }
                      }
                      ++v73;
                      ++v74;
                    }
                    while (v73 != v59);
                  }
                }
                ++v190;
              }
              while (v190 != v174);
            }
          }
        }
        ++v175;
      }
      while (v175 != v169);
    }
    __compactLightIndices((uint64_t)&v261, v176, v164);
    uint64_t v158 = v292;
    if (v292 <= 1) {
      int v159 = 1;
    }
    else {
      int v159 = v292;
    }
    unsigned int v160 = (v159 - 1) | ((v159 - 1) >> 1) | (((v159 - 1) | ((v159 - 1) >> 1)) >> 2);
    unsigned int v161 = v160 | (v160 >> 4) | ((v160 | (v160 >> 4)) >> 8);
    LOWORD(v231) = (v161 | HIWORD(v161)) + 1;
    *(_DWORD *)((char *)&v231 + 2) = 0;
    *(_DWORD *)((char *)&v231 + 5) = 0;
    BYTE9(v231) = 0;
    *(_DWORD *)((char *)&v231 + 10) = 851969;
    HIWORD(v231) = 0;
    int v232 = 0;
    int v162 = (void *)SCNMTLTexturePool::allocate(v165, &v231, 0, 1);
    *((void *)v167 + 4) = v162;
    if (v158)
    {
      memset(v229, 0, 24);
      v229[3] = v158;
      int64x2_t v230 = vdupq_n_s64(1uLL);
      [v162 replaceRegion:v229 mipmapLevel:0 withBytes:v291[2] bytesPerRow:v292];
    }
    v222[1] = v170.u16[2];
    v222[0] = v170.i16[0];
    v222[2] = v170.u16[4];
    if (v177) {
      __int16 v163 = 113;
    }
    else {
      __int16 v163 = 63;
    }
    v222[3] = 0;
    char v223 = 7;
    char v224 = 2;
    __int16 v225 = 1;
    __int16 v226 = v163;
    __int16 v227 = 0;
    int v228 = 0;
    long long v220 = *(_OWORD *)v167;
    uint64_t v221 = *((void *)v167 + 2);
    *((void *)v167 + 3) = SCNMTLTexturePool::allocateWithStagingBuffer(v165, v222, &v220, 1);
    return C3DStackAllocatorPopFrame(StackAllocator);
  }
  return result;
}

void _addLightsInFrustum(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  unsigned int v218 = v3;
  uint64_t v5 = v4;
  uint64_t v342 = *MEMORY[0x263EF8340];
  uint64_t v7 = v6[1];
  uint64_t v267 = *v6;
  CFDictionaryRef v8 = (const __CFDictionary *)v6[2];
  uint64_t v217 = (SCNMTLBufferPool *)v6[3];
  float v9 = (__n128 *)v6[4];
  float v10 = (float32x4_t *)v6[5];
  unint64_t v11 = (_OWORD *)v6[6];
  uint64_t Scene = (__n128 *)C3DEngineContextGetScene(v7);
  memset(v341, 0, 512);
  memset(v340, 0, 512);
  uint64_t v324 = 0;
  v325 = &v324;
  uint64_t v326 = 0x2020000000;
  int v327 = 0;
  v323[0] = MEMORY[0x263EF8330];
  v323[1] = 3221225472;
  v323[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke;
  v323[3] = &unk_2640078C8;
  v323[4] = &v324;
  v323[5] = v340;
  v323[6] = v341;
  __int16 v226 = (uint64_t *)v7;
  C3DLightingSystemEnumerateGlobalLights(v8, v7, (uint64_t)v323);
  uint64_t v12 = *((unsigned int *)v325 + 6);
  v311[0] = MEMORY[0x263EF8330];
  v311[1] = 3221225472;
  v311[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_2;
  v311[3] = &unk_2640078F0;
  long long v13 = v5[3];
  long long v314 = v5[2];
  long long v315 = v13;
  long long v14 = v5[5];
  long long v316 = v5[4];
  long long v317 = v14;
  long long v15 = v5[1];
  long long v312 = *v5;
  long long v313 = v15;
  v318 = &v324;
  uint64_t v16 = v12;
  int64x2_t v230 = v9;
  v319 = v9;
  int v322 = v12;
  v320 = v340;
  v321 = v341;
  C3DLightingSystemEnumerateLocalOmnis((uint64_t)v8, (uint64_t)v311);
  uint64_t v231 = (uint64_t)v8;
  if (Scene)
  {
    ParticleManager = C3DSceneGetParticleManager((uint64_t)Scene, 0);
    if (ParticleManager)
    {
      v298[0] = MEMORY[0x263EF8330];
      v298[1] = 3221225472;
      v298[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_3;
      v298[3] = &unk_264007918;
      long long v18 = v5[3];
      long long v301 = v5[2];
      long long v302 = v18;
      long long v19 = v5[5];
      long long v303 = v5[4];
      long long v304 = v19;
      long long v20 = v5[1];
      long long v299 = *v5;
      long long v300 = v20;
      uint64_t v305 = &v324;
      v306 = v9;
      int v310 = v16;
      v307 = (_OWORD *)v339;
      unsigned int v308 = v340;
      v309 = v341;
      C3DParticleManagerEnumerateInstancesWithLightEmission((uint64_t)ParticleManager, (uint64_t)v298);
    }
  }
  LODWORD(v21) = v16;
  HIDWORD(v21) = *((_DWORD *)v325 + 6) - v16;
  v2[5].i64[1] = v21;
  C3DEngineContextGetAuthoringEnvironment(v7, 0);
  long long v22 = v5[3];
  v297[2] = v5[2];
  v297[3] = v22;
  long long v23 = v5[5];
  v297[4] = v5[4];
  v297[5] = v23;
  long long v24 = v5[1];
  v297[0] = *v5;
  v297[1] = v24;
  __sortOmniLightsOnZAxis((uint64_t)v297, v9, (void *)v341 + v16, (void *)v340 + v16, &v339[v16], v2[5].i16[6], *(double *)v297);
  uint64_t v219 = v16;
  uint64_t v25 = *((unsigned int *)v325 + 6);
  v285[0] = MEMORY[0x263EF8330];
  v285[1] = 3221225472;
  v285[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_4;
  v285[3] = &unk_264007940;
  long long v26 = v5[3];
  long long v288 = v5[2];
  long long v289 = v26;
  long long v27 = v5[5];
  long long v290 = v5[4];
  long long v291 = v27;
  long long v28 = v5[1];
  long long v286 = *v5;
  long long v287 = v28;
  unsigned int v292 = &v324;
  float32x4_t v293 = v10;
  int v296 = v25;
  float32x4_t v294 = v340;
  float32x4_t v295 = v341;
  C3DLightingSystemEnumerateSpots((uint64_t)v8, (uint64_t)v285);
  unsigned int v29 = *((_DWORD *)v325 + 6) - v25;
  v2[6].i64[0] = __PAIR64__(v29, v25);
  long long v30 = v5[3];
  v284[2] = v5[2];
  v284[3] = v30;
  long long v31 = v5[5];
  v284[4] = v5[4];
  v284[5] = v31;
  long long v32 = v5[1];
  v284[0] = *v5;
  v284[1] = v32;
  __sortSpotLightsOnZAxis((uint64_t)v284, v10, (void *)v341 + v25, (void *)v340 + v25, (__int16)v29, *(double *)v284);
  uint64_t v33 = *((unsigned int *)v325 + 6);
  v272[0] = MEMORY[0x263EF8330];
  v272[1] = 3221225472;
  v272[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_5;
  v272[3] = &unk_264007968;
  long long v34 = v5[3];
  long long v275 = v5[2];
  long long v276 = v34;
  long long v35 = v5[5];
  long long v277 = v5[4];
  long long v278 = v35;
  long long v36 = v5[1];
  long long v273 = *v5;
  long long v274 = v36;
  v280 = v11;
  unsigned int v279 = &v324;
  int v283 = v33;
  unsigned int v281 = v340;
  v282 = v341;
  C3DLightingSystemEnumerateRadianceProbes((uint64_t)v8, (uint64_t)v272);
  unsigned int v37 = *((_DWORD *)v325 + 6) - v33;
  v2[6].i64[1] = __PAIR64__(v37, v33);
  __sortProbesByVolume(v11, (void *)v341 + v33, (void *)v340 + v33, (__int16)v37);
  unsigned int v38 = v218;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v7);
  __int16 v225 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v223 = RenderContext;
  char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(v7);
  if (v218)
  {
    float32x4_t v40 = (float32x4_t *)(v267 + 3088);
    simd_float4 v41 = v337;
    simd_float4 v42 = v338;
    simd_float4 v43 = (float *)v336;
    uint64_t v44 = v218;
    do
    {
      float32x4_t v45 = v40[1];
      *simd_float4 v42 = *v40;
      v42[1] = v45;
      float32x4_t v46 = v40[3];
      v42[2] = v40[2];
      v42[3] = v46;
      simd_float4x4 v343 = *(simd_float4x4 *)v42->i8;
      float32x4_t v259 = (float32x4_t)v343.columns[1];
      float32x4_t v261 = (float32x4_t)v343.columns[2];
      float32x4_t v268 = *v42;
      simd_float4x4 v344 = __invert_f4(*(simd_float4x4 *)v42->f32);
      int8x16_t v47 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v261, (int32x4_t)v261), (int8x16_t)v261, 0xCuLL), vnegq_f32(v259)), v261, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v259, (int32x4_t)v259), (int8x16_t)v259, 0xCuLL));
      float32x4_t v48 = vmulq_f32(v268, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), v47, 0xCuLL));
      float32x4_t v49 = vmulq_f32(v268, v268);
      float32x4_t v50 = vmulq_f32(v259, v259);
      float32x4_t v51 = vmulq_f32(v261, v261);
      float32x4_t v54 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1)));
      _NF = v54.f32[0] < 0.0;
      v54.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0]);
      v49.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0]);
      float v53 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]);
      v54.i32[1] = v49.i32[0];
      if (_NF) {
        float v55 = -1.0;
      }
      else {
        float v55 = 1.0;
      }
      v54.f32[2] = v53;
      float32x4_t v56 = vabsq_f32(vmulq_n_f32(v54, v55));
      *v43++ = fmaxf(fmaxf(v56.f32[0], v56.f32[2]), v56.f32[1]);
      *(simd_float4x4 *)(v41 - 32) = v344;
      v41 += 64;
      v42 += 4;
      v40 += 4;
      --v44;
    }
    while (v44);
  }
  unsigned int v57 = *((_DWORD *)v325 + 6);
  if (v57 <= 1) {
    unsigned int v57 = 1;
  }
  v2[8].i32[2] = v57;
  SCNMTLBufferPool::allocate(v217, (v218 * (unint64_t)v57) << 8, v270);
  v2[7] = v270[0].columns[0];
  v2[8].i64[0] = v270[0].columns[1].i64[0];
  size_t v58 = v325;
  if (*((_DWORD *)v325 + 6))
  {
    unsigned int v59 = 0;
    unint64_t v260 = 0;
    uint64_t v269 = v2[7].i64[0];
    __asm { FMOV            V0.4S, #1.0 }
    int v229 = DWORD2(_Q0);
    v252 = v2;
    do
    {
      if (v38)
      {
        uint64_t v63 = 0;
        uint64_t v64 = (uint64_t *)v2 + v260;
        char v224 = (const void **)(v64 + 18);
        __int16 v227 = (void **)(v64 + 34);
        int v228 = (float32x2_t **)(v64 + 26);
        unsigned int v221 = v59;
        do
        {
          int v65 = (__n128 *)*((void *)v340 + v260);
          float32x4_t v262 = (float32x4_t *)*((void *)v341 + v260);
          uint64_t v66 = v260 * v218 + v63;
          uint64_t v67 = v269 + (v66 << 8);
          uint64_t v68 = v252[6].i64[1];
          if (v260 < v68 || v260 >= (v68 + HIDWORD(v252[6].i64[1])))
          {
            if (v65)
            {
              int Type = C3DLightGetType((uint64_t)v65);
              C3DLightGetColorModulatedByIntensity((uint64_t)v65, v71, v72, v73, v74, v75, v76, v77);
              *(void *)&long long v79 = v78;
              DWORD2(v79) = v80;
              HIDWORD(v79) = *(_DWORD *)(v67 + 12);
              *(_OWORD *)uint64_t v67 = v79;
              C3DLightGetShadowColor((uint64_t)v65);
              long long v82 = *(_OWORD *)v67;
              HIDWORD(v82) = vdupq_n_s64(v81).i32[3];
              *(_OWORD *)uint64_t v67 = v82;
              WorldMatrix = C3DNodeGetWorldMatrix(v262);
              uint64_t v84 = 0;
              simd_float4 v85 = (simd_float4)WorldMatrix[1];
              simd_float4 v86 = (simd_float4)WorldMatrix[2];
              simd_float4 v87 = (simd_float4)WorldMatrix[3];
              uint64_t v88 = &v338[4 * v63];
              float32x4_t v89 = *v88;
              float32x4_t v90 = v88[1];
              float32x4_t v91 = v88[2];
              float32x4_t v92 = v88[3];
              unint64_t v93 = v269 + 128 + ((unint64_t)v59 << 8);
              v329.columns[0] = (simd_float4)*WorldMatrix;
              v329.columns[1] = v85;
              v329.columns[2] = v86;
              v329.columns[3] = v87;
              do
              {
                v270[0].columns[v84] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v89, COERCE_FLOAT(*(_OWORD *)&v329.columns[v84])), v90, *(float32x2_t *)v329.columns[v84].f32, 1), v91, (float32x4_t)v329.columns[v84], 2), v92, (float32x4_t)v329.columns[v84], 3);
                ++v84;
              }
              while (v84 != 4);
              simd_float4x4 v240 = v270[0];
              uint64_t v94 = v269 + (v66 << 8);
              int32x4_t v95 = (int32x4_t)vmulq_f32((float32x4_t)v270[0].columns[2], (float32x4_t)v270[0].columns[2]);
              v95.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v95, 2), vadd_f32(*(float32x2_t *)v95.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v95.i8, 1))).u32[0];
              float32x2_t v96 = vrsqrte_f32((float32x2_t)v95.u32[0]);
              float32x2_t v97 = vmul_f32(v96, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v96, v96)));
              float32x4_t v98 = vmulq_n_f32((float32x4_t)v270[0].columns[2], vmul_f32(v97, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v97, v97))).f32[0]);
              *(simd_float4 *)(v94 + 16) = v270[0].columns[3];
              *(float32x4_t *)(v94 + 32) = v98;
              float32x4_t v253 = (simd_float4 *)v94;
              v99.f32[0] = C3DLightComputeDistanceAttenuations((float *)v65, 1, *(float *)&v336[v63]);
              v253[4] = v99;
              float32x4_t v254 = v253 + 4;
              if (Type == 6)
              {
                switch(v65[16].n128_u8[0])
                {
                  case 0u:
                    v254->i32[0] = v65[17].n128_i32[0];
                    break;
                  case 1u:
                  case 2u:
                    float v124 = 1.0;
                    if ((v65[15].n128_u8[0] & 1) == 0) {
                      float v124 = 0.0;
                    }
                    v254->f32[2] = v124;
                    v254->i64[0] = v65[17].n128_i64[0];
                    break;
                  case 3u:
                    *float32x4_t v254 = (simd_float4)v65[17];
                    break;
                  case 4u:
                    float v125 = 1.0;
                    if ((v65[15].n128_u8[0] & 1) == 0) {
                      float v125 = 0.0;
                    }
                    v254->f32[1] = v125;
                    v254->i32[0] = v65[17].n128_u8[0];
                    break;
                  default:
                    break;
                }
                *(simd_float4x4 *)(v269 + (v66 << 8) + 192) = v240;
              }
              else if (Type == 3)
              {
                C3DLightComputeSpotAttenuations((uint64_t)v65);
                v254[1].i64[0] = v100;
              }
              int v126 = (unsigned char *)(v269 + (v66 << 8));
              v126[52] = Type;
              v126[53] = C3DLightGetDistanceAttenuationType((uint64_t)v65);
              v126[54] = C3DLightGetEffectiveShadowSampleCount((uint64_t)v65);
              uint64_t v238 = v126 + 54;
              if (v260 <= 7)
              {
                if (C3DLightGetCastsShadow((uint64_t)v65)
                  && C3DLightTypeSupportsShadow((uint64_t)v65))
                {
                  int v127 = C3DLightGetUsesDeferredShadows((uint64_t)v65) ^ 1;
                }
                else
                {
                  int v127 = 0;
                }
                int HasValidGobo = C3DLightHasValidGobo((uint64_t)v65);
                BOOL HasValidIES = C3DLightHasValidIES((uint64_t)v65);
                if (v127)
                {
                  ShadowMapNameForuint64_t Node = (__CFString *)C3DLightingSystemGetShadowMapNameForNode(v231, v262);
                  if (!ShadowMapNameForNode)
                  {
                    long long v220 = scn_default_log();
                    if (os_log_type_enabled(v220, OS_LOG_TYPE_FAULT)) {
                      _addLightsInFrustum(v330, &v331, v220);
                    }
                  }
                  *char v224 = C3DEngineContextGetTextureWithName((uint64_t)v226, ShadowMapNameForNode);
                  ActiveShadowCasterunsigned int Index = C3DLightingSystemGetActiveShadowCasterIndex(v231, v262);
                  if (ActiveShadowCasterIndex)
                  {
                    ActiveShadowCasterDatSCNMatrix4 a = C3DLightingSystemGetActiveShadowCasterData(v231, ActiveShadowCasterIndex);
                    uint64_t v138 = ActiveShadowCasterData;
                    __n128 v139 = *(__n128 *)(ActiveShadowCasterData + 64);
                    __n128 v140 = *(__n128 *)(ActiveShadowCasterData + 80);
                    __n128 v141 = *(__n128 *)(ActiveShadowCasterData + 96);
                    __n128 v142 = *(__n128 *)(ActiveShadowCasterData + 112);
                    if (Type == 2)
                    {
                      uint64_t v143 = 0;
                      float32x4_t v144 = (simd_float4 *)&v336[16 * v63 + 6];
                      simd_float4 v145 = v144[1];
                      simd_float4 v146 = v144[2];
                      simd_float4 v147 = v144[3];
                      v329.columns[0] = *v144;
                      v329.columns[1] = v145;
                      v329.columns[2] = v146;
                      v329.columns[3] = v147;
                      do
                      {
                        v270[0].columns[v143] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v139, COERCE_FLOAT(*(_OWORD *)&v329.columns[v143])), (float32x4_t)v140, *(float32x2_t *)v329.columns[v143].f32, 1), (float32x4_t)v141, (float32x4_t)v329.columns[v143], 2), (float32x4_t)v142, (float32x4_t)v329.columns[v143], 3);
                        ++v143;
                      }
                      while (v143 != 4);
                      uint64_t v148 = 0;
                      simd_float4 v149 = v270[0].columns[0];
                      simd_float4 v150 = v270[0].columns[1];
                      simd_float4 v151 = v270[0].columns[2];
                      simd_float4 v152 = v270[0].columns[3];
                      float v153 = (simd_float4 *)(v269 + (v66 << 8));
                      v153[12] = v270[0].columns[0];
                      v153[13] = v150;
                      uint64_t v154 = v153 + 12;
                      v154[2] = v151;
                      v154[3] = v152;
                      v329.columns[0] = v149;
                      v329.columns[1] = v150;
                      v329.columns[2] = v151;
                      v329.columns[3] = v152;
                      do
                      {
                        v270[0].columns[v148] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(_OWORD *)&v329.columns[v148])), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)v329.columns[v148].f32, 1), (float32x4_t)xmmword_20B5CB810, (float32x4_t)v329.columns[v148], 2), (float32x4_t)xmmword_20B5CB530, (float32x4_t)v329.columns[v148], 3);
                        ++v148;
                      }
                      while (v148 != 4);
                      simd_float4 v155 = v270[0].columns[1];
                      simd_float4 v156 = v270[0].columns[2];
                      simd_float4 v157 = v270[0].columns[3];
                      simd_float4 *v154 = v270[0].columns[0];
                      v154[1] = v155;
                      v154[2] = v156;
                      v154[3] = v157;
                      v254[1] = *(simd_float4 *)(ActiveShadowCasterData + 192);
                    }
                    else
                    {
                      *(double *)&long long v158 = _computeShadowMatrix(CoordinatesSystemOptions, v139, v140, v141, v142, *(__n128 *)(ActiveShadowCasterData + 128), *(__n128 *)(ActiveShadowCasterData + 144), *(__n128 *)(ActiveShadowCasterData + 160), *(__n128 *)(ActiveShadowCasterData + 176), v131, v132, v133, v134, v135, v136, v137, *(__n128 *)&v336[16 * v63 + 6], *(__n128 *)&v336[16 * v63 + 10], *(__n128 *)&v336[16 * v63 + 14],
                                           *(__n128 *)&v337[64 * v63 + 16]);
                      int v159 = (_OWORD *)(v269 + (v66 << 8));
                      v159[12] = v158;
                      v159[13] = v160;
                      v159[14] = v161;
                      v159[15] = v162;
                      if (Type == 1)
                      {
                        ShadowCascadeint Count = C3DLightGetShadowCascadeCount((uint64_t)v65);
                        if (ShadowCascadeCount)
                        {
                          uint64_t v164 = ShadowCascadeCount;
                          uint64_t v165 = (long long *)(v138 + 208);
                          do
                          {
                            long long v166 = *(v165 - 1);
                            HIDWORD(v166) = *(_DWORD *)(v93 - 52);
                            *(_OWORD *)(v93 - 64) = v166;
                            long long v167 = *v165;
                            HIDWORD(v167) = *(_DWORD *)(v93 + 12);
                            *(_OWORD *)unint64_t v93 = v167;
                            v93 += 16;
                            v165 += 24;
                            --v164;
                          }
                          while (v164);
                        }
                      }
                    }
                  }
                  if (*v238 >= 2u)
                  {
                    RealShadowMapint Size = C3DLightGetRealShadowMapSize((uint64_t)v65);
                    float ShadowRadius = C3DLightGetShadowRadius((uint64_t)v65);
                    __int32 v169 = RealShadowMapSize.i32[1];
                    if (*(float *)RealShadowMapSize.i32 >= *(float *)&RealShadowMapSize.i32[1]) {
                      __int32 v169 = RealShadowMapSize.i32[0];
                    }
                    *(float *)(v269 + (v66 << 8) + 4_Block_object_dispose(&STACK[0x380], 8) = ShadowRadius / fmaxf(*(float *)&v169, 1.0);
                  }
                  float ShadowCascadeDebugFactor = C3DLightGetShadowCascadeDebugFactor((uint64_t)v65);
                  if (ShadowCascadeDebugFactor != 0.0) {
                    *(float *)(v67 + 12) = ShadowCascadeDebugFactor;
                  }
                }
                if (HasValidIES)
                {
                  *(float *)v171.i32 = (float)(180.0 / C3DLightGetIESSpotAngle((uint64_t)v65)) * 0.5;
                  *(int32x2_t *)v254[1].f32 = vdup_lane_s32(v171, 0);
                  simd_float4x4 v173 = __invert_f4(v240);
                  int8x16_t v172 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v173.columns[2], (int32x4_t)v173.columns[2]), (int8x16_t)v173.columns[2], 0xCuLL), vnegq_f32((float32x4_t)v173.columns[1])), (float32x4_t)v173.columns[2], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v173.columns[1], (int32x4_t)v173.columns[1]), (int8x16_t)v173.columns[1], 0xCuLL));
                  v173.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v173.columns[0], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v172, (int32x4_t)v172), v172, 0xCuLL));
                  _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v173.columns[3], 2), vaddq_f32((float32x4_t)v173.columns[3], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v173.columns[3].f32, 1))).f32[0] < 0.0;
                  v173.columns[3].i32[0] = 1.0;
                  if (_NF) {
                    v173.columns[3].f32[0] = -1.0;
                  }
                  float32x4_t v174 = vmulq_f32((float32x4_t)v173.columns[0], (float32x4_t)v173.columns[0]);
                  float32x4_t v175 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v174, 2), vaddq_f32(v174, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v174.f32, 1)));
                  float32x4_t v176 = vmulq_f32((float32x4_t)v173.columns[1], (float32x4_t)v173.columns[1]);
                  v175.f32[0] = sqrtf(v175.f32[0]);
                  float32x4_t v177 = vmulq_f32((float32x4_t)v173.columns[2], (float32x4_t)v173.columns[2]);
                  v175.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v176, 2), vaddq_f32(v176, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v176.f32, 1))).f32[0]);
                  v175.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v177, 2), vaddq_f32(v177, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v177.f32, 1))).f32[0]);
                  float32x4_t v178 = vmulq_n_f32(v175, v173.columns[3].f32[0]);
                  uint32x4_t v179 = (uint32x4_t)vceqzq_f32(v178);
                  v179.i32[3] = v179.i32[2];
                  if ((vmaxvq_u32(v179) & 0x80000000) != 0
                    || (uint32x4_t v180 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v178), (int8x16_t)vcgezq_f32(v178))),
                        v180.i32[3] = v180.i32[2],
                        (vmaxvq_u32(v180) & 0x80000000) != 0))
                  {
                    v173.columns[0] = *(simd_float4 *)(MEMORY[0x263EF89A8] + 48);
                  }
                  else
                  {
                    v173.columns[3] = (simd_float4)vdivq_f32((float32x4_t)v173.columns[0], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v178.f32, 0));
                    v173.columns[0] = (simd_float4)vdivq_f32((float32x4_t)v173.columns[1], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v178.f32, 1));
                    v173.columns[1] = (simd_float4)vdivq_f32((float32x4_t)v173.columns[2], (float32x4_t)vdupq_laneq_s32((int32x4_t)v178, 2));
                    v173.columns[2].f32[0] = v173.columns[1].f32[2]
                                           + (float)(v173.columns[3].f32[0] + v173.columns[0].f32[1]);
                    if (v173.columns[2].f32[0] <= 0.0)
                    {
                      if (v173.columns[3].f32[0] <= v173.columns[0].f32[1]
                        || v173.columns[3].f32[0] <= v173.columns[1].f32[2])
                      {
                        if (v173.columns[0].f32[1] <= v173.columns[1].f32[2])
                        {
                          v173.columns[2].f32[0] = (float)(v173.columns[1].f32[2] + 1.0) - v173.columns[3].f32[0];
                          v173.columns[3] = (simd_float4)vzip2q_s32((int32x4_t)v173.columns[3], vzip1q_s32((int32x4_t)v173.columns[1], (int32x4_t)v173.columns[3]));
                          v173.columns[0] = (simd_float4)vrev64q_s32((int32x4_t)v173.columns[0]);
                          float32x4_t v207 = (float32x4_t)vextq_s8((int8x16_t)v173.columns[0], (int8x16_t)v173.columns[0], 8uLL);
                          v207.i32[0] = v173.columns[1].i32[0];
                          v173.columns[0].i64[0] = vaddq_f32((float32x4_t)v173.columns[3], v207).u64[0];
                          v173.columns[3].i32[2] = v173.columns[2].i32[0];
                          v173.columns[0].i64[1] = vsubq_f32(*(float32x4_t *)(&v173 + 48), v207).i64[1];
                          v173.columns[1].i32[0] = v173.columns[0].i32[2];
                        }
                        else
                        {
                          v173.columns[2].f32[0] = (float)(v173.columns[0].f32[1] + 1.0) - v173.columns[3].f32[0];
                          float32x4_t v204 = (float32x4_t)v173.columns[0];
                          v204.i32[0] = v173.columns[3].i32[1];
                          v173.columns[0].i32[1] = v173.columns[1].i32[2];
                          v173.columns[0].i32[2] = v173.columns[1].i32[1];
                          int32x4_t v205 = (int32x4_t)vaddq_f32(v204, (float32x4_t)v173.columns[0]);
                          v204.i32[1] = v173.columns[2].i32[0];
                          v204.i32[3] = v173.columns[1].i32[0];
                          v173.columns[0].i32[3] = v173.columns[3].i32[2];
                          v173.columns[1] = (simd_float4)vsubq_f32(v204, (float32x4_t)v173.columns[0]);
                          v173.columns[0] = (simd_float4)vtrn2q_s32(vrev64q_s32(v205), (int32x4_t)v173.columns[1]);
                          v173.columns[1].i32[0] = v173.columns[1].i32[1];
                        }
                      }
                      else
                      {
                        float32x4_t v206 = (float32x4_t)v173.columns[3];
                        v206.f32[0] = (float)(v173.columns[3].f32[0] + 1.0) - v173.columns[0].f32[1];
                        v206.i32[3] = v173.columns[0].i32[2];
                        v173.columns[2] = (simd_float4)vextq_s8((int8x16_t)v173.columns[1], (int8x16_t)v173.columns[1], 8uLL);
                        v173.columns[1] = (simd_float4)vsubq_f32(v206, (float32x4_t)v173.columns[2]);
                        v173.columns[2].i32[1] = v173.columns[0].i32[0];
                        v173.columns[0] = (simd_float4)vaddq_f32((float32x4_t)v173.columns[3], (float32x4_t)v173.columns[2]);
                        v173.columns[0].i32[0] = v173.columns[1].i32[0];
                        v173.columns[0].i32[3] = v173.columns[1].i32[3];
                      }
                    }
                    else
                    {
                      float32x4_t v181 = (float32x4_t)vzip2q_s32((int32x4_t)v173.columns[0], vuzp1q_s32((int32x4_t)v173.columns[0], (int32x4_t)v173.columns[1]));
                      v181.i32[2] = v173.columns[3].i32[1];
                      v173.columns[1] = (simd_float4)vtrn2q_s32((int32x4_t)v173.columns[1], vzip2q_s32((int32x4_t)v173.columns[1], (int32x4_t)v173.columns[3]));
                      v173.columns[1].i32[2] = v173.columns[0].i32[0];
                      v173.columns[0] = (simd_float4)vsubq_f32(v181, (float32x4_t)v173.columns[1]);
                      v173.columns[1].i32[3] = 1.0;
                      v181.i32[3] = v173.columns[2].i32[0];
                      v173.columns[0].i32[3] = vaddq_f32(v181, *(float32x4_t *)(&v173 + 16)).i32[3];
                      v173.columns[1].i32[0] = v173.columns[0].i32[3];
                    }
                    v173.columns[2].i32[0] = 0;
                    v173.columns[0] = (simd_float4)vmulq_n_f32((float32x4_t)v173.columns[0], 0.5 / sqrtf(v173.columns[1].f32[0]));
                    v173.columns[1] = (simd_float4)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)v173.columns[0]), (int8x16_t)vcgezq_f32((float32x4_t)v173.columns[0])));
                    v173.columns[1].i32[0] = vmaxvq_u32((uint32x4_t)v173.columns[1]);
                    v173.columns[0] = (simd_float4)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32((int32x4_t)v173.columns[2], (int32x4_t)v173.columns[1]), 0), *(int8x16_t *)(MEMORY[0x263EF89A8] + 48), (int8x16_t)v173.columns[0]);
                  }
                  v254[2] = v173.columns[0];
                  int *v228 = (float32x2_t *)[v225 iesTextureForProfile:C3DLightGetIESProfileURL((uint64_t)v65) renderContext:v223];
                  *__int16 v227 = 0;
                }
                else if (HasValidGobo)
                {
                  uint64_t v271 = 0;
                  int *v228 = C3DEngineContextGetTextureForEffectSlot(v226, v65[12].n128_i64[1], &v271);
                  *__int16 v227 = -[SCNMTLResourceManager renderResourceForSampler:]((uint64_t)v225, v271);
                  C3DLightGetProjectionInfo((uint64_t)v65, (uint64_t)v270);
                  Matrix = C3DProjectionInfosGetMatrix((char *)v270, 0, CoordinatesSystemOptions);
                  float32x4_t v257 = *(float32x4_t *)Matrix;
                  float32x4_t v265 = *((float32x4_t *)Matrix + 1);
                  float32x4_t v236 = *((float32x4_t *)Matrix + 3);
                  float32x4_t v239 = *((float32x4_t *)Matrix + 2);
                  simd_float4x4 v346 = __invert_f4(v240);
                  uint64_t v183 = 0;
                  simd_float4x4 v328 = v346;
                  do
                  {
                    v329.columns[v183] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v257, COERCE_FLOAT(*(_OWORD *)&v328.columns[v183])), v265, *(float32x2_t *)v328.columns[v183].f32, 1), v239, (float32x4_t)v328.columns[v183], 2), v236, (float32x4_t)v328.columns[v183], 3);
                    ++v183;
                  }
                  while (v183 != 4);
                  simd_float4 v266 = v329.columns[0];
                  simd_float4 v258 = v329.columns[1];
                  simd_float4 v244 = v329.columns[3];
                  simd_float4 v246 = v329.columns[2];
                  if (C3DKeyframeControllerHasInterpolationModesPerKey(v65[12].n128_i64[1]))
                  {
                    ImageTransforCFIndex m = (float32x4_t *)C3DEffectSlotGetImageTransform(v65[12].n128_i64[1]);
                    uint64_t v185 = 0;
                    float32x4_t v186 = *ImageTransform;
                    float32x4_t v187 = ImageTransform[1];
                    float32x4_t v188 = ImageTransform[2];
                    float32x4_t v189 = ImageTransform[3];
                    v328.columns[0] = v266;
                    v328.columns[1] = v258;
                    v328.columns[2] = v246;
                    v328.columns[3] = v244;
                    do
                    {
                      v329.columns[v185] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v186, COERCE_FLOAT(*(_OWORD *)&v328.columns[v185])), v187, *(float32x2_t *)v328.columns[v185].f32, 1), v188, (float32x4_t)v328.columns[v185], 2), v189, (float32x4_t)v328.columns[v185], 3);
                      ++v185;
                    }
                    while (v185 != 4);
                    simd_float4 v190 = v329.columns[0];
                    simd_float4 v191 = v329.columns[1];
                    simd_float4 v192 = v329.columns[2];
                    simd_float4 v193 = v329.columns[3];
                  }
                  else
                  {
                    simd_float4 v190 = v266;
                    simd_float4 v191 = v258;
                    simd_float4 v193 = v244;
                    simd_float4 v192 = v246;
                  }
                  uint64_t v194 = 0;
                  float32x4_t v195 = *(float32x4_t *)MEMORY[0x263EF89A8];
                  float32x4_t v196 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
                  v195.i32[0] = 0.5;
                  float32x4_t v197 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
                  v196.i32[1] = -0.5;
                  v197.i32[2] = 1.0;
                  v198.i64[0] = 0x3F0000003F000000;
                  v198.i64[1] = *(void *)(MEMORY[0x263EF89A8] + 56);
                  v328.columns[0] = v190;
                  v328.columns[1] = v191;
                  v328.columns[2] = v192;
                  v328.columns[3] = v193;
                  do
                  {
                    v329.columns[v194] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v195, COERCE_FLOAT(*(_OWORD *)&v328.columns[v194])), v196, *(float32x2_t *)v328.columns[v194].f32, 1), v197, (float32x4_t)v328.columns[v194], 2), v198, (float32x4_t)v328.columns[v194], 3);
                    ++v194;
                  }
                  while (v194 != 4);
                  simd_float4 v199 = v329.columns[1];
                  simd_float4 v200 = v329.columns[2];
                  simd_float4 v201 = v329.columns[3];
                  v202 = (simd_float4 *)(v269 + (v66 << 8));
                  v202[12] = v329.columns[0];
                  v202[13] = v199;
                  v202[14] = v200;
                  v202[15] = v201;
                  *(float *)(v67 + 12) = C3DEffectSlotGetIntensity(v65[12].n128_i64[1]);
                }
              }
            }
            else
            {
              *(__n128 *)uint64_t v67 = v339[v260];
              float32x4_t v105 = (float32x4_t)v230[(v260 - v219)];
              uint64_t v104 = v269 + (v66 << 8);
              *(float32x4_t *)(v104 + 16) = vaddq_f32(v338[4 * v63 + 3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v338[4 * v63], v105.f32[0]), v338[4 * v63 + 1], *(float32x2_t *)v105.f32, 1), v338[4 * v63 + 2], v105, 2));
              v105.i32[0] = v105.i32[3];
              if (v105.f32[3] <= 0.01) {
                v105.f32[0] = INFINITY;
              }
              DWORD2(v106) = v229;
              *(float *)&long long v106 = -1.0 / v105.f32[3];
              *((float *)&v106 + 1) = (float)((float)(-1.0 / v105.f32[3]) * -0.0) + 1.0;
              *((float *)&v106 + 3) = 1.0 / (float)(v105.f32[0] * v105.f32[0]);
              *(_OWORD *)(v104 + 64) = v106;
            }
          }
          else
          {
            *(unsigned char *)(v67 + 52) = 4;
            if (v65)
            {
              if (C3DLightGetType((uint64_t)v65) != 4)
              {
                unsigned int v101 = scn_default_log();
                if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
                  _addLightsInFrustum(v334, &v335, v101);
                }
              }
              uint64_t ProbeEnvironment = C3DLightGetProbeEnvironment((uint64_t)v65, 0);
              if (ProbeEnvironment) {
                float Intensity = C3DEffectSlotGetIntensity(ProbeEnvironment);
              }
              else {
                float Intensity = 1.0;
              }
              *(float *)uint64_t v67 = (float)(Intensity * C3DLightGetIntensity((uint64_t)v65)) / 1000.0;
              RadianceProbeunsigned int Index = C3DLightGetRadianceProbeIndex((uint64_t)v65);
              uint64_t v108 = v269 + (v66 << 8);
              *(_DWORD *)(v108 + 12_Block_object_dispose(&STACK[0x380], 8) = RadianceProbeIndex;
              if (RadianceProbeIndex < 0)
              {
                int32x4_t v109 = scn_default_log();
                if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
                  _addLightsInFrustum(v332, &v333, v109);
                }
              }
              *(__n128 *)(v108 + 64) = C3DLightGetProbeOffset(v65);
              __n128 ProbeExtents = C3DLightGetProbeExtents(v65);
              v111.i64[0] = 0x3F0000003F000000;
              v111.i64[1] = 0x3F0000003F000000;
              float32x4_t v255 = vmulq_f32((float32x4_t)ProbeExtents, v111);
              float32x4_t v112 = v255;
              v112.f32[3] = fmaxf(fmaxf(v255.f32[0], v255.f32[2]), v255.f32[1]) * 0.1;
              *(float32x4_t *)(v108 + 80) = v112;
              *(_DWORD *)(v108 + 132) = C3DLightGetParallaxCorrectionEnabled((uint64_t)v65);
              float32x4_t v113 = vmulq_f32(v255, (float32x4_t)C3DLightGetParallaxCenterOffset(v65));
              *(_DWORD *)(v108 + 104) = v113.i32[2];
              *(void *)(v108 + 96) = v113.i64[0];
              float32x4_t v114 = vmulq_f32(v255, (float32x4_t)C3DLightGetParallaxExtentsFactor(v65));
              *(_DWORD *)(v108 + 120) = v114.i32[2];
              *(void *)(v108 + 112) = v114.i64[0];
              float32x4_t v115 = C3DNodeGetWorldMatrix(v262);
              simd_float4 v248 = (simd_float4)v115[1];
              simd_float4 v249 = *(simd_float4 *)v115;
              simd_float4 v243 = (simd_float4)v115[3];
              simd_float4 v245 = (simd_float4)v115[2];
              *(simd_float4 *)(v269 + (v66 << 8) + 16) = v243;
              float32x4_t v116 = &v338[4 * v63];
              float32x4_t v263 = *v116;
              float32x4_t v256 = v116[1];
              float32x4_t v250 = v116[3];
              float32x4_t v251 = v116[2];
              __n128 v117 = C3DSceneComputeWorldToCubemapMatrix(Scene);
              float32x4_t v234 = v119;
              float32x4_t v237 = v118;
              float32x4_t v241 = v120;
              float32x4_t v242 = (float32x4_t)v117;
              uint64_t v121 = 0;
              v329.columns[0] = v249;
              v329.columns[1] = v248;
              v329.columns[2] = v245;
              v329.columns[3] = v243;
              do
              {
                v270[0].columns[v121] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v263, COERCE_FLOAT(*(_OWORD *)&v329.columns[v121])), v256, *(float32x2_t *)v329.columns[v121].f32, 1), v251, (float32x4_t)v329.columns[v121], 2), v250, (float32x4_t)v329.columns[v121], 3);
                ++v121;
              }
              while (v121 != 4);
              simd_float4x4 v345 = __invert_f4(v270[0]);
              uint64_t v122 = 0;
              simd_float4x4 v329 = v345;
              do
              {
                v270[0].columns[v122] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v242, COERCE_FLOAT(*(_OWORD *)&v329.columns[v122])), v241, *(float32x2_t *)v329.columns[v122].f32, 1), v237, (float32x4_t)v329.columns[v122], 2), v234, (float32x4_t)v329.columns[v122], 3);
                ++v122;
              }
              while (v122 != 4);
              simd_float4x4 v247 = v270[0];
            }
            unsigned int v123 = (_OWORD *)(v269 + (v66 << 8));
            v123[12] = v247.columns[0];
            v123[13] = v247.columns[1];
            v123[14] = v247.columns[2];
            v123[15] = v247.columns[3];
          }
          ++v63;
          ++v59;
        }
        while (v63 != v218);
        size_t v58 = v325;
        uint64_t v2 = v252;
        unsigned int v38 = v218;
        unsigned int v59 = v221;
      }
      v59 += v38;
      ++v260;
    }
    while (v260 < *((unsigned int *)v58 + 6));
  }
  uint64_t v208 = v219;
  if (!v219) {
    goto LABEL_127;
  }
  uint64_t v209 = 0;
  uint64_t v210 = (uint64_t *)v340;
  do
  {
    uint64_t v211 = *v210;
    if (C3DLightGetType(*v210) == 6 && *(unsigned char *)(v211 + 256) == 4) {
      v209 += 8 * *(unsigned __int8 *)(v211 + 272);
    }
    ++v210;
    --v208;
  }
  while (v208);
  uint64_t v212 = v219;
  if (v209)
  {
    memset(v270, 0, 24);
    SCNMTLBufferPool::allocate(v217, v209, v270);
    char v213 = v2 + 22;
    uint64_t v214 = (uint64_t *)v340;
    do
    {
      uint64_t v215 = *v214;
      if (C3DLightGetType(*v214) == 6 && *(unsigned char *)(v215 + 256) == 4) {
        memcpy((void *)(v270[0].columns[0].i64[0] + v213->i64[0]), *(const void **)(v215 + 280), 8 * *(unsigned __int8 *)(v215 + 272));
      }
      ++v214;
      char v213 = (simd_float4 *)((char *)v213 + 8);
      --v212;
    }
    while (v212);
    uint64_t v216 = v270[0].columns[1].i64[0];
    v2[21].i64[0] = v270[0].columns[0].i64[1];
    v2[21].i64[1] = v216;
  }
  else
  {
LABEL_127:
    v2[21].i64[0] = 0;
  }
  _Block_object_dispose(&v324, 8);
}

void sub_20B2BE2BC(_Unwind_Exception *a1)
{
}

double __sortSpotLightsOnZAxis(uint64_t a1, float32x4_t *a2, void *a3, void *a4, int a5, double result)
{
  v52[1] = *MEMORY[0x263EF8340];
  if (a5)
  {
    *(double *)v12.i64 = MEMORY[0x270FA5388](a1);
    long long v15 = (float *)((char *)v52 - v14);
    if (v16 >= 1)
    {
      float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL);
      float32x4_t v18 = vnegq_f32(v12);
      long long v19 = a2 + 2;
      __asm { FMOV            V4.4S, #1.0 }
      uint64_t v25 = v11;
      long long v26 = v15;
      do
      {
        float32x4_t v27 = v19[-2];
        float32x4_t v28 = v19[-1];
        float v29 = v19->f32[0];
        v13.i32[0] = v19->i32[1];
        v19 += 3;
        float32x4_t v30 = vmulq_f32(v12, v27);
        float32x4_t v31 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL);
        int8x16_t v32 = (int8x16_t)vmlaq_f32(vmulq_f32(v31, v18), v28, v17);
        float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), v32, 0xCuLL);
        float32x4_t v34 = vmlaq_f32(vmulq_f32(v31, vnegq_f32(v33)), v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL));
        float v35 = v12.f32[3]
            + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
        float32x4_t v36 = vmulq_f32(v34, v34);
        v36.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v36)).u64[0];
        float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 0);
        float32x4_t v38 = vrsqrteq_f32(v37);
        float32x4_t v39 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL);
        float32x4_t v40 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
        _ZF = v36.f32[0] == 0.0;
        float32x4_t v41 = vrsqrtsq_f32(v37, vmulq_f32(v40, v40));
        unsigned int v42 = !_ZF;
        int32x4_t v43 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v42)), 0x1FuLL));
        v43.i32[3] = 0;
        float32x4_t v44 = vmulq_f32(v12, vmlsq_lane_f32(vmlaq_n_f32(v27, v28, v29), vmulq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vmulq_f32(v40, v41), _Q4)), v13, 0));
        v44.f32[0] = v12.f32[3]
                   + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0];
        float v45 = v35 * v44.f32[0];
        float v46 = fminf(v35, v44.f32[0]);
        if (v45 < 0.0) {
          float v46 = 0.0;
        }
        *v26++ = v46;
        --v25;
      }
      while (v25);
    }
    MEMORY[0x270FA5388](v10);
    float32x4_t v49 = (__int16 *)((char *)v52 - v48);
    uint64_t v50 = 0;
    uint64_t v51 = 2 * a5;
    do
    {
      v49[v50] = v50;
      ++v50;
      v51 -= 2;
    }
    while (v51);
    v52[0] = v47;
    std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>((uint64_t)v52 - v48, (__int16 *)((char *)v52 + 2 * a5 - v48), v52, 126 - 2 * __clz(a5), 1);
    reorder<__C3DNode *>(a3, v49, a5);
    reorder<__C3DNode *>(a4, v49, a5);
    *(void *)&uint64_t result = reorder<scn_cone>(a2, v49, a5).n128_u64[0];
  }
  return result;
}

double __sortOmniLightsOnZAxis(uint64_t a1, __n128 *a2, void *a3, void *a4, __n128 *a5, int a6, double result)
{
  v32[1] = *MEMORY[0x263EF8340];
  if (a6)
  {
    *(double *)v14.i64 = MEMORY[0x270FA5388](a1);
    int v16 = (char *)v32 - v15;
    if (v17 >= 1)
    {
      float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
      v19.i64[0] = 0x8000000080000000;
      v19.i64[1] = 0x8000000080000000;
      uint64_t v20 = v13;
      uint64_t v21 = (float32x4_t *)a2;
      long long v22 = v16;
      do
      {
        float32x4_t v23 = *v21++;
        int8x16_t v24 = (int8x16_t)v23;
        float32x4_t v25 = vmulq_f32(v14, v23);
        int8x16_t v26 = (int8x16_t)vaddq_f32(v18, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))));
        *(float *)v24.i32 = fmaxf(fabsf(*(float *)v26.i32) - v23.f32[3], 0.0);
        *v22++ = vbslq_s8(v19, v24, v26).u32[0];
        --v20;
      }
      while (v20);
    }
    MEMORY[0x270FA5388](v12);
    float v29 = (__int16 *)((char *)v32 - v28);
    uint64_t v30 = 0;
    uint64_t v31 = 2 * a6;
    do
    {
      v29[v30] = v30;
      ++v30;
      v31 -= 2;
    }
    while (v31);
    v32[0] = v27;
    std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>((uint64_t)v32 - v28, (__int16 *)((char *)v32 + 2 * a6 - v28), v32, 126 - 2 * __clz(a6), 1);
    reorder<__C3DNode *>(a3, v29, a6);
    reorder<__C3DNode *>(a4, v29, a6);
    reorder<scn_sphere>(a2, v29, a6);
    *(void *)&uint64_t result = reorder<scn_sphere>(a5, v29, a6).n128_u64[0];
  }
  return result;
}

double __sortProbesByVolume(_OWORD *a1, void *a2, void *a3, int a4)
{
  v24[1] = *MEMORY[0x263EF8340];
  if (a4)
  {
    MEMORY[0x270FA5388](a1);
    uint64_t v11 = (float *)((char *)v24 - v10);
    if (v12 >= 1)
    {
      uint64_t v13 = (float *)a1 + 18;
      uint64_t v14 = v9;
      uint64_t v15 = v11;
      do
      {
        float v16 = *(v13 - 2) * *(v13 - 1);
        float v17 = *v13;
        v13 += 20;
        *v15++ = (float)(v17 * v16) * 8.0;
        --v14;
      }
      while (v14);
    }
    MEMORY[0x270FA5388](v8);
    uint64_t v20 = (__int16 *)((char *)v24 - v19);
    uint64_t v21 = 0;
    uint64_t v22 = 2 * a4;
    do
    {
      v20[v21] = v21;
      ++v21;
      v22 -= 2;
    }
    while (v22);
    v24[0] = v18;
    std::__introsort<std::_ClassicAlgPolicy,__VolumeComp &,short *,false>((uint64_t)v24 - v19, (__int16 *)((char *)v24 + 2 * a4 - v19), v24, 126 - 2 * __clz(a4), 1);
    reorder<__C3DNode *>(a2, v20, a4);
    reorder<__C3DNode *>(a3, v20, a4);
    *(void *)&double result = reorder<scn_obb>(a1, v20, a4).n128_u64[0];
  }
  return result;
}

__n128 C3DSceneComputeViewToCubemapMatrix(__n128 *a1, uint64_t a2)
{
  memset(&v10, 0, sizeof(v10));
  C3DMatrix4x4Invert((simd_float4x4 *)a2, &v10);
  v9.n128_u32[2] = 0;
  v9.n128_u64[0] = 0;
  C3DSceneGetUpAxis(a1, &v9);
  memset(v8, 0, sizeof(v8));
  if (v9.n128_f32[2] == 1.0)
  {
    long long v7 = xmmword_20B5CB820;
    double v4 = 1.57079633;
LABEL_7:
    C3DMatrix4x4MakeAxisAngleRotation(v8, (float32x4_t *)&v7, v4);
    C3DMatrix4x4Mult((uint64_t)&v10, v8, &v10);
    goto LABEL_8;
  }
  if (v9.n128_f32[2] == -1.0)
  {
    long long v7 = xmmword_20B5CB820;
    double v4 = -1.57079633;
    goto LABEL_7;
  }
  if (v9.n128_f32[1] == -1.0)
  {
    long long v7 = xmmword_20B5CB820;
    double v4 = -3.14159265;
    goto LABEL_7;
  }
LABEL_8:
  v10.columns[0].f32[2] = -v10.columns[0].f32[2];
  v10.columns[1].f32[2] = -v10.columns[1].f32[2];
  v10.columns[2].f32[2] = -v10.columns[2].f32[2];
  simd_float4 v5 = v10.columns[1];
  *(simd_float4 *)a2 = v10.columns[0];
  *(simd_float4 *)(a2 + 16) = v5;
  __n128 result = (__n128)v10.columns[3];
  *(simd_float4 *)(a2 + 32) = v10.columns[2];
  *(__n128 *)(a2 + 4_Block_object_dispose(&STACK[0x690], 8) = result;
  return result;
}

__n128 C3DSceneGetUpAxis(__n128 *a1, __n128 *a2)
{
  if (!a1)
  {
    double v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = a1[13];
  *a2 = result;
  return result;
}

__n64 C3DSceneComputeFogParameters(uint64_t a1, float a2)
{
  if (!a1)
  {
    double v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = fmaxf(*(float *)(a1 + 328) * a2, 0.0);
  float v13 = fmaxf(*(float *)(a1 + 332) * a2, 0.0);
  double v14 = v13 + -0.001;
  if (v14 <= v12)
  {
    float v15 = v14;
    float v16 = v15;
  }
  else
  {
    float v16 = v12;
  }
  result.n64_f32[0] = 1.0 / (float)(v13 - v16);
  result.n64_f32[1] = -(float)(result.n64_f32[0] * v16);
  return result;
}

uint64_t C3DMatrix4x4Invert(simd_float4x4 *a1, simd_float4x4 *a2)
{
  *a2 = __invert_f4(*a1);
  return 1;
}

BOOL C3DLightingSystemHasLocalLights(uint64_t a1)
{
  return *(_DWORD *)(a1 + 572) != 0;
}

uint64_t C3DLightingSystemGetAmbientLighting(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t C3DLightingSystemEnumerateSpots(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 76);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 160), *(void *)(result + 224), *(void *)(result + 472));
  }
  return result;
}

uint64_t C3DLightingSystemEnumerateLocalOmnis(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 72);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 152), *(void *)(result + 216), *(void *)(result + 456));
  }
  return result;
}

__n128 C3DEngineContextGetViewportAtIndex(uint64_t a1, unsigned int a2)
{
  if (a2 >= 6)
  {
    double v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetViewportAtIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return *(__n128 *)(a1 + 16 * a2 + 240);
}

float C3DEngineContextGetPointOfViewScale(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 200);
}

unint64_t C3DEngineContextGetEyeMatrix4x4(uint64_t a1, int a2, unsigned int a3)
{
  if (a3 >= 6)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetEyeMatrix4x4_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  return a1 + 384 * a2 + ((unint64_t)a3 << 6) + 480;
}

void ___pathComponentForString_block_invoke()
{
  _pathComponentForString__pathComponents = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 110, MEMORY[0x263EFFF88], 0);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"transform", (const void *)1);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"opacity", (const void *)2);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"hidden", (const void *)3);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"attributes", (const void *)4);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"matrix", (const void *)5);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"translation", (const void *)6);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"position", (const void *)6);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"rotation", (const void *)7);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"orientation", (const void *)0xD);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"scale", (const void *)8);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"eulerAngles", (const void *)0xC);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"quaternion", (const void *)0xD);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"pivot", (const void *)9);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"filters", (const void *)0xA);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"nodes", (const void *)0xB);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"childNodes", (const void *)0xB);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"x", (const void *)0xE);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"y", (const void *)0xF);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"z", (const void *)0x10);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"w", (const void *)0x11);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"(0)", (const void *)0xE);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"(1)", (const void *)0xF);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"(2)", (const void *)0x10);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"(3)", (const void *)0x11);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"r", (const void *)0x12);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"g", (const void *)0x13);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"b", (const void *)0x14);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"a", (const void *)0x15);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m11", (const void *)0x16);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m12", (const void *)0x1A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m13", (const void *)0x1E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m14", (const void *)0x22);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m21", (const void *)0x17);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m22", (const void *)0x1B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m23", (const void *)0x1F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m24", (const void *)0x23);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m31", (const void *)0x18);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m32", (const void *)0x1C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m33", (const void *)0x20);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m34", (const void *)0x24);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m41", (const void *)0x19);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m42", (const void *)0x1D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m43", (const void *)0x21);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"m44", (const void *)0x25);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"camera", (const void *)0x26);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"geometry", (const void *)0x27);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"firstMaterial", (const void *)0x28);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"materials", (const void *)0x29);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"commonProfile", (const void *)0x2A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"diffuse", (const void *)0x2B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"ambient", (const void *)0x2C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"specular", (const void *)0x2D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"emission", (const void *)0x2E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"reflective", (const void *)0x2F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"normal", (const void *)0x30);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"ambientOcclusion", (const void *)0x31);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"selfIllumination", (const void *)0x32);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"metalness", (const void *)0x33);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"roughness", (const void *)0x34);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"selfIlluminationOcclusion", (const void *)0x39);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"clearCoat", (const void *)0x35);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"clearCoatRoughness", (const void *)0x36);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"clearCoatNormal", (const void *)0x37);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"displacement", (const void *)0x38);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"transparent", (const void *)0x3A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"multiply", (const void *)0x3B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"shininess", (const void *)0x3C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"transparency", (const void *)0x3D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"fresnelExponent", (const void *)0x3E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"shaderModifiers", (const void *)0x43);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"doubleSided", (const void *)0x3F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"litPerPixel", (const void *)0x40);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"cullMode", (const void *)0x41);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"lockAmbientWithDiffuse", (const void *)0x42);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"color", (const void *)0x44);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"contents", (const void *)0x45);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"texture", (const void *)0x46);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"image", (const void *)0x47);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"contentsTransform", (const void *)0x48);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"borderColor", (const void *)0x49);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"intensity", (const void *)0x4A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"light", (const void *)0x4B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"shadowColor", (const void *)0x4C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"shadowRadius", (const void *)0x4D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"attenuationStart", (const void *)0x51);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"attenuationEnd", (const void *)0x52);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"attenuationFalloffExponent", (const void *)0x53);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"spotInnerAngle", (const void *)0x54);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"spotOuterAngle", (const void *)0x55);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"spotFalloffExponent", (const void *)0x56);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"weights", (const void *)0x57);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"morpher", (const void *)0x58);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"background", (const void *)0x5B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"environment", (const void *)0x5C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"gobo", (const void *)0x4E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"probeEnvironment", (const void *)0x4F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"ies", (const void *)0x50);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"customProperty", (const void *)0x59);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"animations", (const void *)0x5A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, @"euler", (const void *)0xC);
  CFAllocatorRef v0 = (__CFDictionary *)_pathComponentForString__pathComponents;

  CFDictionaryAddValue(v0, @"axisAngle", (const void *)7);
}

void _C3DResourceCacheResourceWillDie(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
}

void _C3DImageDeleteTextureRawDataIfNeeded(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    CFRelease(*(CFTypeRef *)(v1 + 40));
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
}

id _C3DImageCFFinalize(void *a1)
{
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationImageWillDie", a1, 0, 1u);
  _C3DImageDeleteTextureRawDataIfNeeded((uint64_t)a1);
  uint64_t v3 = (const void *)a1[11];
  if (v3)
  {
    CFRelease(v3);
    a1[11] = 0;
  }
  uint64_t v4 = (const void *)a1[8];
  if (v4)
  {
    CFRelease(v4);
    a1[8] = 0;
  }

  return C3DEntityCFFinalize((uint64_t)a1);
}

void C3DResourceCacheRemoveResource(uint64_t a1, const void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceOrCreateIfNeededForSource_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DResourceCacheCopySourceForResource_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

uint64_t C3DIndexSetGetLastRange(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v1 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v4 = 0;
    return v1[2 * v4];
  }
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(v2 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v1 = (uint64_t *)(v2 + 56);
  uint64_t v4 = v3 - 1;
  return v1[2 * v4];
}

__n128 C3DShapeMeshCreationInitProfile(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(CGPath **)(a1 + 40);
  CFMutableArrayRef Mutable = v4;
  if (!v4)
  {
    CFMutableArrayRef Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, 0.0, 1.0);
    CGPathAddArcToPoint(Mutable, 0, 1.0, 1.0, 1.0, 0.0, 1.0);
  }
  unsigned __int32 v19 = 0;
  unint64_t v18 = 0;
  __n128 v16 = 0u;
  __n128 v17 = 0u;
  uint64_t v6 = (__n128 *)C3DShapeBoundaryMakeWithCGPath(Mutable, &v19, *(float *)(a1 + 4) * 0.1, 1.79769313e308);
  uint64_t v7 = v6;
  if (!v6)
  {
    unint64_t v9 = 0;
    unsigned int v8 = 0;
    unsigned __int32 v10 = 0;
    goto LABEL_16;
  }
  unsigned int v8 = v6->n128_u32[2];
  if (v8 < 2)
  {
    unsigned __int32 v10 = 0;
    unsigned int v8 = 0;
LABEL_9:
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DShapeMeshCreationInitProfile_cold_1(v11);
    }
    unint64_t v9 = 0;
    goto LABEL_12;
  }
  unint64_t v9 = v6->n128_u64[0];
  unsigned __int32 v10 = v6->n128_u32[3];
  __n128 v16 = v6[1];
  __n128 v17 = v6[2];
  unint64_t v18 = v6[3].n128_u64[0];
  if (!v6->n128_u64[0]) {
    goto LABEL_9;
  }
LABEL_12:
  if (*(unsigned char *)(v9 + 72))
  {
    *(unsigned char *)(v9 + 72) = 0;
    *(_OWORD *)(v9 + 16) = *(_OWORD *)(v9 + 32);
    --v10;
  }
  unint64_t v12 = v9 + 80 * (v8 - 1);
  int v14 = *(unsigned __int8 *)(v12 + 72);
  uint64_t v13 = (unsigned char *)(v12 + 72);
  if (v14)
  {
    *uint64_t v13 = 0;
    --v10;
  }
LABEL_16:
  if (!v4) {
    CGPathRelease(Mutable);
  }
  a2[2].n128_u64[0] = v9;
  a2[2].n128_u32[2] = v8;
  a2[2].n128_u32[3] = v10;
  __n128 result = v16;
  a2[3] = v16;
  a2[4] = v17;
  a2[5].n128_u64[0] = v18;
  a2[5].n128_u64[1] = (unint64_t)v7;
  a2[1].n128_u32[3] = v19;
  return result;
}

int32x2_t C3DShapeMeshCreationInitMisc(unsigned int a1, unsigned int a2, uint64_t a3, char a4)
{
  if (a1)
  {
    size_t v8 = 12 * a1;
    *(void *)(a3 + 112) = malloc_type_malloc(v8, 0x10000403E1C8BA9uLL);
    *(void *)(a3 + 120) = malloc_type_malloc(v8, 0x10000403E1C8BA9uLL);
    unint64_t v9 = malloc_type_malloc(8 * a1, 0x100004000313F17uLL);
  }
  else
  {
    unint64_t v9 = 0;
    *(void *)(a3 + 112) = 0;
    *(void *)(a3 + 120) = 0;
  }
  *(void *)(a3 + 104) = v9;
  *(_WORD *)(a3 + 96) = 0;
  if (a2) {
    unsigned __int32 v10 = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
  }
  else {
    unsigned __int32 v10 = 0;
  }
  *(void *)(a3 + 12_Block_object_dispose(&STACK[0x690], 8) = v10;
  *(_WORD *)(a3 + 9_Block_object_dispose(&STACK[0x690], 8) = 0;
  *(_DWORD *)(a3 + 136) = 0;
  *(void *)(a3 + 16_Block_object_dispose(&STACK[0x690], 8) = 0;
  *(_DWORD *)(a3 + 176) = 0;
  *(void *)(a3 + 144) = 0;
  *(void *)(a3 + 152) = 0;
  *(_DWORD *)(a3 + 160) = 0;
  *(void *)(a3 + 184) = 0;
  *(void *)(a3 + 192) = 0;
  *(unsigned char *)(a3 + 24) = a4;
  if (C3DWasLinkedBeforeMajorOSYear2013()) {
    *(unsigned char *)(a3 + 24) = 1;
  }
  *(_OWORD *)a3 = xmmword_20B5CB4F0;
  int32x2_t result = vdup_n_s32(0xC9742400);
  *(int32x2_t *)(a3 + 16) = result;
  return result;
}

void C3DShapeMeshCreationAppendShape(uint64_t a1, uint64_t a2, uint64_t a3, char a4, double a5, double a6)
{
  uint64_t v7 = a2;
  uint64_t v8 = a1;
  int v9 = *(_DWORD *)(a1 + 24);
  v228[0] = MEMORY[0x263EF8330];
  v228[1] = 0x40000000;
  int v229 = __C3DShapeMeshCreationAppendShape_block_invoke;
  int64x2_t v230 = &__block_descriptor_tmp;
  uint64_t v231 = a3;
  char v232 = a4;
  double v10 = *(float *)(a2 + 8);
  if (*(unsigned char *)(a3 + 24) == 1)
  {
    unsigned int v11 = (unsigned __int16)v9;
    *(_DWORD *)(a3 + 136) = (unsigned __int16)v9;
    size_t v12 = 2 * (unsigned __int16)v9;
    *(void *)(a3 + 144) = malloc_type_malloc(v12, 0x1000040BDFB0063uLL);
    if (*(float *)(v7 + 8) == 0.0) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = malloc_type_malloc(v12, 0x1000040BDFB0063uLL);
    }
    int v14 = 0;
  }
  else
  {
    int v14 = *(_DWORD *)(a3 + 136);
    unsigned int v11 = (unsigned __int16)v9;
    unsigned int v15 = v14 + (unsigned __int16)v9;
    *(_DWORD *)(a3 + 136) = v15;
    *(void *)(a3 + 144) = malloc_type_realloc(*(void **)(a3 + 144), 2 * v15, 0x1000040BDFB0063uLL);
    if (*(float *)(v7 + 8) == 0.0) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = malloc_type_realloc(*(void **)(a3 + 152), 2 * *(unsigned int *)(a3 + 136), 0x1000040BDFB0063uLL);
    }
  }
  double v16 = v10 * 0.5;
  *(void *)(a3 + 152) = v13;
  if (v11)
  {
    int v17 = *(_DWORD *)(v7 + 16);
    float v18 = v16;
    uint64_t v20 = *(void *)(a3 + 112);
    uint64_t v19 = *(void *)(a3 + 120);
    uint64_t v21 = *(UInt8 **)(a3 + 144);
    uint64_t v22 = v11;
    unsigned __int16 v23 = *(_WORD *)(a3 + 96);
    v24.f64[0] = a5;
    v24.f64[1] = a6;
    int v25 = v14;
    int8x16_t v26 = *(float64x2_t ***)(v8 + 32);
    do
    {
      uint64_t v27 = v19 + 12 * v23;
      *(void *)uint64_t v27 = 0;
      *(_DWORD *)(v27 + _Block_object_dispose(&STACK[0x690], 8) = 1065353216;
      uint64_t v28 = (float32x2_t *)(v20 + 12 * v23);
      float v29 = *v26;
      if (v17 == 2)
      {
        v30.f32[0] = a5 + v29->f64[0];
        v31.f32[0] = a6 + v29->f64[1];
        v28->i32[0] = v30.i32[0];
        v28->i32[1] = v31.i32[0];
        v28[1].f32[0] = v18;
        v31.f32[1] = v16;
      }
      else
      {
        float32x2_t v30 = vcvt_f32_f64(vaddq_f64(v24, v29[3]));
        float32x2_t *v28 = v30;
        v28[1].f32[0] = v18;
        float32x2_t v31 = *(float32x2_t *)((char *)v28 + 4);
      }
      if (v30.f32[0] >= *(float *)a3) {
        v30.i32[0] = *(_DWORD *)a3;
      }
      *(_DWORD *)a3 = v30.i32[0];
      *(int8x8_t *)(a3 + 4) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a3 + 4), v31), (int8x8_t)v31, *(int8x8_t *)(a3 + 4));
      float v32 = v28[1].f32[0];
      if (v32 <= *(float *)(a3 + 20)) {
        float v32 = *(float *)(a3 + 20);
      }
      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*v28, *(float32x2_t *)(a3 + 12)), (int8x8_t)*v28, *(int8x8_t *)(a3 + 12));
      *(float *)(a3 + 20) = v32;
      *(_WORD *)&v21[2 * v25] = v23;
      unsigned __int16 v23 = *(_WORD *)(a3 + 96) + 1;
      *(_WORD *)(a3 + 96) = v23;
      ++v26;
      ++v25;
      --v22;
    }
    while (v22);
  }
  else
  {
    uint64_t v21 = *(UInt8 **)(a3 + 144);
  }
  v229((uint64_t)v228, 0, *(unsigned int *)(a3 + 136) / 3uLL, v21, *(_DWORD *)(a3 + 136));
  if (*(float *)(v7 + 8) > 0.0)
  {
    if (v11)
    {
      int v33 = *(_DWORD *)(v7 + 16);
      float v34 = v16;
      float v35 = -v34;
      uint64_t v37 = *(void *)(a3 + 112);
      uint64_t v36 = *(void *)(a3 + 120);
      float32x4_t v38 = *(UInt8 **)(a3 + 152);
      uint64_t v39 = v11;
      unsigned __int16 v40 = *(_WORD *)(a3 + 96);
      v41.f64[0] = a5;
      v41.f64[1] = a6;
      unsigned int v42 = *(float64x2_t ***)(v8 + 32);
      do
      {
        uint64_t v43 = v36 + 12 * v40;
        *(void *)uint64_t v43 = 0;
        *(_DWORD *)(v43 + _Block_object_dispose(&STACK[0x690], 8) = -1082130432;
        float32x4_t v44 = (float32x2_t *)(v37 + 12 * v40);
        float v45 = *v42;
        if (v33 == 1)
        {
          v46.f32[0] = a5 + v45->f64[0];
          v47.f32[0] = a6 + v45->f64[1];
          v44->i32[0] = v46.i32[0];
          v44->i32[1] = v47.i32[0];
          v44[1].f32[0] = v35;
          v47.f32[1] = v35;
        }
        else
        {
          float32x2_t v46 = vcvt_f32_f64(vaddq_f64(v41, v45[3]));
          *float32x4_t v44 = v46;
          v44[1].f32[0] = v35;
          float32x2_t v47 = *(float32x2_t *)((char *)v44 + 4);
        }
        if (v46.f32[0] >= *(float *)a3) {
          v46.i32[0] = *(_DWORD *)a3;
        }
        *(_DWORD *)a3 = v46.i32[0];
        *(int8x8_t *)(a3 + 4) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a3 + 4), v47), (int8x8_t)v47, *(int8x8_t *)(a3 + 4));
        float v48 = v44[1].f32[0];
        if (v48 <= *(float *)(a3 + 20)) {
          float v48 = *(float *)(a3 + 20);
        }
        *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*v44, *(float32x2_t *)(a3 + 12)), (int8x8_t)*v44, *(int8x8_t *)(a3 + 12));
        *(float *)(a3 + 20) = v48;
        *(_WORD *)&v38[2 * (v14 - 1 + v39)] = v40;
        unsigned __int16 v40 = *(_WORD *)(a3 + 96) + 1;
        *(_WORD *)(a3 + 96) = v40;
        ++v42;
        --v39;
      }
      while (v39);
    }
    else
    {
      float32x4_t v38 = *(UInt8 **)(a3 + 152);
    }
    v229((uint64_t)v228, 0, *(unsigned int *)(a3 + 136) / 3uLL, v38, *(_DWORD *)(a3 + 136));
  }
  if (v16 > 0.0)
  {
    uint64_t v49 = *(unsigned int *)(v8 + 48);
    if (v49)
    {
      uint64_t v50 = 0;
      int v51 = 0;
      uint64_t v52 = *(void *)(v8 + 40);
      do
      {
        uint64_t v53 = *(unsigned int *)(v52 + 32 * v50 + 8);
        if (v53)
        {
          float32x4_t v54 = (int *)(*(void *)(v52 + 32 * v50) + 8);
          do
          {
            int v55 = *v54;
            v54 += 14;
            v51 += v55;
            --v53;
          }
          while (v53);
        }
        ++v50;
      }
      while (v50 != v49);
    }
    else
    {
      int v51 = 0;
    }
    if (*(unsigned char *)(a3 + 24) == 1)
    {
      *(_DWORD *)(a3 + 160) = 0;
      float32x4_t v56 = (UInt8 *)malloc_type_malloc(2 * (6 * v51), 0x1000040BDFB0063uLL);
    }
    else
    {
      float32x4_t v56 = (UInt8 *)malloc_type_realloc(*(void **)(a3 + 168), 2 * (*(_DWORD *)(a3 + 160) + 6 * v51), 0x1000040BDFB0063uLL);
    }
    unsigned int v57 = v56;
    *(void *)(a3 + 16_Block_object_dispose(&STACK[0x690], 8) = v56;
    unint64_t v58 = *(unsigned int *)(v8 + 48);
    if (v58)
    {
      for (unint64_t i = 0; i < v58; ++i)
      {
        uint64_t v61 = *(void *)(v8 + 40) + 32 * i;
        uint64_t v62 = *(unsigned int *)(v61 + 8);
        if (v62)
        {
          uint64_t v63 = 0;
          uint64_t v64 = *(void *)v61;
          do
          {
            int v65 = (uint64_t *)(v64 + 56 * v63);
            uint64_t v66 = *((unsigned int *)v65 + 2);
            __int16 v67 = *(_WORD *)(a3 + 96);
            if (v66)
            {
              uint64_t v68 = *v65;
              uint64_t v69 = *(void *)(a3 + 112);
              unsigned __int16 v70 = *(_WORD *)(a3 + 96);
              do
              {
                uint64_t v71 = v68 + 80 * (v66 - 1);
                float64x2_t v72 = *(float64x2_t *)(v71 + 16);
                double v73 = *(double *)(v71 + 64);
                float v74 = a5 + *(double *)v71;
                float v75 = a6 + *(double *)(v71 + 8);
                float v76 = v16 - v73;
                int v77 = *(_DWORD *)(v7 + 16);
                if (v77 == 2) {
                  float v76 = v16;
                }
                float v78 = v73 - v16;
                if (v77 == 1)
                {
                  float v60 = v16;
                  float v78 = -v60;
                }
                if (*(unsigned char *)(v71 + 72))
                {
                  unsigned __int16 v79 = v70 + 1;
                  unsigned __int16 v80 = v70 + 2;
                  unint64_t v81 = (float *)(v69 + 12 * v70);
                  *unint64_t v81 = v74;
                  v81[1] = v75;
                  v81[2] = v76;
                  *(_WORD *)(a3 + 96) = v80;
                  long long v82 = (float *)(v69 + 12 * v79);
                  *long long v82 = v74;
                  v82[1] = v75;
                  v82[2] = v78;
                  uint64_t v83 = *(void *)(a3 + 120) + 12 * v80;
                  *(float32x2_t *)(v83 - 12) = vcvt_f32_f64(*(float64x2_t *)(v71 + 32));
                  *(_DWORD *)(v83 - 4) = 0;
                  *(_DWORD *)(v83 - 16) = 0;
                  *(void *)(v83 - 24) = *(void *)(v83 - 12);
                  unsigned __int16 v70 = *(_WORD *)(a3 + 96);
                  uint64_t v69 = *(void *)(a3 + 112);
                }
                uint64_t v84 = *(void *)(a3 + 168);
                uint64_t v85 = *(unsigned int *)(a3 + 160);
                *(_WORD *)(v84 + 2 * v85) = v70;
                *(_WORD *)(v84 + 2 * (v85 + 1)) = *(_WORD *)(a3 + 96) + 1;
                *(_WORD *)(v84 + 2 * (v85 + 2)) = *(_WORD *)(a3 + 96) + 3;
                *(_WORD *)(v84 + 2 * (v85 + 3)) = *(_WORD *)(a3 + 96);
                *(_WORD *)(v84 + 2 * (v85 + 4)) = *(_WORD *)(a3 + 96) + 3;
                __int16 v86 = *(_WORD *)(a3 + 96) + 2;
                *(_DWORD *)(a3 + 160) = v85 + 6;
                *(_WORD *)(v84 + 2 * (v85 + 5)) = v86;
                unsigned __int16 v87 = *(_WORD *)(a3 + 96);
                LOWORD(v84) = v87 + 1;
                uint64_t v88 = (float *)(v69 + 12 * v87);
                float *v88 = v74;
                v88[1] = v75;
                v88[2] = v76;
                v87 += 2;
                *(_WORD *)(a3 + 96) = v87;
                float32x4_t v89 = (float *)(v69 + 12 * (unsigned __int16)v84);
                float *v89 = v74;
                v89[1] = v75;
                v89[2] = v78;
                uint64_t v90 = *(void *)(a3 + 120) + 12 * v87;
                *(float32x2_t *)(v90 - 12) = vcvt_f32_f64(v72);
                *(_DWORD *)(v90 - 4) = 0;
                *(_DWORD *)(v90 - 16) = 0;
                *(void *)(v90 - 24) = *(void *)(v90 - 12);
                uint64_t v69 = *(void *)(a3 + 112);
                unsigned __int16 v70 = *(_WORD *)(a3 + 96);
                uint64_t v91 = v69 + 12 * v70;
                float v92 = *(float *)(v91 - 16);
                if (v92 >= *(float *)(a3 + 8)) {
                  float v92 = *(float *)(a3 + 8);
                }
                float v93 = *(float *)(a3 + 20);
                float32x2_t v94 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v91 - 24)), *(int8x8_t *)(v91 - 24), *(int8x8_t *)a3);
                *(float32x2_t *)a3 = v94;
                *(float *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v92;
                if (*(float *)(v91 - 16) > v93) {
                  float v93 = *(float *)(v91 - 16);
                }
                float32x2_t v95 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v91 - 24), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v91 - 24), *(int8x8_t *)(a3 + 12));
                *(float32x2_t *)(a3 + 12) = v95;
                *(float *)(a3 + 20) = v93;
                int8x8_t v96 = vbsl_s8((int8x8_t)vcgt_f32(v94, *(float32x2_t *)(v91 - 12)), *(int8x8_t *)(v91 - 12), (int8x8_t)v94);
                if (*(float *)(v91 - 4) < v92) {
                  float v92 = *(float *)(v91 - 4);
                }
                *(int8x8_t *)a3 = v96;
                *(float *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v92;
                int8x8_t v97 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v91 - 12), v95), *(int8x8_t *)(v91 - 12), (int8x8_t)v95);
                if (*(float *)(v91 - 4) > v93) {
                  float v93 = *(float *)(v91 - 4);
                }
                *(int8x8_t *)(a3 + 12) = v97;
                *(float *)(a3 + 20) = v93;
                --v66;
              }
              while (v66);
              unsigned int v57 = *(UInt8 **)(a3 + 168);
            }
            int v98 = *(_DWORD *)(a3 + 160);
            *(_WORD *)&v57[2 * (v98 - 1)] = v67;
            __int16 v99 = v67 + 1;
            *(_WORD *)&v57[2 * (v98 - 4)] = v99;
            *(_WORD *)&v57[2 * (v98 - 2)] = v99;
            ++v63;
          }
          while (v63 != v62);
          unint64_t v58 = *(unsigned int *)(v8 + 48);
        }
      }
    }
    v229((uint64_t)v228, 0, *(unsigned int *)(a3 + 160) / 3uLL, v57, *(_DWORD *)(a3 + 160));
  }
  if (*(float *)(v7 + 12) > 0.0)
  {
    uint64_t v100 = *(unsigned int *)(v8 + 48);
    if (v100)
    {
      uint64_t v101 = 0;
      int v102 = 0;
      uint64_t v103 = *(void *)(v8 + 40);
      do
      {
        uint64_t v104 = *(unsigned int *)(v103 + 32 * v101 + 8);
        if (v104)
        {
          float32x4_t v105 = (int *)(*(void *)(v103 + 32 * v101) + 8);
          do
          {
            int v106 = *v105;
            v105 += 14;
            v102 += v106;
            --v104;
          }
          while (v104);
        }
        ++v101;
      }
      while (v101 != v100);
    }
    else
    {
      int v102 = 0;
    }
    if (*(unsigned char *)(a3 + 24) == 1)
    {
      unsigned int v107 = (6 * *(_DWORD *)(a3 + 40) - 6) * v102;
      *(_DWORD *)(a3 + 176) = v107;
      *(void *)(a3 + 184) = malloc_type_malloc(2 * v107, 0x1000040BDFB0063uLL);
      uint64_t v108 = malloc_type_malloc(2 * *(unsigned int *)(a3 + 176), 0x1000040BDFB0063uLL);
      int v109 = 0;
    }
    else
    {
      int v109 = *(_DWORD *)(a3 + 176);
      unsigned int v110 = v109 + (6 * *(_DWORD *)(a3 + 40) - 6) * v102;
      *(_DWORD *)(a3 + 176) = v110;
      *(void *)(a3 + 184) = malloc_type_realloc(*(void **)(a3 + 184), 2 * v110, 0x1000040BDFB0063uLL);
      uint64_t v108 = malloc_type_realloc(*(void **)(a3 + 192), 2 * *(unsigned int *)(a3 + 176), 0x1000040BDFB0063uLL);
    }
    *(void *)(a3 + 192) = v108;
    v221[0] = MEMORY[0x263EF8330];
    v221[1] = 0x40000000;
    v222 = __C3DShapeMeshCreationAppendShape_block_invoke_2;
    uint64_t v223 = &__block_descriptor_tmp_3;
    uint64_t v224 = a3;
    double v225 = a5;
    double v226 = a6;
    double v227 = v16;
    uint64_t v185 = v8;
    if (*(_DWORD *)(v7 + 16) == 2)
    {
      free(*(void **)(a3 + 184));
    }
    else
    {
      uint64_t v184 = v7;
      unint64_t v111 = *(unsigned int *)(v8 + 48);
      if (v111)
      {
        unint64_t v112 = 0;
        unsigned __int16 v113 = 0;
        do
        {
          uint64_t v114 = *(void *)(v185 + 40) + 32 * v112;
          uint64_t v190 = *(unsigned int *)(v114 + 8);
          if (v190)
          {
            uint64_t v115 = 0;
            uint64_t v186 = *(void *)v114;
            unint64_t v188 = v112;
            LODWORD(v116) = *(_DWORD *)(a3 + 40);
            do
            {
              if (v116)
              {
                uint64_t v117 = 0;
                uint64_t v192 = v115;
                float32x4_t v118 = (uint64_t *)(v186 + 56 * v115);
                uint64_t v119 = *v118;
                uint64_t v120 = *((unsigned int *)v118 + 2);
                int v121 = *((_DWORD *)v118 + 3);
                uint64_t v203 = v120;
                do
                {
                  uint64_t v122 = *(void *)(a3 + 32) + 80 * v117;
                  double v123 = *(double *)v122;
                  double v124 = *(double *)(v122 + 8);
                  uint64_t v206 = v117;
                  double v198 = *(double *)(v122 + 40);
                  double v200 = *(double *)(v122 + 32);
                  __int16 v194 = *(_WORD *)(a3 + 96);
                  char v196 = *(unsigned char *)(v122 + 72);
                  if (v120)
                  {
                    double v126 = *(double *)(v122 + 16);
                    double v125 = *(double *)(v122 + 24);
                    do
                    {
                      int v127 = (long long *)(v119 + 80 * (v120 - 1));
                      long long v220 = *v127;
                      double v128 = *((double *)v127 + 2);
                      double v129 = *((double *)v127 + 3);
                      double v130 = *((double *)v127 + 4);
                      double v131 = *((double *)v127 + 5);
                      long long v218 = v127[3];
                      uint64_t v219 = *((void *)v127 + 8);
                      char v132 = *((unsigned char *)v127 + 72);
                      v217[0] = *(_DWORD *)((char *)v127 + 73);
                      *(_DWORD *)((char *)v217 + 3) = *((_DWORD *)v127 + 19);
                      if (v132)
                      {
                        long long v208 = v220;
                        double v209 = v128;
                        double v210 = v129;
                        double v211 = v130;
                        double v212 = v131;
                        long long v213 = v218;
                        uint64_t v214 = v219;
                        char v215 = v132;
                        v216[0] = v217[0];
                        *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                        v222((uint64_t)v221, (float64x2_t *)&v208, v130, v131, 1.0, v123, v124, v126, v125);
                      }
                      if (v206)
                      {
                        uint64_t v133 = *(void *)(a3 + 184);
                        *(_WORD *)(v133 + 2 * (v109 + v113)) = *(_WORD *)(a3 + 96);
                        *(_WORD *)(v133 + 2 * (v109 + (unsigned __int16)(v113 + 1))) = *(_WORD *)(a3 + 96) - v121;
                        *(_WORD *)(v133 + 2 * (v109 + (unsigned __int16)(v113 + 2))) = *(_WORD *)(a3 + 96) - v121 + 1;
                        *(_WORD *)(v133 + 2 * (v109 + (unsigned __int16)(v113 + 3))) = *(_WORD *)(a3 + 96);
                        unsigned __int16 v134 = v113 + 5;
                        *(_WORD *)(v133 + 2 * (v109 + (unsigned __int16)(v113 + 4))) = *(_WORD *)(a3 + 96) - v121 + 1;
                        v113 += 6;
                        *(_WORD *)(v133 + 2 * (v109 + v134)) = *(_WORD *)(a3 + 96) + 1;
                      }
                      long long v208 = v220;
                      double v209 = v128;
                      double v210 = v129;
                      double v211 = v130;
                      double v212 = v131;
                      long long v213 = v218;
                      uint64_t v214 = v219;
                      char v215 = v132;
                      v216[0] = v217[0];
                      *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                      v222((uint64_t)v221, (float64x2_t *)&v208, v128, v129, 1.0, v123, v124, v126, v125);
                      uint64_t v135 = *(void *)(a3 + 112) + 12 * *(unsigned __int16 *)(a3 + 96);
                      float v136 = *(float *)(v135 - 4);
                      if (v136 >= *(float *)(a3 + 8)) {
                        float v136 = *(float *)(a3 + 8);
                      }
                      *(int8x8_t *)a3 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v135 - 12)), *(int8x8_t *)(v135 - 12), *(int8x8_t *)a3);
                      *(float *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v136;
                      float v137 = *(float *)(v135 - 4);
                      if (v137 <= *(float *)(a3 + 20)) {
                        float v137 = *(float *)(a3 + 20);
                      }
                      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v135 - 12), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v135 - 12), *(int8x8_t *)(a3 + 12));
                      *(float *)(a3 + 20) = v137;
                      --v120;
                    }
                    while (v120);
                  }
                  if (v206)
                  {
                    uint64_t v138 = *(void *)(a3 + 184);
                    int v139 = v109 + v113;
                    *(_WORD *)(v138 + 2 * (v139 - 1)) = v194;
                    *(_WORD *)(v138 + 2 * (v139 - 4)) = v194 - v121;
                    *(_WORD *)(v138 + 2 * (v139 - 2)) = v194 - v121;
                  }
                  if ((v196 & 1) != 0 && v203)
                  {
                    uint64_t v140 = v203;
                    do
                    {
                      __n128 v141 = (long long *)(v119 + 80 * (v140 - 1));
                      long long v220 = *v141;
                      double v142 = *((double *)v141 + 2);
                      double v143 = *((double *)v141 + 3);
                      double v144 = *((double *)v141 + 4);
                      double v145 = *((double *)v141 + 5);
                      long long v218 = v141[3];
                      uint64_t v219 = *((void *)v141 + 8);
                      char v146 = *((unsigned char *)v141 + 72);
                      v217[0] = *(_DWORD *)((char *)v141 + 73);
                      *(_DWORD *)((char *)v217 + 3) = *((_DWORD *)v141 + 19);
                      simd_float4 v147 = v222;
                      if (v146)
                      {
                        long long v208 = v220;
                        double v209 = v142;
                        double v210 = v143;
                        double v211 = v144;
                        double v212 = v145;
                        long long v213 = v218;
                        uint64_t v214 = v219;
                        char v215 = v146;
                        v216[0] = v217[0];
                        *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                        v222((uint64_t)v221, (float64x2_t *)&v208, v144, v145, 1.0, v123, v124, v200, v198);
                        simd_float4 v147 = v222;
                      }
                      long long v208 = v220;
                      double v209 = v142;
                      double v210 = v143;
                      double v211 = v144;
                      double v212 = v145;
                      long long v213 = v218;
                      uint64_t v214 = v219;
                      char v215 = v146;
                      v216[0] = v217[0];
                      *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                      v147((uint64_t)v221, (float64x2_t *)&v208, v142, v143, 1.0, v123, v124, v200, v198);
                      --v140;
                    }
                    while (v140);
                  }
                  uint64_t v117 = v206 + 1;
                  unint64_t v116 = *(unsigned int *)(a3 + 40);
                  uint64_t v120 = v203;
                }
                while (v206 + 1 < v116);
                unint64_t v112 = v188;
                uint64_t v115 = v192;
              }
              ++v115;
            }
            while (v115 != v190);
            unint64_t v111 = *(unsigned int *)(v185 + 48);
          }
          ++v112;
        }
        while (v112 < v111);
      }
      v229((uint64_t)v228, 0, *(unsigned int *)(a3 + 176) / 3uLL, *(UInt8 **)(a3 + 184), *(_DWORD *)(a3 + 176));
      uint64_t v8 = v185;
      uint64_t v7 = v184;
    }
    if (*(_DWORD *)(v7 + 16) == 1)
    {
      free(*(void **)(a3 + 192));
    }
    else
    {
      unint64_t v148 = *(unsigned int *)(v8 + 48);
      if (v148)
      {
        unint64_t v149 = 0;
        unsigned __int16 v150 = 0;
        do
        {
          uint64_t v151 = *(void *)(v185 + 40) + 32 * v149;
          uint64_t v191 = *(unsigned int *)(v151 + 8);
          if (v191)
          {
            uint64_t v152 = 0;
            uint64_t v187 = *(void *)v151;
            unint64_t v189 = v149;
            LODWORD(v153) = *(_DWORD *)(a3 + 40);
            do
            {
              if (v153)
              {
                uint64_t v154 = 0;
                uint64_t v193 = v152;
                simd_float4 v155 = (uint64_t *)(v187 + 56 * v152);
                uint64_t v156 = *v155;
                uint64_t v157 = *((unsigned int *)v155 + 2);
                int v158 = *((_DWORD *)v155 + 3);
                uint64_t v204 = v157;
                do
                {
                  uint64_t v159 = *(void *)(a3 + 32) + 80 * v154;
                  double v160 = *(double *)v159;
                  double v161 = *(double *)(v159 + 8);
                  uint64_t v207 = v154;
                  double v199 = *(double *)(v159 + 40);
                  double v201 = *(double *)(v159 + 32);
                  __int16 v195 = *(_WORD *)(a3 + 96);
                  char v197 = *(unsigned char *)(v159 + 72);
                  if (v157)
                  {
                    double v163 = *(double *)(v159 + 16);
                    double v162 = *(double *)(v159 + 24);
                    do
                    {
                      uint64_t v164 = (long long *)(v156 + 80 * (v157 - 1));
                      long long v220 = *v164;
                      double v165 = *((double *)v164 + 2);
                      double v166 = *((double *)v164 + 3);
                      double v167 = *((double *)v164 + 4);
                      double v168 = *((double *)v164 + 5);
                      long long v218 = v164[3];
                      uint64_t v219 = *((void *)v164 + 8);
                      char v169 = *((unsigned char *)v164 + 72);
                      v217[0] = *(_DWORD *)((char *)v164 + 73);
                      *(_DWORD *)((char *)v217 + 3) = *((_DWORD *)v164 + 19);
                      if (v169)
                      {
                        long long v208 = v220;
                        double v209 = v165;
                        double v210 = v166;
                        double v211 = v167;
                        double v212 = v168;
                        long long v213 = v218;
                        uint64_t v214 = v219;
                        char v215 = v169;
                        v216[0] = v217[0];
                        *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                        v222((uint64_t)v221, (float64x2_t *)&v208, v167, v168, -1.0, v160, v161, v163, v162);
                      }
                      if (v207)
                      {
                        uint64_t v170 = *(void *)(a3 + 192);
                        *(_WORD *)(v170 + 2 * (v109 + v150)) = *(_WORD *)(a3 + 96);
                        *(_WORD *)(v170 + 2 * (v109 + (unsigned __int16)(v150 + 1))) = *(_WORD *)(a3 + 96) - v158 + 1;
                        *(_WORD *)(v170 + 2 * (v109 + (unsigned __int16)(v150 + 2))) = *(_WORD *)(a3 + 96) - v158;
                        *(_WORD *)(v170 + 2 * (v109 + (unsigned __int16)(v150 + 3))) = *(_WORD *)(a3 + 96);
                        unsigned __int16 v171 = v150 + 5;
                        *(_WORD *)(v170 + 2 * (v109 + (unsigned __int16)(v150 + 4))) = *(_WORD *)(a3 + 96) + 1;
                        v150 += 6;
                        *(_WORD *)(v170 + 2 * (v109 + v171)) = *(_WORD *)(a3 + 96) - v158 + 1;
                      }
                      long long v208 = v220;
                      double v209 = v165;
                      double v210 = v166;
                      double v211 = v167;
                      double v212 = v168;
                      long long v213 = v218;
                      uint64_t v214 = v219;
                      char v215 = v169;
                      v216[0] = v217[0];
                      *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                      v222((uint64_t)v221, (float64x2_t *)&v208, v165, v166, -1.0, v160, v161, v163, v162);
                      uint64_t v172 = *(void *)(a3 + 112) + 12 * *(unsigned __int16 *)(a3 + 96);
                      float v173 = *(float *)(v172 - 4);
                      if (v173 >= *(float *)(a3 + 8)) {
                        float v173 = *(float *)(a3 + 8);
                      }
                      *(int8x8_t *)a3 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v172 - 12)), *(int8x8_t *)(v172 - 12), *(int8x8_t *)a3);
                      *(float *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v173;
                      float v174 = *(float *)(v172 - 4);
                      if (v174 <= *(float *)(a3 + 20)) {
                        float v174 = *(float *)(a3 + 20);
                      }
                      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v172 - 12), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v172 - 12), *(int8x8_t *)(a3 + 12));
                      *(float *)(a3 + 20) = v174;
                      --v157;
                    }
                    while (v157);
                  }
                  if (v207)
                  {
                    uint64_t v175 = *(void *)(a3 + 192);
                    int v176 = v109 + v150;
                    *(_WORD *)(v175 + 2 * (v176 - 2)) = v195;
                    *(_WORD *)(v175 + 2 * (v176 - 1)) = v195 - v158;
                    *(_WORD *)(v175 + 2 * (v176 - 5)) = v195 - v158;
                  }
                  if ((v197 & 1) != 0 && v204)
                  {
                    uint64_t v177 = v204;
                    do
                    {
                      float32x4_t v178 = (long long *)(v156 + 80 * (v177 - 1));
                      long long v220 = *v178;
                      double v179 = *((double *)v178 + 2);
                      double v180 = *((double *)v178 + 3);
                      double v181 = *((double *)v178 + 4);
                      double v182 = *((double *)v178 + 5);
                      long long v218 = v178[3];
                      uint64_t v219 = *((void *)v178 + 8);
                      char v183 = *((unsigned char *)v178 + 72);
                      v217[0] = *(_DWORD *)((char *)v178 + 73);
                      *(_DWORD *)((char *)v217 + 3) = *((_DWORD *)v178 + 19);
                      if (v183)
                      {
                        long long v208 = v220;
                        double v209 = v179;
                        double v210 = v180;
                        double v211 = v181;
                        double v212 = v182;
                        long long v213 = v218;
                        uint64_t v214 = v219;
                        char v215 = v183;
                        v216[0] = v217[0];
                        *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                        v222((uint64_t)v221, (float64x2_t *)&v208, v181, v182, -1.0, v160, v161, v201, v199);
                      }
                      long long v208 = v220;
                      double v209 = v179;
                      double v210 = v180;
                      double v211 = v181;
                      double v212 = v182;
                      long long v213 = v218;
                      uint64_t v214 = v219;
                      char v215 = v183;
                      v216[0] = v217[0];
                      *(_DWORD *)((char *)v216 + 3) = *(_DWORD *)((char *)v217 + 3);
                      v222((uint64_t)v221, (float64x2_t *)&v208, v179, v180, -1.0, v160, v161, v201, v199);
                      --v177;
                    }
                    while (v177);
                  }
                  uint64_t v154 = v207 + 1;
                  unint64_t v153 = *(unsigned int *)(a3 + 40);
                  uint64_t v157 = v204;
                }
                while (v207 + 1 < v153);
                unint64_t v149 = v189;
                uint64_t v152 = v193;
              }
              ++v152;
            }
            while (v152 != v191);
            unint64_t v148 = *(unsigned int *)(v185 + 48);
          }
          ++v149;
        }
        while (v149 < v148);
      }
      v229((uint64_t)v228, 0, *(unsigned int *)(a3 + 176) / 3uLL, *(UInt8 **)(a3 + 192), *(_DWORD *)(a3 + 176));
    }
  }
}

void __C3DShapeMeshCreationAppendShape_block_invoke(uint64_t a1, char a2, int a3, UInt8 *bytes, unsigned int a5)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 24) || *(unsigned char *)(a1 + 40))
  {
    CFDataRef v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 2 * a5);
    uint64_t v10 = C3DMeshElementCreate();
    C3DMeshElementInit(v10, a2, a3, v9, 2);
    if (v9) {
      CFRelease(v9);
    }
    free(bytes);
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(v11 + 128);
    uint64_t v13 = *(unsigned __int16 *)(v11 + 98);
    *(_WORD *)(v11 + 9_Block_object_dispose(&STACK[0x690], 8) = v13 + 1;
    *(void *)(v12 + 8 * v13) = v10;
  }
}

float __C3DShapeMeshCreationAppendShape_block_invoke_2(uint64_t a1, float64x2_t *a2, double a3, double a4, float a5, double a6, double a7, double a8, double a9)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(unsigned __int16 *)(v9 + 96);
  uint64_t v11 = (float32x2_t *)(*(void *)(v9 + 112) + 12 * v10);
  uint64_t v12 = (float *)(*(void *)(v9 + 120) + 12 * v10);
  double v13 = a2[4].f64[0];
  float v14 = v13;
  *(float *)&double v13 = *(double *)(a1 + 56) - v13;
  float v15 = *(float *)&v13 + a6 * v14;
  *uint64_t v11 = vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(vaddq_f64(*(float64x2_t *)(a1 + 40), *a2), a7), vaddq_f64(a2[3], *(float64x2_t *)(a1 + 40)), 1.0 - a7));
  v11[1].f32[0] = v15 * a5;
  float result = a3 * a9;
  float v17 = a4 * a9;
  float v18 = a8 * a5;
  *uint64_t v12 = result;
  v12[1] = v17;
  void v12[2] = v18;
  *(_WORD *)(v9 + 96) = v10 + 1;
  return result;
}

uint64_t C3DShapeMeshCreationCreateMesh(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = (long long *)(*(void *)(a1 + 88) + v2);
      long long v5 = *v4;
      long long v6 = v4[1];
      long long v7 = v4[2];
      uint64_t v53 = *((void *)v4 + 6);
      *(_OWORD *)CFTypeRef cf = v6;
      long long v52 = v7;
      *(_OWORD *)values = v5;
      C3DShapeBoundaryDestroy(values);
      ++v3;
      v2 += 56;
    }
    while (v3 < *(unsigned int *)(a1 + 28));
  }
  uint64_t v8 = *(void **)(a1 + 88);
  if (v8) {
    free(v8);
  }
  uint64_t v9 = *(unsigned __int16 *)(a1 + 96);
  if (*(_WORD *)(a1 + 96))
  {
    float v10 = *(float *)a1;
    float v11 = *(float *)(a1 + 4);
    float v12 = *(float *)(a1 + 8);
    float v13 = *(float *)(a1 + 12) - *(float *)a1;
    float v14 = *(float *)(a1 + 16) - v11;
    float v15 = *(float *)(a1 + 20) - v12;
    double v16 = (float *)(*(void *)(a1 + 112) + 8);
    float v17 = (float *)(*(void *)(a1 + 104) + 4);
    float v18 = (float *)(*(void *)(a1 + 120) + 4);
    uint64_t v19 = *(unsigned __int16 *)(a1 + 96);
    do
    {
      float v20 = *(v16 - 2);
      float v21 = *(v16 - 1);
      float v22 = *v16;
      float v23 = *(v18 - 1);
      float v24 = v18[1];
      float v25 = fabsf(v23);
      float v26 = fabsf(*v18);
      float v27 = fabsf(v24);
      if (v25 <= v26)
      {
        float v32 = (float)(v20 - v10) / v13;
        if (v24 > 0.0) {
          float v33 = (float)(v20 - v10) / v13;
        }
        else {
          float v33 = 1.0 - v32;
        }
        float v31 = (float)(v22 - v12) / v15;
        if (*v18 <= 0.0) {
          float v32 = 1.0 - v32;
        }
        BOOL v34 = v26 <= v27;
        if (v26 > v27) {
          float v30 = v32;
        }
        else {
          float v30 = v33;
        }
        if (v34) {
          float v31 = 1.0 - (float)((float)(v21 - v11) / v14);
        }
      }
      else
      {
        float v28 = (float)(v20 - v10) / v13;
        if (v24 <= 0.0) {
          float v28 = 1.0 - v28;
        }
        float v29 = (float)(v22 - v12) / v15;
        if (v23 <= 0.0) {
          float v29 = 1.0 - v29;
        }
        if (v25 > v27) {
          float v30 = v29;
        }
        else {
          float v30 = v28;
        }
        float v31 = 1.0 - (float)((float)(v21 - v11) / v14);
      }
      *(v17 - 1) = v30;
      float *v17 = v31;
      v16 += 3;
      v17 += 2;
      v18 += 3;
      --v19;
    }
    while (v19);
    CFIndex v35 = 12 * v9;
  }
  else
  {
    CFIndex v35 = 0;
  }
  CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], v35);
  CFDataAppendBytes(Mutable, *(const UInt8 **)(a1 + 112), 12 * *(unsigned __int16 *)(a1 + 96));
  values[0] = (void *)C3DMeshSourceCreate(Mutable, 0, *(unsigned __int16 *)(a1 + 96), 3, 1);
  if (Mutable) {
    CFRelease(Mutable);
  }
  float32x4_t v38 = CFDataCreateMutable(v36, 12 * *(unsigned __int16 *)(a1 + 96));
  CFDataAppendBytes(v38, *(const UInt8 **)(a1 + 120), 12 * *(unsigned __int16 *)(a1 + 96));
  values[1] = (void *)C3DMeshSourceCreate(v38, 1, *(unsigned __int16 *)(a1 + 96), 3, 1);
  if (v38) {
    CFRelease(v38);
  }
  uint64_t v39 = CFDataCreateMutable(v36, 8 * *(unsigned __int16 *)(a1 + 96));
  CFDataAppendBytes(v39, *(const UInt8 **)(a1 + 104), 8 * *(unsigned __int16 *)(a1 + 96));
  cf[0] = (CFTypeRef)C3DMeshSourceCreate(v39, 3, *(unsigned __int16 *)(a1 + 96), 2, 1);
  if (v39) {
    CFRelease(v39);
  }
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 104));
  char v49 = 0;
  __int16 v48 = 0;
  unsigned __int16 v40 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  CFArrayRef v41 = CFArrayCreate(v36, (const void **)values, 3, MEMORY[0x263EFFF70]);
  CFArrayRef v42 = CFArrayCreate(v36, *(const void ***)(a1 + 128), *(unsigned __int16 *)(a1 + 98), v40);
  unsigned int v43 = *(unsigned __int16 *)(a1 + 98);
  if (*(_WORD *)(a1 + 98))
  {
    unint64_t v44 = 0;
    do
    {
      float v45 = *(const void **)(*(void *)(a1 + 128) + 8 * v44);
      if (v45)
      {
        CFRelease(v45);
        *(void *)(*(void *)(a1 + 128) + 8 * v44) = 0;
        unsigned int v43 = *(unsigned __int16 *)(a1 + 98);
      }
      ++v44;
    }
    while (v44 < v43);
  }
  free(*(void **)(a1 + 128));
  uint64_t v46 = C3DMeshCreateWithMeshSourcesAndMeshElements(v41, v42, (uint64_t)&v48);
  if (v42) {
    CFRelease(v42);
  }
  if (v41) {
    CFRelease(v41);
  }
  if (values[0])
  {
    CFRelease(values[0]);
    values[0] = 0;
  }
  if (values[1])
  {
    CFRelease(values[1]);
    values[1] = 0;
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v46;
}

uint64_t C3DMeshCreateShape(uint64_t a1, long long *a2)
{
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v4 = a2[1];
  long long v19 = *a2;
  long long v20 = v4;
  long long v21 = a2[2];
  uint64_t v22 = *((void *)a2 + 6);
  C3DShapeMeshCreationInitProfile((uint64_t)&v19, v23);
  if (*((float *)a2 + 3) <= 0.0)
  {
    int v6 = 0;
  }
  else
  {
    int v5 = *((_DWORD *)a2 + 4);
    if (v5 == 2) {
      int v6 = 1;
    }
    else {
      int v6 = (v5 != 1) + 1;
    }
  }
  float v7 = *((float *)a2 + 2);
  unsigned int v8 = *(_DWORD *)(a1 + 24) << (v7 > 0.0);
  if (v7 <= 0.0) {
    unsigned int v9 = v6 + 1;
  }
  else {
    unsigned int v9 = v6 + 3;
  }
  uint64_t v10 = *(unsigned int *)(a1 + 48);
  if (v10)
  {
    uint64_t v11 = 0;
    int v12 = HIDWORD(v24) * v6 + 2 * (v7 > 0.0);
    do
    {
      uint64_t v13 = *(void *)(a1 + 40) + 32 * v11;
      uint64_t v14 = *(unsigned int *)(v13 + 8);
      if (v14)
      {
        float v15 = (int *)(*(void *)v13 + 12);
        do
        {
          int v16 = *v15;
          v15 += 14;
          v8 += v12 * v16;
          --v14;
        }
        while (v14);
      }
      ++v11;
    }
    while (v11 != v10);
  }
  C3DShapeMeshCreationInitMisc(v8, v9, (uint64_t)v23, 0);
  long long v17 = a2[1];
  long long v19 = *a2;
  long long v20 = v17;
  long long v21 = a2[2];
  uint64_t v22 = *((void *)a2 + 6);
  C3DShapeMeshCreationAppendShape(a1, (uint64_t)&v19, (uint64_t)v23, 1, *MEMORY[0x263F00148], *(double *)(MEMORY[0x263F00148] + 8));
  uint64_t result = C3DShapeMeshCreationCreateMesh((uint64_t)v23);
  if (!result) {
    return C3DMeshCreate();
  }
  return result;
}

uint64_t C3DMeshCreateText(uint64_t a1, long long *a2, uint64_t a3, float64_t a4, float64_t a5)
{
  if (a1)
  {
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    memset(v51, 0, sizeof(v51));
    long long v7 = a2[1];
    long long v47 = *a2;
    long long v48 = v7;
    long long v49 = a2[2];
    uint64_t v50 = *((void *)a2 + 6);
    C3DShapeMeshCreationInitProfile((uint64_t)&v47, v51);
    float v8 = *((float *)a2 + 2);
    float v9 = *((float *)a2 + 3);
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 24)) < 1)
    {
      unsigned int v11 = 0;
      unsigned int v10 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      CFIndex v12 = 0;
      int v13 = v8 > 0.0;
      int v14 = 2 * (v9 > 0.0);
      if (v8 > 0.0) {
        int v15 = v14 + 3;
      }
      else {
        int v15 = v14 + 1;
      }
      int v16 = HIDWORD(v52) * v14 + 2 * v13;
      do
      {
        CFStringRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v12);
        if (C3DTextLineGetGlyphCount((CFIndex)ValueAtIndex))
        {
          CFIndex v18 = 0;
          do
          {
            GlyphAtunsigned int Index = C3DTextLineGetGlyphAtIndex(ValueAtIndex, v18);
            v10 += *((_DWORD *)GlyphAtIndex + 6) << v13;
            uint64_t v20 = *((unsigned int *)GlyphAtIndex + 12);
            if (v20)
            {
              for (uint64_t i = 0; i != v20; ++i)
              {
                uint64_t v22 = (uint64_t)GlyphAtIndex[5] + 32 * i;
                uint64_t v23 = *(unsigned int *)(v22 + 8);
                if (v23)
                {
                  long long v24 = (int *)(*(void *)v22 + 12);
                  do
                  {
                    int v25 = *v24;
                    v24 += 14;
                    v10 += v16 * v25;
                    --v23;
                  }
                  while (v23);
                }
              }
            }
            v11 += v15;
            CFIndex v18 = (v18 + 1);
          }
          while (v18 < C3DTextLineGetGlyphCount((CFIndex)ValueAtIndex));
        }
        ++v12;
      }
      while (v12 < CFArrayGetCount(*(CFArrayRef *)(a1 + 24)));
    }
    C3DShapeMeshCreationInitMisc(v10, v11, (uint64_t)v51, *(unsigned char *)(a3 + 34));
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    long long v29 = (CGPoint *)malloc_type_malloc(16 * Count, 0x1000040451B5BE8uLL);
    v63.location = 0;
    v63.CFIndex length = 0;
    CTFrameGetLineOrigins(*(CTFrameRef *)(a1 + 16), v63, v29);
    CFIndex v44 = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    if (v44 >= 1)
    {
      CFIndex v30 = 0;
      v31.f64[0] = a4;
      v31.f64[1] = a5;
      float64x2_t v46 = v31;
      do
      {
        long long v32 = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v30);
        GlyphCFIndex Count = C3DTextLineGetGlyphCount((CFIndex)v32);
        uint64_t v34 = (float64x2_t *)malloc_type_malloc(16 * GlyphCount, 0x1000040451B5BE8uLL);
        C3DTextLineGetAdvances((uint64_t)v32, (uint64_t)v34, GlyphCount, v35);
        if (GlyphCount)
        {
          for (CFIndex j = 0; j != GlyphCount; ++j)
          {
            uint64_t v37 = C3DTextLineGetGlyphAtIndex(v32, j);
            char v39 = v30 == v44 - 1 && GlyphCount - 1 == j;
            float64x2_t v40 = vaddq_f64(vaddq_f64(v46, (float64x2_t)v29[v30]), v34[j]);
            long long v41 = a2[1];
            long long v47 = *a2;
            long long v48 = v41;
            long long v49 = a2[2];
            uint64_t v50 = *((void *)a2 + 6);
            C3DShapeMeshCreationAppendShape((uint64_t)v37, (uint64_t)&v47, (uint64_t)v51, v39, v40.f64[0], v40.f64[1]);
          }
        }
        free(v34);
        ++v30;
      }
      while (v30 != v44);
    }
    free(v29);
    uint64_t result = C3DShapeMeshCreationCreateMesh((uint64_t)v51);
    if (!result) {
      return C3DMeshCreate();
    }
  }
  else
  {
    long long v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      C3DMeshCreateText_cold_1(v26);
    }
    return 0;
  }
  return result;
}

const void *C3DKeyValueStoreGetValueForKey(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
}

void C3DKeyValueStoreResetValueForKey(uint64_t a1, const void *a2)
{
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  if (Value)
  {
    int v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == C3DValueGetTypeID())
    {
      int v7 = *((unsigned __int16 *)v5 + 8);
      float v8 = (void *)v5[3];
      if (v7 == 11)
      {
        C3DMatrix4x4MakeIdentity(v5[3]);
      }
      else
      {
        uint64_t v9 = C3DSizeOfBaseType((__int16)v7);
        bzero(v8, v5[4] * v9);
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), a2);
    }
    ++*(_DWORD *)(a1 + 72);
  }
}

uint64_t C3DKeyValueStoreGetTimestamp(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t C3DKeyValueStoreEnumerate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 64);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  _OWORD v4[2] = __C3DKeyValueStoreEnumerate_block_invoke;
  v4[3] = &unk_264004058;
  _OWORD v4[4] = a2;
  return [v2 enumerateKeysAndObjectsUsingBlock:v4];
}

uint64_t __C3DKeyValueStoreEnumerate_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __C3DKeyValueStoreEnumerateBySortingKeys_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id _C3DKeyValueStoreCFFinalize(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 64));

  return C3DEntityCFFinalize(a1);
}

CFStringRef _C3DKeyValueStoreCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DKeyValueStore>");
}

CFStringRef _C3DKeyValueStoreCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DKeyValueStore>");
}

void *_C3DKeyValueStoreSetValue(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  uint64_t result = memcpy(__dst, __src, __n);
  ++*(_DWORD *)(a1 + 72);
  return result;
}

BOOL std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1) {
LABEL_10:
    }
      abort();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void _C3DSceneSourceCFFinalize(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[2];
    if (v2) {
      CFRelease(v2);
    }
    unint64_t v3 = (const void *)a1[3];
    if (v3) {
      CFRelease(v3);
    }
    size_t v4 = (const void *)a1[6];
    if (v4) {
      CFRelease(v4);
    }
    int v5 = (const void *)a1[5];
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

CFStringRef _C3DSceneSourceCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DSceneSource >");
}

CFStringRef _C3DSceneSourceCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DSceneSource >");
}

uint64_t __C3DSceneSourceGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DSceneSourceGetTypeID_typeID = result;
  return result;
}

uint64_t C3DSceneSourceCreate()
{
  if (C3DSceneSourceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSceneSourceGetTypeID_onceToken, &__block_literal_global_0);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DSceneSourceGetTypeID_typeID, 0x28uLL);
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x690], 8) = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  return Instance;
}

uint64_t C3DSceneSourceCreateWithURL(const void *a1)
{
  uint64_t v2 = C3DSceneSourceCreate();
  *(void *)(v2 + 16) = CFRetain(a1);
  return v2;
}

uint64_t C3DSceneSourceCreateWithData(const void *a1)
{
  uint64_t v2 = C3DSceneSourceCreate();
  if (a1) {
    CFTypeRef v3 = CFRetain(a1);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *(void *)(v2 + 24) = v3;
  return v2;
}

uint64_t C3DSceneSourceGetURL(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t C3DSceneSourceGetData(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void C3DSceneSourceSetLibrary(uint64_t a1, CFTypeRef cf)
{
  size_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 40) = cf;
  if (cf)
  {
    CFRetain(cf);
  }
}

void C3DSceneSourceSetProperty(uint64_t a1, const void *a2, const void *a3)
{
}

CFDictionaryRef C3DSceneSourceCopyPropertiesAtIndex(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  else {
    return CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(a1 + 48));
  }
}

__CFDictionary *__CreateViewerOptionsWithOptions(CFDictionaryRef theDict)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (theDict) {
    MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(v2, 0, theDict);
  }
  else {
    MutableCFSetRef Copy = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  }
  size_t v4 = MutableCopy;
  int v5 = (const void *)*MEMORY[0x263EFFB40];
  CFDictionaryAddValue(MutableCopy, @"kSceneSourceCreateCameraIfAbsent", (const void *)*MEMORY[0x263EFFB40]);
  CFDictionaryAddValue(v4, @"kSceneSourceCreateNormalsIfAbsent", v5);
  CFDictionaryAddValue(v4, @"kSceneSourceCreateLightIfAbsent", v5);
  CFDictionaryAddValue(v4, @"kSceneSourceAdjustInvalidClippingPlanes", v5);
  CFDictionaryAddValue(v4, @"kSceneSourceFlattenScene", (const void *)*MEMORY[0x263EFFB38]);
  CFDictionaryAddValue(v4, @"kSceneSourceSplitMeshesForGLES", v5);
  CFDictionaryAddValue(v4, @"kSceneSourceAutoLimitMemoryForImages", v5);
  CFDictionaryAddValue(v4, @"triggerOptionsForRealtimeViewer", v5);
  CFDictionaryAddValue(v4, @"kSceneSourceAnimationLoadingMode", @"playUsingSceneTime");
  return v4;
}

__CFDictionary *C3DIOCreateImportContextFromOptions(CFDictionaryRef theDict, const __CFURL *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (theDict) {
    MutableCFSetRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, theDict);
  }
  else {
    MutableCFSetRef Copy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  }
  int v5 = MutableCopy;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, @"kSceneSourceAssetDirectoryURLs");
  if (Value) {
    CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(v3, 0, Value);
  }
  else {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
  }
  CFMutableArrayRef v8 = Mutable;
  CFDictionarySetValue(v5, @"kSceneSourceAssetDirectoryURLs", Mutable);
  CFRelease(v8);
  CFStringRef v9 = CFURLCopyScheme(a2);
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, a2);
  if (PathComponent)
  {
    CFURLRef v11 = PathComponent;
    CFDictionarySetValue(v5, @"kEnclosingDirectoryURL", PathComponent);
    v15.CFIndex length = CFArrayGetCount(v8);
    v15.location = 0;
    if (!CFArrayContainsValue(v8, v15, v11)) {
      CFArrayAppendValue(v8, v11);
    }
    CFRelease(v11);
  }
  if (!CFDictionaryGetValue(v5, @"kEnclosingFolderURL"))
  {
    CFURLRef v13 = CFURLCreateCopyDeletingLastPathComponent(v3, a2);
    CFURLRef v14 = C3DCopyResolvedURLFromFileURL(v13);
    CFDictionarySetValue(v5, @"kEnclosingFolderURL", v14);
    CFRelease(v13);
    CFRelease(v14);
    if (!v9) {
      return v5;
    }
    goto LABEL_13;
  }
  if (v9) {
LABEL_13:
  }
    CFRelease(v9);
  return v5;
}

uint64_t C3DSceneSourceGetFileFormat(uint64_t a1)
{
  CFDataRef v2 = *(const __CFData **)(a1 + 24);
  if (!v2)
  {
    CFURLRef v6 = *(const __CFURL **)(a1 + 16);
    if (!v6) {
      return -1;
    }
    CFURLRef v7 = CFURLCopyAbsoluteURL(v6);
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFStringRef v9 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x263EFFB08], v7);
    if (v9)
    {
      unsigned int v10 = v9;
      if (CFReadStreamOpen(v9))
      {
        CFIndex v11 = CFReadStreamRead(v10, buffer, 6);
        BOOL v12 = v11 != 6;
        if (v11 == 6)
        {
          BOOL v23 = *(_DWORD *)buffer != 1768714338 || v26 != 29811;
          CFReadStreamClose(v10);
          CFRelease(v10);
          if (!v23) {
            goto LABEL_24;
          }
        }
        else
        {
          CFReadStreamClose(v10);
          CFRelease(v10);
        }
LABEL_20:
        CFStringRef v14 = CFURLCopyPathExtension(v7);
        if (v14)
        {
          CFStringRef v15 = v14;
          BOOL v16 = CFStringCompare(v14, @"c3d", 1uLL) == kCFCompareEqualTo;
          CFRelease(v15);
        }
        else
        {
          BOOL v16 = 0;
        }
        if (!v12 && !v16)
        {
          CFStringRef v17 = CFURLCopyPathExtension(v7);
          if (v17)
          {
            CFStringRef v18 = v17;
            MutableCFSetRef Copy = CFStringCreateMutableCopy(v8, 0, v17);
            if (MutableCopy)
            {
              CFStringRef v20 = MutableCopy;
              CFStringLowercase(MutableCopy, 0);
              CFComparisonResult v21 = CFStringCompare(v20, @"dae", 0);
              CFRelease(v20);
              CFRelease(v18);
              if (v21 == kCFCompareEqualTo)
              {
                uint64_t v5 = 0;
                goto LABEL_39;
              }
            }
            else
            {
              CFRelease(v18);
            }
          }
          uint64_t v5 = -1;
          goto LABEL_39;
        }
LABEL_24:
        uint64_t v5 = 1;
LABEL_39:
        CFRelease(v7);
        return v5;
      }
      CFRelease(v10);
    }
    else
    {
      CFURLRef v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        C3DSceneSourceGetFileFormat_cold_1((uint64_t)v7, v13);
      }
    }
    BOOL v12 = 1;
    goto LABEL_20;
  }
  BytePtr = CFDataGetBytePtr(v2);
  if ((unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) < 6) {
    return 0;
  }
  return *(_DWORD *)BytePtr == 1768714338 && *((_WORD *)BytePtr + 2) == 29811;
}

__n128 *C3DSceneSourceCreateSceneAtIndex(void *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  os_unfair_lock_lock((os_unfair_lock_t)&scene_source_mutex);
  CFURLRef v7 = (CFURLRef *)(a1 + 2);
  if (!a1[2] && !a1[3])
  {
    BOOL v16 = 0;
    goto LABEL_27;
  }
  if (a3
    && (CFArrayRef Value = CFDictionaryGetValue(a3, @"triggerOptionsForRealtimeViewer")) != 0
    && CFEqual(Value, (CFTypeRef)*MEMORY[0x263EFFB40]))
  {
    ViewerOptionsWithOptions = __CreateViewerOptionsWithOptions(a3);
    a3 = ViewerOptionsWithOptions;
  }
  else
  {
    ViewerOptionsWithOptions = 0;
  }
  unsigned int v10 = (const void *)C3DLibraryCreate();
  C3DSceneSourceSetLibrary((uint64_t)a1, v10);
  uint64_t FileFormat = C3DSceneSourceGetFileFormat((uint64_t)a1);
  CFDataRef v12 = (const __CFData *)a1[3];
  if (!v12)
  {
    CFURLRef v14 = CFURLCopyAbsoluteURL(*v7);
    CFURLRef v15 = v14;
    if (FileFormat == -1)
    {
      CFErrorRef Error = C3DSceneSourceCreateError(-6, @"Unknown or missing file");
      (*(void (**)(uint64_t, uint64_t, CFErrorRef, void, float))(a4 + 16))(a4, 0xFFFFFFFFLL, Error, 0, 1.0);
      CFRelease(Error);
    }
    else if (FileFormat == 1)
    {
      BOOL v16 = C3DIOCreateSceneAtURL(v14, (uint64_t)a1, v10, a3, a4);
      goto LABEL_21;
    }
    BOOL v16 = 0;
LABEL_21:
    CFRelease(v15);
    if (!v16) {
      goto LABEL_23;
    }
LABEL_22:
    C3DIOFinalizeLoadScene((uint64_t)v16, v10, a3, a1[6], FileFormat);
    goto LABEL_23;
  }
  if (FileFormat != 1)
  {
    CFStringRef v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      C3DSceneSourceCreateSceneAtIndex_cold_1((uint64_t *)v7, v17);
    }
    BOOL v16 = 0;
    goto LABEL_23;
  }
  if (*v7) {
    CFURLRef v13 = C3DIOCreateSceneAtURL(*v7, (uint64_t)a1, v10, a3, a4);
  }
  else {
    CFURLRef v13 = C3DIOCreateSceneWithData(v12, (uint64_t)a1, v10, a3, a4);
  }
  BOOL v16 = v13;
  if (v13) {
    goto LABEL_22;
  }
LABEL_23:
  if (v10) {
    CFRelease(v10);
  }
  if (ViewerOptionsWithOptions) {
    CFRelease(ViewerOptionsWithOptions);
  }
LABEL_27:
  os_unfair_lock_unlock((os_unfair_lock_t)&scene_source_mutex);
  return v16;
}

CFErrorRef C3DSceneSourceCreateError(CFIndex a1, void *a2)
{
  MainBundle = CFBundleGetMainBundle();
  uint64_t v5 = (__CFString *)CFBundleCopyLocalizedString(MainBundle, @"Could not load the scene", @"Could not load the scene", 0);
  CFErrorRef v6 = C3DErrorCreate(a1, v5, a2);
  CFRelease(v5);
  return v6;
}

CFErrorRef C3DSceneSourceCreateMalformedDocumentError(int a1)
{
  MainBundle = CFBundleGetMainBundle();
  if (a1) {
    CFStringRef v3 = @"The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.";
  }
  else {
    CFStringRef v3 = @"The document does not appear to be valid. Please re-create it from your original COLLADA assets.";
  }
  size_t v4 = (__CFString *)CFBundleCopyLocalizedString(MainBundle, v3, v3, 0);
  uint64_t v5 = CFBundleGetMainBundle();
  CFErrorRef v6 = (__CFString *)CFBundleCopyLocalizedString(v5, @"Could not load the scene", @"Could not load the scene", 0);
  CFErrorRef v7 = C3DErrorCreate(-5, v6, v4);
  CFRelease(v4);
  CFRelease(v6);
  return v7;
}

BOOL C3DEqual(CFTypeRef cf1, const void *a2)
{
  BOOL result = 0;
  if (cf1)
  {
    if (a2) {
      return CFEqual(cf1, a2) != 0;
    }
  }
  return result;
}

__n128 C3D::CopyTextureComputePass::CopyTextureComputePass(C3D::CopyTextureComputePass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  C3D::ComputePass::ComputePass(this, a2, a3);
  *(void *)uint64_t v5 = &unk_26BF6E240;
  __n128 result = *(__n128 *)&a4->var0;
  *(void *)(v5 + 124) = *(void *)&a4[1].var6;
  *(__n128 *)(v5 + 10_Block_object_dispose(&STACK[0x690], 8) = result;
  return result;
}

const char *C3D::CopyTextureComputePass::name(C3D::CopyTextureComputePass *this)
{
  return "CopyTextureComputePass";
}

void C3D::CopyTextureComputePass::setup(C3D::CopyTextureComputePass *this)
{
  C3D::Pass::setInputCount(this, 1u);

  C3D::Pass::setOutputCount(this, 1u);
}

uint64_t C3D::CopyTextureComputePass::compile(C3D::CopyTextureComputePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::CopyTextureComputePass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v3);
  *((void *)this + 17) = result;
  if (!result) {
    operator new();
  }
  return result;
}

void C3D::CopyTextureComputePass::execute(uint64_t a1, SCNMTLComputeCommandEncoder **a2)
{
  v63[6] = *MEMORY[0x263EF8340];
  if (*(_WORD *)(C3D::Pass::descriptor((C3D::Pass *)a1) + 4))
  {
    size_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::CopyTextureComputePass::execute(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDataRef v12 = *a2;
  CFURLRef v13 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  CFURLRef v14 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  unint64_t v15 = [v13 mipmapLevelCount];
  unint64_t v16 = [v14 mipmapLevelCount];
  if (v15 >= v16) {
    int v17 = v16;
  }
  else {
    int v17 = v15;
  }
  unsigned int v18 = *(_DWORD *)(a1 + 112);
  unsigned int v19 = v17 - *(_DWORD *)(a1 + 116);
  unsigned int v20 = *(_DWORD *)(a1 + 120);
  if (v20 >= v19) {
    unsigned int v21 = v19;
  }
  else {
    unsigned int v21 = *(_DWORD *)(a1 + 120);
  }
  if (v20) {
    unsigned int v19 = v21;
  }
  unsigned int v62 = v19;
  if (!v18)
  {
    unsigned int v22 = [v13 arrayLength];
    if ((unint64_t)([v13 textureType] - 5) >= 2) {
      unsigned int v18 = v22;
    }
    else {
      unsigned int v18 = 6 * v22;
    }
  }
  uint64_t v23 = [v13 width];
  if (v23 == [v14 width] && (uint64_t v24 = objc_msgSend(v13, "height"), v24 == objc_msgSend(v14, "height")))
  {
    uint64_t v25 = [v13 depth];
    BOOL v26 = v25 != [v14 depth];
  }
  else
  {
    BOOL v26 = 1;
  }
  BOOL v61 = v26;
  BOOL IsArray = SCNMTLTextureTypeIsArray([v13 textureType]);
  BOOL v59 = SCNMTLTextureTypeIsArray([v14 textureType]);
  ArrayElementint Type = SCNMTLTextureTypeGetArrayElementType([v13 textureType]);
  uint64_t v58 = SCNMTLTextureTypeGetArrayElementType([v14 textureType]);
  if (ArrayElementType != v58)
  {
    long long v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      C3D::CopyTextureComputePass::execute(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }
  if (v62)
  {
    int v36 = 0;
    while (1)
    {
      uint64_t v37 = (*(_DWORD *)(a1 + 116) + v36);
      uint64_t v38 = *(unsigned int *)(a1 + 108);
      int v39 = v37 | v38 || IsArray;
      if (v39 != 1) {
        break;
      }
      float64x2_t v40 = (MTLTexture *)(id)objc_msgSend(v13, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v13, "pixelFormat"), ArrayElementType, v37, 1, v38, v18);
      if (v12->_textures[0] != v40) {
        goto LABEL_32;
      }
LABEL_33:
      uint64_t v41 = (*(_DWORD *)(a1 + 128) + v36);
      CFArrayRef v42 = *(void **)(a1 + 136);
      if (ArrayElementType == 5)
      {
        if (v61) {
          uint64_t v43 = v42[5];
        }
        else {
          uint64_t v43 = v42[3];
        }
        uint64_t v45 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v43);
        if (v12->_computePipelineState != (MTLComputePipelineState *)v45)
        {
          v12->_computePipelineState = (MTLComputePipelineState *)v45;
          -[MTLComputeCommandEncoder setComputePipelineState:](v12->_encoder, "setComputePipelineState:");
        }
        if (C3DEngineContextHasFeatures(*(void *)(a1 + 16), 512))
        {
          if (v41) {
            int v46 = 1;
          }
          else {
            int v46 = v59;
          }
          if (v46 == 1)
          {
            long long v47 = (MTLTexture *)(id)objc_msgSend(v14, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v14, "pixelFormat"), v58, v41, 1, *(unsigned int *)(a1 + 124), 6);
            if (v12->_textures[1] == v47)
            {
LABEL_67:
              long long v57 = v12;
              long long v56 = v14;
LABEL_68:
              SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v57, v56);
              goto LABEL_69;
            }
          }
          else
          {
            long long v47 = (MTLTexture *)v14;
            if ((void *)v12->_textures[1] == v14) {
              goto LABEL_67;
            }
          }
          v12->_textures[1] = v47;
          v12->_texturesToBind[0] |= 2uLL;
          goto LABEL_67;
        }
        uint64_t v52 = 0;
        do
        {
          long long v53 = (MTLBuffer *)(id)objc_msgSend(v14, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v14, "pixelFormat"), 2, v41, 1, (v52 + *(_DWORD *)(a1 + 124)), 1);
          v63[v52] = v53;
          unint64_t v54 = v52 + 1;
          long long v55 = &v12->_buffers[v52];
          if (v55[63] != v53)
          {
            v55[63] = v53;
            v12->_texturesToBind[v54 >> 6] |= (2 << v52);
          }
          ++v52;
        }
        while (v54 != 6);
        long long v56 = (void *)v63[0];
        long long v57 = v12;
        goto LABEL_68;
      }
      if (v61) {
        uint64_t v44 = v42[4];
      }
      else {
        uint64_t v44 = v42[2];
      }
      uint64_t v48 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v44);
      uint64_t v49 = v48;
      if (v12->_computePipelineState != (MTLComputePipelineState *)v48)
      {
        v12->_computePipelineState = (MTLComputePipelineState *)v48;
        -[MTLComputeCommandEncoder setComputePipelineState:](v12->_encoder, "setComputePipelineState:");
      }
      if (v41) {
        int v50 = 1;
      }
      else {
        int v50 = v59;
      }
      if (v50 == 1)
      {
        int v51 = (MTLTexture *)(id)objc_msgSend(v14, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v14, "pixelFormat", v49), v58, v41, 1, *(unsigned int *)(a1 + 124), 1);
        if (v12->_textures[1] == v51) {
          goto LABEL_64;
        }
LABEL_63:
        v12->_textures[1] = v51;
        v12->_texturesToBind[0] |= 2uLL;
        goto LABEL_64;
      }
      int v51 = (MTLTexture *)v14;
      if ((void *)v12->_textures[1] != v14) {
        goto LABEL_63;
      }
LABEL_64:
      SCNMTLComputeCommandEncoder::dispatchOnGrid2D(v12, [v14 width], objc_msgSend(v14, "height"));
LABEL_69:
      if (++v36 == v62) {
        return;
      }
    }
    float64x2_t v40 = (MTLTexture *)v13;
    if ((void **)v12->_textures[0] == v13) {
      goto LABEL_33;
    }
LABEL_32:
    v12->_textures[0] = v40;
    v12->_texturesToBind[0] |= 1uLL;
    goto LABEL_33;
  }
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnTextureCube(SCNMTLComputeCommandEncoder *this, void *a2)
{
  if (!this->_computePipelineState)
  {
    size_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  unsigned int features = this->_features;
  unint64_t v13 = [(MTLComputePipelineState *)this->_computePipelineState threadExecutionWidth];
  if ((features & 0x40) != 0)
  {
    unint64_t v23 = [(MTLComputePipelineState *)this->_computePipelineState maxTotalThreadsPerThreadgroup]/ v13;
    uint64_t v24 = [a2 width];
    uint64_t v25 = [a2 height];
    encoder = this->_encoder;
    v30[0] = v24;
    v30[1] = v25;
    v30[2] = 6;
    v29[0] = v13;
    v29[1] = v23;
    v29[2] = 1;
    return [(MTLComputeCommandEncoder *)encoder dispatchThreads:v30 threadsPerThreadgroup:v29];
  }
  else
  {
    unint64_t v14 = [a2 width];
    if (v13 >= v14) {
      unint64_t v13 = v14;
    }
    unint64_t v15 = [(MTLComputePipelineState *)this->_computePipelineState maxTotalThreadsPerThreadgroup];
    unint64_t v16 = v13;
    do
    {
      unint64_t v17 = v16;
      unint64_t v18 = 6 * v13 * v16;
      v16 >>= 1;
    }
    while (v18 > v15);
    unint64_t v19 = (v13 + [a2 width] - 1) / v13;
    unint64_t v20 = v17 + [a2 height] - 1;
    unsigned int v21 = this->_encoder;
    v28[0] = v19;
    v28[1] = v20 / v17;
    void v28[2] = 6;
    v27[0] = v13;
    v27[1] = v17;
    v27[2] = 1;
    return [(MTLComputeCommandEncoder *)v21 dispatchThreadgroups:v28 threadsPerThreadgroup:v27];
  }
}

uint64_t C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(uint64_t a1)
{
  if (!*(void *)a1)
  {
    CFDataRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)a1;
}

uint64_t SCNMTLRenderCommandEncoder::drawFullScreenTriangle(SCNMTLRenderCommandEncoder *this)
{
  SCNMTLRenderCommandEncoder::_bindPendingTextures(this);
  SCNMTLRenderCommandEncoder::applyChangedStates(this);
  CFDataRef v2 = (void *)this->var24[1];
  if (LODWORD(this->var14[0].var1) < 2)
  {
    return [v2 drawPrimitives:3 vertexStart:0 vertexCount:3];
  }
  else
  {
    return objc_msgSend(v2, "drawPrimitives:vertexStart:vertexCount:instanceCount:", 3, 0, 3);
  }
}

void C3D::CopyTextureComputePass::Resource::~Resource(C3D::CopyTextureComputePass::Resource *this)
{
  *(void *)this = &unk_26BF6E220;
  CFDataRef v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4) {

  }
  uint64_t v5 = (void *)*((void *)this + 2);
  if (v5) {
}
  }

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E220;
  CFDataRef v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4) {

  }
  uint64_t v5 = (void *)*((void *)this + 2);
  if (v5) {

  }
  JUMPOUT(0x210534FE0);
}

void SCNMTLComputeCommandEncoder::_bindPendingTextures(SCNMTLComputeCommandEncoder *this)
{
  uint64_t v2 = 0;
  *(void *)&void v15[5] = *MEMORY[0x263EF8340];
  textures = this->_textures;
  do
  {
    uint64_t v4 = &this->_buffers[v2];
    unint64_t v5 = (unint64_t)v4[211];
    if (v5)
    {
      unint64_t v6 = 0;
      uint64_t v7 = 1;
      unint64_t v8 = 0xFFFFFFFFLL;
      do
      {
        if (v5)
        {
          if (v8 >= v7 - 1) {
            uint64_t v9 = v7 - 1;
          }
          else {
            uint64_t v9 = v8;
          }
          if ((v5 & 2) == 0)
          {
            if (v8 >= v6) {
              unint64_t v11 = v6;
            }
            else {
              unint64_t v11 = v8;
            }
            encoder = this->_encoder;
            if (v7 - v11 < 2) {
              -[MTLComputeCommandEncoder setTexture:atIndex:](encoder, "setTexture:atIndex:", this->_textures[v9]);
            }
            else {
              -[MTLComputeCommandEncoder setTextures:withRange:](encoder, "setTextures:withRange:", &textures[v9]);
            }
            uint64_t v9 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          uint64_t v9 = 0xFFFFFFFFLL;
          if (v8 != 0xFFFFFFFF)
          {
            uint64_t v10 = scn_default_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
              SCNMTLComputeCommandEncoder::_bindPendingTextures(v14, v15, v10);
            }
            uint64_t v9 = v8;
          }
        }
        ++v6;
        ++v7;
        unint64_t v8 = v9;
        BOOL v13 = v5 >= 2;
        v5 >>= 1;
      }
      while (v13);
    }
    v4[211] = 0;
    ++v2;
  }
  while (v2 != 2);
}

void SCNMTLComputeCommandEncoder::_bindPendingBuffers(SCNMTLComputeCommandEncoder *this)
{
  *(void *)&v12[5] = *MEMORY[0x263EF8340];
  unint64_t v2 = this->_buffersToBind[0];
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 1;
    unint64_t v5 = 0xFFFFFFFFLL;
    do
    {
      if (v2)
      {
        if (v5 >= v4 - 1) {
          uint64_t v6 = v4 - 1;
        }
        else {
          uint64_t v6 = v5;
        }
        if ((v2 & 2) == 0)
        {
          if (v5 >= v3) {
            unint64_t v8 = v3;
          }
          else {
            unint64_t v8 = v5;
          }
          encoder = this->_encoder;
          if (v4 - v8 < 2) {
            -[MTLComputeCommandEncoder setBuffer:offset:atIndex:](encoder, "setBuffer:offset:atIndex:", this->_buffers[v6], this->_offsets[v6]);
          }
          else {
            -[MTLComputeCommandEncoder setBuffers:offsets:withRange:](encoder, "setBuffers:offsets:withRange:", &this->_buffers[v6], &this->_offsets[v6]);
          }
          uint64_t v6 = 0xFFFFFFFFLL;
        }
      }
      else
      {
        uint64_t v6 = 0xFFFFFFFFLL;
        if (v5 != 0xFFFFFFFF)
        {
          uint64_t v7 = scn_default_log();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v11, v12, v7);
          }
          uint64_t v6 = v5;
        }
      }
      ++v3;
      ++v4;
      unint64_t v5 = v6;
      BOOL v10 = v2 >= 2;
      v2 >>= 1;
    }
    while (v10);
  }
  this->_buffersToBind[0] = 0;
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnGrid2D(SCNMTLComputeCommandEncoder *this, unint64_t a2, unint64_t a3)
{
  if (!this->_computePipelineState)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  unsigned int features = this->_features;
  unint64_t v15 = [(MTLComputePipelineState *)this->_computePipelineState threadExecutionWidth];
  unint64_t v16 = v15;
  if ((features & 0x40) != 0)
  {
    unint64_t v23 = [(MTLComputePipelineState *)this->_computePipelineState maxTotalThreadsPerThreadgroup];
    encoder = this->_encoder;
    v28[0] = a2;
    v28[1] = a3;
    void v28[2] = 1;
    v27[0] = v16;
    v27[1] = v23 / v16;
    v27[2] = 1;
    return [(MTLComputeCommandEncoder *)encoder dispatchThreads:v28 threadsPerThreadgroup:v27];
  }
  else
  {
    if (v15 >= a2) {
      unint64_t v17 = a2;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v15 >= a3) {
      unint64_t v16 = a3;
    }
    unint64_t v18 = [(MTLComputePipelineState *)this->_computePipelineState maxTotalThreadsPerThreadgroup];
    do
    {
      unint64_t v19 = v16;
      unint64_t v20 = v16 * v17;
      v16 >>= 1;
    }
    while (v20 > v18);
    unsigned int v21 = this->_encoder;
    v26[0] = (a2 + v17 - 1) / v17;
    v26[1] = (a3 + v19 - 1) / v19;
    v26[2] = 1;
    v25[0] = v17;
    v25[1] = v19;
    v25[2] = 1;
    return [(MTLComputeCommandEncoder *)v21 dispatchThreadgroups:v26 threadsPerThreadgroup:v25];
  }
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

CFStringRef _C3DSortSystemCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DSortSystem %p>", a1);
}

CFStringRef _C3DSortSystemCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DSortSystem %p>", a1);
}

uint64_t C3DSortSystemInvalidateKeyForRendererElementSpan(uint64_t a1, unint64_t a2)
{
  uint64_t Count = C3DArrayGetCount(*(void *)(a1 + 16));
  uint64_t result = C3DRendererElementFlattenedIndexForSpanHandle((unsigned __int16)a2, WORD1(a2));
  if (Count > result)
  {
    unint64_t v6 = HIDWORD(a2);
    uint64_t result = C3DArrayGetValuesPtr(*(void *)(a1 + 16));
    if (HIDWORD(a2))
    {
      uint64_t v7 = result;
      unint64_t v8 = a2 >> 16;
      do
      {
        uint64_t result = C3DRendererElementFlattenedIndexForSpanHandle((unsigned __int16)a2, (unsigned __int16)v8);
        *(void *)(v7 + 8 * result) = -1;
        LODWORD(v_Block_object_dispose(&STACK[0x690], 8) = v8 + 1;
        LODWORD(v6) = v6 - 1;
      }
      while (v6);
    }
  }
  return result;
}

void Variable::Variable(std::string *this, long long *a2, long long *a3, long long *a4, long long *a5)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v9;
  }
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v10 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v10;
  }
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v11 = *a4;
    this[2].__r_.__value_.__r.__words[2] = *((void *)a4 + 2);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v11;
  }
  uint64_t v12 = this + 3;
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v13 = *a5;
    this[3].__r_.__value_.__r.__words[2] = *((void *)a5 + 2);
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v13;
  }
}

void sub_20B2C3540(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *Variable::Output(std::string *result, uint64_t a2, int a3, std::string *this)
{
  uint64_t v5 = (uint64_t)result;
  if (a3 == 2)
  {
    unint64_t v17 = ShaderConverter::GLSLToMetalSymbol(a2, (const void **)&result[1].__r_.__value_.__l.__data_);
    int v18 = *((char *)v17 + 23);
    if (v18 >= 0) {
      unint64_t v19 = (const std::string::value_type *)v17;
    }
    else {
      unint64_t v19 = (const std::string::value_type *)*v17;
    }
    if (v18 >= 0) {
      std::string::size_type v20 = *((unsigned __int8 *)v17 + 23);
    }
    else {
      std::string::size_type v20 = (std::string::size_type)v17[1];
    }
    std::string::append(this, v19, v20);
    std::string::append(this, " ");
    int v21 = *(char *)(v5 + 23);
    if (v21 >= 0) {
      unsigned int v22 = (const std::string::value_type *)v5;
    }
    else {
      unsigned int v22 = *(const std::string::value_type **)v5;
    }
    if (v21 >= 0) {
      std::string::size_type v23 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      std::string::size_type v23 = *(void *)(v5 + 8);
    }
    std::string::append(this, v22, v23);
    char v24 = *(unsigned char *)(v5 + 95);
    if (v24 < 0)
    {
      if (!*(void *)(v5 + 80)) {
        goto LABEL_48;
      }
    }
    else if (!*(unsigned char *)(v5 + 95))
    {
      goto LABEL_48;
    }
    if (v24 >= 0) {
      uint64_t v25 = (const std::string::value_type *)(v5 + 72);
    }
    else {
      uint64_t v25 = *(const std::string::value_type **)(v5 + 72);
    }
    if (v24 >= 0) {
      std::string::size_type v26 = *(unsigned __int8 *)(v5 + 95);
    }
    else {
      std::string::size_type v26 = *(void *)(v5 + 80);
    }
    std::string::append(this, v25, v26);
LABEL_48:
    if (*(char *)(v5 + 71) < 0)
    {
      if (!*(void *)(v5 + 56)) {
        goto LABEL_67;
      }
    }
    else if (!*(unsigned char *)(v5 + 71))
    {
      goto LABEL_67;
    }
    long long v27 = (const std::string::value_type *)(v5 + 48);
    long long v28 = " =";
    goto LABEL_60;
  }
  if (a3 != 1) {
    return result;
  }
  unint64_t v6 = std::string::append(this, "uniform ");
  uint64_t v7 = ShaderConverter::MetalToGLSLSymbol((uint64_t)v6, (const void **)(v5 + 24));
  int v8 = *((char *)v7 + 23);
  if (v8 >= 0) {
    long long v9 = (const std::string::value_type *)v7;
  }
  else {
    long long v9 = (const std::string::value_type *)*v7;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *((unsigned __int8 *)v7 + 23);
  }
  else {
    std::string::size_type v10 = (std::string::size_type)v7[1];
  }
  std::string::append(this, v9, v10);
  std::string::append(this, " ");
  int v11 = *(char *)(v5 + 23);
  if (v11 >= 0) {
    uint64_t v12 = (const std::string::value_type *)v5;
  }
  else {
    uint64_t v12 = *(const std::string::value_type **)v5;
  }
  if (v11 >= 0) {
    std::string::size_type v13 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    std::string::size_type v13 = *(void *)(v5 + 8);
  }
  std::string::append(this, v12, v13);
  char v14 = *(unsigned char *)(v5 + 95);
  if (v14 < 0)
  {
    if (*(void *)(v5 + 80)) {
      goto LABEL_17;
    }
  }
  else if (*(unsigned char *)(v5 + 95))
  {
LABEL_17:
    if (v14 >= 0) {
      unint64_t v15 = (const std::string::value_type *)(v5 + 72);
    }
    else {
      unint64_t v15 = *(const std::string::value_type **)(v5 + 72);
    }
    if (v14 >= 0) {
      std::string::size_type v16 = *(unsigned __int8 *)(v5 + 95);
    }
    else {
      std::string::size_type v16 = *(void *)(v5 + 80);
    }
    std::string::append(this, v15, v16);
  }
  if ((*(char *)(v5 + 71) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(v5 + 71)) {
      goto LABEL_67;
    }
    goto LABEL_55;
  }
  if (*(void *)(v5 + 56))
  {
LABEL_55:
    long long v27 = (const std::string::value_type *)(v5 + 48);
    long long v28 = " = ";
LABEL_60:
    std::string::append(this, v28);
    int v29 = *(char *)(v5 + 71);
    if (v29 >= 0) {
      uint64_t v30 = v27;
    }
    else {
      uint64_t v30 = *(const std::string::value_type **)(v5 + 48);
    }
    if (v29 >= 0) {
      std::string::size_type v31 = *(unsigned __int8 *)(v5 + 71);
    }
    else {
      std::string::size_type v31 = *(void *)(v5 + 56);
    }
    std::string::append(this, v30, v31);
  }
LABEL_67:

  return std::string::append(this, ";\n");
}

const void **ShaderConverter::MetalToGLSLSymbol(uint64_t a1, const void **a2)
{
  if (ShaderConverter::StaticInit(void)::onceToken != -1) {
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
  }
  uint64_t v3 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics, a2);
  if (ShaderConverter::mpStatics + 8 == v3) {
    return a2;
  }
  else {
    return (const void **)(v3 + 56);
  }
}

const void **ShaderConverter::GLSLToMetalSymbol(uint64_t a1, const void **a2)
{
  if (ShaderConverter::StaticInit(void)::onceToken != -1) {
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
  }
  uint64_t v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics + 24, a2);
  if (ShaderConverter::mpStatics + 32 != v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics + 96, a2);
    if (ShaderConverter::mpStatics + 104 != v6)
    {
      uint64_t v7 = (const std::string *)ShaderConverter::GLSLToMetalSymbol(a1, v6 + 56);
      std::string::size_type v10 = (long long *)(v5 + 56);
      int v8 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(a1 + 200), (const void **)(v5 + 56), (uint64_t)&std::piecewise_construct, &v10);
      std::string::operator=((std::string *)(v8 + 7), v7);
    }
    return (const void **)(v5 + 56);
  }
  return a2;
}

void Statement::AddToken()
{
}

void sub_20B2C3978(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

void Statement::AddTokens(uint64_t a1, void *a2)
{
  if (*a2 != a2[1]) {
    operator new();
  }
}

void sub_20B2C3A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x210534FE0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

uint64_t ShaderConverter::ParseUniform(ShaderConverter *this)
{
  CFAllocatorRef v2 = (ShaderConverter *)((char *)this + 40);
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 7
      || (*(_DWORD *)__p.__r_.__value_.__l.__data_ == 1718185589
        ? (BOOL v4 = *(_DWORD *)(__p.__r_.__value_.__r.__words[0] + 3) == 1836216166)
        : (BOOL v4 = 0),
          !v4))
    {
LABEL_108:
      __assert_rtn("ParseUniform", "C3DShaderConverter.mm", 626, "mToken.str() == \"uniform\"");
    }
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 7) {
      goto LABEL_108;
    }
    if (LODWORD(__p.__r_.__value_.__l.__data_) != 1718185589
      || *(_DWORD *)((char *)__p.__r_.__value_.__r.__words + 3) != 1836216166)
    {
      goto LABEL_108;
    }
  }
  ShaderConverter::NextToken(this);
  if (*((_DWORD *)this + 16) == 13)
  {
    ShaderConverter::NextToken(this);
    if (*((_DWORD *)this + 16) == 1)
    {
      Token::str(v2, &v35);
      ShaderConverter::NextToken(this);
      if (*((_DWORD *)this + 16) != 13 || (ShaderConverter::NextToken(this), *((_DWORD *)this + 16) != 1))
      {
        Token::str(v2, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v8 = 0;
        goto LABEL_40;
      }
      Token::str(v2, &v34);
      ShaderConverter::NextToken(this);
      int v5 = *((_DWORD *)this + 16);
      if (v5 == 13)
      {
        ShaderConverter::NextToken(this);
        int v5 = *((_DWORD *)this + 16);
      }
      memset(&v33, 0, sizeof(v33));
      memset(&v32, 0, sizeof(v32));
      if (v5 == 10)
      {
        while (v5 != 11)
        {
          Token::str(v2, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
          }
          std::string::append(&v32, (const std::string::value_type *)p_p, size);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          ShaderConverter::NextToken(this);
          int v5 = *((_DWORD *)this + 16);
          if (!v5) {
            goto LABEL_90;
          }
        }
        Token::str(v2, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v10 = &__p;
        }
        else {
          std::string::size_type v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v11 = __p.__r_.__value_.__l.__size_;
        }
        std::string::append(&v32, (const std::string::value_type *)v10, v11);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        ShaderConverter::NextToken(this);
        int v5 = *((_DWORD *)this + 16);
        if (v5 == 13)
        {
          ShaderConverter::NextToken(this);
          int v5 = *((_DWORD *)this + 16);
        }
      }
      if (v5 == 5)
      {
        Token::str(v2, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          uint64_t v12 = (void *)__p.__r_.__value_.__r.__words[0];
          if (__p.__r_.__value_.__l.__size_ == 1)
          {
            int v13 = *__p.__r_.__value_.__l.__data_;
            operator delete(__p.__r_.__value_.__l.__data_);
            if (v13 == 61) {
              goto LABEL_59;
            }
          }
          else
          {
LABEL_78:
            operator delete(v12);
          }
        }
        else if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 1 && __p.__r_.__value_.__s.__data_[0] == 61)
        {
          while (1)
          {
LABEL_59:
            ShaderConverter::NextToken(this);
            Token::str(v2, &__p);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              if (__p.__r_.__value_.__l.__size_ == 1)
              {
                uint64_t v12 = (void *)__p.__r_.__value_.__r.__words[0];
                if (*__p.__r_.__value_.__l.__data_ == 59) {
                  goto LABEL_78;
                }
                int v14 = *((_DWORD *)this + 16);
              }
              else
              {
                int v14 = *((_DWORD *)this + 16);
                uint64_t v12 = (void *)__p.__r_.__value_.__r.__words[0];
              }
              operator delete(v12);
              if (!v14) {
                break;
              }
            }
            else
            {
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 1 && __p.__r_.__value_.__s.__data_[0] == 59) {
                break;
              }
              if (!*((_DWORD *)this + 16)) {
                goto LABEL_81;
              }
            }
            Token::str(v2, &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = &__p;
            }
            else {
              uint64_t v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v16 = __p.__r_.__value_.__l.__size_;
            }
            std::string::append(&v33, (const std::string::value_type *)v15, v16);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
        }
      }
      if (*((_DWORD *)this + 16) == 13) {
        ShaderConverter::NextToken(this);
      }
LABEL_81:
      Token::str(v2, &__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 1 || __p.__r_.__value_.__s.__data_[0] != 59) {
          goto LABEL_90;
        }
LABEL_87:
        ShaderConverter::NextToken(this);
        Variable::Variable(&__p, (long long *)&v34, (long long *)&v35, (long long *)&v33, (long long *)&v32);
        unint64_t v18 = *((void *)this + 14);
        if (v18 >= *((void *)this + 15))
        {
          uint64_t v23 = std::vector<Variable>::__push_back_slow_path<Variable>((uint64_t *)this + 13, (long long *)&__p);
          int v24 = SHIBYTE(v31);
          *((void *)this + 14) = v23;
          if (v24 < 0) {
            operator delete(v30[0]);
          }
        }
        else
        {
          long long v19 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(v18 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)unint64_t v18 = v19;
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
          uint64_t v20 = v27;
          *(_OWORD *)(v18 + 24) = *(_OWORD *)v26;
          *(void *)(v18 + 40) = v20;
          __p.__r_.__value_.__r.__words[2] = 0;
          v26[0] = 0;
          v26[1] = 0;
          uint64_t v27 = 0;
          long long v21 = *(_OWORD *)v28;
          *(void *)(v18 + 64) = v29;
          *(_OWORD *)(v18 + 4_Block_object_dispose(&STACK[0x690], 8) = v21;
          v28[0] = 0;
          v28[1] = 0;
          long long v22 = *(_OWORD *)v30;
          *(void *)(v18 + 8_Block_object_dispose(&STACK[0x690], 8) = v31;
          *(_OWORD *)(v18 + 72) = v22;
          uint64_t v29 = 0;
          v30[0] = 0;
          v30[1] = 0;
          uint64_t v31 = 0;
          *((void *)this + 14) = v18 + 96;
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[0]);
        }
        if (SHIBYTE(v27) < 0) {
          operator delete(v26[0]);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v8 = 1;
        goto LABEL_93;
      }
      if (__p.__r_.__value_.__l.__size_ == 1)
      {
        int v17 = *__p.__r_.__value_.__l.__data_;
        operator delete(__p.__r_.__value_.__l.__data_);
        if (v17 == 59) {
          goto LABEL_87;
        }
      }
      else
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
LABEL_90:
      Token::str(v2, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      uint64_t v8 = 0;
LABEL_93:
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
LABEL_40:
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      return v8;
    }
  }
  Token::str(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_20B2C401C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  Variable::~Variable(&a9);
  if (a29 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v29 - 81) < 0) {
    operator delete(*(void **)(v29 - 104));
  }
  if (*(char *)(v29 - 57) < 0) {
    operator delete(*(void **)(v29 - 80));
  }
  if (*(char *)(v29 - 33) < 0) {
    operator delete(*(void **)(v29 - 56));
  }
  _Unwind_Resume(a1);
}

void Variable::~Variable(void **this)
{
  if (*((char *)this + 95) < 0) {
    operator delete(this[9]);
  }
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(this[3]);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

void ShaderConverter::ParseFunctionArgument(ShaderConverter *this)
{
}

void sub_20B2C42CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ShaderConverter::ParseTextureLookup(ShaderConverter *this)
{
  CFAllocatorRef v2 = (ShaderConverter *)((char *)this + 40);
  Token::str((ShaderConverter *)((char *)this + 40), &v6);
  ShaderConverter::NextToken(this);
  int v3 = *((_DWORD *)this + 16);
  if (v3 == 13)
  {
    ShaderConverter::NextToken(this);
    int v3 = *((_DWORD *)this + 16);
  }
  if (v3 == 6)
  {
    ShaderConverter::NextToken(this);
    if (*((_DWORD *)this + 16) == 13) {
      ShaderConverter::NextToken(this);
    }
    ShaderConverter::ParseFunctionArgument(this);
  }
  Token::str(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_20B2C46F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  MEMORY[0x210534FE0](v17, 0x10B3C406D35A18FLL);
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t ShaderConverter::ParseMatrixCTOR(uint64_t **this)
{
  Token::str((Token *)(this + 5), &v6);
  memset(&__p[3], 0, 24);
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(this + 22, (const void **)&v6.__r_.__value_.__l.__data_, (uint64_t)&v6);
  ShaderConverter::NextToken((ShaderConverter *)this);
  int v2 = *((_DWORD *)this + 16);
  if (v2 == 13)
  {
    ShaderConverter::NextToken((ShaderConverter *)this);
    int v2 = *((_DWORD *)this + 16);
  }
  if (v2 != 6) {
    operator new();
  }
  ShaderConverter::NextToken((ShaderConverter *)this);
  if (*((_DWORD *)this + 16) == 13) {
    ShaderConverter::NextToken((ShaderConverter *)this);
  }
  int v3 = *((_DWORD *)this + 16);
  if (v3)
  {
    if (v3 != 7) {
      ShaderConverter::ParseFunctionArgument((ShaderConverter *)this);
    }
    ShaderConverter::NextToken((ShaderConverter *)this);
    __p[0] = &v6;
    std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(ShaderConverter::mpStatics + 72), (const void **)&v6.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (long long **)__p);
    operator new();
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_20B2C4A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  MEMORY[0x210534FE0](v23, 0x1093C40CC6E360FLL);
  if (__p) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

void ShaderConverter::ParseMacro(ShaderConverter *this)
{
}

void sub_20B2C5044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x210534FE0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

void ShaderConverter::ParseDeclaration(ShaderConverter *this)
{
  uint64_t v135 = 0;
  float v136 = 0;
  float v137 = 0;
  int v2 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, 1uLL);
  int v3 = (_OWORD *)((char *)this + 40);
  long long v5 = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)int v2 = *(_OWORD *)((char *)this + 40);
  *((_OWORD *)v2 + 1) = v5;
  uint64_t v135 = v2;
  float v137 = &v2[32 * v4];
  float v136 = v2 + 32;
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 5)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_20:
      char v12 = 0;
      goto LABEL_21;
    }
    BOOL v8 = *(_DWORD *)__p.__r_.__value_.__l.__data_ != 1936617315
      || *(unsigned char *)(__p.__r_.__value_.__r.__words[0] + 4) != 116;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v8) {
      goto LABEL_20;
    }
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 5) {
      goto LABEL_20;
    }
    if (LODWORD(__p.__r_.__value_.__l.__data_) != 1936617315 || __p.__r_.__value_.__s.__data_[4] != 116) {
      goto LABEL_20;
    }
  }
  ShaderConverter::NextToken(this);
  long long v9 = v136;
  if (v136 >= v137)
  {
    int v36 = v135;
    uint64_t v37 = (v136 - v135) >> 5;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 59) {
      goto LABEL_216;
    }
    uint64_t v39 = v137 - v135;
    if ((v137 - v135) >> 4 > v38) {
      unint64_t v38 = v39 >> 4;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v40 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      uint64_t v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v40);
      int v36 = v135;
      long long v9 = v136;
    }
    else
    {
      uint64_t v41 = 0;
    }
    uint64_t v66 = &v41[32 * v37];
    long long v67 = *(_OWORD *)((char *)this + 56);
    uint64_t v68 = &v41[32 * v40];
    *(_OWORD *)uint64_t v66 = *v3;
    *((_OWORD *)v66 + 1) = v67;
    std::string::size_type v11 = v66 + 32;
    if (v9 == v36)
    {
      unsigned __int16 v70 = v66;
    }
    else
    {
      do
      {
        long long v69 = *((_OWORD *)v9 - 2);
        unsigned __int16 v70 = v66 - 32;
        *(_OWORD *)(v66 - 20) = *(_OWORD *)(v9 - 20);
        *((_OWORD *)v66 - 2) = v69;
        v9 -= 32;
        v66 -= 32;
      }
      while (v9 != v36);
    }
    uint64_t v135 = v70;
    float v136 = v11;
    float v137 = v68;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    long long v10 = *(_OWORD *)((char *)this + 56);
    *(_OWORD *)float v136 = *v3;
    *((_OWORD *)v9 + 1) = v10;
    std::string::size_type v11 = v9 + 32;
  }
  float v136 = v11;
  if (*((_DWORD *)this + 16) == 13)
  {
    ShaderConverter::NextToken(this);
    uint64_t v71 = v136;
    if (v136 < v137)
    {
      long long v72 = *(_OWORD *)((char *)this + 56);
      *(_OWORD *)float v136 = *v3;
      *((_OWORD *)v71 + 1) = v72;
      double v73 = v71 + 32;
LABEL_149:
      float v136 = v73;
      char v12 = 1;
LABEL_21:
      Token::str((ShaderConverter *)((char *)this + 40), &v134);
      ShaderConverter::NextToken(this);
      int v13 = v136;
      if (v136 >= v137)
      {
        std::string::size_type v16 = v135;
        uint64_t v17 = (v136 - v135) >> 5;
        unint64_t v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 59) {
          goto LABEL_215;
        }
        uint64_t v19 = v137 - v135;
        if ((v137 - v135) >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20)
        {
          long long v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v20);
          std::string::size_type v16 = v135;
          int v13 = v136;
        }
        else
        {
          long long v21 = 0;
        }
        long long v22 = &v21[32 * v17];
        long long v23 = *(_OWORD *)((char *)this + 56);
        int v24 = &v21[32 * v20];
        *(_OWORD *)long long v22 = *v3;
        *((_OWORD *)v22 + 1) = v23;
        uint64_t v15 = v22 + 32;
        if (v13 == v16)
        {
          std::string::size_type v26 = v22;
        }
        else
        {
          do
          {
            long long v25 = *((_OWORD *)v13 - 2);
            std::string::size_type v26 = v22 - 32;
            *(_OWORD *)(v22 - 20) = *(_OWORD *)(v13 - 20);
            *((_OWORD *)v22 - 2) = v25;
            v13 -= 32;
            v22 -= 32;
          }
          while (v13 != v16);
        }
        uint64_t v135 = v26;
        float v136 = v15;
        float v137 = v24;
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        long long v14 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)float v136 = *v3;
        *((_OWORD *)v13 + 1) = v14;
        uint64_t v15 = v13 + 32;
      }
      float v136 = v15;
      if (*((_DWORD *)this + 16) != 13)
      {
        Statement::AddTokens(*((void *)this + 11), &v135);
        ShaderConverter::NextToken(this);
        *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
        LODWORD(v133.__r_.__value_.__l.__data_) = 15;
        std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)&v133, &v133);
        ShaderConverter::ParseRValue();
      }
      ShaderConverter::NextToken(this);
      uint64_t v27 = v136;
      if (v136 >= v137)
      {
        uint64_t v30 = v135;
        uint64_t v31 = (v136 - v135) >> 5;
        unint64_t v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 59) {
          goto LABEL_215;
        }
        uint64_t v33 = v137 - v135;
        if ((v137 - v135) >> 4 > v32) {
          unint64_t v32 = v33 >> 4;
        }
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v34 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v32;
        }
        if (v34)
        {
          std::string v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v34);
          uint64_t v30 = v135;
          uint64_t v27 = v136;
        }
        else
        {
          std::string v35 = 0;
        }
        CFArrayRef v42 = &v35[32 * v31];
        long long v43 = *(_OWORD *)((char *)this + 56);
        uint64_t v44 = &v35[32 * v34];
        *(_OWORD *)CFArrayRef v42 = *v3;
        *((_OWORD *)v42 + 1) = v43;
        uint64_t v29 = v42 + 32;
        if (v27 == v30)
        {
          int v46 = v42;
        }
        else
        {
          do
          {
            long long v45 = *((_OWORD *)v27 - 2);
            int v46 = v42 - 32;
            *(_OWORD *)(v42 - 20) = *(_OWORD *)(v27 - 20);
            *((_OWORD *)v42 - 2) = v45;
            v27 -= 32;
            v42 -= 32;
          }
          while (v27 != v30);
        }
        uint64_t v135 = v46;
        float v136 = v29;
        float v137 = v44;
        if (v30) {
          operator delete(v30);
        }
      }
      else
      {
        long long v28 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)float v136 = *v3;
        *((_OWORD *)v27 + 1) = v28;
        uint64_t v29 = v27 + 32;
      }
      float v136 = v29;
      int v47 = *((_DWORD *)this + 16);
      if (v47 != 1)
      {
        if (v47 == 5)
        {
          *((_DWORD *)this + 25) = 4;
          ShaderConverter::NextToken(this);
          uint64_t v48 = v136;
          if (v136 < v137)
          {
            long long v49 = *(_OWORD *)((char *)this + 56);
            *(_OWORD *)float v136 = *v3;
            *((_OWORD *)v48 + 1) = v49;
            int v50 = v48 + 32;
            goto LABEL_118;
          }
          unint64_t v54 = v135;
          uint64_t v55 = (v136 - v135) >> 5;
          unint64_t v56 = v55 + 1;
          if (!((unint64_t)(v55 + 1) >> 59))
          {
            uint64_t v57 = v137 - v135;
            if ((v137 - v135) >> 4 > v56) {
              unint64_t v56 = v57 >> 4;
            }
            if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v58 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v58 = v56;
            }
            if (v58)
            {
              BOOL v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v58);
              unint64_t v54 = v135;
              uint64_t v48 = v136;
            }
            else
            {
              BOOL v59 = 0;
            }
            unsigned __int16 v80 = &v59[32 * v55];
            long long v81 = *(_OWORD *)((char *)this + 56);
            long long v82 = &v59[32 * v58];
            *(_OWORD *)unsigned __int16 v80 = *v3;
            *((_OWORD *)v80 + 1) = v81;
            int v50 = v80 + 32;
            if (v48 == v54)
            {
              uint64_t v84 = v80;
            }
            else
            {
              do
              {
                long long v83 = *((_OWORD *)v48 - 2);
                uint64_t v84 = v80 - 32;
                *(_OWORD *)(v80 - 20) = *(_OWORD *)(v48 - 20);
                *((_OWORD *)v80 - 2) = v83;
                v48 -= 32;
                v80 -= 32;
              }
              while (v48 != v54);
            }
            uint64_t v135 = v84;
            float v136 = v50;
            float v137 = v82;
            if (v54) {
              operator delete(v54);
            }
LABEL_118:
            float v136 = v50;
            Statement::AddTokens(*((void *)this + 11), &v135);
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
            LODWORD(v133.__r_.__value_.__l.__data_) = 15;
            std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)&v133, &v133);
            ShaderConverter::ParseRValue();
          }
LABEL_215:
          abort();
        }
        Token::str((ShaderConverter *)((char *)this + 40), &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        Statement::AddTokens(*((void *)this + 11), &v135);
        goto LABEL_119;
      }
      Token::str((ShaderConverter *)((char *)this + 40), &v133);
      ShaderConverter::NextToken(this);
      int v51 = v136;
      if (v136 >= v137)
      {
        long long v60 = v135;
        uint64_t v61 = (v136 - v135) >> 5;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 59) {
          goto LABEL_217;
        }
        uint64_t v63 = v137 - v135;
        if ((v137 - v135) >> 4 > v62) {
          unint64_t v62 = v63 >> 4;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v64 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64)
        {
          int v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v64);
          long long v60 = v135;
          int v51 = v136;
        }
        else
        {
          int v65 = 0;
        }
        uint64_t v85 = &v65[32 * v61];
        long long v86 = *(_OWORD *)((char *)this + 56);
        unsigned __int16 v87 = &v65[32 * v64];
        *(_OWORD *)uint64_t v85 = *v3;
        *((_OWORD *)v85 + 1) = v86;
        long long v53 = v85 + 32;
        if (v51 == v60)
        {
          float32x4_t v89 = v85;
        }
        else
        {
          do
          {
            long long v88 = *((_OWORD *)v51 - 2);
            float32x4_t v89 = v85 - 32;
            *(_OWORD *)(v85 - 20) = *(_OWORD *)(v51 - 20);
            *((_OWORD *)v85 - 2) = v88;
            v51 -= 32;
            v85 -= 32;
          }
          while (v51 != v60);
        }
        uint64_t v135 = v89;
        float v136 = v53;
        float v137 = v87;
        if (v60) {
          operator delete(v60);
        }
      }
      else
      {
        long long v52 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)float v136 = *v3;
        *((_OWORD *)v51 + 1) = v52;
        long long v53 = v51 + 32;
      }
      float v136 = v53;
      int v90 = *((_DWORD *)this + 16);
      if (v90 != 13)
      {
LABEL_158:
        if (v90 == 6)
        {
          if ((*((_DWORD *)this + 25) - 1) <= 1) {
            *((_DWORD *)this + 25) = 3;
          }
          Statement::AddTokens(*((void *)this + 11), &v135);
          ShaderConverter::NextToken(this);
          int v110 = *((_DWORD *)this + 16);
          if (v110) {
            BOOL v111 = v110 == 7;
          }
          else {
            BOOL v111 = 1;
          }
          if (!v111) {
            ShaderConverter::ParseFunctionArgument(this);
          }
          Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
        }
        memset(&v132, 0, sizeof(v132));
        if (v90 == 10)
        {
          while (v90 && v90 != 11)
          {
            Token::str((ShaderConverter *)((char *)this + 40), &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_p = &__p;
            }
            else {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type size = __p.__r_.__value_.__l.__size_;
            }
            std::string::append(&v132, (const std::string::value_type *)p_p, size);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            ShaderConverter::NextToken(this);
            int v90 = *((_DWORD *)this + 16);
            if (!v90)
            {
              Token::str((ShaderConverter *)((char *)this + 40), &__p);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              int v90 = *((_DWORD *)this + 16);
            }
          }
          Token::str((ShaderConverter *)((char *)this + 40), &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v114 = &__p;
          }
          else {
            uint64_t v114 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v115 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v115 = __p.__r_.__value_.__l.__size_;
          }
          std::string::append(&v132, (const std::string::value_type *)v114, v115);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          ShaderConverter::NextToken(this);
          int v90 = *((_DWORD *)this + 16);
          if (v90 == 13)
          {
            ShaderConverter::NextToken(this);
            int v90 = *((_DWORD *)this + 16);
          }
        }
        if (v90 == 5)
        {
          ShaderConverter::NextToken(this);
          std::vector<Token>::push_back[abi:nn180100]((void **)&v135, (ShaderConverter *)((char *)this + 40));
          if ((v12 & 1) != 0 || *((_DWORD *)this + 25) == 3)
          {
            std::string::basic_string[abi:nn180100]<0>(&__p, "constant");
            Statement::AddToken();
          }
          Statement::AddTokens(*((void *)this + 11), &v135);
          *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
          LODWORD(v123[0]) = 15;
          std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)v123, v123);
          ShaderConverter::ParseRValue();
        }
        if (v90 == 15)
        {
          std::string::basic_string[abi:nn180100]<0>(v123, "");
          Variable::Variable(&__p, (long long *)&v133, (long long *)&v134, (long long *)v123, (long long *)&v132);
          unint64_t v116 = *((void *)this + 17);
          if (v116 >= *((void *)this + 18))
          {
            uint64_t v121 = std::vector<Variable>::__push_back_slow_path<Variable>((uint64_t *)this + 16, (long long *)&__p);
            int v122 = SHIBYTE(v131);
            *((void *)this + 17) = v121;
            if (v122 < 0) {
              operator delete(v130[0]);
            }
          }
          else
          {
            long long v117 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(void *)(v116 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)unint64_t v116 = v117;
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
            uint64_t v118 = v127;
            *(_OWORD *)(v116 + 24) = *(_OWORD *)v126;
            *(void *)(v116 + 40) = v118;
            __p.__r_.__value_.__r.__words[2] = 0;
            v126[0] = 0;
            v126[1] = 0;
            uint64_t v127 = 0;
            long long v119 = *(_OWORD *)v128;
            *(void *)(v116 + 64) = v129;
            *(_OWORD *)(v116 + 4_Block_object_dispose(&STACK[0x690], 8) = v119;
            v128[0] = 0;
            v128[1] = 0;
            long long v120 = *(_OWORD *)v130;
            *(void *)(v116 + 8_Block_object_dispose(&STACK[0x690], 8) = v131;
            *(_OWORD *)(v116 + 72) = v120;
            uint64_t v129 = 0;
            v130[0] = 0;
            v130[1] = 0;
            uint64_t v131 = 0;
            *((void *)this + 17) = v116 + 96;
          }
          if (SHIBYTE(v129) < 0) {
            operator delete(v128[0]);
          }
          if (SHIBYTE(v127) < 0) {
            operator delete(v126[0]);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (v124 < 0) {
            operator delete(v123[0]);
          }
          std::string::basic_string[abi:nn180100]<0>(&__p, "constant");
          Statement::AddToken();
        }
        if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v132.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v133.__r_.__value_.__l.__data_);
        }
LABEL_119:
        if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v134.__r_.__value_.__l.__data_);
        }
        goto LABEL_121;
      }
      ShaderConverter::NextToken(this);
      uint64_t v91 = v136;
      if (v136 < v137)
      {
        long long v92 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)float v136 = *v3;
        *((_OWORD *)v91 + 1) = v92;
        float v93 = v91 + 32;
LABEL_157:
        float v136 = v93;
        int v90 = *((_DWORD *)this + 16);
        goto LABEL_158;
      }
      float32x2_t v94 = v135;
      uint64_t v95 = (v136 - v135) >> 5;
      unint64_t v96 = v95 + 1;
      if (!((unint64_t)(v95 + 1) >> 59))
      {
        uint64_t v97 = v137 - v135;
        if ((v137 - v135) >> 4 > v96) {
          unint64_t v96 = v97 >> 4;
        }
        if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v98 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v98 = v96;
        }
        if (v98)
        {
          __int16 v99 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v98);
          float32x2_t v94 = v135;
          uint64_t v91 = v136;
        }
        else
        {
          __int16 v99 = 0;
        }
        float32x4_t v105 = &v99[32 * v95];
        long long v106 = *(_OWORD *)((char *)this + 56);
        unsigned int v107 = &v99[32 * v98];
        *(_OWORD *)float32x4_t v105 = *v3;
        *((_OWORD *)v105 + 1) = v106;
        float v93 = v105 + 32;
        if (v91 == v94)
        {
          int v109 = v105;
        }
        else
        {
          do
          {
            long long v108 = *((_OWORD *)v91 - 2);
            int v109 = v105 - 32;
            *(_OWORD *)(v105 - 20) = *(_OWORD *)(v91 - 20);
            *((_OWORD *)v105 - 2) = v108;
            v91 -= 32;
            v105 -= 32;
          }
          while (v91 != v94);
        }
        uint64_t v135 = v109;
        float v136 = v93;
        float v137 = v107;
        if (v94) {
          operator delete(v94);
        }
        goto LABEL_157;
      }
LABEL_217:
      abort();
    }
    float v74 = v135;
    uint64_t v75 = (v136 - v135) >> 5;
    unint64_t v76 = v75 + 1;
    if (!((unint64_t)(v75 + 1) >> 59))
    {
      uint64_t v77 = v137 - v135;
      if ((v137 - v135) >> 4 > v76) {
        unint64_t v76 = v77 >> 4;
      }
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v78 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v78 = v76;
      }
      if (v78)
      {
        unsigned __int16 v79 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v137, v78);
        float v74 = v135;
        uint64_t v71 = v136;
      }
      else
      {
        unsigned __int16 v79 = 0;
      }
      uint64_t v100 = &v79[32 * v75];
      long long v101 = *(_OWORD *)((char *)this + 56);
      int v102 = &v79[32 * v78];
      *(_OWORD *)uint64_t v100 = *v3;
      *((_OWORD *)v100 + 1) = v101;
      double v73 = v100 + 32;
      if (v71 == v74)
      {
        uint64_t v104 = v100;
      }
      else
      {
        do
        {
          long long v103 = *((_OWORD *)v71 - 2);
          uint64_t v104 = v100 - 32;
          *(_OWORD *)(v100 - 20) = *(_OWORD *)(v71 - 20);
          *((_OWORD *)v100 - 2) = v103;
          v71 -= 32;
          v100 -= 32;
        }
        while (v71 != v74);
      }
      uint64_t v135 = v104;
      float v136 = v73;
      float v137 = v102;
      if (v74) {
        operator delete(v74);
      }
      goto LABEL_149;
    }
LABEL_216:
    abort();
  }
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  Statement::AddTokens(*((void *)this + 11), &v135);
LABEL_121:
  if (v135)
  {
    float v136 = v135;
    operator delete(v135);
  }
}

void sub_20B2C6058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  std::__tree<char>::destroy((uint64_t)&a16, a17);
  if (a36 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v36 - 113) < 0) {
    operator delete(*(void **)(v36 - 136));
  }
  if (*(char *)(v36 - 89) < 0) {
    operator delete(*(void **)(v36 - 112));
  }
  unint64_t v38 = *(void **)(v36 - 88);
  if (v38)
  {
    *(void *)(v36 - 80) = v38;
    operator delete(v38);
  }
  _Unwind_Resume(a1);
}

void std::vector<Token>::push_back[abi:nn180100](void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((char *)v7 - (unsigned char *)*a1) >> 5;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 59) {
      abort();
    }
    uint64_t v12 = v5 - (void)*a1;
    if (v12 >> 4 > v11) {
      unint64_t v11 = v12 >> 4;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(v4, v13);
    }
    else {
      long long v14 = 0;
    }
    uint64_t v15 = &v14[32 * v10];
    std::string::size_type v16 = &v14[32 * v13];
    long long v17 = a2[1];
    *(_OWORD *)uint64_t v15 = *a2;
    *((_OWORD *)v15 + 1) = v17;
    long long v9 = v15 + 32;
    uint64_t v19 = (char *)*a1;
    unint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *((_OWORD *)v18 - 2);
        *(_OWORD *)(v15 - 20) = *(_OWORD *)(v18 - 20);
        *((_OWORD *)v15 - 2) = v20;
        v15 -= 32;
        v18 -= 32;
      }
      while (v18 != v19);
      unint64_t v18 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    long long v8 = a2[1];
    _OWORD *v7 = *a2;
    v7[1] = v8;
    long long v9 = v7 + 2;
  }
  a1[1] = v9;
}

void ShaderConverter::ParseRValue()
{
}

void sub_20B2C64B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ShaderConverter::OutputCode(uint64_t a1, uint64_t a2, std::string *this)
{
  if (*(char *)(a1 + 31) < 0) {
    unint64_t v6 = *(void *)(a1 + 16);
  }
  else {
    unint64_t v6 = *(unsigned __int8 *)(a1 + 31);
  }
  std::string::reserve(this, vcvtmd_u64_f64((double)v6 * 1.2));
  if (*(void *)(a1 + 104) != *(void *)(a1 + 112) || *(void *)(a1 + 152) != *(void *)(a1 + 160))
  {
    std::string::append(this, "#pragma arguments\n");
    uint64_t v7 = *(std::string **)(a1 + 104);
    long long v8 = *(std::string **)(a1 + 112);
    while (v7 != v8)
    {
      Variable::Output(v7, a1, a2, this);
      v7 += 4;
    }
    long long v9 = *(uint64_t **)(a1 + 152);
    uint64_t v10 = *(uint64_t **)(a1 + 160);
    while (v9 != v10)
    {
      uint64_t v11 = *v9++;
      TextureLookup::OutputUniformDeclaration(v11, a1, a2, this);
    }
  }
  if (*(unsigned char *)(a1 + 96)) {
    uint64_t v12 = "#pragma declaration\n";
  }
  else {
    uint64_t v12 = "#pragma body\n";
  }
  std::string::append(this, v12);
  unint64_t v13 = *(uint64_t (**)(void))(**(void **)(a1 + 88) + 16);

  return v13();
}

void TextureLookup::OutputUniformDeclaration(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  memset(&v7, 0, sizeof(v7));
  (*(void (**)(void, uint64_t, uint64_t, std::string *))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2, a3, &v7);
  if (std::string::compare(&v7, 0, 2uLL, "u_"))
  {
    std::string::append(a4, "sampler ");
    if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v5 = &v7;
    }
    else {
      unint64_t v5 = (std::string *)v7.__r_.__value_.__r.__words[0];
    }
    if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v7.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v7.__r_.__value_.__l.__size_;
    }
    std::string::append(a4, (const std::string::value_type *)v5, size);
    std::string::append(a4, "Sampler\n");
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
}

void sub_20B2C66E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void C3DConvertGLSLShaderToMetal(NSString *a1)
{
  ShaderConverter::ShaderConverter((ShaderConverter *)v1, a1);
  ShaderConverter::Parse(v1);
}

void sub_20B2C68D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  ShaderConverter::~ShaderConverter((ShaderConverter *)&a22);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

std::string *TokenStatement::Output(std::string *result, uint64_t a2, int a3, std::string *this)
{
  if (LODWORD(result[2].__r_.__value_.__r.__words[1]) == 1)
  {
    if (a3 == 2)
    {
      uint64_t v11 = ShaderConverter::GLSLToMetalSymbol(a2, (const void **)&result[1].__r_.__value_.__l.__size_);
    }
    else
    {
      if (a3 != 1)
      {
        if (a3) {
          return result;
        }
        goto LABEL_5;
      }
      uint64_t v11 = ShaderConverter::MetalToGLSLSymbol((uint64_t)result, (const void **)&result[1].__r_.__value_.__l.__size_);
    }
    int v12 = *((char *)v11 + 23);
    if (v12 >= 0) {
      long long v9 = (const std::string::value_type *)v11;
    }
    else {
      long long v9 = (const std::string::value_type *)*v11;
    }
    if (v12 >= 0) {
      std::string::size_type v10 = *((unsigned __int8 *)v11 + 23);
    }
    else {
      std::string::size_type v10 = (std::string::size_type)v11[1];
    }
    goto LABEL_19;
  }
LABEL_5:
  std::string::size_type size = result[1].__r_.__value_.__l.__size_;
  unint64_t v5 = &result[1].__r_.__value_.__s.__data_[8];
  unint64_t v6 = (const std::string::value_type *)size;
  int v8 = v5[23];
  if (v8 >= 0) {
    long long v9 = v5;
  }
  else {
    long long v9 = v6;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = v5[23];
  }
  else {
    std::string::size_type v10 = *((void *)v5 + 1);
  }
LABEL_19:

  return std::string::append(this, v9, v10);
}

uint64_t Statement::Output(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(result + 8);
  for (uint64_t i = *(uint64_t **)(result + 16);
        v4 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16))(v9, a2, a3, a4))
  {
    uint64_t v9 = *v4++;
  }
  return result;
}

void *TextureLookup::TextureLookup(void *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  *a1 = &unk_26BF696F8;
  uint64_t v9 = (std::string *)(a1 + 4);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v10 = *a2;
    v9->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  a1[7] = a3;
  a1[8] = a4;
  a1[9] = a5;
  return a1;
}

void sub_20B2C6B88(_Unwind_Exception *a1)
{
  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

void TextureLookup::~TextureLookup(TextureLookup *this)
{
  TextureLookup::~TextureLookup(this);

  JUMPOUT(0x210534FE0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_26BF696F8;
  int v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = *((void *)this + 8);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 9);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(*((void **)this + 4));
  }

  Statement::~Statement(this);
}

std::string *TextureLookup::Output(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  (*(void (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
  std::string::append(a4, ".sample(");
  (*(void (**)(void, uint64_t, uint64_t, std::string *))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2, a3, a4);
  std::string::append(a4, "Sampler");
  std::string::append(a4, ", ");
  (*(void (**)(void, uint64_t, uint64_t, std::string *))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), a2, a3, a4);
  if (*(void *)(a1 + 72))
  {
    if (*(char *)(a1 + 55) < 0) {
      uint64_t v8 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v8 = *(unsigned __int8 *)(a1 + 55);
    }
    if (!std::string::compare((const std::string *)(a1 + 32), v8 - 3, 3uLL, "Lod")) {
      uint64_t v9 = ", level(";
    }
    else {
      uint64_t v9 = ", bias(";
    }
    std::string::append(a4, v9);
    (*(void (**)(void, uint64_t, uint64_t, std::string *))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72), a2, a3, a4);
    std::string::append(a4, ")");
  }

  return std::string::append(a4, ")");
}

uint64_t MatrixCTOR::MatrixCTOR(uint64_t a1, long long *a2, uint64_t a3, int a4, int a5)
{
  *(void *)(a1 + _Block_object_dispose(&STACK[0x690], 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26BF69238;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 32), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x690], 8) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 32) = v9;
  }
  std::vector<Statement *>::vector((void *)(a1 + 56), a3);
  *(_DWORD *)(a1 + 80) = a4;
  *(_DWORD *)(a1 + 84) = a5;
  return a1;
}

void sub_20B2C6F08(_Unwind_Exception *a1)
{
  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

void MatrixCTOR::~MatrixCTOR(MatrixCTOR *this)
{
  MatrixCTOR::~MatrixCTOR(this);

  JUMPOUT(0x210534FE0);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF69238;
  int v2 = (void *)*((void *)this + 7);
  int v3 = (void *)*((void *)this + 8);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    int v2 = (void *)*((void *)this + 7);
  }
  if (v2)
  {
    *((void *)this + _Block_object_dispose(&STACK[0x690], 8) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(*((void **)this + 4));
  }

  Statement::~Statement(this);
}

void MatrixCTOR::Output(uint64_t a1, uint64_t a2, uint64_t a3, std::string *this)
{
  std::string v7 = (const void **)(a1 + 32);
  if (a3 == 2)
  {
    uint64_t v8 = ShaderConverter::GLSLToMetalSymbol(a2, v7);
    int v9 = *((char *)v8 + 23);
    if (v9 >= 0) {
      long long v10 = (const std::string::value_type *)v8;
    }
    else {
      long long v10 = (const std::string::value_type *)*v8;
    }
    if (v9 >= 0) {
      std::string::size_type v11 = *((unsigned __int8 *)v8 + 23);
    }
    else {
      std::string::size_type v11 = (std::string::size_type)v8[1];
    }
    std::string::append(this, v10, v11);
    uint64_t v12 = *(void *)(a1 + 64) - *(void *)(a1 + 56);
    uint64_t v13 = *(int *)(a1 + 84) * (uint64_t)*(int *)(a1 + 80);
    std::string::append(this, "(");
    if (v13 == v12 >> 3)
    {
      std::string __p = 0;
      std::string::size_type v33 = 0;
      uint64_t v34 = 0;
      unsigned int v14 = *(_DWORD *)(a1 + 84) - 2;
      if (v14 < 3) {
        MEMORY[0x210534E80](&__p, off_2640047A8[v14]);
      }
      if (*(int *)(a1 + 80) >= 1)
      {
        int v15 = 0;
        char v16 = 1;
        do
        {
          if ((v16 & 1) == 0) {
            std::string::append(this, ", ");
          }
          if (v34 >= 0) {
            p_p = (const std::string::value_type *)&__p;
          }
          else {
            p_p = (const std::string::value_type *)__p;
          }
          if (v34 >= 0) {
            std::string::size_type v18 = HIBYTE(v34);
          }
          else {
            std::string::size_type v18 = v33;
          }
          std::string::append(this, p_p, v18);
          if (*(int *)(a1 + 84) >= 1)
          {
            uint64_t v19 = 0;
            char v20 = 1;
            do
            {
              if ((v20 & 1) == 0) {
                std::string::append(this, ", ");
              }
              uint64_t v21 = *(void *)(*(void *)(a1 + 56) + 8 * (v19 + *(int *)(a1 + 80) * (uint64_t)v15));
              (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(void *)v21 + 16))(v21, a2, 2, this);
              char v20 = 0;
              ++v19;
            }
            while ((int)v19 < *(_DWORD *)(a1 + 84));
          }
          std::string::append(this, ")");
          char v16 = 0;
          ++v15;
        }
        while (v15 < *(_DWORD *)(a1 + 80));
      }
      std::string::append(this, ")");
      if (SHIBYTE(v34) < 0) {
        operator delete(__p);
      }
      return;
    }
    long long v28 = *(uint64_t **)(a1 + 56);
    uint64_t v29 = *(uint64_t **)(a1 + 64);
    if (v28 != v29)
    {
      char v30 = 1;
      do
      {
        uint64_t v31 = *v28;
        if ((v30 & 1) == 0) {
          std::string::append(this, ", ");
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(void *)v31 + 16))(v31, a2, 2, this);
        char v30 = 0;
        ++v28;
      }
      while (v28 != v29);
    }
  }
  else
  {
    if (*(char *)(a1 + 55) >= 0)
    {
      std::string::size_type v23 = *(unsigned __int8 *)(a1 + 55);
    }
    else
    {
      std::string v7 = *(const void ***)(a1 + 32);
      std::string::size_type v23 = *(void *)(a1 + 40);
    }
    std::string::append(this, (const std::string::value_type *)v7, v23);
    std::string::append(this, "(");
    int v24 = *(uint64_t **)(a1 + 56);
    long long v25 = *(uint64_t **)(a1 + 64);
    if (v24 != v25)
    {
      char v26 = 1;
      do
      {
        uint64_t v27 = *v24;
        if ((v26 & 1) == 0) {
          std::string::append(this, ", ");
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(void *)v27 + 16))(v27, a2, a3, this);
        char v26 = 0;
        ++v24;
      }
      while (v24 != v25);
    }
  }

  std::string::append(this, ")");
}

void sub_20B2C72A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<Statement *>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<Statement *>::__vallocate[abi:nn180100](a1, v5 >> 3);
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<Statement *>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void BodyStatement::~BodyStatement(BodyStatement *this)
{
  Statement::~Statement(this);

  JUMPOUT(0x210534FE0);
}

std::string *BodyStatement::Output(int a1, int a2, int a3, std::string *this)
{
  return std::string::append(this, "\n");
}

std::string *std::pair<std::string const,std::string>::pair[abi:nn180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  int64_t v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

void sub_20B2C74F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::allocator<Variable>::destroy[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 95) < 0) {
    operator delete(*(void **)(a2 + 72));
  }
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*(void **)(a2 + 48));
  }
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t std::vector<Variable>::__push_back_slow_path<Variable>(uint64_t *a1, long long *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  uint64_t v8 = a1[2];
  std::string v7 = a1 + 2;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 5);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x155555555555555) {
    unint64_t v10 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v4;
  }
  v19[4] = v7;
  if (v10) {
    std::string::size_type v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Variable>>((uint64_t)v7, v10);
  }
  else {
    std::string::size_type v11 = 0;
  }
  uint64_t v12 = &v11[96 * v3];
  v19[0] = v11;
  v19[1] = v12;
  v19[3] = &v11[96 * v10];
  long long v13 = *a2;
  *((void *)v12 + 2) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v12 = v13;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v14 = *(long long *)((char *)a2 + 24);
  *((void *)v12 + 5) = *((void *)a2 + 5);
  *(_OWORD *)(v12 + 24) = v14;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  long long v15 = a2[3];
  *((void *)v12 + _Block_object_dispose(&STACK[0x690], 8) = *((void *)a2 + 8);
  *((_OWORD *)v12 + 3) = v15;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + _Block_object_dispose(&STACK[0x690], 8) = 0;
  long long v16 = *(long long *)((char *)a2 + 72);
  *((void *)v12 + 11) = *((void *)a2 + 11);
  *(_OWORD *)(v12 + 72) = v16;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  v19[2] = v12 + 96;
  std::vector<Variable>::__swap_out_circular_buffer(a1, v19);
  uint64_t v17 = a1[1];
  std::__split_buffer<Variable>::~__split_buffer(v19);
  return v17;
}

void sub_20B2C7728(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Variable>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<Variable>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 96;
      long long v6 = *(_OWORD *)(v3 - 96);
      *(void *)(v4 - 80) = *(void *)(v3 - 80);
      *(_OWORD *)(v4 - 96) = v6;
      *(void *)(v3 - 8_Block_object_dispose(&STACK[0x690], 8) = 0;
      *(void *)(v3 - 80) = 0;
      *(void *)(v3 - 96) = 0;
      long long v7 = *(_OWORD *)(v3 - 72);
      *(void *)(v4 - 56) = *(void *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v7;
      *(void *)(v3 - 64) = 0;
      *(void *)(v3 - 56) = 0;
      *(void *)(v3 - 72) = 0;
      long long v8 = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 4_Block_object_dispose(&STACK[0x690], 8) = v8;
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 4_Block_object_dispose(&STACK[0x690], 8) = 0;
      long long v9 = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - _Block_object_dispose(&STACK[0x690], 8) = *(void *)(v3 - 8);
      *(_OWORD *)(v4 - 24) = v9;
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - _Block_object_dispose(&STACK[0x690], 8) = 0;
      v3 -= 96;
      v4 -= 96;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v10 = *result;
  *uint64_t result = v5;
  a2[1] = v10;
  uint64_t v11 = result[1];
  result[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = result[2];
  result[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Variable>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(96 * a2);
}

void **std::__split_buffer<Variable>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<Variable>::clear[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 96;
    std::allocator<Variable>::destroy[abi:nn180100](v4, i - 96);
  }
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  uint64_t result = *v5;
  if (!*v5)
  {
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::string>::__construct_node<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  long long v6 = (char *)operator new(0x38uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  long long v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_20B2C79D0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  long long v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  long long v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x690], 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  long long v7 = (std::string *)(v6 + 32);
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_20B2C7B10(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>(uint64_t **a1, int *a2, _DWORD *a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        long long v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        long long v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_20B2C7CD8(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C40F7E7E543);
  _Unwind_Resume(a1);
}

void sub_20B2C7E00(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C40F7E7E543);
  _Unwind_Resume(a1);
}

void SCNCActionHide::~SCNCActionHide(SCNCActionHide *this)
{
  SCNCAction::~SCNCAction((SCNCAction *)this);

  JUMPOUT(0x210534FE0);
}

SCNCActionHide *SCNCActionHide::cpp_updateWithTargetForTime(SCNCActionHide *this, SCNNode *a2, double a3)
{
  if (!this->var10)
  {
    uint64_t v5 = this;
    [(SCNNode *)a2 setHidden:this->var19];
    long long v6 = (uint64_t (*)(SCNCActionHide *, SCNNode *, __n128))*((void *)v5->var0 + 14);
    v7.n128_f64[0] = a3;
    return (SCNCActionHide *)v6(v5, a2, v7);
  }
  return this;
}

SCNCActionHide *SCNCActionHide::cpp_backwardUpdateWithTargetForTime(SCNCActionHide *this, SCNNode *a2, double a3)
{
  if (!this->var10)
  {
    uint64_t v5 = this;
    [(SCNNode *)a2 setHidden:!this->var19];
    long long v6 = (uint64_t (*)(SCNCActionHide *, SCNNode *, __n128))*((void *)v5->var0 + 14);
    v7.n128_f64[0] = a3;
    return (SCNCActionHide *)v6(v5, a2, v7);
  }
  return this;
}

void __CopyParticles(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)((char *)&v30[1] + 4) = *MEMORY[0x263EF8340];
  if (a1 == (unsigned int *)a3)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      __CopyParticles_cold_2(v10, v11, v12);
    }
  }
  if (a1[244])
  {
    unint64_t v13 = 0;
    do
    {
      long long v14 = &a1[2 * v13];
      if (*((void *)v14 + 90))
      {
        int v15 = *((unsigned __int8 *)a1 + v13 + 980);
        uint64_t v16 = *(unsigned int *)(a3 + 976);
        if (!v16) {
          goto LABEL_14;
        }
        uint64_t v17 = a1[v13 + 148];
        std::string::size_type v18 = (unsigned __int8 *)(a3 + 980);
        while (1)
        {
          int v19 = *v18++;
          if (v19 == v15) {
            break;
          }
          if (!--v16) {
            goto LABEL_14;
          }
        }
        if (*(_DWORD *)(a3 + 592 + 4 * v13) == v17)
        {
          memcpy((void *)(*(void *)&a1[2 * v13] + v17 * a2), (const void *)(*(void *)(a3 + 8 * v13) + v17 * a4), v17 * a5);
        }
        else
        {
LABEL_14:
          if (v15 == 3)
          {
            uint64_t v20 = *(void *)&a1[2 * v13];
            if (!v20)
            {
              uint64_t v21 = scn_default_log();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
                __CopyParticles_cold_1(v29, v30, v21);
              }
            }
            ParticleLifeunint64_t Span = C3DParticleSystemGetParticleLifeSpan(*(void *)(a6 + 48));
            if (a5 >= 1)
            {
              uint64_t v23 = a2;
              float v24 = 1.0 / ParticleLifeSpan;
              do
                *(float *)(v20 + 4 * v23++) = v24;
              while (v23 < a5 + a2);
            }
          }
          else
          {
            long long v25 = (void (**)(_OWORD *, void, uint64_t))(v14 + 180);
            memset(v28, 0, 512);
            C3DParticleContextSetup((uint64_t)v28, a6, a1, 0.0, 0.0);
            (*v25)(v28, 0, a5);
          }
        }
      }
      ++v13;
    }
    while (v13 < a1[244]);
  }
}

void __DestroyParticles(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 976);
  if (v1)
  {
    for (unint64_t i = 0; i < v1; ++i)
    {
      uint64_t v4 = *(void **)(a1 + 8 * i);
      if (v4)
      {
        free(v4);
        unint64_t v1 = *(unsigned int *)(a1 + 976);
      }
      *(void *)(a1 + 8 * i) = 0;
    }
  }
}

uint64_t _C3DParticleSystemInstanceAllocateParticlesData(unsigned int *a1, const void *a2, unsigned int a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__src, 0x250uLL);
  memcpy(&__src[148], a2, 0x1B0uLL);
  if (a3)
  {
    unint64_t v6 = __src[244];
    if (__src[244])
    {
      uint64_t v7 = 0;
      for (uint64_t i = 148; i - 148 < v6; ++i)
      {
        unsigned int v9 = __src[i];
        if (v9)
        {
          if (malloc_type_posix_memalign((void **)&__src[v7], 0x40uLL, v9 * a3, 0xC5C365A3uLL)) {
            return 0;
          }
          unint64_t v6 = __src[244];
        }
        v7 += 2;
      }
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = (unsigned __int8 *)&__src[250] + 1;
  do
  {
    uint64_t v12 = *(v11 - 21);
    if (v12 != 255)
    {
      uint64_t v13 = *(void *)&__src[2 * v12];
      *(void *)&__src[v10 + 64] = v13;
      uint64_t v14 = *v11;
      if (v14 != 255) {
        uint64_t v13 = *(void *)&__src[2 * v14];
      }
      *(void *)&__src[v10 + 106] = v13;
    }
    v10 += 2;
    ++v11;
  }
  while (v10 != 42);
  uint64_t v15 = a1[276];
  if (v15) {
    __CopyParticles(__src, 0, (uint64_t)(a1 + 20), 0, v15, (uint64_t)a1);
  }
  __DestroyParticles((uint64_t)(a1 + 20));
  memcpy(a1 + 20, __src, 0x400uLL);
  a1[278] = a3;
  a1[277] = 0;
  return 1;
}

uint64_t C3DParticleSystemInstanceGetTypeID()
{
  if (C3DParticleSystemInstanceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParticleSystemInstanceGetTypeID_onceToken, &__block_literal_global_3);
  }
  return C3DParticleSystemInstanceGetTypeID_typeID;
}

void _C3DParticleSystemInstanceCFFinalize(uint64_t a1)
{
  free(*(void **)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  __DestroyParticles(a1 + 80);
  *(_DWORD *)(a1 + 1104) = 0;
  *(_DWORD *)(a1 + 1112) = 0;
  if (*(_DWORD *)(a1 + 1188))
  {
    uint64_t EnginePipeline = C3DSceneGetEnginePipeline(*(void *)(a1 + 64));
    if (EnginePipeline)
    {
      uint64_t v3 = EnginePipeline;
      uint64_t v4 = *(void *)(EnginePipeline + 48);
      if (v4) {
        __C3DRendererElementStoreDeallocateSpan(v4, *(void *)(a1 + 1184), v3);
      }
    }
  }
  uint64_t v5 = *(const void **)(a1 + 1192);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 1192) = 0;
  }
  unint64_t v6 = *(const void **)(a1 + 1200);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 1200) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 48);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x690], 8) = 0;
  }
}

CFStringRef _C3DParticleSystemInstanceCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleSystemInstanceRef>");
}

CFStringRef _C3DParticleSystemInstanceCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleSystemInstanceRef>");
}

uint64_t __C3DParticleSystemInstanceGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DParticleSystemInstanceGetTypeID_typeID = result;
  return result;
}

uint64_t C3DParticleSystemInstanceCreate(uint64_t a1, const void *a2, uint64_t a3)
{
  if (C3DParticleSystemInstanceGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParticleSystemInstanceGetTypeID_onceToken, &__block_literal_global_3);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DParticleSystemInstanceGetTypeID_typeID, 0x4B0uLL);
  uint64_t URL = C3DSceneSourceGetURL(a3);
  *(void *)(Instance + 40) = a1;
  uint64_t v8 = *(const void **)(Instance + 48);
  if (v8 != a2)
  {
    if (v8)
    {
      CFRelease(v8);
      *(void *)(Instance + 4_Block_object_dispose(&STACK[0x690], 8) = 0;
    }
    if (a2) {
      CFRetain(a2);
    }
  }
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x690], 8) = a2;
  *(void *)(Instance + 56) = a3;
  *(void *)(Instance + 64) = URL;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  *(void *)(Instance + 1192) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 1, MEMORY[0x263EFFF70]);
  *(void *)(Instance + 1200) = CFArrayCreateMutable(v9, 1, v10);
  int Seed = C3DParticleSystemGetSeed((uint64_t)a2);
  *(_DWORD *)(Instance + 1116) = Seed;
  if (!Seed) {
    *(_DWORD *)(Instance + 1116) = random();
  }
  return Instance;
}

uint64_t C3DParticleSystemInstanceGetParticlesCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1104);
}

uint64_t C3DParticleSystemInstanceSetNode(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = a2;
  return result;
}

uint64_t C3DParticleSystemInstanceGetSystem(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

__n128 C3DParticleSystemInstanceGetWorldBoundingBox(uint64_t a1)
{
  if (C3DParticleSystemGetIsLocal(*(void *)(a1 + 48)) && (uint64_t v2 = *(float32x4_t **)(a1 + 40)) != 0)
  {
    WorldMatrix = C3DNodeGetWorldMatrix(v2);
    result.n128_u64[0] = vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(WorldMatrix[1], *(float32x2_t *)(a1 + 1152), 1), *WorldMatrix, COERCE_FLOAT(*(_OWORD *)(a1 + 1152))), WorldMatrix[2], *(float32x4_t *)(a1 + 1152), 2)).u64[0];
  }
  else
  {
    return *(__n128 *)(a1 + 1152);
  }
  return result;
}

uint64_t __C3DParticleSystemInstanceComputeDepth(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(float **)(result + 632);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(result + 1104);
    if (v3)
    {
      uint64_t v4 = *(float32x4_t **)(result + 504);
      float32x4_t v5 = (float32x4_t)vuzp2q_s32(vuzp2q_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 16)), *(int32x4_t *)a2);
      v5.i32[2] = *(_DWORD *)(a2 + 44);
      float v6 = *(float *)(a2 + 60);
      do
      {
        float32x4_t v7 = *v4++;
        float32x4_t v8 = vmulq_f32(v5, v7);
        *v2++ = v6
              + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

uint64_t __C3DParticleSystemInstanceComputeDistance(uint64_t result, float32x4_t *a2)
{
  uint64_t v2 = *(_DWORD **)(result + 632);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(result + 1104);
    if (v3)
    {
      float32x4_t v4 = *a2;
      v4.i32[3] = 0;
      float32x4_t v5 = *(float32x4_t **)(result + 504);
      do
      {
        float32x4_t v6 = *v5++;
        float32x4_t v7 = vsubq_f32(v6, v4);
        float32x4_t v8 = vmulq_f32(v7, v7);
        *v2++ = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u32[0];
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

uint64_t __decreasingFloatData(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  if (*(float *)(a1 + 4 * *a2) <= *(float *)(a1 + 4 * *a3)) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t __increasingFloatData(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  if (*(float *)(a1 + 4 * *a2) > *(float *)(a1 + 4 * *a3)) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void _C3DParticleSystemInstanceSort(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  unsigned int SortingMode = C3DParticleSystemGetSortingMode(*(void *)(a1 + 48));
  if ((C3DParticleSystemGetRenderingMode(*(void *)(a1 + 48)) & 0xFE) == 2) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = SortingMode;
  }
  if (v7)
  {
    float32x4_t v8 = *(void **)(a1 + 632);
    CFAllocatorRef v9 = *(void **)(a1 + 536);
    if (v7 > 2)
    {
      if (!v9) {
        return;
      }
    }
    else if (!v8)
    {
      return;
    }
    uint64_t v10 = *(_DWORD **)(a1 + 544);
    if (v10)
    {
      if (*(_DWORD *)(a1 + 1104))
      {
        size_t v11 = 0;
        do
        {
          v10[v11] = v11;
          ++v11;
          size_t v12 = *(unsigned int *)(a1 + 1104);
        }
        while (v11 < v12);
      }
      else
      {
        size_t v12 = 0;
      }
      switch(v7)
      {
        case 1u:
          __C3DParticleSystemInstanceComputeDepth(a1, a3);
          goto LABEL_19;
        case 2u:
          __C3DParticleSystemInstanceComputeDistance(a1, a2);
LABEL_19:
          size_t v12 = *(unsigned int *)(a1 + 1104);
          uint64_t v13 = (int (__cdecl *)(void *, const void *, const void *))__decreasingFloatData;
          uint64_t v14 = v10;
          CFAllocatorRef v9 = v8;
          goto LABEL_23;
        case 3u:
          uint64_t v15 = __increasingFloatData;
          goto LABEL_22;
        case 4u:
          uint64_t v15 = __decreasingFloatData;
LABEL_22:
          uint64_t v13 = (int (__cdecl *)(void *, const void *, const void *))v15;
          uint64_t v14 = v10;
LABEL_23:
          qsort_r(v14, v12, 4uLL, v9, v13);
          break;
        default:
          return;
      }
    }
  }
}

_DWORD *__CopyParticle(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (result[244])
  {
    float32x4_t v5 = result;
    unint64_t v6 = 0;
    do
    {
      if (*(void *)&v5[2 * v6 + 180])
      {
        size_t v7 = v5[v6 + 148];
        switch(v7)
        {
          case 4:
            *(_DWORD *)(*(void *)&v5[2 * v6] + 4 * a2) = *(_DWORD *)(*(void *)&v5[2 * v6] + 4 * a3);
            break;
          case 0xC:
            uint64_t v8 = *(void *)&v5[2 * v6];
            CFAllocatorRef v9 = (uint64_t *)(v8 + 12 * a3);
            uint64_t v10 = *v9;
            uint64_t v11 = v8 + 12 * a2;
            *(_DWORD *)(v11 + _Block_object_dispose(&STACK[0x690], 8) = *((_DWORD *)v9 + 2);
            *(void *)uint64_t v11 = v10;
            break;
          case 0x10:
            *(_OWORD *)(*(void *)&v5[2 * v6] + 16 * a2) = *(_OWORD *)(*(void *)&v5[2 * v6] + 16 * a3);
            break;
          default:
            __n128 result = memcpy((void *)(*(void *)&v5[2 * v6] + v7 * a2), (const void *)(*(void *)&v5[2 * v6] + v7 * a3), v7);
            break;
        }
      }
      ++v6;
    }
    while (v6 < v5[244]);
  }
  return result;
}

uint64_t C3DParticleSystemInstanceCheckParticlesCount(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 1112);
  if (v4 < a2)
  {
    float BirthRate = C3DParticleSystemGetBirthRate(*(void *)(a1 + 48));
    float v6 = BirthRate + C3DParticleSystemGetBirthRateVariation(*(void *)(a1 + 48));
    ParticleLifeunint64_t Span = C3DParticleSystemGetParticleLifeSpan(*(void *)(a1 + 48));
    for (unsigned int i = (float)(v6
                                  * (float)(ParticleLifeSpan
                                          + C3DParticleSystemGetParticleLifeSpanVariation(*(void *)(a1 + 48))))
            + 8; i < a2; i += i >> 1)
      ;
LABEL_13:
    _C3DParticleSystemInstanceAllocateParticlesData((unsigned int *)a1, (const void *)(a1 + 672), i);
    return 1;
  }
  unsigned int v9 = v4 >> 2;
  BOOL v11 = *(_DWORD *)(a1 + 1104) >= a2 && a2 >= 8 && v9 >= a2;
  unsigned int i = a2;
  if (v11) {
    goto LABEL_13;
  }
  return 1;
}

void __C3DParticleSystemInstanceApplyControllers(uint64_t a1, double a2, double a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  unsigned int v17 = 0;
  uint64_t Controllers = C3DParticleSystemGetControllers(*(void *)(a1 + 48), &v17);
  if (Controllers)
  {
    uint64_t v7 = Controllers;
    float v8 = a3;
    memset(v18, 0, 512);
    C3DParticleContextSetup((uint64_t)v18, a1, (const void *)(a1 + 80), a2, v8);
    if (v17)
    {
      for (unint64_t i = 0; i < v17; ++i)
      {
        if (*(unsigned char *)(v7 + 48) && *(void *)(v7 + 16))
        {
          int v13 = *(unsigned __int8 *)(v7 + 24);
          if (v13 == 2)
          {
            C3DParticleAnimatePropertyWithOtherProperty((uint64_t)v18, 0, v19, (float *)v7, v9, v10, v11);
          }
          else if (v13 == 1)
          {
            if (*(void *)(v7 + 40)) {
              uint64_t v14 = *(float32x4_t **)(v7 + 40);
            }
            else {
              uint64_t v14 = v20;
            }
            if (v14)
            {
              v16.i32[2] = 0;
              v16.i64[0] = 0;
              C3DNodeGetWorldPosition(v14, (__n128 *)&v16);
              float32x4_t v15 = v16;
              v15.i32[3] = 0;
            }
            else
            {
              float32x4_t v15 = 0uLL;
            }
            C3DParticleAnimatePropertyWithDistance((uint64_t)v18, 0, v19, (float *)v7, v15, *(double *)v10.i64, v11);
          }
          else if (!*(unsigned char *)(v7 + 24))
          {
            C3DParticleAnimatePropertyWithLife(v18, 0, v19, (unsigned __int8 *)v7);
          }
        }
        v7 += 80;
      }
    }
  }
}

void __C3DParticleSystemInstanceStep(uint64_t a1, double a2, float a3, float a4)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 48);
  if (C3DParticleSystemGetParticleLifeSpan(v8) < INFINITY)
  {
    SimulateLifeCallbacuint64_t k = (void (*)(uint64_t, float))C3DParticleSystemGetSimulateLifeCallback(v8);
    SimulateLifeCallback(a1, a3);
  }
  uint64_t v10 = *(unsigned int *)(a1 + 1104);
  if (!*(_DWORD *)(a1 + 24))
  {
    char v11 = 0;
    if (!v10) {
      goto LABEL_11;
    }
LABEL_14:
    memset(__src, 0, 512);
    C3DParticleContextSetup((uint64_t)__src, a1, (const void *)(a1 + 80), a2, a3);
    LODWORD(__src[64]) = v10;
    if (v10 >= 0x801 && *((void *)&__src[74] + 1))
    {
      uint64_t v32 = 0;
      std::string::size_type v33 = &v32;
      uint64_t v34 = 0x4010000000;
      std::string v35 = &unk_20B6AE426;
      long long v36 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
      long long v37 = xmmword_20B5CB570;
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = ____C3DParticleSystemInstanceStep_block_invoke;
      block[3] = &unk_2640047C8;
      memcpy(v39, __src, sizeof(v39));
      unsigned int v42 = (v10 + 15) >> 4;
      uint64_t v41 = a1;
      unint64_t v40 = &v32;
      dispatch_apply(0x10uLL, *((dispatch_queue_t *)&__src[74] + 1), block);
      long long v26 = *((_OWORD *)v33 + 3);
      __src[68] = *((_OWORD *)v33 + 2);
      __src[69] = v26;
      _Block_object_dispose(&v32, 8);
    }
    else
    {
      C3DParticleSystemProcessAffectors(*(void *)(a1 + 48), (uint64_t)__src, 0, v10);
    }
    Particleint Size = C3DParticleSystemGetParticleSize(v8);
    *(float *)v28.i32 = ParticleSize + C3DParticleSystemGetParticleSizeVariation(v8);
    float32x4_t v29 = vaddq_f32((float32x4_t)__src[69], (float32x4_t)vdupq_lane_s32(v28, 0));
    v29.i32[3] = HIDWORD(__src[69]);
    __src[69] = v29;
    *(_OWORD *)(a1 + 1152) = __src[68];
    *(_OWORD *)(a1 + 116_Block_object_dispose(&STACK[0x690], 8) = __src[69];
    if (v11) {
      goto LABEL_12;
    }
    goto LABEL_19;
  }
  char v11 = 0;
  unsigned int v12 = 0;
  do
  {
    uint64_t v13 = *(void *)(a1 + 16) + 160 * v12;
    C3DParticleSystemInstanceStepEmitter(a1, v13, a2, a3, a4);
    if (*(_DWORD *)(v13 + 16) == 3)
    {
      unsigned int v14 = *(_DWORD *)(a1 + 24) - 1;
      *(_DWORD *)(a1 + 24) = v14;
      if (v12 < v14)
      {
        uint64_t v15 = *(void *)(a1 + 16);
        float32x4_t v16 = (_OWORD *)(v15 + 160 * v12);
        unsigned int v17 = (_OWORD *)(v15 + 160 * v14);
        long long v18 = v17[1];
        *float32x4_t v16 = *v17;
        v16[1] = v18;
        long long v19 = v17[2];
        long long v20 = v17[3];
        long long v21 = v17[5];
        _OWORD v16[4] = v17[4];
        v16[5] = v21;
        v16[2] = v19;
        v16[3] = v20;
        long long v22 = v17[6];
        long long v23 = v17[7];
        long long v24 = v17[9];
        v16[8] = v17[8];
        v16[9] = v24;
        v16[6] = v22;
        v16[7] = v23;
      }
    }
    else
    {
      ++v12;
      char v11 = 1;
    }
  }
  while (v12 < *(_DWORD *)(a1 + 24));
  if (*(_DWORD *)(a1 + 1104)) {
    goto LABEL_14;
  }
LABEL_11:
  if (v11)
  {
LABEL_12:
    int v25 = 0;
    goto LABEL_28;
  }
LABEL_19:
  if (C3DIsRunningInXcode()
    && ((v30 = *(void *)(a1 + 64)) != 0 || (uint64_t v31 = *(void **)(a1 + 40)) != 0 && (v30 = C3DGetScene(v31)) != 0)
    && C3DSceneIsPausedForEditing(v30))
  {
    __DestroyParticles(a1 + 80);
    *(_DWORD *)(a1 + 1104) = 0;
    *(_DWORD *)(a1 + 1112) = 0;
    int v25 = 2;
  }
  else if (*(_DWORD *)(a1 + 1104))
  {
    int v25 = 1;
  }
  else
  {
    int v25 = 2;
  }
LABEL_28:
  *(_DWORD *)(a1 + 32) = v25;
}

float32x4_t *C3DParticleSystemInstanceStepEmitter(uint64_t a1, uint64_t a2, double a3, float a4, float a5)
{
  uint64_t v9 = *(void *)(a1 + 48);
  if (!*(_DWORD *)(a2 + 16))
  {
    float EmissionDuration = C3DParticleSystemGetEmissionDuration(*(void *)(a1 + 48));
    float EmissionDurationVariation = C3DParticleSystemGetEmissionDurationVariation(v9);
    if (EmissionDurationVariation != 0.0)
    {
      unsigned int v12 = 214013 * *(_DWORD *)(a1 + 1116) + 2531011;
      *(_DWORD *)(a1 + 1116) = v12;
      float EmissionDuration = EmissionDuration
                       + (float)((float)((float)((float)HIWORD(v12) * 0.000015259) + -0.5) * EmissionDurationVariation);
    }
    *(float *)a2 = EmissionDuration;
    *(_DWORD *)(a2 + 4) = 0;
    float IdleDuration = C3DParticleSystemGetIdleDuration(v9);
    float IdleDurationVariation = C3DParticleSystemGetIdleDurationVariation(v9);
    if (IdleDurationVariation != 0.0)
    {
      unsigned int v15 = 214013 * *(_DWORD *)(a1 + 1116) + 2531011;
      *(_DWORD *)(a1 + 1116) = v15;
      float IdleDuration = IdleDuration
                   + (float)((float)((float)((float)HIWORD(v15) * 0.000015259) + -0.5) * IdleDurationVariation);
    }
    *(float *)(a2 + _Block_object_dispose(&STACK[0x690], 8) = IdleDuration;
    *(_DWORD *)(a2 + 16) = 1;
  }
  EmissionCallbacuint64_t k = C3DParticleSystemGetEmissionCallback(v9);
  __n128 result = *(float32x4_t **)(a2 + 24);
  if (result)
  {
    long long v18 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a2 + 96) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a2 + 112) = v18;
    long long v19 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a2 + 12_Block_object_dispose(&STACK[0x690], 8) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a2 + 144) = v19;
    __n128 result = (float32x4_t *)C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)result);
    if (result) {
      return result;
    }
    __n128 result = C3DNodeGetWorldMatrix(*(float32x4_t **)(a2 + 24));
    float32x4_t v20 = vmlaq_n_f32(vmulq_n_f32(result[1], a5), *(float32x4_t *)(a2 + 112), 1.0 - a5);
    float32x4_t v21 = vmlaq_n_f32(vmulq_n_f32(result[2], a5), *(float32x4_t *)(a2 + 128), 1.0 - a5);
    float32x4_t v22 = vmlaq_n_f32(vmulq_n_f32(result[3], a5), *(float32x4_t *)(a2 + 144), 1.0 - a5);
    *(float32x4_t *)(a2 + 32) = vmlaq_n_f32(vmulq_n_f32(*result, a5), *(float32x4_t *)(a2 + 96), 1.0 - a5);
    *(float32x4_t *)(a2 + 4_Block_object_dispose(&STACK[0x690], 8) = v20;
    *(float32x4_t *)(a2 + 64) = v21;
    *(float32x4_t *)(a2 + 80) = v22;
  }
  int v23 = *(_DWORD *)(a2 + 16);
  if (v23 != 1) {
    goto LABEL_16;
  }
  __n128 result = (float32x4_t *)((uint64_t (*)(uint64_t, uint64_t, double, float))EmissionCallback)(a1, a2, a3, a4);
  float v24 = *(float *)a2;
  float v25 = *(float *)(a2 + 4) + a4;
  *(float *)(a2 + 4) = v25;
  if (v25 <= v24)
  {
    int v23 = *(_DWORD *)(a2 + 16);
LABEL_16:
    if (v23 != 2) {
      return result;
    }
    float v26 = *(float *)(a2 + 8);
LABEL_18:
    float v27 = v26 - a4;
    *(float *)(a2 + _Block_object_dispose(&STACK[0x690], 8) = v27;
    if (v27 >= 0.0) {
      return result;
    }
    goto LABEL_19;
  }
  __n128 result = (float32x4_t *)C3DParticleSystemGetLoops(v9);
  if (!result)
  {
    int v28 = 3;
    goto LABEL_21;
  }
  float v26 = *(float *)(a2 + 8);
  if (v26 > 0.0)
  {
    *(_DWORD *)(a2 + 16) = 2;
    a4 = *(float *)(a2 + 4) - *(float *)a2;
    goto LABEL_18;
  }
LABEL_19:
  int v28 = 0;
LABEL_21:
  *(_DWORD *)(a2 + 16) = v28;
  return result;
}

void C3DParticleSystemInstanceReset(uint64_t a1)
{
  *(_DWORD *)(a1 + 1104) = 0;
  *(_DWORD *)(a1 + 1112) = 0;
}

void C3DParticleSystemInstanceUpdate(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 1128);
  unsigned int v5 = 2;
  if (v4 == 0.0)
  {
    float WarmupDuration = C3DParticleSystemGetWarmupDuration(*(void *)(a1 + 48));
    double v7 = fmaxf(WarmupDuration, 0.0);
    BOOL v8 = WarmupDuration == 0.0;
    if (WarmupDuration == 0.0) {
      unsigned int v5 = 2;
    }
    else {
      unsigned int v5 = 1000;
    }
    double v9 = -0.0;
    if (!v8) {
      double v9 = v7;
    }
    a2 = v9 + a2;
    double v4 = *(double *)(a1 + 1128);
  }
  *(double *)(a1 + 112_Block_object_dispose(&STACK[0x690], 8) = a2 + v4;
  double SpeedFactor = C3DParticleSystemGetSpeedFactor(*(void *)(a1 + 48));
  if (C3DParticleSystemGetAndClearMeshDidChange(*(void *)(a1 + 48)))
  {
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1192));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1200));
  }
  double v11 = a2 * SpeedFactor;
  ParticleLayout = (_DWORD *)C3DParticleSystemGetParticleLayout(*(void *)(a1 + 48));
  uint64_t v13 = ParticleLayout;
  if (ParticleLayout[96] != *(_DWORD *)(a1 + 1056) || memcmp(ParticleLayout, (const void *)(a1 + 672), 0x1B0uLL))
  {
    if (!_C3DParticleSystemInstanceAllocateParticlesData((unsigned int *)a1, v13, *(_DWORD *)(a1 + 1112))) {
      return;
    }
    if (v11 == 0.0) {
      __C3DParticleSystemInstanceApplyControllers(a1, v4, v11);
    }
  }
  if (v11 != 0.0 || C3DIsRunningInXcode())
  {
    double v14 = SpeedFactor / 60.0;
    float v15 = v11 / (SpeedFactor / 60.0);
    unsigned int v16 = rintf(v15);
    if (v16 <= 1) {
      unsigned int v16 = 1;
    }
    if (v16 >= v5) {
      unsigned int v17 = v5;
    }
    else {
      unsigned int v17 = v16;
    }
    if (v17 >= 2)
    {
      for (unsigned int i = 1; i != v17; ++i)
      {
        float v18 = v14;
        __C3DParticleSystemInstanceStep(a1, v4, v18, (float)i / (float)v17);
        double v4 = v14 + v4;
        double v11 = v11 - v14;
      }
    }
    float v20 = v11;
    __C3DParticleSystemInstanceStep(a1, v4, v20, 1.0);
    __C3DParticleSystemInstanceApplyControllers(a1, v4, v11);
  }
}

uint64_t C3DParticleSystemInstanceSync(uint64_t result, uint64_t a2)
{
  if (!*(_DWORD *)(result + 1188))
  {
    uint64_t v3 = result;
    *(void *)(result + 1184) = C3DRendererElementStoreAllocateSpanForNode(a2, 0, *(void *)(result + 40), 4);
    __n128 result = C3DEnginePipelineGetRendererElementStore(a2);
    if (*(_DWORD *)(v3 + 1188))
    {
      uint64_t v4 = result;
      unint64_t v5 = 0;
      do
      {
        __n128 result = C3DRendererElementStoreGetElementInSpanAtIndex(v4, *(void *)(v3 + 1184), v5);
        *(void *)(result + 4_Block_object_dispose(&STACK[0x690], 8) = v3;
        ++v5;
      }
      while (v5 < *(unsigned int *)(v3 + 1188));
    }
  }
  return result;
}

uint64_t _C3DParticleRender_Quads(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, char a6)
{
  int LightingEnabled = C3DParticleSystemGetLightingEnabled(*(void *)(a1 + 48));
  if (C3DParticleSystemGetOrientationMode(*(void *)(a1 + 48)) == 2) {
    int v11 = 0;
  }
  else {
    int v11 = LightingEnabled;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 1104);
  if (C3DEngineContextIsWarmUp(a3)) {
    unsigned int v12 = 1;
  }
  if (!v12) {
    return 0;
  }
  if (C3DParticleSystemGetSortingMode(*(void *)(a1 + 48)))
  {
    uint64_t v13 = (float32x4_t *)(a2 + (a4 << 6));
    float32x4_t v28 = v13[172];
    _C3DParticleSystemInstanceSort(a1, &v28, (uint64_t)&v13[241]);
    uint64_t v14 = *(void *)(a1 + 544);
  }
  else
  {
    uint64_t v14 = 0;
  }
  BOOL HasFeatures = C3DEngineContextHasFeatures(a3, 2);
  int v17 = 0;
  CFIndex v18 = 0;
  if (v11) {
    unsigned int v19 = 13107;
  }
  else {
    unsigned int v19 = 0x4000;
  }
  do
  {
    if (v12 >= v19) {
      unsigned int v20 = v19;
    }
    else {
      unsigned int v20 = v12;
    }
    if (HasFeatures) {
      int v21 = v12;
    }
    else {
      int v21 = v20;
    }
    float32x4_t v22 = (CFArrayRef *)__meshAtIndex(a1, v18);
    int v23 = __meshElementAtIndex(a1, v18);
    uint64_t result = _C3DParticleRender_Quads_Batch((void *)a1, v17, v21, v14, v22, (uint64_t)v23, v24, a3, a5, a6);
    if (result) {
      int v25 = v21;
    }
    else {
      int v25 = 0;
    }
    if (!result) {
      break;
    }
    v17 += v25;
    v18 += result;
    v12 -= v25;
  }
  while (v12);
  return result;
}

const void *__meshAtIndex(uint64_t a1, CFIndex a2)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1192)) <= a2)
  {
    Volatile = (const void *)C3DMeshCreateVolatile();
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1192), Volatile);
    CFRelease(Volatile);
    return Volatile;
  }
  else
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 1192);
    return CFArrayGetValueAtIndex(v4, a2);
  }
}

const void *__meshElementAtIndex(uint64_t a1, CFIndex a2)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1200)) <= a2)
  {
    float v6 = (const void *)C3DMeshElementCreate();
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1200), v6);
    CFRelease(v6);
    return v6;
  }
  else
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 1200);
    return CFArrayGetValueAtIndex(v4, a2);
  }
}

uint64_t _C3DParticleRender_Quads_Batch(void *a1, int a2, int a3, uint64_t a4, CFArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, char a10)
{
  BOOL HasFeatures = C3DEngineContextHasFeatures(a8, 1);
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a8);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a8);
  if (!(RendererContextGL | RenderContext)) {
    return 0;
  }
  uint64_t v20 = RenderContext;
  uint64_t v138 = a8;
  uint64_t v136 = RendererContextGL;
  uint64_t v148 = a4;
  int LightingEnabled = C3DParticleSystemGetLightingEnabled(a1[6]);
  uint64_t v141 = v20;
  int v142 = a3;
  BOOL v157 = C3DParticleSystemGetStretchFactor(a1[6]) != 0.0 && C3DParticleSystemGetRenderingMode(a1[6]) == 0;
  int OrientationMode = C3DParticleSystemGetOrientationMode(a1[6]);
  BOOL v23 = OrientationMode != 2;
  BOOL HasTextureAnimation = C3DParticleSystemHasTextureAnimation(a1[6]);
  BOOL v25 = a9 - 1 < 2 && a10 == 1;
  BOOL v137 = v25;
  Particlefloat Intensity = C3DParticleSystemGetParticleIntensity(a1[6]);
  float v27 = ParticleIntensity + C3DParticleSystemGetParticleIntensityVariation(a1[6]);
  if (v27 > 1.0) {
    unsigned int v28 = 1;
  }
  else {
    unsigned int v28 = 21;
  }
  char v140 = LightingEnabled & v23;
  if ((LightingEnabled & v23) != 0) {
    LODWORD(v29) = 5;
  }
  else {
    LODWORD(v29) = 4;
  }
  if (HasFeatures) {
    uint64_t v29 = 1;
  }
  else {
    uint64_t v29 = v29;
  }
  uint64_t v152 = v29;
  SourceWithSemanticAtunsigned int Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 0, 0, 1);
  if (!SourceWithSemanticAtIndex)
  {
    SourceWithSemanticAtunsigned int Index = (const void *)C3DMeshSourceCreateVolatile(0, 4, 1u);
    C3DMeshAddSource((uint64_t)a5, SourceWithSemanticAtIndex, 0, 0);
    CFRelease(SourceWithSemanticAtIndex);
  }
  Volatile = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 0, 1);
  if (!Volatile)
  {
    if (HasTextureAnimation) {
      uint64_t v32 = 3;
    }
    else {
      uint64_t v32 = 2;
    }
    Volatile = (const void *)C3DMeshSourceCreateVolatile(3, v32, 1u);
    C3DMeshAddSource((uint64_t)a5, Volatile, 0, 0);
    CFRelease(Volatile);
  }
  std::string::size_type v33 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 2, 0, 1);
  if (!v33)
  {
    std::string::size_type v33 = (const void *)C3DMeshSourceCreateVolatile(2, 4, v28);
    C3DMeshAddSource((uint64_t)a5, v33, 0, 0);
    CFRelease(v33);
  }
  int v147 = a2;
  if (HasFeatures)
  {
    uint64_t v34 = a1[7];
    if (v137) {
      SharedQuadStereoMeshSource = (const void *)C3DParticleManagerGetSharedQuadStereoMeshSource(v34, v140 & 1);
    }
    else {
      SharedQuadStereoMeshSource = (const void *)C3DParticleManagerGetSharedQuadMeshSource(v34, v140 & 1);
    }
    long long v36 = SharedQuadStereoMeshSource;
    uint64_t v37 = v141;
    if (C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 1, 1) != SharedQuadStereoMeshSource)
    {
      C3DMeshRemoveSourceWithSemanticAtIndex(a5, 3, 1);
      C3DMeshRemoveSourceWithSemanticAtIndex(a5, 3, 1);
      C3DMeshAddSource((uint64_t)a5, v36, 0, 0);
    }
  }
  else
  {
    long long v36 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 1, 1);
    uint64_t v37 = v141;
    if (!v36)
    {
      long long v36 = (const void *)C3DMeshSourceCreateVolatile(3, 2, 1u);
      C3DMeshAddSource((uint64_t)a5, v36, 0, 0);
      CFRelease(v36);
    }
  }
  int v38 = v157;
  if (OrientationMode == 2) {
    int v38 = 1;
  }
  double v143 = a1;
  if (v38 == 1)
  {
    uint64_t v39 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 2, 1);
    if (!v39)
    {
      if (OrientationMode == 2) {
        uint64_t v40 = 4;
      }
      else {
        uint64_t v40 = 3;
      }
      uint64_t v39 = (const void *)C3DMeshSourceCreateVolatile(3, v40, 1u);
      C3DMeshAddSource((uint64_t)a5, v39, 0, 0);
      CFRelease(v39);
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  uint64_t v41 = (v152 * v142);
  if (HasFeatures)
  {
    C3DMeshSourceSetInstancingDivisor((uint64_t)SourceWithSemanticAtIndex, 1);
    C3DMeshSourceSetInstancingDivisor((uint64_t)Volatile, 1);
    if (v39) {
      C3DMeshSourceSetInstancingDivisor((uint64_t)v39, 1);
    }
    if (v33) {
      C3DMeshSourceSetInstancingDivisor((uint64_t)v33, 1);
    }
  }
  if (v37)
  {
    -[SCNMTLRenderContext mapVolatileMesh:verticesCount:](v37, (uint64_t)a5, v41);
  }
  else
  {
    uint64_t ResourceManager = C3DEngineContextGetResourceManager(v138);
    int v43 = C3DRendererContextMapVolatileMesh(v136, ResourceManager, a5, v41, 0);
    uint64_t result = 0;
    if (!v43) {
      return result;
    }
  }
  uint64_t v133 = (uint64_t)a5;
  BOOL v44 = HasFeatures;
  uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  int v46 = (void *)C3DMeshSourceGetAccessor(Volatile);
  int v47 = (void *)C3DMeshSourceGetAccessor(v33);
  uint64_t v48 = (void *)C3DMeshSourceGetAccessor(v36);
  uint64_t v134 = a6;
  if (v39) {
    long long v49 = (void *)C3DMeshSourceGetAccessor(v39);
  }
  else {
    long long v49 = 0;
  }
  uint64_t VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
  uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)Accessor);
  uint64_t v52 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v47, 0);
  uint64_t v53 = C3DSceneSourceGetLibrary((uint64_t)v47);
  if (v44)
  {
    uint64_t v155 = 0;
    uint64_t v156 = 0;
  }
  else
  {
    uint64_t v156 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v48, 0);
    uint64_t v155 = C3DSceneSourceGetLibrary((uint64_t)v48);
  }
  uint64_t v54 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v46, 0);
  uint64_t v55 = C3DSceneSourceGetLibrary((uint64_t)v46);
  if (v49)
  {
    uint64_t v56 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v49, 0);
    uint64_t v161 = C3DSceneSourceGetLibrary((uint64_t)v49);
  }
  else
  {
    uint64_t v56 = 0;
    uint64_t v161 = 0;
  }
  uint64_t v57 = v56;
  if (v56) {
    BOOL v58 = OrientationMode == 2;
  }
  else {
    BOOL v58 = 0;
  }
  int v59 = v58;
  unsigned __int16 v150 = (float *)v143[65];
  uint64_t v146 = v143[66];
  long long v60 = (_DWORD *)v143[63];
  unint64_t v153 = (float32x4_t *)v143[64];
  unint64_t v149 = (char *)v143[76];
  uint64_t v159 = (_DWORD *)v143[77];
  Particleint Size = C3DParticleSystemGetParticleSize(v143[6]);
  uint64_t v145 = v143[70];
  float v135 = C3DParticleSystemGetParticleIntensity(v143[6]);
  uint64_t v144 = v143[83];
  float32x4_t v132 = *(float32x4_t *)C3DParticleSystemGetParticleColor(v143[6]);
  uint64_t v151 = v143[71];
  if (C3DEngineContextIsWarmUp(v138))
  {
    long long v60 = &_C3DParticleRender_Quads_Batch_s_vel_velAngle;
    unint64_t v62 = (float32x4_t *)&_C3DParticleRender_Quads_Batch_s_vel_velAngle;
    unint64_t v149 = (char *)&_C3DParticleRender_Quads_Batch_s_rotAxis;
    unsigned __int16 v150 = (float *)&_C3DParticleRender_Quads_Batch_s_frame;
    uint64_t v63 = &_C3DParticleRender_Quads_Batch_s_frame;
  }
  else
  {
    unint64_t v62 = v153;
    uint64_t v63 = v159;
  }
  uint64_t v64 = v143[5];
  uint64_t v154 = v62;
  double v160 = v63;
  if (v64)
  {
    C3DNodeGetWorldAlpha(v64);
    float v139 = v65;
  }
  else
  {
    float v139 = 1.0;
  }
  ParticleLifeunint64_t Span = C3DParticleSystemGetParticleLifeSpan(v143[6]);
  float v67 = v135;
  if (v142)
  {
    unsigned int v68 = 0;
    uint64_t v69 = 0;
    float32x4_t v70 = vmulq_n_f32(v132, v139);
    float32x4_t v72 = vmulq_n_f32(v70, v135);
    float32x4_t v71 = vmulq_laneq_f32(v72, v70, 3);
    v72.i32[3] = v70.i32[3];
    v71.i32[3] = v70.i32[3];
    float32x4_t v73 = vmaxnmq_f32(v71, (float32x4_t)0);
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v78 = vminnmq_f32(v73, _Q3);
    float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v80.i64[0] = 0x3F0000003F000000;
    v80.i64[1] = 0x3F0000003F000000;
    int8x16_t v81 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32(v80, v79, v78));
    v82.i64[0] = 0xFF000000FFLL;
    v82.i64[1] = 0xFF000000FFLL;
    int8x16_t v83 = vandq_s8(v81, v82);
    uint32x2_t v84 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL), (uint32x2_t)0x1800000010);
    __int32 v85 = v83.i32[0] | (v83.i32[1] << 8) | v84.i32[0] | v84.i32[1];
    float v86 = 1.0 / ParticleLifeSpan;
    do
    {
      unsigned int v87 = v69 + v147;
      if (v148) {
        unsigned int v87 = *(_DWORD *)(v148 + 4 * v87);
      }
      if (v146) {
        float v86 = *(float *)(v146 + 4 * v87);
      }
      if (v145) {
        Particleint Size = *(float *)(v145 + 4 * v87);
      }
      if (v144)
      {
        float v67 = *(float *)(v144 + 4 * v87);
        if (v151) {
          goto LABEL_88;
        }
        float32x4_t v72 = vmulq_n_f32(v70, v67);
        v72.i32[3] = v70.i32[3];
      }
      else if (v151)
      {
LABEL_88:
        float32x4_t v88 = vmulq_n_f32(*(float32x4_t *)(v151 + 16 * v87), v139);
        float32x4_t v89 = vmulq_n_f32(v88, v67);
        float32x4_t v72 = v89;
        v72.i32[3] = v88.i32[3];
        if (v27 <= 1.0)
        {
          float32x4_t v90 = vmulq_laneq_f32(v89, v88, 3);
          v90.i32[3] = v72.i32[3];
          v91.i64[0] = 0x3F0000003F000000;
          v91.i64[1] = 0x3F0000003F000000;
          int8x16_t v92 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32(v91, v79, vminnmq_f32(vmaxnmq_f32(v90, (float32x4_t)0), _Q3))), v82);
          __int32 v93 = v92.i32[0] | (v92.i32[1] << 8);
          *(uint32x2_t *)v92.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v92, v92, 8uLL), (uint32x2_t)0x1800000010);
          __int32 v85 = v93 | v92.i32[0] | v92.i32[1];
        }
      }
      float32x2_t v94 = &v149[12 * v87];
      float v95 = 1.0 - (float)(v86 * v150[v87]);
      unint64_t v96 = &v60[4 * v87];
      uint64_t v97 = v96 + 1;
      unint64_t v98 = v96 + 2;
      __int16 v99 = v96 + 3;
      uint64_t v100 = &v154[v87];
      long long v101 = &v100->i32[1];
      int v102 = &v100->i32[2];
      uint64_t v103 = v152;
      unsigned int v104 = v68;
      float32x4_t v105 = &qword_20B5CB5C0;
      do
      {
        long long v106 = (_DWORD *)(VolatileValuePtrAtIndex + Library * v104);
        *long long v106 = v60[4 * v87];
        v106[1] = *v97;
        v106[2] = *v98;
        v106[3] = *v99;
        uint64_t v107 = v53 * v104;
        if (v27 > 1.0) {
          *(float32x4_t *)(v52 + v107) = v72;
        }
        else {
          *(_DWORD *)(v52 + v107) = v85;
        }
        uint64_t v108 = v54 + v55 * v104;
        *(float *)uint64_t v108 = v95;
        *(float *)(v108 + 4) = ParticleSize;
        if (HasTextureAnimation)
        {
          *(_DWORD *)(v108 + _Block_object_dispose(&STACK[0x690], 8) = v160[v87];
          if (!v44) {
            goto LABEL_96;
          }
        }
        else if (!v44)
        {
LABEL_96:
          *(void *)(v156 + v155 * v104) = *v105;
          if (v59) {
            goto LABEL_102;
          }
          goto LABEL_97;
        }
        if (v59)
        {
LABEL_102:
          unint64_t v112 = (_DWORD *)(v57 + v161 * v104);
          *unint64_t v112 = *(_DWORD *)v94;
          v112[1] = *((_DWORD *)v94 + 1);
          v112[2] = *((_DWORD *)v94 + 2);
          void v112[3] = *v99;
          goto LABEL_104;
        }
LABEL_97:
        if (v157)
        {
          float32x4_t v109 = v154[v87];
          float32x4_t v110 = vmulq_f32(v109, v109);
          uint64_t v111 = v57 + v161 * v104;
          if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 2), vaddq_f32(v110, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110.f32, 1))).f32[0] <= 0.0)
          {
            *(void *)uint64_t v111 = 0x3A83126F00000000;
            *(_DWORD *)(v111 + _Block_object_dispose(&STACK[0x690], 8) = 0;
          }
          else
          {
            *(_DWORD *)uint64_t v111 = v109.i32[0];
            *(_DWORD *)(v111 + 4) = *v101;
            *(_DWORD *)(v111 + _Block_object_dispose(&STACK[0x690], 8) = *v102;
          }
        }
LABEL_104:
        ++v105;
        ++v104;
        --v103;
      }
      while (v103);
      ++v69;
      v68 += v152;
    }
    while (v69 != v142);
  }
  if (v141) {
    -[SCNMTLRenderContext unmapVolatileMesh:modifiedVerticesCount:](v141, v133, -1);
  }
  else {
    C3DRendererContextUnmapVolatileMesh(v136, v133);
  }
  BOOL v113 = v44;
  if (v140) {
    unsigned int v114 = 4;
  }
  else {
    unsigned int v114 = 2;
  }
  if (v140) {
    char v115 = 2;
  }
  else {
    char v115 = 1;
  }
  unsigned int v116 = v142 << v115;
  if (v113) {
    uint64_t v117 = v114;
  }
  else {
    uint64_t v117 = v116;
  }
  Primitiveuint64_t Count = C3DMeshElementGetPrimitiveCount(v134);
  uint64_t v119 = PrimitiveCount;
  if (!v113)
  {
    if (PrimitiveCount != v117)
    {
      uint64_t v123 = v143[7];
      if (v140) {
        SharedPyramidQuadsMeshuint64_t Element = (char *)C3DParticleManagerGetSharedPyramidQuadsMeshElement(v123, v142);
      }
      else {
        SharedPyramidQuadsMeshuint64_t Element = (char *)C3DParticleManagerGetSharedQuadsMeshElement(v123, v142);
      }
      C3DMeshElementSetSharedMeshElement(v134, SharedPyramidQuadsMeshElement, 0, v116);
    }
    return 1;
  }
  Instanceuint64_t Count = C3DMeshElementGetInstanceCount(v134);
  if (v119 != v117 || InstanceCount != v142)
  {
    C3DMeshElementSetPrimitives(v134, v117, 0, 0);
    if (v137)
    {
      uint64_t v121 = v143[7];
      if (v140) {
        SharedPyramidStereoMeshuint64_t Element = C3DParticleManagerGetSharedPyramidStereoMeshElement(v121);
      }
      else {
        SharedPyramidStereoMeshuint64_t Element = C3DParticleManagerGetSharedQuadsStereoMeshElement(v121);
      }
      double v130 = (char *)SharedPyramidStereoMeshElement;
      char Type = C3DMeshElementGetType(SharedPyramidStereoMeshElement);
      C3DMeshElementSetType(v134, Type);
      int v129 = 2 * v114;
      uint64_t v127 = v134;
      double v128 = v130;
    }
    else
    {
      if ((v140 & 1) == 0)
      {
        C3DMeshElementSetType(v134, 1);
        goto LABEL_135;
      }
      SharedPyramidMeshuint64_t Element = C3DParticleManagerGetSharedPyramidMeshElement(v143[7]);
      char v126 = C3DMeshElementGetType(SharedPyramidMeshElement);
      C3DMeshElementSetType(v134, v126);
      uint64_t v127 = v134;
      double v128 = (char *)SharedPyramidMeshElement;
      int v129 = 4;
    }
    C3DMeshElementSetSharedMeshElement(v127, v128, 0, v129);
LABEL_135:
    C3DMeshElementSetInstanceCount(v134, v142);
  }
  return 1;
}

uint64_t _C3DParticleRender_Strip(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (a3 < 2) {
    return 0;
  }
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a5);
  uint64_t v10 = __meshAtIndex(a1, 0);
  uint64_t v64 = __meshElementAtIndex(a1, 0);
  SourceWithSemanticAtunsigned int Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 0, 0, 1);
  if (!SourceWithSemanticAtIndex)
  {
    SourceWithSemanticAtunsigned int Index = (const void *)C3DMeshSourceCreateVolatile(0, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, SourceWithSemanticAtIndex, 0, 0);
    CFRelease(SourceWithSemanticAtIndex);
  }
  Volatile = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 3, 0, 1);
  if (!Volatile)
  {
    Volatile = (const void *)C3DMeshSourceCreateVolatile(3, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, Volatile, 0, 0);
    CFRelease(Volatile);
  }
  uint64_t v13 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 3, 1, 1);
  if (!v13)
  {
    uint64_t v13 = (const void *)C3DMeshSourceCreateVolatile(3, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, v13, 0, 0);
    CFRelease(v13);
  }
  uint64_t v14 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 2, 0, 1);
  if (!v14)
  {
    uint64_t v14 = (const void *)C3DMeshSourceCreateVolatile(2, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, v14, 0, 0);
    CFRelease(v14);
  }
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a5);
  uint64_t v63 = RenderContext;
  if (RenderContext)
  {
    -[SCNMTLRenderContext mapVolatileMesh:verticesCount:](RenderContext, (uint64_t)v10, 2 * a3);
  }
  else
  {
    uint64_t ResourceManager = C3DEngineContextGetResourceManager(a5);
    int v17 = C3DRendererContextMapVolatileMesh(RendererContextGL, ResourceManager, v10, 2 * a3, 0);
    uint64_t result = 0;
    if (!v17) {
      return result;
    }
  }
  int v61 = 2 * a3;
  uint64_t v62 = (uint64_t)v10;
  uint64_t v60 = RendererContextGL;
  uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  unsigned int v19 = (void *)C3DMeshSourceGetAccessor(Volatile);
  uint64_t v20 = (void *)C3DMeshSourceGetAccessor(v13);
  int v21 = (void *)C3DMeshSourceGetAccessor(v14);
  uint64_t VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
  unsigned int v74 = a3;
  uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)Accessor);
  uint64_t v24 = (uint64_t *)a1;
  uint64_t v25 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v21, 0);
  uint64_t v26 = C3DSceneSourceGetLibrary((uint64_t)v21);
  uint64_t v27 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v19, 0);
  uint64_t v28 = C3DSceneSourceGetLibrary((uint64_t)v19);
  uint64_t v29 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v20, 0);
  uint64_t v30 = C3DSceneSourceGetLibrary((uint64_t)v20);
  _C3DParticleSystemInstanceSort((uint64_t)v24, 0, 0);
  uint64_t ParticleColorController = C3DParticleSystemGetParticleColorController(v24[6]);
  uint64_t v70 = v24[65];
  uint64_t v71 = ParticleColorController;
  uint64_t v69 = v24[66];
  uint64_t v32 = v24[63];
  uint64_t v67 = v24[68];
  Particleint Size = C3DParticleSystemGetParticleSize(v24[6]);
  uint64_t v68 = v24[70];
  Particleuint64_t Color = (long long *)C3DParticleSystemGetParticleColor(v24[6]);
  uint64_t v65 = v24[71];
  long long v76 = *ParticleColor;
  ParticleLifeunint64_t Span = C3DParticleSystemGetParticleLifeSpan(v24[6]);
  uint64_t v36 = v67;
  uint64_t v37 = 0;
  unint64_t v38 = v74;
  int8x16_t v39 = 0uLL;
  float32x4_t v40 = 0uLL;
  float v41 = 1.0 / ParticleLifeSpan;
  unint64_t v66 = v74;
  do
  {
    uint64_t v42 = *(unsigned int *)(v36 + 4 * v37);
    if (v69) {
      float v41 = *(float *)(v69 + 4 * v42);
    }
    if (v68) {
      Particleint Size = *(float *)(v68 + 4 * v42);
    }
    float v43 = 1.0 - (float)(v41 * *(float *)(v70 + 4 * v42));
    if (v71)
    {
      uint64_t v75 = v37;
      float32x4_t v72 = v40;
      int8x16_t v73 = v39;
      C3DAnimationEvaluate(v71);
      float32x4_t v40 = v72;
      int8x16_t v39 = v73;
      uint64_t v37 = v75;
      unint64_t v38 = v66;
      uint64_t v36 = v67;
    }
    else if (v65)
    {
      long long v76 = *(_OWORD *)(v65 + 16 * v42);
    }
    if (v37) {
      int8x16_t v39 = (int8x16_t)vsubq_f32(*(float32x4_t *)(v32 + 16 * v42), v40);
    }
    uint64_t v44 = v37 + 1;
    int8x16_t v45 = v39;
    if (v37 + 1 < v38)
    {
      float32x4_t v40 = *(float32x4_t *)(v32 + 16 * v42);
      int8x16_t v45 = (int8x16_t)vsubq_f32(*(float32x4_t *)(v32 + 16 * *(unsigned int *)(v36 + 4 * v44)), v40);
    }
    uint64_t v46 = 0;
    uint64_t v47 = (2 * v37);
    uint64_t v48 = (_DWORD *)(v32 + 16 * v42);
    v49.i64[1] = *((void *)&v76 + 1);
    int v50 = v48 + 1;
    int v51 = v48 + 2;
    uint64_t v52 = v48 + 3;
    char v53 = 1;
    do
    {
      uint64_t v54 = v46 | v47;
      uint64_t v55 = (_DWORD *)(VolatileValuePtrAtIndex + Library * (v46 | v47));
      *uint64_t v55 = *(_DWORD *)(v32 + 16 * v42);
      v55[1] = *v50;
      v55[2] = *v51;
      v55[3] = *v52;
      uint64_t v56 = v29 + v30 * (v46 | v47);
      *(void *)uint64_t v56 = v45.i64[0];
      *(_DWORD *)(v56 + _Block_object_dispose(&STACK[0x690], 8) = v45.i32[2];
      int v57 = *((_DWORD *)&qword_20B5CB568 + v46);
      char v58 = v53;
      *(_DWORD *)(v56 + 12) = v57;
      uint64_t v59 = v27 + v28 * (v46 | v47);
      *(float *)uint64_t v59 = v43;
      *(float *)(v59 + 4) = ParticleSize;
      *(float *)(v59 + _Block_object_dispose(&STACK[0x690], 8) = v43;
      *(_DWORD *)(v59 + 12) = v57;
      *(_OWORD *)(v25 + v26 * v54) = v76;
      uint64_t v46 = 1;
      char v53 = 0;
    }
    while ((v58 & 1) != 0);
    v40.i64[0] = 0;
    v49.i64[0] = v37;
    int8x16_t v39 = vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v49, (int64x2_t)v40).i64[0], 0), v45, v39);
    float32x4_t v40 = *(float32x4_t *)(v32 + 16 * v42);
    ++v37;
  }
  while (v44 != v38);
  if (v63) {
    -[SCNMTLRenderContext unmapVolatileMesh:modifiedVerticesCount:](v63, v62, -1);
  }
  else {
    C3DRendererContextUnmapVolatileMesh(v60, v62);
  }
  if (v61 - 2 != C3DMeshElementGetPrimitiveCount((uint64_t)v64)) {
    C3DMeshElementInit((uint64_t)v64, 1, v61 - 2, 0, 0);
  }
  return 1;
}

__n128 C3DParticleSystemInstanceDraw(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1192));
  if (Count == CFArrayGetCount(*(CFArrayRef *)(a1 + 1200)))
  {
    uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
    if (RendererContextGL)
    {
      uint64_t v15 = RendererContextGL;
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(a2);
      if (Count >= 1)
      {
        uint64_t v17 = ResourceManager;
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1192), i);
          C3DRendererContextBindMesh(v15, v17, ValueAtIndex);
          uint64_t v20 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1200), i);
          C3DRendererContextBindMeshElement(v15, v17, v20);
          C3DRendererContextRenderResidentMeshElement(v15);
        }
      }
    }
    else
    {
      uint64_t RenderContext = C3DEngineContextGetRenderContext(a2);
      uint64_t v30 = *(void *)(a3 + 24);
      __n128 v31 = *(__n128 *)(a3 + 40);
      if (Count >= 1)
      {
        uint64_t v23 = RenderContext;
        CFIndex v24 = 0;
        BOOL v26 = (a5 - 3) < 0xFFFFFFFE || a6 != 1;
        do
        {
          uint64_t v27 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1192), v24);
          uint64_t v28 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1200), v24);
          if (v28) {
            char v29 = v26;
          }
          else {
            char v29 = 1;
          }
          if ((v29 & 1) == 0 && C3DEngineContextGetEyeCount(a2) == 2) {
            v28[17] >>= 1;
          }
          *(void *)(a3 + 24) = v27;
          *(void *)(a3 + 40) = 0;
          *(void *)(a3 + 4_Block_object_dispose(&STACK[0x690], 8) = v28;
          -[SCNMTLRenderContext drawRenderElement:withPass:](v23, a3, a4);
          ++v24;
        }
        while (Count != v24);
      }
      *(void *)(a3 + 24) = v30;
      __n128 result = v31;
      *(__n128 *)(a3 + 40) = v31;
    }
  }
  else if ((C3DParticleSystemInstanceDraw_done & 1) == 0)
  {
    C3DParticleSystemInstanceDraw_done = 1;
    int v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      C3DParticleSystemInstanceDraw_cold_1(v21);
    }
  }
  return result;
}

void C3DParticleSystemInstancePushRendererElements(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, float32x4_t *a5, uint64_t a6, int a7, int a8)
{
  *(void *)&v58[5] = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(a1 + 1188)) {
    return;
  }
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v15 = v14 ? C3DNodeGetCategoryBitMask(*(void *)(a1 + 40)) : -1;
  if (a2[589] & v15 | ((a2[588] & v15) == 0)) {
    return;
  }
  if (v14)
  {
    if (*((unsigned char *)a2 + 4690) && (*(unsigned char *)(v14 + 222) & 0x40) == 0
      || *((unsigned char *)a2 + 4691) && (*(unsigned char *)(v14 + 222) & 0x40) != 0)
    {
      return;
    }
  }
  else if (*((unsigned char *)a2 + 4690))
  {
    return;
  }
  __int16 v52 = *(_WORD *)(a1 + 1186);
  __int16 v53 = *(_WORD *)(a1 + 1184);
  uint64_t v56 = *(unsigned int *)(a1 + 1188);
  int v51 = &a2[2 * a6 + 614];
  if (*(_DWORD *)(a1 + 1120) != a4 || *(unsigned char *)(a1 + 1124))
  {
    float FogEndDistance = C3DSceneGetFogEndDistance(a2[591]);
    *(unsigned char *)(a1 + 1124) = C3DParticleSystemGetSortingMode(*(void *)(a1 + 48)) - 1 < 2;
    *(_DWORD *)(a1 + 1120) = a4;
    if (!v56) {
      return;
    }
    uint64_t v17 = 0;
    int v49 = *((unsigned __int8 *)a2 + 4693);
    CFIndex v18 = &a2[2 * a6];
    unsigned int v19 = v18 + 615;
    int v50 = (_DWORD *)v18 + 1231;
    while (1)
    {
      uint64_t ElementInSpanAtIndex = C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(*a2 + 48), *(void *)(a1 + 1184), v17);
      uint64_t Material = (const void *)C3DParticleSystemGetMaterial(*(__n128 **)(a1 + 48), *(void *)(a1 + 56), FogEndDistance > 0.0, a3, a7, a8);
      uint64_t Technique = (const void *)C3DMaterialGetTechnique((uint64_t)Material);
      uint64_t v23 = *(const void **)(ElementInSpanAtIndex + 32);
      if (v23 != Material)
      {
        if (v23)
        {
          CFRelease(v23);
          *(void *)(ElementInSpanAtIndex + 32) = 0;
        }
        if (Material) {
          CFTypeRef v24 = CFRetain(Material);
        }
        else {
          CFTypeRef v24 = 0;
        }
        *(void *)(ElementInSpanAtIndex + 32) = v24;
      }
      uint64_t v25 = *(const void **)(ElementInSpanAtIndex + 40);
      if (v25 != Technique)
      {
        if (v25)
        {
          CFRelease(v25);
          *(void *)(ElementInSpanAtIndex + 40) = 0;
        }
        if (Technique) {
          CFTypeRef v26 = CFRetain(Technique);
        }
        else {
          CFTypeRef v26 = 0;
        }
        *(void *)(ElementInSpanAtIndex + 40) = v26;
      }
      *(void *)(ElementInSpanAtIndex + _Block_object_dispose(&STACK[0x690], 8) = *(void *)(a1 + 40);
      *(void *)(ElementInSpanAtIndex + 4_Block_object_dispose(&STACK[0x690], 8) = a1;
      if ((C3DParticleSystemGetRenderingMode(*(void *)(a1 + 48)) & 0xFE) == 2)
      {
        if (_C3DParticleRender_Strip(a1, v27, *(_DWORD *)(a1 + 1104), v28, a3)) {
          goto LABEL_36;
        }
      }
      else if (_C3DParticleRender_Quads(a1, (uint64_t)a2, a3, a6, a7, a8))
      {
LABEL_36:
        C3DEnginePipelineSyncRendererElement(*a2, ElementInSpanAtIndex, -1);
        *(_WORD *)(ElementInSpanAtIndex + 72) = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xFFEF | (16
                                                                                                * (C3DParticleSystemGetBlendMode(*(void *)(a1 + 48)) == 5));
        if (C3DParticleSystemGetLightingEnabled(*(void *)(a1 + 48))) {
          __int16 v29 = 64;
        }
        else {
          __int16 v29 = 0;
        }
        *(_WORD *)(ElementInSpanAtIndex + 72) = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xFFBF | v29;
        if (!C3DEngineContextIsClusteredShadingEnabled(a3)
          && v49
          && a5
          && (*(_WORD *)(ElementInSpanAtIndex + 72) & 0x40) != 0)
        {
          LightingSysteCFIndex m = C3DSceneGetLightingSystem(a2[591]);
          uint64_t v31 = *(void *)(ElementInSpanAtIndex + 8);
          if (v31) {
            uint64_t CategoryBitMask = C3DNodeGetCategoryBitMask(v31);
          }
          else {
            uint64_t CategoryBitMask = -1;
          }
          C3DLightingSystemQuery(LightingSystem, a5, CategoryBitMask, (void *)(ElementInSpanAtIndex + 56));
        }
        if ((*v19 + 1) > *v50)
        {
          std::string::size_type v33 = scn_default_log();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
            C3DParticleSystemInstancePushRendererElements_cold_2(v57, v58, v33);
          }
        }
        uint64_t v34 = *v19;
        std::string v35 = (_WORD *)(*v51 + 4 * v34);
        *std::string v35 = v53;
        v35[1] = v52 + v17;
        *unsigned int v19 = v34 + 1;
      }
      if (v56 == ++v17) {
        return;
      }
    }
  }
  uint64_t v36 = &a2[2 * a6];
  uint64_t v37 = v36 + 615;
  if ((*((_DWORD *)v36 + 1230) + 1) > *((_DWORD *)v36 + 1231))
  {
    unint64_t v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemInstancePushRendererElements_cold_1(v38, v39, v40);
    }
  }
  uint64_t v41 = *v37;
  uint64_t v42 = (_WORD *)(*v51 + 4 * v41);
  *uint64_t v42 = v53;
  v42[1] = v52;
  *uint64_t v37 = v41 + 1;
  if (!C3DEngineContextIsClusteredShadingEnabled(a3) && v56)
  {
    for (uint64_t i = 0; i != v56; ++i)
    {
      uint64_t v44 = C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(*a2 + 48), *(void *)(a1 + 1184), i);
      if (a5)
      {
        uint64_t v45 = v44;
        if ((*(_WORD *)(v44 + 72) & 0x40) != 0)
        {
          uint64_t v46 = C3DSceneGetLightingSystem(a2[591]);
          uint64_t v47 = *(void *)(v45 + 8);
          if (v47) {
            uint64_t v48 = C3DNodeGetCategoryBitMask(v47);
          }
          else {
            uint64_t v48 = -1;
          }
          C3DLightingSystemQuery(v46, a5, v48, (void *)(v45 + 56));
        }
      }
    }
  }
}

_DWORD *C3DParticleSystemInstanceSimulateLife(_DWORD *result, float a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[276];
  if (v3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)result + 44);
    while (1)
    {
      float v7 = *(float *)(v6 + 4 * v5) - a2;
      *(float *)(v6 + 4 * v5) = v7;
      if (v7 >= 0.0)
      {
        ++v5;
      }
      else
      {
        if (v3 >= v5) {
          uint64_t v8 = v5;
        }
        else {
          uint64_t v8 = v3;
        }
        while (v5 < v3)
        {
          uint64_t v9 = v3 - 1;
          float v10 = *(float *)(v6 - 4 + 4 * v3--);
          if (v10 >= a2)
          {
            uint64_t v8 = v9 + 1;
            break;
          }
        }
        if (v5 == v8)
        {
          LODWORD(v3) = v5;
          goto LABEL_17;
        }
        uint64_t v3 = v8 - 1;
        __n128 result = __CopyParticle(v2 + 20, v5, v8 - 1);
      }
      if (v5 >= v3) {
        goto LABEL_17;
      }
    }
  }
  LODWORD(v3) = 0;
LABEL_17:
  v2[276] = v3;
  return result;
}

_DWORD *C3DParticleSystemInstanceSimulateLifeWithBlock(_DWORD *result, float a2)
{
  uint64_t v2 = result;
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v3 = result[276];
  if (v3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)result + 44);
    float v7 = (char *)*((void *)result + 59);
    uint64_t v8 = v7;
    do
    {
      float v9 = *(float *)(v6 + 4 * v5) - a2;
      *(float *)(v6 + 4 * v5) = v9;
      if (v9 < 0.0)
      {
        *(_DWORD *)uint64_t v8 = v5;
        v8 += 4;
      }
      ++v5;
    }
    while (v3 != v5);
    uint64_t v10 = v8 - v7;
    uint64_t v11 = (v8 - v7) >> 2;
    if (v8 != v7)
    {
      CFArrayRef theArray = 0;
      EventBlocuint64_t k = C3DParticleSystemGetEventBlock(*((void *)result + 6), 1u, &theArray);
      memset(v19, 0, 256);
      C3DParticleSystemInstanceFillUserData(*((void *)v2 + 6), (uint64_t)(v2 + 20), theArray, (uint64_t)v19, (uint64_t)v18, 0);
      __n128 result = (_DWORD *)(*(uint64_t (**)(uint64_t, unsigned char *, unsigned char *, char *, uint64_t))(EventBlock + 16))(EventBlock, v19, v18, v7, v11);
    }
    if (v10 >= 1)
    {
      uint64_t v13 = 0;
      unsigned int v14 = v3;
      do
      {
        LODWORD(v3) = *(_DWORD *)&v7[4 * v13];
        if (v3 < v14)
        {
          uint64_t v15 = (float *)(v6 + 4 * (v14 - 1));
          while (*v15 < a2)
          {
            --v11;
            --v14;
            --v15;
            if (v3 >= v14) {
              goto LABEL_17;
            }
          }
        }
        if (v3 != v14)
        {
          unsigned int v16 = v14 - 1;
          __n128 result = __CopyParticle(v2 + 20, *(unsigned int *)&v7[4 * v13], v14 - 1);
          LODWORD(v3) = v16;
        }
LABEL_17:
        ++v13;
        unsigned int v14 = v3;
      }
      while (v13 < v11);
    }
  }
  v2[276] = v3;
  return result;
}

unint64_t C3DParticleSystemInstanceFillUserData(unint64_t result, uint64_t a2, CFArrayRef theArray, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (theArray)
  {
    uint64_t v11 = result;
    __n128 result = CFArrayGetCount(theArray);
    if ((uint64_t)result >= 1)
    {
      unint64_t v12 = result;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        __n128 result = (unint64_t)C3DParticleSystemGetPropertyIndexAndStride(v11, ValueAtIndex);
        *(void *)(a4 + 8 * i) = *(void *)(a2 + 8 * result) + HIWORD(result) + WORD2(result) * a6;
        *(void *)(a5 + 8 * i) = WORD2(result);
      }
    }
  }
  return result;
}

void C3DParticleSystemInstanceSimulateLifeAndSpawnWhenDying(uint64_t a1, float a2)
{
  uint64_t SystemSpawnedOnDying = C3DParticleSystemGetSystemSpawnedOnDying(*(void *)(a1 + 48));
  uint64_t v5 = *(unsigned int *)(a1 + 1104);
  if (v5)
  {
    uint64_t v6 = (const void *)SystemSpawnedOnDying;
    uint64_t v7 = 0;
    uint64_t v9 = *(void *)(a1 + 344);
    uint64_t v8 = *(void *)(a1 + 352);
    uint64_t v10 = *(void *)(a1 + 336);
    while (1)
    {
      float v11 = *(float *)(v8 + 4 * v7) - a2;
      *(float *)(v8 + 4 * v7) = v11;
      if (v11 >= 0.0)
      {
        ++v7;
      }
      else
      {
        __SpawnSubSystem(*(void *)(a1 + 56), v6, *(__n128 *)(v10 + 16 * v7), *(float32x4_t *)(v9 + 16 * v7));
        if (v5 >= v7) {
          uint64_t v12 = v7;
        }
        else {
          uint64_t v12 = v5;
        }
        while (v7 < v5)
        {
          uint64_t v13 = v5 - 1;
          float v14 = *(float *)(v8 - 4 + 4 * v5--);
          if (v14 >= a2)
          {
            uint64_t v12 = v13 + 1;
            break;
          }
        }
        if (v7 == v12)
        {
          LODWORD(v5) = v7;
          goto LABEL_17;
        }
        uint64_t v5 = v12 - 1;
        __CopyParticle((_DWORD *)(a1 + 80), v7, v12 - 1);
      }
      if (v7 >= v5) {
        goto LABEL_17;
      }
    }
  }
  LODWORD(v5) = 0;
LABEL_17:
  *(_DWORD *)(a1 + 1104) = v5;
}

__n128 C3DParticleSystemInstanceAddEmitter(uint64_t a1, long long *a2, float32x4_t *a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 24);
  if (v6 == *(_DWORD *)(a1 + 28))
  {
    if (v6) {
      unsigned int v7 = 2 * v6;
    }
    else {
      unsigned int v7 = 1;
    }
    *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x690], 8) = v7;
    uint64_t v8 = (float32x4_t *)malloc_type_realloc(*(void **)(a1 + 16), 160 * v7, 0x1020040C96D2ADFuLL);
    *(void *)(a1 + 16) = v8;
    unsigned int v6 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    uint64_t v8 = *(float32x4_t **)(a1 + 16);
  }
  *(_DWORD *)(a1 + 24) = v6 + 1;
  unsigned int v9 = v6;
  f32 = (_OWORD *)v8[10 * v6].f32;
  f32[8] = 0u;
  f32[9] = 0u;
  f32[6] = 0u;
  f32[7] = 0u;
  f32[4] = 0u;
  f32[5] = 0u;
  f32[2] = 0u;
  f32[3] = 0u;
  _OWORD *f32 = 0u;
  f32[1] = 0u;
  *((_DWORD *)f32 + 4) = 0;
  if (a3)
  {
    float v11 = &v8[10 * v9];
    v11[1].i64[1] = (uint64_t)a3;
    WorldMatrix = C3DNodeGetWorldMatrix(a3);
    float32x4_t v13 = WorldMatrix[3];
    float32x4_t v15 = *WorldMatrix;
    float32x4_t v14 = WorldMatrix[1];
    uint8_t v11[4] = WorldMatrix[2];
    void v11[5] = v13;
    void v11[2] = v15;
    v11[3] = v14;
  }
  else
  {
    unsigned int v16 = (_OWORD *)v8[10 * v9].f32;
    uint64_t v17 = v16 + 2;
    if (a2)
    {
      long long v18 = *a2;
      long long v19 = a2[1];
      long long v20 = a2[3];
      _OWORD v16[4] = a2[2];
      v16[5] = v20;
      _OWORD *v17 = v18;
      v16[3] = v19;
    }
    else
    {
      Identity = (long long *)C3DMatrix4x4GetIdentity();
      long long v22 = Identity[3];
      long long v24 = *Identity;
      long long v23 = Identity[1];
      void v17[2] = Identity[2];
      v17[3] = v22;
      _OWORD *v17 = v24;
      v17[1] = v23;
    }
  }
  if (*(float32x4_t **)(a1 + 40) != a3)
  {
    if (C3DParticleSystemGetIsLocal(*(void *)(a1 + 48)))
    {
      uint64_t v25 = *(float32x4_t **)(a1 + 40);
      if (v25)
      {
        memset(&v31, 0, sizeof(v31));
        CFTypeRef v26 = (simd_float4x4 *)C3DNodeGetWorldMatrix(v25);
        C3DMatrix4x4Invert(v26, &v31);
        C3DMatrix4x4Mult((uint64_t)&v31, &v8[10 * v9 + 2], (float32x4_t *)v8[10 * v9 + 2].f32);
      }
    }
  }
  uint64_t v27 = &v8[10 * v9];
  float32x4_t v28 = v27[3];
  void v27[6] = v27[2];
  v27[7] = v28;
  __n128 result = (__n128)v27[4];
  float32x4_t v30 = v27[5];
  v27[8] = (float32x4_t)result;
  v27[9] = v30;
  return result;
}

uint64_t C3DParticleSystemInstanceRemoveEmittersWithNode(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 24);
  if (v2)
  {
    char v3 = 0;
    unsigned int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(result + 16);
      if (*(void *)(v5 + 160 * v4 + 24) != a2)
      {
        uint64_t v6 = v4 + 1;
        uint64_t v7 = v6 - 1;
        uint64_t v8 = (uint64_t *)(v5 + 160 * v6 + 24);
        while (v6 < v2)
        {
          uint64_t v9 = *v8;
          v8 += 20;
          ++v7;
          LODWORD(v6) = v6 + 1;
          if (v9 == a2)
          {
            char v3 = 1;
            unsigned int v4 = v7;
            goto LABEL_9;
          }
        }
        goto LABEL_13;
      }
      uint64_t v7 = v4;
LABEL_9:
      *(_DWORD *)(result + 24) = --v2;
      if (v4 < v2)
      {
        uint64_t v10 = (_OWORD *)(v5 + 160 * v7);
        float v11 = (_OWORD *)(v5 + 160 * v2);
        long long v12 = v11[1];
        _OWORD *v10 = *v11;
        v10[1] = v12;
        long long v13 = v11[2];
        long long v14 = v11[3];
        long long v15 = v11[5];
        v10[4] = v11[4];
        v10[5] = v15;
        _OWORD v10[2] = v13;
        v10[3] = v14;
        long long v16 = v11[6];
        long long v17 = v11[7];
        long long v18 = v11[9];
        v10[8] = v11[8];
        v10[9] = v18;
        v10[6] = v16;
        v10[7] = v17;
        unsigned int v2 = *(_DWORD *)(result + 24);
      }
    }
    while (v4 < v2);
    if ((v3 & 1) == 0) {
      goto LABEL_14;
    }
LABEL_13:
    *(_DWORD *)(result + 32) = 0;
  }
  else
  {
LABEL_14:
    if (*(_DWORD *)(result + 1104)) {
      int v19 = 1;
    }
    else {
      int v19 = 2;
    }
    *(_DWORD *)(result + 32) = v19;
  }
  return result;
}

BOOL C3DColor4IsEqualToColor4WithThreshold(float *a1, float *a2)
{
  return vabds_f32(*a1, *a2) <= 0.001
      && vabds_f32(a1[1], a2[1]) <= 0.001
      && vabds_f32(a1[2], a2[2]) <= 0.001
      && vabds_f32(a1[3], a2[3]) <= 0.001;
}

float C3DColor4Lerp(float *a1, float *a2, float *a3, float a4)
{
  *a3 = *a1 + (float)((float)(*a2 - *a1) * a4);
  a3[1] = a1[1] + (float)((float)(a2[1] - a1[1]) * a4);
  a3[2] = a1[2] + (float)((float)(a2[2] - a1[2]) * a4);
  float result = a1[3] + (float)((float)(a2[3] - a1[3]) * a4);
  a3[3] = result;
  return result;
}

float C3DColor4Add(float *a1, float *a2, float *a3)
{
  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  float result = a1[3] + a2[3];
  a3[3] = result;
  return result;
}

BOOL C3DColor4InitWithPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (!a1 || !a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      C3DColor4InitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
      if (!a4) {
        return 0;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*a4)
    {
      MalformedDocumentCFErrorRef Error = C3DSceneSourceCreateMalformedDocumentError(0);
      BOOL result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
  if (C3DInitC3DFloatArrayWithPropertyList(a2, a1, a4)) {
    return 1;
  }
  long long v14 = scn_default_log();
  BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3DColor4InitWithPropertyList_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    return 0;
  }
  return result;
}

uint64_t C3DColor4CopyPropertyList(uint64_t result)
{
  if (result) {
    return C3DCreatePropertyListFromC3DFloatBuffer(result, 4);
  }
  return result;
}

float C3DColor4Sub(float *a1, float *a2, float *a3)
{
  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  a3[2] = a1[2] - a2[2];
  float result = a1[3] - a2[3];
  a3[3] = result;
  return result;
}

float C3DColor4Distance(float *a1, float *a2)
{
  float v2 = a1[1] - a2[1];
  float v3 = a1[2] - a2[2];
  float v4 = a1[3] - a2[3];
  return sqrtf((float)((float)((float)(v2 * v2) + (float)((float)(*a1 - *a2) * (float)(*a1 - *a2))) + (float)(v3 * v3))+ (float)(v4 * v4));
}

unint64_t C3DColor4RGB2HSB(uint64_t a1, int a2)
{
  if (*(float *)&a1 <= *((float *)&a1 + 1)) {
    float v2 = *((float *)&a1 + 1);
  }
  else {
    float v2 = *(float *)&a1;
  }
  if (*(float *)&a1 >= *((float *)&a1 + 1)) {
    float v3 = *((float *)&a1 + 1);
  }
  else {
    float v3 = *(float *)&a1;
  }
  if (v2 <= *(float *)&a2) {
    float v2 = *(float *)&a2;
  }
  if (v3 >= *(float *)&a2) {
    float v3 = *(float *)&a2;
  }
  float v4 = v2 - v3;
  if (v2 == 0.0) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = COERCE_UNSIGNED_INT(v4 / v2);
  }
  if (v4 == 0.0)
  {
    float v8 = 0.0;
  }
  else
  {
    float v6 = (float)((float)(*(float *)&a1 - *((float *)&a1 + 1)) / v4) + 4.0;
    if (v2 == *((float *)&a1 + 1)) {
      float v6 = (float)((float)(*(float *)&a2 - *(float *)&a1) / v4) + 2.0;
    }
    if (v2 == *(float *)&a1) {
      float v7 = (float)(*((float *)&a1 + 1) - *(float *)&a2) / v4;
    }
    else {
      float v7 = v6;
    }
    float v8 = v7 * 60.0;
    if (v8 < 0.0) {
      float v8 = v8 + 360.0;
    }
  }
  return COERCE_UNSIGNED_INT(v8 / 360.0) | (unint64_t)(v5 << 32);
}

unint64_t C3DColor4HSB2RGB(uint64_t a1, int a2)
{
  if (*((float *)&a1 + 1) <= 1.0) {
    float v2 = *((float *)&a1 + 1);
  }
  else {
    float v2 = 1.0;
  }
  float v3 = 0.0;
  if (*((float *)&a1 + 1) < 0.0) {
    float v2 = 0.0;
  }
  if (*(float *)&a2 <= 1.0) {
    float v4 = *(float *)&a2;
  }
  else {
    float v4 = 1.0;
  }
  if (*(float *)&a2 < 0.0) {
    float v4 = 0.0;
  }
  if (v2 == 0.0)
  {
    float v5 = v4;
    float v6 = v4;
  }
  else
  {
    float v8 = *(float *)&a1 * 360.0;
    if (*(float *)&a1 > 1.0) {
      float v8 = 360.0;
    }
    if (*(float *)&a1 >= 0.0) {
      float v9 = v8;
    }
    else {
      float v9 = 0.0;
    }
    if (v9 != 360.0) {
      float v3 = v9 / 60.0;
    }
    int v10 = (int)v3;
    float v11 = v3 - (float)(int)v3;
    float v12 = v4 * (float)(1.0 - v2);
    float v13 = v4 * (float)(1.0 - (float)(v2 * v11));
    float v14 = v4 * (float)(1.0 - (float)(v2 * (float)(1.0 - v11)));
    float v5 = v4;
    float v6 = v14;
    switch(v10)
    {
      case 0:
        return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
      case 1:
        float v5 = v13;
        float v6 = v4;
        break;
      case 2:
        float v5 = v12;
        float v6 = v4;
        break;
      case 3:
        float v5 = v12;
        float v6 = v13;
        break;
      case 4:
        float v5 = v14;
        float v6 = v12;
        break;
      default:
        float v5 = v4;
        float v6 = v12;
        break;
    }
  }
  return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
}

uint64_t C3DGetColorTransformToGlobalColorSpace()
{
  int IsEnabled = C3DLinearRenderingIsEnabled();
  int IsUsed = C3DWideGamutIsUsed();
  if (IsEnabled)
  {
    if (IsUsed)
    {
      if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1) {
        dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_38);
      }
      float v2 = &C3DGetColorTransformToExtendedLinearSRGB_colorTransform;
    }
    else
    {
      if (C3DGetColorTransformToLinearSRGB_onceToken != -1) {
        dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_41);
      }
      float v2 = &C3DGetColorTransformToLinearSRGB_colorTransform;
    }
  }
  else if (IsUsed)
  {
    if (C3DGetColorTransformToExtendedSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_44);
    }
    float v2 = &C3DGetColorTransformToExtendedSRGB_colorTransform;
  }
  else
  {
    if (C3DGetColorTransformToSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToSRGB_onceToken, &__block_literal_global_47);
    }
    float v2 = &C3DGetColorTransformToSRGB_colorTransform;
  }
  return *v2;
}

__n128 _C3DCGColorGetComponentsInColorSpace(CGColorRef color, CGColorSpace *a2)
{
  if (!color)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DCGColorGetComponentsInColorSpace_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (CGColorGetColorSpace(color) == a2) {
    float v12 = CGColorRetain(color);
  }
  else {
    float v12 = (CGColor *)CGColorTransformConvertColor();
  }
  float v13 = v12;
  size_t NumberOfComponents = CGColorGetNumberOfComponents(v12);
  Components = (float64x2_t *)CGColorGetComponents(v13);
  if (NumberOfComponents >= 4)
  {
    *(float *)&__int32 v16 = Components[1].f64[1];
    v17.i64[0] = 0;
    v17.i32[2] = 0;
    v17.i32[3] = v16;
LABEL_9:
    *(float32x2_t *)&long long v18 = vcvt_f32_f64(*Components);
    *((void *)&v18 + 1) = vextq_s8(v17, v17, 8uLL).u64[0];
    float v19 = Components[1].f64[0];
LABEL_16:
    *((float *)&v18 + 2) = v19;
    goto LABEL_17;
  }
  if (NumberOfComponents == 2)
  {
    float v20 = Components->f64[1];
    *((float *)&v18 + 3) = v20;
    goto LABEL_15;
  }
  if (NumberOfComponents >= 3)
  {
    int8x16_t v17 = (int8x16_t)xmmword_20B5CB530;
    goto LABEL_9;
  }
  long long v18 = xmmword_20B5CB530;
  if (NumberOfComponents)
  {
LABEL_15:
    float v19 = Components->f64[0];
    *(float *)&long long v18 = v19;
    *((float *)&v18 + 1) = v19;
    goto LABEL_16;
  }
LABEL_17:
  long long v22 = v18;
  CGColorRelease(v13);
  return (__n128)v22;
}

double C3DCGColorGetLinearExtendedSRGBComponents(CGColorRef color)
{
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
  }
  float v2 = (CGColorSpace *)C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
  if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_38);
  }

  *(void *)&double result = _C3DCGColorGetComponentsInColorSpace(color, v2).n128_u64[0];
  return result;
}

double C3DCGColorGetITUR_709Components(CGColorRef color)
{
  if (C3DColorSpaceITUR_709_onceToken != -1) {
    dispatch_once(&C3DColorSpaceITUR_709_onceToken, &__block_literal_global_25);
  }
  float v2 = (CGColorSpace *)C3DColorSpaceITUR_709_kC3DColorSpaceITUR_709;
  if (C3DGetColorTransformToITUR_709_onceToken != -1) {
    dispatch_once(&C3DGetColorTransformToITUR_709_onceToken, &__block_literal_global_56);
  }

  *(void *)&double result = _C3DCGColorGetComponentsInColorSpace(color, v2).n128_u64[0];
  return result;
}

uint64_t C3DColorSpaceExtendedSRGB()
{
  if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
  }
  return C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
}

CGColorRef C3DCGColorCreateExtendedLinearSRGBWithComponents(float32x4_t a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = vcvtq_f64_f32(*(float32x2_t *)a1.f32);
  v2[1] = vcvt_hight_f64_f32(a1);
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
  }
  return CGColorCreate((CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB, (const CGFloat *)v2);
}

float64_t C3DColor4ConvertToLinear(float32x4_t *a1)
{
  v3.f64[0] = 0.0;
  v3.f64[1] = a1->f32[3];
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_38);
    }
    if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
    }
  }
  else
  {
    if (C3DGetColorTransformToLinearSRGB_onceToken != -1) {
      dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_41);
    }
    if (C3DColorSpaceSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
    }
  }
  CGColorTransformConvertColorComponents();
  float64_t result = v3.f64[0];
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v3);
  return result;
}

uint64_t C3DColorSpaceGray()
{
  if (C3DColorSpaceGray_onceToken != -1) {
    dispatch_once(&C3DColorSpaceGray_onceToken, &__block_literal_global_7);
  }
  return C3DColorSpaceGray_kC3DColorSpaceGray;
}

CGColorSpaceRef __C3DColorSpaceGray_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00250]);
  C3DColorSpaceGray_kC3DColorSpaceGray = (uint64_t)result;
  return result;
}

uint64_t C3DGetGlobalColorSpace()
{
  int IsEnabled = C3DLinearRenderingIsEnabled();
  int IsUsed = C3DWideGamutIsUsed();
  if (IsEnabled)
  {
    if (IsUsed)
    {
      if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
        dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
      }
      float v2 = &C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
    }
    else
    {
      if (C3DColorSpaceLinearSRGB_onceToken != -1) {
        dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_4);
      }
      float v2 = &C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
    }
  }
  else if (IsUsed)
  {
    if (C3DColorSpaceExtendedSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_13);
    }
    float v2 = &C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
  }
  else
  {
    if (C3DColorSpaceSRGB_onceToken != -1) {
      dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
    }
    float v2 = &C3DColorSpaceSRGB_kC3DColorSpaceSRGB;
  }
  return *v2;
}

void C3DGetColorMatchingComputeKernelParameters(CGColorSpaceRef a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0xA000000000;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  int v23 = -1;
  uint64_t v16 = 0;
  int8x16_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  int v19 = -1;
  CGColorConversionInfoRef v4 = CGColorConversionInfoCreateFromList(0, a1, kCGColorConversionTransformFromSpace, kCGRenderingIntentDefault, a2, 1, 0, 0);
  if (v4)
  {
    CGColorConversionInfoRef v5 = v4;
    if ((CGColorConversionInfoIterateFunctionsWithCallbacks() & 1) == 0)
    {
      uint64_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        C3DGetColorMatchingComputeKernelParameters_cold_4();
      }
      uint64_t v7 = v25;
      *((_WORD *)v25 + 16) = 0;
      *((unsigned char *)v7 + 34) = 0;
    }
    CFRelease(v5);
  }
  else
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      C3DGetColorMatchingComputeKernelParameters_cold_3();
    }
  }
  if (!*((unsigned char *)v25 + 33))
  {
    if (*((unsigned char *)v25 + 34))
    {
      if (*((unsigned char *)v25 + 32)) {
        goto LABEL_10;
      }
      if (*((_DWORD *)v17 + 6) != 4) {
        goto LABEL_10;
      }
      float v14 = scn_default_log();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
    }
    else
    {
      if (!*((unsigned char *)v25 + 32)) {
        goto LABEL_10;
      }
      if (*((_DWORD *)v21 + 6) != 1) {
        goto LABEL_10;
      }
      uint64_t v15 = scn_default_log();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
    }
    C3DGetColorMatchingComputeKernelParameters_cold_1();
  }
LABEL_10:
  uint64_t v9 = v25;
  long long v10 = *((_OWORD *)v25 + 7);
  a3[4] = *((_OWORD *)v25 + 6);
  a3[5] = v10;
  long long v11 = *((_OWORD *)v9 + 9);
  a3[6] = *((_OWORD *)v9 + 8);
  a3[7] = v11;
  long long v12 = *((_OWORD *)v9 + 3);
  *a3 = *((_OWORD *)v9 + 2);
  a3[1] = v12;
  long long v13 = *((_OWORD *)v9 + 5);
  a3[2] = *((_OWORD *)v9 + 4);
  a3[3] = v13;
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
}

uint64_t __C3DGetColorMatchingComputeKernelParameters_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)&void v20[5] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(*(void *)(a2 + 52) + 8 * *a5);
  if (a4 >= 2)
  {
    uint64_t v9 = a4 - 1;
    long long v10 = a5 + 1;
    do
    {
      uint64_t v11 = *v10++;
      if (*(void *)(*(void *)(a2 + 52) + 8 * v11) != v8)
      {
        long long v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          __C3DGetColorMatchingComputeKernelParameters_block_invoke_cold_3(buf, v20, v12);
        }
      }
      --v9;
    }
    while (v9);
  }
  int v13 = CGColorTRCGetGammaID();
  if (v13 == 7) {
    return 1;
  }
  int v15 = v13;
  CGColorTRCGetFunction();
  if (!a3)
  {
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v15;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 32) = 1;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 36) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 40) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 44) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 4_Block_object_dispose(&STACK[0x690], 8) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 52) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 56) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 60) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 64) = 0;
    return 1;
  }
  uint64_t v17 = *(void *)(a2 + 4);
  uint64_t v16 = (uint64_t *)(a2 + 4);
  if (v17 - 1 == a3)
  {
    *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = v15;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 34) = 1;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 12_Block_object_dispose(&STACK[0x690], 8) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 132) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 136) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 140) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 144) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 14_Block_object_dispose(&STACK[0x690], 8) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 152) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 156) = 0;
    return 1;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
    __C3DGetColorMatchingComputeKernelParameters_block_invoke_cold_1(a3, v16, v18);
  }
  return 0;
}

BOOL __C3DGetColorMatchingComputeKernelParameters_block_invoke_29(uint64_t a1, uint64_t a2)
{
  float v2 = (uint64_t *)(a2 + 36);
  uint64_t v3 = *(void *)(a2 + 36);
  if (v3 == 1)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 33) = 1;
    memset(v10, 0, 24);
    CGColorMatrixGetMatrix();
    long long v5 = 0u;
    DWORD1(v5) = 0;
    DWORD2(v5) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 80) = v5;
    long long v6 = *(_OWORD *)((char *)v10 + 4);
    DWORD1(v6) = 0;
    DWORD2(v6) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 96) = v6;
    long long v7 = *(_OWORD *)((char *)v10 + 8);
    DWORD1(v7) = 0;
    DWORD2(v7) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 112) = v7;
  }
  else
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      __C3DGetColorMatchingComputeKernelParameters_block_invoke_29_cold_1(v2, v8);
    }
  }
  return v3 == 1;
}

uint64_t __C3DGetColorMatchingComputeKernelParameters_block_invoke_32()
{
  CFAllocatorRef v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    __C3DGetColorMatchingComputeKernelParameters_block_invoke_32_cold_1(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  return 0;
}

uint64_t __C3DGetColorTransformToExtendedLinearSRGB_block_invoke()
{
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1) {
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_16);
  }
  uint64_t result = MEMORY[0x210534520](C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB, 0);
  C3DGetColorTransformToExtendedLinearSRGB_colorTransforCFIndex m = result;
  return result;
}

void OUTLINED_FUNCTION_1_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

C3D::RenderPass *C3D::DownsamplePass::DownsamplePass(C3D::DownsamplePass *this, RenderGraph *a2, C3D::Pass *a3)
{
  uint64_t result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)uint64_t result = &unk_26BF6D1B0;
  return result;
}

const char *C3D::DownsamplePass::name(C3D::DownsamplePass *this)
{
  return "DownsamplePass";
}

double C3D::DownsamplePass::setup(C3D::DownsamplePass *this)
{
  float SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(*((void *)this + 2));
  C3D::Pass::setInputCount(this, 1u);
  uint64_t v3 = (*(uint64_t (**)(C3D::DownsamplePass *))(*(void *)this + 88))(this);
  uint64_t v4 = C3D::PassDescriptor::inputAtIndex((C3D::DownsamplePass *)((char *)this + 32), 0);
  *(void *)(v4 + _Block_object_dispose(&STACK[0x690], 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  *(_OWORD *)(v4 + 16) = v7;
  *(_DWORD *)(v4 + 32) = v8;
  *(_WORD *)(v4 + 16) = vcvtms_s32_f32(SuperSamplingFactor * *(float *)(v3 + 8));
  *(_WORD *)(v4 + 1_Block_object_dispose(&STACK[0x690], 8) = vcvtms_s32_f32(SuperSamplingFactor * *(float *)(v3 + 12));
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::DownsamplePass *)((char *)this + 32), 0);
  *(void *)(v5 + _Block_object_dispose(&STACK[0x690], 8) = "COLOR";
  *(unsigned char *)(v5 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  double result = *(double *)&v7;
  *(_OWORD *)(v5 + 16) = v7;
  *(_DWORD *)(v5 + 32) = v8;
  return result;
}

uint64_t C3D::DownsamplePass::compile(C3D::DownsamplePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::DownsamplePass *))(*(void *)this + 88))(this);
  uint64_t v4 = *(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128);
  uint64_t v5 = *(void *)(v3 + 24);
  unint64_t v6 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::DownsamplePass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v5) ^ ((0xC6A4A7935BD1E995 * v5) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(v4, (0xC6A4A7935BD1E995 * (v6 ^ (v6 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v6 ^ (v6 >> 47))) >> 47));
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::DownsamplePass::execute(uint64_t *a1, uint64_t *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  uint64_t RenderContext = (_OWORD *)C3DEngineContextGetRenderContext(a1[2]);
  [(SCNMTLRenderContext *)RenderContext screenTransform];
  v9[0] = v8[0];
  v9[1] = v8[1];
  v9[2] = v8[2];
  v9[3] = v8[3];
  float SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(a1[2]);
  uint64_t v5 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 16) state];
  if (*(void *)(v3 + 3376) != v5)
  {
    *(void *)(v3 + 3376) = v5;
    [*(id *)(v3 + 3392) setRenderPipelineState:v5];
  }
  unint64_t v6 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v6, 0);
  SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v3, v9, 0x50uLL, 0);
  SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v3, v9, 0x50uLL, 0);
  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v3);
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBytes(SCNMTLRenderCommandEncoder *this, const void *a2, size_t a3, uint64_t a4)
{
  long long v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  SCNMTLBufferPool::allocateAndCopy((SCNMTLBufferPool *)this->var25[0], a2, a3, &v7);
  return SCNMTLRenderCommandEncoder::setVertexBuffer((uint64_t)this, v8, v9, a4);
}

uint64_t SCNMTLRenderCommandEncoder::setFragmentBytes(SCNMTLRenderCommandEncoder *this, const void *a2, size_t a3, uint64_t a4)
{
  long long v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  SCNMTLBufferPool::allocateAndCopy((SCNMTLBufferPool *)this->var25[0], a2, a3, &v7);
  return SCNMTLRenderCommandEncoder::setFragmentBuffer((uint64_t)this, v8, v9, a4);
}

void C3D::DownsamplePassResource::~DownsamplePassResource(C3D::DownsamplePassResource *this)
{
  *(void *)this = &unk_26BF6E320;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E320;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

void C3DNotifyGeometryDidChange(uint64_t a1)
{
  CFSetRef v1 = *(const __CFSet **)(a1 + 88);
  if (v1) {
    CFSetApplyFunction(v1, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
  }
}

id _C3DGeometryCFFinalize(__C3DGeometry *a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationGeometryWillDie", a1, 0, 1u);
  C3DGeometryFinalizeSubdivision(a1);
  CFSetRef var4 = a1->var4;
  if (var4)
  {
    if (CFSetGetCount(var4))
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        _C3DGeometryCFFinalize_cold_1((uint64_t)a1, v4);
      }
    }
    uint64_t v5 = a1->var4;
    if (v5)
    {
      CFRelease(v5);
      a1->CFSetRef var4 = 0;
    }
  }
  var3 = a1->var3;
  if (var3)
  {
    CFRelease(var3);
    a1->var3 = 0;
  }
  var2 = a1->var2;
  if (var2)
  {
    CFRelease(var2);
    a1->var2 = 0;
  }
  var1 = a1->var1;
  if (var1)
  {
    CFRelease(var1);
    a1->var1 = 0;
  }
  var5 = a1->var5;
  if (var5)
  {
    CFRelease(var5);
    a1->var5 = 0;
  }
  var6 = a1->var6;
  if (var6) {
    free(var6);
  }
  a1->var6 = 0;
  return C3DEntityCFFinalize((uint64_t)a1);
}

__CFString *_C3DGeometryCFCopyDebugDescription(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  CFStringRef v3 = CFCopyTypeIDDescription(v2);
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t Name = C3DGeometryGetName((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, @"<%@:%p \"%@\"\n", v3, a1, Name);
  uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, @"  mesh: %@\n", Mesh);
  if ((uint64_t)C3DGeometryGetMaterialsCount((uint64_t)a1) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a1, v7);
      CFStringAppendFormat(Mutable, 0, @"  mat%d: %@\n", v7++, MaterialAtIndex);
    }
    while (v7 < (uint64_t)C3DGeometryGetMaterialsCount((uint64_t)a1));
  }
  CFStringAppend(Mutable, @">");
  CFRelease(v3);
  return Mutable;
}

void *_C3DGeometryFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    unint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount >= 1)
  {
    CFArrayRef v15 = MaterialsCount;
    for (uint64_t i = 0; (const __CFArray *)i != v15; ++i)
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
      C3DLibraryAddEntry(a2, MaterialAtIndex);
      C3DFillLibraryForSerialization(MaterialAtIndex, a2, a3);
    }
  }
  uint64_t result = (void *)C3DGeometryGetMesh(a1);
  if (result)
  {
    int v19 = result;
    C3DLibraryAddEntry(a2, result);
    return C3DFillLibraryForSerialization(v19, a2, a3);
  }
  return result;
}

uint64_t _C3DGeometryFinalizeDeserialization(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFErrorRef *a4)
{
  uint64_t v7 = a1;
  uint64_t v75 = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (theDict) {
      goto LABEL_6;
    }
  }
  else if (theDict)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t valuePtr = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"geometryID");
  if (!Value) {
    goto LABEL_10;
  }
  if (!CFNumberGetValue(Value, kCFNumberLongType, &valuePtr))
  {
    uint64_t v56 = scn_default_log();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      _C3DGeometryFinalizeDeserialization_cold_2();
    }
    goto LABEL_41;
  }
  uint64_t v25 = (uint64_t)valuePtr;
  uint64_t TypeID = C3DMeshGetTypeID();
  uint64_t valuePtr = (const void *)C3DLibraryGetRemappedID(a2, v25, TypeID);
  long long v27 = (void *)C3DMeshGetTypeID();
  Entry = C3DLibraryGetEntry(a2, v27, valuePtr);
  if (!Entry)
  {
    int v57 = scn_default_log();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
      _C3DGeometryFinalizeDeserialization_cold_3();
    }
LABEL_41:
    if (!a4 || *a4) {
      return 0;
    }
    MalformedDocumentCFErrorRef Error = C3DSceneSourceCreateMalformedDocumentError(0);
    uint64_t result = 0;
    *a4 = MalformedDocumentError;
    return result;
  }
  C3DGeometrySetMesh(v7, Entry);
LABEL_10:
  CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(theDict, @"bindInfos");
  CFArrayRef v30 = (const __CFArray *)CFDictionaryGetValue(theDict, @"materialsID");
  if (v30)
  {
    CFArrayRef v31 = v30;
    CFIndex Count = CFArrayGetCount(v30);
    if (Count >= 1)
    {
      CFIndex v33 = Count;
      uint64_t v60 = a4;
      CFIndex v34 = 0;
      CFArrayRef v62 = v31;
      CFIndex v61 = Count;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v31, v34);
        IntCFNumberRef Value = CFStringGetIntValue(ValueAtIndex);
        if (!IntValue)
        {
          uint64_t v54 = scn_default_log();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)float32x4_t buf = 0;
            _os_log_impl(&dword_20B249000, v54, OS_LOG_TYPE_DEFAULT, "Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected", buf, 2u);
          }
          goto LABEL_32;
        }
        uint64_t v37 = IntValue;
        uint64_t v38 = C3DMaterialGetTypeID();
        RemappedID = (const void *)C3DLibraryGetRemappedID(a2, v37, v38);
        uint64_t v40 = (void *)C3DMaterialGetTypeID();
        uint64_t v41 = C3DLibraryGetEntry(a2, v40, RemappedID);
        if (!v41)
        {
          char v58 = scn_default_log();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
            _C3DGeometryFinalizeDeserialization_cold_1();
          }
          a4 = v60;
          goto LABEL_41;
        }
        uint64_t v42 = v41;
        if (v29)
        {
          CFDictionaryRef v43 = (const __CFDictionary *)CFArrayGetValueAtIndex(v29, v34);
          long long v70 = xmmword_20B5CB680;
          long long v71 = unk_20B5CB690;
          long long v72 = xmmword_20B5CB6A0;
          long long v73 = unk_20B5CB6B0;
          long long v66 = xmmword_20B5CB640;
          long long v67 = unk_20B5CB650;
          long long v68 = xmmword_20B5CB660;
          long long v69 = unk_20B5CB670;
          *(_OWORD *)float32x4_t buf = xmmword_20B5CB620;
          long long v65 = unk_20B5CB630;
          uint64_t v74 = 0;
          _loadBindInfos(v43, @"emissionUVSet", 0, (uint64_t)buf);
          _loadBindInfos(v43, @"ambientUVSet", 1, (uint64_t)buf);
          _loadBindInfos(v43, @"diffuseUVSet", 2, (uint64_t)buf);
          _loadBindInfos(v43, @"specularUVSet", 3, (uint64_t)buf);
          _loadBindInfos(v43, @"reflectiveUVSet", 4, (uint64_t)buf);
          _loadBindInfos(v43, @"transparentUVSet", 5, (uint64_t)buf);
          _loadBindInfos(v43, @"filterUVSet", 6, (uint64_t)buf);
          _loadBindInfos(v43, @"normalUVSet", 7, (uint64_t)buf);
          _loadBindInfos(v43, @"ambientOcclusionUVSet", 8, (uint64_t)buf);
          _loadBindInfos(v43, @"selfIlluminationUVSet", 9, (uint64_t)buf);
          _loadBindInfos(v43, @"metalness", 10, (uint64_t)buf);
          _loadBindInfos(v43, @"roughness", 11, (uint64_t)buf);
          _loadBindInfos(v43, @"displacement", 15, (uint64_t)buf);
          _loadBindInfos(v43, @"clearCoat", 12, (uint64_t)buf);
          _loadBindInfos(v43, @"clearCoat", 13, (uint64_t)buf);
          _loadBindInfos(v43, @"clearCoat", 14, (uint64_t)buf);
          uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)v42);
          if (CommonProfile)
          {
            uint64_t v45 = CommonProfile;
            CFArrayRef v46 = v29;
            uint64_t v47 = v7;
            unint64_t v48 = 0;
            BOOL v49 = 1;
            do
            {
              uint64_t UVSet = C3DEffectCommonProfileGetUVSet(v45, (char)v48);
              if (C3DEffectCommonProfileUVSetIsSet(v45, (char)v48))
              {
                uint64_t v51 = *(void *)&buf[8 * v48];
                if (v51 != -1 && UVSet != v51) {
                  break;
                }
              }
              BOOL v49 = v48++ < 0xF;
            }
            while (v48 != 16);
            uint64_t v7 = v47;
            CFArrayRef v29 = v46;
            CFIndex v33 = v61;
            CFArrayRef v31 = v62;
            if (v49)
            {
              CFSetRef Copy = (void *)C3DMaterialCreateCopy((uint64_t)v42);
              _updateUVSet((uint64_t)Copy, (uint64_t)buf);
              C3DGeometryAppendMaterial(v7, Copy);
              if (Copy) {
                CFRelease(Copy);
              }
              goto LABEL_32;
            }
          }
          _updateUVSet((uint64_t)v42, (uint64_t)buf);
        }
        C3DGeometryAppendMaterial(v7, v42);
LABEL_32:
        ++v34;
      }
      while (v34 != v33);
    }
  }
  return 1;
}

void _loadBindInfos(const __CFDictionary *a1, const void *a2, int a3, uint64_t a4)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    uint64_t valuePtr = 0;
    if (!CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr))
    {
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        _loadBindInfos_cold_1((uint64_t)a2, (uint64_t)a1, v9);
      }
    }
    *(void *)(a4 + 8 * a3) = valuePtr;
  }
}

void _updateUVSet(uint64_t a1, uint64_t a2)
{
  uint64_t CommonProfile = C3DMaterialGetCommonProfile(a1);
  if (CommonProfile)
  {
    uint64_t v4 = CommonProfile;
    for (uint64_t i = 0; i != 16; ++i)
    {
      uint64_t v6 = *(void *)(a2 + 8 * i);
      if (v6 != -1) {
        C3DEffectCommonProfileSetUVSet(v4, (char)i, v6);
      }
    }
  }
}

__CFDictionary *_C3DGeometryCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (v14)
  {
    uint64_t valuePtr = C3DLibraryGetEntryID(a2, *(CFTypeRef *)(a1 + 64));
    CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
    CFNumberRef v16 = CFNumberCreate(v15, kCFNumberLongType, &valuePtr);
    CFDictionarySetValue(v14, @"geometryID", v16);
    CFRelease(v16);
    CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v17, 0, MEMORY[0x263EFFF70]);
    MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(a1);
    if ((uint64_t)MaterialsCount >= 1)
    {
      CFArrayRef v20 = MaterialsCount;
      for (uint64_t i = 0; (const __CFArray *)i != v20; ++i)
      {
        CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
        EntryID = C3DLibraryGetEntryID(a2, MaterialAtIndex);
        CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
        CFStringRef v25 = CFStringCreateWithFormat(v24, 0, @"%ld", EntryID, valuePtr);
        CFArrayAppendValue(Mutable, v25);
        CFRelease(v25);
      }
    }
    CFDictionarySetValue(v14, @"materialsID", Mutable);
    CFRelease(Mutable);
  }
  return v14;
}

void C3DGeometrySetBoundingBox(uint64_t a1, _OWORD *a2)
{
  CFStringRef v3 = *(_OWORD **)(a1 + 104);
  if (a2)
  {
    if (!v3)
    {
      CFStringRef v3 = malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
      *(void *)(a1 + 104) = v3;
    }
    long long v5 = a2[1];
    *CFStringRef v3 = *a2;
    v3[1] = v5;
  }
  else
  {
    if (!v3) {
      return;
    }
    free(v3);
    *(void *)(a1 + 104) = 0;
  }
  CFSetRef v6 = *(const __CFSet **)(a1 + 88);
  if (v6)
  {
    CFSetApplyFunction(v6, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
  }
}

__CFArray *_C3DGeometryCopyInstanceVariables(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFStringRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  long long v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v31 = 1;
  int valuePtr = 5;
  uint64_t Name = C3DGeometryGetName(a1);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v5, @"name", @"name");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v31 = 2;
  int valuePtr = 5;
  uint64_t Name = a1 + 64;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v9, @"name", @"mesh");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v31 = 2;
  int valuePtr = 5;
  uint64_t Name = a1 + 72;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v13, @"name", @"overrideMaterial");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  CFAllocatorRef v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v31 = 2;
  int valuePtr = 5;
  uint64_t Name = a1 + 80;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v17, @"name", @"materials");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v31 = 2;
  int valuePtr = 5;
  uint64_t Name = a1 + 96;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v21, @"name", @"levelsOfDetail");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  CFStringRef v25 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v31 = 0;
  int valuePtr = 5;
  uint64_t Name = a1 + 48;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v25, @"name", @"sceneRef");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  return Mutable;
}

double C3DGeometryInit(uint64_t a1)
{
  *(void *)(a1 + 80) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  *(void *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x690], 8) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 12_Block_object_dispose(&STACK[0x690], 8) = 0;

  return C3DGeometryInitSubdivision(a1);
}

uint64_t C3DGeometryCreateInterleavedCopy(CFTypeRef cf)
{
  if (!cf)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Copy = C3DGeometryCreateCopy(cf);
  uint64_t Mesh = C3DGeometryGetMesh(Copy);
  CopyWithInterleavedSources = (uint64_t *)C3DMeshCreateCopyWithInterleavedSources(Mesh);
  C3DGeometrySetMesh(Copy, CopyWithInterleavedSources);
  CFRelease(CopyWithInterleavedSources);
  return Copy;
}

uint64_t C3DGeometryCreateRenderableCopy(CFTypeRef cf)
{
  if (!cf)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Copy = C3DGeometryCreateCopy(cf);
  uint64_t Mesh = C3DGeometryGetMesh(Copy);
  Renderableuint64_t Copy = (uint64_t *)C3DMeshCreateRenderableCopy(Mesh);
  C3DGeometrySetMesh(Copy, RenderableCopy);
  CFRelease(RenderableCopy);
  return Copy;
}

uint64_t C3DGeometryCreateMutableCopy(CFTypeRef cf)
{
  if (!cf)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Copy = C3DGeometryCreateCopy(cf);
  uint64_t Mesh = C3DGeometryGetMesh(Copy);
  Deepuint64_t Copy = (uint64_t *)C3DMeshCreateDeepCopy(Mesh);
  C3DMeshMarkMutable((uint64_t)DeepCopy);
  C3DGeometrySetMesh(Copy, DeepCopy);
  CFRelease(DeepCopy);
  return Copy;
}

void C3DGeometryRemoveMaterialAtIndex(uint64_t a1, CFIndex a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DGetSceneRef(a1))
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a2);
    uint64_t v13 = C3DGetSceneRef(a1);
    C3DRemoveSceneRef(ValueAtIndex, v13);
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), a2);
  __PostGeometryMaterialDidChangeNotification((void *)a1);
}

void C3DGeometryReplaceMaterialAtIndex(uint64_t a1, void *a2, CFIndex a3)
{
  newValues = a2;
  if (!a1)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  if (C3DGetSceneRef(a1))
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a3);
    uint64_t v14 = C3DGetSceneRef(a1);
    C3DRemoveSceneRef(ValueAtIndex, v14);
  }
  v18.location = a3;
  v18.CFIndex length = 1;
  CFArrayReplaceValues(*(CFMutableArrayRef *)(a1 + 80), v18, (const void **)&newValues, 1);
  CFNumberRef v15 = (uint64_t *)newValues;
  uint64_t v16 = C3DGetSceneRef(a1);
  C3DAddSceneRef(v15, v16);
  __PostGeometryMaterialDidChangeNotification((void *)a1);
}

void _C3DGeometryShadingDidUpdate(void *a1)
{
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount((uint64_t)a1);
  if ((uint64_t)MaterialsCount >= 1)
  {
    CFArrayRef v3 = MaterialsCount;
    for (uint64_t i = 0; (const __CFArray *)i != v3; ++i)
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a1, i);
      _C3DMaterialShadingDidUpdate(MaterialAtIndex);
    }
  }

  __PostGeometryMaterialDidChangeNotification(a1);
}

void C3DGeometrySetOverrideMaterial(void *a1, void *cf)
{
  uint64_t v4 = (const void *)a1[9];
  if (v4 != cf)
  {
    if (v4)
    {
      CFRelease(v4);
      a1[9] = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    a1[9] = v5;
  }
  if (cf)
  {
    uint64_t v6 = C3DGetSceneRef((uint64_t)a1);
    C3DAddSceneRef((uint64_t *)cf, v6);
  }

  _C3DGeometryShadingDidUpdate(a1);
}

void __propagateUnTrackingOfNodesToLODs(const void *a1, uint64_t a2)
{
}

CFIndex __propagateTrackingOfNodesToLODs(const void *a1, uint64_t a2)
{
  return C3DGeometryTrackNode(a2, a1);
}

void C3DGeometryGeneratePoints(CFTypeRef cf, uint64_t a2, unsigned int *a3, _OWORD *a4, _OWORD *a5, int a6)
{
  int v6 = a6;
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (a6 != 2)
  {
    CFTypeID v10 = CFGetTypeID(cf);
    if (v10 == C3DParametricGeometryGetTypeID())
    {
      C3DParametricGeometryGeneratePoints((uint64_t)cf);
      return;
    }
  }
  uint64_t Mesh = C3DGeometryGetMesh((uint64_t)cf);
  if (!Mesh) {
    return;
  }
  uint64_t v12 = Mesh;
  PositionSource = C3DMeshGetPositionSource(Mesh, 1);
  if (!PositionSource) {
    return;
  }
  uint64_t v14 = (uint64_t)PositionSource;
  uint64_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  if (!Count) {
    return;
  }
  uint64_t v16 = Count;
  NormalSource = C3DMeshGetNormalSource(v12, 1);
  uint64_t v18 = (uint64_t)NormalSource;
  if (!NormalSource || C3DMeshSourceGetCount((uint64_t)NormalSource) == v16)
  {
    if (v6 == 1)
    {
      if ((C3DGeometryGeneratePoints_done_56 & 1) == 0)
      {
        C3DGeometryGeneratePoints_done_56 = 1;
        CFNumberRef v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          C3DGeometryGeneratePoints_cold_1();
        }
      }
      int v6 = 0;
    }
    Elementsuint64_t Count = C3DMeshGetElementsCount(v12);
    if (ElementsCount) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v6 == 0;
    }
    if (v21) {
      int v22 = 2;
    }
    else {
      int v22 = v6;
    }
    if (v22)
    {
      if (v22 == 2 && a2 >= 1)
      {
        if (a5) {
          BOOL v23 = v18 == 0;
        }
        else {
          BOOL v23 = 1;
        }
        int v24 = !v23;
        do
        {
          uint64_t v25 = 214013 * *a3 + 2531011;
          *a3 = v25;
          uint64_t v26 = v25 % v16;
          *(double *)&long long v27 = C3DMeshSourceGetValueAtIndexAsVector3(v14, v25 % v16);
          *a4 = v27;
          if (v24)
          {
            *(double *)&long long v28 = C3DMeshSourceGetValueAtIndexAsVector3(v18, v26);
            *a5 = v28;
          }
          ++a5;
          ++a4;
          --a2;
        }
        while (a2);
      }
      return;
    }
    if (a2 < 1) {
      return;
    }
    uint64_t v30 = 0;
    uint64_t v63 = a4;
    uint64_t v64 = a5;
    CFArrayRef v61 = ElementsCount;
    uint64_t v62 = v12;
    while (1)
    {
      uint64_t v31 = 214013 * *a3 + 2531011;
      *a3 = v31;
      uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v12, v31 % (uint64_t)ElementsCount, 1);
      Primitiveuint64_t Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      uint64_t v34 = 214013 * *a3 + 2531011;
      *a3 = v34;
      uint64_t IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive((uint64_t)ElementAtIndex);
      if (IndexCountPerPrimitive >= 1)
      {
        uint64_t v39 = 0;
        uint64_t v40 = v34 % PrimitiveCount;
        do
        {
          uint64_t Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v40, v39, 0);
          *(double *)&long long v36 = C3DMeshSourceGetValueAtIndexAsVector3(v14, Index);
          *((_OWORD *)&v70 + v39) = v36;
          if (v18)
          {
            *(double *)&long long v36 = C3DMeshSourceGetValueAtIndexAsVector3(v18, Index);
            *((_OWORD *)&v67 + v39) = v36;
          }
          ++v39;
        }
        while (IndexCountPerPrimitive != v39);
      }
      if (IndexCountPerPrimitive == 1)
      {
        uint64_t v42 = v64;
        v63[v30] = v70;
        Elementsuint64_t Count = v61;
        uint64_t v12 = v62;
        if (v64)
        {
          float32x4_t v55 = v67;
LABEL_54:
          v42[v30] = v55;
        }
      }
      else
      {
        uint64_t v42 = v64;
        Elementsuint64_t Count = v61;
        uint64_t v12 = v62;
        if (IndexCountPerPrimitive != 2)
        {
          if (IndexCountPerPrimitive != 3) {
            goto LABEL_55;
          }
          unsigned int v43 = 214013 * *a3 + 2531011;
          float v44 = (float)HIWORD(v43) * 0.000015259;
          unsigned int v45 = 214013 * v43 + 2531011;
          float v46 = (float)HIWORD(v45) * 0.000015259;
          unsigned int v47 = 214013 * v45 + 2531011;
          *a3 = v47;
          float v48 = (float)HIWORD(v47) * 0.000015259;
          float v49 = 1.0 / (float)((float)(v44 + v46) + v48);
          *(float *)v37.i32 = v44 * v49;
          float v50 = v46 * v49;
          v63[v30] = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v71, v46 * v49), v70, *(float *)v37.i32), v72, v48 * v49);
          if (!v64) {
            goto LABEL_55;
          }
          *(float *)v38.i32 = v48 * v49;
          float32x4_t v51 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v68, v50), v67, (float32x4_t)vdupq_lane_s32(v37, 0)), v69, (float32x4_t)vdupq_lane_s32(v38, 0));
          int32x4_t v52 = (int32x4_t)vmulq_f32(v51, v51);
          v52.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v52, 2), vadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v52.i8, 1))).u32[0];
          float32x2_t v53 = vrsqrte_f32((float32x2_t)v52.u32[0]);
          float32x2_t v54 = vmul_f32(v53, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v53, v53)));
          float32x4_t v55 = vmulq_n_f32(v51, vmul_f32(v54, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v54, v54))).f32[0]);
          goto LABEL_54;
        }
        unsigned int v56 = 214013 * *a3 + 2531011;
        *a3 = v56;
        *(float *)&long long v36 = (float)HIWORD(v56) * 0.000015259;
        v63[v30] = vmlaq_n_f32(v70, vsubq_f32(v71, v70), *(float *)&v36);
        if (v64)
        {
          float32x4_t v57 = vmlaq_f32(v67, vsubq_f32(v68, v67), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v36, 0));
          int32x4_t v58 = (int32x4_t)vmulq_f32(v57, v57);
          v58.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v58, 2), vadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v58.i8, 1))).u32[0];
          float32x2_t v59 = vrsqrte_f32((float32x2_t)v58.u32[0]);
          float32x2_t v60 = vmul_f32(v59, vrsqrts_f32((float32x2_t)v58.u32[0], vmul_f32(v59, v59)));
          float32x4_t v55 = vmulq_n_f32(v57, vmul_f32(v60, vrsqrts_f32((float32x2_t)v58.u32[0], vmul_f32(v60, v60))).f32[0]);
          goto LABEL_54;
        }
      }
LABEL_55:
      if (++v30 == a2) {
        return;
      }
    }
  }
  if ((C3DGeometryGeneratePoints_done & 1) == 0)
  {
    C3DGeometryGeneratePoints_done = 1;
    CFArrayRef v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      C3DGeometryGeneratePoints_cold_2();
    }
  }
}

BOOL C3DGeometryMeshElementsSupportsTessellation(uint64_t a1)
{
  char v1 = *(unsigned char *)(a1 + 208);
  int v2 = v1 & 3;
  if ((v1 & 3) == 0)
  {
    int v2 = 1;
    CFArrayRef MeshElements = (const __CFArray *)C3DMeshGetMeshElements(*(void *)(a1 + 64), 1);
    CFIndex Count = CFArrayGetCount(MeshElements);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(MeshElements, v7);
        if (C3DMeshElementGetType((uint64_t)ValueAtIndex)) {
          break;
        }
        if (v6 == ++v7)
        {
          int v2 = 1;
          goto LABEL_8;
        }
      }
      int v2 = 2;
    }
LABEL_8:
    *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x690], 8) = v2 | v1 & 0xFC;
  }
  return v2 == 1;
}

__n128 C3DGeometryGetTessellator@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *(__n128 *)(a1 + 184);
  *a2 = result;
  a2[1].n128_u64[0] = *(void *)(a1 + 200);
  return result;
}

uint64_t C3DGeometryCreatePositionSourceForDeformerBasedDynamicMesh(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 128))();
}

uint64_t C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 128) + 8))();
}

uint64_t _C3DGeometryGetBoundingSphere(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result = C3DGeometryGetMesh(a1);
  if (result)
  {
    return C3DMeshGetBoundingSphere(result, a3);
  }
  return result;
}

void _C3DGeometryDidTransferFromScene(uint64_t a1)
{
  uint64_t Mesh = C3DGeometryGetMesh(a1);
  if (Mesh)
  {
    uint64_t Copy = (uint64_t *)C3DMeshCreateCopy(Mesh);
    C3DGeometrySetMesh(a1, Copy);
    if (Copy)
    {
      CFRelease(Copy);
    }
  }
}

uint64_t _C3DGeometrySearchByID(uint64_t a1, const void *a2)
{
  uint64_t v3 = a1;
  ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return v3;
  }
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(v3);
  if ((uint64_t)MaterialsCount >= 1)
  {
    CFArrayRef v6 = MaterialsCount;
    uint64_t v7 = 0;
    do
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(v3, v7);
      uint64_t v9 = C3DSearchByID(MaterialAtIndex, (uint64_t)a2);
      if (v9) {
        return v9;
      }
    }
    while (v6 != (const __CFArray *)++v7);
  }
  uint64_t Mesh = (const void *)C3DGeometryGetMesh(v3);

  return C3DSearchByID(Mesh, (uint64_t)a2);
}

id _C3DImageToMDLTexture(__C3DImage *a1, char a2)
{
  if ((a2 & 1) == 0 && C3DImageIsCubeMap((uint64_t)a1))
  {
    VerticalStripCubemapWithuint64_t Image = (__C3DImage *)C3DImageCreateVerticalStripCubemapWithImage((uint64_t)a1);
    uint64_t v4 = _C3DImageToMDLTexture(VerticalStripCubemapWithImage, 1);
    CFRelease(VerticalStripCubemapWithImage);
    return (id)v4;
  }
  if (C3DImageGetImageType((uint64_t)a1) == 2)
  {
    CFArrayRef v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      _C3DImageToMDLTexture(v6, v7, v8);
    }
    return 0;
  }
  uint64_t v9 = (CGContext *)C3DImageCopyBitmap((uint64_t)a1, 1);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  DatSCNMatrix4 a = CGBitmapContextGetData(v9);
  double Size = C3DImageGetSize((uint64_t)a1);
  size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(v10);
  size_t BitsPerPixel = CGBitmapContextGetBitsPerPixel(v10);
  if (BitsPerComponent != 8)
  {
    CFRelease(v10);
    return 0;
  }
  size_t v14 = BitsPerPixel >> 3;
  id v15 = objc_alloc(MEMORY[0x263F13678]);
  uint64_t v16 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", Data, (unint64_t)vmuls_lane_f32((float)CGBitmapContextGetBytesPerRow(v10), *(float32x2_t *)&Size, 1));
  size_t BytesPerRow = CGBitmapContextGetBytesPerRow(v10);
  LOBYTE(v19) = C3DImageGetImageType((uint64_t)a1) == 3;
  uint64_t v18 = (void *)[v15 initWithData:v16 topLeftOrigin:1 name:0 dimensions:BytesPerRow rowStride:v14 channelCount:1 channelEncoding:COERCE_DOUBLE(vcvt_s32_f32(*(float32x2_t *)&Size)) isCube:v19];
  CFRelease(v10);

  return v18;
}

id flattenObjectInMeshes(simd_float4x4 a1, MDLObject *a2, NSMutableArray *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if ([(MDLObject *)a2 transform])
  {
    objc_msgSend(-[MDLObject transform](a2, "transform"), "matrix");
    uint64_t v5 = 0;
    v21[0] = v6;
    v21[1] = v7;
    void v21[2] = v8;
    v21[3] = v9;
    do
    {
      v22.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a1.columns[0], COERCE_FLOAT(v21[v5])), (float32x4_t)a1.columns[1], *(float32x2_t *)&v21[v5], 1), (float32x4_t)a1.columns[2], (float32x4_t)v21[v5], 2), (float32x4_t)a1.columns[3], (float32x4_t)v21[v5], 3);
      ++v5;
    }
    while (v5 != 4);
    a1 = v22;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v10 = objc_msgSend(objc_alloc(MEMORY[0x263F13688]), "initWithMatrix:", *(double *)a1.columns[0].i64, *(double *)a1.columns[1].i64, *(double *)a1.columns[2].i64, *(double *)a1.columns[3].i64);
    [(MDLObject *)a2 setTransform:v10];

    return (id)[(NSMutableArray *)a3 addObject:a2];
  }
  else
  {
    id result = [(MDLObject *)a2 children];
    if (result)
    {
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v12 = [(MDLObject *)a2 children];
      id result = (id)[v12 countByEnumeratingWithState:&v17 objects:v23 count:16];
      if (result)
      {
        id v13 = result;
        uint64_t v14 = *(void *)v18;
        do
        {
          id v15 = 0;
          do
          {
            if (*(void *)v18 != v14) {
              objc_enumerationMutation(v12);
            }
            flattenObjectInMeshes(a1, *(MDLObject **)(*((void *)&v17 + 1) + 8 * (void)v15), a3);
            id v15 = (char *)v15 + 1;
          }
          while (v13 != v15);
          id result = (id)[v12 countByEnumeratingWithState:&v17 objects:v23 count:16];
          id v13 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

NSMutableArray *FlattenedMDLMeshesFromMDLAsset(MDLAsset *a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  simd_float4 v10 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 16);
  simd_float4 v11 = *(simd_float4 *)MEMORY[0x263EF89A8];
  simd_float4 v8 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 48);
  simd_float4 v9 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 32);
  int v2 = (NSMutableArray *)objc_opt_new();
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v3 = [(MDLAsset *)a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v13;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(a1);
        }
        v18.columns[1] = v10;
        v18.columns[0] = v11;
        v18.columns[3] = v8;
        v18.columns[2] = v9;
        flattenObjectInMeshes(v18, *(MDLObject **)(*((void *)&v12 + 1) + 8 * v6++), v2);
      }
      while (v4 != v6);
      uint64_t v4 = [(MDLAsset *)a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v4);
  }
  return v2;
}

id flattenLightsInMeshes(simd_float4x4 a1, MDLObject *a2, NSMutableArray *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if ([(MDLObject *)a2 transform])
  {
    objc_msgSend(-[MDLObject transform](a2, "transform"), "matrix");
    uint64_t v5 = 0;
    v21[0] = v6;
    v21[1] = v7;
    void v21[2] = v8;
    v21[3] = v9;
    do
    {
      v22.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a1.columns[0], COERCE_FLOAT(v21[v5])), (float32x4_t)a1.columns[1], *(float32x2_t *)&v21[v5], 1), (float32x4_t)a1.columns[2], (float32x4_t)v21[v5], 2), (float32x4_t)a1.columns[3], (float32x4_t)v21[v5], 3);
      ++v5;
    }
    while (v5 != 4);
    a1 = v22;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    simd_float4 v10 = objc_msgSend(objc_alloc(MEMORY[0x263F13688]), "initWithMatrix:", *(double *)a1.columns[0].i64, *(double *)a1.columns[1].i64, *(double *)a1.columns[2].i64, *(double *)a1.columns[3].i64);
    [(MDLObject *)a2 setTransform:v10];

    return (id)[(NSMutableArray *)a3 addObject:a2];
  }
  else
  {
    id result = [(MDLObject *)a2 children];
    if (result)
    {
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v12 = [(MDLObject *)a2 children];
      id result = (id)[v12 countByEnumeratingWithState:&v17 objects:v23 count:16];
      if (result)
      {
        id v13 = result;
        uint64_t v14 = *(void *)v18;
        do
        {
          long long v15 = 0;
          do
          {
            if (*(void *)v18 != v14) {
              objc_enumerationMutation(v12);
            }
            flattenLightsInMeshes(a1, *(MDLObject **)(*((void *)&v17 + 1) + 8 * (void)v15), a3);
            long long v15 = (char *)v15 + 1;
          }
          while (v13 != v15);
          id result = (id)[v12 countByEnumeratingWithState:&v17 objects:v23 count:16];
          id v13 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

NSMutableArray *FlattenedMDLLightsFromMDLAsset(MDLAsset *a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  simd_float4 v10 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 16);
  simd_float4 v11 = *(simd_float4 *)MEMORY[0x263EF89A8];
  simd_float4 v8 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 48);
  simd_float4 v9 = *(simd_float4 *)(MEMORY[0x263EF89A8] + 32);
  int v2 = (NSMutableArray *)objc_opt_new();
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v3 = [(MDLAsset *)a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v13;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(a1);
        }
        v18.columns[1] = v10;
        v18.columns[0] = v11;
        v18.columns[3] = v8;
        v18.columns[2] = v9;
        flattenLightsInMeshes(v18, *(MDLObject **)(*((void *)&v12 + 1) + 8 * v6++), v2);
      }
      while (v4 != v6);
      uint64_t v4 = [(MDLAsset *)a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v4);
  }
  return v2;
}

SCNScene *loadMDLAssetWithURL(void *a1, void *a2)
{
  v22[2] = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)[a2 objectForKeyedSubscript:@"kSceneSourcePreserveOriginalTopology"];
  if (v4) {
    uint64_t v5 = [v4 BOOLValue];
  }
  else {
    uint64_t v5 = C3DPreserveOriginalTopologyDefaultValue();
  }
  uint64_t v6 = v5;
  if ([MEMORY[0x263F135E8] instancesRespondToSelector:sel_initThroughSCNKitBridgeWithURL_options_error_])
  {
    if (C3DWasLinkedBeforeMajorOSYear2023())
    {
      uint64_t v19 = *MEMORY[0x263F13570];
      uint64_t v20 = [NSNumber numberWithBool:v6];
      uint64_t v7 = [NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
    }
    else
    {
      uint64_t v15 = 0;
      uint64_t v16 = &v15;
      uint64_t v17 = 0x2020000000;
      simd_float4 v9 = (__CFString **)getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr;
      uint64_t v18 = getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr;
      if (!getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr)
      {
        v14[0] = MEMORY[0x263EF8330];
        v14[1] = 3221225472;
        v14[2] = ___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke;
        v14[3] = &unk_264004AF0;
        uint8_t v14[4] = &v15;
        ___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke((uint64_t)v14);
        simd_float4 v9 = (__CFString **)v16[3];
      }
      _Block_object_dispose(&v15, 8);
      if (!v9) {
        loadMDLAssetWithURL_cold_1();
      }
      if (*v9) {
        simd_float4 v10 = *v9;
      }
      else {
        simd_float4 v10 = @"kMDLAssetDefaultUSDColorSpace";
      }
      v21[0] = *MEMORY[0x263F13570];
      v22[0] = [NSNumber numberWithBool:v6];
      v21[1] = v10;
      v22[1] = C3DColorSpaceLinearDisplayP3();
      uint64_t v7 = [NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:2];
    }
    uint64_t v8 = [objc_alloc(MEMORY[0x263F135E8]) initThroughSCNKitBridgeWithURL:a1 options:v7 error:0];
  }
  else
  {
    uint64_t v8 = [objc_alloc(MEMORY[0x263F135E8]) initThroughSCNKitBridgeWithURL:a1 preserveTopology:v6 error:0];
  }
  simd_float4 v11 = (void *)v8;
  if (((C3DIsRunningInXcode() & 1) != 0
     || objc_msgSend((id)objc_msgSend(a2, "valueForKey:", @"SCNSceneSourceLoadTexturesInCPUMemory"), "BOOLValue"))&& objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "pathExtension"), "lowercaseString"), "isEqualToString:", @"usdz"))
  {
    [v11 loadTextures];
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08B88], "currentThread"), "threadDictionary"), "setValue:forKey:", objc_msgSend(v11, "resolver"), @"SCN_MDLCurrentAssetResolver");
  if (!v11) {
    return 0;
  }
  long long v12 = +[SCNScene sceneWithMDLAsset:v11 options:a2];
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08B88], "currentThread"), "threadDictionary"), "setValue:forKey:", 0, @"SCN_MDLCurrentAssetResolver");

  return v12;
}

void sub_20B2CF920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SCNNodesToMDLAsset(void *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  id result = objc_alloc_init(MEMORY[0x263F135E8]);
  if (result)
  {
    uint64_t v3 = result;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    uint64_t v4 = [a1 countByEnumeratingWithState:&v8 objects:v12 count:16];
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)v9;
      do
      {
        uint64_t v7 = 0;
        do
        {
          if (*(void *)v9 != v6) {
            objc_enumerationMutation(a1);
          }
          objc_msgSend(v3, "addObject:", objc_msgSend(MEMORY[0x263F13638], "objectWithSCNNode:", *(void *)(*((void *)&v8 + 1) + 8 * v7++)));
        }
        while (v5 != v7);
        uint64_t v5 = [a1 countByEnumeratingWithState:&v8 objects:v12 count:16];
      }
      while (v5);
    }
    return v3;
  }
  return result;
}

id jointNodesFromMDLSkinDeformer(void *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v3 = (void *)[a1 jointPaths];
  uint64_t v4 = objc_opt_new();
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v3);
        }
        uint64_t v9 = *(void *)(*((void *)&v12 + 1) + 8 * i);
        uint64_t v10 = [a2 objectForKeyedSubscript:v9];
        if (!v10)
        {
          NSLog(&cfstr_WhileCreatingS.isa, v9);
          [v4 removeAllObjects];
          return v4;
        }
        [v4 addObject:v10];
      }
      uint64_t v6 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  return v4;
}

id boneInverseTransformsFromMDLSkinDeformer(void *a1)
{
  int v2 = objc_opt_new();
  uint64_t v3 = objc_msgSend((id)objc_msgSend(a1, "jointBindTransforms"), "bytes");
  unint64_t v4 = objc_msgSend((id)objc_msgSend(a1, "jointBindTransforms"), "length");
  [a1 meshBindTransform];
  long long v15 = v6;
  long long v16 = v5;
  long long v13 = v8;
  long long v14 = v7;
  if (v4 >= 0x40)
  {
    uint64_t v9 = 0;
    unint64_t v10 = v4 >> 6;
    do
    {
      simd_float4x4 v20 = __invert_f4(*(simd_float4x4 *)(v3 + (v9 << 6)));
      uint64_t v11 = 0;
      v18[0] = v16;
      v18[1] = v15;
      v18[2] = v14;
      v18[3] = v13;
      do
      {
        v19[v11] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v20.columns[0], COERCE_FLOAT(v18[v11])), (float32x4_t)v20.columns[1], *(float32x2_t *)&v18[v11], 1), (float32x4_t)v20.columns[2], (float32x4_t)v18[v11], 2), (float32x4_t)v20.columns[3], (float32x4_t)v18[v11], 3);
        ++v11;
      }
      while (v11 != 4);
      v17[0] = v19[0];
      v17[1] = v19[1];
      void v17[2] = v19[2];
      v17[3] = v19[3];
      objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", v17));
      ++v9;
    }
    while (v9 != v10);
  }
  return v2;
}

void *createFloatAnimation(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v4 = *(double **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v5 = v3 - *(void *)a2;
  if (v3 == *(void *)a2) {
    return 0;
  }
  double v6 = *v4;
  double v7 = *(double *)(v3 - 8) - *v4;
  if (v7 < 2.22044605e-16) {
    return 0;
  }
  unint64_t v12 = v5 >> 3;
  long long v13 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:v5 >> 3];
  long long v14 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:v12];
  uint64_t v15 = 0;
  if (v12 <= 1) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = v12;
  }
  do
  {
    uint64_t v17 = [NSNumber numberWithDouble:(*(double *)(*(void *)a2 + 8 * v15) - v6) / v7];
    LODWORD(v1_Block_object_dispose(&STACK[0x690], 8) = *(_DWORD *)(*a3 + 4 * v15);
    uint64_t v19 = [NSNumber numberWithFloat:v18];
    [v13 addObject:v17];
    [v14 addObject:v19];
    ++v15;
  }
  while (v16 != v15);
  long long v8 = (void *)[MEMORY[0x263F157D8] animationWithKeyPath:a1];
  [v8 setValues:v14];
  [v8 setKeyTimes:v13];
  [v8 setDuration:v7];
  [v8 setBeginTime:v6];
  [v8 setAdditive:0];
  [v8 setRemovedOnCompletion:0];
  return v8;
}

id morpherFromMDLMorphDeformer(void *a1)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v30 = (id)objc_opt_new();
  int v2 = objc_opt_new();
  uint64_t v3 = objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetCounts"), "count");
  uint64_t v4 = objc_msgSend((id)objc_msgSend(a1, "targetShapes"), "count");
  if (v4)
  {
    uint64_t v5 = v4;
    for (uint64_t i = 0; i != v5; ++i)
    {
      double v7 = objc_msgSend((id)objc_msgSend(a1, "targetShapes"), "objectAtIndexedSubscript:", i);
      long long v8 = +[SCNGeometry geometryWithMDLMesh:v7];
      -[SCNGeometry setName:](v8, "setName:", [v7 name]);
      [(SCNGeometry *)v8 setEdgeCreasesSource:0];
      [(SCNGeometry *)v8 setEdgeCreasesElement:0];
      [v2 addObject:v8];
    }
  }
  if (v3)
  {
    uint64_t v9 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:0];
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetCounts"), "objectAtIndexedSubscript:", v10), "unsignedIntegerValue");
      uint64_t v13 = v12 - 1;
      if (v12 != 1)
      {
        uint64_t v14 = v13 + v11;
        do
        {
          uint64_t v15 = objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetWeights"), "objectAtIndexedSubscript:", v11);
          [v9 addObject:v15];
          [v15 floatValue];
          if (v16 >= 1.0)
          {
            uint64_t v17 = scn_default_log();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
            {
              [v15 floatValue];
              *(_DWORD *)float32x4_t buf = 136315394;
              *(void *)&uint8_t buf[4] = "influenceWeightNumber.floatValue < 1.f";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(double *)&buf[14] = v18;
              _os_log_fault_impl(&dword_20B249000, v17, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Found in-between morph target with influence weight of %f", buf, 0x16u);
            }
          }
          ++v11;
          --v13;
        }
        while (v13);
        uint64_t v11 = v14;
      }
      ++v11;
      ++v10;
    }
    while (v10 != v3);
    objc_msgSend(v30, "setTargets:withInBetweenTargetCounts:inBetweenWeights:", v2, objc_msgSend(a1, "shapeSetTargetCounts"), v9);
  }
  else
  {
    [v30 setTargets:v2];
  }
  uint64_t v19 = (void *)[a1 weights];
  unint64_t v20 = [v19 elementCount];
  memset(buf, 0, sizeof(buf));
  if (v20)
  {
    std::vector<float>::__vallocate[abi:nn180100](buf, v20);
    uint64_t v21 = *(void *)&buf[8];
    bzero(*(void **)&buf[8], 4 * v20);
    *(void *)&buf[8] = v21 + 4 * v20;
  }
  if (objc_msgSend((id)objc_msgSend(v19, "keyTimes"), "count"))
  {
    uint64_t v22 = *(void *)buf;
    uint64_t v23 = [v19 elementCount];
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v19, "keyTimes"), "objectAtIndexedSubscript:", 0), "doubleValue");
    objc_msgSend(v19, "getFloatArray:maxCount:atTime:", v22, v23);
  }
  uint64_t v24 = objc_opt_new();
  uint64_t v26 = *(_DWORD **)buf;
  for (CFIndex j = *(_DWORD **)&buf[8]; v26 != j; ++v26)
  {
    LODWORD(v25) = *v26;
    objc_msgSend(v24, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v25));
  }
  [v30 setWeights:v24];

  id v28 = v30;
  if (*(void *)buf)
  {
    *(void *)&buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  return v28;
}

void sub_20B2D019C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void addMorphAnimation(void *a1, void *a2, void *a3)
{
  if ([a2 morpher])
  {
    uint64_t v4 = (void *)[a1 weights];
    if ([v4 isAnimated])
    {
      unint64_t v5 = [v4 timeSampleCount];
      uint64_t v6 = [v4 elementCount];
      long long v36 = 0;
      int32x2_t v37 = 0;
      uint64_t v38 = 0;
      if (v5)
      {
        std::vector<Statement *>::__vallocate[abi:nn180100](&v36, v5);
        double v7 = (char *)v37;
        bzero(v37, 8 * v5);
        int32x2_t v37 = &v7[8 * v5];
        long long v8 = v36;
      }
      else
      {
        long long v8 = 0;
      }
      [v4 getTimes:v8 maxCount:v5];
      unint64_t v9 = v6 * v5;
      CFIndex v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      if (v6 * v5)
      {
        std::vector<float>::__vallocate[abi:nn180100](&v33, v6 * v5);
        uint64_t v10 = (char *)v34;
        bzero(v34, 4 * v9);
        uint64_t v34 = &v10[4 * v9];
      }
      if (v6) {
        [v4 getFloatArray:v33 maxCount:v6 * v5];
      }
      std::string __p = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      if (v5)
      {
        std::vector<float>::__vallocate[abi:nn180100](&__p, v5);
        uint64_t v11 = (char *)v31;
        bzero(v31, 4 * v5);
        uint64_t v31 = &v11[4 * v5];
      }
      if (v6)
      {
        uint64_t v12 = 0;
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (v5)
          {
            uint64_t v14 = __p;
            uint64_t v15 = (char *)v33 + v12;
            unint64_t v16 = v5;
            do
            {
              *v14++ = *v15;
              v15 += v6;
              --v16;
            }
            while (v16);
          }
          uint64_t v17 = createFloatAnimation(objc_msgSend(NSString, "stringWithFormat:", @"morpher.weights[%d]", i), (uint64_t)&v36, &__p);
          float v18 = v17;
          if (v17)
          {
            [v17 duration];
            if (v19 != 0.0)
            {
              unint64_t v20 = (void *)[a3 valueForKey:@"kSceneSourceAnimationLoadingMode"];
              uint64_t v22 = v20;
              if (v20)
              {
                objc_msgSend(v18, "setUsesSceneTimeBase:", objc_msgSend(v20, "isEqualToString:", @"playUsingSceneTime"));
                objc_msgSend(v18, "setRemovedOnCompletion:", objc_msgSend(v22, "isEqualToString:", @"playUsingSceneTime") ^ 1);
                int v23 = [v22 isEqualToString:@"playRepeatedly"];
                LODWORD(v21) = 2139095040;
                if (!v23) {
                  *(float *)&double v21 = 0.0;
                }
              }
              else
              {
                LODWORD(v21) = 2139095040;
              }
              [v18 setRepeatCount:v21];
              if (([v18 usesSceneTimeBase] & 1) == 0)
              {
                [v18 beginTime];
                if (v24 != 0.0)
                {
                  C3DTransactionGetAtomicTime();
                  double v26 = v25;
                  [v18 beginTime];
                  [v18 setBeginTime:v26 + v27];
                }
              }
              [a2 addAnimation:v18 forKey:0];
            }
          }
          v12 += 4;
        }
      }
      if (__p)
      {
        uint64_t v31 = __p;
        operator delete(__p);
      }
      if (v33)
      {
        uint64_t v34 = v33;
        operator delete(v33);
      }
      if (v36)
      {
        int32x2_t v37 = v36;
        operator delete(v36);
      }
    }
  }
}

void sub_20B2D04B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_20B2D119C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
}

void anonymous namespace'::_loadAnimations(_anonymous_namespace_ *a1, void *a2, void *a3, void *a4, uint64_t **a5)
{
  uint64_t v100 = a4;
  uint64_t v142 = *MEMORY[0x263EF8340];
  long long v123 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v126 = 0u;
  float v95 = a1;
  long long v8 = (void *)[(_anonymous_namespace_ *)a1 children];
  uint64_t v9 = [v8 countByEnumeratingWithState:&v123 objects:v139 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v124;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v124 != v10) {
          objc_enumerationMutation(v8);
        }
      }
      uint64_t v9 = [v8 countByEnumeratingWithState:&v123 objects:v139 count:16];
    }
    while (v9);
  }
  uint64_t v13 = [(_anonymous_namespace_ *)v95 componentConformingToProtocol:&unk_26BFFFD70];
  if (v13)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v14 = (void *)v13;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v122 = BoundSkeleton;
  if (BoundSkeleton)
  {
    unint64_t v16 = objc_opt_new();
    std::string __p = 0;
    long long v120 = 0;
    uint64_t v121 = 0;
    if ([v16 count])
    {
      uint64_t v89 = (uint64_t)a5;
      unint64_t v98 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend((id)objc_msgSend(BoundSkeleton, "jointPaths"), "count"));
      uint64_t v17 = (uint64_t *)[v14 skeleton];
      float v135 = v17;
      if ([v14 jointPaths]) {
        double v19 = (uint64_t *)v14;
      }
      else {
        double v19 = v17;
      }
      unint64_t v20 = (void *)[v19 jointPaths];
      long long v133 = 0u;
      long long v134 = 0u;
      long long v131 = 0u;
      long long v132 = 0u;
      uint64_t v21 = [v20 countByEnumeratingWithState:&v131 objects:v141 count:16];
      obuint64_t j = v16;
      uint64_t v93 = (uint64_t)v14;
      uint64_t v87 = (uint64_t)a3;
      uint64_t v22 = 0;
      if (v21)
      {
        uint64_t v23 = *(void *)v132;
        do
        {
          for (uint64_t j = 0; j != v21; ++j)
          {
            if (*(void *)v132 != v23) {
              objc_enumerationMutation(v20);
            }
            uint64_t v25 = *(void *)(*((void *)&v131 + 1) + 8 * j);
            uint64_t v26 = [*v18 objectForKeyedSubscript:v25];
            if (v26)
            {
              [v98 addObject:v26];
            }
            else
            {
              if (!v22) {
                uint64_t v22 = objc_msgSend(objc_alloc(MEMORY[0x263EFF980]), "initWithCapacity:", objc_msgSend(v20, "count"));
              }
              [v22 addObject:v25];
            }
          }
          uint64_t v21 = [v20 countByEnumeratingWithState:&v131 objects:v141 count:16];
        }
        while (v21);
        if (v22)
        {
          a3 = (void *)v87;
          unint64_t v16 = obj;
          uint64_t v14 = (void *)v93;
          if ([v22 count])
          {
            long long v129 = 0u;
            long long v130 = 0u;
            long long v127 = 0u;
            long long v128 = 0u;
            uint64_t v27 = [v22 countByEnumeratingWithState:&v127 objects:v140 count:16];
            if (v27)
            {
              uint64_t v28 = *(void *)v128;
              do
              {
                for (uint64_t k = 0; k != v27; ++k)
                {
                  if (*(void *)v128 != v28) {
                    objc_enumerationMutation(v22);
                  }
                  NSLog(&cfstr_BadJointPathDe.isa, *(void *)(*((void *)&v127 + 1) + 8 * k));
                }
                uint64_t v27 = [v22 countByEnumeratingWithState:&v127 objects:v140 count:16];
              }
              while (v27);
            }
          }
        }
        else
        {
          a3 = (void *)v87;
          unint64_t v16 = obj;
          uint64_t v14 = (void *)v93;
        }
      }

              v101,
              *((uint64_t *)&v101 + 1),
              v102,
              *((uint64_t *)&v102 + 1),
              v103,
              v104,
              v105,
              v106,
              v107,
              v108,
              v109,
              v110,
              v111,
              *((uint64_t *)&v111 + 1),
              v112,
              *((uint64_t *)&v112 + 1));
      long long v117 = 0u;
      long long v118 = 0u;
      long long v115 = 0u;
      long long v116 = 0u;
      uint64_t v39 = [v16 countByEnumeratingWithState:&v115 objects:v138 count:16];
      if (v39)
      {
        uint64_t v40 = *(void *)v116;
        do
        {
          for (uint64_t m = 0; m != v39; ++m)
          {
            if (*(void *)v116 != v40) {
              objc_enumerationMutation(obja);
            }
            uint64_t v42 = *(_anonymous_namespace_ **)(*((void *)&v115 + 1) + 8 * m);
            unsigned int v43 = objc_msgSend(a2, "objectForKeyedSubscript:", -[_anonymous_namespace_ path](v42, "path"));
            uint64_t v44 = [v43 geometry];
            uint64_t v49 = [(_anonymous_namespace_ *)v42 componentConformingToProtocol:&unk_26BFFFD70];
            if (v42 != v95 && (float32x4_t v51 = (void *)v49) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              [v51 geometryBindTransform];
              v114[0] = v53;
              v114[1] = v54;
              v114[2] = v55;
              v114[3] = v56;
              [(SCNSkinner *)v48 setBaseGeometryBindTransform:v114];
            }
            else
            {
              if (v94) {
                [v94 geometryBindTransform];
              }
              else {
                memset(v141, 0, sizeof(v141));
              }
              v113[0] = v57;
              v113[1] = v58;
              v113[2] = v59;
              void v113[3] = v60;
              [(SCNSkinner *)v48 setBaseGeometryBindTransform:v113];
            }
            [(SCNSkinner *)v48 setSkeleton:v97];
            [v43 setSkinner:v48];
          }
          unint64_t v16 = obja;
          uint64_t v39 = [obja countByEnumeratingWithState:&v115 objects:v138 count:16];
        }
        while (v39);
        a3 = v88;
        a5 = v90;
        uint64_t v14 = v94;
      }
      else
      {
        a5 = v90;
      }
    }
    else
    {
      uint64_t v97 = 0;
    }

    if (__p)
    {
      long long v120 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v97 = 0;
  }
  if (v14)
  {
    CFArrayRef v61 = (_anonymous_namespace_ *)[v14 jointAnimation];
    if (v61)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        if (!v97) {
          uint64_t v97 = objc_msgSend(a2, "objectForKeyedSubscript:", -[_anonymous_namespace_ path](v95, "path"));
        }
        uint64_t v62 = objc_msgSend(v100, "objectForKeyedSubscript:", -[_anonymous_namespace_ name](v61, "name"));
        if (v62)
        {
          objc_msgSend(v97, "addAnimation:forKey:", v62, -[_anonymous_namespace_ name](v61, "name"));
          char v63 = 1;
        }
        else
        {
          char v63 = 0;
        }
        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        uint64_t v64 = (void *)[a3 animations];
        uint64_t v65 = [v64 countByEnumeratingWithState:&v109 objects:v137 count:16];
        if (v65)
        {
          uint64_t v66 = *(void *)v110;
          do
          {
            for (uint64_t n = 0; n != v65; ++n)
            {
              if (*(void *)v110 != v66) {
                objc_enumerationMutation(v64);
              }
              float32x4_t v68 = *(_anonymous_namespace_ **)(*((void *)&v109 + 1) + 8 * n);
              if (v68 != v61)
              {
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  if (RootNodeName)
                  {
                    if (v72)
                    {
                      if ([RootNodeName isEqualToString:v72])
                      {
                        uint64_t v73 = objc_msgSend(v100, "objectForKeyedSubscript:", -[_anonymous_namespace_ name](v68, "name"));
                        if (v73)
                        {
                          objc_msgSend(v97, "addAnimation:forKey:", v73, -[_anonymous_namespace_ name](v68, "name"));
                          char v63 = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
            uint64_t v65 = [v64 countByEnumeratingWithState:&v109 objects:v137 count:16];
          }
          while (v65);
        }
        uint64_t v74 = v122;
        if (v122)
        {
          if (v63)
          {
            long long v107 = 0u;
            long long v108 = 0u;
            long long v105 = 0u;
            long long v106 = 0u;
            long long v76 = (void *)[v74 jointPaths];
            uint64_t v77 = [v76 countByEnumeratingWithState:&v105 objects:v136 count:16];
            if (v77)
            {
              uint64_t v78 = *(void *)v106;
              float32x4_t v79 = (long long *)MEMORY[0x263EF89A8];
              do
              {
                for (iuint64_t i = 0; ii != v77; ++ii)
                {
                  if (*(void *)v106 != v78) {
                    objc_enumerationMutation(v76);
                  }
                  int8x16_t v81 = (void *)[*v75 objectForKeyedSubscript:*(void *)(*((void *)&v105 + 1) + 8 * ii)];
                  if (v81)
                  {
                    long long v82 = v79[1];
                    long long v83 = v79[2];
                    long long v84 = v79[3];
                    long long v101 = *v79;
                    long long v102 = v82;
                    long long v103 = v83;
                    long long v104 = v84;
                    [v81 setTransform:&v101];
                  }
                }
                uint64_t v77 = [v76 countByEnumeratingWithState:&v105 objects:v136 count:16];
              }
              while (v77);
            }
          }
        }
      }
    }
  }
}

void sub_20B2D19F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void UniqueVertices()
{
}

id uniqueIndexBufferWithSCNGeometryElements(void *a1, uint64_t a2, std::vector<int> *a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
  id v7 = objc_alloc_init(MEMORY[0x263EFF980]);
  if ([a1 count])
  {
    char v8 = 0;
    int v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = (void *)[a1 objectAtIndexedSubscript:v10];
      if ([v11 indicesChannelCount] >= 2)
      {
        *a5 = [v11 indicesChannelCount];
        char v8 = 1;
      }
      unint64_t v12 = objc_msgSend((id)objc_msgSend(v11, "data"), "length");
      v9 += v12 / [v11 bytesPerIndex];
      ++v10;
    }
    while (v10 < [a1 count]);
    if (v8)
    {
      std::vector<int>::value_type __u = -1;
      std::vector<int>::assign(a3, v9, &__u);
      if ([a1 count])
      {
        uint64_t v13 = (void *)[a1 objectAtIndexedSubscript:0];
        [v13 hasInterleavedIndicesChannels];
        unint64_t v14 = [v13 indicesChannelCount];
        unint64_t v15 = [v13 bytesPerIndex];
        uint64_t v16 = [v13 primitiveCount];
        objc_msgSend((id)objc_msgSend(v13, "data"), "bytes");
        unint64_t v17 = objc_msgSend((id)objc_msgSend(v13, "data"), "length");
        if ([v13 primitiveType] == 1 || objc_msgSend(v13, "primitiveType") != 4)
        {
          objc_msgSend((id)objc_msgSend(v13, "data"), "bytes");
        }
        else
        {
          float v18 = objc_msgSend((id)objc_msgSend(v13, "data"), "subdataWithRange:", v16 * v15, objc_msgSend((id)objc_msgSend(v13, "data"), "length") - v16 * v15);
          [v18 bytes];
          unint64_t v17 = [v18 length];
        }
        malloc_type_malloc((v17 / v15) / v14 * v15, 0xFF6C3F43uLL);
        UniqueVertices();
      }
    }
  }
  return v7;
}

void std::vector<int>::assign(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __u)
{
  uint64_t value = (uint64_t)this->__end_cap_.__value_;
  begiuint64_t n = this->__begin_;
  if (__n <= (value - (uint64_t)begin) >> 2)
  {
    std::vector<int>::pointer end = this->__end_;
    std::vector<int>::size_type v14 = end - begin;
    if (v14 >= __n) {
      std::vector<int>::size_type v15 = __n;
    }
    else {
      std::vector<int>::size_type v15 = end - begin;
    }
    if (v15)
    {
      uint64_t v16 = begin;
      do
      {
        *v16++ = *__u;
        --v15;
      }
      while (v15);
    }
    if (__n <= v14)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      unint64_t v17 = &end[__n - v14];
      std::vector<int>::size_type v18 = 4 * __n - 4 * v14;
      do
      {
        *end++ = *__u;
        v18 -= 4;
      }
      while (v18);
      this->__end_ = v17;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      uint64_t value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62) {
      abort();
    }
    std::vector<int>::size_type v8 = value >> 1;
    if (value >> 1 <= __n) {
      std::vector<int>::size_type v8 = __n;
    }
    if ((unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    std::vector<float>::__vallocate[abi:nn180100](this, v9);
    std::vector<int>::pointer v10 = this->__end_;
    uint64_t v11 = &v10[__n];
    std::vector<int>::size_type v12 = 4 * __n;
    do
    {
      *v10++ = *__u;
      v12 -= 4;
    }
    while (v12);
    this->__end_ = v11;
  }
}

void *remapVertexAttributeBuffer(void *a1, int a2, void *a3, void *a4, int a5, int a6, int a7, char *a8)
{
  int v11 = [a1 dataStride];
  id result = (void *)[a1 dataOffset];
  uint64_t v13 = (int)result;
  int v23 = a6;
  if (a6 >= 1)
  {
    uint64_t v14 = 0;
    int v15 = a2 - 1;
    uint64_t v16 = a8;
    do
    {
      if (a2) {
        int v17 = *(_DWORD *)(*a3 + 4 * v15);
      }
      else {
        int v17 = v14;
      }
      id result = memcpy(v16, (const void *)(objc_msgSend((id)objc_msgSend(a1, "data"), "bytes") + v13 + (v17 * v11)), v11);
      ++v14;
      v16 += v11;
      v15 += a5;
    }
    while (v23 != v14);
  }
  if (a7 >= 1)
  {
    uint64_t v18 = a7;
    double v19 = &a8[v11 * (uint64_t)v23];
    uint64_t v20 = 4 * a2;
    do
    {
      id result = memcpy(v19, (const void *)(objc_msgSend((id)objc_msgSend(a1, "data"), "bytes")+ v13+ (*(_DWORD *)(*a4 + v20) * v11)), v11);
      v19 += v11;
      v20 += 4 * (a5 + 1);
      --v18;
    }
    while (v18);
  }
  return result;
}

void sub_20B2D3D48(_Unwind_Exception *a1)
{
}

void sub_20B2D4758(_Unwind_Exception *a1)
{
}

void setupMDLMaterialProperty(MDLMaterial *a1, NSString *a2, SCNMaterialProperty *a3, MDLMaterialSemantic a4)
{
  id v7 = [(MDLMaterial *)a1 propertyNamed:a2];
  std::vector<int>::size_type v8 = v7;
  if (!v7) {
    std::vector<int>::size_type v8 = (MDLMaterialProperty *)[objc_alloc(MEMORY[0x263F13610]) initWithName:a2 semantic:a4];
  }
  [(SCNMaterialProperty *)a3 contents];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  id v10 = [(SCNMaterialProperty *)a3 contents];
  if (isKindOfClass)
  {
    objc_msgSend(v10, "scn_colorComponentsForModelIO");
    float32x4_t v43 = v11;
    if (v11.f32[3] == 1.0)
    {
      [(MDLMaterialProperty *)v8 setType:7];
      [(SCNMaterialProperty *)a3 intensity];
      *(float *)&double v12 = v12;
      [(MDLMaterialProperty *)v8 setFloat3Value:*(double *)vmulq_n_f32(v43, *(float *)&v12).i64];
    }
    else
    {
      [(MDLMaterialProperty *)v8 setType:8];
      [(SCNMaterialProperty *)a3 intensity];
      *(float *)&double v31 = v31;
      [(MDLMaterialProperty *)v8 setFloat4Value:*(double *)vmulq_n_f32(v43, *(float *)&v31).i64];
    }
    goto LABEL_27;
  }
  objc_opt_class();
  char v13 = objc_opt_isKindOfClass();
  id v14 = [(SCNMaterialProperty *)a3 contents];
  int v15 = v14;
  if (v13)
  {
    if (v14)
    {
      [(MDLMaterialProperty *)v8 setType:5];
      [(SCNMaterialProperty *)a3 intensity];
      double v17 = v16;
      [v15 floatValue];
      double v19 = v17 * v18;
      *(float *)&double v19 = v19;
      [(MDLMaterialProperty *)v8 setFloatValue:v19];
    }
    goto LABEL_27;
  }
  objc_opt_class();
  char v20 = objc_opt_isKindOfClass();
  id v21 = [(SCNMaterialProperty *)a3 contents];
  if (v20)
  {
    if (!objc_msgSend((id)objc_msgSend(v21, "pathExtension"), "isEqualToString:", @"usdz"))
    {
      [(MDLMaterialProperty *)v8 setType:2];
      [(MDLMaterialProperty *)v8 setURLValue:[(SCNMaterialProperty *)a3 contents]];
      goto LABEL_27;
    }
    uint64_t v22 = [(SCNMaterialProperty *)a3 getC3DImageRef];
    if (!v22) {
      goto LABEL_27;
    }
    id v23 = _C3DImageToMDLTexture(v22, 0);
    if (a3)
    {
      [(SCNMaterialProperty *)a3 contentsTransform];
      int8x16_t v26 = v48;
      int64x2_t v25 = v49;
      __int32 v27 = v48.i32[3];
      __int32 v28 = v49.i32[1];
      int32x4_t v30 = v50;
      int8x16_t v29 = v51;
LABEL_21:
      int8x16_t v33 = vextq_s8(v29, (int8x16_t)vtrn2q_s32(v30, (int32x4_t)v29), 4uLL);
      int8x16_t v34 = (int8x16_t)vzip2q_s64((int64x2_t)v30, v25);
      int8x16_t v24 = vextq_s8(v26, v26, 8uLL);
      *(int8x8_t *)v24.i8 = vext_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v24.i8, 4uLL);
      goto LABEL_25;
    }
    int8x16_t v29 = 0uLL;
    v24.i64[0] = 0;
    __int32 v28 = 0;
    goto LABEL_24;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [(MDLMaterialProperty *)v8 setType:1];
    [(MDLMaterialProperty *)v8 setStringValue:[(SCNMaterialProperty *)a3 contents]];
    goto LABEL_27;
  }
  uint64_t v32 = [(SCNMaterialProperty *)a3 getC3DImageRef];
  if (v32)
  {
    id v23 = _C3DImageToMDLTexture(v32, 0);
    if (a3)
    {
      [(SCNMaterialProperty *)a3 contentsTransform];
      int8x16_t v26 = v44;
      int64x2_t v25 = v45;
      __int32 v27 = v44.i32[3];
      __int32 v28 = v45.i32[1];
      int32x4_t v30 = v46;
      int8x16_t v29 = v47;
      goto LABEL_21;
    }
    int8x16_t v29 = 0uLL;
    v24.i64[0] = 0;
    __int32 v28 = 0;
LABEL_24:
    v30.i32[0] = 0;
    v25.i32[0] = 0;
    __int32 v27 = 0;
    int8x16_t v26 = 0uLL;
    int8x16_t v33 = 0uLL;
    int8x16_t v34 = 0uLL;
LABEL_25:
    int8x16_t v35 = vextq_s8(vextq_s8(v26, v26, 4uLL), v24, 0xCuLL);
    v35.i32[3] = v27;
    v25.i32[1] = v28;
    v25.i64[1] = v34.i64[1];
    int8x16_t v36 = vextq_s8(v33, v34, 8uLL);
    v36.i32[0] = v30.i32[0];
    v52.columns[0] = (simd_float4)v35;
    v52.columns[1] = (simd_float4)v25;
    v52.columns[2] = (simd_float4)v36;
    v52.columns[3] = (simd_float4)vextq_s8(vextq_s8(v29, v29, 4uLL), v33, 0xCuLL);
    double v37 = convertUVTranformForModelIO(&v52);
    if (v23)
    {
      uint64_t v41 = objc_msgSend(objc_alloc(MEMORY[0x263F13688]), "initWithMatrix:", v37, v38, v39, v40);
      id v42 = objc_alloc_init(MEMORY[0x263F13680]);
      [v42 setTransform:v41];
      [v42 setTexture:v23];
      [(MDLMaterialProperty *)v8 setType:3];
      [(MDLMaterialProperty *)v8 setTextureSamplerValue:v42];
    }
  }
LABEL_27:
  if (!v7)
  {
    if (v8) {
  }
    }
}

uint64_t **anonymous namespace'::_makeSkelNodes(void *a1, uint64_t *a2, uint64_t **a3)
{
  int32x4_t v46 = a3;
  int8x16_t v47 = a1;
  uint64_t v67 = *MEMORY[0x263EF8340];
  char v63 = a2;
  uint64_t v4 = objc_opt_new();
  uint64_t v5 = objc_msgSend((id)objc_msgSend(a2, "jointPaths"), "count");
  unsigned int v6 = v5;
  uint64_t v7 = v5;
  std::vector<int>::size_type v8 = objc_msgSend(a2, "jointRestTransforms", MEMORY[0x270FA5388](v5));
  int8x16_t v48 = &v44 - 8 * v7;
  if ([v8 getFloat4x4Array:v48 maxCount:v7] < (unint64_t)v6)
  {
    unint64_t v9 = (_OWORD *)MEMORY[0x263EF89A8];
    id v10 = v48;
    do
    {
      long long v11 = v9[1];
      *(_OWORD *)id v10 = *v9;
      *((_OWORD *)v10 + 1) = v11;
      long long v12 = v9[3];
      *((_OWORD *)v10 + 2) = v9[2];
      *((_OWORD *)v10 + 3) = v12;
      v10 += 8;
      --v7;
    }
    while (v7);
  }
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  int64x2_t v45 = a2;
  id v49 = (id)[a2 jointPaths];
  uint64_t v13 = [v49 countByEnumeratingWithState:&v59 objects:v66 count:16];
  if (v13)
  {
    uint64_t v14 = v13;
    int v15 = 0;
    uint64_t v16 = *(void *)v60;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v60 != v16) {
          objc_enumerationMutation(v49);
        }
        float v18 = *(void **)(*((void *)&v59 + 1) + 8 * i);
        uint64_t v19 = [v18 rangeOfString:@"/" options:4];
        uint64_t v20 = (uint64_t)v18;
        if (v19 != 0x7FFFFFFFFFFFFFFFLL) {
          uint64_t v20 = [v18 substringFromIndex:v19 + 1];
        }
        if (v20)
        {
          id v21 = objc_opt_new();
          [v21 setName:v20];
          if (v21)
          {
            [v4 setObject:v21 forKeyedSubscript:v18];
            uint64_t v22 = &v48[8 * (unint64_t)(v15 + i)];
            long long v23 = *((_OWORD *)v22 + 1);
            long long v24 = *((_OWORD *)v22 + 2);
            long long v25 = *((_OWORD *)v22 + 3);
            v58[0] = *(_OWORD *)v22;
            v58[1] = v23;
            v58[2] = v24;
            v58[3] = v25;
            [v21 setTransform:v58];
          }
        }
      }
      uint64_t v14 = [v49 countByEnumeratingWithState:&v59 objects:v66 count:16];
      v15 += i;
    }
    while (v14);
  }
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  int8x16_t v26 = (void *)[v45 jointPaths];
  uint64_t v27 = [v26 countByEnumeratingWithState:&v54 objects:v65 count:16];
  if (v27)
  {
    uint64_t v28 = v27;
    uint64_t v29 = *(void *)v55;
    do
    {
      uint64_t v30 = 0;
      do
      {
        if (*(void *)v55 != v29) {
          objc_enumerationMutation(v26);
        }
        double v31 = *(void **)(*((void *)&v54 + 1) + 8 * v30);
        uint64_t v32 = [v31 rangeOfString:@"/" options:4];
        if (v32) {
          BOOL v33 = v32 == 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          BOOL v33 = 1;
        }
        if (!v33)
        {
          uint64_t v34 = [v31 substringToIndex:v32];
          if (v34)
          {
            uint64_t v35 = v34;
            if ([v4 valueForKey:v34]) {
              objc_msgSend((id)objc_msgSend(v4, "objectForKeyedSubscript:", v35), "addChildNode:", objc_msgSend(v4, "objectForKeyedSubscript:", v31));
            }
          }
        }
        ++v30;
      }
      while (v28 != v30);
      uint64_t v36 = [v26 countByEnumeratingWithState:&v54 objects:v65 count:16];
      uint64_t v28 = v36;
    }
    while (v36);
  }
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t v37 = [v4 countByEnumeratingWithState:&v50 objects:v64 count:16];
  double v38 = v47;
  if (v37)
  {
    uint64_t v39 = v37;
    uint64_t v40 = *(void *)v51;
    do
    {
      for (uint64_t j = 0; j != v39; ++j)
      {
        if (*(void *)v51 != v40) {
          objc_enumerationMutation(v4);
        }
        id v42 = (void *)[v4 objectForKeyedSubscript:*(void *)(*((void *)&v50 + 1) + 8 * j)];
        if (![v42 parentNode]) {
          [v38 addChildNode:v42];
        }
      }
      uint64_t v39 = [v4 countByEnumeratingWithState:&v50 objects:v64 count:16];
    }
    while (v39);
  }
  *id result = (uint64_t *)v4;
  result[1] = (uint64_t *)v38;
  return result;
}

SCNGeometrySource *anonymous namespace'::boneWeightsFromMDL(_anonymous_namespace_ *this, MDLMesh *a2)
{
  uint64_t v3 = [(_anonymous_namespace_ *)this vertexCount];
  uint64_t v4 = (void *)[(_anonymous_namespace_ *)this vertexAttributeDataForAttributeNamed:*MEMORY[0x263F135A8]];
  uint64_t v5 = [v4 dataStart];
  uint64_t v6 = [v4 format] & 0xFFF;
  return +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", [MEMORY[0x263EFF8F8] dataWithBytes:v5 length:4 * v6 * v3], @"kGeometrySourceSemanticBoneWeights", v3, 1, v6, 4, 0, 4 * v6);
}

SCNGeometrySource *anonymous namespace'::boneIndicesFromMDL(_anonymous_namespace_ *this, MDLMesh *a2)
{
  uint64_t v3 = [(_anonymous_namespace_ *)this vertexCount];
  uint64_t v4 = (void *)[(_anonymous_namespace_ *)this vertexAttributeDataForAttributeNamed:*MEMORY[0x263F135A0]];
  uint64_t v5 = [v4 dataStart];
  uint64_t v6 = [v4 format] & 0xFFF;
  return +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", [MEMORY[0x263EFF8F8] dataWithBytes:v5 length:2 * v6 * v3], @"kGeometrySourceSemanticBoneIndices", v3, 0, v6, 2, 0, 2 * v6);
}

void sub_20B2D6268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(&STACK[0x690], 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void sub_20B2D665C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, char a14, void *a15)
{
}

SCNGeometryElement *_indexedGeometryElement(MDLSubmesh *a1)
{
  if (![(MDLSubmesh *)a1 faceIndexing]
    || [(MDLSubmesh *)a1 geometryType] != MDLGeometryTypeVariableTopology
    || ![(MDLSubmeshTopology *)[(MDLSubmesh *)a1 topology] faceTopology]
    || !objc_msgSend(-[MDLSubmesh indexBuffer](a1, "indexBuffer"), "length"))
  {
    return 0;
  }
  unint64_t v2 = (unint64_t)[(MDLSubmesh *)a1 indexType] >> 3;
  switch(v2)
  {
    case 4uLL:
      return _createIndexedGeometryElement<unsigned int>(a1);
    case 2uLL:
      return _createIndexedGeometryElement<unsigned short>(a1);
    case 1uLL:
      return _createIndexedGeometryElement<unsigned char>(a1);
    default:
      return 0;
  }
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned char>(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  uint64_t v7 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  std::string __p = 0;
  id v42 = 0;
  float32x4_t v43 = 0;
  std::vector<unsigned char>::reserve((unint64_t *)&__p, v7 + v6);
  uint64_t v39 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    unint64_t v9 = v42;
    do
    {
      char v10 = *(unsigned char *)(v3 + v8);
      if (v9 >= v43)
      {
        unint64_t v12 = (unint64_t)__p;
        int64_t v13 = v9 - (unsigned char *)__p;
        uint64_t v14 = v9 - (unsigned char *)__p + 1;
        if (v14 < 0) {
          abort();
        }
        unint64_t v15 = v43 - (unsigned char *)__p;
        if (2 * (v43 - (unsigned char *)__p) > (unint64_t)v14) {
          uint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v16 = v14;
        }
        if (v16) {
          double v17 = (char *)operator new(v16);
        }
        else {
          double v17 = 0;
        }
        float v18 = &v17[v13];
        uint64_t v19 = &v17[v13];
        *uint64_t v19 = v10;
        long long v11 = v19 + 1;
        if (v9 != (char *)v12)
        {
          uint64_t v20 = &v9[~v12];
          do
          {
            char v21 = *--v9;
            (v20--)[(void)v17] = v21;
          }
          while (v9 != (char *)v12);
          unint64_t v9 = (char *)__p;
          float v18 = v17;
        }
        std::string __p = v18;
        id v42 = v11;
        float32x4_t v43 = &v17[v16];
        if (v9) {
          operator delete(v9);
        }
        uint64_t v6 = v39;
      }
      else
      {
        *unint64_t v9 = v10;
        long long v11 = v9 + 1;
      }
      id v42 = v11;
      ++v8;
      unint64_t v9 = v11;
    }
    while (v8 != v6);
  }
  if (v7)
  {
    uint64_t v22 = 0;
    long long v23 = v42;
    do
    {
      if (v23 >= v43)
      {
        unint64_t v25 = (unint64_t)__p;
        int64_t v26 = v23 - (unsigned char *)__p;
        uint64_t v27 = v23 - (unsigned char *)__p + 1;
        if (v27 < 0) {
          abort();
        }
        unint64_t v28 = v43 - (unsigned char *)__p;
        if (2 * (v43 - (unsigned char *)__p) > (unint64_t)v27) {
          uint64_t v27 = 2 * v28;
        }
        if (v28 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v29 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v29 = v27;
        }
        if (v29) {
          uint64_t v30 = (char *)operator new(v29);
        }
        else {
          uint64_t v30 = 0;
        }
        double v31 = &v30[v26];
        v30[v26] = *(unsigned char *)(v5 + v22);
        uint64_t v24 = (uint64_t)&v30[v26 + 1];
        if (v23 != (char *)v25)
        {
          uint64_t v32 = &v23[~v25];
          do
          {
            char v33 = *--v23;
            (v32--)[(void)v30] = v33;
          }
          while (v23 != (char *)v25);
          long long v23 = (char *)__p;
          double v31 = v30;
        }
        std::string __p = v31;
        id v42 = &v30[v26 + 1];
        float32x4_t v43 = &v30[v29];
        if (v23) {
          operator delete(v23);
        }
      }
      else
      {
        *long long v23 = *(unsigned char *)(v5 + v22);
        uint64_t v24 = (uint64_t)(v23 + 1);
      }
      id v42 = (char *)v24;
      ++v22;
      long long v23 = (char *)v24;
    }
    while (v22 != v7);
  }
  else
  {
    uint64_t v24 = (uint64_t)v42;
  }
  uint64_t v35 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", __p, v24 - (void)__p, v39);
  unint64_t v36 = 0;
  for (unint64_t i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v36 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))unint64_t v36 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"); {
  }
    }
  uint64_t v34 = +[SCNGeometryElement geometryElementWithData:v35 primitiveType:4 primitiveCount:v40 indicesChannelCount:v36 + 1 interleavedIndicesChannels:1 bytesPerIndex:1];
  if (__p)
  {
    id v42 = (char *)__p;
    operator delete(__p);
  }
  return v34;
}

void sub_20B2D6F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned short>(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  std::string __p = 0;
  double v38 = 0;
  uint64_t v39 = 0;
  unint64_t v36 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  std::vector<unsigned short>::reserve(&__p, v6 + (v36 >> 1));
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v38;
    do
    {
      __int16 v9 = *(unsigned __int8 *)(v3 + v7);
      if (v8 >= v39)
      {
        long long v11 = (char *)__p;
        uint64_t v12 = v8 - (unsigned char *)__p;
        if (v8 - (unsigned char *)__p <= -3) {
          abort();
        }
        uint64_t v13 = v12 >> 1;
        if (v39 - (unsigned char *)__p <= (unint64_t)((v12 >> 1) + 1)) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v39 - (unsigned char *)__p;
        }
        if ((unint64_t)(v39 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          size_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)&v39, v15);
          long long v11 = (char *)__p;
          uint64_t v8 = v38;
        }
        else
        {
          size_t v16 = 0;
        }
        double v17 = &v16[2 * v13];
        *(_WORD *)double v17 = v9;
        char v10 = v17 + 2;
        while (v8 != v11)
        {
          __int16 v18 = *((_WORD *)v8 - 1);
          v8 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        std::string __p = v17;
        double v38 = v10;
        uint64_t v39 = &v16[2 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_WORD *)uint64_t v8 = v9;
        char v10 = v8 + 2;
      }
      double v38 = v10;
      ++v7;
      uint64_t v8 = v10;
    }
    while (v7 != v6);
  }
  if (v36 > 1)
  {
    uint64_t v21 = 0;
    if (v36 >> 1 <= 1) {
      uint64_t v22 = 1;
    }
    else {
      uint64_t v22 = v36 >> 1;
    }
    long long v23 = v38;
    do
    {
      if (v23 >= v39)
      {
        uint64_t v24 = (char *)__p;
        uint64_t v25 = v23 - (unsigned char *)__p;
        if (v23 - (unsigned char *)__p <= -3) {
          abort();
        }
        uint64_t v26 = v25 >> 1;
        if (v39 - (unsigned char *)__p <= (unint64_t)((v25 >> 1) + 1)) {
          uint64_t v27 = v26 + 1;
        }
        else {
          uint64_t v27 = v39 - (unsigned char *)__p;
        }
        if ((unint64_t)(v39 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v28 = v27;
        }
        if (v28)
        {
          size_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)&v39, v28);
          uint64_t v24 = (char *)__p;
          long long v23 = v38;
        }
        else
        {
          size_t v29 = 0;
        }
        uint64_t v30 = &v29[2 * v26];
        *(_WORD *)uint64_t v30 = *(_WORD *)(v5 + 2 * v21);
        uint64_t v19 = v30 + 2;
        while (v23 != v24)
        {
          __int16 v31 = *((_WORD *)v23 - 1);
          v23 -= 2;
          *((_WORD *)v30 - 1) = v31;
          v30 -= 2;
        }
        std::string __p = v30;
        double v38 = v19;
        uint64_t v39 = &v29[2 * v28];
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        *(_WORD *)long long v23 = *(_WORD *)(v5 + 2 * v21);
        uint64_t v19 = v23 + 2;
      }
      double v38 = v19;
      ++v21;
      long long v23 = v19;
    }
    while (v21 != v22);
  }
  else
  {
    uint64_t v19 = v38;
  }
  uint64_t v32 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", __p, v19 - (unsigned char *)__p, v36);
  unint64_t v33 = 0;
  for (unint64_t i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v33 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))unint64_t v33 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"); {
  }
    }
  uint64_t v20 = +[SCNGeometryElement geometryElementWithData:v32 primitiveType:4 primitiveCount:v6 indicesChannelCount:v33 + 1 interleavedIndicesChannels:1 bytesPerIndex:2];
  if (__p)
  {
    double v38 = (char *)__p;
    operator delete(__p);
  }
  return v20;
}

void sub_20B2D7290(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned int>(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  memset(&v37, 0, sizeof(v37));
  unint64_t v36 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  std::vector<unsigned int>::reserve(&v37, v6 + (v36 >> 2));
  if (v6)
  {
    uint64_t v7 = 0;
    std::vector<int>::pointer end = v37.__end_;
    do
    {
      int v9 = *(unsigned __int8 *)(v3 + v7);
      if (end >= v37.__end_cap_.__value_)
      {
        begiuint64_t n = v37.__begin_;
        uint64_t v12 = end - v37.__begin_;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62) {
          abort();
        }
        int64_t v14 = (char *)v37.__end_cap_.__value_ - (char *)v37.__begin_;
        if (((char *)v37.__end_cap_.__value_ - (char *)v37.__begin_) >> 1 > v13) {
          unint64_t v13 = v14 >> 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          size_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v37.__end_cap_, v15);
          begiuint64_t n = v37.__begin_;
          std::vector<int>::pointer end = v37.__end_;
        }
        else
        {
          size_t v16 = 0;
        }
        double v17 = (int *)&v16[4 * v12];
        int *v17 = v9;
        char v10 = v17 + 1;
        while (end != begin)
        {
          int v18 = *--end;
          *--double v17 = v18;
        }
        v37.__begin_ = v17;
        v37.__end_ = v10;
        v37.__end_cap_.__value_ = (int *)&v16[4 * v15];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *std::vector<int>::pointer end = v9;
        char v10 = end + 1;
      }
      v37.__end_ = v10;
      ++v7;
      std::vector<int>::pointer end = v10;
    }
    while (v7 != v6);
  }
  if (v36 > 3)
  {
    uint64_t v21 = 0;
    if (v36 >> 2 <= 1) {
      uint64_t v22 = 1;
    }
    else {
      uint64_t v22 = v36 >> 2;
    }
    std::vector<int>::pointer v23 = v37.__end_;
    do
    {
      if (v23 >= v37.__end_cap_.__value_)
      {
        std::vector<int>::pointer v24 = v37.__begin_;
        uint64_t v25 = v23 - v37.__begin_;
        unint64_t v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 62) {
          abort();
        }
        int64_t v27 = (char *)v37.__end_cap_.__value_ - (char *)v37.__begin_;
        if (((char *)v37.__end_cap_.__value_ - (char *)v37.__begin_) >> 1 > v26) {
          unint64_t v26 = v27 >> 1;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          size_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v37.__end_cap_, v28);
          std::vector<int>::pointer v24 = v37.__begin_;
          std::vector<int>::pointer v23 = v37.__end_;
        }
        else
        {
          size_t v29 = 0;
        }
        uint64_t v30 = (int *)&v29[4 * v25];
        *uint64_t v30 = *(_DWORD *)(v5 + 4 * v21);
        uint64_t v19 = v30 + 1;
        while (v23 != v24)
        {
          int v31 = *--v23;
          *--uint64_t v30 = v31;
        }
        v37.__begin_ = v30;
        v37.__end_ = v19;
        v37.__end_cap_.__value_ = (int *)&v29[4 * v28];
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        *std::vector<int>::pointer v23 = *(_DWORD *)(v5 + 4 * v21);
        uint64_t v19 = v23 + 1;
      }
      v37.__end_ = v19;
      ++v21;
      std::vector<int>::pointer v23 = v19;
    }
    while (v21 != v22);
  }
  else
  {
    uint64_t v19 = v37.__end_;
  }
  uint64_t v32 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", v37.__begin_, (char *)v19 - (char *)v37.__begin_, v36);
  unint64_t v33 = 0;
  for (unint64_t i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v33 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))unint64_t v33 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"); {
  }
    }
  uint64_t v20 = +[SCNGeometryElement geometryElementWithData:v32 primitiveType:4 primitiveCount:v6 indicesChannelCount:v33 + 1 interleavedIndicesChannels:1 bytesPerIndex:4];
  if (v37.__begin_)
  {
    v37.__end_ = v37.__begin_;
    operator delete(v37.__begin_);
  }
  return v20;
}

void sub_20B2D75F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!ModelIOLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x263EF8330];
    _OWORD v4[2] = (void *)3221225472;
    v4[3] = ___ZL18ModelIOLibraryCorePPc_block_invoke;
    _OWORD v4[4] = &__block_descriptor_40_e5_v8__0l;
    void v4[5] = v4;
    long long v5 = xmmword_264004B10;
    uint64_t v6 = 0;
    ModelIOLibraryCore(char **)::frameworkuint64_t Library = _sl_dlopen();
  }
  uint64_t v2 = (void *)ModelIOLibraryCore(char **)::frameworkLibrary;
  if (!ModelIOLibraryCore(char **)::frameworkLibrary) {
    ___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke_cold_1(v4);
  }
  if (v4[0]) {
    free(v4[0]);
  }
  id result = dlsym(v2, "MDLAssetLoadingOptionDefaultUSDColorSpace");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24);
  return result;
}

uint64_t ___ZL18ModelIOLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  ModelIOLibraryCore(char **)::frameworkuint64_t Library = result;
  return result;
}

void *anonymous namespace'::_normalizedKeyTimes(void *a1, double a2, double a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v6 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(a1, "count"));
  unint64_t v7 = [a1 count];
  if (a3 != 0.0 && v7 > 1)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    uint64_t v9 = [a1 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)v16;
      do
      {
        uint64_t v12 = 0;
        do
        {
          if (*(void *)v16 != v11) {
            objc_enumerationMutation(a1);
          }
          [*(id *)(*((void *)&v15 + 1) + 8 * v12) doubleValue];
          objc_msgSend(v6, "addObject:", objc_msgSend(NSNumber, "numberWithDouble:", (v13 - a2) / a3));
          ++v12;
        }
        while (v10 != v12);
        uint64_t v10 = [a1 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }
      while (v10);
    }
  }
  else
  {
    objc_msgSend(v6, "addObject:", objc_msgSend(NSNumber, "numberWithDouble:", 0.0));
  }
  return v6;
}

void *anonymous namespace'::_valuesWithMDLAnimatedVector3Array(uint64_t a1, int a2, int a3, int a4)
{
  int v6 = a2;
  uint64_t v8 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:a2];
  if (v6 >= 1)
  {
    uint64_t v12 = (_DWORD *)(a1 + 16 * a4 + 8);
    uint64_t v13 = 16 * a3;
    do
    {
      LODWORD(v9) = *(v12 - 2);
      LODWORD(v10) = *(v12 - 1);
      LODWORD(v11) = *v12;
      objc_msgSend(v8, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNVector3:", v9, v10, v11));
      uint64_t v12 = (_DWORD *)((char *)v12 + v13);
      --v6;
    }
    while (v6);
  }
  return v8;
}

uint64_t anonymous namespace'::_getBoundSkeleton(_anonymous_namespace_ *this, MDLObject *a2)
{
  uint64_t v2 = [(_anonymous_namespace_ *)this componentConformingToProtocol:&unk_26BFFFD70];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void *)v2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return [v3 skeleton];
}

uint64_t anonymous namespace'::_findMeshes(void *a1, float32x4_t *a2, void *a3, void **a4)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if ([a1 transform])
  {
    float32x4_t v43 = *a2;
    float32x4_t v44 = a2[1];
    float32x4_t v41 = a2[3];
    float32x4_t v42 = a2[2];
    objc_msgSend((id)objc_msgSend(a1, "transform"), "matrix");
    uint64_t v8 = 0;
    v49[0] = v9;
    v49[1] = v10;
    v49[2] = v11;
    v49[3] = v12;
    do
    {
      *(float32x4_t *)((char *)&v50 + v8 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v43, COERCE_FLOAT(v49[v8])), v44, *(float32x2_t *)&v49[v8], 1), v42, (float32x4_t)v49[v8], 2), v41, (float32x4_t)v49[v8], 3);
      ++v8;
    }
    while (v8 != 4);
  }
  else
  {
    float32x4_t v13 = a2[1];
    float32x4_t v50 = *a2;
    float32x4_t v51 = v13;
    float32x4_t v14 = a2[3];
    float32x4_t v52 = a2[2];
    float32x4_t v53 = v14;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [a3 addObject:a1];
    unint64_t v15 = (unint64_t)a4[2];
    long long v16 = (float32x4_t *)a4[1];
    if ((unint64_t)v16 >= v15)
    {
      uint64_t v20 = ((char *)v16 - (unsigned char *)*a4) >> 6;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 58) {
        abort();
      }
      uint64_t v22 = v15 - (void)*a4;
      if (v22 >> 5 > v21) {
        unint64_t v21 = v22 >> 5;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v23 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23) {
        std::vector<int>::pointer v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_float4x4>>((uint64_t)(a4 + 2), v23);
      }
      else {
        std::vector<int>::pointer v24 = 0;
      }
      uint64_t v25 = (float32x4_t *)&v24[64 * v20];
      unint64_t v26 = &v24[64 * v23];
      float32x4_t v27 = v51;
      float32x4_t *v25 = v50;
      v25[1] = v27;
      float32x4_t v28 = v53;
      v25[2] = v52;
      void v25[3] = v28;
      f32 = (_OWORD *)v25[4].f32;
      uint64_t v30 = (char *)*a4;
      size_t v29 = (float32x4_t *)a4[1];
      if (v29 != *a4)
      {
        do
        {
          float32x4_t v31 = v29[-4];
          float32x4_t v32 = v29[-3];
          float32x4_t v33 = v29[-1];
          v25[-2] = v29[-2];
          v25[-1] = v33;
          v25[-4] = v31;
          v25[-3] = v32;
          v25 -= 4;
          v29 -= 4;
        }
        while (v29 != (float32x4_t *)v30);
        size_t v29 = (float32x4_t *)*a4;
      }
      *a4 = v25;
      a4[1] = f32;
      a4[2] = v26;
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      float32x4_t v17 = v51;
      *long long v16 = v50;
      v16[1] = v17;
      float32x4_t v18 = v53;
      v16[2] = v52;
      v16[3] = v18;
      f32 = (_OWORD *)v16[4].f32;
    }
    a4[1] = f32;
  }
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  uint64_t v34 = (void *)[a1 children];
  uint64_t result = [v34 countByEnumeratingWithState:&v45 objects:v54 count:16];
  uint64_t v37 = result;
  if (result)
  {
    uint64_t v38 = *(void *)v46;
    do
    {
      uint64_t v39 = 0;
      do
      {
        if (*(void *)v46 != v38) {
          objc_enumerationMutation(v34);
        }
        uint64_t v40 = *(_anonymous_namespace_ **)(*((void *)&v45 + 1) + 8 * v39);
        ++v39;
      }
      while (v37 != v39);
      uint64_t result = [v34 countByEnumeratingWithState:&v45 objects:v54 count:16];
      uint64_t v37 = result;
    }
    while (result);
  }
  return result;
}

uint64_t **std::map<MDLSkeleton *,anonymous namespace'::SkelNodes>::operator[](uint64_t **a1, uint64_t **a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v3 = a1[1];
  long long v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        int v6 = (uint64_t **)v3;
        unint64_t v7 = v3[4];
        if ((unint64_t)v5 >= v7) {
          break;
        }
        uint64_t v3 = *v6;
        uint64_t v4 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= (unint64_t)v5) {
        break;
      }
      uint64_t v3 = v6[1];
      if (!v3)
      {
        uint64_t v4 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v6 = a1 + 1;
LABEL_9:
    uint64_t v8 = (uint64_t *)v6;
    int v6 = (uint64_t **)operator new(0x38uLL);
    void v6[5] = 0;
    v6[6] = 0;
    v6[4] = v5;
    *int v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *uint64_t v4 = (uint64_t *)v6;
    long long v9 = (uint64_t *)**a1;
    long long v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      long long v10 = *v4;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6 + 5;
}

void *anonymous namespace'::boneInverseTransformsFromMDL(_anonymous_namespace_ *this, MDLAnimationBindComponent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float64x2_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,long long a24,long long a25,long long a26,long long a27,long long a28,long long a29,long long a30,long long a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  a35 = *MEMORY[0x263EF8340];
  unint64_t v36 = (void *)[(_anonymous_namespace_ *)this skeleton];
  uint64_t v37 = objc_msgSend((id)objc_msgSend(v36, "jointBindTransforms"), "elementCount");
  uint64_t v38 = [(_anonymous_namespace_ *)this jointPaths];
  uint64_t v39 = v38;
  if (v38)
  {
    uint64_t v38 = objc_opt_new();
    uint64_t v40 = (void *)v38;
    if (v37)
    {
      for (uint64_t i = 0; i != v37; ++i)
        uint64_t v38 = objc_msgSend(v40, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", i), objc_msgSend((id)objc_msgSend(v36, "jointPaths"), "objectAtIndexedSubscript:", i));
    }
  }
  else
  {
    uint64_t v40 = 0;
  }
  unint64_t v42 = (unint64_t)(var30 - 8 * v37 + 1) & 0xFFFFFFFFFFFFFFE0;
  objc_msgSend((id)objc_msgSend(v36, "jointBindTransforms", MEMORY[0x270FA5388](v38)), "getDouble4x4Array:maxCount:", v42, v37);
  if (v39) {
    uint64_t v37 = objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "count");
  }
  float32x4_t v43 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:v37];
  if (v37)
  {
    for (uint64_t j = 0; j != v37; ++j)
    {
      uint64_t v45 = j;
      if (v39) {
        uint64_t v45 = objc_msgSend((id)objc_msgSend(v40, "objectForKeyedSubscript:", objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "objectAtIndexedSubscript:", j)), "unsignedLongValue");
      }
      long long v46 = (long long *)(v42 + (v45 << 7));
      long long v47 = v46[5];
      a28 = v46[4];
      a29 = v47;
      long long v48 = v46[7];
      a30 = v46[6];
      a31 = v48;
      long long v49 = v46[1];
      a24 = *v46;
      a25 = v49;
      long long v50 = v46[3];
      a26 = v46[2];
      a27 = v50;
      __invert_d4();
      float32x4_t v51 = (void *)MEMORY[0x263F08D40];
      var30[0] = v53;
      var30[1] = v54;
      var30[2] = v55;
      var30[3] = v56;
      objc_msgSend(v43, "addObject:", objc_msgSend(v51, "valueWithSCNMatrix4:", var30));
    }
  }
  if (v40) {

  }
  return v43;
}

double anonymous namespace'::_convertDouble2Float(float64x2_t *this, const simd_double4x4 *a2)
{
  *(void *)&double result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*this), this[1]).u64[0];
  return result;
}

void *anonymous namespace'::_getRootNodeName(_anonymous_namespace_ *this, MDLPackedJointAnimation *a2)
{
  if (!objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "count")) {
    return 0;
  }
  uint64_t v3 = objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "objectAtIndexedSubscript:", 0);
  uint64_t v4 = v3;
  if (!v3) {
    return v4;
  }
  if (![v3 length]) {
    return 0;
  }
  if (objc_msgSend((id)objc_msgSend(v4, "substringToIndex:", 1), "isEqualToString:", @"/")) {
    uint64_t v4 = (void *)[v4 substringFromIndex:1];
  }
  uint64_t v5 = [v4 rangeOfString:@"/"];
  if (v5 == 0x7FFFFFFFFFFFFFFFLL) {
    return v4;
  }

  return (void *)[v4 substringToIndex:v5];
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<simd_float4x4>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(a2 << 6);
}

void std::__tree<std::__value_type<MDLSkeleton *,anonymous namespace'::SkelNodes>,std::__map_value_compare<MDLSkeleton *,std::__value_type<MDLSkeleton *,anonymous namespace'::SkelNodes>,std::less<MDLSkeleton *>,true>,std::allocator<std::__value_type<MDLSkeleton *,anonymous namespace'::SkelNodes>>>::destroy(void *a1)
{
  if (a1)
  {
    operator delete(a1);
  }
}

double convertUVTranformForModelIO(const simd_float4x4 *a1)
{
  uint64_t v1 = 0;
  float32x4_t v2 = *(float32x4_t *)MEMORY[0x263EF89A8];
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v4 = (float32x4_t)a1->columns[1];
  int8x16_t v5 = (int8x16_t)vmulq_f32((float32x4_t)a1->columns[0], (float32x4_t)a1->columns[0]);
  *(float32x2_t *)v5.i8 = vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
  int8x16_t v6 = (int8x16_t)vmulq_f32(v4, v4);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x2_t v7 = (int32x2_t)vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8)));
  float32x4_t v8 = (float32x4_t)a1->columns[2];
  simd_float4 v9 = a1->columns[3];
  float32x4_t v10 = vmulq_f32(v8, v8);
  float32x2_t v11 = (float32x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL).u64[0];
  v11.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v10.f32, v11)));
  *(int32x2_t *)v10.f32 = v7;
  v10.i64[1] = __PAIR64__(1.0, v11.u32[0]);
  __asm { FMOV            V5.4S, #1.0 }
  float32x4_t v17 = vdivq_f32(_Q5, v10);
  v18.i64[0] = 0;
  v18.i64[1] = v17.u32[2];
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  int32x4_t v20 = *(int32x4_t *)(MEMORY[0x263EF89A8] + 48);
  float32x4_t v21 = vdivq_f32((float32x4_t)a1->columns[0], (float32x4_t)vdupq_lane_s32(v7, 0));
  int32x4_t v22 = (int32x4_t)vdivq_f32(v4, (float32x4_t)vdupq_lane_s32(v7, 1));
  int32x4_t v23 = (int32x4_t)vdivq_f32(v8, (float32x4_t)vdupq_lane_s32((int32x2_t)v11, 0));
  int32x4_t v24 = vzip1q_s32((int32x4_t)v21, v23);
  int32x4_t v25 = vzip2q_s32((int32x4_t)v21, v23);
  int32x4_t v26 = vzip1q_s32(v22, v20);
  int32x4_t v27 = vzip2q_s32(v22, v20);
  float32x4_t v28 = (float32x4_t)vzip1q_s32(v24, v26);
  float32x4_t v29 = (float32x4_t)vzip1q_s32(v25, v27);
  float32x4_t v41 = v8;
  simd_float4 v42 = v9;
  do
  {
    *(long long *)((char *)&v43 + v1) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(long long *)((char *)&v39 + v1))), v3, *(float32x2_t *)((char *)&v39 + v1), 1), v19, *(float32x4_t *)((char *)&v39 + v1), 2), (float32x4_t)xmmword_20B5CB6F0, *(float32x4_t *)((char *)&v39 + v1), 3);
    v1 += 16;
  }
  while (v1 != 64);
  uint64_t v30 = 0;
  v32.i64[0] = 0;
  v32.i32[2] = 0;
  v31.i32[0] = 0;
  v31.i64[1] = 0;
  v31.i32[1] = v17.i32[1];
  v32.i32[3] = v17.i32[3];
  float32x4_t v33 = (float32x4_t)vzip2q_s32(v24, v26);
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  simd_float4 v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v30) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v17.u32[0], COERCE_FLOAT(*(long long *)((char *)&v39 + v30))), v31, *(float32x2_t *)((char *)&v39 + v30), 1), v18, *(float32x4_t *)((char *)&v39 + v30), 2), v32, *(float32x4_t *)((char *)&v39 + v30), 3);
    v30 += 16;
  }
  while (v30 != 64);
  uint64_t v34 = 0;
  float32x4_t v35 = (float32x4_t)vzip2q_s32(v25, v27);
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  simd_float4 v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v34) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v28, COERCE_FLOAT(*(long long *)((char *)&v39 + v34))), v33, *(float32x2_t *)((char *)&v39 + v34), 1), v29, *(float32x4_t *)((char *)&v39 + v34), 2), v35, *(float32x4_t *)((char *)&v39 + v34), 3);
    v34 += 16;
  }
  while (v34 != 64);
  uint64_t v36 = 0;
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  simd_float4 v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v36) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(long long *)((char *)&v39 + v36))), v3, *(float32x2_t *)((char *)&v39 + v36), 1), v19, *(float32x4_t *)((char *)&v39 + v36), 2), (float32x4_t)xmmword_20B5CB700, *(float32x4_t *)((char *)&v39 + v36), 3);
    v36 += 16;
  }
  while (v36 != 64);
  float32x4_t v37 = vmulq_n_f32(v21, *(float *)v7.i32);
  v37.i32[1] = vnegq_f32(v37).i32[1];
  return *(double *)v37.i64;
}

uint64_t **std::__tree<std::__value_type<unsigned long long,float>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,float>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,float>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  int32x2_t v7 = a1 + 1;
  int8x16_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        simd_float4 v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int8x16_t v6 = *v9;
        int32x2_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int8x16_t v6 = v9[1];
      if (!v6)
      {
        int32x2_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    simd_float4 v9 = a1 + 1;
LABEL_10:
    float32x2_t v11 = operator new(0x30uLL);
    uint8_t v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<unsigned int,float>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,float>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, unsigned int **a4)
{
  int32x2_t v7 = a1 + 1;
  int8x16_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        simd_float4 v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        int8x16_t v6 = *v9;
        int32x2_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int8x16_t v6 = v9[1];
      if (!v6)
      {
        int32x2_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    simd_float4 v9 = a1 + 1;
LABEL_10:
    float32x2_t v11 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v11 + 2_Block_object_dispose(&STACK[0x690], 8) = **a4;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

char *std::vector<float>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  int8x16_t v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    int32x2_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    long long v12 = &v7[v11];
    float32x4_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      float32x4_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int8x16_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int8x16_t v5 = v6;
  int32x2_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      float32x4_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v4, v13);
      unint64_t v8 = *a1;
      int32x2_t v7 = a1[1];
    }
    else
    {
      float32x4_t v14 = 0;
    }
    char v15 = &v14[4 * v11];
    long long v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    float32x4_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      abort();
    }
    int8x16_t v5 = (char *)a1[1];
    unint64_t v6 = operator new(__sz);
    int32x2_t v7 = &v5[(void)v6 - v2];
    unint64_t v8 = v7;
    if (v5 != (char *)v2)
    {
      uint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }
      while (v5 != (char *)v2);
      unint64_t v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
    {
      operator delete((void *)v2);
    }
  }
}

void std::vector<unsigned short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3, a2);
    int32x2_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    uint64_t v9 = &v6[2 * v8];
    char v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        __int16 v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(2 * a2);
}

void std::vector<unsigned int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  uint64_t value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      abort();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    int32x2_t v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v9 = (int *)&v6[4 * v8];
    begiuint64_t n = this->__begin_;
    std::vector<int>::pointer end = this->__end_;
    uint64_t v12 = v7;
    if (end != this->__begin_)
    {
      uint64_t v12 = v7;
      do
      {
        int v13 = *--end;
        *--uint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void OUTLINED_FUNCTION_0_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

C3D::RenderPass *C3D::SSAORaytracePass::SSAORaytracePass(C3D::RenderPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  double result = C3D::RenderPass::RenderPass(a1, a2, a3);
  *(void *)double result = &unk_26BF6D890;
  *((void *)result + 31) = a4;
  return result;
}

const char *C3D::SSAORaytracePass::name(C3D::SSAORaytracePass *this)
{
  return "SSAORaytracePass";
}

float32x4_t C3D::SSAORaytracePass::setup(C3D::SSAORaytracePass *this)
{
  C3D::Pass::setInputCount(this, 2u);
  C3D::Pass::setOutputCount(this, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x690], 8) = "SSAO-DepthNormal";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 1u) + _Block_object_dispose(&STACK[0x690], 8) = "SSAO-MinMaxOffset";
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 0);
  *(unsigned char *)(v2 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v10);
  *(_OWORD *)(v2 + 16) = v10;
  *(_DWORD *)(v2 + 32) = v11;
  *(_WORD *)(v2 + 2_Block_object_dispose(&STACK[0x690], 8) = 115;
  uint64_t v3 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 31));
  *(_WORD *)(v2 + 16) = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v3, 0) + 16)
                      / *(_DWORD *)(*((void *)this + 31) + 12);
  uint64_t v4 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 31));
  *(_WORD *)(v2 + 1_Block_object_dispose(&STACK[0x690], 8) = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v4, 0) + 18)
                      / *(_DWORD *)(*((void *)this + 31) + 12);
  *(_WORD *)(v2 + 66) &= 0xFFFCu;
  if (*(unsigned char *)(v2 + 24) == 5)
  {
    *((_WORD *)this + 19) = 6;
  }
  else if (C3DEngineContextGetEyeCount(*((void *)this + 2)) >= 2)
  {
    EyeCFIndex Count = C3DEngineContextGetEyeCount(*((void *)this + 2));
    *((_WORD *)this + 19) = EyeCount;
    *((unsigned char *)this + 121) = 1;
    if (EyeCount)
    {
      unint64_t v7 = 0;
      do
      {
        ViewportAtuint64_t Index = C3DEngineContextGetViewportAtIndex(*((void *)this + 2), v7);
        *(float *)v9.i32 = (float)*(unsigned int *)(*((void *)this + 31) + 12);
        float32x4_t result = vdivq_f32((float32x4_t)ViewportAtIndex, (float32x4_t)vdupq_lane_s32(v9, 0));
        *((float32x4_t *)this + v7++ + _Block_object_dispose(&STACK[0x690], 8) = result;
      }
      while (v7 < *((unsigned __int16 *)this + 19));
    }
  }
  return result;
}

uint64_t C3D::SSAORaytracePass::compile(C3D::SSAORaytracePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = *(unsigned __int8 *)(*((void *)this + 31) + 16) | (2 * *(unsigned __int8 *)(*((void *)this + 31) + 17)) | (4 * *(_DWORD *)(*((void *)this + 31) + 12)) | (*(_DWORD *)(*((void *)this + 31) + 8) << 6);
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::SSAORaytracePass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) >> 47));
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

void C3D::SSAORaytracePass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  PointOfView = C3DEngineContextGetPointOfView(a1[2]);
  if (PointOfView)
  {
    CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)PointOfView);
    if (Camera)
    {
      uint64_t v7 = (uint64_t)Camera;
      ViewportAtuint64_t Index = C3DEngineContextGetViewportAtIndex(a1[2], *(unsigned __int16 *)(a2 + 16));
      float32x4_t v25 = vmulq_n_f32((float32x4_t)ViewportAtIndex, C3DEngineContextGetSuperSamplingFactor(a1[2]));
      float v8 = fmax(C3DCameraGetScreenSpaceAmbientOcclusionRadius(v7) * 1000.0, 0.001);
      float v28 = v8;
      float v29 = v8 * v8;
      double v9 = fmax(C3DCameraGetScreenSpaceAmbientOcclusionIntensity(v7), 0.0);
      float v10 = v9 / powf(v8, 6.0);
      float v31 = v10;
      float v32 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionDepthThreshold(v7), 0.0);
      float v33 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionNormalThreshold(v7), 0.0);
      float v30 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionBias(v7), 0.0);
      int v27 = 1140457472;
      uint64_t v11 = a1[31];
      *(float *)v12.i32 = (float)*(unsigned int *)(v11 + 12);
      float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v12, 0);
      float32x2_t v23 = (float32x2_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL).u64[0];
      *(float32x2_t *)v14.f32 = vdiv_f32(v23, *(float32x2_t *)v13.f32);
      v14.i64[1] = v14.i64[0];
      v13.i64[0] = vdivq_f32(v25, v13).u64[0];
      v13.i64[1] = vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v25, 0), v14).i64[1];
      v26[1] = v13;
      unint64_t v15 = C3D::DrawNodesPass::getCullingContext(*(C3D::DrawNodesPass **)v11)
          + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6);
      LODWORD(v16) = *(_DWORD *)(v15 + 1360);
      *(float32x2_t *)v17.f32 = vdiv_f32((float32x2_t)0xC000000040000000, v23);
      v17.i64[1] = 0x3F800000BF800000;
      HIDWORD(v16) = *(_DWORD *)(v15 + 1380);
      v26[0] = vdivq_f32(v17, (float32x4_t)vdupq_lane_s64(v16, 0));
      uint64_t v18 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 16) state];
      if (*(void *)(v4 + 3376) != v18)
      {
        *(void *)(v4 + 3376) = v18;
        [*(id *)(v4 + 3392) setRenderPipelineState:v18];
      }
      SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v4, v26, 0x40uLL, 0);
      float32x4_t v19 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v19, 0);
      int32x4_t v20 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v20, 1uLL);
      SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v4);
    }
    else if ((C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done & 1) == 0)
    {
      C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done = 1;
      int32x4_t v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        C3D::SSAORaytracePass::execute(v22);
      }
    }
  }
  else if ((C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done & 1) == 0)
  {
    C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done = 1;
    float32x4_t v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      C3D::SSAORaytracePass::execute(v21);
    }
  }
}

void C3D::SSAORaytracePassResource::~SSAORaytracePassResource(C3D::SSAORaytracePassResource *this)
{
  *(void *)this = &unk_26BF6E4D0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E4D0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

uint64_t C3DMeshElementGetEmptyElement()
{
  if (C3DMeshElementGetEmptyElement_onceToken != -1) {
    dispatch_once(&C3DMeshElementGetEmptyElement_onceToken, &__block_literal_global_4_0);
  }
  return emptyMeshElement;
}

uint64_t __C3DMeshElementGetEmptyElement_block_invoke()
{
  uint64_t result = C3DMeshElementCreate();
  emptyMeshuint64_t Element = result;
  return result;
}

CFTypeRef C3DMeshElementInitIndexedWithMTLBuffer(uint64_t a1, char a2, int a3, char a4, char a5, const void *a6, char a7)
{
  C3DMeshElementSetType(a1, a2);
  *(unsigned char *)(a1 + 130) = a4;
  *(unsigned char *)(a1 + 131) = a5;
  *(_DWORD *)(a1 + 104) = a3;
  __SetIndexes(a1, 0, a7);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 12_Block_object_dispose(&STACK[0x690], 8) = 0;
  CFTypeRef result = CFRetain(a6);
  *(void *)(a1 + 136) = result;
  return result;
}

void C3DMeshElementInit(uint64_t a1, char a2, int a3, const void *a4, char a5)
{
}

uint64_t C3DMeshElementCreateCopy(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMeshElementCreate();
  __C3DMeshElementCopy(a1, v10, 0);
  return v10;
}

void __C3DMeshElementCopy(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float32x4_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  *(_WORD *)(a2 + 80) = *(_WORD *)(a1 + 80);
  *(unsigned char *)(a2 + 8_Block_object_dispose(&STACK[0x690], 8) = *(unsigned char *)(a1 + 88);
  CFDataRef v22 = *(const __CFData **)(a1 + 96);
  if (a3 && v22)
  {
    CFDataRef Copy = CFDataCreateCopy(0, v22);
    CFDataRef v24 = *(CFDataRef *)(a2 + 96);
    if (v24 != Copy)
    {
      if (v24)
      {
        CFRelease(v24);
        *(void *)(a2 + 96) = 0;
      }
      if (Copy) {
        CFTypeRef v25 = CFRetain(Copy);
      }
      else {
        CFTypeRef v25 = 0;
      }
      *(void *)(a2 + 96) = v25;
    }
    CFRelease(Copy);
  }
  else
  {
    CFDataRef v26 = *(const __CFData **)(a2 + 96);
    if (v26 != v22)
    {
      if (v26)
      {
        CFRelease(v26);
        *(void *)(a2 + 96) = 0;
        CFDataRef v22 = *(const __CFData **)(a1 + 96);
      }
      if (v22) {
        CFTypeRef v27 = CFRetain(v22);
      }
      else {
        CFTypeRef v27 = 0;
      }
      *(void *)(a2 + 96) = v27;
    }
  }
  *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
  free(*(void **)(a2 + 112));
  *(void *)(a2 + 112) = 0;
  if (*(void *)(a1 + 112))
  {
    size_t v28 = 4 * *(unsigned int *)(a1 + 104);
    float v29 = malloc_type_malloc(v28, 0x775DBC8AuLL);
    *(void *)(a2 + 112) = v29;
    memcpy(v29, *(const void **)(a1 + 112), v28);
  }
  free(*(void **)(a2 + 120));
  *(void *)(a2 + 120) = 0;
  if (*(void *)(a1 + 120))
  {
    size_t v30 = 2 * *(unsigned __int16 *)(a1 + 128);
    float v31 = malloc_type_malloc(v30, 0xD8BE413FuLL);
    *(void *)(a2 + 120) = v31;
    memcpy(v31, *(const void **)(a1 + 120), v30);
  }
  *(_DWORD *)(a2 + 12_Block_object_dispose(&STACK[0x690], 8) = *(_DWORD *)(a1 + 128);
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
}

uint64_t C3DMeshElementCreateDeepCopy(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMeshElementCreate();
  __C3DMeshElementCopy(a1, v10, 1);
  return v10;
}

CFTypeRef C3DMeshElementSetPrimitiveNormals(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 168);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16_Block_object_dispose(&STACK[0x690], 8) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16_Block_object_dispose(&STACK[0x690], 8) = result;
  }
  return result;
}

uint64_t C3DMeshElementGetPrimitiveNormals(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 168);
}

uint64_t C3DMeshElementCreateByMergingElements(CFArrayRef theArray)
{
  if (!theArray)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreateByMergingElements_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    return 0;
  }
  uint64_t v11 = Count;
  if (Count < 1)
  {
LABEL_9:
    LODWORD(v12) = 0;
    CFStringRef ValueAtIndex = 0;
  }
  else
  {
    CFIndex v12 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(theArray, v12);
      if (C3DMeshElementGetType((uint64_t)ValueAtIndex) < 6) {
        break;
      }
      if (v11 == ++v12) {
        goto LABEL_9;
      }
    }
  }
  char DoubleSided = C3DMeshElementGetDoubleSided((uint64_t)ValueAtIndex);
  IndexCFIndex Count = C3DMeshElementGetIndexCount((uint64_t)ValueAtIndex);
  int Type = C3DMeshElementGetType((uint64_t)ValueAtIndex);
  char v17 = Type;
  uint64_t v18 = ValueAtIndex[80];
  if (Type == 1)
  {
    uint64_t v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      C3DMeshElementCreateByMergingElements_cold_2();
    }
  }
  for (CFIndex i = (v12 + 1); v11 > i; ++i)
  {
    uint64_t v21 = (unsigned __int8 *)CFArrayGetValueAtIndex(theArray, i);
    if (C3DMeshElementGetType((uint64_t)v21) <= 5)
    {
      uint64_t v22 = C3DMeshElementGetIndexCount((uint64_t)v21);
      if (v18 != v21[80])
      {
        uint64_t v34 = scn_default_log();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          C3DMeshElementCreateByMergingElements_cold_1();
        }
        return 0;
      }
      IndexCount += v22;
    }
  }
  uint64_t v23 = C3DMeshElementCreate();
  PrimitiveNormals = (const void *)C3DMeshElementGetPrimitiveNormals((uint64_t)ValueAtIndex);
  C3DMeshElementSetPrimitiveNormals(v23, PrimitiveNormals);
  C3DMeshElementSetDoubleSided(v23, DoubleSided);
  C3DMeshElementSetType(v23, v17);
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, IndexCount * v18);
  CFDataSetLength(Mutable, IndexCount * v18);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (v11 >= 1)
  {
    CFTypeRef v27 = MutableBytePtr;
    for (CFIndex j = 0; j != v11; ++j)
    {
      float v29 = (CFDataRef *)CFArrayGetValueAtIndex(theArray, j);
      if (C3DMeshElementGetType((uint64_t)v29) <= 5)
      {
        CFIndex Length = CFDataGetLength(v29[12]);
        BytePtr = CFDataGetBytePtr(v29[12]);
        memcpy(v27, BytePtr, Length);
        v27 += Length;
      }
    }
  }
  unint64_t IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive(v23);
  if (IndexCountPerPrimitive <= 1) {
    uint64_t v33 = 1;
  }
  else {
    uint64_t v33 = IndexCountPerPrimitive;
  }
  *(_DWORD *)(v23 + 104) = IndexCount / v33;
  __SetIndexes(v23, Mutable, v18);
  free(*(void **)(v23 + 120));
  *(void *)(v23 + 120) = 0;
  *(_WORD *)(v23 + 12_Block_object_dispose(&STACK[0x690], 8) = 0;
  CFRelease(Mutable);
  return v23;
}

BOOL C3DMeshElementTypeDefinesTopology(unsigned int a1)
{
  return a1 < 6;
}

BOOL C3DMeshElementGetDoubleSided(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 81) != 0;
}

void C3DMeshElementSetDoubleSided(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 81) = a2;
}

uint64_t C3DMeshElementGetIndexCountPerPrimitive(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  unint64_t v1 = *(char *)(a1 + 88);
  if (v1 < 4) {
    return qword_20B5CB798[v1];
  }
  uint64_t v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "C3DMeshElementGetIndexCountPerPrimitive";
    _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: %s does not support non-renderable topologies.", (uint8_t *)&v4, 0xCu);
  }
  return 0;
}

void C3DMeshElementSetPrimitives(uint64_t a1, int a2, CFTypeRef cf, char a4)
{
  *(_DWORD *)(a1 + 104) = a2;
  __SetIndexes(a1, cf, a4);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 12_Block_object_dispose(&STACK[0x690], 8) = 0;
}

BOOL C3DMeshElementTypeDefinesSurface(char a1)
{
  return (a1 & 0xFA) == 0;
}

void *C3DMeshElementSetPrimitiveRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(unsigned __int16 *)(a1 + 128);
  CFTypeRef result = *(void **)(a1 + 120);
  if (!v6)
  {
    CFTypeRef result = malloc_type_realloc(result, 0x10uLL, 0x1000040451B5BE8uLL);
    *(void *)(a1 + 120) = result;
  }
  *CFTypeRef result = a2;
  result[1] = a3;
  *(_WORD *)(a1 + 12_Block_object_dispose(&STACK[0x690], 8) = 1;
  return result;
}

uint64_t C3DMeshElementGetPrimitiveRanges(uint64_t a1, _WORD *a2)
{
  if (a2) {
    *a2 = *(_WORD *)(a1 + 128);
  }
  return *(void *)(a1 + 120);
}

uint64_t C3DMeshElementEnumeratePrimitiveRanges(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 120))
  {
    uint64_t v2 = result;
    if (*(_WORD *)(result + 128))
    {
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      do
      {
        CFTypeRef result = (*(uint64_t (**)(uint64_t, void, void))(a2 + 16))(a2, *(void *)(*(void *)(v2 + 120) + v4), *(void *)(*(void *)(v2 + 120) + v4 + 8));
        ++v5;
        v4 += 16;
      }
      while (v5 < *(unsigned __int16 *)(v2 + 128));
    }
  }
  return result;
}

uint64_t C3DMeshElementGetPrimitiveCountByEvaluatingPrimitiveRanges(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (!v1) {
    return *(unsigned int *)(a1 + 104);
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 128);
  if (!*(_WORD *)(a1 + 128)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = (uint64_t *)(v1 + 8);
  do
  {
    uint64_t v5 = *v4;
    v4 += 2;
    result += v5;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 120))
  {
    unsigned int v4 = *(unsigned __int16 *)(result + 128);
    if (*(_WORD *)(result + 128))
    {
      unint64_t v5 = 0;
      do
      {
        int v6 = (unsigned int *)(*(void *)(v3 + 120) + 16 * v5);
        uint64_t v7 = *v6;
        uint64_t v8 = *((void *)v6 + 1);
        if (v7 < (int)v8 + (int)v7)
        {
          do
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
            uint64_t v7 = (v7 + 1);
            LODWORD(v_Block_object_dispose(&STACK[0x690], 8) = v8 - 1;
          }
          while (v8);
          unsigned int v4 = *(unsigned __int16 *)(v3 + 128);
        }
        ++v5;
      }
      while (v5 < v4);
    }
  }
  else if (*(_DWORD *)(result + 104))
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v9);
      uint64_t v9 = (v9 + 1);
    }
    while (v9 < *(_DWORD *)(v3 + 104));
  }
  return result;
}

uint64_t C3DMeshElementGetUsesInterleavedIndicesChannels(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 131);
}

float C3DMeshElementGetPointSize(uint64_t a1)
{
  return *(float *)(a1 + 144);
}

uint64_t C3DMeshElementSetPointSize(uint64_t result, float a2)
{
  *(float *)(result + 144) = a2;
  return result;
}

float C3DMeshElementGetMinimumPointScreenRadius(uint64_t a1)
{
  return *(float *)(a1 + 148);
}

uint64_t C3DMeshElementSetMinimumPointScreenRadius(uint64_t result, float a2)
{
  *(float *)(result + 14_Block_object_dispose(&STACK[0x690], 8) = a2;
  return result;
}

float C3DMeshElementGetMaximumPointScreenRadius(uint64_t a1)
{
  return *(float *)(a1 + 152);
}

uint64_t C3DMeshElementSetMaximumPointScreenRadius(uint64_t result, float a2)
{
  *(float *)(result + 152) = a2;
  return result;
}

uint64_t C3DMeshElementGetVertexCountForPrimitiveAtIndex(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
    return __readIndexInBuffer((uint64_t)BytePtr, a2, *(unsigned __int8 *)(a1 + 80), Length);
  }
  else
  {
    return C3DMeshElementGetIndexCountPerPrimitive(a1);
  }
}

uint64_t __readIndexInBuffer(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if ((a2 + 1) * a3 <= a4)
  {
    switch(a3)
    {
      case 4uLL:
        return *(unsigned int *)(a1 + 4 * a2);
      case 2uLL:
        return *(unsigned __int16 *)(a1 + 2 * a2);
      case 1uLL:
        return *(unsigned __int8 *)(a1 + a2);
      default:
        uint64_t v9 = scn_default_log();
        uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_FAULT);
        if (result)
        {
          __readIndexInBuffer_cold_1(a3, v9);
          return 0;
        }
        break;
    }
  }
  else
  {
    uint64_t v7 = scn_default_log();
    uint64_t result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v10[0] = 67109376;
      v10[1] = a2;
      __int16 v11 = 2048;
      unint64_t v12 = a4 / a3;
      _os_log_error_impl(&dword_20B249000, v7, OS_LOG_TYPE_ERROR, "Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", (uint8_t *)v10, 0x12u);
      return 0;
    }
  }
  return result;
}

uint64_t C3DMeshElementGetIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    char v17 = *(_DWORD **)(a1 + 112);
    if (!v17)
    {
      unint64_t v26 = *(unsigned __int8 *)(a1 + 80);
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
      if (BytePtr)
      {
        uint64_t v29 = (uint64_t)BytePtr;
        uint64_t v30 = *(unsigned int *)(a1 + 104);
        char v17 = malloc_type_malloc(4 * v30, 0x100004052888210uLL);
        *(void *)(a1 + 112) = v17;
        if (v30)
        {
          int v33 = a3;
          uint64_t v31 = 0;
          int v32 = 0;
          do
          {
            v32 += __readIndexInBuffer(v29, v31, v26, Length);
            char v17 = *(_DWORD **)(a1 + 112);
            v17[v31++] = v32;
          }
          while (v30 != v31);
          a3 = v33;
        }
      }
      else
      {
        char v17 = *(_DWORD **)(a1 + 112);
      }
    }
    int v18 = 0;
    if (a2 >= 1 && v17) {
      int v18 = v17[a2 - 1];
    }
  }
  else
  {
    int v16 = 0;
    int v18 = C3DMeshElementGetIndexCountPerPrimitive(a1) * a2;
  }
  if (*(unsigned char *)(a1 + 131))
  {
    int v19 = *(unsigned __int8 *)(a1 + 130);
  }
  else
  {
    a4 *= C3DMeshElementGetIndexCount(a1);
    int v19 = 1;
  }
  unsigned int v20 = a4 + v16 + v19 * (a3 + v18);
  CFDataRef v21 = *(const __CFData **)(a1 + 96);
  if (!v21) {
    return v20;
  }
  unint64_t v22 = *(unsigned __int8 *)(a1 + 80);
  CFIndex v23 = CFDataGetLength(v21);
  CFDataRef v24 = CFDataGetBytePtr(v21);
  return __readIndexInBuffer((uint64_t)v24, v20, v22, v23);
}

uint64_t C3DMeshElementGetChannelsDefineSameTopology(uint64_t a1, int a2, int a3)
{
  if (!a1)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  IndexCFIndex Count = C3DMeshElementGetIndexCount(a1);
  unint64_t v15 = *(unsigned __int8 *)(a1 + 80);
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
  uint64_t v18 = (uint64_t)BytePtr;
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    unint64_t v19 = *(unsigned int *)(a1 + 104) * (unint64_t)v15;
    BOOL v20 = Length > v19;
    Length -= v19;
    if (!v20) {
      C3DMeshElementGetChannelsDefineSameTopology_cold_1();
    }
    uint64_t v18 = (uint64_t)&BytePtr[v19];
  }
  if (*(unsigned char *)(a1 + 131))
  {
    if (IndexCount)
    {
      int v21 = 0;
      while (1)
      {
        int IndexInBuffer = __readIndexInBuffer(v18, a2 + v21 * *(unsigned __int8 *)(a1 + 130), v15, Length);
        if (IndexInBuffer != __readIndexInBuffer(v18, a3 + v21 * *(unsigned __int8 *)(a1 + 130), v15, Length))break; {
        if (IndexCount == ++v21)
        }
          return 1;
      }
      return 0;
    }
  }
  else if (memcmp((const void *)(v18 + v15 * (unint64_t)(IndexCount * a2)), (const void *)(v18 + v15 * (unint64_t)(IndexCount * a3)), IndexCount * (unint64_t)v15))
  {
    return 0;
  }
  return 1;
}

uint64_t C3DMeshElementGetAllChannelsDefineSameTopology(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  unsigned int v10 = *(unsigned __int8 *)(a1 + 130);
  if (v10 < 2) {
    return 1;
  }
  for (unsigned __int8 i = 1; i < v10; ++i)
  {
    uint64_t result = C3DMeshElementGetChannelsDefineSameTopology(a1, 0, i);
    if (!result) {
      break;
    }
  }
  return result;
}

void C3DMeshElementSetSharedMeshElement(uint64_t a1, char *cf, int a3, int a4)
{
  uint64_t v8 = *(char **)(a1 + 72);
  if (v8 != cf)
  {
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 72) = 0;
    }
    if (cf) {
      CFTypeRef v9 = CFRetain(cf);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *(void *)(a1 + 72) = v9;
  }
  char v10 = cf[80];
  uint64_t v11 = (const void *)*((void *)cf + 12);
  *(_DWORD *)(a1 + 104) = a4;
  *(_DWORD *)(a1 + 64) = a3;

  __SetIndexes(a1, v11, v10);
}

uint64_t C3DMeshElementGetSharedIndexBufferOffset(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 64);
}

void C3DMeshElementSetInstanceCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x690], 8) = a2;
}

uint64_t C3DMeshElementCreateVolatile()
{
  uint64_t result = C3DMeshElementCreate();
  *(unsigned char *)(result + 82) = 1;
  return result;
}

void C3DMeshElementSetVolatileDataPtr(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 160) = a2;
}

uint64_t C3DMeshElementGetVolatileDataPtr(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 160);
}

uint64_t C3DMeshElementGetBytesPerIndex(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 80);
}

void C3DIndicesContentEnumeratePrimitives(uint64_t *a1, uint64_t a2, __n128 a3)
{
  v3[0] = MEMORY[0x263EF8330];
  a3.n128_u64[0] = 0x40000000;
  v3[1] = 0x40000000;
  void v3[2] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
  v3[3] = &unk_264004BB0;
  v3[4] = a2;
  C3DIndicesContentArrayEnumeratePrimitives(a1, 1u, (uint64_t)v3, a3);
}

void C3DIndicesContentArrayEnumeratePrimitives(uint64_t *a1, unsigned int a2, uint64_t a3, __n128 a4)
{
  uint64_t v130 = *MEMORY[0x263EF8340];
  int v4 = *((unsigned __int8 *)a1 + 26);
  uint64_t v117 = *((unsigned int *)a1 + 2);
  int v5 = *((unsigned __int8 *)a1 + 27);
  uint64_t v6 = a1[4];
  char v122 = 0;
  long long v116 = (__n128 *)a3;
  switch(v4)
  {
    case 0:
    case 1:
    case 5:
      if (a2 == 1)
      {
        long long v10 = *((_OWORD *)a1 + 1);
        *(_OWORD *)float32x4_t buf = *(_OWORD *)a1;
        long long v124 = v10;
        long long v125 = *((_OWORD *)a1 + 2);
        uint64_t v126 = a1[6];
        if (v117)
        {
          for (uint64_t i = 0; i != v117; ++i)
          {
            *(_OWORD *)long long v118 = *(_OWORD *)buf;
            long long v119 = v124;
            long long v120 = v125;
            uint64_t v121 = v126;
            C3DIndicesContentGetTriangleIndex((uint64_t *)v118, i, &v127, &v128, &v129);
            (*(void (**)(uint64_t, uint64_t, int *, uint64_t, char *))(a3 + 16))(a3, i, &v127, 3, &v122);
            if (v122) {
              break;
            }
          }
        }
      }
      else
      {
        long long v115 = &v111;
        MEMORY[0x270FA5388](a1);
        uint64_t v13 = (char *)&v111 - v12;
        if (v117)
        {
          uint64_t v14 = 0;
          do
          {
            if (a2)
            {
              uint64_t v15 = 0;
              int v16 = a1;
              do
              {
                long long v17 = *((_OWORD *)v16 + 1);
                *(_OWORD *)float32x4_t buf = *(_OWORD *)v16;
                long long v124 = v17;
                long long v125 = *((_OWORD *)v16 + 2);
                uint64_t v126 = v16[6];
                C3DIndicesContentGetTriangleIndex((uint64_t *)buf, v14, &v13[v15], &v13[4 * a2 + v15], &v13[8 * a2 + v15]);
                v15 += 4;
                v16 += 7;
              }
              while (4 * a2 != v15);
            }
            ((void (*)(__n128 *, uint64_t, char *, uint64_t, char *))v116[1].n128_u64[0])(v116, v14, v13, 3, &v122);
            if (v122) {
              break;
            }
            ++v14;
          }
          while (v14 != v117);
        }
      }
      return;
    case 2:
      if (a2 == 1)
      {
        if (v117)
        {
          uint64_t v25 = 0;
          uint64_t v26 = *a1;
          unsigned int v27 = 1;
          uint64_t v29 = a1[5];
          uint64_t v28 = a1[6];
          while (1)
          {
            switch(v5)
            {
              case 1:
                *(_DWORD *)float32x4_t buf = *(unsigned __int8 *)(v26 + v29 + v28 * (v27 - 1));
                int v30 = *(unsigned __int8 *)(v26 + v29 + v28 * v27);
                break;
              case 2:
                *(_DWORD *)float32x4_t buf = *(unsigned __int16 *)(v26 + 2 * (v29 + v28 * (v27 - 1)));
                int v30 = *(unsigned __int16 *)(v26 + 2 * (v29 + v28 * v27));
                break;
              case 4:
                *(_DWORD *)float32x4_t buf = *(_DWORD *)(v26 + 4 * (v29 + v28 * (v27 - 1)));
                int v30 = *(_DWORD *)(v26 + 4 * (v29 + v28 * v27));
                break;
              default:
                goto LABEL_28;
            }
            *(_DWORD *)&uint8_t buf[4] = v30;
LABEL_28:
            (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a3 + 16))(a3, v25, buf, 2, &v122);
            if (!v122)
            {
              ++v25;
              v27 += 2;
              if (v117 != v25) {
                continue;
              }
            }
            return;
          }
        }
      }
      else
      {
        MEMORY[0x270FA5388](a1);
        float32x4_t v80 = (char *)&v111 - v79;
        if (v117)
        {
          uint64_t v81 = 0;
          uint64_t v82 = 4 * a2;
          long long v83 = &v80[v82];
          do
          {
            if (v5 == 1)
            {
              if (a2)
              {
                uint64_t v89 = 0;
                float32x4_t v90 = a1 + 6;
                do
                {
                  uint64_t v91 = *(v90 - 6);
                  uint64_t v92 = *(v90 - 1);
                  uint64_t v93 = *v90;
                  *(_DWORD *)&v80[v89] = *(unsigned __int8 *)(v91 + v92 + *v90 * (2 * v81));
                  *(_DWORD *)&v83[v89] = *(unsigned __int8 *)(v91 + v92 + v93 * ((2 * v81) | 1u));
                  v89 += 4;
                  v90 += 7;
                }
                while (v82 != v89);
              }
            }
            else if (v5 == 2)
            {
              if (a2)
              {
                uint64_t v94 = 0;
                float v95 = a1 + 6;
                do
                {
                  uint64_t v96 = *(v95 - 6);
                  uint64_t v97 = *(v95 - 1);
                  uint64_t v98 = *v95;
                  *(_DWORD *)&v80[v94] = *(unsigned __int16 *)(v96 + 2 * (v97 + *v95 * (2 * v81)));
                  *(_DWORD *)&v83[v94] = *(unsigned __int16 *)(v96 + 2 * (v97 + v98 * ((2 * v81) | 1u)));
                  v94 += 4;
                  v95 += 7;
                }
                while (v82 != v94);
              }
            }
            else if (v5 == 4 && a2)
            {
              uint64_t v84 = 0;
              uint64_t v85 = a1 + 6;
              do
              {
                uint64_t v86 = *(v85 - 6);
                uint64_t v87 = *(v85 - 1);
                uint64_t v88 = *v85;
                *(_DWORD *)&v80[v84] = *(_DWORD *)(v86 + 4 * (v87 + *v85 * (2 * v81)));
                *(_DWORD *)&v83[v84] = *(_DWORD *)(v86 + 4 * (v87 + v88 * ((2 * v81) | 1u)));
                v84 += 4;
                v85 += 7;
              }
              while (v82 != v84);
            }
            ((void (*)(__n128 *, uint64_t, char *, uint64_t, char *))v116[1].n128_u64[0])(v116, v81, v80, 2, &v122);
            if (v122) {
              break;
            }
            ++v81;
          }
          while (v81 != v117);
        }
      }
      return;
    case 3:
      if (a2 == 1)
      {
        uint64_t v31 = *a1;
        uint64_t v33 = a1[5];
        uint64_t v32 = a1[6];
        *(_DWORD *)float32x4_t buf = 0;
        if (!v117) {
          return;
        }
        uint64_t v34 = 0;
        while (1)
        {
          switch(v5)
          {
            case 4:
              int v35 = *(_DWORD *)(v31 + 4 * v33);
              break;
            case 2:
              int v35 = *(unsigned __int16 *)(v31 + 2 * v33);
              break;
            case 1:
              int v35 = *(unsigned __int8 *)(v31 + v33);
              break;
            default:
              goto LABEL_41;
          }
          *(_DWORD *)float32x4_t buf = v35;
LABEL_41:
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a3 + 16))(a3, v34, buf, 1, &v122);
          if (!v122)
          {
            ++v34;
            v33 += v32;
            if (v117 != v34) {
              continue;
            }
          }
          return;
        }
      }
      MEMORY[0x270FA5388](a1);
      uint64_t v100 = (char *)&v111 - v99;
      if (v117)
      {
        for (uint64_t j = 0; j != v117; ++j)
        {
          switch(v5)
          {
            case 1:
              if (a2)
              {
                uint64_t v105 = a2;
                long long v106 = v100;
                long long v107 = a1 + 6;
                do
                {
                  *(_DWORD *)long long v106 = *(unsigned __int8 *)(*(v107 - 6) + *(v107 - 1) + *v107 * j);
                  v106 += 4;
                  v107 += 7;
                  --v105;
                }
                while (v105);
              }
              break;
            case 2:
              uint64_t v108 = a2;
              long long v109 = v100;
              long long v110 = a1 + 6;
              if (a2)
              {
                do
                {
                  *(_DWORD *)long long v109 = *(unsigned __int16 *)(*(v110 - 6) + 2 * (*(v110 - 1) + *v110 * j));
                  v109 += 4;
                  v110 += 7;
                  --v108;
                }
                while (v108);
              }
              break;
            case 4:
              uint64_t v102 = a2;
              long long v103 = v100;
              long long v104 = a1 + 6;
              if (a2)
              {
                do
                {
                  *(_DWORD *)long long v103 = *(_DWORD *)(*(v104 - 6) + 4 * (*(v104 - 1) + *v104 * j));
                  v103 += 4;
                  v104 += 7;
                  --v102;
                }
                while (v102);
              }
              break;
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a3 + 16))(a3, j, v100, 1, &v122);
          if (v122) {
            break;
          }
        }
      }
      return;
    case 4:
      if (!v117) {
        return;
      }
      uint64_t v36 = 0;
      unsigned int v37 = 0;
      long long v115 = v116 + 1;
      long long v112 = &v118[1];
      a4.n128_u64[0] = 67109120;
      __n128 v111 = a4;
      uint64_t v113 = v6;
      while (2)
      {
        switch(v5)
        {
          case 4:
            uint64_t v38 = *(unsigned int *)(v6 + 4 * v36);
            break;
          case 2:
            uint64_t v38 = *(unsigned __int16 *)(v6 + 2 * v36);
            break;
          case 1:
            uint64_t v38 = *(unsigned __int8 *)(v6 + v36);
            break;
          default:
            LODWORD(v3_Block_object_dispose(&STACK[0x690], 8) = 0;
LABEL_60:
            simd_float4 v46 = scn_default_log();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              C3DIndicesContentArrayEnumeratePrimitives_cold_2(v118, v112, v46);
            }
            goto LABEL_90;
        }
        if (v38 <= 2) {
          goto LABEL_60;
        }
        if (a2 == 1)
        {
          MEMORY[0x270FA5388](56);
          if (v5 == 1)
          {
            unsigned int v59 = v37;
            long long v60 = (__n128 *)((char *)&v111 - v43);
            do
            {
              v60->n128_u32[0] = *(unsigned __int8 *)(v39 + v40 + v42 * v59);
              long long v60 = (__n128 *)((char *)v60 + 4);
              ++v59;
              --v41;
            }
            while (v41);
          }
          else if (v5 == 2)
          {
            unsigned int v61 = v37;
            long long v62 = (__n128 *)((char *)&v111 - v43);
            do
            {
              v62->n128_u32[0] = *(unsigned __int16 *)(v39 + 2 * (v40 + v42 * v61));
              long long v62 = (__n128 *)((char *)v62 + 4);
              ++v61;
              --v41;
            }
            while (v41);
          }
          else
          {
            unsigned int v44 = v37;
            float32x4_t v45 = (__n128 *)((char *)&v111 - v43);
            do
            {
              v45->n128_u32[0] = *(_DWORD *)(v39 + 4 * (v40 + v42 * v44));
              float32x4_t v45 = (__n128 *)((char *)v45 + 4);
              ++v44;
              --v41;
            }
            while (v41);
          }
          ((void (*)(__n128 *, uint64_t, char *, uint64_t, char *))v116[1].n128_u64[0])(v116, v36, (char *)&v111 - v43, v38, &v122);
          uint64_t v6 = v113;
          if (v122) {
            return;
          }
LABEL_90:
          v37 += v38;
          if (++v36 == v117) {
            return;
          }
          continue;
        }
        break;
      }
      uint64_t v47 = MEMORY[0x270FA5388](56);
      long long v49 = (char *)&v111 - v48;
      uint64_t v114 = v50;
      if (v5 == 1)
      {
        if (a2)
        {
          uint64_t v63 = 0;
          do
          {
            uint64_t v64 = (uint64_t *)((char *)a1 + v63 * v47);
            uint64_t v65 = *v64;
            uint64_t v66 = v64[5];
            uint64_t v67 = v64[6];
            uint64_t v68 = v38;
            unsigned int v69 = v37;
            int v70 = v63;
            do
            {
              *(_DWORD *)&v49[4 * v70] = *(unsigned __int8 *)(v65 + v66 + v67 * v69);
              v70 += a2;
              ++v69;
              --v68;
            }
            while (v68);
            ++v63;
          }
          while (v63 != a2);
        }
      }
      else if (v5 == 2)
      {
        if (a2)
        {
          uint64_t v71 = 0;
          do
          {
            float32x4_t v72 = (uint64_t *)((char *)a1 + v71 * v47);
            uint64_t v73 = *v72;
            uint64_t v74 = v72[5];
            uint64_t v75 = v72[6];
            uint64_t v76 = v38;
            unsigned int v77 = v37;
            int v78 = v71;
            do
            {
              *(_DWORD *)&v49[4 * v78] = *(unsigned __int16 *)(v73 + 2 * (v74 + v75 * v77));
              v78 += a2;
              ++v77;
              --v76;
            }
            while (v76);
            ++v71;
          }
          while (v71 != a2);
        }
      }
      else if (a2)
      {
        uint64_t v51 = 0;
        do
        {
          float32x4_t v52 = (uint64_t *)((char *)a1 + v51 * v47);
          uint64_t v53 = *v52;
          uint64_t v54 = v52[5];
          uint64_t v55 = v52[6];
          uint64_t v56 = v38;
          unsigned int v57 = v37;
          int v58 = v51;
          do
          {
            *(_DWORD *)&v49[4 * v58] = *(_DWORD *)(v53 + 4 * (v54 + v55 * v57));
            v58 += a2;
            ++v57;
            --v56;
          }
          while (v56);
          ++v51;
        }
        while (v51 != a2);
      }
      ((void (*)(__n128 *, uint64_t, char *, uint64_t, char *))v116[1].n128_u64[0])(v116, v36, v49, v38, &v122);
      if (!v122) {
        goto LABEL_90;
      }
      return;
    default:
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        C3DIndicesContentArrayEnumeratePrimitives_cold_1((char)v4, v18, v19, v20, v21, v22, v23, v24);
      }
      return;
  }
}

uint64_t __C3DIndicesContentEnumeratePrimitives_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void C3DIndicesContentEnumerateTriangulatedPrimitives(uint64_t *a1, uint64_t a2, __n128 a3)
{
  v3[0] = MEMORY[0x263EF8330];
  a3.n128_u64[0] = 0x40000000;
  v3[1] = 0x40000000;
  void v3[2] = __C3DIndicesContentEnumerateTriangulatedPrimitives_block_invoke;
  v3[3] = &unk_264004BD8;
  v3[4] = a2;
  C3DIndicesContentArrayEnumeratePrimitives(a1, 1u, (uint64_t)v3, a3);
}

void __C3DIndicesContentEnumerateTriangulatedPrimitives_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if (a4 == 3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
  }
  else if (a4 < 4)
  {
    long long v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      __C3DIndicesContentEnumerateTriangulatedPrimitives_block_invoke_cold_1();
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = a4 - 2;
    do
    {
      if (v8 == v7) {
        break;
      }
      uint64_t v9 = v7 + 1;
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
      uint64_t v7 = v9;
    }
    while (!a5);
  }
}

void C3DIndicesContentGetTriangleIndex(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v5 = *((unsigned __int8 *)a1 + 26);
  uint64_t v6 = 3;
  if (a2) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 2;
  }
  if (a2) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 1;
  }
  BOOL v9 = v5 == 1 || v5 != 5;
  if (v5 != 1)
  {
    uint64_t v7 = 2;
    uint64_t v8 = 1;
  }
  BOOL v10 = v5 == 0;
  if (*((unsigned char *)a1 + 26)) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = 3;
  }
  if (*((unsigned char *)a1 + 26))
  {
    uint64_t v6 = 1;
    uint64_t v12 = v7;
  }
  else
  {
    uint64_t v12 = 2;
  }
  if (v10) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v8;
  }
  uint64_t v14 = *a1;
  if (!*a1)
  {
    *a3 = v11 * a2;
    *a4 = v13 + v6 * a2;
    int v20 = v6 * a2 + v12;
    goto LABEL_29;
  }
  uint64_t v16 = (uint64_t)a1 + 27;
  int v15 = *((unsigned __int8 *)a1 + 27);
  switch(v15)
  {
    case 4:
      uint64_t v21 = a1[5];
      uint64_t v22 = a1[6];
      *a3 = *(_DWORD *)(v14 + 4 * (v21 + v11 * a2 * v22));
      uint64_t v23 = v6 * a2;
      *a4 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v13 + v23)));
      int v20 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v23 + v12)));
      goto LABEL_29;
    case 2:
      uint64_t v24 = a1[5];
      uint64_t v25 = a1[6];
      *a3 = *(unsigned __int16 *)(v14 + 2 * (v24 + v11 * a2 * v25));
      uint64_t v26 = v6 * a2;
      *a4 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v13 + v26)));
      int v20 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v26 + v12)));
      goto LABEL_29;
    case 1:
      uint64_t v17 = a1[5];
      uint64_t v18 = a1[6];
      *a3 = *(unsigned __int8 *)(v14 + v17 + v11 * a2 * v18);
      uint64_t v19 = v6 * a2;
      *a4 = *(unsigned __int8 *)(v14 + v17 + v18 * (v13 + v19));
      int v20 = *(unsigned __int8 *)(v14 + v17 + v18 * (v19 + v12));
LABEL_29:
      *a5 = v20;
      return;
  }
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  unsigned int v27 = scn_default_log();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
    C3DIndicesContentGetTriangleIndex_cold_1(v16, v27, v28, v29, v30, v31, v32, v33);
  }
}

void C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v4 = a1;
  v92[5] = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 16))
  {
    long long v11 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)float32x4_t buf = *(_OWORD *)a1;
    long long v88 = v11;
    long long v89 = *(_OWORD *)(a1 + 32);
    v12.n128_u64[1] = *((void *)&v89 + 1);
    uint64_t v90 = *(void *)(a1 + 48);
    *(void *)uint64_t v91 = MEMORY[0x263EF8330];
    v12.n128_u64[0] = 0x40000000;
    v92[0] = 0x40000000;
    v92[1] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
    v92[2] = &unk_264004BB0;
    v92[3] = a2;
    C3DIndicesContentArrayEnumeratePrimitives((uint64_t *)buf, 1u, (uint64_t)v91, v12);
    return;
  }
  char v86 = 0;
  switch(*(unsigned char *)(a1 + 26))
  {
    case 0:
    case 1:
    case 5:
      LODWORD(v92[0]) = 0;
      *(void *)uint64_t v91 = 0;
      unsigned int v5 = *(unsigned __int16 *)(a1 + 24);
      if (*(_WORD *)(a1 + 24))
      {
        uint64_t v6 = 0;
        while (1)
        {
          uint64_t v7 = (void *)(*(void *)(v4 + 16) + 16 * v6);
          uint64_t v8 = v7[1];
          if (*v7 < v8 + *v7) {
            break;
          }
LABEL_10:
          if (++v6 >= (unint64_t)v5) {
            return;
          }
        }
        uint64_t v9 = *v7;
        while (1)
        {
          long long v10 = *(_OWORD *)(v4 + 16);
          *(_OWORD *)float32x4_t buf = *(_OWORD *)v4;
          long long v88 = v10;
          long long v89 = *(_OWORD *)(v4 + 32);
          uint64_t v90 = *(void *)(v4 + 48);
          C3DIndicesContentGetTriangleIndex((uint64_t *)buf, v9, v91, &v91[4], v92);
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a2 + 16))(a2, v9, v91, 3, &v86);
          if (v86) {
            break;
          }
          ++v9;
          LODWORD(v_Block_object_dispose(&STACK[0x690], 8) = v8 - 1;
          if (!v8)
          {
            unsigned int v5 = *(unsigned __int16 *)(v4 + 24);
            goto LABEL_10;
          }
        }
      }
      return;
    case 2:
      *(void *)float32x4_t buf = 0;
      unsigned int v20 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      unint64_t v21 = 0;
      do
      {
        uint64_t v22 = (uint64_t *)(*(void *)(v4 + 16) + 16 * v21);
        uint64_t v23 = *v22;
        uint64_t v24 = v22[1] + *v22;
        if (v23 >= v24) {
          goto LABEL_30;
        }
        uint64_t v25 = v23;
        unsigned int v26 = 2 * v23;
        unint64_t v27 = v24 - (unint64_t)v23;
        do
        {
          int v28 = *(unsigned __int8 *)(v4 + 27);
          switch(v28)
          {
            case 1:
              uint64_t v33 = *(void *)v4;
              uint64_t v34 = *(void *)(v4 + 40);
              uint64_t v35 = *(void *)(v4 + 48);
              *(_DWORD *)float32x4_t buf = *(unsigned __int8 *)(*(void *)v4 + v34 + v35 * v26);
              int v32 = *(unsigned __int8 *)(v33 + v34 + v35 * (v26 + 1));
              break;
            case 2:
              uint64_t v36 = *(void *)v4;
              uint64_t v37 = *(void *)(v4 + 40);
              uint64_t v38 = *(void *)(v4 + 48);
              *(_DWORD *)float32x4_t buf = *(unsigned __int16 *)(*(void *)v4 + 2 * (v37 + v38 * v26));
              int v32 = *(unsigned __int16 *)(v36 + 2 * (v37 + v38 * (v26 + 1)));
              break;
            case 4:
              uint64_t v29 = *(void *)v4;
              uint64_t v30 = *(void *)(v4 + 40);
              uint64_t v31 = *(void *)(v4 + 48);
              *(_DWORD *)float32x4_t buf = *(_DWORD *)(*(void *)v4 + 4 * (v30 + v31 * v26));
              int v32 = *(_DWORD *)(v29 + 4 * (v30 + v31 * (v26 + 1)));
              break;
            default:
              goto LABEL_27;
          }
          *(_DWORD *)&uint8_t buf[4] = v32;
LABEL_27:
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a2 + 16))(a2, v25, buf, 2, &v86);
          if (v86) {
            return;
          }
          ++v25;
          v26 += 2;
          --v27;
        }
        while (v27);
        unsigned int v20 = *(unsigned __int16 *)(v4 + 24);
LABEL_30:
        ++v21;
      }
      while (v21 < v20);
      return;
    case 3:
      *(_DWORD *)float32x4_t buf = 0;
      unsigned int v39 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      uint64_t v40 = 0;
      while (1)
      {
        uint64_t v41 = (uint64_t *)(*(void *)(v4 + 16) + 16 * v40);
        uint64_t v42 = *v41;
        uint64_t v43 = v41[1] + *v41;
        if (v42 < v43) {
          break;
        }
LABEL_46:
        if (++v40 >= (unint64_t)v39) {
          return;
        }
      }
      uint64_t v44 = v42;
      uint64_t v45 = v43;
      while (1)
      {
        int v46 = *(unsigned __int8 *)(v4 + 27);
        if (v46 == 4) {
          break;
        }
        if (v46 == 2)
        {
          int v47 = *(unsigned __int16 *)(*(void *)v4 + 2 * (*(void *)(v4 + 40) + *(void *)(v4 + 48) * v44));
          goto LABEL_42;
        }
        if (v46 == 1)
        {
          int v47 = *(unsigned __int8 *)(*(void *)v4 + *(void *)(v4 + 40) + *(void *)(v4 + 48) * v44);
LABEL_42:
          *(_DWORD *)float32x4_t buf = v47;
        }
        (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a2 + 16))(a2, v44, buf, 1, &v86);
        if (v86) {
          return;
        }
        if (v45 == ++v44)
        {
          unsigned int v39 = *(unsigned __int16 *)(v4 + 24);
          goto LABEL_46;
        }
      }
      int v47 = *(_DWORD *)(*(void *)v4 + 4 * (*(void *)(v4 + 40) + *(void *)(v4 + 48) * v44));
      goto LABEL_42;
    case 4:
      unsigned int v48 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      uint64_t v49 = 0;
      uint64_t v84 = &v91[1];
      uint64_t v85 = a2 + 16;
      a3.n128_u64[0] = 67109120;
      __n128 v83 = a3;
      while (2)
      {
        uint64_t v50 = (uint64_t *)(*(void *)(v4 + 16) + 16 * v49);
        uint64_t v51 = *v50;
        if (*v50)
        {
          uint64_t v52 = 0;
          unsigned int v53 = 0;
          int v54 = *(unsigned __int8 *)(v4 + 27);
          do
          {
            switch(v54)
            {
              case 4:
                int v55 = *(_DWORD *)(*(void *)(v4 + 32) + 4 * v52);
                break;
              case 2:
                int v55 = *(unsigned __int16 *)(*(void *)(v4 + 32) + 2 * v52);
                break;
              case 1:
                int v55 = *(unsigned __int8 *)(*(void *)(v4 + 32) + v52);
                break;
              default:
                int v55 = 0;
                break;
            }
            v53 += v55;
            ++v52;
          }
          while (*v50 != v52);
        }
        else
        {
          unsigned int v53 = 0;
        }
        uint64_t v56 = v50[1] + v51;
        if (v51 >= v56) {
          goto LABEL_91;
        }
        uint64_t v57 = v51;
        uint64_t v58 = v56;
LABEL_64:
        int v59 = *(unsigned __int8 *)(v4 + 27);
        switch(v59)
        {
          case 4:
            uint64_t v60 = *(unsigned int *)(*(void *)(v4 + 32) + 4 * v57);
            break;
          case 2:
            uint64_t v60 = *(unsigned __int16 *)(*(void *)(v4 + 32) + 2 * v57);
            break;
          case 1:
            uint64_t v60 = *(unsigned __int8 *)(*(void *)(v4 + 32) + v57);
            break;
          default:
            LODWORD(v60) = 0;
            goto LABEL_78;
        }
        if (v60 > 2)
        {
          MEMORY[0x270FA5388](a1);
          uint64_t v63 = (char *)&v83 - v62;
          int v64 = *(unsigned __int8 *)(v4 + 27);
          switch(v64)
          {
            case 4:
              uint64_t v71 = *(void *)v4;
              unsigned int v72 = v53;
              uint64_t v73 = (__n128 *)((char *)&v83 - v62);
              uint64_t v74 = *(void *)(v4 + 40);
              uint64_t v75 = *(void *)(v4 + 48);
              do
              {
                v73->n128_u32[0] = *(_DWORD *)(v71 + 4 * (v74 + v75 * v72));
                uint64_t v73 = (__n128 *)((char *)v73 + 4);
                ++v72;
                --v61;
              }
              while (v61);
              break;
            case 2:
              uint64_t v76 = *(void *)v4;
              unsigned int v77 = v53;
              int v78 = (__n128 *)((char *)&v83 - v62);
              uint64_t v79 = *(void *)(v4 + 40);
              uint64_t v80 = *(void *)(v4 + 48);
              do
              {
                v78->n128_u32[0] = *(unsigned __int16 *)(v76 + 2 * (v79 + v80 * v77));
                int v78 = (__n128 *)((char *)v78 + 4);
                ++v77;
                --v61;
              }
              while (v61);
              break;
            case 1:
              uint64_t v65 = *(void *)v4;
              unsigned int v66 = v53;
              uint64_t v67 = (__n128 *)((char *)&v83 - v62);
              uint64_t v68 = *(void *)(v4 + 40);
              uint64_t v69 = *(void *)(v4 + 48);
              do
              {
                v67->n128_u32[0] = *(unsigned __int8 *)(v65 + v68 + v69 * v66);
                uint64_t v67 = (__n128 *)((char *)v67 + 4);
                ++v66;
                --v61;
              }
              while (v61);
              break;
            default:
              bzero((char *)&v83 - v62, 4 * v61);
              uint64_t v81 = scn_default_log();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
              {
                int v82 = *(unsigned __int8 *)(v4 + 27);
                *(_DWORD *)float32x4_t buf = v83.n128_u32[0];
                *(_DWORD *)&uint8_t buf[4] = v82;
                _os_log_error_impl(&dword_20B249000, v81, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
              }
              break;
          }
          a1 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a2 + 16))(a2, v57, v63, v60, &v86);
          if (v86) {
            return;
          }
LABEL_89:
          v53 += v60;
          if (++v57 == v58)
          {
            unsigned int v48 = *(unsigned __int16 *)(v4 + 24);
LABEL_91:
            if (++v49 >= (unint64_t)v48) {
              return;
            }
            continue;
          }
          goto LABEL_64;
        }
        break;
      }
LABEL_78:
      int v70 = scn_default_log();
      a1 = os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
      if (a1) {
        C3DIndicesContentArrayEnumeratePrimitives_cold_2(v91, v84, v70);
      }
      goto LABEL_89;
    default:
      uint64_t v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges_cold_1(v4 + 26, v13, v14, v15, v16, v17, v18, v19);
      }
      return;
  }
}

void C3DMeshElementPrintData(uint64_t a1)
{
  char Type = C3DMeshElementGetType(a1);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 130);
  if (*(unsigned char *)(a1 + 130))
  {
    char v4 = Type;
    uint64_t v5 = 0;
    do
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "CHANNEL %ld/%ld\n", v5 + 1, v3);
      uint64_t v15 = 0;
      long long v13 = 0u;
      __n128 v14 = 0u;
      long long v12 = 0u;
      C3DMeshElementGetContent(a1, v5, (uint64_t)&v12);
      v10[0] = 0;
      v10[1] = v10;
      _DWORD v10[2] = 0x2000000000;
      int v11 = 0;
      v8[0] = MEMORY[0x263EF8330];
      v8[1] = 0x40000000;
      v8[2] = __C3DMeshElementPrintData_block_invoke;
      v8[3] = &unk_264004C00;
      char v9 = v4;
      _OWORD v8[4] = v10;
      v6[0] = v12;
      v6[1] = v13;
      v6[2] = v14;
      uint64_t v7 = v15;
      v16[0] = MEMORY[0x263EF8330];
      v16[1] = 0x40000000;
      v16[2] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
      v16[3] = &unk_264004BB0;
      _OWORD v16[4] = v8;
      C3DIndicesContentArrayEnumeratePrimitives((uint64_t *)v6, 1u, (uint64_t)v16, v14);
      _Block_object_dispose(v10, 8);
      ++v5;
    }
    while (v3 != v5);
  }
}

uint64_t __C3DMeshElementPrintData_block_invoke(uint64_t result, uint64_t a2, int *a3, unsigned int a4)
{
  uint64_t v4 = result;
  switch(*(unsigned char *)(result + 40))
  {
    case 0:
    case 1:
    case 5:
      uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8358], "%4u : %4u %4u %4u\n");
      break;
    case 2:
      uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8358], "%4u : %4u %4u\n");
      break;
    case 3:
      uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8358], "%4u : %4u\n");
      break;
    case 4:
      uint64_t v7 = (FILE **)MEMORY[0x263EF8358];
      fprintf((FILE *)*MEMORY[0x263EF8358], "%2u : [Polygon %4u]", *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24), a4);
      if (a4)
      {
        uint64_t v8 = a4;
        do
        {
          int v9 = *a3++;
          fprintf(*v7, " %4u", v9);
          --v8;
        }
        while (v8);
      }
      uint64_t result = fputc(10, *v7);
      break;
    default:
      break;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(v4 + 32) + 8) + 24);
  return result;
}

id _C3DMeshElementCFFinalize(uint64_t a1)
{
  if (!*(void *)(a1 + 72))
  {
    CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshElementWillDie", (const void *)a1, 0, 1u);
  }
  uint64_t v3 = *(const void **)(a1 + 96);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 168);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16_Block_object_dispose(&STACK[0x690], 8) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 72);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 136);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 136) = 0;
  }
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 208));

  return C3DEntityCFFinalize(a1);
}

__CFString *_C3DMeshElementCFCopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  unint64_t v3 = *(char *)(a1 + 88);
  if (v3 > 5) {
    uint64_t v4 = @"invalid";
  }
  else {
    uint64_t v4 = off_264004C20[v3];
  }
  uint64_t v5 = *(unsigned int *)(a1 + 104);
  uint64_t v6 = *(unsigned __int8 *)(a1 + 130);
  uint64_t v7 = *(unsigned __int8 *)(a1 + 80);
  uint64_t v8 = *(unsigned int *)(a1 + 64);
  float v9 = C3DMeshElementComputeACMR(a1, 0x20uLL);
  uint64_t v10 = *(unsigned int *)(a1 + 68);
  CFDataRef Length = *(const __CFData **)(a1 + 96);
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  CFStringAppendFormat(Mutable, 0, @"<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>", a1, v4, v5, v6, v7, v8, v9, v10, Length, *(void *)(a1 + 72));
  return Mutable;
}

BOOL _C3DMeshElementInitWithPropertyList(char *a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    if (!a2)
    {
LABEL_4:
      uint64_t v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
        _C3DGeometryFinalizeDeserialization_cold_4(v15, v16, v17, v18, v19, v20, v21, v22);
      }
    }
  }
  else if (!a2)
  {
    goto LABEL_4;
  }
  if ((C3DEntityInitWithPropertyList((uint64_t)a1, a2) & 1) == 0)
  {
    int v28 = scn_default_log();
    BOOL result = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DMeshElementInitWithPropertyList_cold_6(v28);
    return 0;
  }
  *((_DWORD *)a1 + 26) = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"facesCount");
  if (!Value || !CFNumberGetValue(Value, kCFNumberIntType, a1 + 104))
  {
    uint64_t v30 = scn_default_log();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_61;
    }
    _C3DMeshElementInitWithPropertyList_cold_1();
    if (!a4) {
      return 0;
    }
    goto LABEL_62;
  }
  CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(a2, @"geometryElement");
  if (!v24) {
    goto LABEL_21;
  }
  CFNumberRef v25 = v24;
  int valuePtr = 0;
  CFTypeID v26 = CFGetTypeID(v24);
  if (v26 == CFNumberGetTypeID() && CFNumberGetValue(v25, kCFNumberIntType, &valuePtr))
  {
    char v27 = valuePtr;
    goto LABEL_36;
  }
  CFTypeID v31 = CFGetTypeID(v25);
  if (v31 != CFStringGetTypeID())
  {
LABEL_21:
    int v32 = scn_default_log();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_61;
    }
    _C3DMeshElementInitWithPropertyList_cold_2();
    if (!a4) {
      return 0;
    }
    goto LABEL_62;
  }
  if (CFEqual(v25, @"linesArray"))
  {
    char v27 = 2;
    goto LABEL_36;
  }
  if (CFEqual(v25, @"trianglesArray")) {
    goto LABEL_27;
  }
  if (CFEqual(v25, @"pointsArray"))
  {
    char v27 = 3;
  }
  else if (CFEqual(v25, @"trianglesStrip"))
  {
    char v27 = 1;
  }
  else if (CFEqual(v25, @"polygonsArray"))
  {
    char v27 = 4;
  }
  else
  {
    uint64_t v33 = scn_default_log();
    BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    char v27 = 0;
    if (v34)
    {
      *(_DWORD *)float32x4_t buf = 138412290;
      CFNumberRef v52 = v25;
      _os_log_impl(&dword_20B249000, v33, OS_LOG_TYPE_DEFAULT, "Warning: Unknown mesh element type %@, assuming triangles array.", buf, 0xCu);
LABEL_27:
      char v27 = 0;
    }
  }
LABEL_36:
  a1[88] = v27;
  CFDataRef v35 = (const __CFData *)CFDictionaryGetValue(a2, @"indexes");
  if (!v35)
  {
    unsigned int v39 = scn_default_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_61;
    }
    _C3DMeshElementInitWithPropertyList_cold_3();
    if (!a4) {
      return 0;
    }
    goto LABEL_62;
  }
  CFDataRef v36 = v35;
  a1[80] = 4;
  CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bytesPerIndex");
  if (v37)
  {
    *(_DWORD *)float32x4_t buf = 0;
    if (!CFNumberGetValue(v37, kCFNumberIntType, buf))
    {
      int v47 = scn_default_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        _C3DMeshElementInitWithPropertyList_cold_5();
        if (!a4) {
          return 0;
        }
      }
      else if (!a4)
      {
        return 0;
      }
      if (!*a4) {
        *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
      }
      return 0;
    }
    int v38 = buf[0];
    a1[80] = buf[0];
  }
  else
  {
    int v38 = a1[80];
  }
  CFIndex v40 = CFDataGetLength(v36) / a1[80];
  if (v40 >= 1)
  {
    uint64_t v41 = 9;
    if (v38 == 1) {
      uint64_t v41 = 7;
    }
    if (v38 == 2) {
      uint64_t v42 = 8;
    }
    else {
      uint64_t v42 = v41;
    }
    CFDataRef v43 = C3DCopyLittleEndianToHostRepresentationOfData(v36, v42, v40);
    if (v43)
    {
      CFDataRef v44 = v43;
      __SetIndexes((uint64_t)a1, v43, a1[80]);
      CFRelease(v44);
      goto LABEL_52;
    }
    unsigned int v48 = scn_default_log();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
LABEL_61:
      if (!a4) {
        return 0;
      }
      goto LABEL_62;
    }
    _C3DMeshElementInitWithPropertyList_cold_4();
    if (!a4) {
      return 0;
    }
LABEL_62:
    if (!*a4)
    {
      MalformedDocumentCFErrorRef Error = C3DSceneSourceCreateMalformedDocumentError(0);
      BOOL result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
LABEL_52:
  CFBooleanRef v45 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"doubleSided");
  if (v45) {
    char v46 = CFBooleanGetValue(v45) != 0;
  }
  else {
    char v46 = 0;
  }
  C3DMeshElementSetDoubleSided((uint64_t)a1, v46);
  C3DMeshElementConvertStripToTriangleList((uint64_t)a1);
  return 1;
}

__CFDictionary *_C3DMeshElementCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (v14)
  {
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFNumberRef v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, (const void *)(a1 + 104));
    CFDictionarySetValue(v14, @"facesCount", v16);
    CFRelease(v16);
    unint64_t v17 = *(char *)(a1 + 88);
    if (v17 > 4) {
      uint64_t v18 = 0;
    }
    else {
      uint64_t v18 = off_264004C50[v17];
    }
    CFDictionarySetValue(v14, @"geometryElement", v18);
    int valuePtr = *(unsigned __int8 *)(a1 + 80);
    CFNumberRef v19 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(v14, @"bytesPerIndex", v19);
    CFRelease(v19);
    CFDataRef v20 = *(const __CFData **)(a1 + 96);
    int v21 = *(unsigned __int8 *)(a1 + 80);
    uint64_t v22 = 7;
    if (v21 != 1) {
      uint64_t v22 = 9;
    }
    if (v21 == 2) {
      uint64_t v23 = 8;
    }
    else {
      uint64_t v23 = v22;
    }
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    CFDataRef v25 = C3DCopyHostToLittleEndianRepresentationOfData(v20, v23, Length / *(unsigned __int8 *)(a1 + 80));
    if (v25)
    {
      CFDataRef v26 = v25;
      CFDictionarySetValue(v14, @"indexes", v25);
      CFRelease(v26);
    }
    char v27 = (const void **)MEMORY[0x263EFFB40];
    if (!*(unsigned char *)(a1 + 81)) {
      char v27 = (const void **)MEMORY[0x263EFFB38];
    }
    CFDictionarySetValue(v14, @"doubleSided", *v27);
  }
  return v14;
}

uint64_t _C3DMeshElementFinalizeDeserialization()
{
  return 1;
}

__CFArray *_C3DMeshElementCopyInstanceVariables(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  unint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 96);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v5, @"name", @"indexes");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 104;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v9, @"name", @"subElementsCount");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = v4;
  uint64_t v14 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 88;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v14, @"name", @"type");
  CFDictionarySetValue(v14, @"type", v15);
  CFDictionarySetValue(v14, @"address", v17);
  CFDictionarySetValue(v14, @"semantic", v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  uint64_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFNumberRef v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 80;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v19, @"name", @"bytesPerIndex");
  CFDictionarySetValue(v19, @"type", v20);
  CFDictionarySetValue(v19, @"address", v22);
  CFDictionarySetValue(v19, @"semantic", v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  uint64_t v23 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 3;
  uint64_t v40 = a1 + 81;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v23, @"name", @"doubleSided");
  CFDictionarySetValue(v23, @"type", v24);
  CFDictionarySetValue(v23, @"address", v26);
  CFDictionarySetValue(v23, @"semantic", v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  char v27 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x263EFFF90]);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 168);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v27, @"name", @"primitiveNormals");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  CFTypeID v31 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 9;
  uint64_t v40 = a1 + 176;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v31, @"name", @"bbox[0]");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  CFDataRef v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 9;
  uint64_t v40 = a1 + 192;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v35, @"name", @"bbox[1]");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

void OUTLINED_FUNCTION_3_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void C3DMaterialSetTextureSampler(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    CFNumberRef v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t CommonProfile = C3DMaterialGetCommonProfile(a1);
  C3DEffectCommonProfileSetTextureSampler(CommonProfile, a2, a3);
}

__n128 C3DTransformBoundingSphere(float32x4_t *a1, float32x4_t *a2, __n128 *a3, __n128 a4)
{
  if (!a1 && (uint64_t v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    C3DTransformBoundingSphere_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  CFNumberRef v15 = scn_default_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
    C3DTransformBoundingSphere_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
  }
LABEL_6:
  float32x4_t v23 = *a1;
  float32x4_t v24 = a2[1];
  v30[0] = *a2;
  v30[1] = v24;
  float32x4_t v25 = a2[3];
  v30[2] = a2[2];
  void v30[3] = v25;
  result.n128_f64[0] = C3DVector3MultMatrix4x4(v30, v23);
  result.n128_u32[3] = a3->n128_u32[3];
  *a3 = result;
  float32x2_t v27 = vabs_f32((float32x2_t)a4.n128_u64[0]);
  if (v27.f32[0] < v27.f32[1]) {
    v27.f32[0] = v27.f32[1];
  }
  float v28 = fabsf(a4.n128_f32[2]);
  if (v27.f32[0] < v28) {
    v27.f32[0] = v28;
  }
  result.n128_f32[3] = v27.f32[0] * a1->f32[3];
  *a3 = result;
  return result;
}

uint64_t C3DMeshElementConvertStripToTriangleList(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DMeshElementGetType(a1) == 1)
  {
    int v26 = 0;
    uint64_t Indexes = C3DMeshElementGetIndexes(a1, &v26);
    if (v26 == 2)
    {
      CFDataRef v11 = (const __CFData *)Indexes;
      CFMutableArrayRef Mutable = CFDataCreateMutable(0, 0);
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount(a1);
      uint64_t v14 = (UInt8 *)C3DMalloc(6 * PrimitiveCount);
      BytePtr = CFDataGetBytePtr(v11);
      if (PrimitiveCount < 1)
      {
        int v17 = 0;
      }
      else
      {
        uint64_t v16 = 0;
        int v17 = 0;
        uint64_t v18 = BytePtr + 4;
        uint64_t v19 = v14;
        do
        {
          uint64_t v20 = v18 - 2;
          int v21 = (unsigned __int16)*(v18 - 2);
          int v22 = (unsigned __int16)*(v18 - 1);
          if (v21 != v22)
          {
            int v23 = (unsigned __int16)*v18;
            if (v22 != v23 && v21 != v23)
            {
              if (v16) {
                LOWORD(v21) = *v18;
              }
              else {
                uint64_t v20 = v18;
              }
              *(_WORD *)uint64_t v19 = v21;
              *((_WORD *)v19 + 1) = *(v18 - 1);
              *((_WORD *)v19 + 2) = *v20;
              ++v17;
              v19 += 6;
            }
          }
          ++v16;
          ++v18;
        }
        while (PrimitiveCount != v16);
      }
      CFDataAppendBytes(Mutable, v14, 6 * PrimitiveCount);
      C3DMeshElementInit(a1, 0, v17, Mutable, 2);
      CFRelease(Mutable);
      if (v14) {
        free(v14);
      }
    }
  }
  return 1;
}

void __MakeNormalMatrix(__n128 *a1, _OWORD *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __MakeNormalMatrix_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    __MakeNormalMatrix_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  C3DMatrix4x4ComputeNormalMatrix(a1, a2);
}

void __DestroyMaterialMeshElementCouple(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
    uint64_t v3 = a1[1];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

CFComparisonResult __CompareMaterials(uint64_t *a1, uint64_t *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __CompareMaterials_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    __CompareMaterials_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  if (C3DMaterialGetName(*a1)) {
    CFStringRef Name = (const __CFString *)C3DMaterialGetName(*a1);
  }
  else {
    CFStringRef Name = &stru_26BF72F58;
  }
  if (C3DMaterialGetName(*a2)) {
    CFStringRef v21 = (const __CFString *)C3DMaterialGetName(*a2);
  }
  else {
    CFStringRef v21 = &stru_26BF72F58;
  }
  CFComparisonResult result = CFStringCompare(Name, v21, 0);
  if (result) {
    return result;
  }
  uint64_t v23 = a1[1];
  uint64_t v24 = a2[1];
  if (!v23)
  {
    PrimitiveCFIndex Count = 0;
    if (v24) {
      goto LABEL_15;
    }
LABEL_17:
    uint64_t v26 = 0;
    goto LABEL_18;
  }
  PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount(v23);
  if (!v24) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v26 = C3DMeshElementGetPrimitiveCount(v24);
LABEL_18:
  uint64_t v27 = -1;
  if (PrimitiveCount >= v26) {
    uint64_t v27 = 1;
  }
  if (PrimitiveCount == v26) {
    return 0;
  }
  else {
    return v27;
  }
}

void __ReorderRendererElements(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
  uint64_t Mesh = C3DGeometryGetMesh(a1);
  MaterialsCFIndex Count = (CFIndex)C3DGeometryGetMaterialsCount(a1);
  if (MaterialsCount >= 1)
  {
    CFIndex v5 = MaterialsCount;
    if (C3DMeshGetElementsCount(Mesh) == (const __CFArray *)MaterialsCount)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        uint64_t v7 = C3DMalloc(0x10uLL);
        void *v7 = 0;
        v7[1] = 0;
        CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
        if (MaterialAtIndex) {
          CFArrayRef MaterialAtIndex = CFRetain(MaterialAtIndex);
        }
        void *v7 = MaterialAtIndex;
        if ((uint64_t)C3DMeshGetElementsCount(Mesh) >= 1)
        {
          uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(Mesh, i, 0);
          if (ElementAtIndex) {
            uint64_t ElementAtIndex = CFRetain(ElementAtIndex);
          }
          v7[1] = ElementAtIndex;
        }
        CFArrayAppendValue(Mutable, v7);
      }
      if (v5 >= 2)
      {
        v13.locatiouint64_t n = 0;
        v13.CFIndex length = v5;
        CFArraySortValues(Mutable, v13, (CFComparatorFunction)__CompareMaterials, 0);
      }
      C3DGeometryRemoveAllMaterials(a1);
      C3DMeshRemoveAllElements(Mesh);
      for (CFIndex j = 0; j != v5; ++j)
      {
        CFStringRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Mutable, j);
        C3DMeshAppendElement(Mesh, ValueAtIndex[1]);
        C3DGeometryAppendMaterial(a1, (void *)*ValueAtIndex);
        __DestroyMaterialMeshElementCouple(ValueAtIndex);
      }
    }
  }

  CFRelease(Mutable);
}

uint64_t _C3DCreateFlattenedGeometryFromNodeHierarchy(float32x4_t *a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)((char *)&v96[2] + 4) = *MEMORY[0x263EF8340];
  uint64_t v92 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v79 = 0u;
  memset(v73, 0, sizeof(v73));
  C3DNodeGetLocalNoPivotMatrix((uint64_t)a1, (uint64_t)v73);
  uint64_t Identity = C3DMatrix4x4GetIdentity();
  C3DNodeSetMatrix(a1, Identity);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  BOOL HasPivot = C3DNodeGetHasPivot((uint64_t)a1);
  if (HasPivot)
  {
    PivotMatrix = (long long *)C3DNodeGetPivotMatrix((uint64_t)a1);
    long long v8 = PivotMatrix[3];
    long long v10 = *PivotMatrix;
    long long v9 = PivotMatrix[1];
    long long v71 = PivotMatrix[2];
    long long v72 = v8;
    long long v69 = v10;
    long long v70 = v9;
    uint64_t v11 = (long long *)C3DMatrix4x4GetIdentity();
    C3DNodeSetPivotMatrix(a1, v11);
  }
  int64x2_t v76 = vdupq_n_s64(3uLL);
  long long v77 = xmmword_20B5CB7C0;
  *(void *)&long long v81 = 0;
  memset(v74, 0, sizeof(v74));
  uint64_t v78 = 4;
  uint64_t v75 = 0;
  BYTE8(v81) = a4;
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  CFArrayRef v14 = CFArrayCreateMutable(v12, 0, 0);
  CFMutableArrayRef v15 = CFArrayCreateMutable(v12, 0, MEMORY[0x263EFFF70]);
  CFAllocatorRef bytesDeallocator = v12;
  CFMutableDictionaryRef v16 = CFDictionaryCreateMutable(v12, 0, 0, 0);
  uint64_t context = (uint64_t)Mutable;
  CFArrayRef v90 = v14;
  uint64_t v91 = v74;
  CFMutableArrayRef v59 = v15;
  CFMutableArrayRef v93 = v15;
  CFMutableDictionaryRef v94 = v16;
  v82[0] = 0;
  v82[1] = (uint64_t (*)(uint64_t, uint64_t))__CreateAndDispatchRendererElements;
  v82[2] = 0;
  uint64_t v63 = a1;
  C3DNodeIterateTree((uint64_t)a1, v82, 0, (uint64_t)&context);
  uint64_t v17 = C3DGeometryCreate();
  uint64_t v18 = (uint64_t *)C3DMeshCreate();
  C3DGeometrySetMesh(v17, v18);
  CFRelease(v18);
  uint64_t v60 = v17;
  CFDictionaryRef cf = Mutable;
  uint64_t context = v17;
  CFArrayRef v90 = (const __CFArray *)v74;
  CFMutableDictionaryRef v58 = v16;
  uint64_t v91 = v16;
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__MergeRendererElements, &context);
  CFIndex Count = CFArrayGetCount(v14);
  if (Count >= 1)
  {
    CFIndex v20 = 0;
    do
    {
      while (1)
      {
        uint64_t v21 = *((void *)CFArrayGetValueAtIndex(v14, v20) + 1);
        v88[0] = MEMORY[0x263EF8330];
        v88[1] = 3221225472;
        v88[2] = ____MergeMeshSources_block_invoke;
        v88[3] = &__block_descriptor_40_e201_v32__0____C3DMeshSource____C3DGenericSource____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DSourceAccessor________CFData__v_v_qb1b1b1_SCC_8c16q20C28l;
        uint8_t v88[4] = v74;
        C3DMeshApplySources(v21, 1, (uint64_t)v88);
        if ((void)v77 == 4) {
          break;
        }
        if (++v20 >= Count) {
          goto LABEL_12;
        }
      }
      ++v20;
    }
    while (v76.i64[0] != 4 && v20 < Count);
  }
LABEL_12:
  CFIndex v64 = Count;
  CFArrayRef v65 = v14;
  uint64_t v23 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v67 = _Q0;
  do
  {
    if (*((uint64_t *)v74 + v23) >= 1)
    {
      uint64_t v29 = 0;
      CFNumberRef v30 = &v76.i64[v23];
      do
      {
        uint64_t v31 = v81;
        uint64_t v32 = *v30;
        if (!*v30)
        {
          CFNumberRef v33 = scn_default_log();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
            _C3DCreateFlattenedGeometryFromNodeHierarchy_cold_1(v95, v96, v33);
          }
        }
        if (v31 <= (0x7FFFFFFF / v32) && v31 * v32 <= 0x1FFFFFFF)
        {
          CFDataRef v35 = (const UInt8 *)malloc_type_calloc(4 * v31 * v32, 1uLL, 0xF6541223uLL);
          CFDataRef v36 = CFDataCreateWithBytesNoCopy(bytesDeallocator, v35, 4 * v31 * v32, bytesDeallocator);
          CFNumberRef v37 = (const void *)C3DMeshSourceCreate(v36, (char)v23, v31, v32, 1);
          CFRelease(v36);
          if (v37)
          {
            if (v23 == 2)
            {
              uint64_t v38 = C3DMeshSourceGetCount((uint64_t)v37);
              if (v38 >= 1)
              {
                uint64_t v39 = v38;
                for (uint64_t i = 0; i != v39; ++i)
                  C3DMeshSourceSetValueAtIndexAsVector4((uint64_t)v37, i, v67);
              }
            }
            C3DMeshAddSource((uint64_t)v18, v37, 0, 0);
            CFRelease(v37);
          }
        }
        ++v29;
      }
      while (v29 < *((void *)v74 + v23));
    }
    ++v23;
  }
  while (v23 != 9);
  CFArrayRef v41 = v14;
  if (Count >= 1)
  {
    CFIndex v42 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v41, v42);
      uint64_t v46 = *((void *)ValueAtIndex + 1);
      int v47 = (float32x4_t *)*((void *)ValueAtIndex + 3);
      memset(v87, 0, sizeof(v87));
      CFIndex v68 = v42;
      if (v47) {
        C3DNodeComputeWorldMatrix(v47, (uint64_t)v87);
      }
      else {
        C3DMatrix4x4MakeIdentity((uint64_t)v87);
      }
      for (uint64_t j = 0; j != 9; ++j)
      {
        if (*((uint64_t *)v74 + j) >= 1)
        {
          uint64_t v49 = 0;
          uint64_t v50 = v43;
          while (1)
          {
            SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v18, (char)j, v49, 0);
            CFNumberRef v52 = C3DMeshGetSourceWithSemanticAtIndex(v46, (char)j, v49, 1);
            if (!v52) {
              goto LABEL_47;
            }
            uint64_t v43 = (uint64_t)v52;
            if ((unint64_t)(j - 2) < 3) {
              break;
            }
            if (j == 1)
            {
              long long v85 = 0u;
              long long v86 = 0u;
              *(_OWORD *)float32x4_t buf = 0u;
              long long v84 = 0u;
              C3DMatrix4x4ComputeNormalMatrix((__n128 *)v87, buf);
              int v55 = (float32x4_t *)buf;
              uint64_t v53 = (uint64_t)SourceWithSemanticAtIndex;
              uint64_t v54 = v43;
              goto LABEL_46;
            }
            if (j)
            {
              uint64_t v56 = scn_default_log();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)float32x4_t buf = 0;
                _os_log_impl(&dword_20B249000, v56, OS_LOG_TYPE_DEFAULT, "Warning: __MergeMeshSources unknown source type\n", buf, 2u);
              }
              goto LABEL_47;
            }
            __TransformAndAppendMeshSource((uint64_t)SourceWithSemanticAtIndex, (uint64_t)v52, v87, v44);
LABEL_48:
            ++v49;
            uint64_t v50 = v43;
            if (v49 >= *((void *)v74 + j)) {
              goto LABEL_52;
            }
          }
          uint64_t v53 = (uint64_t)SourceWithSemanticAtIndex;
          uint64_t v54 = v43;
          int v55 = 0;
LABEL_46:
          __TransformAndAppendMeshSource(v53, v54, v55, v44);
LABEL_47:
          uint64_t v43 = v50;
          goto LABEL_48;
        }
LABEL_52:
        ;
      }
      if (v43) {
        v44 += C3DMeshSourceGetCount(v43);
      }
      CFArrayRef v41 = v65;
      CFIndex v42 = v68 + 1;
    }
    while (v68 + 1 != v64);
  }
  __ReorderRendererElements(v60);
  CFRelease(cf);
  __DestroyFlattenElementsArray(v41);
  CFRelease(v59);
  CFRelease(v58);
  CFRelease(v41);
  C3DNodeSetMatrix(v63, (uint64_t)v73);
  if (HasPivot) {
    C3DNodeSetPivotMatrix(v63, &v69);
  }
  return v60;
}

uint64_t __CreateAndDispatchRendererElements(const void *a1, uint64_t a2)
{
  *(void *)&v53[5] = *MEMORY[0x263EF8340];
  CFDictionaryRef v4 = *(const __CFDictionary **)a2;
  CFIndex v5 = *(__CFArray **)(a2 + 32);
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a1);
  if (Geometry)
  {
    uint64_t v7 = Geometry;
    if ((C3DNodeIsGizmo((uint64_t)a1) & 1) == 0)
    {
      long long v8 = *(__CFArray **)(a2 + 8);
      uint64_t Mesh = C3DGeometryGetMesh(v7);
      if (Mesh)
      {
        if (C3DMeshGetPositionSource(Mesh, 1))
        {
          if (!a1)
          {
            long long v9 = scn_default_log();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
              C3DGeometryTrackNode_cold_2(v9, v10, v11, v12, v13, v14, v15, v16);
            }
          }
          uint64_t v17 = C3DNodeGetGeometry((uint64_t)a1);
          if (v17)
          {
            uint64_t v18 = v17;
            uint64_t v19 = C3DGeometryGetMesh(v17);
            if (v19)
            {
              uint64_t v20 = v19;
              ElementsCFIndex Count = C3DMeshGetElementsCount(v19);
              if (ElementsCount)
              {
                uint64_t v22 = (uint64_t)ElementsCount;
                CFArrayRef theArray = v8;
                CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
                CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], (CFIndex)ElementsCount, 0);
                if (v22 >= 1)
                {
                  for (CFIndex i = 0; i != v22; ++i)
                  {
                    float32x4_t v25 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    v25[1] = v20;
                    void *v25 = C3DMeshGetElementAtIndex(v20, i, 1);
                    v25[2] = C3DGeometryGetMaterialAtIndex(v18, i);
                    void v25[3] = a1;
                    CFArrayAppendValue(Mutable, v25);
                  }
                }
                if (Mutable)
                {
                  CFIndex Count = CFArrayGetCount(Mutable);
                  CFArrayAppendValue(v5, a1);
                  if (Count >= 1)
                  {
                    CFIndex v27 = 0;
                    uint64_t v28 = *(void *)(a2 + 16);
                    uint64_t v29 = *(__CFDictionary **)(a2 + 40);
                    CFNumberRef v30 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
                    do
                    {
                      CFStringRef ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(Mutable, v27);
                      if (!ValueAtIndex)
                      {
                        uint64_t v32 = scn_default_log();
                        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
                          __CreateAndDispatchRendererElements_cold_1(v52, v53, v32);
                        }
                      }
                      C3DNodeGetWorldAlpha(ValueAtIndex[3]);
                      uint64_t v35 = 0;
                      if (v33 >= 1.0)
                      {
                        uint64_t v34 = ValueAtIndex[2];
                        if (!v34 || C3DMaterialIsOpaque(v34)) {
                          uint64_t v35 = 1;
                        }
                      }
                      uint64_t v36 = ValueAtIndex[2];
                      if (v36 && C3DMaterialIsDoubleSided(v36)) {
                        v35 |= 2uLL;
                      }
                      int Type = C3DMeshElementGetType(*ValueAtIndex);
                      if (Type == 2)
                      {
                        uint64_t v39 = (const void *)(v35 | 0x10);
                      }
                      else
                      {
                        uint64_t v38 = v35 | 4;
                        if (Type) {
                          uint64_t v38 = v35;
                        }
                        if (Type == 1) {
                          uint64_t v39 = (const void *)(v35 | 8);
                        }
                        else {
                          uint64_t v39 = (const void *)v38;
                        }
                      }
                      CFNumberRef Value = (void *)CFDictionaryGetValue(v4, v39);
                      if (!Value)
                      {
                        CFNumberRef Value = CFDictionaryCreateMutable(allocator, 0, 0, v30);
                        CFDictionarySetValue(v4, v39, Value);
                        CFRelease(Value);
                      }
                      CFDictionarySetValue(v29, ValueAtIndex, *(const void **)(v28 + 144));
                      CFArrayRef v41 = (void *)CFDictionaryGetValue((CFDictionaryRef)Value, (const void *)ValueAtIndex[2]);
                      if (!v41)
                      {
                        CFArrayRef v41 = CFArrayCreateMutable(allocator, 0, 0);
                        CFDictionarySetValue((CFMutableDictionaryRef)Value, (const void *)ValueAtIndex[2], v41);
                        CFRelease(v41);
                      }
                      CFArrayAppendValue((CFMutableArrayRef)v41, ValueAtIndex);
                      ++v27;
                    }
                    while (Count != v27);
                    PositionSource = C3DMeshGetPositionSource(Mesh, 1);
                    if (PositionSource)
                    {
                      uint64_t v43 = 0;
                      *(void *)(v28 + 144) += C3DMeshSourceGetCount((uint64_t)PositionSource);
                      do
                      {
                        SourcesCountForSemantiCC_SHA256_CTX c = C3DMeshGetSourcesCountForSemantic(Mesh, (char)v43);
                        if (SourcesCountForSemantic > *(void *)(v28 + 8 * v43)) {
                          *(void *)(v28 + 8 * v43) = SourcesCountForSemantic;
                        }
                        ++v43;
                      }
                      while (v43 != 9);
                    }
                    CFBooleanRef v45 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    uint64_t v46 = CFArrayGetValueAtIndex(Mutable, 0);
                    long long v47 = v46[1];
                    *CFBooleanRef v45 = *v46;
                    v45[1] = v47;
                    CFArrayAppendValue(theArray, v45);
                  }
                  CFRelease(Mutable);
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

void __MergeRendererElements(char a1, CFDictionaryRef theDict, uint64_t *a3)
{
  uint64_t v3 = a3[1];
  uint64_t context = *a3;
  uint64_t v6 = 0;
  if (*(uint64_t *)(v3 + 144) < 0x10000) {
    int v4 = 2;
  }
  else {
    int v4 = 4;
  }
  HIDWORD(v6) = v4;
  LOBYTE(v6) = a1 & 1 | (*(unsigned char *)(v3 + 152) != 0);
  uint64_t v7 = a3[2];
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__MergeRendererElementsSharingSameMaterial, &context);
}

void __DestroyFlattenElementsArray(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      free(ValueAtIndex);
    }
  }

  CFArrayRemoveAllValues(a1);
}

float32x4_t *C3DSplitMeshIfNeeded(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    CFIndex v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  uint64_t Geometry = C3DNodeGetGeometry(a1);
  if (!Geometry) {
    return 0;
  }
  if (C3DNodeGetSkinner(a1)) {
    return 0;
  }
  if (C3DNodeGetMorpher(a1)) {
    return 0;
  }
  uint64_t Mesh = C3DGeometryGetMesh(Geometry);
  if (!Mesh) {
    return 0;
  }
  uint64_t v14 = Mesh;
  PositionSource = C3DMeshGetPositionSource(Mesh, 1);
  uint64_t v16 = PositionSource ? C3DMeshSourceGetCount((uint64_t)PositionSource) : 0;
  if (v16 <= a2) {
    return 0;
  }
  uint64_t v11 = (float32x4_t *)C3DNodeCreate();
  uint64_t Name = C3DNodeGetName(a1);
  if (Name)
  {
    CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"%@-splitContainer", Name);
    C3DNodeSetName((uint64_t)v11, v18);
    CFRelease(v18);
  }
  else
  {
    C3DNodeSetName((uint64_t)v11, @"splitContainer");
  }
  uint64_t v45 = a1;
  C3DNodeAddChildNode(a1, v11);
  CFRelease(v11);
  size_t v19 = 8 * v16;
  uint64_t v57 = (uint64_t *)malloc_type_malloc(v19, 0x100004000313F17uLL);
  size_t v54 = v19;
  uint64_t v20 = malloc_type_malloc(v19, 0x100004000313F17uLL);
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(Geometry);
  ElementsCFIndex Count = C3DMeshGetElementsCount(v14);
  uint64_t v22 = a2;
  if ((uint64_t)ElementsCount >= 1)
  {
    uint64_t v23 = 0;
    CFIndex v24 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v59 = 0;
    uint64_t v52 = (uint64_t)v11;
    uint64_t v53 = v14;
    CFArrayRef v55 = MaterialsCount;
    do
    {
      uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v14, v24, 1);
      uint64_t v58 = v23 + 1;
      _createSubNodeForSplittedMesh((uint64_t)v11, v23, &v61, &v59, &v60);
      uint64_t v26 = v59;
      int Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
      if (Type == 3) {
        char v28 = 3;
      }
      else {
        char v28 = 2 * (Type == 2);
      }
      C3DMeshElementSetType(v26, v28);
      char DoubleSided = C3DMeshElementGetDoubleSided((uint64_t)ElementAtIndex);
      C3DMeshElementSetDoubleSided(v26, DoubleSided);
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      uint64_t IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive((uint64_t)ElementAtIndex);
      bzero(v20, v54);
      uint64_t v48 = v24 / (uint64_t)MaterialsCount;
      CFIndex v49 = v24;
      if (PrimitiveCount < 1)
      {
        uint64_t v34 = 0;
        uint64_t v36 = 0;
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        uint64_t v51 = IndexCountPerPrimitive - 1;
        uint64_t v47 = PrimitiveCount;
        do
        {
          if (IndexCountPerPrimitive < 1)
          {
            uint64_t v36 = v32;
          }
          else
          {
            uint64_t v35 = 0;
            uint64_t v36 = v32;
            do
            {
              uint64_t Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v33, v35, 0);
              if (!*((void *)v20 + Index))
              {
                v57[v36++] = Index;
                *((void *)v20 + Index) = v36;
                if (v36 == v22)
                {
                  if (v35 == v51) {
                    uint64_t v32 = v22;
                  }
                  v33 -= v35 != v51;
                  _finalizeSplit(v34, (const __CFAllocator *)(v33 + 1), (uint64_t)v20, v57, v32, (uint64_t)ElementAtIndex, v26, (uint64_t)v61, v53);
                  if (v55)
                  {
                    CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(Geometry, v49 - v48 * (void)v55);
                    C3DGeometryInsertMaterialAtIndex((uint64_t)v60, MaterialAtIndex, 0);
                  }
                  _createSubNodeForSplittedMesh(v52, v58, &v61, &v59, &v60);
                  uint64_t v26 = v59;
                  int v39 = C3DMeshElementGetType((uint64_t)ElementAtIndex);
                  if (v39 == 3) {
                    char v40 = 3;
                  }
                  else {
                    char v40 = 2 * (v39 == 2);
                  }
                  C3DMeshElementSetType(v26, v40);
                  char v41 = C3DMeshElementGetDoubleSided((uint64_t)ElementAtIndex);
                  C3DMeshElementSetDoubleSided(v26, v41);
                  bzero(v20, v54);
                  uint64_t v36 = 0;
                  uint64_t v34 = v33 + 1;
                  uint64_t v35 = IndexCountPerPrimitive;
                  ++v58;
                  uint64_t v22 = a2;
                }
              }
              ++v35;
            }
            while (v35 < IndexCountPerPrimitive);
          }
          ++v33;
          uint64_t v32 = v36;
          PrimitiveCFIndex Count = v47;
        }
        while (v33 < v47);
      }
      BOOL v42 = v34 < PrimitiveCount;
      CFAllocatorRef v43 = (const __CFAllocator *)PrimitiveCount;
      uint64_t v14 = v53;
      if (v42)
      {
        _finalizeSplit(v34, v43, (uint64_t)v20, v57, v36, (uint64_t)ElementAtIndex, v26, (uint64_t)v61, v53);
        if (v55)
        {
          CFArrayRef v44 = C3DGeometryGetMaterialAtIndex(Geometry, v49 - v48 * (void)v55);
          C3DGeometryInsertMaterialAtIndex((uint64_t)v60, v44, 0);
        }
      }
      CFIndex v24 = v49 + 1;
      uint64_t v11 = (float32x4_t *)v52;
      MaterialsCFIndex Count = v55;
      uint64_t v23 = v58;
    }
    while ((const __CFArray *)(v49 + 1) != ElementsCount);
  }
  free(v20);
  free(v57);
  C3DNodeSetGeometry(v45, 0);
  return v11;
}

void _createSubNodeForSplittedMesh(uint64_t a1, uint64_t a2, uint64_t **a3, void *a4, __C3DGeometry **a5)
{
  uint64_t v10 = (float32x4_t *)C3DNodeCreate();
  C3DNodeAddChildNode(a1, v10);
  uint64_t Name = C3DNodeGetName(a1);
  if (Name)
  {
    CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"%@-split%d", Name, a2);
    C3DNodeSetName((uint64_t)v10, v12);
    CFRelease(v12);
  }
  uint64_t v13 = (__C3DGeometry *)C3DGeometryCreate();
  uint64_t v14 = (uint64_t *)C3DMeshCreate();
  C3DNodeSetGeometry((uint64_t)v10, v13);
  C3DGeometrySetMesh((uint64_t)v13, v14);
  uint64_t v15 = (const void *)C3DMeshElementCreate();
  C3DMeshAppendElement((uint64_t)v14, v15);
  CFRelease(v15);
  CFRelease(v14);
  CFRelease(v13);
  CFRelease(v10);
  *a4 = v15;
  *a3 = v14;
  *a5 = v13;
}

void _finalizeSplit(uint64_t a1, const __CFAllocator *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = a1;
  *(void *)&v72[5] = *MEMORY[0x263EF8340];
  uint64_t v14 = (char *)a2 - a1;
  BOOL v15 = a5 > 255;
  if (a5 <= 255) {
    unsigned int v16 = 1;
  }
  else {
    unsigned int v16 = 2;
  }
  uint64_t IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive(a6);
  uint64_t v18 = IndexCountPerPrimitive;
  uint64_t v66 = a5;
  BOOL v19 = a5 < 0x10000;
  if (a5 < 0x10000) {
    uint64_t v20 = v16;
  }
  else {
    uint64_t v20 = 4;
  }
  char v21 = 2;
  if (v19) {
    char v21 = v15;
  }
  CFIndex length = (IndexCountPerPrimitive << v21) * (void)v14;
  bytes = (UInt8 *)malloc_type_malloc(length, 0x6FA693C6uLL);
  CFAllocatorRef bytesDeallocator = a2;
  CFArrayRef v55 = (char *)a2 - v13;
  CFArrayRef v22 = 0;
  if ((uint64_t)a2 > v13)
  {
    do
    {
      if (v18 >= 1)
      {
        uint64_t v23 = 0;
        float32x4_t v67 = &bytes[2 * (void)v22];
        CFIndex v24 = (UInt8 *)v22 + (void)bytes;
        CFArrayRef theArray = v22;
        float32x4_t v25 = &bytes[4 * (void)v22];
        do
        {
          uint64_t Index = C3DMeshElementGetIndex(a6, v13, v23, 0);
          if (!*(void *)(a3 + 8 * Index))
          {
            CFIndex v27 = scn_default_log();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
              _finalizeSplit_cold_3(v69, &v70, v27);
            }
          }
          int v28 = *(_DWORD *)(a3 + 8 * Index) - 1;
          if (v20 == 2)
          {
            *(_WORD *)&v67[2 * v23] = v28;
          }
          else if (v20 == 1)
          {
            v24[v23] = v28;
          }
          else
          {
            *(_DWORD *)&v25[4 * v23] = v28;
          }
          ++v23;
        }
        while (v18 != v23);
        CFArrayRef v22 = (CFArrayRef)((char *)theArray + v23);
      }
      ++v13;
    }
    while ((CFAllocatorRef)v13 != bytesDeallocator);
  }
  if (v22 != (const __CFArray *)(v18 * (void)v55))
  {
    uint64_t v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      _finalizeSplit_cold_2(v29, v30, v31, v32, v33, v34, v35, v36);
    }
  }
  bytesDeallocatorSCNMatrix4 a = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDataRef v37 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  C3DMeshElementSetPrimitives(a7, (int)v55, v37, v20);
  CFRelease(v37);
  theArraySCNMatrix4 a = C3DMeshCopyAllSources(a9, 1);
  bytesSCNMatrix4 a = CFArrayGetCount(theArraya);
  uint64_t v38 = v66;
  if (bytesa >= 1)
  {
    for (CFIndex i = 0; i != bytesa; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArraya, i);
      ComponentsCountPerCFNumberRef Value = C3DMeshSourceGetComponentsCountPerValue((uint64_t)ValueAtIndex);
      Valueint Type = C3DMeshSourceGetValueType((uint64_t)ValueAtIndex);
      uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(ValueAtIndex);
      uint64_t v68 = ComponentsCountPerValue;
      size_t v44 = C3DSizeOfBaseType(ValueType) * ComponentsCountPerValue;
      CFIndex v45 = v44 * v38;
      uint64_t v46 = (const UInt8 *)malloc_type_malloc(v44 * v38, 0x84E99E34uLL);
      if (v38 < 1)
      {
        uint64_t v47 = 0;
      }
      else
      {
        uint64_t v47 = 0;
        uint64_t v48 = a4;
        do
        {
          uint64_t v49 = *v48++;
          ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(Accessor, v49);
          memcpy((void *)&v46[v47], ValuePtrAtIndex, v44);
          v47 += v44;
          --v38;
        }
        while (v38);
      }
      if (v47 != v45)
      {
        uint64_t v51 = scn_default_log();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT)) {
          _finalizeSplit_cold_1(v71, v72, v51);
        }
      }
      CFDataRef v52 = CFDataCreateWithBytesNoCopy(0, v46, v45, bytesDeallocatora);
      SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      uint64_t v38 = v66;
      size_t v54 = (const void *)C3DMeshSourceCreate(v52, Semantic, v66, v68, ValueType);
      CFRelease(v52);
      C3DMeshAddSource(a8, v54, 0, 0);
      CFRelease(v54);
    }
  }
  CFRelease(theArraya);
}

void C3DSplitMeshesIfNeededInNodeTree(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v13 = a2;
  CFTypeRef cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], 0);
  v12[0] = 0;
  v12[1] = (uint64_t (*)(uint64_t, uint64_t))_C3DSplitMeshesIfNeededInNodeTree;
  void v12[2] = 0;
  C3DNodeIterateTree(a1, v12, 1, (uint64_t)&v13);
  CFRelease(cf);
}

uint64_t _C3DSplitMeshesIfNeededInNodeTree(uint64_t a1, uint64_t *a2)
{
  uint64_t Geometry = (float32x4_t *)C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    CFDataRef Copy = Geometry;
    CFDictionaryRef v6 = (const __CFDictionary *)a2[1];
    CFNumberRef Value = CFDictionaryGetValue(v6, Geometry);
    if (Value)
    {
      CFDataRef Copy = (float32x4_t *)C3DNodeCreateCopy((uint64_t)Value, 1);
      C3DNodeAddChildNode(a1, Copy);
      C3DNodeSetGeometry(a1, 0);
    }
    else
    {
      uint64_t v8 = *a2;
      CFRetain(Copy);
      uint64_t v9 = C3DSplitMeshIfNeeded(a1, v8);
      if (v9) {
        CFDictionarySetValue(v6, Copy, v9);
      }
    }
    CFRelease(Copy);
  }
  return 0;
}

uint64_t C3DVRAMResourceGetID(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DVRAMResourceGetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

void C3DVRAMResourceSetID(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DVRAMResourceSetID_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x690], 8) = a2;
}

uint64_t C3DVRAMResourceIsAttachment(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DVRAMResourceSetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t C3DVRAMResourceLockCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t C3DVRAMResourceLock(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 56) + 1);
  *(_DWORD *)(a1 + 56) = v1;
  return v1;
}

uint64_t C3DVRAMResourceUnlock(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DVRAMResourceSetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(_DWORD *)(a1 + 56);
  if (v10)
  {
    *(_DWORD *)(a1 + 56) = v10 - 1;
  }
  else
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl(&dword_20B249000, v11, OS_LOG_TYPE_DEFAULT, "Warning: unlock not locked ressource\n", v13, 2u);
    }
  }
  return *(unsigned int *)(a1 + 56);
}

uint64_t C3DMeshCreateByMergingMeshes(const __CFArray *a1)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return 0;
  }
  uint64_t v2 = Count;
  if (Count != 1)
  {
    uint64_t v43 = C3DMeshCreate();
    CFDictionaryRef Mutable = (const void *)C3DMeshSourceCreateMutable(0, 0, 0, 3, 1);
    uint64_t v6 = (const void *)C3DMeshSourceCreateMutable(0, 1, 0, 3, 1);
    uint64_t v7 = C3DMeshSourceCreateMutable(0, 3, 0, 2, 1);
    uint64_t v8 = (const void *)v7;
    if (v2 >= 1)
    {
      CFIndex v9 = 0;
      uint64_t v10 = 0;
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      uint64_t v38 = v6;
      int v39 = Mutable;
      uint64_t v36 = (const void *)v7;
      uint64_t v37 = v2;
      while (1)
      {
        CFIndex v41 = v9;
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v9);
        SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)ValueAtIndex, 0, 0, 1);
        uint64_t v13 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)ValueAtIndex, 1, 0, 1);
        uint64_t v14 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)ValueAtIndex, 3, 0, 1);
        uint64_t v15 = C3DMeshSourceGetCount((uint64_t)SourceWithSemanticAtIndex);
        if (v15 >= 1)
        {
          for (uint64_t i = 0; i != v15; ++i)
          {
            *(_DWORD *)&bytes[8] = 0;
            *(void *)bytes = 0;
            *(double *)&long long v17 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)SourceWithSemanticAtIndex, i);
            *(_OWORD *)bytes = v17;
            C3DMeshSourceAppendVector3((uint64_t)Mutable, (uint64_t)bytes, 1);
            DWORD2(v45) = 0;
            *(void *)&long long v45 = 0;
            *(double *)&long long v18 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)v13, i);
            long long v45 = v18;
            C3DMeshSourceAppendVector3((uint64_t)v6, (uint64_t)&v45, 1);
            double ValueAtIndexAsVector2 = 0.0;
            double ValueAtIndexAsVector2 = C3DMeshSourceGetValueAtIndexAsVector2((uint64_t)v14, i);
            C3DMeshSourceAppendVector2((uint64_t)v8, (uint64_t)&ValueAtIndexAsVector2, 1);
          }
        }
        uint64_t v19 = v15 + v10;
        if ((uint64_t)C3DMeshGetElementsCount((uint64_t)ValueAtIndex) >= 1) {
          break;
        }
LABEL_46:
        CFIndex v9 = v41 + 1;
        uint64_t v10 = v19;
        uint64_t v6 = v38;
        CFDictionaryRef Mutable = v39;
        uint64_t v8 = v36;
        if (v41 + 1 == v37) {
          goto LABEL_47;
        }
      }
      CFIndex v20 = 0;
      while (1)
      {
        uint64_t ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)ValueAtIndex, v20, 1);
        int Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
        CFMutableDataRef v23 = CFDataCreateMutable(allocator, 0);
        PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
        uint64_t v25 = PrimitiveCount;
        if (v19 >= 0x10000) {
          break;
        }
        if (PrimitiveCount >= 1)
        {
          for (uint64_t j = 0; v25 != j; ++j)
          {
            if (Type == 3)
            {
              *(_WORD *)bytes = 0;
              *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
              CFIndex v27 = v23;
              CFIndex v28 = 2;
            }
            else if (Type == 2)
            {
              *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
              *(_WORD *)&bytes[2] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 1, 0) + v10;
              CFIndex v27 = v23;
              CFIndex v28 = 4;
            }
            else
            {
              if ((_BYTE)Type)
              {
                uint64_t v29 = scn_default_log();
                if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
                  C3DMeshCreateByMergingMeshes_cold_1(v48, &v49, v29);
                }
                continue;
              }
              *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
              *(_WORD *)&bytes[2] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 1, 0) + v10;
              *(_WORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 2, 0) + v10;
              CFIndex v27 = v23;
              CFIndex v28 = 6;
            }
            CFDataAppendBytes(v27, bytes, v28);
          }
        }
        char v34 = 2;
LABEL_43:
        uint64_t v35 = (const void *)C3DMeshElementCreate();
        C3DMeshElementInit((uint64_t)v35, Type, v25, v23, v34);
        C3DMeshAppendElement(v43, v35);
        if (v35) {
          CFRelease(v35);
        }
        CFRelease(v23);
        if (++v20 >= (uint64_t)C3DMeshGetElementsCount((uint64_t)ValueAtIndex)) {
          goto LABEL_46;
        }
      }
      if (PrimitiveCount < 1)
      {
LABEL_42:
        char v34 = 4;
        goto LABEL_43;
      }
      uint64_t v30 = 0;
      while (1)
      {
        if (Type == 3)
        {
          *(_DWORD *)bytes = 0;
          *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
          uint64_t v31 = v23;
          CFIndex v32 = 4;
        }
        else if (Type == 2)
        {
          *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
          *(_DWORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 1, 0) + v10;
          uint64_t v31 = v23;
          CFIndex v32 = 8;
        }
        else
        {
          if ((_BYTE)Type)
          {
            uint64_t v33 = scn_default_log();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
              C3DMeshCreateByMergingMeshes_cold_1(v46, &v47, v33);
            }
            goto LABEL_39;
          }
          *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
          *(_DWORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 1, 0) + v10;
          *(_DWORD *)&bytes[8] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 2, 0) + v10;
          uint64_t v31 = v23;
          CFIndex v32 = 12;
        }
        CFDataAppendBytes(v31, bytes, v32);
LABEL_39:
        if (v25 == ++v30) {
          goto LABEL_42;
        }
      }
    }
LABEL_47:
    C3DMeshSourceMakeImmutable(Mutable);
    C3DMeshSourceMakeImmutable(v6);
    C3DMeshSourceMakeImmutable(v8);
    C3DMeshAddSource(v43, Mutable, 0, 0);
    C3DMeshAddSource(v43, v6, 0, 0);
    C3DMeshAddSource(v43, v8, 0, 0);
    CFRelease(Mutable);
    CFRelease(v6);
    CFRelease(v8);
    return v43;
  }
  uint64_t v3 = CFArrayGetValueAtIndex(a1, 0);

  return C3DMeshCreateCopy((uint64_t)v3);
}

CFTypeRef C3DMeshSubdivide(uint64_t a1, CFIndex a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v121 = *MEMORY[0x263EF8340];
  Primitiveuint64_t Count = C3DMeshElementGetPrimitiveCount((uint64_t)a3);
  if (C3DMeshElementGetType((uint64_t)a3) == 2) {
    return 0;
  }
  int v109 = a7;
  uint64_t v106 = PrimitiveCount;
  uint64_t v102 = (uint64_t)a3;
  uint64_t v105 = (const void *)C3DMeshElementEditorCreateWithMeshElementAndCapacity(a3, 4 * PrimitiveCount);
  uint64_t Count = C3DMeshSourceGetCount(a4);
  unsigned int v16 = C3DEdgeArrayCreateFromMeshElement(a1, a2);
  uint64_t v17 = C3DEdgeArrayGetCount((uint64_t)v16);
  long long v18 = (float32x4_t *)malloc_type_malloc(16 * v17, 0x1000040451B5BE8uLL);
  if (a6)
  {
    uint64_t v19 = (float32x2_t *)malloc_type_malloc(8 * v17, 0x100004000313F17uLL);
    BOOL v20 = a5 != 0;
LABEL_7:
    if (v17 >= 1)
    {
      for (uint64_t i = 0; i != v17; ++i)
      {
        EdgeAtuint64_t Index = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, i);
        CFMutableDataRef v23 = EdgeAtIndex;
        if (v20)
        {
          *(double *)&long long v24 = C3DMeshSourceGetValueAtIndexAsVector3(a5, *EdgeAtIndex);
          *(_OWORD *)cfSCNMatrix4 b = v24;
          *(double *)v25.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v23[1]);
          *(double *)v26.i64 = C3DVector3MidVector(*(float32x4_t *)cfb, v25);
          int32x4_t v27 = (int32x4_t)vmulq_f32(v26, v26);
          v27.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
          float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
          float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28)));
          v18[i] = vmulq_n_f32(v26, vmul_f32(v29, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v29, v29))).f32[0]);
        }
        if (a6)
        {
          double ValueAtIndexAsVector2 = C3DMeshSourceGetValueAtIndexAsVector2(a6, *v23);
          v19[i] = vmul_f32(vadd_f32(*(float32x2_t *)&ValueAtIndexAsVector2, COERCE_FLOAT32X2_T(C3DMeshSourceGetValueAtIndexAsVector2(a6, v23[1]))), (float32x2_t)0x3F0000003F000000);
        }
      }
    }
    if (v20) {
      C3DMeshSourceAppendVector3(a5, (uint64_t)v18, v17);
    }
    if (a6) {
      C3DMeshSourceAppendVector2(a6, (uint64_t)v19, v17);
    }
    if (v19) {
      free(v19);
    }
    goto LABEL_20;
  }
  BOOL v20 = a5 != 0;
  if (a5)
  {
    uint64_t v19 = 0;
    goto LABEL_7;
  }
LABEL_20:
  if (v17 >= 1)
  {
    for (uint64_t j = 0; j != v17; ++j)
    {
      CFIndex v32 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, j);
      *(double *)&long long v33 = C3DMeshSourceGetValueAtIndexAsVector3(a4, *v32);
      *(_OWORD *)cfCC_SHA256_CTX c = v33;
      *(double *)v34.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, v32[1]);
      *(double *)v35.i64 = C3DVector3MidVector(*(float32x4_t *)cfc, v34);
      v18[j] = v35;
    }
    if ((v20 & v109) == 1)
    {
      uint64_t v36 = 0;
      long long v103 = v18;
      do
      {
        uint64_t v37 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v36);
        uint64_t v38 = *v37;
        uint64_t v39 = v37[1];
        *(double *)v40.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, *v37);
        float32x4_t v104 = v40;
        v120[0] = v40;
        *(double *)v41.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, v39);
        float32x4_t v110 = v41;
        v120[1] = v41;
        *(double *)&long long v42 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v38);
        v119[0] = v42;
        *(double *)&long long v43 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v39);
        v119[1] = v43;
        float32x4_t v108 = v18[v36];
        uint64_t v44 = a5;
        *(double *)v45.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v36 + Count);
        float32x4_t v46 = v45;
        uint64_t v47 = 0;
        float32x4_t v48 = vsubq_f32(v104, v108);
        float32x4_t v49 = vmulq_f32(v48, v48);
        float32x4_t v50 = vsubq_f32(v110, v108);
        float32x4_t v51 = vmulq_f32(v50, v50);
        v118[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0]);
        v118[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]);
        float32x4_t v52 = 0uLL;
        char v53 = 1;
        *(float32x4_t *)CFTypeRef cf = v46;
        do
        {
          float32x4_t v111 = v52;
          char v54 = v53;
          float32x4_t v55 = vsubq_f32((float32x4_t)v120[v47], v108);
          int32x4_t v56 = (int32x4_t)vmulq_f32(v55, v55);
          v56.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v56, 2), vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v56.i8, 1))).u32[0];
          float32x2_t v57 = vrsqrte_f32((float32x2_t)v56.u32[0]);
          float32x2_t v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v57, v57)));
          float v59 = C3DVector3Angle(vmulq_n_f32(v55, vmul_f32(v58, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v58, v58))).f32[0]), v46);
          float v60 = C3DVector3Angle(*(float32x4_t *)cf, (float32x4_t)v119[v47]) * 0.5;
          float v61 = cosf(v60);
          if (v61 == 0.0)
          {
            uint64_t v62 = scn_default_log();
            float v63 = 1.0;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
              C3DMeshSubdivide_cold_2(&buf, v117, v62);
            }
          }
          else
          {
            float v63 = v61;
          }
          float v64 = *(float *)&v118[v47];
          float v65 = cosf(v59 - v60);
          char v53 = 0;
          float32x4_t v46 = *(float32x4_t *)cf;
          float32x4_t v52 = vaddq_f32(v111, vmulq_n_f32(*(float32x4_t *)cf, (float)((float)(v65 * v64) / v63) * 0.5));
          uint64_t v47 = 1;
        }
        while ((v54 & 1) != 0);
        v103[v36++] = vaddq_f32(v108, v52);
        a5 = v44;
        long long v18 = v103;
      }
      while (v36 != v17);
    }
  }
  C3DMeshSourceAppendVector3(a4, (uint64_t)v18, v17);
  free(v18);
  cfSCNMatrix4 a = C3DTriangulationInfoCreateFromMeshElement(v102, a4, (uint64_t)v16);
  if (v106 >= 1)
  {
    for (uint64_t k = 0; k != v106; ++k)
    {
      EdgesAtFaceuint64_t Index = (uint64_t *)C3DTriangulationInfoGetEdgesAtFaceIndex((uint64_t)cfa, k);
      uint64_t v69 = *EdgesAtFaceIndex;
      uint64_t v68 = EdgesAtFaceIndex[1];
      uint64_t v70 = EdgesAtFaceIndex[2];
      long long v71 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, *EdgesAtFaceIndex);
      long long v72 = (void *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v68);
      uint64_t v73 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v70);
      uint64_t Index = C3DMeshElementGetIndex(v102, k, 0, 0);
      uint64_t v75 = C3DMeshElementGetIndex(v102, k, 2, 0);
      uint64_t v76 = *v71;
      if (*v71 == Index)
      {
        uint64_t v77 = v71[1];
        uint64_t v78 = Count;
        uint64_t v79 = v69 + Count;
        BOOL v80 = v77 == v75;
        if (v77 == v75) {
          uint64_t v81 = v69 + Count;
        }
        else {
          uint64_t v81 = -1;
        }
        if (v80) {
          uint64_t v79 = -1;
        }
        uint64_t v82 = -1;
      }
      else
      {
        uint64_t v83 = v71[1];
        uint64_t v78 = Count;
        BOOL v84 = v83 == Index;
        if (v83 == Index) {
          uint64_t v79 = v69 + Count;
        }
        else {
          uint64_t v79 = -1;
        }
        if (v84) {
          uint64_t v82 = -1;
        }
        else {
          uint64_t v82 = v69 + Count;
        }
        BOOL v85 = v76 == v75;
        if (v76 == v75) {
          uint64_t v81 = v79;
        }
        else {
          uint64_t v81 = -1;
        }
        if (v85) {
          uint64_t v79 = -1;
        }
      }
      if (*v72 == Index)
      {
        if (v72[1] == v75) {
          uint64_t v81 = v68 + v78;
        }
        else {
          uint64_t v79 = v68 + v78;
        }
      }
      else
      {
        uint64_t v86 = v72[1];
        uint64_t v87 = v68 + v78;
        BOOL v88 = v86 == Index;
        if (v86 == Index)
        {
          uint64_t v89 = v68 + v78;
        }
        else
        {
          uint64_t v82 = v68 + v78;
          uint64_t v89 = v79;
        }
        if (!v88) {
          uint64_t v87 = v81;
        }
        if (*v72 == v75) {
          uint64_t v81 = v87;
        }
        else {
          uint64_t v79 = v89;
        }
      }
      uint64_t v90 = *v73;
      if (*v73 == Index)
      {
        uint64_t v91 = v73[1];
        if (v91 == v75) {
          uint64_t v92 = v70 + v78;
        }
        else {
          uint64_t v92 = v81;
        }
        if (v91 == v75) {
          uint64_t v93 = v79;
        }
        else {
          uint64_t v93 = v70 + v78;
        }
      }
      else
      {
        uint64_t v94 = v73[1];
        uint64_t v95 = v70 + v78;
        BOOL v96 = v94 == Index;
        if (v94 == Index)
        {
          uint64_t v97 = v70 + v78;
        }
        else
        {
          uint64_t v82 = v70 + v78;
          uint64_t v97 = v79;
        }
        if (!v96) {
          uint64_t v95 = v81;
        }
        if (v90 == v75) {
          uint64_t v92 = v95;
        }
        else {
          uint64_t v92 = v81;
        }
        if (v90 == v75) {
          uint64_t v93 = v79;
        }
        else {
          uint64_t v93 = v97;
        }
      }
      if (v92 == -1 || v93 == -1 || v82 == -1)
      {
        uint64_t v100 = scn_default_log();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
          C3DMeshSubdivide_cold_1((uint8_t *)v120, (_OWORD *)((char *)v120 + 4), v100);
        }
      }
      C3DMeshElementEditorSubdivideTriangleAtIndex((uint64_t)v105, k, v92, v93, v82);
    }
  }
  Meshuint64_t Element = (const void *)C3DMeshElementEditorGenerateMeshElement((uint64_t)v105);
  CFRetain(MeshElement);
  CFRelease(v105);
  CFRelease(v16);
  CFRelease(cfa);
  return CFAutorelease(MeshElement);
}

uint64_t C3DMeshCopyWithTransform(uint64_t a1, float32x4_t *a2)
{
  memset(v15, 0, sizeof(v15));
  uint64_t Copy = C3DMeshCreateCopy(a1);
  PositionSource = C3DMeshGetPositionSource(Copy, 0);
  Deepuint64_t Copy = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)PositionSource);
  uint64_t Accessor = (void *)C3DGenericSourceGetAccessor((uint64_t)DeepCopy);
  uint64_t Count = C3DMeshSourceGetCount((uint64_t)DeepCopy);
  __C3DTransformFloatsInAccessor(Accessor, 0, Count, a2, 0);
  unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
  C3DMeshSetSourceWithInputSet(Copy, DeepCopy, 0, ChannelForSourceWithSemanticAtIndex);
  NormalSource = C3DMeshGetNormalSource(Copy, 0);
  if (NormalSource)
  {
    uint64_t v11 = (uint64_t)NormalSource;
    CFStringRef v12 = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)NormalSource);
    __MakeNormalMatrix((__n128 *)a2, v15);
    __TransformAndAppendMeshSource((uint64_t)v12, v11, v15, 0);
    unsigned __int8 v13 = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 1, 0);
    C3DMeshSetSourceWithInputSet(Copy, v12, 0, v13);
    CFRelease(v12);
  }
  CFRelease(DeepCopy);
  return Copy;
}

void __C3DTransformFloatsInAccessor(void *a1, uint64_t a2, uint64_t a3, float32x4_t *a4, int a5)
{
  if (a3 >= 1)
  {
    uint64_t v19 = v5;
    uint64_t v20 = v6;
    uint64_t v9 = a3;
    do
    {
      MutableValuePtrAtuint64_t Index = C3DSourceAccessorGetMutableValuePtrAtIndex(a1, a2);
      v13.i64[0] = *(void *)MutableValuePtrAtIndex;
      v13.i32[2] = *((_DWORD *)MutableValuePtrAtIndex + 2);
      float32x4_t v14 = a4[1];
      v18[0] = *a4;
      v18[1] = v14;
      float32x4_t v15 = a4[3];
      v18[2] = a4[2];
      v18[3] = v15;
      if (a5) {
        double v16 = C3DVector3Rotate((float32x2_t *)v18, v13);
      }
      else {
        double v16 = C3DVector3MultMatrix4x4(v18, v13);
      }
      *(double *)MutableValuePtrAtuint64_t Index = v16;
      *((_DWORD *)MutableValuePtrAtIndex + 2) = v17;
      ++a2;
      --v9;
    }
    while (v9);
  }
}

void __TransformAndAppendMeshSource(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t Accessor = (void *)C3DGenericSourceGetAccessor(a1);
  uint64_t v9 = C3DGenericSourceGetAccessor(a2);
  uint64_t Count = C3DSourceAccessorGetCount(v9);
  if (C3DSourceAccessorCopyDataToAccessor(v9, (uint64_t)Accessor, a4))
  {
    MutableValuePtrAtuint64_t Index = C3DSourceAccessorGetMutableValuePtrAtIndex(Accessor, 0);
    uint64_t v12 = C3DSourceAccessorGetCount((uint64_t)Accessor);
    ComponentsCountPerCFNumberRef Value = C3DSourceAccessorGetComponentsCountPerValue(v9);
    _C3DMeshSourceSetupNonInitializedComponents(a1, (uint64_t)MutableValuePtrAtIndex, v12, ComponentsCountPerValue);
    if (a3)
    {
      BOOL v14 = C3DMeshSourceGetSemantic(a1) == 1;
      __C3DTransformFloatsInAccessor(Accessor, a4, Count, a3, v14);
    }
  }
  else
  {
    float32x4_t v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      __TransformAndAppendMeshSource_cold_1();
    }
  }
}

uint64_t C3DWarmupMaterialVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t CommonProfile = C3DMaterialGetCommonProfile(a1);
  if (!CommonProfile) {
    return 1;
  }
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke;
  v15[3] = &unk_264004C80;
  void v15[5] = CommonProfile;
  v15[6] = a2;
  float32x4_t v15[4] = a3;
  v13[48] = a2;
  v14[0] = MEMORY[0x263EF8330];
  v14[1] = 3221225472;
  v14[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_2;
  v14[3] = &unk_264004C80;
  void v14[5] = CommonProfile;
  void v14[6] = a2;
  uint8_t v14[4] = a3;
  v13[42] = MEMORY[0x263EF8330];
  v13[43] = 3221225472;
  v13[44] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_3;
  v13[45] = &unk_264004C80;
  v13[46] = a3;
  v13[47] = CommonProfile;
  v13[35] = MEMORY[0x263EF8330];
  v13[36] = 3221225472;
  v13[37] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_4;
  v13[38] = &unk_264004C80;
  v13[41] = a2;
  v13[40] = CommonProfile;
  v13[39] = a3;
  v13[28] = MEMORY[0x263EF8330];
  v13[29] = 3221225472;
  v13[30] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_5;
  v13[31] = &unk_264004C80;
  v13[34] = a2;
  v13[33] = CommonProfile;
  v13[32] = a3;
  v13[21] = MEMORY[0x263EF8330];
  v13[22] = 3221225472;
  v13[23] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_6;
  v13[24] = &unk_264004C80;
  v13[27] = a2;
  v13[26] = CommonProfile;
  v13[25] = a3;
  v13[14] = MEMORY[0x263EF8330];
  v13[15] = 3221225472;
  uint8_t v13[16] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_7;
  v13[17] = &unk_264004C80;
  v13[20] = a2;
  v13[19] = CommonProfile;
  v13[18] = a3;
  v13[7] = MEMORY[0x263EF8330];
  v13[8] = 3221225472;
  v13[9] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_8;
  v13[10] = &unk_264004C80;
  v13[13] = a2;
  v13[12] = CommonProfile;
  v13[11] = a3;
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  _OWORD v13[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_9;
  v13[3] = &unk_264004C80;
  void v13[6] = a2;
  void v13[5] = CommonProfile;
  _OWORD v13[4] = a3;
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  void v12[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_10;
  v12[3] = &unk_264004C80;
  v12[6] = a2;
  v12[5] = CommonProfile;
  v12[4] = a3;
  v10[6] = a2;
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 3221225472;
  void v11[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_11;
  v11[3] = &unk_264004C80;
  v11[6] = a2;
  uint8_t v11[4] = a3;
  void v11[5] = CommonProfile;
  v9[6] = a2;
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  _DWORD v10[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_12;
  void v10[3] = &unk_264004C80;
  v10[4] = a3;
  v10[5] = CommonProfile;
  v8[6] = a2;
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_13;
  v9[3] = &unk_264004C80;
  _OWORD v9[4] = a3;
  v9[5] = CommonProfile;
  void v7[6] = a2;
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  v8[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_14;
  v8[3] = &unk_264004C80;
  _OWORD v8[4] = a3;
  void v8[5] = CommonProfile;
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  int v7[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_15;
  v7[3] = &unk_264004C80;
  v7[4] = a3;
  void v7[5] = CommonProfile;
  return C3DExecuteProgressBlocks((uint64_t)v15, (uint64_t)v13, (uint64_t)v12, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, (uint64_t)v8, (uint64_t)v7, (uint64_t)v14);
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 1, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 1);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 2, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 2);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_3(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 4, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 4);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_4(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 3, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 3);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_5(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 0, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 0);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_6(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 5, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 5);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_7(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 6, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 6);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_8(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 7, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 7);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_9(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 9, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 9);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_10(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 8, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 8);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_11(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 10, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 10);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_12(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 11, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 11);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_13(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 15, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 15);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_14(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 12, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 12);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_15(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 13, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 13);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_16(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 14, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 14);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_17(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v2, 16, 0);
  if (EffectSlot)
  {
    uint64_t v5 = EffectSlot;
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v3);
    if (RenderContext)
    {
      -[SCNMTLRenderContext textureForEffectSlot:](RenderContext, v5);
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(v3);
      uint64_t ResourceManager = C3DEngineContextGetResourceManager(v3);
      uint64_t Image = C3DEffectSlotGetImage(v5);
      if (Image)
      {
        uint64_t v10 = (void *)Image;
        TextureSampler = (const void *)C3DEffectCommonProfileGetTextureSampler(v2, 16);
        C3DResourceManagerMakeImageResident(ResourceManager, v10, TextureSampler, RendererContextGL);
      }
    }
  }
  uint64_t v12 = a1[4];
  if (v12) {
    return (*(unsigned int (**)(void))(v12 + 16))() ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t C3DWarmupGeometryVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
  uint64_t ResourceManager = C3DEngineContextGetResourceManager(a2);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a2);
  uint64_t v9 = -[SCNMTLRenderContext resourceManager](RenderContext);
  v19[0] = MEMORY[0x263EF8330];
  v19[1] = 3221225472;
  v19[2] = __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke;
  v19[3] = &unk_264004C80;
  void v19[5] = a1;
  void v19[6] = a2;
  _OWORD v19[4] = a3;
  v18[0] = MEMORY[0x263EF8330];
  v18[1] = 3221225472;
  v18[2] = __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke_2;
  v18[3] = &unk_264004CA8;
  v18[6] = a1;
  v18[7] = ResourceManager;
  __int16 v18[8] = RendererContextGL;
  float32x4_t v18[4] = v9;
  void v18[5] = a3;
  return C3DExecuteProgressBlocks((uint64_t)v19, v10, v11, v12, v13, v14, v15, v16, (uint64_t)v18);
}

BOOL __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke(uint64_t *a1)
{
  Materialsuint64_t Count = C3DGeometryGetMaterialsCount(a1[5]);
  if ((uint64_t)MaterialsCount < 1)
  {
    return 1;
  }
  else
  {
    CFArrayRef v3 = MaterialsCount;
    BOOL v4 = 0;
    for (i = 0; (const __CFArray *)i != v3; BOOL v4 = i >= (uint64_t)v3)
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1[5], i);
      C3DWarmupMaterialVRAMResourcesForEngineContext((uint64_t)MaterialAtIndex, a1[6], a1[4]);
      uint64_t v7 = a1[4];
      if (v7 && ((*(uint64_t (**)(void))(v7 + 16))() & 1) != 0) {
        break;
      }
      ++i;
    }
  }
  return v4;
}

uint64_t __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke_2(void *a1)
{
  uint64_t Mesh = C3DGeometryGetMesh(a1[6]);
  if (!Mesh)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint8_t buf = 0;
      _os_log_impl(&dword_20B249000, v6, OS_LOG_TYPE_DEFAULT, "Warning: try to preload a geometry with no mesh", buf, 2u);
    }
    return 1;
  }
  uint64_t v3 = Mesh;
  uint64_t v4 = a1[4];
  if (v4)
  {
    BOOL EffectiveDataKindForRendering = C3DGeometryGetEffectiveDataKindForRendering((__C3DGeometry *)a1[6]);
    -[SCNMTLResourceManager renderResourceForMesh:dataKind:](v4, v3, EffectiveDataKindForRendering);
    return 1;
  }
  CFArrayRef v7 = C3DMeshCopyAllSources(Mesh, 1);
  CFIndex Count = CFArrayGetCount(v7);
  if (Count < 1)
  {
LABEL_16:
    CFRelease(v7);
    return 1;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (1)
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v7, v10);
    if (C3DMeshSourceGetAccessor(ValueAtIndex)
      && (uint64_t Accessor = C3DMeshSourceGetAccessor(ValueAtIndex), C3DSourceAccessorGetData(Accessor)))
    {
      C3DResourceManagerMakeMeshSourceResident(a1[7], (uint64_t)ValueAtIndex, a1[8]);
    }
    else
    {
      uint64_t v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke_2_cold_1(&v16, v17, v13);
      }
    }
    uint64_t v14 = a1[5];
    if (v14)
    {
      if ((*(unsigned int (**)(void))(v14 + 16))()) {
        break;
      }
    }
    if (v9 == ++v10) {
      goto LABEL_16;
    }
  }
  CFRelease(v7);
  return 0;
}

uint64_t __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke_27(void *a1)
{
  if (a1[4]) {
    return 1;
  }
  uint64_t Mesh = C3DGeometryGetMesh(a1[6]);
  ElementsCFIndex Count = C3DMeshGetElementsCount(Mesh);
  if ((uint64_t)ElementsCount < 1) {
    return 1;
  }
  CFArrayRef v5 = ElementsCount;
  CFIndex v6 = 0;
  while (1)
  {
    uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(Mesh, v6, 1);
    C3DResourceManagerMakeMeshElementResident(a1[7], (uint64_t)ElementAtIndex, a1[8]);
    uint64_t v8 = a1[5];
    if (v8)
    {
      if ((*(uint64_t (**)(void))(v8 + 16))()) {
        break;
      }
    }
    if (v5 == (const __CFArray *)++v6) {
      return 1;
    }
  }
  return 0;
}

uint64_t C3DWarmupNodeTreeVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  int v14 = 0;
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  _DWORD v10[2] = __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke;
  void v10[3] = &unk_264004CD0;
  v10[4] = &v11;
  C3DNodeApplyHierarchy(a1, (uint64_t)v10);
  int v6 = *((_DWORD *)v12 + 6);
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke_2;
  v9[3] = &unk_264004D20;
  v9[5] = a1;
  v9[6] = a2;
  _OWORD v9[4] = a3;
  uint64_t v7 = C3DExecuteIncrementalProgressBlock(v6, (uint64_t)v9);
  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_20B2E1B18(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke(uint64_t a1)
{
  return 0;
}

BOOL __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke_2(void *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke_3;
  _OWORD v6[3] = &unk_264004CF8;
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  v6[4] = a1[4];
  void v6[5] = a2;
  v6[6] = &v7;
  v6[7] = v3;
  C3DNodeApplyHierarchy(v2, (uint64_t)v6);
  BOOL v4 = *((unsigned char *)v8 + 24) == 0;
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_20B2E1C08(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke_3(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[4];
  uint64_t Geometry = C3DNodeGetGeometry(a2);
  if (Geometry && !C3DWarmupGeometryVRAMResourcesForEngineContext(Geometry, v3, v4))
  {
    (*(void (**)(void))(a1[5] + 16))();
    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
    return 2;
  }
  else
  {
    (*(void (**)(void))(a1[5] + 16))();
    return 0;
  }
}

uint64_t C3DCreateTangentsWithGeometry(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  PositionSource = C3DMeshGetPositionSource(v3, a2);
  NormalSource = C3DMeshGetNormalSource(v3, a2);
  SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(v3, 3, 0, a2);
  if (!PositionSource && (uint64_t v15 = scn_default_log(), os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
    if (NormalSource) {
      goto LABEL_9;
    }
  }
  else if (NormalSource)
  {
    goto LABEL_9;
  }
  CFMutableDataRef v23 = scn_default_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
    C3DCreateTangentsWithGeometry_cold_2(v23, v24, v25, v26, v27, v28, v29, v30);
  }
LABEL_9:
  uint64_t v119 = (uint64_t)NormalSource;
  if (!SourceWithSemanticAtIndex)
  {
    uint64_t v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometry_cold_1(v31, v32, v33, v34, v35, v36, v37, v38);
    }
  }
  size_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  Elementssize_t Count = C3DMeshGetElementsCount(v3);
  uint64_t v120 = Count;
  Count *= 16;
  float32x4_t v41 = (UInt8 *)malloc_type_calloc(Count, 1uLL, 0xA69E3218uLL);
  CFIndex length = Count;
  long long v42 = malloc_type_calloc(Count, 1uLL, 0xBE279100uLL);
  uint64_t Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
  __int16 v44 = v43;
  uint64_t v127 = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
  if ((uint64_t)ElementsCount < 1)
  {
    char v48 = 0;
  }
  else
  {
    CFIndex v47 = 0;
    char v48 = 0;
    uint64_t v125 = HIBYTE(v44);
    int v126 = v44;
    uint64_t v123 = v46;
    int v124 = v45;
    CFArrayRef v121 = ElementsCount;
    uint64_t v122 = v3;
    do
    {
      uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(v3, v47, 1);
      if (!C3DMeshElementGetType((uint64_t)ElementAtIndex)
        || C3DMeshElementGetType((uint64_t)ElementAtIndex) == 1)
      {
        Primitivesize_t Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
        if (PrimitiveCount < 1)
        {
          char v48 = 0;
        }
        else
        {
          for (uint64_t i = 0; i != PrimitiveCount; ++i)
          {
            uint64_t Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 0, 0);
            uint64_t v52 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 1, 0);
            uint64_t v53 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 2, 0);
            *(double *)v57.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + Index * v125), v54, v55, v56);
            float32x4_t v134 = v57;
            *(double *)v60.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + v52 * v125), v57, v58, v59);
            float32x4_t v133 = v60;
            *(double *)v63.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + v53 * v125), v60, v61, v62);
            float32x4_t v132 = v63;
            *(double *)v66.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + Index * v123), v63, v64, v65);
            float32x4_t v131 = v66;
            *(double *)v69.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + v52 * v123), v66, v67, v68);
            float32x4_t v130 = v69;
            *(double *)v72.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + v53 * v123), v69, v70, v71);
            float32x2_t v73 = (float32x2_t)vsubq_f32(v130, v131).u64[0];
            unint64_t v74 = vsubq_f32(v72, v131).u64[0];
            float v75 = v73.f32[1];
            float v76 = *((float *)&v74 + 1);
            float v77 = -*(float *)&v74;
            float v78 = vmlas_n_f32(vmuls_lane_f32(-*(float *)&v74, v73, 1), *((float *)&v74 + 1), v73.f32[0]);
            if (v78 == 0.0)
            {
              float v75 = v73.f32[1] + 0.00000011921;
              float v76 = *((float *)&v74 + 1) + -0.00000011921;
              v73.f32[0] = v73.f32[0] + -0.00000011921;
              float v77 = -(float)(*(float *)&v74 + -0.00000011921);
              float v78 = (float)(v73.f32[0] * (float)(*((float *)&v74 + 1) + -0.00000011921))
                  - (float)((float)(*(float *)&v74 + -0.00000011921) * (float)(v73.f32[1] + 0.00000011921));
            }
            float32x4_t v79 = vsubq_f32(v133, v134);
            float32x4_t v80 = vsubq_f32(v132, v134);
            float v81 = 1.0 / v78;
            float v82 = -v75;
            float v83 = (float)((float)(v76 * v79.f32[2]) - (float)(v75 * v80.f32[2])) * v81;
            uint64_t v84 = 4 * Index;
            uint64_t v85 = (16 * Index) | 8;
            *(float *)&v41[v85] = v83 + *(float *)&v41[v85];
            uint64_t v86 = (16 * v52) | 8;
            uint64_t v87 = 4 * v52;
            *(float *)&v41[v86] = v83 + *(float *)&v41[v86];
            float32x2_t v88 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v80.f32, v82), *(float32x2_t *)v79.f32, v76), v81);
            *(float32x2_t *)&v41[v84 * 4] = vadd_f32(*(float32x2_t *)&v41[16 * Index], v88);
            uint64_t v89 = 4 * v53;
            *(float32x2_t *)&v41[v87 * 4] = vadd_f32(v88, *(float32x2_t *)&v41[16 * v52]);
            *(float32x2_t *)&v41[v89 * 4] = vadd_f32(v88, *(float32x2_t *)&v41[16 * v53]);
            uint64_t v90 = (16 * v53) | 8;
            *(float *)&v41[v90] = v83 + *(float *)&v41[v90];
            v88.f32[0] = (float)((float)(v79.f32[2] * v77) + (float)(v73.f32[0] * v80.f32[2])) * v81;
            *(float *)((char *)v42 + v85) = v88.f32[0] + *(float *)((char *)v42 + v85);
            *(float *)((char *)v42 + v86) = v88.f32[0] + *(float *)((char *)v42 + v86);
            float32x2_t v91 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v79.f32, v77), *(float32x2_t *)v80.f32, v73.f32[0]), v81);
            *(float32x2_t *)&v42[v84] = vadd_f32(v91, *(float32x2_t *)&v42[4 * Index]);
            *(float32x2_t *)&v42[v87] = vadd_f32(v91, *(float32x2_t *)&v42[4 * v52]);
            *(float32x2_t *)&v42[v89] = vadd_f32(v91, *(float32x2_t *)&v42[4 * v53]);
            *(float *)((char *)v42 + v90) = v88.f32[0] + *(float *)((char *)v42 + v90);
          }
          char v48 = 1;
          Elementssize_t Count = v121;
          uint64_t v3 = v122;
        }
      }
      ++v47;
    }
    while ((const __CFArray *)v47 != ElementsCount);
  }
  uint64_t v92 = C3DMeshSourceGetContent(v119);
  if (v120 >= 1)
  {
    uint64_t v98 = (float *)v92;
    int v99 = 0;
    int v100 = v93;
    uint64_t v101 = v94;
    uint64_t v102 = v120;
    do
    {
      *(double *)v103.i64 = C3DConvertFloatingTypeToFloat4(v100, v98, v95, v96.f32[0], *(float *)v97.i32);
      uint64_t v104 = 4 * v99;
      uint64_t v105 = (__int32 *)&v41[4 * v99 + 8];
      v106.i64[0] = *(void *)&v41[v104];
      float32x4_t v107 = v106;
      v106.i32[2] = *v105;
      v107.i32[2] = *v105;
      float32x4_t v108 = vmulq_f32(v103, v106);
      float32x4_t v109 = vmlsq_lane_f32(v107, v103, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))), 0);
      int32x4_t v110 = (int32x4_t)vmulq_f32(v109, v109);
      v110.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v110, 2), vadd_f32(*(float32x2_t *)v110.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v110.i8, 1))).u32[0];
      float32x2_t v111 = vrsqrte_f32((float32x2_t)v110.u32[0]);
      float32x2_t v112 = vmul_f32(v111, vrsqrts_f32((float32x2_t)v110.u32[0], vmul_f32(v111, v111)));
      float32x4_t v113 = vmulq_n_f32(v109, vmul_f32(v112, vrsqrts_f32((float32x2_t)v110.u32[0], vmul_f32(v112, v112))).f32[0]);
      *(void *)&v41[v104] = v113.i64[0];
      *uint64_t v105 = v113.i32[2];
      v113.i64[0] = *(void *)&v42[(unint64_t)v104 / 4];
      v113.i32[2] = v42[v99 + 2];
      int32x4_t v97 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v107, (int32x4_t)v107), (int8x16_t)v107, 0xCuLL), vnegq_f32(v103)), v107, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
      float32x4_t v114 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v97, v97), (int8x16_t)v97, 0xCuLL), v113);
      float32x4_t v96 = vaddq_f32(v114, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1));
      float32x4_t v95 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 2), v96);
      if (v95.f32[0] < 0.0) {
        v95.f32[0] = -1.0;
      }
      else {
        v95.f32[0] = 1.0;
      }
      *(_DWORD *)&v41[4 * v99 + 12] = v95.i32[0];
      v99 += 4;
      uint64_t v98 = (float *)((char *)v98 + v101);
      --v102;
    }
    while (v102);
  }
  free(v42);
  if (v48)
  {
    CFDataRef v115 = CFDataCreateWithBytesNoCopy(0, v41, length, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
    uint64_t v116 = C3DMeshSourceCreate(v115, 4, v120, 4, 1);
    CFRelease(v115);
  }
  else
  {
    free(v41);
    return 0;
  }
  return v116;
}

uint64_t C3DCreateNormalsWithMesh(uint64_t a1, int a2, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  if (!PositionSource)
  {
    uint64_t v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  if (!C3DMeshGetElementsCount(a1)) {
    return 0;
  }
  uint64_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  uint64_t Mutable = C3DMeshSourceCreateMutable(0, 1, Count, 3, 1);
  _unifyNormalsOptimized(a1, (uint64_t)PositionSource, Mutable, a2, a3);
  C3DMeshSourceMakeImmutable(Mutable);
  return Mutable;
}

void _unifyNormalsOptimized(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t Content = C3DMeshSourceGetContent(a2);
  if ((v11 & 0xFF00000000) == 0x900000000
    && (uint64_t v12 = Content, v13 = v11, v14 = C3DMeshSourceGetContent(a3), v61 = v15, (v15 & 0xFF00000000) == 0x900000000))
  {
    if (v13)
    {
      uint64_t v16 = (char *)v14;
      if (a5) {
        WeldRemappingTable = C3DMeshSourceCreateWeldRemappingTable(a2);
      }
      else {
        WeldRemappingTable = 0;
      }
      Elementsunsigned int Count = C3DMeshGetElementsCount(a1);
      unsigned int Count = C3DMeshSourceGetCount(a3);
      unsigned int v21 = Count;
      if (BYTE5(v61) == 12)
      {
        LODWORD(__pattern4) = 0;
        memset_pattern4(v16, &__pattern4, 12 * Count);
      }
      else if (Count)
      {
        int v22 = 0;
        uint64_t v23 = Count;
        do
        {
          uint64_t v24 = &v16[v22];
          *(void *)uint64_t v24 = 0;
          *((_DWORD *)v24 + 2) = 0;
          v22 += BYTE5(v61);
          --v23;
        }
        while (v23);
      }
      unsigned int v60 = v21;
      if ((uint64_t)ElementsCount >= 1)
      {
        CFIndex v25 = 0;
        while (1)
        {
          uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(a1, v25, a4);
          uint64_t v27 = a4 ? 0 : C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
          uint64_t v71 = 0;
          long long v69 = 0u;
          __n128 v70 = 0u;
          long long __pattern4 = 0u;
          C3DMeshElementGetContent((uint64_t)ElementAtIndex, v27, (uint64_t)&__pattern4);
          if ((BYTE10(v69) & 0xFA) == 0) {
            break;
          }
          uint64_t v28 = scn_default_log();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint8_t buf = 0;
            uint64_t v29 = v28;
            uint64_t v30 = "Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons";
LABEL_24:
            _os_log_impl(&dword_20B249000, v29, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
          }
LABEL_29:
          if (ElementsCount == (const __CFArray *)++v25) {
            goto LABEL_30;
          }
        }
        if ((void)__pattern4)
        {
          v66[0] = MEMORY[0x263EF8330];
          v66[1] = 3221225472;
          v66[2] = ___unifyNormalsOptimized_block_invoke;
          v66[3] = &__block_descriptor_76_e19_v32__0I8_I12I20_B24l;
          int v67 = v13 - 1;
          v66[4] = v12;
          v66[5] = v13;
          v66[6] = WeldRemappingTable;
          v66[7] = v16;
          v66[8] = v61;
          *(_OWORD *)uint8_t buf = __pattern4;
          long long v63 = v69;
          __n128 v64 = v70;
          uint64_t v65 = v71;
          C3DIndicesContentEnumeratePrimitives((uint64_t *)buf, (uint64_t)v66, v70);
          goto LABEL_29;
        }
        uint64_t v31 = scn_default_log();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_29;
        }
        *(_WORD *)uint8_t buf = 0;
        uint64_t v29 = v31;
        uint64_t v30 = "Warning: C3DUnifyNormalsFromGeometry empty indices";
        goto LABEL_24;
      }
LABEL_30:
      if (WeldRemappingTable && v60)
      {
        int v32 = 0;
        for (uint64_t i = 0; i != v60; ++i)
        {
          uint64_t v34 = WeldRemappingTable[i];
          if (i != v34)
          {
            uint64_t v35 = &v16[v34 * BYTE5(v61)];
            int v36 = *((_DWORD *)v35 + 2);
            uint64_t v37 = *(void *)v35;
            uint64_t v38 = &v16[v32];
            *(void *)uint64_t v38 = v37;
            *((_DWORD *)v38 + 2) = v36;
          }
          v32 += BYTE5(v61);
        }
      }
      LODWORD(v39) = 0;
      if (BYTE5(v61) == 12 && v60 >= 4)
      {
        uint64_t v40 = 0;
        unint64_t v39 = 0;
        do
        {
          float32x4_t v41 = (float *)&v16[v40 & 0xFFFFFFF0];
          *(float32x4x3_t *)(&v20 - 1) = vld3q_f32(v41);
          float32x4_t v44 = vaddq_f32(vmulq_f32(v43, v43), vaddq_f32(vmulq_f32(v42, v42), vmulq_f32(v20, v20)));
          float32x4_t v45 = vrsqrteq_f32(v44);
          float32x4_t v46 = vmulq_f32(v45, vrsqrtsq_f32(v44, vmulq_f32(v45, v45)));
          v73.val[0] = vmulq_f32(v42, v46);
          v73.val[1] = vmulq_f32(v20, v46);
          v73.val[2] = vmulq_f32(v43, v46);
          vst3q_f32(v41, v73);
          v39 += 4;
          v40 += 48;
        }
        while (v39 < (v60 & 0xFFFFFFFC));
      }
      if (v39 < v60)
      {
        int v47 = v39 * BYTE5(v61);
        unint64_t v48 = v60 - (unint64_t)v39;
        __asm { FMOV            V0.4S, #1.0 }
        do
        {
          float32x4_t v54 = &v16[v47];
          v20.i64[0] = *(void *)v54;
          v20.i32[2] = *((_DWORD *)v54 + 2);
          float32x4_t v55 = vmulq_f32(v20, v20);
          v55.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).u64[0];
          float32x4_t v56 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0);
          float32x4_t v57 = vrsqrteq_f32(v56);
          float32x4_t v58 = vmulq_f32(v57, vrsqrtsq_f32(v56, vmulq_f32(v57, v57)));
          int32x4_t v59 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v55.f32[0] != 0.0)), 0x1FuLL));
          v59.i32[3] = 0;
          float32x4_t v20 = vmulq_f32(v20, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v59), (int8x16_t)vmulq_f32(v58, vrsqrtsq_f32(v56, vmulq_f32(v58, v58))), _Q0));
          *(void *)float32x4_t v54 = v20.i64[0];
          *((_DWORD *)v54 + 2) = v20.i32[2];
          v47 += BYTE5(v61);
          --v48;
        }
        while (v48);
      }
      free(WeldRemappingTable);
    }
  }
  else
  {
    _unifyNormals(a1, a2, a3, a4, a5);
  }
}

uint64_t C3DCreateNormalsForMorphTargetWithBaseMesh(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCreateNormalsForMorphTargetWithBaseMesh_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!C3DMeshGetElementsCount(a2)) {
    return 0;
  }
  PositionSource = C3DMeshGetPositionSource(a1, a3);
  if (!PositionSource)
  {
    uint64_t v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3DCreateNormalsForMorphTargetWithBaseMesh_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  uint64_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  uint64_t Mutable = C3DMeshSourceCreateMutable(0, 1, Count, 3, 1);
  _unifyNormalsOptimized(a2, (uint64_t)PositionSource, Mutable, a3, 0);
  C3DMeshSourceMakeImmutable(Mutable);
  return Mutable;
}

void C3DMeshUnifyNormals(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (C3DMeshGetElementsCount(a2))
  {
    PositionSource = C3DMeshGetPositionSource(a1, 1);
    if (PositionSource)
    {
      uint64_t v9 = (uint64_t)PositionSource;
      uint64_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
      if (Count)
      {
        uint64_t v11 = Count;
        uint64_t v12 = C3DMeshGetPositionSource(a2, 1);
        if (v12)
        {
          uint64_t v13 = C3DMeshSourceGetCount((uint64_t)v12);
          if (v11 == v13)
          {
            NormalSource = C3DMeshGetNormalSource(a1, 1);
            if (!NormalSource && a3)
            {
              NormalSource = (const void *)C3DMeshSourceCreateMutable(0, 1, v11, 3, 1);
              __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, NormalSource, 0);
              CFRelease(NormalSource);
            }
            if (NormalSource)
            {
              if (C3DMeshSourceIsMutable(NormalSource))
              {
                _unifyNormalsOptimized(a2, v9, (uint64_t)NormalSource, 1, a4);
              }
              else
              {
                Mutableuint64_t Copy = (const void *)C3DMeshSourceCreateMutableCopy((uint64_t)NormalSource);
                __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, MutableCopy, 0);
                CFRelease(MutableCopy);
                _unifyNormalsOptimized(a2, v9, (uint64_t)MutableCopy, 1, a4);
                C3DMeshSourceMakeImmutable(MutableCopy);
              }
            }
          }
          else
          {
            int v15 = v13;
            uint64_t v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
              C3DMeshUnifyNormals_cold_1(v11, v15, v16);
            }
          }
        }
      }
    }
  }
}

void C3DApplyScaleFactorOnScene(uint64_t a1, float a2)
{
  Rootuint64_t Node = (__n128 *)C3DSceneGetRootNode(a1);
  *(float *)&double v4 = a2;

  C3DApplyScaleFactorOnNode(RootNode, 1, v4);
}

void C3DApplyScaleFactorOnNode(__n128 *a1, int a2, double a3)
{
  if (a1)
  {
    *(double *)v5.i64 = C3DNodeGetPosition(a1);
    C3DNodeSetPosition((uint64_t)a1, (__n128)vmulq_n_f32(v5, *(float *)&a3));
    if (C3DNodeGetHasPivot((uint64_t)a1))
    {
      *(double *)v6.i64 = C3DNodeGetPivotPosition((uint64_t)a1);
      uint32x4_t v7 = (uint32x4_t)vceqzq_f32(v6);
      v7.i32[3] = v7.i32[2];
      if ((vminvq_u32(v7) & 0x80000000) == 0) {
        C3DNodeSetPivotPosition((float32x4_t *)a1, (__n128)vmulq_n_f32(v6, *(float *)&a3));
      }
    }
    uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a1);
    if (Geometry)
    {
      uint64_t Mesh = C3DGeometryGetMesh(Geometry);
      if (Mesh) {
        C3DApplyScaleFactorOnMesh(Mesh, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0));
      }
    }
    CFDictionaryRef Light = C3DNodeGetLight((uint64_t)a1);
    if (Light) {
      C3DApplyScaleFactorOnLight((uint64_t)Light, *(float *)&a3);
    }
    CamerSCNMatrix4 a = C3DNodeGetCamera((uint64_t)a1);
    if (Camera) {
      C3DApplyScaleFactorOnCamera((uint64_t)Camera, *(float *)&a3);
    }
    if (a2)
    {
      v13[0] = MEMORY[0x263EF8330];
      v13[1] = 3221225472;
      _OWORD v13[2] = __C3DApplyScaleFactorOnNode_block_invoke;
      v13[3] = &__block_descriptor_36_e318_v24__0____C3DNode____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DNode_____C3DNode_____C3DNode_i____C3DMatrix4x4__16f__4_____4__________C3DMatrix4x4_BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1______SS_I_________C3DGeometry_____C3DDeformerStack_f_____8q16l;
      int v14 = LODWORD(a3);
      C3DNodeApplyChildren((uint64_t)a1, (uint64_t)v13);
    }
  }
}

void C3DApplyScaleFactorOnLight(uint64_t a1, float a2)
{
  double ZNear = C3DLightGetZNear(a1);
  double v5 = a2;
  C3DLightSetZNear(a1, ZNear * v5);
  double v6 = C3DLightGetZFar(a1) * v5;

  C3DLightSetZFar(a1, v6);
}

float64x2_t C3DApplyScaleFactorOnCamera(uint64_t a1, float a2)
{
  float FocusDistance = C3DCameraGetFocusDistance(a1);
  C3DCameraSetFocusDistance(a1, FocusDistance * a2);
  uint64_t ProjectionInfosPtr = C3DCameraGetProjectionInfosPtr(a1);
  float64x2_t result = vmulq_n_f64(*(float64x2_t *)(ProjectionInfosPtr + 8), a2);
  *(float64x2_t *)(ProjectionInfosPtr + _Block_object_dispose(&STACK[0x690], 8) = result;
  return result;
}

uint64_t __C3DApplyScaleFactorOnNode_block_invoke(uint64_t a1, uint64_t a2)
{
  return C3DApplyScaleFactorOnNode(a2, 1, *(float *)(a1 + 32));
}

void C3DApplyScaleFactorOnMesh(uint64_t a1, float32x4_t a2)
{
  PositionSource = C3DMeshGetPositionSource(a1, 0);
  if (PositionSource)
  {
    uint64_t v4 = (uint64_t)PositionSource;
    unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
    Mutableuint64_t Copy = (const void *)C3DMeshSourceCreateMutableCopy(v4);
    uint64_t Count = C3DMeshSourceGetCount((uint64_t)MutableCopy);
    if (Count >= 1)
    {
      uint64_t v8 = Count;
      for (uint64_t i = 0; i != v8; ++i)
      {
        *(double *)v10.i64 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)MutableCopy, i);
        C3DMeshSourceSetValueAtIndexAsVector3((uint64_t)MutableCopy, i, (__n128)vmulq_f32(a2, v10));
      }
    }
    C3DMeshSourceMakeImmutable(MutableCopy);
    C3DMeshSetSourceWithInputSet(a1, MutableCopy, 0, ChannelForSourceWithSemanticAtIndex);
    CFRelease(MutableCopy);
  }
  BOOL v11 = a2.f32[1] != a2.f32[2];
  if (a2.f32[0] != a2.f32[2]) {
    BOOL v11 = 0;
  }
  BOOL v12 = a2.f32[0] == a2.f32[1] && v11;
  NormalSource = C3DMeshGetNormalSource(a1, 0);
  if (!v12)
  {
    uint64_t v14 = (uint64_t)NormalSource;
    if (NormalSource)
    {
      unsigned __int8 v15 = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 1, 0);
      uint64_t v16 = (const void *)C3DMeshSourceCreateMutableCopy(v14);
      uint64_t v17 = C3DMeshSourceGetCount((uint64_t)v16);
      if (v17 >= 1)
      {
        uint64_t v18 = v17;
        uint64_t v19 = 0;
        __asm { FMOV            V0.4S, #1.0 }
        float32x4_t v27 = vdivq_f32(_Q0, a2);
        do
        {
          *(double *)v25.i64 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)v16, v19);
          C3DMeshSourceSetValueAtIndexAsVector3((uint64_t)v16, v19++, (__n128)vmulq_f32(v27, v25));
        }
        while (v18 != v19);
      }
      C3DMeshSourceMakeImmutable(v16);
      C3DMeshSetSourceWithInputSet(a1, v16, 0, v15);
      CFRelease(v16);
    }
  }
}

BOOL C3DGeometryNeedsTexTangent(uint64_t a1, uint64_t *a2)
{
  Materialsuint64_t Count = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount < 1)
  {
    return 0;
  }
  else
  {
    CFArrayRef v5 = MaterialsCount;
    uint64_t v6 = 0;
    BOOL v7 = 1;
    while (1)
    {
      CFArrayRef MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, v6);
      uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
      if (CommonProfile)
      {
        uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 7, 0);
        if (EffectSlot)
        {
          if (C3DEffectSlotHasImageOrTexture(EffectSlot)) {
            break;
          }
        }
      }
      BOOL v7 = ++v6 < (uint64_t)v5;
      if (v5 == (const __CFArray *)v6) {
        return v7;
      }
    }
    if (a2) {
      *a2 = v6;
    }
  }
  return v7;
}

uint64_t C3DGeometryCreateTangentsIfNeeded(uint64_t a1, int a2)
{
  uint64_t v13 = 0;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DGeometryNeedsTexTangent(a1, &v13);
  if (result)
  {
    uint64_t result = C3DGeometryGetMesh(a1);
    if (result) {
      return C3DMeshCreateTangentsIfNeeded(result, a2);
    }
  }
  return result;
}

BOOL C3DMeshIsInterleaved(uint64_t a1)
{
  SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
  if (!SourceWithSemanticAtIndex) {
    return 0;
  }
  uint64_t Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  if (!Accessor) {
    return 0;
  }

  return C3DSourceAccessorIsInterleaved(Accessor);
}

uint64_t C3DMeshCreateCopyWithDeinterleavedSources(uint64_t a1)
{
  uint64_t Copy = C3DMeshCreateCopy(a1);
  unsigned __int8 v3 = 0;
  do
  {
    SourcesCountForSemantiCC_SHA256_CTX c = C3DMeshGetSourcesCountForSemantic(a1, (char)v3);
    if (SourcesCountForSemantic >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = SourcesCountForSemantic;
      do
      {
        SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, (char)v3, v5, 0);
        if (SourceWithSemanticAtIndex)
        {
          Deepuint64_t Copy = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)SourceWithSemanticAtIndex);
          C3DMeshSetSourceWithInputSet(Copy, DeepCopy, v5, 255);
          CFRelease(DeepCopy);
        }
        ++v5;
      }
      while (v6 != v5);
    }
    unsigned int v9 = v3++;
  }
  while (v9 < 8);
  return Copy;
}

uint64_t C3DMeshCreateCopyWithInterleavedSources(uint64_t a1)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __C3DMeshCreateCopyWithInterleavedSources_block_invoke;
  v15[3] = &unk_264004D68;
  float32x4_t v15[4] = &v20;
  void v15[5] = &v16;
  C3DMeshApplySources(a1, 0, (uint64_t)v15);
  uint64_t v2 = v21[3];
  if (v2)
  {
    size_t v3 = v17[3] * v2;
    uint64_t v4 = (const UInt8 *)C3DMalloc(v3);
    CFDataRef v5 = CFDataCreateWithBytesNoCopy(0, v4, v3, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
    uint64_t v11 = 0;
    BOOL v12 = &v11;
    uint64_t v13 = 0x2020000000;
    uint64_t v14 = 0;
    uint64_t v6 = C3DMeshCreate();
    CFArrayRef MeshElements = (const void *)C3DMeshGetMeshElements(a1, 0);
    C3DMeshSetMeshElements(v6, MeshElements);
    v10[0] = 0;
    v10[1] = v10;
    _DWORD v10[2] = 0x2020000000;
    void v10[3] = 0;
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 3221225472;
    v9[2] = __C3DMeshCreateCopyWithInterleavedSources_block_invoke_38;
    v9[3] = &unk_264004D90;
    _OWORD v9[4] = &v11;
    v9[5] = &v16;
    v9[6] = &v20;
    void v9[7] = v10;
    v9[8] = v5;
    v9[9] = v6;
    C3DMeshApplySources(a1, 0, (uint64_t)v9);
    CFRelease((CFTypeRef)v12[3]);
    CFRelease(v5);
    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    uint64_t v6 = 0;
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v6;
}

void sub_20B2E3264(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void __C3DMeshCreateCopyWithInterleavedSources_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Accessor = C3DMeshSourceGetAccessor(a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += C3DSourceAccessorGetValueLength(Accessor);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t Count = C3DMeshSourceGetCount(a2);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  if (v5)
  {
    if (Count != *(void *)(v7 + 24))
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v9 = 0;
        _os_log_impl(&dword_20B249000, v8, OS_LOG_TYPE_DEFAULT, "Warning: Cannot create an interleaved copy, count mismatch", v9, 2u);
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  else
  {
    *(void *)(v7 + 24) = Count;
  }
}

uint64_t __C3DMeshCreateCopyWithInterleavedSources_block_invoke_38(void *a1, uint64_t a2, __int16 a3, uint64_t a4, int a5)
{
  uint64_t Accessor = C3DMeshSourceGetAccessor(a2);
  uint64_t v10 = Accessor;
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    int ComponentsValueType = C3DSourceAccessorGetComponentsValueType(Accessor);
    ComponentsCountPerCFNumberRef Value = C3DSourceAccessorGetComponentsCountPerValue(v10);
    uint64_t v13 = (const void *)C3DSourceAccessorCreate(ComponentsValueType, ComponentsCountPerValue, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24), *(void *)(*(void *)(a1[7] + 8) + 24));
    uint64_t v14 = (const void *)C3DMeshSourceCreateWithAccessor(v13, a3);
    CFRelease(v13);
    C3DSourceAccessorSetSource((uint64_t)v13, *(void *)(*(void *)(a1[4] + 8) + 24));
    C3DMeshSetSourceWithInputSet(a1[9], v14, a4, a5);
    CFRelease(v14);
  }
  else
  {
    unsigned __int8 v15 = (const void *)a1[8];
    int v16 = C3DSourceAccessorGetComponentsValueType(Accessor);
    uint64_t v17 = C3DSourceAccessorGetComponentsCountPerValue(v10);
    *(void *)(*(void *)(a1[4] + 8) + 24) = C3DMeshSourceCreateWithData(a3, v15, v16, v17, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24), *(void *)(*(void *)(a1[7] + 8) + 24));
    uint64_t v13 = (const void *)C3DMeshSourceGetAccessor(*(void *)(*(void *)(a1[4] + 8) + 24));
    C3DMeshSetSourceWithInputSet(a1[9], *(const void **)(*(void *)(a1[4] + 8) + 24), a4, a5);
  }
  C3DSourceAccessorCopyDataToAccessor(v10, (uint64_t)v13, 0);
  uint64_t result = C3DSourceAccessorGetValueLength(v10);
  *(void *)(*(void *)(a1[7] + 8) + 24) += result;
  return result;
}

void C3DGeometryMakeSourcesCheaperWhenRelevant(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Mesh = C3DGeometryGetMesh(a1);
  SourcesCountForSemantiCC_SHA256_CTX c = C3DMeshGetSourcesCountForSemantic(Mesh, 1);
  if (SourcesCountForSemantic >= 1)
  {
    uint64_t v12 = SourcesCountForSemantic;
    for (uint64_t i = 0; i != v12; ++i)
    {
      SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 1, i, 0);
      unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 1, i);
      uint64_t Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
      if (C3DSourceAccessorGetComponentsValueType(Accessor) != 4)
      {
        CopyWithComponentsint BaseType = (const void *)C3DMeshSourceCreateCopyWithComponentsBaseType((uint64_t)SourceWithSemanticAtIndex, 4);
        if (CopyWithComponentsBaseType)
        {
          uint64_t v18 = CopyWithComponentsBaseType;
          C3DMeshSetSourceWithInputSet(Mesh, CopyWithComponentsBaseType, i, ChannelForSourceWithSemanticAtIndex);
          CFRelease(v18);
        }
      }
    }
  }
  uint64_t v19 = C3DMeshGetSourcesCountForSemantic(Mesh, 2);
  if (v19 >= 1)
  {
    uint64_t v20 = v19;
    for (uint64_t j = 0; j != v20; ++j)
    {
      uint64_t v22 = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 2, j, 0);
      unsigned __int8 v23 = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 2, j);
      uint64_t v24 = C3DMeshSourceGetAccessor(v22);
      if (C3DSourceAccessorGetComponentsValueType(v24) != 16)
      {
        float32x4_t v25 = (const void *)C3DMeshSourceCreateCopyWithComponentsBaseType((uint64_t)v22, 16);
        if (v25)
        {
          uint64_t v26 = v25;
          C3DMeshSetSourceWithInputSet(Mesh, v25, j, v23);
          CFRelease(v26);
        }
      }
    }
  }
}

float32x4_t *C3DCreateDefaultCameraNode(__n128 *a1, int a2)
{
  *(uint64_t *)((char *)v41.i64 + 4) = 0;
  v41.i32[0] = 0;
  memset(&v40, 0, sizeof(v40));
  memset(&v39, 0, sizeof(v39));
  float32x4_t v37 = 0u;
  float32x4_t v38 = 0u;
  Rootuint64_t Node = C3DSceneGetRootNode((uint64_t)a1);
  uint64_t v5 = 0;
  if (C3DNodeGetBoundingBoxOmittingFloor(RootNode, &v37, 0))
  {
    float32x4_t v6 = vsubq_f32(v37, v38);
    float32x4_t v7 = vaddq_f32(v37, v38);
    if (a2)
    {
      float32x4_t v8 = vmulq_f32(vsubq_f32(v7, v6), (float32x4_t)vdupq_n_s32(0x3DCCCCCDu));
      float32x4_t v6 = vsubq_f32(v6, v8);
      float32x4_t v7 = vaddq_f32(v7, v8);
    }
    float32x4_t v28 = v6;
    float32x4_t v29 = v7;
    memset(&v36, 0, sizeof(v36));
    C3DNodeGetMatrix(RootNode, (uint64_t)&v36);
    C3DMatrix4x4Invert(&v36, &v39);
    uint64_t v5 = (float32x4_t *)C3DNodeCreate();
    CFDictionaryRef v9 = (const __CFDictionary *)C3DCameraCreate();
    C3DNodeSetCamera((uint64_t)v5, v9);
    C3DEntitySetName((uint64_t)v5, @"default camera");
    CFRelease(v9);
    uint64_t ProjectionInfosPtr = C3DCameraGetProjectionInfosPtr((uint64_t)v9);
    C3DCameraSetFov((uint64_t)v9, 45.0);
    *(double *)v11.i64 = C3DVector3MidVector(v28, v29);
    float32x4_t v27 = v11;
    float32x4_t v42 = v11;
    C3DSceneGetUpAxis(a1, (__n128 *)&v41);
    long long v12 = (__int128)v41;
    uint32x4_t v13 = (uint32x4_t)vceqzq_f32(v41);
    v13.i32[3] = v13.i32[2];
    if ((vminvq_u32(v13) & 0x80000000) != 0)
    {
      long long v12 = xmmword_20B5CB7D0;
      float32x4_t v41 = (float32x4_t)xmmword_20B5CB7D0;
    }
    float32x4_t v43 = v27;
    v14.i64[0] = 0x3F0000003F000000;
    v14.i64[1] = 0x3F0000003F000000;
    float32x4_t v15 = vmulq_f32(vsubq_f32(v29, v28), v14);
    float32x4_t v16 = vmulq_f32(v15, (float32x4_t)vdupq_n_s32(0x401A827Au));
    if (*((float *)&v12 + 1) == 0.0 && *(float *)&v12 == 0.0)
    {
      if (*((float *)&v12 + 2) != 0.0)
      {
        if (v16.f32[0] < v16.f32[2]) {
          v16.f32[0] = v16.f32[2];
        }
        v43.f32[1] = v27.f32[1] - (float)(v15.f32[1] + v16.f32[0]);
      }
    }
    else
    {
      if (v16.f32[0] < v16.f32[1]) {
        v16.f32[0] = v16.f32[1];
      }
      v43.f32[2] = (float)(v15.f32[2] + v16.f32[0]) + v27.f32[2];
    }
    C3DMatrix4x4MakeLookAt((int32x4_t *)&v40, &v43, &v42, &v41);
    C3DMatrix4x4Invert(&v40, &v40);
    if (a2)
    {
      memset(v33, 0, sizeof(v33));
      memset(v32, 0, sizeof(v32));
      memset(v31, 0, sizeof(v31));
      memset(v30, 0, sizeof(v30));
      float32x4_t v35 = vnegq_f32(v42);
      if (v41.f32[1] != 0.0 || v41.f32[2] == 0.0) {
        long long v17 = xmmword_20B5CB7E0;
      }
      else {
        long long v17 = xmmword_20B5CB7F0;
      }
      long long v34 = v17;
      C3DMatrix4x4MakeTranslation((uint64_t)v33, (__n128 *)&v42);
      C3DMatrix4x4MakeEulerRotation(v32, &v34);
      C3DMatrix4x4MakeTranslation((uint64_t)v31, (__n128 *)&v35);
      C3DMatrix4x4Mult((uint64_t)v31, v32, v30);
      C3DMatrix4x4Mult((uint64_t)v30, v33, v30);
      C3DMatrix4x4Mult((uint64_t)&v40, v30, &v40);
    }
    C3DMatrix4x4Mult((uint64_t)&v40, (float32x4_t *)&v39, &v40);
    C3DNodeSetMatrix(v5, (uint64_t)&v40);
    float32x4_t v18 = v42;
    if (v41.f32[1] == 0.0 && v41.f32[0] == 0.0) {
      v18.i32[1] = v28.i32[1];
    }
    else {
      v18.i32[2] = v28.i32[2];
    }
    float32x4_t v19 = vsubq_f32(v43, v18);
    float32x4_t v20 = vmulq_f32(v19, v19);
    float v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]);
    float32x4_t v22 = vsubq_f32(v43, v29);
    float32x4_t v23 = vmulq_f32(v22, v22);
    float v24 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]);
    if (v21 != 0.0 && v24 != 0.0 && (float)(v24 / v21) < 250.0)
    {
      float v25 = sqrt((float)(v24 / v21) / 250.0);
      float v21 = v21 * v25;
      float v24 = v24 / v25;
    }
    C3DProjectionInfosSetZFar(ProjectionInfosPtr, v24);
    C3DProjectionInfosSetZNear(ProjectionInfosPtr, v21);
  }
  return v5;
}

uint64_t C3DComputeFrustumPlanesFromNode(float32x4_t *a1, float32x4_t *a2, __n128 a3)
{
  __n128 v39 = a3;
  memset(v38, 0, sizeof(v38));
  uint64_t ProjectionInfos = C3DNodeGetProjectionInfos((uint64_t)a1, (uint64_t)v38);
  if (ProjectionInfos)
  {
    memset(&v37, 0, sizeof(v37));
    C3DNodeComputeWorldMatrix(a1, (uint64_t)&v37);
    C3DMatrix4x4Invert(&v37, &v37);
    Matrix = (float32x4_t *)C3DProjectionInfosGetMatrix((char *)v38, (uint64_t)&v39, 0);
    C3DMatrix4x4Mult((uint64_t)&v37, Matrix, &v37);
    float v8 = v37.columns[0].f32[2];
    float v7 = v37.columns[1].f32[2];
    float v10 = v37.columns[2].f32[2];
    float v9 = v37.columns[3].f32[2];
    float v11 = v37.columns[0].f32[3];
    v12.f32[0] = v37.columns[0].f32[3] - v37.columns[0].f32[0];
    float v13 = v37.columns[1].f32[3];
    float v14 = v37.columns[2].f32[3];
    float v15 = v37.columns[3].f32[3];
    v12.f32[1] = v37.columns[1].f32[3] - v37.columns[1].f32[0];
    v12.f32[2] = v37.columns[2].f32[3] - v37.columns[2].f32[0];
    v12.f32[3] = v37.columns[3].f32[3] - v37.columns[3].f32[0];
    float32x4_t v16 = vmulq_f32(v12, v12);
    v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v16, 2), vadd_f32(*(float32x2_t *)v16.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.f32, 1))).u32[0];
    float32x2_t v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
    float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
    float32x4_t v19 = vmulq_n_f32(v12, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]);
    v16.f32[0] = v37.columns[0].f32[3] + v37.columns[0].f32[0];
    v16.f32[1] = v37.columns[1].f32[3] + v37.columns[1].f32[0];
    v16.f32[2] = v37.columns[2].f32[3] + v37.columns[2].f32[0];
    v16.f32[3] = v37.columns[3].f32[3] + v37.columns[3].f32[0];
    int32x4_t v20 = (int32x4_t)vmulq_f32(v16, v16);
    v20.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v20, 2), vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v20.i8, 1))).u32[0];
    float32x2_t v21 = vrsqrte_f32((float32x2_t)v20.u32[0]);
    *(float32x2_t *)v22.f32 = vmul_f32(v21, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(v21, v21)));
    float32x4_t v23 = vmulq_n_f32(v16, vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32))).f32[0]);
    v20.i32[0] = v37.columns[0].i32[1];
    v22.f32[0] = v37.columns[0].f32[3] + v37.columns[0].f32[1];
    float v24 = v37.columns[1].f32[1];
    float v25 = v37.columns[2].f32[1];
    float v26 = v37.columns[3].f32[1];
    v22.f32[1] = v37.columns[1].f32[3] + v37.columns[1].f32[1];
    v22.f32[2] = v37.columns[2].f32[3] + v37.columns[2].f32[1];
    v22.f32[3] = v37.columns[3].f32[3] + v37.columns[3].f32[1];
    int32x4_t v27 = (int32x4_t)vmulq_f32(v22, v22);
    *a2 = v19;
    a2[1] = v23;
    v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
    *(float32x2_t *)v23.f32 = vrsqrte_f32((float32x2_t)v19.u32[0]);
    *(float32x2_t *)v23.f32 = vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32)));
    float32x4_t v28 = vmulq_n_f32(v22, vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32))).f32[0]);
    v23.f32[0] = v11 - *(float *)v20.i32;
    v23.f32[1] = v13 - v24;
    v23.f32[2] = v14 - v25;
    v23.f32[3] = v15 - v26;
    float32x4_t v29 = vmulq_f32(v23, v23);
    v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v29, 2), vadd_f32(*(float32x2_t *)v29.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
    *(float32x2_t *)v22.f32 = vrsqrte_f32((float32x2_t)v29.u32[0]);
    *(float32x2_t *)v22.f32 = vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32)));
    float32x4_t v30 = vmulq_n_f32(v23, vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32))).f32[0]);
    v29.f32[0] = v11 - v8;
    v29.f32[1] = v13 - v7;
    v29.f32[2] = v14 - v10;
    v29.f32[3] = v15 - v9;
    int32x4_t v31 = (int32x4_t)vmulq_f32(v29, v29);
    a2[2] = v28;
    a2[3] = v30;
    v28.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))).u32[0];
    *(float32x2_t *)v30.f32 = vrsqrte_f32((float32x2_t)v28.u32[0]);
    *(float32x2_t *)v30.f32 = vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32)));
    v32.f32[0] = v11 + v8;
    v32.f32[1] = v13 + v7;
    v32.f32[2] = v14 + v10;
    v32.f32[3] = v15 + v9;
    int32x4_t v33 = (int32x4_t)vmulq_f32(v32, v32);
    v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
    float32x2_t v34 = vrsqrte_f32((float32x2_t)v33.u32[0]);
    float32x2_t v35 = vmul_f32(v34, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v34, v34)));
    a2[4] = vmulq_n_f32(v29, vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32))).f32[0]);
    a2[5] = vmulq_n_f32(v32, vmul_f32(v35, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v35, v35))).f32[0]);
  }
  return ProjectionInfos;
}

void C3DAdjustZRangeOfProjectionInfos(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a2 && a4)
  {
    Rootuint64_t Node = C3DSceneGetRootNode(a4);
    if (RootNode)
    {
      long long v43 = 0u;
      float32x4_t v44 = 0u;
      char v42 = 0;
      if (C3DNodeGetBoundingBoxOmittingFloor(RootNode, &v43, (uint64_t)&v42))
      {
        v41.i32[2] = 0;
        v41.i64[0] = 0;
        WorldMatrix = C3DNodeGetWorldMatrix(a2);
        if (WorldMatrix)
        {
          float v8 = WorldMatrix;
          C3DMatrix4x4GetAffineTransforms((uint64_t)WorldMatrix, &v41, 0, 0);
          float32x4_t v9 = *v8;
          float32x4_t v10 = v8[1];
          float32x4_t v11 = v8[3];
          float32x4_t v47 = v8[2];
          float32x4_t v48 = v11;
          float32x4_t v45 = v9;
          float32x4_t v46 = v10;
          *(double *)v12.i64 = C3DVector3Rotate((float32x2_t *)&v45, (float32x4_t)xmmword_20B5CB810);
          uint64_t v13 = 0;
          v14.f32[0] = *(float *)&v43 - v44.f32[0];
          float32x4_t v15 = v14;
          v15.f32[1] = *((float *)&v43 + 1) - v44.f32[1];
          float32x4_t v16 = v15;
          v16.f32[2] = *((float *)&v43 + 2) - v44.f32[2];
          float v17 = 3.4028e38;
          float v18 = -3.4028e38;
          v15.f32[2] = *((float *)&v43 + 2) + v44.f32[2];
          v14.f32[1] = *((float *)&v43 + 1) + v44.f32[1];
          float32x4_t v19 = v14;
          v19.f32[2] = *((float *)&v43 + 2) - v44.f32[2];
          v14.f32[2] = *((float *)&v43 + 2) + v44.f32[2];
          float32x4_t v45 = v16;
          float32x4_t v46 = v15;
          *(float *)&long long v20 = *(float *)&v43 + v44.f32[0];
          long long v21 = v20;
          *((float *)&v21 + 1) = *((float *)&v43 + 1) - v44.f32[1];
          float32x4_t v47 = v19;
          float32x4_t v48 = v14;
          long long v22 = v21;
          *((float *)&v22 + 2) = *((float *)&v43 + 2) - v44.f32[2];
          *((float *)&v21 + 2) = *((float *)&v43 + 2) + v44.f32[2];
          *((float *)&v20 + 1) = *((float *)&v43 + 1) + v44.f32[1];
          long long v23 = v20;
          *((float *)&v23 + 2) = *((float *)&v43 + 2) - v44.f32[2];
          long long v49 = v22;
          long long v50 = v21;
          *((float *)&v20 + 2) = *((float *)&v43 + 2) + v44.f32[2];
          long long v51 = v23;
          long long v52 = v20;
          do
          {
            float32x4_t v24 = vmulq_f32(v12, vsubq_f32(*(float32x4_t *)((char *)&v45 + v13), v41));
            float v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
            if (v25 < v17) {
              float v17 = v25;
            }
            float v26 = fabsf(v25);
            if (v26 >= v18) {
              float v18 = v26;
            }
            v13 += 16;
          }
          while (v13 != 128);
          int8x16_t v27 = (int8x16_t)vmulq_f32(v44, v44);
          *(float *)v27.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL))));
          float v28 = *(float *)v27.i32 + *(float *)v27.i32;
          float v29 = v17 + v17 * -0.05;
          float v30 = v18 + v18 * 0.05;
          if (v28 <= v30) {
            float v28 = v18 + v18 * 0.05;
          }
          double v31 = fmax(v28 * 0.0001, 0.001);
          if (v31 > 1.0) {
            double v31 = 1.0;
          }
          float v32 = v31;
          if (v32 < v29) {
            float v32 = v29;
          }
          if (v32 <= v30) {
            float v33 = v18 + v18 * 0.05;
          }
          else {
            float v33 = v32;
          }
          if (v42) {
            float v33 = v33 + v33;
          }
          double v34 = v33;
          double v35 = v33 * 0.01;
          if (v35 <= v32) {
            float v36 = v35;
          }
          else {
            float v36 = v32;
          }
          if (v36 > v33)
          {
            simd_float4x4 v37 = scn_default_log();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
              C3DAdjustZRangeOfProjectionInfos_cold_3(v37, v36, v34);
            }
          }
          *(double *)(a1 + _Block_object_dispose(&STACK[0x690], 8) = v36;
          *(double *)(a1 + 16) = v34;
        }
        else
        {
          simd_float4x4 v40 = scn_default_log();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
            C3DAdjustZRangeOfProjectionInfos_cold_2();
          }
        }
      }
      else if ((*(unsigned char *)a1 & 4) != 0)
      {
        *(_OWORD *)(a1 + _Block_object_dispose(&STACK[0x690], 8) = xmmword_20B5CB800;
      }
    }
    else
    {
      __n128 v39 = scn_default_log();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        C3DAdjustZRangeOfProjectionInfos_cold_1();
      }
    }
  }
  else
  {
    float32x4_t v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      C3DAdjustZRangeOfProjectionInfos_cold_4();
    }
  }
}

float32x4_t C3DComputeMirrorPlane(float32x4_t *a1, float32x4_t *a2, __n128 *a3)
{
  long long v20 = 0u;
  long long v21 = 0u;
  float32x4_t v18 = 0u;
  long long v19 = 0u;
  C3DNodeComputeWorldMatrix(a1, (uint64_t)&v18);
  float32x4_t v14 = v18;
  long long v15 = v19;
  long long v16 = v20;
  long long v17 = v21;
  *(double *)v5.i64 = C3DVector3MultMatrix4x4(&v14, (float32x4_t)0);
  float32x4_t v13 = v5;
  float32x4_t v6 = *a2;
  float32x4_t v14 = v18;
  long long v15 = v19;
  long long v16 = v20;
  long long v17 = v21;
  *(float32x2_t *)v7.f32 = C3DVector3RotateAndScale((float32x2_t *)&v14, v6);
  int32x4_t v8 = (int32x4_t)vmulq_f32(v7, v7);
  v8.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))).u32[0];
  float32x2_t v9 = vrsqrte_f32((float32x2_t)v8.u32[0]);
  float32x2_t v10 = vmul_f32(v9, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v9, v9)));
  float32x4_t result = vmulq_n_f32(v7, vmul_f32(v10, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v10, v10))).f32[0]);
  float32x4_t v11 = vmulq_f32(v13, result);
  result.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
  *a3 = (__n128)result;
  return result;
}

__n128 C3DComputeMirrorMatrix(__n128 *a1, float32x4_t *a2, uint64_t a3)
{
  v21.n128_u32[2] = 0;
  v21.n128_u64[0] = 0;
  C3DSceneGetUpAxis(a1, &v21);
  float32x4_t v20 = 0uLL;
  C3DComputeMirrorPlane(a2, (float32x4_t *)&v21, (__n128 *)&v20);
  _Q0 = v20;
  float32x4_t v6 = vnegq_f32(v20);
  _S2 = vmuls_lane_f32(-2.0, v6, 2);
  _D5 = vmul_f32(*(float32x2_t *)v6.f32, (float32x2_t)0xC0000000C0000000);
  __asm { FMLS            S6, S5, V0.S[0] }
  _S7 = _D5.i32[1];
  HIDWORD(v15) = 0;
  *(void *)&long long v15 = __PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(v6.f32[0], _D5, 1)), _S6);
  *((float *)&v15 + 2) = _S2 * v6.f32[0];
  __asm { FMLS            S16, S7, V0.S[1] }
  *(void *)&_Q6 = __PAIR64__(_S16, COERCE_UNSIGNED_INT(vmuls_lane_f32(_D5.f32[0], *(float32x2_t *)v6.f32, 1)));
  *((void *)&_Q6 + 1) = COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, *(float32x2_t *)v6.f32, 1));
  *(_OWORD *)a3 = v15;
  *(_OWORD *)(a3 + 16) = _Q6;
  *(float32x2_t *)&long long v18 = vmul_laneq_f32(_D5, v6, 2);
  __asm { FMLS            S6, S2, V0.S[2] }
  *((void *)&v18 + 1) = _Q6;
  result.n128_u64[0] = (unint64_t)vmul_laneq_f32(_D5, v6, 3);
  result.n128_u64[1] = __PAIR64__(1.0, COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, v6, 3)));
  *(_OWORD *)(a3 + 32) = v18;
  *(__n128 *)(a3 + 4_Block_object_dispose(&STACK[0x690], 8) = result;
  return result;
}

char *C3DSizeForScreenSpaceSizeAndTransform(__n128 *a1)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a1);
  if (RendererContextGL) {
    C3DRendererContextGetContentScaleFactor(RendererContextGL);
  }
  uint64_t RenderContext = C3DEngineContextGetRenderContext((uint64_t)a1);
  if (RenderContext) {
    -[SCNMTLRenderContext contentScaleFactor](RenderContext);
  }
  __n128 Viewport = C3DEngineContextGetViewport(a1);
  memset(v12, 0, sizeof(v12));
  PointOfView = C3DEngineContextGetPointOfView((uint64_t)a1);
  char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a1);
  if (PointOfView
    && (char v6 = CoordinatesSystemOptions, C3DNodeGetProjectionInfos((uint64_t)PointOfView, (uint64_t)v12)))
  {
    *(void *)&long long v7 = 0;
    *((void *)&v7 + 1) = vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL).u64[0];
    long long v11 = v7;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfView);
    v13.columns[0] = (simd_float4)*WorldMatrix;
    v13.columns[1] = (simd_float4)WorldMatrix[1];
    v13.columns[2] = (simd_float4)WorldMatrix[2];
    v13.columns[3] = (simd_float4)WorldMatrix[3];
    __invert_f4(v13);
    return C3DProjectionInfosGetMatrix((char *)v12, (uint64_t)&v11, v6);
  }
  else
  {
    C3DEngineContextGetMatrix4x4((uint64_t)a1, 1);
    return (char *)C3DEngineContextGetMatrix4x4((uint64_t)a1, 0);
  }
}

float32x4_t *C3DSetupHaltonFilterKernelConic(float32x4_t *result, int a2, float a3, float a4, float a5)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; result[i++] = v16)
    {
      if (i)
      {
        float v6 = 0.5;
        float v7 = 0.0;
        unsigned int v8 = i;
        do
        {
          if (v8) {
            float v9 = v6;
          }
          else {
            float v9 = -0.0;
          }
          float v7 = v7 + v9;
          float v6 = v6 * 0.5;
          BOOL v10 = v8 > 1;
          v8 >>= 1;
        }
        while (v10);
        float v11 = 0.0;
        int v12 = i;
        float v13 = 0.33333;
        do
        {
          if (v12 != 3 * (v12 / 3)) {
            float v11 = v11 + (float)((float)(v12 % 3) * v13);
          }
          float v13 = v13 * 0.33333;
          unsigned int v14 = v12 + 2;
          v12 /= 3;
        }
        while (v14 >= 5);
        float32_t v15 = (float)((float)(v7 * 2.0) + -1.0) * a3;
        float32x4_t v16 = result[i];
        v16.f32[0] = v15;
        v16.f32[1] = (float)((float)(v11 * 2.0) + -1.0) * a4;
      }
      else
      {
        v16.i64[0] = 0;
        v16.i64[1] = result->i64[1];
        *__n128 result = v16;
      }
      v16.i64[1] = COERCE_UNSIGNED_INT(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmulq_f32(v16, v16).i32[1]), v16.f32[0], v16.f32[0])) * a5);
    }
  }
  return result;
}

uint64_t C3DEngineContextEvaluateProgram(uint64_t a1, void *a2, __C3DGeometry *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FXContext = (void *)C3DEngineContextGetFXContext(a1);
  CurrentPassuint64_t Instance = (unsigned __int8 *)C3DFXContextGetCurrentPassInstance(FXContext);
  uint64_t v12 = CurrentPassInstance[24];
  unsigned __int8 v13 = CurrentPassInstance[27];
  unsigned __int8 v14 = CurrentPassInstance[28];
  if (C3DMeshGetElementsCount(a4)) {
    uint64_t ElementAtIndex = C3DMeshGetElementAtIndex(a4, 0, 1);
  }
  else {
    uint64_t ElementAtIndex = 0;
  }
  float32x4_t v16 = (const void *)C3DProgramHashCodeCreate(a2, a3, a4, (uint64_t)ElementAtIndex, 0, a5, ((unint64_t)((8 * (v13 & 3)) & 0x9F | (32 * (v14 & 3u))) << 24) | (v12 << 16));
  uint64_t CommonProfile = C3DMaterialGetCommonProfile(a5);
  uint64_t v18 = C3DEngineContextEvaluateProgramWithHashCode(a1, (uint64_t)v16, CommonProfile, 0);
  CFRelease(v16);
  return v18;
}

uint64_t C3DMeshElementCreateIntervalList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  MEMORY[0x270FA5388](a1);
  float v7 = &v45 - 2 * v6;
  if (v6 < 1) {
    return 0;
  }
  unsigned int v8 = 0;
  uint64_t v9 = 0;
  BOOL v10 = v7 + 1;
  do
  {
    *(v10 - 1) = C3DMeshSourceGetContent(*(void *)(a1 + 8 * v9));
    void *v10 = v11;
    if (v8)
    {
      if (v8 != v11)
      {
        float v36 = scn_default_log();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          C3DMeshElementCreateIntervalList_cold_1();
        }
        return 0;
      }
    }
    else
    {
      unsigned int v8 = v11;
    }
    ++v9;
    v10 += 2;
  }
  while (a2 != v9);
  if (!v8) {
    return 0;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  long long v49 = (unsigned __int8 *)v7;
  uint64_t v18 = (unsigned __int8 *)v7 + 13;
  char v19 = 1;
  do
  {
    if (a2 < 1)
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v20 = 0;
      __n128 v21 = v18;
      while (1)
      {
        v22.i64[0] = COERCE_UNSIGNED_INT64(C3DConvertFloatingTypeToFloat4(*(v21 - 1), (float *)(*(void *)(v21 - 13) + v17 * *v21), v12, v13.f32[0], v14)) & 0x7FFFFFFF7FFFFFFFLL;
        v22.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v13.i64[0] = 0x3400000034000000;
        v13.i64[1] = 0x3400000034000000;
        float32x4_t v12 = (float32x4_t)vcgeq_f32(v22, v13);
        v12.i32[0] = vmaxvq_u32((uint32x4_t)v12);
        if (v12.i32[0] < 0) {
          break;
        }
        ++v20;
        v21 += 16;
        if (a2 == v20) {
          goto LABEL_17;
        }
      }
    }
    if (v20 == a2)
    {
LABEL_17:
      v19 |= v15++ > a3;
    }
    else
    {
      uint64_t v15 = 0;
      v16 += v19 & 1;
      char v19 = 0;
    }
    ++v17;
  }
  while (v17 != v8);
  if (!v16) {
    return 0;
  }
  if (v8 >= 0xFFFF) {
    int v23 = 4;
  }
  else {
    int v23 = 2;
  }
  char v24 = 1;
  if (v8 >= 0xFFFF) {
    char v24 = 2;
  }
  size_t v25 = 2 * (v16 << v24);
  float32x4_t v48 = (UInt8 *)malloc_type_malloc(v25, 0x945ACAA9uLL);
  CFIndex v46 = v25;
  int v47 = v23;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  v49 += 13;
  char v32 = 1;
  do
  {
    if (a2 < 1)
    {
      uint64_t v33 = 0;
    }
    else
    {
      uint64_t v33 = 0;
      double v34 = v49;
      while (1)
      {
        v35.i64[0] = COERCE_UNSIGNED_INT64(C3DConvertFloatingTypeToFloat4(*(v34 - 1), (float *)(*(void *)(v34 - 13) + v29 * *v34), v26, v27.f32[0], v28)) & 0x7FFFFFFF7FFFFFFFLL;
        v35.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v27.i64[0] = 0x3400000034000000;
        v27.i64[1] = 0x3400000034000000;
        float32x4_t v26 = (float32x4_t)vcgeq_f32(v35, v27);
        v26.i32[0] = vmaxvq_u32((uint32x4_t)v26);
        if (v26.i32[0] < 0) {
          break;
        }
        ++v33;
        v34 += 16;
        if (a2 == v33) {
          goto LABEL_34;
        }
      }
    }
    if (v33 == a2)
    {
LABEL_34:
      if (!(v32 & 1 | (v30 <= a3)))
      {
        if (v8 > 0xFFFE) {
          *(_DWORD *)&v48[8 * v31 + 4] = v29 - v30;
        }
        else {
          *(_WORD *)&v48[4 * v31 + 2] = v29 - v30;
        }
        ++v31;
        char v32 = 1;
      }
      ++v30;
    }
    else if (v32)
    {
      uint64_t v30 = 0;
      char v32 = 0;
      if (v8 > 0xFFFE) {
        *(_DWORD *)&v48[8 * v31] = v29;
      }
      else {
        *(_WORD *)&v48[4 * v31] = v29;
      }
    }
    else
    {
      uint64_t v30 = 0;
      char v32 = 0;
    }
    ++v29;
  }
  while (v29 != v8);
  if (v32)
  {
    char v40 = v47;
    CFIndex v41 = v46;
  }
  else
  {
    uint64_t v42 = (2 * v31) | 1;
    if (v8 > 0xFFFE) {
      *(_DWORD *)&v48[4 * v42] = v8 - v30;
    }
    else {
      *(_WORD *)&v48[2 * v42] = v8 - v30;
    }
    char v40 = v47;
    CFIndex v41 = v46;
    LODWORD(v31) = v31 + 1;
  }
  long long v43 = v48;
  CFDataRef v44 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v48, v41);
  free(v43);
  uint64_t v38 = C3DMeshElementCreate();
  C3DMeshElementSetType(v38, 2);
  C3DMeshElementSetPrimitives(v38, v31, v44, v40);
  CFRelease(v44);
  return v38;
}

void C3DMeshSourceContentClassifyRay(uint64_t a1, uint64_t a2, unsigned char *a3, float32x4_t a4, __n128 a5, double a6, int8x16_t a7, int8x16_t a8)
{
  a7.i32[0] = a5.n128_i32[2];
  a8.i32[0] = 1.0;
  v12.i64[0] = 0x8000000080000000;
  v12.i64[1] = 0x8000000080000000;
  v12.i32[0] = vbslq_s8(v12, a8, a7).i32[0];
  float v13 = a5.n128_f32[1] / (float)(fabsf(a5.n128_f32[2]) + 1.0);
  float v14 = vmuls_lane_f32(v13, (float32x2_t)a5.n128_u64[0], 1);
  v8.f32[0] = -(float)(a5.n128_f32[0] * v13);
  v9.f32[0] = a5.n128_f32[2] + (float)(*(float *)v12.i32 * v14);
  v21.f32[0] = *(float *)v12.i32 * v8.f32[0];
  float32x4_t v15 = v9;
  v15.f32[1] = *(float *)v12.i32 * v8.f32[0];
  v23.f32[0] = -a5.n128_f32[0];
  v15.f32[2] = -a5.n128_f32[0];
  float32_t v16 = 1.0 - v14;
  v20.f32[1] = -v9.f32[0];
  v20.f32[2] = v8.f32[0];
  v8.f32[1] = 1.0 - v14;
  v8.i32[2] = vmuls_lane_f32(-*(float *)v12.i32, (float32x2_t)a5.n128_u64[0], 1);
  float32x4_t v17 = vmulq_f32(a4, v15);
  float v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
  v24.f32[0] = -v18;
  float32x4_t v19 = vmulq_f32(a4, v8);
  v19.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0];
  v20.f32[3] = -(float)(v13 * (float)-a5.n128_f32[0]);
  v21.f32[1] = -(float)(*(float *)v12.i32 * v8.f32[0]);
  v21.f32[2] = v16;
  v21.f32[3] = -v16;
  float v22 = -(float)(a5.n128_f32[1] * (float)-*(float *)v12.i32);
  v23.i32[1] = a5.n128_u32[0];
  v23.i32[2] = v8.i32[2];
  v23.f32[3] = v22;
  v24.f32[1] = v18;
  v24.f32[2] = -v19.f32[0];
  v24.i32[3] = v19.i32[0];
  uint64_t v25 = a2;
  if ((a2 & 0xFF000000000000) == 0x1000000000000)
  {
    if (a2)
    {
      uint64_t v26 = 0;
      float32x4_t v27 = vnegq_f32(v24);
      do
      {
        int8x16_t v28 = (int8x16_t)vcgtq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v21, *(float *)(a1 + v26 + 4)), v20, *(float *)(a1 + v26)), v23, *(float *)(a1 + v26 + 8)), v27);
        int8x8_t v29 = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), (int8x8_t)0x800000004);
        *a3++ = v28.i8[4] & 2 | (v28.i32[0] < 0) | v29.i8[0] | v29.i8[4];
        v26 += BYTE5(a2);
        --v25;
      }
      while (v25);
    }
  }
  else if (a2)
  {
    unsigned int v30 = 0;
    int v31 = BYTE4(a2);
    int v32 = BYTE5(a2);
    float32x4_t v33 = vnegq_f32(v24);
    float32x4_t v35 = v33;
    float32x4_t v37 = v21;
    float32x4_t v38 = v20;
    float32x4_t v36 = v23;
    do
    {
      *(double *)v34.i64 = C3DConvertFloatingTypeToFloat4(v31, (float *)(a1 + v30), v33, a5.n128_f32[0], v22);
      float32x4_t v33 = (float32x4_t)vcgtq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v37, *(float32x2_t *)v34.f32, 1), v38, v34.f32[0]), v36, v34, 2), v35);
      a5.n128_u64[0] = (unint64_t)vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL), (int8x8_t)0x800000004);
      *a3++ = v33.i8[4] & 2 | (v33.i32[0] < 0) | a5.n128_u8[0] | a5.n128_u8[4];
      v30 += v32;
      --v25;
    }
    while (v25);
  }
}

void __MergeRendererElementsSharingSameMaterial(void *a1, CFArrayRef theArray, uint64_t a3)
{
  *(void *)&v53[5] = *MEMORY[0x263EF8340];
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    uint64_t v7 = Count;
    uint64_t v8 = *(void *)CFArrayGetValueAtIndex(theArray, 0);
    BOOL DoubleSided = C3DMeshElementGetDoubleSided(v8);
    int Type = C3DMeshElementGetType(v8);
    if (Type == 2) {
      uint64_t v11 = 2;
    }
    else {
      uint64_t v11 = 3;
    }
    uint64_t bytes = v11;
    if (*(unsigned char *)(a3 + 8))
    {
      char v48 = DoubleSided;
      int v51 = Type;
      if (v7 < 1)
      {
        uint64_t v14 = 0;
        uint64_t v12 = 0;
      }
      else
      {
        uint64_t v12 = 0;
        CFIndex v13 = 0;
        uint64_t v14 = 0;
        do
        {
          CFStringRef ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(theArray, v13);
          if ((void *)ValueAtIndex[2] != a1)
          {
            float32_t v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
              __MergeRendererElementsSharingSameMaterial_cold_1(v52, v53, v16);
            }
          }
          uint64_t v17 = *ValueAtIndex;
          PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount(*ValueAtIndex);
          if (v13 < v7 - 1 && v51 == 1)
          {
            if (C3DMeshElementGetPrimitiveCount(v17)) {
              v14 += 3;
            }
            else {
              v14 += 2;
            }
          }
          v12 += PrimitiveCount;
          ++v13;
        }
        while (v7 != v13);
      }
      uint64_t v30 = v14 + 2 * v7 + v12;
      if (v51 == 1)
      {
        int v31 = v30 - 2;
      }
      else
      {
        uint64_t v30 = v12 * bytes;
        int v31 = v12;
      }
      CFIndex length = v30 * *(unsigned int *)(a3 + 12);
      int v47 = v31;
      bytesSCNMatrix4 a = (UInt8 *)C3DMalloc(length);
      if (v7 >= 1)
      {
        CFIndex v32 = 0;
        uint64_t v33 = (uint64_t)bytesa;
        do
        {
          float32x4_t v34 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v32);
          uint64_t v35 = *v34;
          int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v34);
          __int16 appended = (char *)__AppendIndexes(v33, v35, Value, *(_DWORD *)(a3 + 12));
          uint64_t v33 = (uint64_t)appended;
          if (v51 == 1 && v32 < v7 - 1)
          {
            memcpy(appended, &appended[-*(unsigned int *)(a3 + 12)], *(unsigned int *)(a3 + 12));
            float32x4_t v38 = (_WORD *)(v33 + *(unsigned int *)(a3 + 12));
            if (C3DMeshElementGetPrimitiveCount(v35))
            {
              memcpy(v38, (char *)v38 - *(unsigned int *)(a3 + 12), *(unsigned int *)(a3 + 12));
              float32x4_t v38 = (_WORD *)((char *)v38 + *(unsigned int *)(a3 + 12));
            }
            __n128 v39 = (uint64_t *)CFArrayGetValueAtIndex(theArray, ++v32);
            uint64_t v40 = *v39;
            unsigned int v41 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v39);
            int v42 = *(_DWORD *)(a3 + 12);
            if (v42 == 2)
            {
              *float32x4_t v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            else if (v42 == 4)
            {
              *(_DWORD *)float32x4_t v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            else
            {
              *(unsigned char *)float32x4_t v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            uint64_t v33 = (uint64_t)v38 + *(unsigned int *)(a3 + 12);
          }
          else
          {
            ++v32;
          }
        }
        while (v32 != v7);
      }
      CFDataRef v43 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], bytesa, length, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
      CFDataRef v44 = (const void *)C3DMeshElementCreate();
      C3DMeshElementSetDoubleSided((uint64_t)v44, v48);
      C3DMeshElementInit((uint64_t)v44, v51, v47, v43, *(_DWORD *)(a3 + 12));
      CFRelease(v43);
      uint64_t Mesh = C3DGeometryGetMesh(*(void *)a3);
      C3DMeshAppendElement(Mesh, v44);
      CFRelease(v44);
      if (a1) {
        C3DGeometryAppendMaterial(*(void *)a3, a1);
      }
    }
    else if (v7 >= 1)
    {
      CFIndex v19 = 0;
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      do
      {
        float32x4_t v21 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v19);
        uint64_t v22 = *v21;
        uint64_t v23 = C3DMeshElementGetPrimitiveCount(*v21) * bytes * *(unsigned int *)(a3 + 12);
        float32x4_t v24 = (const UInt8 *)C3DMalloc(v23);
        int v25 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v21);
        __AppendIndexes((uint64_t)v24, v22, v25, *(_DWORD *)(a3 + 12));
        uint64_t Copy = (const void *)C3DMeshElementCreateCopy(v22);
        CFDataRef v27 = CFDataCreateWithBytesNoCopy(v20, v24, v23, v20);
        int v28 = C3DMeshElementGetPrimitiveCount((uint64_t)Copy);
        C3DMeshElementSetPrimitives((uint64_t)Copy, v28, v27, *(_DWORD *)(a3 + 12));
        CFRelease(v27);
        uint64_t v29 = C3DGeometryGetMesh(*(void *)a3);
        C3DMeshAppendElement(v29, Copy);
        CFRelease(Copy);
        if (a1) {
          C3DGeometryAppendMaterial(*(void *)a3, a1);
        }
        ++v19;
      }
      while (v7 != v19);
    }
    __DestroyFlattenElementsArray(theArray);
  }
}