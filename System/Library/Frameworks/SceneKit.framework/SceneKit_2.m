uint64_t C3DASTCIsSupported()
{
  if (C3DMetalIsSupported_onceToken != -1) {
    dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
  }
  return kASTCIsSupported;
}

void _SCNSetLinearRenderingEnabled(int a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (C3DLinearRenderingIsEnabled_onceToken != -1) {
    dispatch_once(&C3DLinearRenderingIsEnabled_onceToken, &__block_literal_global_231);
  }
  v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    v4[0] = 67109120;
    v4[1] = a1;
    _os_log_impl(&dword_20B249000, v2, OS_LOG_TYPE_INFO, "Info: linear rendering forced to %d", (uint8_t *)v4, 8u);
  }
  if (a1)
  {
    if (C3DMetalIsSupported_onceToken != -1) {
      dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
    }
    BOOL v3 = C3DMetalIsSupported_supported != 0;
  }
  else
  {
    BOOL v3 = 0;
  }
  _gC3DEnableLinearRendering = v3;
}

uint64_t C3DDeduceSphericalHarmonicsOrderFromDataLength(unint64_t a1)
{
  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DDeduceSphericalHarmonicsOrderFromDataLength_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = sqrt((double)(a1 / 0xC));
  if (12 * (v10 * v10) != a1)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DDeduceSphericalHarmonicsOrderFromDataLength_cold_1();
    }
  }
  return v10;
}

float C3DComputeGaussianProbability(float a1, float a2)
{
  return (float)(1.0 / (float)(a2 * 2.5066)) * expf((float)-(float)(a1 * a1) / (float)((float)(a2 + a2) * a2));
}

uint64_t C3DIsRunningInXcode()
{
  if (C3DIsRunningInXcode_onceToken != -1) {
    dispatch_once(&C3DIsRunningInXcode_onceToken, &__block_literal_global_255);
  }
  return C3DIsRunningInXcode_runningXcode;
}

Class __C3DIsRunningInXcode_block_invoke()
{
  Class result = NSClassFromString(&cfstr_Skescenedocume.isa);
  C3DIsRunningInXcode_runningXcode = result != 0;
  return result;
}

uint64_t C3DIsRunningInSCNTool()
{
  if (C3DIsRunningInSCNTool_onceToken != -1) {
    dispatch_once(&C3DIsRunningInSCNTool_onceToken, &__block_literal_global_260);
  }
  return C3DIsRunningInSCNTool_runningSCNTool;
}

Class __C3DIsRunningInSCNTool_block_invoke()
{
  Class result = NSClassFromString(&cfstr_Skedocumentsan.isa);
  C3DIsRunningInSCNTool_runningSCNTool = result != 0;
  return result;
}

CFTypeRef C3DSetShaderCompilationDirectory(CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)kShaderCompilationDirectory;
  if ((CFTypeRef)kShaderCompilationDirectory != cf)
  {
    if (kShaderCompilationDirectory)
    {
      CFRelease((CFTypeRef)kShaderCompilationDirectory);
      kShaderCompilationDirectory = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    kShaderCompilationDirectory = (uint64_t)result;
  }
  return result;
}

uint64_t C3DGetShaderCompilationDirectory()
{
  return kShaderCompilationDirectory;
}

CFTypeRef C3DSetShaderCacheLibraryURL(CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)kShaderCacheLibraryURL;
  if ((CFTypeRef)kShaderCacheLibraryURL != cf)
  {
    if (kShaderCacheLibraryURL)
    {
      CFRelease((CFTypeRef)kShaderCacheLibraryURL);
      kShaderCacheLibraryURL = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    kShaderCacheLibraryURL = (uint64_t)result;
  }
  return result;
}

CFArrayRef C3DCreatePathFromComponents(const __CFArray *theArray)
{
  if (theArray) {
    return (const __CFArray *)CFStringCreateByCombiningStrings(0, theArray, @".");
  }
  return theArray;
}

uint64_t C3DIsRunningInEditor()
{
  return gEditingMode;
}

uint64_t C3DSetIsRunningInEditor(uint64_t result)
{
  gEditingMode = result;
  return result;
}

__CFArray *C3DCFArrayCreateBySortingStringValues(CFArrayRef theArray)
{
  if (!theArray) {
    return 0;
  }
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, theArray);
  v4.length = CFArrayGetCount(theArray);
  v4.location = 0;
  CFArraySortValues(MutableCopy, v4, (CFComparatorFunction)_C3DCFArrayCreateBySortingStringValuesComparatorFunction, 0);
  return MutableCopy;
}

CFComparisonResult _C3DCFArrayCreateBySortingStringValuesComparatorFunction(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

uint64_t C3DCFArrayGetSubarrayWithRange(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "subarrayWithRange:", a2, a3);
}

CFArrayRef C3DCFDictionaryCopyAllKeys(const __CFDictionary *a1)
{
  if (a1 && (CFIndex Count = CFDictionaryGetCount(a1)) != 0)
  {
    CFIndex v3 = Count;
    CFRange v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    CFDictionaryGetKeysAndValues(a1, v4, 0);
    CFArrayRef v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v4, v3, MEMORY[0x263EFFF70]);
    free(v4);
    return v5;
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v8 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
    return CFArrayCreate(v7, 0, 0, v8);
  }
}

void C3DCFSetApplyBlock(const __CFSet *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t context = a2;
      CFSetApplyFunction(a1, (CFSetApplierFunction)_C3DCFSetApplyBlock, &context);
    }
  }
}

uint64_t _C3DCFSetApplyBlock(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
}

void C3DCFDictionaryApplyBlockBySortingStringKeys(const __CFDictionary *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      CFArrayRef v4 = C3DCFDictionaryCopyAllKeys(a1);
      CFArrayRef v5 = C3DCFArrayCreateBySortingStringValues(v4);
      CFRelease(v4);
      v6[0] = MEMORY[0x263EF8330];
      v6[1] = 3221225472;
      v6[2] = __C3DCFDictionaryApplyBlockBySortingStringKeys_block_invoke;
      v6[3] = &unk_264007428;
      v6[4] = a2;
      v6[5] = a1;
      C3DCFArrayApplyBlock(v5, (uint64_t)v6);
      CFRelease(v5);
    }
  }
}

uint64_t __C3DCFDictionaryApplyBlockBySortingStringKeys_block_invoke(uint64_t a1, int a2, void *key)
{
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), key);
  CFArrayRef v4 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v4();
}

uint64_t C3DCFTypeIsDictionary()
{
  return objc_opt_isKindOfClass() & 1;
}

void _serializableCFTypeIDs()
{
  if (!_serializableCFTypeIDs_serializableTypes)
  {
    _serializableCFTypeIDs_serializableTypes = CFNumberGetTypeID();
    qword_267697D98 = CFDataGetTypeID();
    qword_267697DA0 = CFStringGetTypeID();
    qword_267697DA8 = CFDateGetTypeID();
    qword_267697DB0 = CFArrayGetTypeID();
    qword_267697DB8 = CFDictionaryGetTypeID();
  }
}

void OUTLINED_FUNCTION_4_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

double SCNNodeGetBoundingSphere(void *a1, int a2)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  uint64_t v4 = [a1 count];
  double result = 0.0;
  if (v4)
  {
    uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "firstObject", 0.0), "nodeRef");
    if (v6)
    {
      uint64_t v7 = C3DGetScene(v6);
      double result = 0.0;
      if (v7)
      {
        uint64_t v8 = v7;
        C3DSceneLock(v7);
        v67[0] = MEMORY[0x263EF8330];
        v67[1] = 3221225472;
        v68 = __SCNNodeGetBoundingSphere_block_invoke;
        v69 = &__block_descriptor_40_e5_v8__0l;
        uint64_t v70 = v8;
        memset(v65, 0, sizeof(v65));
        int v66 = 1065353216;
        std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>((uint64_t)v65, vcvtps_u32_f32((float)(unint64_t)[a1 count] / 1.0));
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        uint64_t v9 = [a1 countByEnumeratingWithState:&v61 objects:v72 count:16];
        if (v9)
        {
          uint64_t v10 = *(void *)v62;
          do
          {
            for (uint64_t i = 0; i != v9; ++i)
            {
              if (*(void *)v62 != v10) {
                objc_enumerationMutation(a1);
              }
              v12 = *(void **)(*((void *)&v61 + 1) + 8 * i);
              uint64_t v58 = [v12 nodeRef];
              uint64_t v49 = (uint64_t)&v58;
              std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::__emplace_unique_key_args<__C3DNode *,std::piecewise_construct_t const&,std::tuple<__C3DNode *&&>,std::tuple<>>((uint64_t)v65, &v58, (uint64_t)&std::piecewise_construct, (void **)&v49)[3] = v12;
            }
            uint64_t v9 = [a1 countByEnumeratingWithState:&v61 objects:v72 count:16];
          }
          while (v9);
        }
        int v44 = a2;
        uint64_t v58 = 0xA00000000;
        v59 = v60;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        uint64_t v13 = [a1 countByEnumeratingWithState:&v54 objects:v71 count:16];
        if (v13)
        {
          uint64_t v14 = *(void *)v55;
          do
          {
            for (uint64_t j = 0; j != v13; ++j)
            {
              if (*(void *)v55 != v14) {
                objc_enumerationMutation(a1);
              }
              v16 = *(void **)(*((void *)&v54 + 1) + 8 * j);
              uint64_t v49 = 0;
              uint64_t v49 = [v16 nodeRef];
              v17 = std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::find<__C3DNode *>(v65, &v49);
              std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::erase(v65, v17);
              v18 = (void *)v49;
              v52[0] = MEMORY[0x263EF8330];
              v52[1] = 3321888768;
              v52[2] = __SCNNodeGetBoundingSphere_block_invoke_2;
              v52[3] = &__block_descriptor_80_e8_32c115_ZTSNSt3__113unordered_mapIP9__C3DNodeP7SCNNodeNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_S4_EEEEEE_e20_q16__0____C3DNode__8l;
              std::unordered_map<__C3DNode *,SCNNode *>::unordered_map((uint64_t)v53, (uint64_t)v65);
              v53[5] = &v58;
              C3DNodeApplyHierarchySkippingHiddenNodes((uint64_t)v18, (uint64_t)v52);
              std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)v53);
            }
            uint64_t v13 = [a1 countByEnumeratingWithState:&v54 objects:v71 count:16];
          }
          while (v13);
        }
        uint64_t v49 = 0xA00000000;
        v50 = (float32x4_t *)v51;
        unsigned int v19 = v58;
        if (v58)
        {
          char v20 = 0;
          v21 = (CFTypeRef *)v59;
          uint64_t v22 = 8 * v58;
          float32x4_t v45 = 0u;
          do
          {
            v23 = (float32x4_t *)*v21;
            if (C3DGetBoundingSphere(*v21, 0, (uint64_t)&v48))
            {
              WorldMatrix = C3DNodeGetWorldMatrix(v23);
              C3DSphereXFormMatrix4x4(&v48, WorldMatrix, (uint64_t)&v48);
              if ((v20 & 1) != 0
                && (float32x4_t v25 = vsubq_f32(v45, v48),
                    float32x4_t v26 = vmulq_f32(v25, v25),
                    float v27 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]), (float)(v45.f32[3] + v27) >= v48.f32[3]))
              {
                if ((float)(v48.f32[3] + v27) > v45.f32[3])
                {
                  float32_t v30 = (float)((float)(v45.f32[3] + v48.f32[3]) + v27) * 0.5;
                  float32x4_t v31 = vmlaq_n_f32(v45, v25, (float)(v45.f32[3] - v30) / v27);
                  v31.f32[3] = v30;
                  float32x4_t v45 = v31;
                }
                char v20 = 1;
              }
              else
              {
                char v20 = 1;
                float32x4_t v45 = v48;
              }
            }
            else if ((v44 & 1) != 0 && (C3DNodeHasCamera((uint64_t)v23) & 1) != 0 {
                   || (v44 & 0x100) != 0 && (C3DNodeHasLight((uint64_t)v23) & 1) != 0
            }
                   || (CFArrayRef ParticleSystems = C3DNodeGetParticleSystems((uint64_t)v23)) != 0
                   && (CFIndex Count = CFArrayGetCount(ParticleSystems), (v44 & 0x10000) != 0)
                   && Count > 0
                   || (v44 & 0x1000000) != 0 && !C3DNodeHasChildren((uint64_t)v23))
            {
              v47.n128_u32[2] = 0;
              v47.n128_u64[0] = 0;
              C3DNodeGetWorldPosition(v23, &v47);
              _ZN3C3D5ArrayIDv3_fLj10ENS_15MallocAllocatorEE9push_backIRS1_EEvOT_((uint64_t)&v49, &v47);
            }
            ++v21;
            v22 -= 8;
          }
          while (v22);
          v32 = v50;
          unsigned int v19 = v49;
          float32x4_t v33 = v45;
        }
        else
        {
          char v20 = 0;
          float32x4_t v33 = 0uLL;
          v32 = (float32x4_t *)v51;
        }
        float v34 = v33.f32[3];
        if (v33.f32[3] >= 1.0 || v33.f32[3] <= 0.0) {
          float v34 = 1.0;
        }
        if (v19)
        {
          uint64_t v36 = 16 * v19;
          v37 = v32;
          do
          {
            float32x4_t v38 = *v37;
            v38.f32[3] = v34;
            if (v20)
            {
              float32x4_t v39 = vsubq_f32(v33, *v37);
              float32x4_t v40 = vmulq_f32(v39, v39);
              float v41 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0]);
              if ((float)(v33.f32[3] + v41) >= v34)
              {
                if ((float)(v34 + v41) > v33.f32[3])
                {
                  float32x4_t v42 = vsubq_f32(v33, v38);
                  float32_t v43 = (float)((float)(v34 + v33.f32[3]) + v41) * 0.5;
                  float32x4_t v33 = vmlaq_n_f32(v33, v42, (float)(v33.f32[3] - v43) / v41);
                  v33.f32[3] = v43;
                }
                float32x4_t v38 = v33;
              }
            }
            ++v37;
            char v20 = 1;
            float32x4_t v33 = v38;
            v36 -= 16;
          }
          while (v36);
        }
        else
        {
          v38.i64[0] = v33.i64[0];
        }
        double v46 = *(double *)v38.i64;
        if (v32 != (float32x4_t *)v51) {
          free(v32);
        }
        if (v59 != v60) {
          free(v59);
        }
        std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)v65);
        v68((uint64_t)v67);
        return v46;
      }
    }
    else
    {
      return 0.0;
    }
  }
  return result;
}

void sub_20B3782FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60)
{
  if (a60 != (void *)a11) {
    free(a60);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)&STACK[0x230]);
  ((void (*)(unint64_t *))STACK[0x268])(&STACK[0x258]);
  _Unwind_Resume(a1);
}

uint64_t __SCNNodeGetBoundingSphere_block_invoke(uint64_t a1)
{
  return C3DSceneUnlock(*(void *)(a1 + 32));
}

uint64_t __SCNNodeGetBoundingSphere_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::find<__C3DNode *>((void *)(a1 + 32), &v4))
  {
    return 1;
  }
  C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>(*(void *)(a1 + 72), &v4);
  return 0;
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__113unordered_mapIP9__C3DNodeP7SCNNodeNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_S4_EEEEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_map<__C3DNode *,SCNNode *>::unordered_map(a1 + 32, a2 + 32);
}

uint64_t __destroy_helper_block_e8_32c115_ZTSNSt3__113unordered_mapIP9__C3DNodeP7SCNNodeNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorINS_4pairIKS2_S4_EEEEEE(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(a1 + 32);
}

__n128 _ZN3C3D5ArrayIDv3_fLj10ENS_15MallocAllocatorEE9push_backIRS1_EEvOT_(uint64_t a1, __n128 *a2)
{
  unsigned int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 + 1) > *(_DWORD *)(a1 + 4))
  {
    _ZN3C3D5ArrayIDv3_fLj10ENS_15MallocAllocatorEE14GrowCapacityByEjb((unsigned int *)a1, 1, 0);
    unsigned int v4 = *(_DWORD *)a1;
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(a1 + 8) + 16 * v4) = *a2;
  ++*(_DWORD *)a1;
  return result;
}

void *std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::__emplace_unique_key_args<__C3DNode *,std::piecewise_construct_t const&,std::tuple<__C3DNode *&&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    BOOL v17 = 1;
    if (v10 >= 3) {
      BOOL v17 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v10);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v20);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v21 = *(void *)a1;
  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *uint64_t i = *v22;
LABEL_38:
    *uint64_t v22 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10) {
        v23 %= v10;
      }
    }
    else
    {
      v23 &= v10 - 1;
    }
    uint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20B37869C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::find<__C3DNode *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  void *v8;
  void *result;
  unint64_t v10;

  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::unordered_map<__C3DNode *,SCNNode *>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::__emplace_unique_key_args<__C3DNode *,std::pair<__C3DNode * const,SCNNode *> const&>(a1, i + 2, (_OWORD *)i + 1);
  return a1;
}

void sub_20B3788E8(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<__C3DNode *,SCNNode *>,std::__unordered_map_hasher<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::hash<__C3DNode *>,std::equal_to<__C3DNode *>,true>,std::__unordered_map_equal<__C3DNode *,std::__hash_value_type<__C3DNode *,SCNNode *>,std::equal_to<__C3DNode *>,std::hash<__C3DNode *>,true>,std::allocator<std::__hash_value_type<__C3DNode *,SCNNode *>>>::__emplace_unique_key_args<__C3DNode *,std::pair<__C3DNode * const,SCNNode *> const&>(uint64_t a1, void *a2, _OWORD *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint8x8_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    void *v21 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20B378B40(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZN3C3D5ArrayIDv3_fLj10ENS_15MallocAllocatorEE14GrowCapacityByEjb(unsigned int *a1, int a2, int a3)
{
  unint64_t v4 = (unsigned int *)*((void *)a1 + 1);
  double v5 = 1.5;
  if (a3) {
    double v5 = 1.0;
  }
  unsigned int v6 = (v5 * (double)(a1[1] + a2));
  unint64_t v7 = malloc_type_malloc(16 * v6, 0x74F3E194uLL);
  memcpy(v7, v4, 16 * *a1);
  *((void *)a1 + 1) = v7;
  a1[1] = v6;
  if (v4 != a1 + 4)
  {
    free(v4);
  }
}

void _C3DFXShaderCFFinalize(uint64_t a1)
{
  int8x8_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t __C3DFXShaderGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXShaderGetTypeID_typeID = result;
  qword_26B466CD8 = (uint64_t)_C3DFXShaderCopyInstanceVariables;
  return result;
}

uint64_t C3DFXShaderCreate(int a1)
{
  if (C3DFXShaderGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXShaderGetTypeID_onceToken, &__block_literal_global_51);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DFXShaderGetTypeID_typeID, 0x10uLL);
  if (result) {
    *(_DWORD *)(result + 16) = a1;
  }
  return result;
}

uint64_t C3DFXShaderGetStage(uint64_t a1)
{
  if (!a1)
  {
    int8x8_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXShaderGetStage_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 16);
}

CFTypeRef C3DFXShaderSetSource(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXShaderGetStage_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 24) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 24) = result;
  }
  return result;
}

uint64_t C3DFXShaderGetSource(uint64_t a1)
{
  if (!a1)
  {
    int8x8_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXShaderGetSource_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

CFStringRef _C3DFXShaderCFCopyFormatDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXShader %@>", a1[3]);
}

CFStringRef _C3DFXShaderCFCopyDebugDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXShader %@>", a1[3]);
}

__CFArray *_C3DFXShaderCopyInstanceVariables(uint64_t a1)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v13 = 2;
  int valuePtr = 5;
  uint64_t v12 = a1 + 24;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v13);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v12);
  CFDictionarySetValue(v3, @"name", @"source");
  CFDictionarySetValue(v3, @"type", v4);
  CFDictionarySetValue(v3, @"address", v6);
  CFDictionarySetValue(v3, @"semantic", v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  uint64_t v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v13 = 0;
  int valuePtr = 2;
  uint64_t v12 = a1 + 16;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v13);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberLongType, &v12);
  CFDictionarySetValue(v7, @"name", @"stage");
  CFDictionarySetValue(v7, @"type", v8);
  CFDictionarySetValue(v7, @"address", v10);
  CFDictionarySetValue(v7, @"semantic", v9);
  CFArrayAppendValue(Mutable, v7);
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v10);
  CFRelease(v8);
  return Mutable;
}

void _C3DLightProbesSystemCFFinalize(void **a1)
{
  free(a1[3]);
  free(a1[2]);

  __cleanupTetrahedronsData(a1);
}

CFStringRef _C3DLightProbesSystemCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DLightProbesSystem %p>", a1);
}

CFStringRef _C3DLightProbesSystemCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DLightProbesSystem %p>", a1);
}

void _resizeProbesData(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 232);
  if (v4 == 2)
  {
    unsigned int v5 = 48;
    goto LABEL_5;
  }
  if (v4 == 3)
  {
    unsigned int v5 = 112;
LABEL_5:
    CFNumberRef v6 = malloc_type_calloc((a2 + 4), v5, 0x5060DACBuLL);
    uint64_t v7 = malloc_type_calloc((a2 + 4), 0x10uLL, 0x1000040451B5BE8uLL);
    if (*(void *)(a1 + 24))
    {
      if (!*(_DWORD *)(a1 + 36))
      {
        CFNumberRef v8 = scn_default_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
          _resizeProbesData_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
        }
      }
      if (!*(void *)(a1 + 16))
      {
        BOOL v16 = scn_default_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          _resizeProbesData_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
        }
      }
      memcpy(v6, *(const void **)(a1 + 24), (*(_DWORD *)(a1 + 36) + 4) * v5);
      free(*(void **)(a1 + 24));
      memcpy(v7, *(const void **)(a1 + 16), 16 * (*(_DWORD *)(a1 + 36) + 4));
      free(*(void **)(a1 + 16));
    }
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v6;
    *(_DWORD *)(a1 + 36) = a2;
    return;
  }
  v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
    _resizeProbesData_cold_1(v24);
  }
}

void _computeTetrahedronMatrices(uint64_t a1)
{
  uint64_t v7 = *(unsigned int *)(a1 + 224);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 16) + 64;
    uint64_t v9 = *(void *)(a1 + 192);
    uint64_t v10 = *(void *)(a1 + 64) + 32;
    uint64_t v11 = (int *)(*(void *)(a1 + 48) + 8);
    do
    {
      uint64_t v12 = v11[1];
      if (v12 == 0x7FFFFFFF)
      {
        uint64_t v13 = *(v11 - 2);
        uint64_t v14 = *(v11 - 1);
        uint64_t v15 = *v11;
        _Q3 = *(float32x4_t *)(v9 + 16 * v15);
        float32x4_t v17 = *(float32x4_t *)(v8 + 16 * v15);
        _Q7 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v13), v17);
        _Q17 = vsubq_f32(*(float32x4_t *)(v9 + 16 * v13), _Q3);
        _Q16 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v14), v17);
        _Q4 = vsubq_f32(*(float32x4_t *)(v9 + 16 * v14), _Q3);
        _S19 = _Q4.i32[2];
        _S20 = _Q4.i32[1];
        _Q22.f32[0] = vmuls_lane_f32(-_Q17.f32[2], *(float32x2_t *)_Q4.f32, 1);
        _S24 = vmuls_lane_f32(_Q4.f32[0], _Q17, 2);
        _S27 = vmuls_lane_f32(_Q17.f32[0], *(float32x2_t *)_Q4.f32, 1);
        __asm
        {
          FMLS            S26, S27, V3.S[2]
          FMLS            S26, S24, V3.S[1]
          FMLS            S26, S22, V3.S[0]
          FMLA            S22, S19, V17.S[1]
        }
        float v33 = -_Q17.f32[0];
        __asm { FMLS            S24, S19, V17.S[0] }
        _Q22.i32[1] = _S24;
        _Q22.i32[2] = vmlas_n_f32((float)-_Q17.f32[1] * _Q4.f32[0], _Q4.f32[1], _Q17.f32[0]);
        _S24 = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q4.f32, 1);
        __asm { FMLS            S30, S24, V3.S[2] }
        _S24 = _Q16.f32[1];
        _S31 = vmuls_lane_f32(_Q17.f32[0], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S30, S31, V3.S[2] }
        _S23 = (float)-_Q17.f32[1] * _Q16.f32[0];
        __asm { FMLS            S30, S23, V3.S[2] }
        _S31 = vmuls_lane_f32(_Q4.f32[0], _Q7, 2);
        __asm { FMLS            S30, S31, V3.S[1] }
        _S31 = vmuls_lane_f32(-_Q7.f32[2], *(float32x2_t *)_Q4.f32, 1);
        __asm { FMLS            S30, S31, V3.S[0] }
        _S31 = vmuls_lane_f32(_Q16.f32[0], _Q17, 2);
        __asm { FMLS            S30, S31, V3.S[1] }
        _Q21.f32[0] = vmuls_lane_f32(-_Q17.f32[2], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S30, S21, V3.S[0] }
        _Q21.f32[0] = vmuls_lane_f32(-_Q7.f32[0], _Q4, 2);
        __asm { FMLS            S30, S21, V3.S[1] }
        _Q21.f32[0] = vmuls_lane_f32(_Q4.f32[2], *(float32x2_t *)_Q7.f32, 1);
        __asm { FMLS            S30, S21, V3.S[0] }
        _S9 = _Q16.i32[2];
        _S10 = vmuls_lane_f32(-_Q17.f32[0], _Q16, 2);
        __asm { FMLS            S30, S10, V3.S[1] }
        _S11 = vmuls_lane_f32(_Q17.f32[1], _Q16, 2);
        __asm { FMLS            S30, S11, V3.S[0] }
        float32x4_t v56 = vmulq_f32(v17, _Q22);
        _Q22.f32[3] = _S30
                    - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2), vaddq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1))).f32[0];
        __asm
        {
          FMLA            S21, S9, V17.S[1]
          FMLS            S21, S24, V17.S[2]
          FMLS            S21, S20, V7.S[2]
          FMLS            S10, S19, V7.S[0]
          FMLA            S10, S4, V7.S[2]
          FMLA            S10, S16, V17.S[2]
          FMLS            S29, S16, V17.S[1]
        }
        _Q21.i32[1] = _S10;
        _Q21.i32[2] = _S29;
        _Q17.f32[0] = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q16.f32, 1);
        float v61 = (float)-_Q7.f32[1] * _Q16.f32[0];
        __asm { FMLS            S18, S17, V3.S[2] }
        _Q17.f32[0] = vmuls_lane_f32(-_Q7.f32[0], _Q16, 2);
        __asm { FMLS            S18, S17, V3.S[1] }
        _Q17.f32[0] = vmuls_lane_f32(_Q7.f32[1], _Q16, 2);
        __asm { FMLS            S18, S17, V3.S[0] }
        _S20 = vmuls_lane_f32(_Q16.f32[0], _Q7, 2);
        __asm { FMLS            S18, S20, V3.S[1] }
        _Q16.f32[0] = vmuls_lane_f32(-_Q7.f32[2], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S18, S16, V3.S[0] }
        float32x4_t v68 = vmulq_f32(v17, _Q21);
        _Q21.f32[3] = _S18
                    - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).f32[0];
        __asm
        {
          FMLS            S17, S24, V7.S[2]
          FMLS            S20, S9, V7.S[0]
        }
        *(float *)&unsigned int v70 = vmlas_n_f32(v61, _S24, _Q7.f32[0]);
        v72.i64[0] = __PAIR64__(_S20, _Q17.u32[0]);
        v72.i64[1] = v70;
        _Q5 = vmulq_f32(v17, v72);
        v72.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q5, 2), vaddq_f32(_Q5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q5.f32, 1))).f32[0];
        _Q5.f32[0] = vmuls_lane_f32(_Q17.f32[1], _Q4, 2);
        __asm { FMLS            S26, S5, V3.S[0] }
        _Q4.f32[0] = vmuls_lane_f32(v33, _Q4, 2);
        __asm { FMLS            S26, S4, V3.S[1] }
        if (fabsf(*(float *)_D26.i32) > 0.0001)
        {
          float32x4_t v74 = (float32x4_t)vdupq_lane_s32(_D26, 0);
          _Q22 = vdivq_f32(_Q22, v74);
          _Q21 = vdivq_f32(_Q21, v74);
          float32x4_t v72 = vdivq_f32(v72, v74);
        }
        *(float32x4_t *)(v10 - 32) = _Q22;
        *(float32x4_t *)(v10 - 16) = _Q21;
        *(float32x4_t *)uint64_t v10 = v72;
      }
      else
      {
        float32x4_t v75 = *(float32x4_t *)(v8 + 16 * v12);
        v76.columns[0] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *(v11 - 2)), v75);
        v76.columns[1] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *(v11 - 1)), v75);
        v76.columns[2] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *v11), v75);
        v76.columns[0].i32[3] = HIDWORD(v1);
        v76.columns[1].i32[3] = HIDWORD(v3);
        v76.columns[2].i32[3] = HIDWORD(v2);
        simd_float3x3 v77 = __invert_f3(v76);
        *(_OWORD *)(v10 - 16) = 0u;
        *(_OWORD *)uint64_t v10 = 0u;
        v77.columns[0].i32[3] = 0;
        v77.columns[1].i32[3] = *(_DWORD *)(v10 - 4);
        *(simd_float3 *)(v10 - 32) = v77.columns[0];
        *(simd_float3 *)(v10 - 16) = v77.columns[1];
        v77.columns[2].i32[3] = *(_DWORD *)(v10 + 12);
        *(simd_float3 *)uint64_t v10 = v77.columns[2];
      }
      v10 += 48;
      v11 += 12;
      --v7;
    }
    while (v7);
  }
}

void _computeNeighbourIndexes(uint64_t a1, unsigned int a2)
{
  *(void *)&v64[5] = *MEMORY[0x263EF8340];
  v60 = malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 32) + 4), 0x370A01F5uLL);
  if (a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v58 = a2;
    uint64_t v5 = v4 + 16;
    CFNumberRef v6 = v60;
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 48 * v3;
      uint64_t v9 = &dword_20B5ED938;
      do
      {
        *(_DWORD *)(v5 + v7) = -1;
        int v10 = *(_DWORD *)(v8 + 4 * *(v9 - 2));
        if (v10 >= *(_DWORD *)(v8 + 4 * *(v9 - 1))) {
          int v10 = *(_DWORD *)(v8 + 4 * *(v9 - 1));
        }
        if (v10 >= *(_DWORD *)(v8 + 4 * *v9)) {
          int v10 = *(_DWORD *)(v8 + 4 * *v9);
        }
        uint64_t Mutable = v6[v10];
        if (!Mutable)
        {
          uint64_t v12 = v10;
          uint64_t Mutable = C3DIndexSetCreateMutable();
          v60[v12] = Mutable;
          CFNumberRef v6 = v60;
        }
        v9 += 3;
        C3DIndexSetAddIndex(Mutable, v3);
        v7 += 4;
      }
      while (v7 != 16);
      ++v3;
      v5 += 48;
    }
    while (v3 != a2);
    for (uint64_t i = 0; i != v58; ++i)
    {
      uint64_t v14 = 0;
      uint64_t v59 = v4 + 48 * i;
      do
      {
        uint64_t v15 = v4 + 48 * i + 4 * v14;
        int v17 = *(_DWORD *)(v15 + 16);
        BOOL v16 = (_DWORD *)(v15 + 16);
        if (v17 == -1)
        {
          uint64_t v18 = &g_TetrahedronFaces[3 * v14];
          uint64_t v19 = *(int *)(v59 + 4 * *v18);
          uint64_t v20 = *(int *)(v59 + 4 * v18[1]);
          uint64_t v21 = *(int *)(v59 + 4 * v18[2]);
          if (v19 >= v20) {
            uint64_t v22 = v20;
          }
          else {
            uint64_t v22 = v19;
          }
          if (v19 <= v20) {
            uint64_t v23 = v20;
          }
          else {
            uint64_t v23 = v19;
          }
          if (v22 >= v21) {
            uint64_t v24 = v21;
          }
          else {
            uint64_t v24 = v22;
          }
          if (v23 <= v21) {
            uint64_t v25 = v21;
          }
          else {
            uint64_t v25 = v23;
          }
          if (v24 != v20 && v25 != v20) {
            uint64_t v21 = v20;
          }
          if (v24 == v19 || v25 == v19) {
            uint64_t v28 = v21;
          }
          else {
            uint64_t v28 = v19;
          }
          uint64_t v29 = v60[v24];
          if (!v29)
          {
            float32_t v30 = scn_default_log();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
              _computeNeighbourIndexes_cold_2(v63, v64, v30);
            }
          }
          uint64_t FirstIndex = C3DIndexSetGetFirstIndex(v29);
          if (FirstIndex != -1)
          {
            uint64_t v32 = FirstIndex;
            uint64_t v33 = -1;
            do
            {
              if (v32 == i)
              {
                uint64_t v34 = -1;
              }
              else
              {
                unint64_t v35 = 0;
                uint64_t v36 = v4 + 48 * v32;
                v37 = &dword_20B5ED938;
                do
                {
                  uint64_t v38 = *(int *)(v36 + 4 * *(v37 - 2));
                  uint64_t v39 = *(int *)(v36 + 4 * *(v37 - 1));
                  uint64_t v40 = *(int *)(v36 + 4 * *v37);
                  if (v38 >= v39) {
                    uint64_t v41 = *(int *)(v36 + 4 * *(v37 - 1));
                  }
                  else {
                    uint64_t v41 = *(int *)(v36 + 4 * *(v37 - 2));
                  }
                  if (v38 <= v39) {
                    uint64_t v42 = *(int *)(v36 + 4 * *(v37 - 1));
                  }
                  else {
                    uint64_t v42 = *(int *)(v36 + 4 * *(v37 - 2));
                  }
                  if (v41 >= v40) {
                    uint64_t v41 = *(int *)(v36 + 4 * *v37);
                  }
                  if (v42 <= v40) {
                    uint64_t v42 = *(int *)(v36 + 4 * *v37);
                  }
                  if (v41 == v39 || v42 == v39) {
                    uint64_t v39 = *(int *)(v36 + 4 * *v37);
                  }
                  if (v41 == v38 || v42 == v38) {
                    uint64_t v38 = v39;
                  }
                  BOOL v46 = v41 == v24 && v38 == v28;
                  BOOL v47 = v42 == v25;
                  if (v46 && v47) {
                    uint64_t v34 = v32;
                  }
                  else {
                    uint64_t v34 = -1;
                  }
                  if (v46 && v47) {
                    uint64_t v33 = v35;
                  }
                  BOOL v48 = v34 != -1 || v35++ >= 3;
                  v37 += 3;
                }
                while (!v48);
              }
              uint64_t IndexGreaterThanIndex = C3DIndexSetGetIndexGreaterThanIndex(v29, v32);
              if (v34 != -1) {
                break;
              }
              uint64_t v32 = IndexGreaterThanIndex;
            }
            while (IndexGreaterThanIndex != -1);
            if (v34 != -1)
            {
              uint64_t v50 = v4 + 48 * v34 + 4 * v33;
              int v52 = *(_DWORD *)(v50 + 16);
              v51 = (_DWORD *)(v50 + 16);
              if (v52 != -1)
              {
                v53 = scn_default_log();
                if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
                  _computeNeighbourIndexes_cold_1(v61, &v62, v53);
                }
              }
              _DWORD *v16 = v34;
              _DWORD *v51 = i;
            }
          }
        }
        ++v14;
      }
      while (v14 != 4);
    }
  }
  unint64_t v54 = *(unsigned int *)(a1 + 32);
  if (v54)
  {
    for (unint64_t j = 0; j < v54; ++j)
    {
      float32x4_t v56 = (const void *)v60[j];
      if (v56)
      {
        CFRelease(v56);
        v60[j] = 0;
        unint64_t v54 = *(unsigned int *)(a1 + 32);
      }
    }
  }
  free(v60);
}

void C3DLightProbesSystemSetProbesCount(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a1 + 36) < a2) {
      _resizeProbesData(a1, a2);
    }
  }
  else
  {
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    __cleanupTetrahedronsData((void **)a1);
    *(_DWORD *)(a1 + 36) = 0;
  }
  *(_DWORD *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 228) = 1;
}

void __cleanupTetrahedronsData(void **a1)
{
  a1[6] = 0;
  free(a1[8]);
  a1[8] = 0;
  free(a1[24]);
  a1[24] = 0;
}

void C3DLightProbesSystemSetProbeData(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  v37.n128_u32[2] = 0;
  uint64_t v6 = a2 + 4;
  v37.n128_u64[0] = 0;
  C3DNodeGetWorldPosition(a3, &v37);
  *(__n128 *)(*(void *)(a1 + 16) + 16 * v6) = v37;
  unsigned int v7 = *(_DWORD *)(a1 + 232);
  CFDataRef IrradianceSH = (const __CFData *)C3DLightGetIrradianceSH(a4);
  if (IrradianceSH)
  {
    CFDataRef v9 = IrradianceSH;
    unsigned int v10 = v7 * v7;
    if (12 * v7 * (unint64_t)v7 != CFDataGetLength(IrradianceSH))
    {
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        C3DLightProbesSystemSetProbeData_cold_2(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }
    BytePtr = CFDataGetBytePtr(v9);
    uint64_t v20 = &BytePtr[4 * v10];
    v38[0] = BytePtr;
    v38[1] = v20;
    uint64_t v21 = &BytePtr[8 * v10];
    v38[2] = v21;
    if (v7 == 3)
    {
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a1 + 24);
      float32x2_t v25 = (float32x2_t)vdup_n_s32(0xBEA6C6BC);
      do
      {
        uint64_t v26 = v38[v23];
        v27.i32[0] = *(_DWORD *)(v26 + 12);
        v27.i32[1] = *(_DWORD *)(v26 + 4);
        *(float32x2_t *)&long long v28 = vmul_f32(v27, v25);
        *((float *)&v28 + 2) = *(float *)(v26 + 8) * 0.32573;
        *((float *)&v28 + 3) = (float)(*(float *)(v26 + 24) * -0.078848) + (float)(*(float *)v26 * 0.28209);
        *(&v39 + v23++) = v28;
      }
      while (v23 != 3);
      uint64_t v29 = 0;
      float32_t v30 = (_OWORD *)(v24 + 112 * v6);
      long long v31 = v40;
      *float32_t v30 = v39;
      v30[1] = v31;
      v30[2] = v41;
      do
      {
        *(&v39 + v29) = (__int128)vmulq_f32(*(float32x4_t *)(v38[v29] + 16), (float32x4_t)xmmword_20B5ED8F0);
        ++v29;
      }
      while (v29 != 3);
      uint64_t v32 = (_OWORD *)(v24 + 112 * v6);
      long long v33 = v40;
      v32[3] = v39;
      v32[4] = v33;
      v32[5] = v41;
      v34.i32[0] = *((_DWORD *)BytePtr + 8);
      v34.i32[1] = *((_DWORD *)v20 + 8);
      *(float32x2_t *)&long long v35 = vmul_f32(v34, (float32x2_t)vdup_n_s32(0x3E0BD8A0u));
      *((void *)&v35 + 1) = __PAIR64__(1.0, *((float *)v21 + 8) * 0.13657);
      v32[6] = v35;
    }
    else if (v7 == 2)
    {
      uint64_t v22 = (_OWORD *)(*(void *)(a1 + 24) + 48 * v6);
      *uint64_t v22 = *(_OWORD *)BytePtr;
      v22[1] = *(_OWORD *)v20;
      v22[2] = *(_OWORD *)v21;
    }
    else
    {
      uint64_t v36 = scn_default_log();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        C3DLightProbesSystemSetProbeData_cold_1(v7, v36);
      }
    }
  }
}

void C3DLightProbesBeginQueries(uint64_t a1, uint64_t a2)
{
  *(void *)((char *)&v163[1] + 4) = *MEMORY[0x263EF8340];
  *(void *)(a1 + 240) = a2;
  *(void *)(a1 + 248) = 0;
  if (!*(unsigned char *)(a1 + 228)) {
    return;
  }
  *(unsigned char *)(a1 + 228) = 0;
  if (*(_DWORD *)(a1 + 32) <= 3u)
  {
    *(_DWORD *)(a1 + 224) = 0;
    return;
  }
  __cleanupTetrahedronsData((void **)a1);
  size_t v2 = (100 * *(_DWORD *)(a1 + 32) + 400);
  *(void *)(a1 + 48) = malloc_type_valloc(16 * (v2 + 2 * v2), 0x1000040EED21634uLL);
  *(void *)(a1 + 64) = malloc_type_valloc(16 * (v2 + 2 * v2), 0x1000040EED21634uLL);
  uint64_t v3 = malloc_type_calloc(8uLL, v2, 0x3658D88AuLL);
  v154 = malloc_type_calloc(0xCuLL, v2, 0x2A900A42uLL);
  v147 = malloc_type_calloc(8uLL, v2, 0xE2410710uLL);
  unsigned int v141 = v2;
  uint64_t v4 = malloc_type_calloc(v2, 1uLL, 0x100004077774924uLL);
  uint64_t v5 = *(float32x4_t **)(a1 + 48);
  uint64_t v6 = *(unsigned int *)(a1 + 32);
  uint64_t v145 = *(void *)(a1 + 16);
  if (v6)
  {
    unsigned int v7 = (float32x4_t *)(*(void *)(a1 + 16) + 64);
    float32x4_t v8 = 0uLL;
    CFDataRef v9 = v7;
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    do
    {
      float32x4_t v11 = *v9++;
      v12.i32[1] = v11.i32[1];
      float32x4_t v8 = vaddq_f32(v8, v11);
      --v10;
    }
    while (v10);
    *(float *)v12.i32 = (float)v6;
    float32x4_t v13 = vdivq_f32(v8, (float32x4_t)vdupq_lane_s32(v12, 0));
    int32x2_t v14 = 0;
    uint64_t v15 = *(unsigned int *)(a1 + 32);
    do
    {
      float32x4_t v16 = *v7++;
      float32x4_t v17 = vsubq_f32(v13, v16);
      float32x4_t v18 = vmulq_f32(v17, v17);
      float v19 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0];
      if (*(float *)v14.i32 <= v19) {
        *(float *)v14.i32 = v19;
      }
      --v15;
    }
    while (v15);
  }
  else
  {
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x7FC00000u);
    int32x2_t v14 = 0;
  }
  uint64_t v20 = 0;
  *(float *)v14.i32 = (float)(sqrtf(*(float *)v14.i32) * 9.0) / 2.4495;
  float32x4_t v21 = (float32x4_t)vdupq_lane_s32(v14, 0);
  do
  {
    *(float32x4_t *)(v145 + v20 * 16) = vmlaq_f32(v13, v21, (float32x4_t)g_TetrahedronVertices[v20]);
    ++v20;
  }
  while (v20 != 4);
  *uint64_t v5 = (float32x4_t)xmmword_20B5ED900;
  v142 = v4;
  *uint64_t v4 = 1;
  if (!computeTetrahedronCircumsphereMatrix(v5, v145))
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      C3DLightProbesBeginQueries_cold_5(v22);
    }
  }
  if (!v6)
  {
    unsigned int v23 = 1;
    uint64_t v25 = v145;
LABEL_147:
    uint64_t v103 = 0;
    __asm { FMOV            V0.4S, #0.25 }
    do
    {
      uint64_t v108 = 0;
      v109 = (int *)&v5[3 * v103];
      float32x4_t v110 = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(v25 + 16 * *v109), *(float32x4_t *)(v25 + 16 * v109[1])), *(float32x4_t *)(v25 + 16 * v109[2])), *(float32x4_t *)(v25 + 16 * v109[3])), _Q0);
      do
      {
        uint64_t v111 = g_TetrahedronFaces[v108];
        uint64_t v112 = g_TetrahedronFaces[v108 + 1];
        uint64_t v113 = v109[v111];
        float32x4_t v114 = *(float32x4_t *)(v25 + 16 * v113);
        uint64_t v115 = v109[v112];
        float32x4_t v116 = vsubq_f32(*(float32x4_t *)(v25 + 16 * v115), v114);
        float32x4_t v117 = vsubq_f32(*(float32x4_t *)(v25 + 16 * v109[g_TetrahedronFaces[v108 + 2]]), v114);
        float32x4_t v118 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v117, (int32x4_t)v117), (int8x16_t)v117, 0xCuLL), vnegq_f32(v116)), v117, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v116, (int32x4_t)v116), (int8x16_t)v116, 0xCuLL));
        float32x4_t v119 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v118, (int32x4_t)v118), (int8x16_t)v118, 0xCuLL);
        int32x4_t v120 = (int32x4_t)vmulq_f32(v118, v118);
        v120.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v120.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v120, 2), *(float32x2_t *)v120.i8)).u32[0];
        float32x2_t v121 = vrsqrte_f32((float32x2_t)v120.u32[0]);
        float32x4_t v122 = vmulq_n_f32(v119, vmul_f32(v121, vrsqrts_f32((float32x2_t)v120.u32[0], vmul_f32(v121, v121))).f32[0]);
        float32x4_t v123 = vmulq_f32(v114, v122);
        float32x4_t v124 = vmulq_f32(v110, v122);
        if ((float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 2), vaddq_f32(v124, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v124.f32, 1))).f32[0]- vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v123, 2), vaddq_f32(v123, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v123.f32, 1))).f32[0]) > 0.0)
        {
          v109[v111] = v115;
          v109[v112] = v113;
        }
        v108 += 3;
      }
      while (v108 != 12);
      ++v103;
    }
    while (v103 != v23);
    uint64_t v125 = 0;
    unsigned int v86 = 0;
    v126.i64[0] = 0x300000003;
    v126.i64[1] = 0x300000003;
    v127 = v5;
    do
    {
      if (v127->i32[0] >= 4 && v127->i32[1] >= 4 && v127->i32[2] >= 4 && v127->i32[3] >= 4)
      {
        if (v125 != v86)
        {
          v128 = &v5[3 * v86];
          float32x4_t v129 = *v127;
          float32x4_t v130 = v127[2];
          v128[1] = v127[1];
          v128[2] = v130;
          float32x4_t *v128 = v129;
        }
        v5[3 * v86] = (float32x4_t)vaddq_s32((int32x4_t)v5[3 * v86], v126);
        ++v86;
      }
      ++v125;
      v127 += 3;
    }
    while (v23 != v125);
    goto LABEL_162;
  }
  uint64_t v140 = 0;
  v138 = v5 + 2;
  unsigned int v23 = 1;
  uint64_t v24 = v142;
  uint64_t v25 = v145;
  v148 = v5;
  v149 = v3;
  uint64_t v139 = v6;
  do
  {
    while (!v23)
    {
      unsigned int v86 = 0;
      if (++v140 == v6) {
        goto LABEL_162;
      }
    }
    uint64_t v26 = 0;
    unsigned int v143 = 0;
    unsigned int v144 = v23;
    float32x4_t v27 = *(float32x4_t *)(v25 + 16 * (v140 + 4));
    uint64_t v28 = v23;
    uint64_t v29 = v138;
    do
    {
      float32x4_t v30 = vsubq_f32(v27, *v29);
      float32x4_t v31 = vmulq_f32(v30, v30);
      if (COERCE_FLOAT(HIDWORD(*(unsigned long long *)v29)) + 0.00001 >= vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0])
      {
        v3[v143] = v26;
        v24[v26] = 0;
        ++v143;
      }
      ++v26;
      v29 += 3;
    }
    while (v28 != v26);
    if (v143)
    {
      uint64_t v32 = 0;
      unsigned int v33 = 0;
      unint64_t v34 = v143;
      do
      {
        uint64_t v35 = 0;
        uint64_t v146 = v32;
        uint64_t v36 = v3[v32];
        __n128 v37 = &v5[3 * v36];
        v150 = v37;
        uint64_t v151 = v36;
        do
        {
          uint64_t v38 = 0;
          long long v39 = &g_TetrahedronFaces[3 * v35];
          uint64_t v40 = v39[1];
          uint64_t v41 = v37->i32[*v39];
          uint64_t v42 = v37->i32[v40];
          uint64_t v43 = v39[2];
          uint64_t v44 = v37->i32[v43];
          if (v41 >= v42) {
            uint64_t v45 = v37->i32[v40];
          }
          else {
            uint64_t v45 = v41;
          }
          if (v41 <= v42) {
            uint64_t v46 = v37->i32[v40];
          }
          else {
            uint64_t v46 = v41;
          }
          if (v45 >= v44) {
            uint64_t v45 = v37->i32[v43];
          }
          if (v46 <= v44) {
            uint64_t v46 = v37->i32[v43];
          }
          if (v45 == v42 || v46 == v42) {
            uint64_t v42 = v37->i32[v43];
          }
          if (v45 != v41 && v46 != v41) {
            uint64_t v42 = v41;
          }
          BOOL v49 = 1;
          while (1)
          {
            uint64_t v50 = v3[v38];
            if (v50 != v36) {
              break;
            }
LABEL_79:
            BOOL v49 = ++v38 < v34;
            if (v38 == v34) {
              goto LABEL_82;
            }
          }
          uint64_t v51 = 0;
          int v52 = &v5[3 * v50];
          while (1)
          {
            uint64_t v53 = v52->i32[g_TetrahedronFaces[v51]];
            uint64_t v54 = v52->i32[g_TetrahedronFaces[v51 + 1]];
            uint64_t v55 = v52->i32[g_TetrahedronFaces[v51 + 2]];
            if (v53 >= v54) {
              uint64_t v56 = v52->i32[g_TetrahedronFaces[v51 + 1]];
            }
            else {
              uint64_t v56 = v52->i32[g_TetrahedronFaces[v51]];
            }
            if (v53 <= v54) {
              uint64_t v57 = v52->i32[g_TetrahedronFaces[v51 + 1]];
            }
            else {
              uint64_t v57 = v52->i32[g_TetrahedronFaces[v51]];
            }
            if (v56 >= v55) {
              uint64_t v56 = v52->i32[g_TetrahedronFaces[v51 + 2]];
            }
            if (v57 <= v55) {
              uint64_t v57 = v52->i32[g_TetrahedronFaces[v51 + 2]];
            }
            if (v56 != v54 && v57 != v54) {
              uint64_t v55 = v52->i32[g_TetrahedronFaces[v51 + 1]];
            }
            if (v56 != v53 && v57 != v53) {
              uint64_t v55 = v52->i32[g_TetrahedronFaces[v51]];
            }
            BOOL v60 = v56 == v45 && v55 == v42;
            if (v60 && v57 == v46) {
              break;
            }
            v51 += 3;
            if (v51 == 12) {
              goto LABEL_79;
            }
          }
          if (!v49)
          {
LABEL_82:
            uint64_t v152 = v35;
            unint64_t v62 = 0;
            uint64_t v63 = v33;
            long long v64 = &v154[3 * v33];
            *long long v64 = v41;
            v64[1] = v37->i32[v40];
            v153 = v64;
            v64[2] = v37->i32[v43];
            unsigned int v155 = v33;
            do
            {
              unint64_t v65 = v62;
              if (v62 == 3) {
                break;
              }
              ++v62;
              uint64_t v66 = v65 == 2 ? 0 : v65 + 1;
              if (v33)
              {
                uint64_t v67 = 0;
                unint64_t v68 = 0;
                v69 = v154;
                int v70 = v153[v65];
                int v71 = v153[v66];
                do
                {
                  uint64_t v72 = 0;
                  unsigned int v73 = 0;
                  do
                  {
                    int v74 = v69[v72];
                    if (v74 == v70 || v74 == v71) {
                      ++v73;
                    }
                    ++v72;
                  }
                  while (v72 != 3);
                  if (v73 >= 3)
                  {
                    simd_float3x3 v76 = scn_default_log();
                    if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
                      C3DLightProbesBeginQueries_cold_4(v162, v163, v76);
                    }
                  }
                  if (v73 == 2) {
                    ++v68;
                  }
                  ++v67;
                  v69 += 3;
                }
                while (v67 != v63);
              }
              else
              {
                unint64_t v68 = 0;
              }
              unsigned int v33 = v155;
            }
            while (v68 < 2);
            if (v65 > 2) {
              ++v33;
            }
            uint64_t v5 = v148;
            uint64_t v3 = v149;
            unint64_t v34 = v143;
            __n128 v37 = v150;
            uint64_t v36 = v151;
            uint64_t v35 = v152;
          }
          ++v35;
        }
        while (v35 != 4);
        v147[v146] = v36;
        uint64_t v32 = v146 + 1;
      }
      while (v146 + 1 != v34);
      if (v33)
      {
        uint64_t v77 = v33;
        v78 = v154 + 2;
        uint64_t v24 = v142;
        unsigned int v79 = v143;
        do
        {
          if (v79)
          {
            unsigned int v80 = v79 - 1;
            uint64_t v81 = v147[v79 - 1];
          }
          else
          {
            uint64_t v81 = v144;
            if (v144 >= v141)
            {
              v82 = scn_default_log();
              if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
                C3DLightProbesBeginQueries_cold_3(&buf, v157, v82);
              }
              unsigned int v80 = 0;
              ++v144;
              uint64_t v24 = v142;
            }
            else
            {
              unsigned int v80 = 0;
              ++v144;
            }
          }
          v24[v81] = 1;
          __int32 v83 = *v78;
          v84 = v24;
          v85 = &v5[3 * v81];
          v85->i64[0] = *((void *)v78 - 1);
          v85->i32[2] = v83;
          v85->i32[3] = v140 + 4;
          if (computeTetrahedronCircumsphereMatrix(v85, v145))
          {
            uint64_t v24 = v84;
            unsigned int v79 = v80;
          }
          else
          {
            v84[v81] = 0;
            v147[v80] = v81;
            unsigned int v79 = v80 + 1;
            uint64_t v24 = v84;
          }
          v78 += 3;
          --v77;
          uint64_t v25 = v145;
        }
        while (v77);
      }
      else
      {
        uint64_t v24 = v142;
        uint64_t v25 = v145;
        unsigned int v79 = v143;
      }
      if (v79)
      {
        uint64_t v87 = 0;
        uint64_t v88 = v79;
        unsigned int v89 = v144 - 1;
        do
        {
          uint64_t v90 = v147[v87];
          unsigned int v91 = v89;
          do
          {
            uint64_t v92 = (int)v91;
            int v93 = v24[v91--];
            if (v93) {
              BOOL v94 = 0;
            }
            else {
              BOOL v94 = v90 < v92;
            }
          }
          while (v94);
          unsigned int v95 = --v144;
          if (v90 >= v92)
          {
            if (v95 > v90)
            {
              v102 = scn_default_log();
              if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
                C3DLightProbesBeginQueries_cold_2(v158, &v159, v102);
              }
            }
          }
          else
          {
            if (!v93)
            {
              v96 = scn_default_log();
              if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
                C3DLightProbesBeginQueries_cold_1(v160, &v161, v96);
              }
            }
            v97 = (long long *)&v5[3 * (int)v92];
            long long v98 = *v97;
            long long v99 = v97[1];
            long long v100 = v97[2];
            f32 = (_OWORD *)v5[3 * v90].f32;
            f32[1] = v99;
            f32[2] = v100;
            _OWORD *f32 = v98;
            v142[v90] = 1;
            v142[v92] = 0;
          }
          ++v87;
          --v89;
          uint64_t v24 = v142;
          uint64_t v25 = v145;
        }
        while (v87 != v88);
      }
    }
    uint64_t v6 = v139;
    ++v140;
    unsigned int v23 = v144;
  }
  while (v140 != v139);
  if (v144) {
    goto LABEL_147;
  }
  unsigned int v86 = 0;
LABEL_162:
  *(_DWORD *)(a1 + 224) = v86;
  _computeNeighbourIndexes(a1, v86);
  _computeTetrahedronMatrices(a1);
  unsigned int v132 = *(_DWORD *)(a1 + 224);
  if (v132)
  {
    v133 = (float32x4_t *)(*(void *)(a1 + 48) + 32);
    float32x4_t v134 = 0uLL;
    uint64_t v135 = *(unsigned int *)(a1 + 224);
    do
    {
      float32x4_t v136 = *v133;
      v133 += 3;
      v131.i32[1] = v136.i32[1];
      float32x4_t v134 = vaddq_f32(v134, v136);
      --v135;
    }
    while (v135);
  }
  else
  {
    float32x4_t v134 = 0uLL;
  }
  *(float *)v131.i32 = (float)v132;
  *(float32x4_t *)(a1 + 208) = vdivq_f32(v134, (float32x4_t)vdupq_lane_s32(v131, 0));
  free(v3);
  free(v154);
  free(v147);
  free(v142);
}

uint64_t C3DLightProbesEndQueries(uint64_t result)
{
  *(void *)(result + 240) = 0;
  return result;
}

void __cubicPolynomialRoot(float a1, float a2, float a3)
{
  float v3 = (float)((float)((float)(a3 * -27.0) + (float)((float)(a1 * 9.0) * a2))
             + (float)((float)((float)(a1 * -2.0) * a1) * a1))
     / 54.0;
  float v4 = (float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0)
     * (float)((float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0)
             * (float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0));
  float v5 = v4 + (float)(v3 * v3);
  if (v5 >= 0.0)
  {
    float v10 = sqrtf(v5);
    cbrtf(v3 + v10);
    cbrtf(v3 - v10);
  }
  else
  {
    float v6 = acosf(v3 / sqrtf(-v4));
    cosf(v6 / 3.0);
    double v7 = v6;
    float v8 = (v7 + 6.28318531) / 3.0;
    cosf(v8);
    float v9 = (v7 + 12.5663706) / 3.0;
    cosf(v9);
  }
}

__n64 __triangleBarycentricCoords(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a3, a1);
  float32x4_t v6 = vsubq_f32(a4, a1);
  float32x4_t v7 = vmulq_f32(v4, v4);
  v7.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u32[0];
  float32x4_t v8 = vmulq_f32(v4, v5);
  float32x4_t v9 = vmulq_f32(v5, v5);
  v8.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
  LODWORD(v10) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).u32[0];
  float32x4_t v11 = vmulq_f32(v4, v6);
  v11.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
  float32x4_t v12 = vmulq_f32(v5, v6);
  v12.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0];
  v5.f32[0] = -v8.f32[0];
  v8.f32[0] = vmlas_n_f32((float)-v8.f32[0] * v8.f32[0], v10, v7.f32[0]);
  float v13 = vmlas_n_f32(v5.f32[0] * v12.f32[0], v11.f32[0], v10) / v8.f32[0];
  result.n64_f32[0] = (float)(1.0 - v13)
                    - (float)(vmlas_n_f32(v5.f32[0] * v11.f32[0], v12.f32[0], v7.f32[0]) / v8.f32[0]);
  result.n64_f32[1] = v13;
  return result;
}

BOOL __lookupTetrahedron(uint64_t a1, unsigned int *a2, float32x4_t *a3, int32x4_t a4, float a5)
{
  unsigned int v5 = *(_DWORD *)(a1 + 224);
  if (!v5) {
    return 0;
  }
  float32x4_t v7 = (float32x4_t)a4;
  uint64_t v8 = *(void *)(a1 + 16) + 64;
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v47 = *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 192);
  float32x4_t v42 = (float32x4_t)vdupq_laneq_s32(a4, 2);
  float32x4_t v43 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  if (*a2 >= v5) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = *a2;
  }
  float32x4_t v49 = (float32x4_t)vdupq_n_s32(0xB8D1B717);
  while (1)
  {
    float32x4_t v12 = (int *)(v9 + 48 * v11);
    uint64_t v13 = v12[3];
    if (v13 == 0x7FFFFFFF)
    {
      uint64_t v15 = *v12;
      uint64_t v14 = v12[1];
      float32x4_t v16 = *(float32x4_t *)(v8 + 16 * v15);
      uint64_t v17 = v12[2];
      float32x4_t v18 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v14), v16);
      float32x4_t v19 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v17), v16);
      int8x16_t v20 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), vnegq_f32(v18)), v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL));
      float32x4_t v21 = vmulq_f32(vsubq_f32(v7, v16), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v20, 0xCuLL));
      float32x4_t v22 = (float32x4_t)xmmword_20B5CC220;
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0] >= 0.0)
      {
        float32x4_t v23 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(v47 + 48 * v11), v7.f32[0]), v43, *(float32x4_t *)(v47 + 48 * v11 + 16)), v42, *(float32x4_t *)(v47 + 48 * v11 + 32));
        float32x4_t v44 = *(float32x4_t *)(v8 + 16 * v15);
        float32x4_t v45 = *(float32x4_t *)(v8 + 16 * v14);
        float32x4_t v46 = *(float32x4_t *)(v8 + 16 * v17);
        __cubicPolynomialRoot(v23.f32[0], v23.f32[1], v23.f32[2]);
        *(__n64 *)v25.f32 = __triangleBarycentricCoords(vmlaq_n_f32(v44, *(float32x4_t *)(v10 + 16 * v15), v24), vmlaq_n_f32(v45, *(float32x4_t *)(v10 + 16 * v14), v24), vmlaq_n_f32(v46, *(float32x4_t *)(v10 + 16 * v17), v24), (float32x4_t)a4);
        float32x4_t v7 = (float32x4_t)a4;
        float32x4_t v22 = v25;
        v22.i32[3] = 0;
      }
    }
    else
    {
      *(double *)v26.i64 = _barycentricCoords(*(float32x4_t *)(v47 + 48 * v11), *(float32x4_t *)(v47 + 48 * v11 + 16), *(float32x4_t *)(v47 + 48 * v11 + 32), *(float32x4_t *)(v8 + 16 * v13), v7);
      float32x4_t v7 = (float32x4_t)a4;
      float32x4_t v22 = v26;
    }
    if ((vminvq_u32((uint32x4_t)vcgtq_f32(v22, v49)) & 0x80000000) != 0)
    {
      *a3 = v22;
      *a2 = v11;
      return *(float *)(v9 + 48 * v11 + 44) >= a5;
    }
    float v27 = v22.f32[1];
    uint64_t v28 = v22.f32[1] < v22.f32[0];
    if (v22.f32[1] >= v22.f32[0]) {
      float v27 = v22.f32[0];
    }
    if (v22.f32[2] < v27)
    {
      float v27 = v22.f32[2];
      uint64_t v28 = 2;
    }
    if (v22.f32[3] < v27) {
      uint64_t v28 = 3;
    }
    unsigned int v29 = *(_DWORD *)(v9 + 48 * v11 + 4 * g_VertexFrontFaceIndex[v28] + 16);
    if (v29 == -1) {
      break;
    }
    unsigned int v11 = v29;
    if (!--v5) {
      return 0;
    }
  }
  if (v11 == -1)
  {
    float32x4_t v50 = v22;
    float32x4_t v31 = scn_default_log();
    BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_FAULT);
    float32x4_t v22 = v50;
    if (v32)
    {
      __lookupTetrahedron_cold_1(v31, v33, v34, v35, v36, v37, v38, v39);
      float32x4_t v22 = v50;
    }
  }
  *a3 = v22;
  *a2 = v11;
  return 1;
}

double _barycentricCoords(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5 = vsubq_f32(a5, a4);
  *(void *)&double result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v5.f32[0]), a2, *(float32x2_t *)v5.f32, 1), a3, v5, 2).u64[0];
  return result;
}

void __debugDrawQuery(void *a1, unsigned int a2, float32x4_t a3, float a4)
{
  uint64_t v5 = a1[2] + 64;
  float32x4_t v6 = (int *)(a1[6] + 48 * a2);
  long long v8 = xmmword_20B5ED910;
  *((float *)&v8 + 2) = 0.25098 * a4;
  C3DAuthoringEnvironmentAppendDebugSegment(a1[31], 0, (float *)&v8, 0, *(float32x4_t *)(v5 + 16 * *v6), a3);
  C3DAuthoringEnvironmentAppendDebugSegment(a1[31], 0, (float *)&v8, 0, *(float32x4_t *)(v5 + 16 * v6[1]), a3);
  C3DAuthoringEnvironmentAppendDebugSegment(a1[31], 0, (float *)&v8, 0, *(float32x4_t *)(v5 + 16 * v6[2]), a3);
  C3DAuthoringEnvironmentAppendDebugSegment(a1[31], 0, (float *)&v8, 0, *(float32x4_t *)(v5 + 16 * v6[3]), a3);
}

float32x4_t C3DLightProbesQuerySH2(uint64_t a1, unsigned int *a2, float32x4_t *a3, int32x4_t a4)
{
  if (!a2)
  {
    int32x4_t v35 = a4;
    float32x4_t v7 = scn_default_log();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_FAULT);
    a4 = v35;
    if (v8)
    {
      C3DLightProbesQuerySH2_cold_1(v7, v9, v10, v11, v12, v13, v14, v15);
      a4 = v35;
    }
  }
  __n128 v36 = 0uLL;
  BOOL v16 = __lookupTetrahedron(a1, a2, (float32x4_t *)&v36, a4, 0.0);
  uint64_t v17 = (int *)(*(void *)(a1 + 48) + 48 * *a2);
  uint64_t v18 = *(void *)(a1 + 24) + 192;
  if (v16)
  {
    float32x4_t v19 = (float32x4_t *)(v18 + 48 * *v17);
    float32x4_t result = (float32x4_t)v36;
    float32x4_t v21 = vmulq_n_f32(*v19, v36.n128_f32[0]);
    *a3 = v21;
    float32x4_t v22 = vmulq_n_f32(v19[1], result.f32[0]);
    a3[1] = v22;
    float32x4_t v23 = vmulq_n_f32(v19[2], result.f32[0]);
    a3[2] = v23;
    float v24 = (float32x4_t *)(v18 + 48 * v17[1]);
    float32x4_t v25 = vmlaq_lane_f32(v21, *v24, *(float32x2_t *)result.f32, 1);
    *a3 = v25;
    float32x4_t v26 = vmlaq_lane_f32(v22, v24[1], *(float32x2_t *)result.f32, 1);
    a3[1] = v26;
    float32x4_t v27 = vmlaq_lane_f32(v23, v24[2], *(float32x2_t *)result.f32, 1);
    a3[2] = v27;
    uint64_t v28 = (float32x4_t *)(v18 + 48 * v17[2]);
    float32x4_t v29 = vmlaq_laneq_f32(v25, *v28, result, 2);
    *a3 = v29;
    float32x4_t v30 = vmlaq_laneq_f32(v26, v28[1], result, 2);
    a3[1] = v30;
    float32x4_t v31 = vmlaq_laneq_f32(v27, v28[2], result, 2);
    a3[2] = v31;
    BOOL v32 = (float32x4_t *)(v18 + 48 * v17[3]);
    *a3 = vmlaq_laneq_f32(v29, *v32, result, 3);
    a3[1] = vmlaq_laneq_f32(v30, v32[1], result, 3);
    a3[2] = vmlaq_laneq_f32(v31, v32[2], result, 3);
  }
  else
  {
    uint64_t v33 = v18 + 48 * *v17;
    float32x4_t result = *(float32x4_t *)v33;
    float32x4_t v34 = *(float32x4_t *)(v33 + 32);
    a3[1] = *(float32x4_t *)(v33 + 16);
    a3[2] = v34;
    *a3 = result;
  }
  return result;
}

float32x4_t C3DLightProbesQueryBoxSH3(void *a1, unsigned int *a2, float32x4_t *a3, int32x4_t a4, float32x4_t a5)
{
  int32x4_t v54 = a4;
  if (!a2)
  {
    float32x4_t v53 = a5;
    BOOL v8 = scn_default_log();
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_FAULT);
    a5 = v53;
    a4 = v54;
    if (v9)
    {
      C3DLightProbesQuerySH2_cold_1(v8, v10, v11, v12, v13, v14, v15, v16);
      a5 = v53;
      a4 = v54;
    }
  }
  float32x4_t v17 = vmulq_f32(a5, a5);
  float32x4_t v56 = 0uLL;
  if (__lookupTetrahedron((uint64_t)a1, a2, &v56, a4, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]))
  {
    float32x4_t v18 = v56;
    if (a1[31])
    {
      float32x4_t v19 = (float32x4_t)v54;
      float32x4_t v55 = v56;
      __debugDrawQuery(a1, *a2, v19, v56.f32[0]);
      float32x4_t v18 = v55;
    }
    int8x16_t v20 = (int *)(a1[6] + 48 * *a2);
    uint64_t v21 = a1[3] + 448;
    float32x4_t v22 = (float32x4_t *)(v21 + 112 * *v20);
    float32x4_t v23 = vmulq_n_f32(*v22, v18.f32[0]);
    *a3 = v23;
    float32x4_t v24 = vmulq_n_f32(v22[1], v18.f32[0]);
    a3[1] = v24;
    float32x4_t v25 = vmulq_n_f32(v22[2], v18.f32[0]);
    a3[2] = v25;
    float32x4_t v26 = vmulq_n_f32(v22[3], v18.f32[0]);
    a3[3] = v26;
    float32x4_t v27 = vmulq_n_f32(v22[4], v18.f32[0]);
    a3[4] = v27;
    float32x4_t v28 = vmulq_n_f32(v22[5], v18.f32[0]);
    a3[5] = v28;
    float32x4_t v29 = vmulq_n_f32(v22[6], v18.f32[0]);
    a3[6] = v29;
    float32x4_t v30 = (float32x4_t *)(v21 + 112 * v20[1]);
    float32x4_t v31 = vmlaq_lane_f32(v23, *v30, *(float32x2_t *)v18.f32, 1);
    *a3 = v31;
    float32x4_t v32 = vmlaq_lane_f32(v24, v30[1], *(float32x2_t *)v18.f32, 1);
    a3[1] = v32;
    float32x4_t v33 = vmlaq_lane_f32(v25, v30[2], *(float32x2_t *)v18.f32, 1);
    a3[2] = v33;
    float32x4_t v34 = vmlaq_lane_f32(v26, v30[3], *(float32x2_t *)v18.f32, 1);
    a3[3] = v34;
    float32x4_t v35 = vmlaq_lane_f32(v27, v30[4], *(float32x2_t *)v18.f32, 1);
    a3[4] = v35;
    float32x4_t v36 = vmlaq_lane_f32(v28, v30[5], *(float32x2_t *)v18.f32, 1);
    a3[5] = v36;
    float32x4_t v37 = vmlaq_lane_f32(v29, v30[6], *(float32x2_t *)v18.f32, 1);
    a3[6] = v37;
    uint64_t v38 = (float32x4_t *)(v21 + 112 * v20[2]);
    float32x4_t v39 = vmlaq_laneq_f32(v31, *v38, v18, 2);
    *a3 = v39;
    float32x4_t v40 = vmlaq_laneq_f32(v32, v38[1], v18, 2);
    a3[1] = v40;
    float32x4_t v41 = vmlaq_laneq_f32(v33, v38[2], v18, 2);
    a3[2] = v41;
    float32x4_t v42 = vmlaq_laneq_f32(v34, v38[3], v18, 2);
    a3[3] = v42;
    float32x4_t v43 = vmlaq_laneq_f32(v35, v38[4], v18, 2);
    a3[4] = v43;
    float32x4_t v44 = vmlaq_laneq_f32(v36, v38[5], v18, 2);
    a3[5] = v44;
    float32x4_t result = vmlaq_laneq_f32(v37, v38[6], v18, 2);
    a3[6] = result;
    int v46 = v20[3];
    if (v46 <= 2147483645)
    {
      uint64_t v47 = (float32x4_t *)(v21 + 112 * v46);
      *a3 = vmlaq_laneq_f32(v39, *v47, v18, 3);
      a3[1] = vmlaq_laneq_f32(v40, v47[1], v18, 3);
      a3[2] = vmlaq_laneq_f32(v41, v47[2], v18, 3);
      a3[3] = vmlaq_laneq_f32(v42, v47[3], v18, 3);
      a3[4] = vmlaq_laneq_f32(v43, v47[4], v18, 3);
      a3[5] = vmlaq_laneq_f32(v44, v47[5], v18, 3);
      float32x4_t result = vmlaq_laneq_f32(result, v47[6], v18, 3);
      a3[6] = result;
    }
  }
  else
  {
    BOOL v48 = (float32x4_t *)a1[3];
    float32x4_t v49 = v48[28];
    float32x4_t v50 = v48[30];
    a3[1] = v48[29];
    a3[2] = v50;
    *a3 = v49;
    float32x4_t result = v48[31];
    float32x4_t v51 = v48[32];
    float32x4_t v52 = v48[34];
    a3[5] = v48[33];
    a3[6] = v52;
    a3[3] = result;
    a3[4] = v51;
  }
  return result;
}

float32x4_t C3DLightProbesQuerySH3(void *a1, unsigned int *a2, float32x4_t *a3, int32x4_t a4)
{
  int32x4_t v51 = a4;
  if (!a2)
  {
    float32x4_t v7 = scn_default_log();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_FAULT);
    a4 = v51;
    if (v8)
    {
      C3DLightProbesQuerySH2_cold_1(v7, v9, v10, v11, v12, v13, v14, v15);
      a4 = v51;
    }
  }
  float32x4_t v53 = 0uLL;
  if (__lookupTetrahedron((uint64_t)a1, a2, &v53, a4, 0.0))
  {
    float32x4_t v16 = v53;
    if (a1[31])
    {
      float32x4_t v17 = (float32x4_t)v51;
      float32x4_t v52 = v53;
      __debugDrawQuery(a1, *a2, v17, v53.f32[0]);
      float32x4_t v16 = v52;
    }
    float32x4_t v18 = (int *)(a1[6] + 48 * *a2);
    uint64_t v19 = a1[3] + 448;
    int8x16_t v20 = (float32x4_t *)(v19 + 112 * *v18);
    float32x4_t v21 = vmulq_n_f32(*v20, v16.f32[0]);
    *a3 = v21;
    float32x4_t v22 = vmulq_n_f32(v20[1], v16.f32[0]);
    a3[1] = v22;
    float32x4_t v23 = vmulq_n_f32(v20[2], v16.f32[0]);
    a3[2] = v23;
    float32x4_t v24 = vmulq_n_f32(v20[3], v16.f32[0]);
    a3[3] = v24;
    float32x4_t v25 = vmulq_n_f32(v20[4], v16.f32[0]);
    a3[4] = v25;
    float32x4_t v26 = vmulq_n_f32(v20[5], v16.f32[0]);
    a3[5] = v26;
    float32x4_t v27 = vmulq_n_f32(v20[6], v16.f32[0]);
    a3[6] = v27;
    float32x4_t v28 = (float32x4_t *)(v19 + 112 * v18[1]);
    float32x4_t v29 = vmlaq_lane_f32(v21, *v28, *(float32x2_t *)v16.f32, 1);
    *a3 = v29;
    float32x4_t v30 = vmlaq_lane_f32(v22, v28[1], *(float32x2_t *)v16.f32, 1);
    a3[1] = v30;
    float32x4_t v31 = vmlaq_lane_f32(v23, v28[2], *(float32x2_t *)v16.f32, 1);
    a3[2] = v31;
    float32x4_t v32 = vmlaq_lane_f32(v24, v28[3], *(float32x2_t *)v16.f32, 1);
    a3[3] = v32;
    float32x4_t v33 = vmlaq_lane_f32(v25, v28[4], *(float32x2_t *)v16.f32, 1);
    a3[4] = v33;
    float32x4_t v34 = vmlaq_lane_f32(v26, v28[5], *(float32x2_t *)v16.f32, 1);
    a3[5] = v34;
    float32x4_t v35 = vmlaq_lane_f32(v27, v28[6], *(float32x2_t *)v16.f32, 1);
    a3[6] = v35;
    float32x4_t v36 = (float32x4_t *)(v19 + 112 * v18[2]);
    float32x4_t v37 = vmlaq_laneq_f32(v29, *v36, v16, 2);
    *a3 = v37;
    float32x4_t v38 = vmlaq_laneq_f32(v30, v36[1], v16, 2);
    a3[1] = v38;
    float32x4_t v39 = vmlaq_laneq_f32(v31, v36[2], v16, 2);
    a3[2] = v39;
    float32x4_t v40 = vmlaq_laneq_f32(v32, v36[3], v16, 2);
    a3[3] = v40;
    float32x4_t v41 = vmlaq_laneq_f32(v33, v36[4], v16, 2);
    a3[4] = v41;
    float32x4_t v42 = vmlaq_laneq_f32(v34, v36[5], v16, 2);
    a3[5] = v42;
    float32x4_t result = vmlaq_laneq_f32(v35, v36[6], v16, 2);
    a3[6] = result;
    int v44 = v18[3];
    if (v44 <= 2147483645)
    {
      float32x4_t v45 = (float32x4_t *)(v19 + 112 * v44);
      *a3 = vmlaq_laneq_f32(v37, *v45, v16, 3);
      a3[1] = vmlaq_laneq_f32(v38, v45[1], v16, 3);
      a3[2] = vmlaq_laneq_f32(v39, v45[2], v16, 3);
      a3[3] = vmlaq_laneq_f32(v40, v45[3], v16, 3);
      a3[4] = vmlaq_laneq_f32(v41, v45[4], v16, 3);
      a3[5] = vmlaq_laneq_f32(v42, v45[5], v16, 3);
      float32x4_t result = vmlaq_laneq_f32(result, v45[6], v16, 3);
      a3[6] = result;
    }
  }
  else
  {
    int v46 = (float32x4_t *)a1[3];
    float32x4_t v47 = v46[28];
    float32x4_t v48 = v46[30];
    a3[1] = v46[29];
    a3[2] = v48;
    *a3 = v47;
    float32x4_t result = v46[31];
    float32x4_t v49 = v46[32];
    float32x4_t v50 = v46[34];
    a3[5] = v46[33];
    a3[6] = v50;
    a3[3] = result;
    a3[4] = v49;
  }
  return result;
}

__n128 C3DLightProbesSetGlobalSH3(uint64_t a1, uint64_t a2, uint64_t a3, __n128 result)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 232) == 3)
  {
    if (a3 != 108)
    {
      float32x4_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        C3DLightProbesSetGlobalSH3_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    uint64_t v14 = 0;
    v23[0] = a2;
    v23[1] = a2 + 36;
    v23[2] = a2 + 72;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0xBEA6C6BC);
    do
    {
      uint64_t v16 = v23[v14];
      v17.i32[0] = *(_DWORD *)(v16 + 12);
      v17.i32[1] = *(_DWORD *)(v16 + 4);
      *(float32x2_t *)&long long v18 = vmul_f32(v17, v15);
      *((float *)&v18 + 2) = *(float *)(v16 + 8) * 0.32573;
      *((float *)&v18 + 3) = (float)(*(float *)(v16 + 24) * -0.078848) + (float)(*(float *)v16 * 0.28209);
      *(&v24 + v14++) = v18;
    }
    while (v14 != 3);
    uint64_t v19 = 0;
    long long v20 = v25;
    *(_OWORD *)(a1 + 80) = v24;
    *(_OWORD *)(a1 + 96) = v20;
    *(_OWORD *)(a1 + 112) = v26;
    do
    {
      *(&v24 + v19) = (__int128)vmulq_f32(*(float32x4_t *)(v23[v19] + 16), (float32x4_t)xmmword_20B5ED8F0);
      ++v19;
    }
    while (v19 != 3);
    long long v21 = v25;
    *(_OWORD *)(a1 + 128) = v24;
    *(_OWORD *)(a1 + 144) = v21;
    *(_OWORD *)(a1 + 160) = v26;
    v22.i32[0] = *(_DWORD *)(a2 + 32);
    v22.i32[1] = *(_DWORD *)(a2 + 68);
    result.n128_u64[0] = (unint64_t)vmul_f32(v22, (float32x2_t)vdup_n_s32(0x3E0BD8A0u));
    result.n128_f32[2] = *(float *)(a2 + 104) * 0.13657;
    result.n128_u32[3] = 1.0;
    *(__n128 *)(a1 + 176) = result;
  }
  return result;
}

uint64_t C3DLightProbesSystemGetSphericalHarmonicsOrder(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

BOOL computeTetrahedronCircumsphereMatrix(float32x4_t *a1, uint64_t a2)
{
  float32x4_t v2 = *(float32x4_t *)(a2 + 16 * a1->i32[0]);
  float32x4_t v3 = *(float32x4_t *)(a2 + 16 * a1->i32[1]);
  float32x4_t v4 = *(float32x4_t *)(a2 + 16 * a1->i32[2]);
  float32x4_t v5 = *(float32x4_t *)(a2 + 16 * a1->i32[3]);
  int8x16_t v6 = (int8x16_t)vsubq_f32(v3, v2);
  double v7 = *(float *)v6.i32;
  int8x16_t v8 = (int8x16_t)vsubq_f32(v4, v2);
  double v9 = *(float *)&v8.i32[1];
  int8x16_t v10 = (int8x16_t)vsubq_f32(v5, v2);
  _D20 = *(float *)&v10.i32[1];
  v12.i32[0] = vextq_s8(v8, v8, 8uLL).u32[0];
  v12.i32[1] = v8.i32[0];
  v8.i32[0] = vextq_s8(v10, v10, 8uLL).u32[0];
  v8.i32[1] = v10.i32[0];
  _Q5 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 4uLL));
  float64x2_t v14 = vcvtq_f64_f32(*(float32x2_t *)v8.i8);
  float64x2_t v15 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v14.f64[0], 0);
  v15.f64[0] = _D20;
  _Q17 = vcvtq_f64_f32(v12);
  float64x2_t v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&_Q17.f64[0], 0);
  v17.f64[0] = v9;
  float64x2_t v18 = vmlaq_f64(vmulq_f64(_Q17, vnegq_f64(v15)), v14, v17);
  __asm
  {
    FMLA            D22, D20, V17.D[1]
    FMLA            D23, D22, V5.D[1]
  }
  double v25 = fabs(_D23);
  if (v25 < 0.00001)
  {
    __asm { FMOV            V4.4S, #0.25 }
    float32x4_t v34 = vsubq_f32(vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v2, v3), v4), v5), _Q4), v2);
  }
  else
  {
    float64_t v26 = -_Q17.f64[1] * _Q5.f64[0] + v7 * v9;
    double v27 = vmlad_n_f64(-(v7 * _D20), v14.f64[1], _Q5.f64[0]);
    double v28 = vmlad_n_f64(_D20 * _D20 + v14.f64[1] * v14.f64[1], v14.f64[0], v14.f64[0]);
    double v29 = vmlad_n_f64(v9 * v9 + _Q17.f64[1] * _Q17.f64[1], _Q17.f64[0], _Q17.f64[0]);
    double v30 = vmulq_f64(_Q5, _Q5).f64[0] + v7 * v7 + _Q5.f64[1] * _Q5.f64[1];
    double v31 = (v29 * v27 + v30 * _D22 + v28 * v26) * (0.5 / _D23);
    *(void *)&v32.f64[0] = vdupq_laneq_s64((int64x2_t)_Q5, 1).u64[0];
    v32.f64[1] = v7;
    float32x4_t v34 = (float32x4_t)vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_f64(vmulq_f64(vnegq_f64(_Q5), v14), v32, v15), v29), v18, v30), vmlaq_f64(vmulq_f64(v32, vnegq_f64(v17)), _Q17, _Q5), v28), 0.5 / _D23);
    *(float32x2_t *)v34.f32 = vcvt_f32_f64((float64x2_t)v34);
    float32_t v33 = v31;
    v34.f32[2] = v33;
  }
  float32x4_t v36 = vaddq_f32(v2, v34);
  float32x4_t v37 = vmulq_f32(v34, v34);
  v36.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u32[0];
  a1[2] = v36;
  return v25 >= 0.00001;
}

void C3D::DOFFinalBlurPass::DOFFinalBlurPass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *float32x4_t v5 = &unk_26BF6D6E0;
  v5[14] = a4;
}

const char *C3D::DOFFinalBlurPass::name(C3D::DOFFinalBlurPass *this)
{
  return "DOFFinalBlurPass";
}

double C3D::DOFFinalBlurPass::setup(C3D::DOFFinalBlurPass *this)
{
  C3D::Pass::setInputCount(this, 2u);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = (*(uint64_t (**)(C3D::DOFFinalBlurPass *))(*(void *)this + 88))(this);
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex((C3D::DOFFinalBlurPass *)((char *)this + 32), 0);
  *(void *)(v3 + 8) = "DofColorCoC";
  *(_WORD *)(v3 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 14), 1.0);
  *(_WORD *)(v3 + 18) = (int)fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 14), 1.0);
  *(_WORD *)(v3 + 28) = 115;
  uint64_t v4 = C3D::PassDescriptor::inputAtIndex((C3D::DOFFinalBlurPass *)((char *)this + 32), 1u);
  *(void *)(v4 + 8) = "DOFCoCBlurred";
  *(_WORD *)(v4 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 14) * 0.25, 1.0);
  *(_WORD *)(v4 + 18) = (int)fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 14) * 0.25, 1.0);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::DOFFinalBlurPass *)((char *)this + 32), 0);
  *(void *)(v5 + 8) = "DOF-Final";
  *(_WORD *)(v5 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 14), 1.0);
  double result = fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 14), 1.0);
  *(_WORD *)(v5 + 18) = (int)result;
  *(_WORD *)(v5 + 28) = 115;
  return result;
}

uint64_t C3D::DOFFinalBlurPass::compile(C3D::DOFFinalBlurPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  -[SCNMTLRenderContext device](RenderContext);
  unint64_t v3 = (2 * *(_DWORD *)(*((void *)this + 14) + 4)) | (unint64_t)*(unsigned __int8 *)(*((void *)this + 14)
                                                                                              + 20);
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::DOFFinalBlurPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) >> 47));
  *((void *)this + 15) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::DOFFinalBlurPass::execute(C3D::Pass *a1, SCNMTLComputeCommandEncoder **a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *((void *)a1 + 14);
  int8x16_t v6 = *(MTLBuffer **)(v4 + 40);
  unint64_t v5 = *(void *)(v4 + 48);
  if ((*a2)->_buffers[0] == v6)
  {
    if (v3->_offsets[0] == v5) {
      goto LABEL_5;
    }
  }
  else
  {
    v3->_buffers[0] = v6;
  }
  v3->_offsets[0] = v5;
  v3->_buffersToBind[0] |= 1uLL;
LABEL_5:
  uint64_t v7 = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((void *)a1 + 15) + 40);
  if (v3->_buffers[1] == (MTLBuffer *)v7)
  {
    if (!v3->_offsets[1]) {
      goto LABEL_9;
    }
  }
  else
  {
    v3->_buffers[1] = (MTLBuffer *)v7;
  }
  v3->_offsets[1] = 0;
  v3->_buffersToBind[0] |= 2uLL;
LABEL_9:
  uint64_t v8 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)a1 + 15) + 24);
  double v9 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v8);
  SCNMTLComputeCommandEncoder::dispatchOne(v3, v9);
  int8x16_t v10 = C3D::Pass::inputTextureAtIndex(a1, 0);
  if ((void **)v3->_textures[0] != v10)
  {
    v3->_textures[0] = (MTLTexture *)v10;
    v3->_texturesToBind[0] |= 1uLL;
  }
  uint64_t v11 = C3D::Pass::inputTextureAtIndex(a1, 1u);
  if ((void **)v3->_textures[1] != v11)
  {
    v3->_textures[1] = (MTLTexture *)v11;
    v3->_texturesToBind[0] |= 2uLL;
  }
  float32x2_t v12 = (MTLTexture *)C3D::Pass::outputTextureAtIndex(a1, 0);
  if (v3->_textures[2] != v12)
  {
    v3->_textures[2] = v12;
    v3->_texturesToBind[0] |= 4uLL;
  }
  uint64_t v13 = C3D::Pass::outputTextureAtIndex(a1, 0);
  uint64_t v14 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)a1 + 15) + 16);
  float64x2_t v15 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v14);

  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v13, v15);
}

void C3D::DOFFinalBlurPassResource::~DOFFinalBlurPassResource(C3D::DOFFinalBlurPassResource *this)
{
  *(void *)this = &unk_26BF6E490;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4) {

  }
  unint64_t v5 = (void *)*((void *)this + 2);
  if (v5) {
}
  }

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E490;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4) {

  }
  unint64_t v5 = (void *)*((void *)this + 2);
  if (v5) {

  }
  JUMPOUT(0x210534FE0);
}

uint64_t C3DMaterialDefaultUVSetForProperty(int a1)
{
  if (a1 == 4) {
    return -1;
  }
  else {
    return 0;
  }
}

__CFString *C3DEffectCommonProfileNameForLightingModel(int a1)
{
  switch(a1)
  {
    case 0:
      long long v1 = kC3DLightingModelConstant;
      goto LABEL_10;
    case 1:
      long long v1 = kC3DLightingModelLambert;
      goto LABEL_10;
    case 2:
      long long v1 = kC3DLightingModelPhong;
      goto LABEL_10;
    case 3:
      long long v1 = kC3DLightingModelBlinn;
      goto LABEL_10;
    case 4:
      long long v1 = kC3DLightingModelNone;
      goto LABEL_10;
    case 5:
      long long v1 = kC3DLightingModelPhysicallyBased;
      goto LABEL_10;
    case 6:
      long long v1 = kC3DLightingModelShadowOnly;
LABEL_10:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

CFComparisonResult C3DEffectCommonProfileLightingModelForName(const __CFString *a1)
{
  if (CFEqual(a1, @"physicallyBased")) {
    return 5;
  }
  CFComparisonResult result = CFStringCompare(a1, @"constant", 0);
  if (result)
  {
    if (CFStringCompare(a1, @"lambert", 0))
    {
      if (CFStringCompare(a1, @"phong", 0))
      {
        if (CFStringCompare(a1, @"blinn", 0))
        {
          if (CFStringCompare(a1, @"none", 0))
          {
            if (CFStringCompare(a1, @"shadowOnly", 0)) {
              return 0xFFFFFFFFLL;
            }
            else {
              return 6;
            }
          }
          else
          {
            return 4;
          }
        }
        else
        {
          return 3;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void C3DEffectCommonProfileSetColor(uint64_t a1, int a2, float *a3)
{
  if (!a1)
  {
    int8x16_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 1);
  if (EffectSlot) {
    C3DEffectSlotSetColor(EffectSlot, a3);
  }
}

void C3DEffectCommonProfileSetImage(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    int8x16_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot) {
    C3DEffectSlotSetImage(EffectSlot, a3);
  }
}

uint64_t C3DEffectCommonProfileUVSetIsSet(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result) {
    return *(_DWORD *)(result + 76) != -2;
  }
  return result;
}

void C3DEffectCommonProfileSetUVSet(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != -1);
  if (EffectSlot)
  {
    if (*(_DWORD *)(EffectSlot + 76) != a3)
    {
      *(_DWORD *)(EffectSlot + 76) = a3;
      __PostParentDidChangeNotification(EffectSlot, 0, 0);
    }
  }
}

uint64_t C3DEffectCommonProfileGetTextureSampler(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

void C3DEffectCommonProfileSetTextureSampler(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot) {
    C3DEffectSlotSetTextureSampler(EffectSlot, a3);
  }
}

CFTypeRef _C3DEffectCommonProfileSetTextureForTextureProxy(uint64_t a1, int a2, const void *a3)
{
  CFTypeRef result = (CFTypeRef)C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (result)
  {
    return C3DEffectSlotSetTextureFromImageProxy((uint64_t)result, a3);
  }
  return result;
}

CFTypeRef C3DEffectSlotSetTextureFromImageProxy(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 32);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 32) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 32) = result;
  }
  return result;
}

void C3DEffectCommonProfileSetTexture(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot)
  {
    C3DEffectSlotSetTexture(EffectSlot, a3);
    *(_WORD *)(a1 + 194) &= ~0x80u;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

void C3DEffectCommonProfileSetMTLTexture(uint64_t a1, int a2, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot)
  {
    C3DEffectSlotSetMTLTexture(EffectSlot, a3);
    *(_WORD *)(a1 + 194) &= ~0x80u;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

uint64_t C3DEffectCommonProfileGetImageProxy(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result)
  {
    if (*(unsigned char *)(result + 48) == 2) {
      return *(void *)(result + 40);
    }
    else {
      return 0;
    }
  }
  return result;
}

void C3DEffectCommonProfileSetAvoidsOverLighting(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __int16 v12 = *(_WORD *)(a1 + 194);
  if (((((v12 & 1) == 0) ^ a2) & 1) == 0)
  {
    *(_WORD *)(a1 + 194) = v12 & 0xFFFE | a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

void C3DEffectCommonProfileSetPerPixelLit(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 192) != a2)
  {
    *(unsigned char *)(a1 + 192) = a2;
    *(_WORD *)(a1 + 194) |= 2u;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

void C3DEffectCommonProfileSetEnableLockAmbientWithDiffuse(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 193) != a2)
  {
    *(unsigned char *)(a1 + 193) = a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

BOOL C3DEffectCommonProfileIsUsingSelfIllumination(uint64_t a1)
{
  if (C3DEffectCommonProfileContainsContentForEffectProperty(a1, 9)) {
    return 1;
  }
  Color = (float *)C3DEffectCommonProfileGetColor(a1, 9);
  return !C3DColor4IsBlack(Color);
}

void C3DEffectCommonProfileSetSelfIlluminationOcclusion(uint64_t a1, float a2)
{
  if (*(float *)(a1 + 176) != a2)
  {
    *(float *)(a1 + 176) = a2;
    C3DMaterialTouchValueStorageModificationCount(*(void *)(a1 + 16));
  }
}

uint64_t C3DEffectCommonProfileIsUsingMappingChannel(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned __int8 v12 = 0;
  while (1)
  {
    uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, (char)v12, 0);
    if (EffectSlot)
    {
      int v14 = *(_DWORD *)(EffectSlot + 76);
      if (v14 == -2)
      {
        if (*(unsigned char *)(EffectSlot + 50) == 4) {
          int v14 = -1;
        }
        else {
          int v14 = 0;
        }
      }
      if (v14 == a2) {
        break;
      }
    }
    unsigned int v15 = v12++;
    if (v15 >= 0xF) {
      return 0;
    }
  }
  return 1;
}

BOOL C3DEffectSlotIsValid(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 48) & 0x200) != 0) {
    return 0;
  }
  if (C3DEffectSlotHasImageOrTexture(a1)) {
    return 1;
  }
  unint64_t v3 = (float *)C3DEffectCommonProfileDefaultColorForEffectProperty(*(char *)(a1 + 50));
  return !C3DColor4IsEqualToColor4((float *)(a1 + 16), v3);
}

uint64_t C3DEffectSlotGetColorIfApplicable(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(_WORD *)(a1 + 48) & 0x200) != 0) {
    return 0;
  }
  if (*(void *)(a1 + 40)) {
    return 0;
  }
  return a1 + 16;
}

uint64_t C3DEffectSlotGetImageTransform(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

void C3DEffectSlotSetImageTransform(uint64_t a1, long long *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned __int8 v12 = *(_OWORD **)(a1 + 64);
  if (a2)
  {
    if (!v12)
    {
      unsigned __int8 v12 = malloc_type_malloc(0x40uLL, 0x1000040FA0F61DDuLL);
      *(void *)(a1 + 64) = v12;
    }
    long long v13 = *a2;
    long long v14 = a2[1];
    long long v15 = a2[3];
    v12[2] = a2[2];
    v12[3] = v15;
    _OWORD *v12 = v13;
    v12[1] = v14;
  }
  else
  {
    if (!v12) {
      return;
    }
    C3DMatrix4x4MakeIdentity((uint64_t)v12);
  }
  __PostParentDidChangeNotification(a1, 0, 0);
}

void C3DEffectSlotSetSRGB(uint64_t a1, int a2)
{
  __int16 v2 = *(_WORD *)(a1 + 48);
  if (((((v2 & 0x400) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      __int16 v3 = 1024;
    }
    else {
      __int16 v3 = 0;
    }
    *(_WORD *)(a1 + 48) = v2 & 0xFBFF | v3;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

char *C3DEffectPropertyGetNameStr(unsigned int a1)
{
  if (a1 > 0x10) {
    return 0;
  }
  else {
    return off_2640075C8[a1];
  }
}

__CFString *_C3DEffectCommonProfileCFCopyDebugDescription(uint64_t a1)
{
  uint64_t Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  CFStringAppendFormat(Mutable, 0, @"<C3DEffectCommonProfile %p :", a1);
  unsigned int LightingModel = C3DEffectCommonProfileGetLightingModel(a1);
  if (LightingModel > 6) {
    uint64_t v4 = @"SCNLightingModelInvalid";
  }
  else {
    uint64_t v4 = off_264007650[LightingModel];
  }
  CFStringAppendFormat(Mutable, 0, @" lightingModel:%@", v4);
  unsigned int IsPerPixelLit = C3DEffectCommonProfileIsPerPixelLit(a1);
  CFStringAppendFormat(Mutable, 0, @" perPixelLit:%d", IsPerPixelLit);
  unsigned int IsOpaque = C3DEffectCommonProfileIsOpaque(a1);
  CFStringAppendFormat(Mutable, 0, @" isOpaque:%d", IsOpaque);
  unsigned int TransparencyMode = C3DEffectCommonProfileGetTransparencyMode(a1);
  CFStringAppendFormat(Mutable, 0, @" transparencyMode:%d", TransparencyMode);
  for (uint64_t i = 0; i != 21; ++i)
  {
    int v9 = C3DEffectCommonProfileGetLightingModel(a1);
    if (C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel(v9, (char)i))
    {
      uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, (char)i, 0);
      if (EffectSlot)
      {
        uint64_t v11 = EffectSlot;
        unsigned __int8 v12 = _C3DEffectCommonProfileCFCopyDebugDescription_propertyNames[i];
        BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(EffectSlot);
        CFStringAppendFormat(Mutable, 0, @"[%@] texture:%d xform:%d", v12, HasImageOrTexture, *(void *)(v11 + 64) != 0);
      }
    }
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

uint64_t _C3DEffectCommonProfileInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    long long v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (C3DCFTypeIsDictionary())
  {
    if (!a2 && (float32x2_t v22 = scn_default_log(), os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)))
    {
      _C3DTextureSamplerInitWithPropertyList_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
      if (!@"function")
      {
LABEL_10:
        double v30 = scn_default_log();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
        }
      }
    }
    else if (!@"function")
    {
      goto LABEL_10;
    }
    if (!a1)
    {
      float32x4_t v38 = scn_default_log();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
        C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v38, v39, v40, v41, v42, v43, v44, v45);
      }
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"function");
    if (Value)
    {
      int v47 = C3DEffectCommonProfileLightingModelForName(Value);
      C3DEffectCommonProfileSetLightingModel(a1, v47);
      int v48 = 1;
    }
    else
    {
      uint64_t v58 = scn_default_log();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
        _C3DEffectCommonProfileInitWithPropertyList_cold_1();
      }
      int v48 = 0;
    }
    int v59 = __DeserializeColor(a1, a2, @"emissionColor") & v48;
    BOOL v60 = __DeserializeColor(a1, a2, @"ambientColor");
    int v61 = v59 & v60 & __DeserializeColor(a1, a2, @"diffuseColor");
    BOOL v62 = __DeserializeColor(a1, a2, @"filterColor");
    int v63 = v61 & v62 & __DeserializeColor(a1, a2, @"specularColor");
    double valuePtr = 0.0;
    CFNumberRef v64 = (const __CFNumber *)CFDictionaryGetValue(a3, @"versionNumber");
    if (v64) {
      CFNumberGetValue(v64, kCFNumberDoubleType, &valuePtr);
    }
    if (valuePtr >= 0.12) {
      v63 &= __DeserializeColor(a1, a2, @"reflectiveColor");
    }
    BOOL v152 = __DeserializeColor(a1, a2, @"transparentColor");
    BOOL v151 = __DeserializeColor(a1, a2, @"normalColor");
    BOOL v150 = __DeserializeUVSet(a1, a2, @"emissionUVSet");
    BOOL v149 = __DeserializeUVSet(a1, a2, @"ambientUVSet");
    BOOL v148 = __DeserializeUVSet(a1, a2, @"diffuseUVSet");
    BOOL v147 = __DeserializeUVSet(a1, a2, @"filterUVSet");
    BOOL v146 = __DeserializeUVSet(a1, a2, @"specularUVSet");
    BOOL v145 = __DeserializeUVSet(a1, a2, @"reflectiveUVSet");
    BOOL v144 = __DeserializeUVSet(a1, a2, @"transparentUVSet");
    BOOL v143 = __DeserializeUVSet(a1, a2, @"normalUVSet");
    BOOL v142 = __DeserializeUVSet(a1, a2, @"shininessUVSet");
    int v141 = __DeserializeTextureSampler(a1, a2, @"emissionTextureSampler");
    int v140 = __DeserializeTextureSampler(a1, a2, @"ambientTextureSampler");
    int v139 = __DeserializeTextureSampler(a1, a2, @"diffuseTextureSampler");
    int v138 = __DeserializeTextureSampler(a1, a2, @"specularTextureSampler");
    int v65 = __DeserializeTextureSampler(a1, a2, @"reflectiveTextureSampler");
    int v66 = __DeserializeTextureSampler(a1, a2, @"transparentTextureSampler");
    int v67 = __DeserializeTextureSampler(a1, a2, @"filterTextureSampler");
    int v68 = __DeserializeTextureSampler(a1, a2, @"normalTextureSampler");
    int v69 = __DeserializeTextureSampler(a1, a2, @"shininessTextureSampler");
    int v70 = __DeserializeFloat(a1, a2, @"shininess");
    int v71 = __DeserializeFloat(a1, a2, @"reflectivity");
    int v72 = __DeserializeFloat(a1, a2, @"transparency");
    if (v63) {
      BOOL v73 = !v152;
    }
    else {
      BOOL v73 = 1;
    }
    uint64_t v57 = !v73
       && v151
       && v150
       && v149
       && v148
       && v147
       && v146
       && v145
       && v144
       && v143
       && v142
       && v141 != 0
       && v140 != 0
       && v139 != 0
       && v138 != 0
       && v65 != 0
       && v66 != 0
       && v67 != 0
       && v68 != 0
       && v69 != 0
       && v70 != 0
       && v71 != 0
       && v72 != 0;
    if (__DeserializeFloat(a1, a2, @"fresnelExponent"))
    {
      if (__DeserializeFloat(a1, a2, @"indexOfRefraction")) {
        uint64_t v57 = v57;
      }
      else {
        uint64_t v57 = 0;
      }
    }
    CFNumberRef v96 = (const __CFNumber *)CFDictionaryGetValue(a2, @"ambientIntensity");
    if (v96)
    {
      int v153 = 0;
      CFNumberGetValue(v96, kCFNumberFloatType, &v153);
      uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, 1, 1);
      *(_DWORD *)(EffectSlot + 72) = v153;
    }
    CFNumberRef v98 = (const __CFNumber *)CFDictionaryGetValue(a2, @"diffuseIntensity");
    if (v98)
    {
      int v153 = 0;
      CFNumberGetValue(v98, kCFNumberFloatType, &v153);
      uint64_t v99 = C3DEffectCommonProfileGetEffectSlot(a1, 2, 1);
      *(_DWORD *)(v99 + 72) = v153;
    }
    CFNumberRef v100 = (const __CFNumber *)CFDictionaryGetValue(a2, @"specularIntensity");
    if (v100)
    {
      int v153 = 0;
      CFNumberGetValue(v100, kCFNumberFloatType, &v153);
      uint64_t v101 = C3DEffectCommonProfileGetEffectSlot(a1, 3, 1);
      *(_DWORD *)(v101 + 72) = v153;
    }
    CFNumberRef v102 = (const __CFNumber *)CFDictionaryGetValue(a2, @"emissionIntensity");
    if (v102)
    {
      int v153 = 0;
      CFNumberGetValue(v102, kCFNumberFloatType, &v153);
      uint64_t v103 = C3DEffectCommonProfileGetEffectSlot(a1, 0, 1);
      *(_DWORD *)(v103 + 72) = v153;
    }
    CFNumberRef v104 = (const __CFNumber *)CFDictionaryGetValue(a2, @"multiplyIntensity");
    if (v104)
    {
      int v153 = 0;
      CFNumberGetValue(v104, kCFNumberFloatType, &v153);
      uint64_t v105 = C3DEffectCommonProfileGetEffectSlot(a1, 6, 1);
      *(_DWORD *)(v105 + 72) = v153;
    }
    CFNumberRef v106 = (const __CFNumber *)CFDictionaryGetValue(a2, @"transparentIntensity");
    if (v106)
    {
      int v153 = 0;
      CFNumberGetValue(v106, kCFNumberFloatType, &v153);
      uint64_t v107 = C3DEffectCommonProfileGetEffectSlot(a1, 5, 1);
      *(_DWORD *)(v107 + 72) = v153;
    }
    CFNumberRef v108 = (const __CFNumber *)CFDictionaryGetValue(a2, @"normalIntensity");
    if (v108)
    {
      int v153 = 0;
      CFNumberGetValue(v108, kCFNumberFloatType, &v153);
      uint64_t v109 = C3DEffectCommonProfileGetEffectSlot(a1, 7, 1);
      *(_DWORD *)(v109 + 72) = v153;
    }
    CFNumberRef v110 = (const __CFNumber *)CFDictionaryGetValue(a2, @"ambientOcclusionIntensity");
    if (v110)
    {
      int v153 = 0;
      CFNumberGetValue(v110, kCFNumberFloatType, &v153);
      uint64_t v111 = C3DEffectCommonProfileGetEffectSlot(a1, 8, 1);
      *(_DWORD *)(v111 + 72) = v153;
    }
    CFNumberRef v112 = (const __CFNumber *)CFDictionaryGetValue(a2, @"selfIlluminationIntensity");
    if (v112)
    {
      int v153 = 0;
      CFNumberGetValue(v112, kCFNumberFloatType, &v153);
      uint64_t v113 = C3DEffectCommonProfileGetEffectSlot(a1, 9, 1);
      *(_DWORD *)(v113 + 72) = v153;
    }
    CFNumberRef v114 = (const __CFNumber *)CFDictionaryGetValue(a2, @"metalness");
    if (v114)
    {
      int v153 = 0;
      CFNumberGetValue(v114, kCFNumberFloatType, &v153);
      uint64_t v115 = C3DEffectCommonProfileGetEffectSlot(a1, 10, 1);
      *(_DWORD *)(v115 + 72) = v153;
    }
    CFNumberRef v116 = (const __CFNumber *)CFDictionaryGetValue(a2, @"roughness");
    if (v116)
    {
      int v153 = 0;
      CFNumberGetValue(v116, kCFNumberFloatType, &v153);
      uint64_t v117 = C3DEffectCommonProfileGetEffectSlot(a1, 11, 1);
      *(_DWORD *)(v117 + 72) = v153;
    }
    CFNumberRef v118 = (const __CFNumber *)CFDictionaryGetValue(a2, @"displacementIntensity");
    if (v118)
    {
      int v153 = 0;
      CFNumberGetValue(v118, kCFNumberFloatType, &v153);
      uint64_t v119 = C3DEffectCommonProfileGetEffectSlot(a1, 15, 1);
      *(_DWORD *)(v119 + 72) = v153;
    }
    CFNumberRef v120 = (const __CFNumber *)CFDictionaryGetValue(a2, @"reflectiveIntensity");
    if (v120)
    {
      int v153 = 0;
      CFNumberGetValue(v120, kCFNumberFloatType, &v153);
      uint64_t v121 = C3DEffectCommonProfileGetEffectSlot(a1, 4, 1);
      *(_DWORD *)(v121 + 72) = v153;
    }
    float32x4_t v122 = CFDictionaryGetValue(a2, @"double sided");
    float32x4_t v123 = CFDictionaryGetValue(a2, @"cullMode");
    float32x4_t v124 = CFDictionaryGetValue(a2, @"avoidsOverlighting");
    uint64_t v125 = CFDictionaryGetValue(a2, @"locksAmbientWithDiffuse");
    int32x4_t v126 = CFDictionaryGetValue(a2, @"litPerPixel");
    uint64_t v127 = *(void *)(a1 + 16);
    v128 = (CFTypeRef *)MEMORY[0x263EFFB40];
    if (v127)
    {
      if (v122) {
        BOOL v129 = CFEqual(v122, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
      }
      else {
        BOOL v129 = 0;
      }
      C3DMaterialSetDoubleSided(v127, v129);
      uint64_t v130 = *(void *)(a1 + 16);
      if (v123) {
        BOOL v131 = CFEqual(v123, @"cullFront") != 0;
      }
      else {
        BOOL v131 = 0;
      }
      C3DMaterialSetCullMode(v130, v131);
    }
    if (v124) {
      __int16 v132 = CFEqual(v124, *v128) != 0;
    }
    else {
      __int16 v132 = 0;
    }
    *(_WORD *)(a1 + 194) = *(_WORD *)(a1 + 194) & 0xFFFE | v132;
    if (v125) {
      char v133 = CFEqual(v125, *v128) != 0;
    }
    else {
      char v133 = C3DWasLinkedBeforeMajorOSYear2014() ^ 1;
    }
    *(unsigned char *)(a1 + 193) = v133;
    if (v126)
    {
      BOOL v134 = CFEqual(v126, *v128) != 0;
      C3DEffectCommonProfileSetPerPixelLit(a1, v134);
    }
    uint64_t v135 = CFDictionaryGetValue(a2, @"transparencyMode");
    if (v135) {
      BOOL v136 = CFEqual(v135, @"A_ONE") == 0;
    }
    else {
      BOOL v136 = 0;
    }
    C3DEffectCommonProfileSetTransparencyMode(a1, v136);
    return v57;
  }
  float32x4_t v49 = scn_default_log();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
    _C3DEffectCommonProfileInitWithPropertyList_cold_5(v49, v50, v51, v52, v53, v54, v55, v56);
  }
  return 0;
}

__CFDictionary *_C3DEffectCommonProfileCopyPropertyList(uint64_t *cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)((char *)&v101[1] + 4) = *MEMORY[0x263EF8340];
  v95[0] = @"emissionColor";
  v95[1] = @"ambientColor";
  v95[2] = @"diffuseColor";
  v95[3] = @"specularColor";
  v95[4] = @"reflectiveColor";
  v95[5] = @"transparentColor";
  v95[6] = @"filterColor";
  v95[7] = @"normalColor";
  v94[0] = @"emissionImageID";
  v94[1] = @"ambientImageID";
  v94[2] = @"diffuseImageID";
  v94[3] = @"specularImageID";
  v94[4] = @"reflectiveImageID";
  v94[5] = @"transparentImageID";
  v94[6] = @"filterImageID";
  v94[7] = @"normalImageID";
  v94[8] = @"shininessImageID";
  v93[0] = @"emissionUVSet";
  v93[1] = @"ambientUVSet";
  v93[2] = @"diffuseUVSet";
  v93[3] = @"specularUVSet";
  v93[4] = @"reflectiveUVSet";
  v93[5] = @"transparentUVSet";
  v93[6] = @"filterUVSet";
  v93[7] = @"normalUVSet";
  v93[8] = @"shininessUVSet";
  v92[0] = @"shininess";
  v92[1] = @"reflectivity";
  v92[2] = @"transparency";
  v92[3] = @"indexOfRefraction";
  v92[4] = @"fresnelExponent";
  v91[0] = @"emissionTextureSampler";
  v91[1] = @"ambientTextureSampler";
  v91[2] = @"diffuseTextureSampler";
  v91[3] = @"specularTextureSampler";
  v91[4] = @"reflectiveTextureSampler";
  v91[5] = @"transparentTextureSampler";
  v91[6] = @"filterTextureSampler";
  v91[7] = @"normalTextureSampler";
  v91[8] = @"shininessTextureSampler";
  if (!cf)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    long long v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  CFAllocatorRef v22 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v22, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable)
  {
    uint64_t v24 = Mutable;
    uint64_t v25 = cf[2];
    if (v25)
    {
      if (C3DMaterialIsDoubleSided(cf[2])) {
        CFDictionarySetValue(v24, @"double sided", (const void *)*MEMORY[0x263EFFB40]);
      }
      int CullMode = C3DMaterialGetCullMode(v25);
      uint64_t v27 = kC3DCullBackValue;
      if (CullMode) {
        uint64_t v27 = kC3DCullFrontValue;
      }
      CFDictionarySetValue(v24, @"cullMode", *v27);
    }
    if (*((_WORD *)cf + 97)) {
      CFDictionarySetValue(v24, @"avoidsOverlighting", (const void *)*MEMORY[0x263EFFB40]);
    }
    if (*((unsigned char *)cf + 193)) {
      CFDictionarySetValue(v24, @"locksAmbientWithDiffuse", (const void *)*MEMORY[0x263EFFB40]);
    }
    if ((*((_WORD *)cf + 97) & 2) != 0)
    {
      uint64_t v28 = (const void **)MEMORY[0x263EFFB40];
      if (!*((unsigned char *)cf + 192)) {
        uint64_t v28 = (const void **)MEMORY[0x263EFFB38];
      }
      CFDictionarySetValue(v24, @"litPerPixel", *v28);
    }
    int LightingModel = C3DEffectCommonProfileGetLightingModel((uint64_t)cf);
    if (!@"function")
    {
      double v30 = scn_default_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
      }
    }
    float32x4_t v38 = C3DEffectCommonProfileNameForLightingModel(LightingModel);
    if (v38) {
      CFDictionarySetValue(v24, @"function", v38);
    }
    uint64_t v88 = v38;
    uint64_t v39 = 0;
    while (1)
    {
      CFStringRef v40 = (const __CFString *)v95[v39];
      int Property = __GetProperty(v40);
      if (Property != -1) {
        break;
      }
LABEL_40:
      if (++v39 == 8)
      {
        for (uint64_t i = 0; i != 9; ++i)
        {
          CFStringRef v51 = (const __CFString *)v94[i];
          int v52 = __GetProperty(v51);
          if (v52 != -1)
          {
            int v53 = v52;
            uint64_t Image = C3DEffectCommonProfileGetImage((uint64_t)cf, v52);
            if (Image)
            {
              uint64_t v55 = (const void *)Image;
              if (!v51)
              {
                uint64_t v56 = scn_default_log();
                if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
                  _C3DEffectCommonProfileCopyPropertyList_cold_2(v100, v101, v56);
                }
              }
              EntryID = C3DLibraryGetEntryID(a2, v55);
              if (EntryID)
              {
                __int32 v58 = (int)EntryID;
                if ((unint64_t)EntryID >= 0x7FFFFFFF)
                {
                  int v59 = scn_default_log();
                  if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
                    _C3DEffectCommonProfileCopyPropertyList_cold_3(v98, &v99, v59);
                  }
                }
                cStr.i32[0] = v58;
                CFAllocatorRef v60 = CFGetAllocator(v24);
                CFNumberRef v61 = CFNumberCreate(v60, kCFNumberIntType, &cStr);
                if (v61)
                {
                  CFNumberRef v62 = v61;
                  CFDictionarySetValue(v24, v51, v61);
                  CFRelease(v62);
                }
              }
            }
            uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)cf, v53, 0);
            if (EffectSlot)
            {
              int v64 = *(_DWORD *)(EffectSlot + 76);
              if (v64 == -2)
              {
                if (*(unsigned char *)(EffectSlot + 50) == 4) {
                  int v64 = -1;
                }
                else {
                  int v64 = 0;
                }
              }
              cStr.i64[0] = v64;
              if (v64 != -1)
              {
                CFNumberRef v65 = CFNumberCreate(0, kCFNumberLongType, &cStr);
                CFDictionarySetValue(v24, (const void *)v93[i], v65);
                CFRelease(v65);
              }
            }
          }
        }
        for (uint64_t j = 0; j != 9; ++j)
        {
          CFStringRef v67 = (const __CFString *)v91[j];
          int v68 = __GetProperty(v67);
          if (v68 != -1)
          {
            uint64_t TextureSampler = C3DEffectCommonProfileGetTextureSampler((uint64_t)cf, v68);
            if (TextureSampler)
            {
              int v70 = (const void *)TextureSampler;
              if (!v67)
              {
                int v71 = scn_default_log();
                if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
                  _C3DEffectCommonProfileCopyPropertyList_cold_2((uint8_t *)&cStr, (uint64_t *)((char *)cStr.i64 + 4), v71);
                }
              }
              int v72 = (const void *)C3DCopyPropertyList(v70, 0, 0, a4);
              if (v72)
              {
                BOOL v73 = v72;
                CFDictionarySetValue(v24, v67, v72);
                CFRelease(v73);
              }
            }
          }
        }
        for (uint64_t k = 0; k != 5; ++k)
        {
          CFStringRef v75 = (const __CFString *)v92[k];
          int v76 = __GetProperty(v75);
          if (v76 != -1)
          {
            Floatint Property = C3DEffectCommonProfileGetFloatProperty((float *)cf, v76);
            C3DSerializeFloatAsNumber(v24, v75, FloatProperty);
          }
        }
        if (*((unsigned char *)cf + 180)) {
          v78 = kC3DTransparency_RGB_ZEROValue;
        }
        else {
          v78 = kC3DTransparency_A_ONEValue;
        }
        CFDictionarySetValue(v24, @"transparencyMode", *v78);
        if (!v88)
        {
          CFRelease(v24);
          return 0;
        }
        return v24;
      }
    }
    unsigned int v42 = Property;
    float32x4_t cStr = *(float32x4_t *)C3DEffectCommonProfileGetColor((uint64_t)cf, Property);
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToNonLinear(&cStr);
    }
    uint64_t v43 = (const void *)C3DColor4CopyPropertyList((uint64_t)&cStr);
    if (!v40 && (uint64_t v44 = scn_default_log(), os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)))
    {
      _C3DEffectCommonProfileCopyPropertyList_cold_2(v96, &v97, v44);
      if (!v43) {
        goto LABEL_34;
      }
    }
    else if (!v43)
    {
LABEL_34:
      uint64_t v45 = C3DEffectCommonProfileGetEffectSlot((uint64_t)cf, v42, 0);
      if (v45)
      {
        float v46 = *(float *)(v45 + 72);
        if (v46 != 1.0)
        {
          if (v42 == 6)
          {
            strcpy((char *)&cStr, "multiplyIntensity");
          }
          else
          {
            NameStr = C3DEffectPropertyGetNameStr(v42);
            size_t v48 = strlen(NameStr);
            __strcpy_chk();
            strcpy((char *)&cStr + v48, "Intensity");
          }
          CFStringRef v49 = CFStringCreateWithCString(0, (const char *)&cStr, 0x8000100u);
          C3DSerializeFloatAsNumber(v24, v49, v46);
          CFRelease(v49);
        }
      }
      goto LABEL_40;
    }
    CFDictionarySetValue(v24, v40, v43);
    CFRelease(v43);
    goto LABEL_34;
  }
  unsigned int v79 = scn_default_log();
  if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
    _C3DGeometryFinalizeDeserialization_cold_4(v79, v80, v81, v82, v83, v84, v85, v86);
  }
  return 0;
}

uint64_t _C3DEffectCommonProfileFinalizeDeserialization(uint64_t a1, uint64_t a2, const __CFDictionary *a3, CFErrorRef *a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  uint64_t result = __DeserializeImage(a1, a2, a3, @"emissionImageID", a4);
  if (result)
  {
    uint64_t result = __DeserializeImage(a1, a2, a3, @"ambientImageID", a4);
    if (result)
    {
      uint64_t result = __DeserializeImage(a1, a2, a3, @"diffuseImageID", a4);
      if (result)
      {
        uint64_t result = __DeserializeImage(a1, a2, a3, @"specularImageID", a4);
        if (result)
        {
          uint64_t result = __DeserializeImage(a1, a2, a3, @"reflectiveImageID", a4);
          if (result)
          {
            uint64_t result = __DeserializeImage(a1, a2, a3, @"transparentImageID", a4);
            if (result)
            {
              uint64_t result = __DeserializeImage(a1, a2, a3, @"normalImageID", a4);
              if (result)
              {
                uint64_t result = __DeserializeImage(a1, a2, a3, @"shininessImageID", a4);
                if (result) {
                  return __DeserializeImage(a1, a2, a3, @"filterImageID", a4);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const void *_C3DEffectCommonProfileFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  unsigned __int8 v14 = 0;
  do
  {
    uint64_t result = (const void *)C3DEffectCommonProfileGetImage(a1, (char)v14);
    if (result)
    {
      uint64_t v16 = result;
      C3DLibraryAddEntry(a2, result);
      uint64_t result = C3DFillLibraryForSerialization(v16, a2, a3);
    }
    unsigned int v17 = v14++;
  }
  while (v17 < 0x14);
  return result;
}

BOOL __DeserializeColor(uint64_t a1, CFDictionaryRef theDict, const __CFString *key)
{
  float32x4_t v35 = 0uLL;
  if (!theDict && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  unsigned __int8 v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a1)
  {
    CFAllocatorRef v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFStringRef Value = CFDictionaryGetValue(theDict, key);
  if (!Value) {
    return 1;
  }
  if (!C3DColor4InitWithPropertyList((uint64_t)&v35, (uint64_t)Value, 0, 0))
  {
    uint64_t v33 = scn_default_log();
    BOOL result = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __DeserializeColor_cold_2();
    return 0;
  }
  if (C3DLinearRenderingIsEnabled()) {
    C3DColor4ConvertToLinear(&v35);
  }
  int Property = __GetProperty(key);
  if (Property != -1)
  {
    C3DEffectCommonProfileSetColor(a1, Property, v35.f32);
    return 1;
  }
  uint64_t v34 = scn_default_log();
  BOOL result = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __DeserializeColor_cold_1();
    return 0;
  }
  return result;
}

BOOL __DeserializeUVSet(uint64_t a1, CFDictionaryRef theDict, const __CFString *key)
{
  uint64_t valuePtr = 0;
  if (!theDict && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  unsigned __int8 v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a1)
  {
    CFAllocatorRef v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (!Value) {
    return 1;
  }
  if (!CFNumberGetValue(Value, kCFNumberLongType, &valuePtr))
  {
    uint64_t v33 = scn_default_log();
    BOOL result = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __DeserializeUVSet_cold_1();
    return 0;
  }
  int Property = __GetProperty(key);
  if (Property != -1)
  {
    C3DEffectCommonProfileSetUVSet(a1, Property, valuePtr);
    return 1;
  }
  uint64_t v34 = scn_default_log();
  BOOL result = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __DeserializeUVSet_cold_2();
    return 0;
  }
  return result;
}

uint64_t __DeserializeTextureSampler(uint64_t a1, const __CFDictionary *a2, const __CFString *a3)
{
  int Property = __GetProperty(a3);
  if (!a2 && (uint64_t v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v15 = scn_default_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
  }
LABEL_6:
  if (!a1)
  {
    uint64_t v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v23, v24, v25, v26, v27, v28, v29, v30);
    }
  }
  CFNumberRef Value = CFDictionaryGetValue(a2, a3);
  if (!Value) {
    return 1;
  }
  uint64_t v32 = (uint64_t)Value;
  uint64_t v33 = (const void *)C3DTextureSamplerCreate();
  if (C3DInitWithPropertyList(v33, v32, 0, 0))
  {
    C3DEffectCommonProfileSetTextureSampler(a1, Property, v33);
    uint64_t v34 = 1;
  }
  else
  {
    float32x4_t v35 = scn_default_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      __DeserializeTextureSampler_cold_1();
    }
    uint64_t v34 = 0;
  }
  CFRelease(v33);
  return v34;
}

uint64_t __DeserializeFloat(uint64_t a1, CFDictionaryRef theDict, const __CFString *key)
{
  float valuePtr = 0.0;
  if (!theDict && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a1)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, key);
  if (!result) {
    return result;
  }
  if (!CFNumberGetValue((CFNumberRef)result, kCFNumberFloatType, &valuePtr))
  {
    uint64_t v32 = scn_default_log();
    uint64_t result = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __DeserializeUVSet_cold_1();
    return 0;
  }
  int Property = __GetProperty(key);
  if (Property != -1)
  {
    C3DEffectCommonProfileSetFloatProperty(a1, Property, valuePtr);
    return 1;
  }
  uint64_t v33 = scn_default_log();
  uint64_t result = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __DeserializeUVSet_cold_2();
    return 0;
  }
  return result;
}

uint64_t __GetProperty(const __CFString *a1)
{
  v4.length = CFStringGetLength(@"emission");
  v4.location = 0;
  if (CFStringCompareWithOptions(a1, @"emission", v4, 0))
  {
    v5.length = CFStringGetLength(@"ambient");
    v5.location = 0;
    if (CFStringCompareWithOptions(a1, @"ambient", v5, 0))
    {
      v6.length = CFStringGetLength(@"diffuse");
      v6.location = 0;
      if (CFStringCompareWithOptions(a1, @"diffuse", v6, 0))
      {
        v7.length = CFStringGetLength(@"specular");
        v7.location = 0;
        if (CFStringCompareWithOptions(a1, @"specular", v7, 0))
        {
          v8.length = CFStringGetLength(@"reflective");
          v8.location = 0;
          if (CFStringCompareWithOptions(a1, @"reflective", v8, 0))
          {
            v9.length = CFStringGetLength(@"transparent");
            v9.location = 0;
            if (CFStringCompareWithOptions(a1, @"transparent", v9, 0))
            {
              v10.length = CFStringGetLength(@"filter");
              v10.location = 0;
              if (CFStringCompareWithOptions(a1, @"filter", v10, 0))
              {
                v11.length = CFStringGetLength(@"normal");
                v11.location = 0;
                if (CFStringCompareWithOptions(a1, @"normal", v11, 0))
                {
                  v12.length = CFStringGetLength(@"ambientOcclusion");
                  v12.location = 0;
                  if (CFStringCompareWithOptions(a1, @"ambientOcclusion", v12, 0))
                  {
                    v13.length = CFStringGetLength(@"selfIllumination");
                    v13.location = 0;
                    if (CFStringCompareWithOptions(a1, @"selfIllumination", v13, 0))
                    {
                      v14.length = CFStringGetLength(@"shininess");
                      v14.location = 0;
                      if (CFStringCompareWithOptions(a1, @"shininess", v14, 0))
                      {
                        if (CFStringCompare(a1, @"reflectivity", 0)
                          && CFStringCompare(a1, @"reflectivity", 0))
                        {
                          if (CFStringCompare(a1, @"transparency", 0))
                          {
                            if (CFStringCompare(a1, @"indexOfRefraction", 0))
                            {
                              if (CFStringCompare(a1, @"fresnelExponent", 0)) {
                                return -1;
                              }
                              else {
                                return 20;
                              }
                            }
                            else
                            {
                              return 19;
                            }
                          }
                          else
                          {
                            return 18;
                          }
                        }
                        else
                        {
                          return 17;
                        }
                      }
                      else
                      {
                        return 16;
                      }
                    }
                    else
                    {
                      return 9;
                    }
                  }
                  else
                  {
                    return 8;
                  }
                }
                else
                {
                  return 7;
                }
              }
              else
              {
                return 6;
              }
            }
            else
            {
              return 5;
            }
          }
          else
          {
            return 4;
          }
        }
        else
        {
          return 3;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __DeserializeImage(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, const __CFString *key, CFErrorRef *a5)
{
  if (!theDict && (CFRange v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (!a1)
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
    }
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (!Value) {
    return 1;
  }
  int valuePtr = 0;
  if (!CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
  {
    uint64_t v50 = scn_default_log();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      __DeserializeImage_cold_1();
      if (!a5) {
        return 1;
      }
    }
    else if (!a5)
    {
      return 1;
    }
    if (!*a5) {
      *a5 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
    return 1;
  }
  uint64_t v35 = valuePtr;
  if (!valuePtr) {
    return 1;
  }
  uint64_t TypeID = C3DImageGetTypeID();
  RemappedID = (const void *)C3DLibraryGetRemappedID(a2, v35, TypeID);
  if (!RemappedID)
  {
    float32x4_t v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      __DeserializeImage_cold_3(v38, v39, v40, v41, v42, v43, v44, v45);
    }
  }
  float v46 = (void *)C3DImageGetTypeID();
  Entry = C3DLibraryGetEntry(a2, v46, RemappedID);
  if (Entry)
  {
    size_t v48 = Entry;
    int Property = __GetProperty(key);
    if (Property != -1) {
      C3DEffectCommonProfileSetImage(a1, Property, v48);
    }
    return 1;
  }
  int v52 = scn_default_log();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
  {
    __DeserializeImage_cold_2(v52);
    if (!a5) {
      return 0;
    }
  }
  else if (!a5)
  {
    return 0;
  }
  if (*a5) {
    return 0;
  }
  CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
  uint64_t result = 0;
  *a5 = MalformedDocumentError;
  return result;
}

__CFArray *_C3DEffectCommonProfileCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  __int16 v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFRange v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 32;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v4, @"name", @"emission");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  CFRange v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 40;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v8, @"name", @"ambient");
  CFDictionarySetValue(v8, @"type", v9);
  CFDictionarySetValue(v8, @"address", v11);
  CFDictionarySetValue(v8, @"semantic", v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  uint64_t v12 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 48;
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v12, @"name", @"diffuse");
  CFDictionarySetValue(v12, @"type", v13);
  CFDictionarySetValue(v12, @"address", v15);
  CFDictionarySetValue(v12, @"semantic", v14);
  CFArrayAppendValue(Mutable, v12);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v16 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 56;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v16, @"name", @"specular");
  CFDictionarySetValue(v16, @"type", v17);
  CFDictionarySetValue(v16, @"address", v19);
  CFDictionarySetValue(v16, @"semantic", v18);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v18);
  CFRelease(v16);
  CFRelease(v19);
  CFRelease(v17);
  uint64_t v20 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 64;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v20, @"name", @"reflective");
  CFDictionarySetValue(v20, @"type", v21);
  CFDictionarySetValue(v20, @"address", v23);
  CFDictionarySetValue(v20, @"semantic", v22);
  CFArrayAppendValue(Mutable, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  uint64_t v24 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 72;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v24, @"name", @"transparent");
  CFDictionarySetValue(v24, @"type", v25);
  CFDictionarySetValue(v24, @"address", v27);
  CFDictionarySetValue(v24, @"semantic", v26);
  CFArrayAppendValue(Mutable, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  uint64_t v28 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 80;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v28, @"name", @"filter");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  CFRelease(v31);
  CFRelease(v29);
  uint64_t v32 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 88;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v32, @"name", @"normal");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  uint64_t v36 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 112;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v36, @"name", @"metalness");
  CFDictionarySetValue(v36, @"type", v37);
  CFDictionarySetValue(v36, @"address", v39);
  CFDictionarySetValue(v36, @"semantic", v38);
  CFArrayAppendValue(Mutable, v36);
  CFRelease(v38);
  CFRelease(v36);
  CFRelease(v39);
  CFRelease(v37);
  uint64_t v40 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 120;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v40, @"name", @"roughness");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  uint64_t v44 = v3;
  uint64_t v45 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  float v46 = CFDictionaryCreateMutable(0, 4, v44, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 128;
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v46, @"name", @"displacement");
  CFDictionarySetValue(v46, @"type", v47);
  CFDictionarySetValue(v46, @"address", v49);
  CFDictionarySetValue(v46, @"semantic", v48);
  uint64_t v50 = Mutable;
  CFArrayAppendValue(Mutable, v46);
  CFRelease(v48);
  CFRelease(v46);
  CFRelease(v49);
  CFRelease(v47);
  CFStringRef v51 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  int v52 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v45);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 136;
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v52, @"name", @"clearCoat");
  CFDictionarySetValue(v52, @"type", v53);
  CFDictionarySetValue(v52, @"address", v55);
  CFDictionarySetValue(v52, @"semantic", v54);
  CFArrayAppendValue(v50, v52);
  CFRelease(v54);
  CFRelease(v52);
  CFRelease(v55);
  CFRelease(v53);
  uint64_t v56 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v57 = CFDictionaryCreateMutable(0, 4, v51, MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 144;
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v57, @"name", @"clearCoatRoughness");
  CFDictionarySetValue(v57, @"type", v58);
  CFDictionarySetValue(v57, @"address", v60);
  CFDictionarySetValue(v57, @"semantic", v59);
  CFArrayAppendValue(v50, v57);
  CFRelease(v59);
  CFRelease(v57);
  CFRelease(v60);
  CFRelease(v58);
  CFNumberRef v61 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v56);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = a1 + 152;
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v63 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v64 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v61, @"name", @"clearCoatNormal");
  CFDictionarySetValue(v61, @"type", v62);
  CFDictionarySetValue(v61, @"address", v64);
  CFDictionarySetValue(v61, @"semantic", v63);
  CFNumberRef v65 = v50;
  CFArrayAppendValue(v50, v61);
  CFRelease(v63);
  CFRelease(v61);
  CFRelease(v64);
  CFRelease(v62);
  int v66 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v56);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = a1 + 160;
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v68 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v66, @"name", @"shininess");
  CFDictionarySetValue(v66, @"type", v67);
  CFDictionarySetValue(v66, @"address", v69);
  CFDictionarySetValue(v66, @"semantic", v68);
  CFArrayAppendValue(v50, v66);
  CFRelease(v68);
  CFRelease(v66);
  CFRelease(v69);
  CFRelease(v67);
  int v70 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  int v71 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = a1 + 164;
  CFNumberRef v72 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v71, @"name", @"transparency");
  CFDictionarySetValue(v71, @"type", v72);
  CFDictionarySetValue(v71, @"address", v74);
  CFDictionarySetValue(v71, @"semantic", v73);
  CFArrayAppendValue(v50, v71);
  CFRelease(v73);
  CFRelease(v71);
  CFRelease(v74);
  CFRelease(v72);
  CFStringRef v75 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  int v76 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v70);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = a1 + 168;
  CFNumberRef v77 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v78 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v79 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v76, @"name", @"indexOfRefraction");
  CFDictionarySetValue(v76, @"type", v77);
  CFDictionarySetValue(v76, @"address", v79);
  CFDictionarySetValue(v76, @"semantic", v78);
  CFArrayAppendValue(v50, v76);
  CFRelease(v78);
  CFRelease(v76);
  CFRelease(v79);
  CFRelease(v77);
  uint64_t v80 = CFDictionaryCreateMutable(0, 4, v75, v70);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = a1 + 172;
  CFNumberRef v81 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v82 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v83 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v80, @"name", @"fresnelExponent");
  CFDictionarySetValue(v80, @"type", v81);
  CFDictionarySetValue(v80, @"address", v83);
  CFDictionarySetValue(v80, @"semantic", v82);
  CFArrayAppendValue(v50, v80);
  CFRelease(v82);
  CFRelease(v80);
  CFRelease(v83);
  CFRelease(v81);
  uint64_t v84 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v85 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v70);
  int v103 = 0;
  int valuePtr = 3;
  uint64_t v102 = a1 + 193;
  CFNumberRef v86 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v87 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v88 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v85, @"name", @"locksAmbientWithDiffuse");
  CFDictionarySetValue(v85, @"type", v86);
  CFDictionarySetValue(v85, @"address", v88);
  CFDictionarySetValue(v85, @"semantic", v87);
  CFArrayAppendValue(v65, v85);
  CFRelease(v87);
  CFRelease(v85);
  CFRelease(v88);
  CFRelease(v86);
  unsigned int v89 = CFDictionaryCreateMutable(0, 4, v84, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 2;
  uint64_t v102 = a1 + 24;
  CFNumberRef v90 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v91 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v92 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v89, @"name", @"lightingModel");
  CFDictionarySetValue(v89, @"type", v90);
  CFDictionarySetValue(v89, @"address", v92);
  CFDictionarySetValue(v89, @"semantic", v91);
  CFArrayAppendValue(v65, v89);
  CFRelease(v91);
  CFRelease(v89);
  CFRelease(v92);
  CFRelease(v90);
  int v93 = CFDictionaryCreateMutable(0, 4, v84, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 2;
  uint64_t v102 = a1 + 180;
  CFNumberRef v94 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v95 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v96 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v93, @"name", @"transparencyMode");
  CFDictionarySetValue(v93, @"type", v94);
  CFDictionarySetValue(v93, @"address", v96);
  CFDictionarySetValue(v93, @"semantic", v95);
  CFArrayAppendValue(v65, v93);
  CFRelease(v95);
  CFRelease(v93);
  CFRelease(v96);
  CFRelease(v94);
  uint64_t v97 = CFDictionaryCreateMutable(0, 4, v84, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 2;
  uint64_t v102 = a1 + 184;
  CFNumberRef v98 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v99 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v100 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v97, @"name", @"imagesCount");
  CFDictionarySetValue(v97, @"type", v98);
  CFDictionarySetValue(v97, @"address", v100);
  CFDictionarySetValue(v97, @"semantic", v99);
  CFArrayAppendValue(v65, v97);
  CFRelease(v99);
  CFRelease(v97);
  CFRelease(v100);
  CFRelease(v98);
  return v65;
}

void _C3DEffectCommonProfileSetValue(uint64_t a1, float *a2, float *a3, size_t a4)
{
  CFRange v8 = (float *)(a1 + 164);
  float v9 = 0.0;
  float v10 = 0.0;
  if ((float *)(a1 + 164) == a2)
  {
    float v9 = *a2;
    float v10 = *a3;
  }
  int HashCode = C3DEffectCommonProfileGetHashCode(a1);
  memcpy(a2, a3, a4);
  int v12 = C3DEffectCommonProfileGetHashCode(a1);
  if (v8 == a2)
  {
    BOOL v13 = v9 != 1.0 || v10 == 1.0;
    if (v13 && (v9 == 1.0 || v10 != 1.0)) {
      goto LABEL_15;
    }
    *(_WORD *)(a1 + 194) &= ~0x80u;
    goto LABEL_14;
  }
  if (HashCode != v12) {
LABEL_14:
  }
    __PostCommonProfileDidChangeNotification(a1);
LABEL_15:
  uint64_t v14 = *(void *)(a1 + 16);

  C3DMaterialTouchValueStorageModificationCount(v14);
}

void _C3DEffectSlotCFFinalize(void *a1)
{
  __int16 v2 = (void *)a1[8];
  if (v2) {
    free(v2);
  }
  __int16 v3 = (const void *)a1[5];
  if (v3)
  {
    CFRelease(v3);
    a1[5] = 0;
  }
  CFRange v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  CFNumberRef v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
}

CFStringRef _C3DEffectSlotCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DEffectSlot>");
}

CFStringRef _C3DEffectSlotCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DEffectSlot>");
}

void _C3DEffectSlotSetValue(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  if (!memcmp(__s1, __s2, __n)) {
    return;
  }
  memcpy(__s1, __s2, __n);
  uint64_t CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
  if (!CommonProfile) {
    return;
  }
  if ((void *)(a1 + 40) == __s2)
  {
    __int16 v9 = -193;
    goto LABEL_8;
  }
  if ((void *)(a1 + 16) == __s2)
  {
    __int16 v9 = -129;
LABEL_8:
    *(_WORD *)(CommonProfile + 194) &= v9;
  }

  __PostCommonProfileDidChangeNotification(CommonProfile);
}

__CFArray *_C3DEffectSlotCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  __int16 v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v46 = 0;
  int valuePtr = 13;
  uint64_t v45 = a1 + 16;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v3, @"name", @"color");
  CFDictionarySetValue(v3, @"type", v4);
  CFDictionarySetValue(v3, @"address", v6);
  CFDictionarySetValue(v3, @"semantic", v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  if (!*(unsigned char *)(a1 + 48))
  {
    CFNumberRef v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v46 = 2;
    int valuePtr = 5;
    uint64_t v45 = a1 + 40;
    CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
    CFNumberRef v10 = CFNumberCreate(0, kCFNumberLongType, &v45);
    CFDictionarySetValue(v7, @"name", @"image");
    CFDictionarySetValue(v7, @"type", v8);
    CFDictionarySetValue(v7, @"address", v10);
    CFDictionarySetValue(v7, @"semantic", v9);
    CFArrayAppendValue(Mutable, v7);
    CFRelease(v9);
    CFRelease(v7);
    CFRelease(v10);
    CFRelease(v8);
  }
  CFNumberRef v11 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v46 = 2;
  int valuePtr = 5;
  uint64_t v45 = a1 + 56;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v11, @"name", @"sampler");
  CFDictionarySetValue(v11, @"type", v12);
  CFDictionarySetValue(v11, @"address", v14);
  CFDictionarySetValue(v11, @"semantic", v13);
  CFArrayAppendValue(Mutable, v11);
  CFRelease(v13);
  CFRelease(v11);
  CFRelease(v14);
  CFRelease(v12);
  __int16 v15 = *(_WORD *)(a1 + 48);
  if (v15 == 1)
  {
    uint64_t v16 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v46 = 2;
    int valuePtr = 5;
    uint64_t v45 = a1 + 40;
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v45);
    CFDictionarySetValue(v16, @"name", @"texture");
    CFDictionarySetValue(v16, @"type", v17);
    CFDictionarySetValue(v16, @"address", v19);
    CFDictionarySetValue(v16, @"semantic", v18);
    CFArrayAppendValue(Mutable, v16);
    CFRelease(v18);
    CFRelease(v16);
    CFRelease(v19);
    CFRelease(v17);
    __int16 v15 = *(_WORD *)(a1 + 48);
  }
  if (v15 == 3)
  {
    uint64_t v20 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v46 = 2;
    int valuePtr = 5;
    uint64_t v45 = a1 + 40;
    CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
    CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v45);
    CFDictionarySetValue(v20, @"name", @"mtltexture");
    CFDictionarySetValue(v20, @"type", v21);
    CFDictionarySetValue(v20, @"address", v23);
    CFDictionarySetValue(v20, @"semantic", v22);
    CFArrayAppendValue(Mutable, v20);
    CFRelease(v22);
    CFRelease(v20);
    CFRelease(v23);
    CFRelease(v21);
    __int16 v15 = *(_WORD *)(a1 + 48);
  }
  if (v15 == 2)
  {
    uint64_t v24 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v46 = 2;
    int valuePtr = 5;
    uint64_t v45 = a1 + 40;
    CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
    CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v45);
    CFDictionarySetValue(v24, @"name", @"imageProxy");
    CFDictionarySetValue(v24, @"type", v25);
    CFDictionarySetValue(v24, @"address", v27);
    CFDictionarySetValue(v24, @"semantic", v26);
    CFArrayAppendValue(Mutable, v24);
    CFRelease(v26);
    CFRelease(v24);
    CFRelease(v27);
    CFRelease(v25);
    __int16 v15 = *(_WORD *)(a1 + 48);
  }
  if (v15 == 4)
  {
    uint64_t v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v46 = 2;
    int valuePtr = 5;
    uint64_t v45 = a1 + 40;
    CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
    CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v45);
    CFDictionarySetValue(v28, @"name", @"precomputedLightingEnvironment");
    CFDictionarySetValue(v28, @"type", v29);
    CFDictionarySetValue(v28, @"address", v31);
    CFDictionarySetValue(v28, @"semantic", v30);
    CFArrayAppendValue(Mutable, v28);
    CFRelease(v30);
    CFRelease(v28);
    CFRelease(v31);
    CFRelease(v29);
  }
  uint64_t v32 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v46 = 2;
  int valuePtr = 5;
  uint64_t v45 = a1 + 64;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v32, @"name", @"transforms");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  uint64_t v36 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v46 = 0;
  int valuePtr = 2;
  uint64_t v45 = a1 + 76;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v36, @"name", @"uvSet");
  CFDictionarySetValue(v36, @"type", v37);
  CFDictionarySetValue(v36, @"address", v39);
  CFDictionarySetValue(v36, @"semantic", v38);
  CFArrayAppendValue(Mutable, v36);
  CFRelease(v38);
  CFRelease(v36);
  CFRelease(v39);
  CFRelease(v37);
  uint64_t v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v46 = 0;
  int valuePtr = 1;
  uint64_t v45 = a1 + 72;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v40, @"name", @"intensity");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  return Mutable;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::CompositePass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 272, 16, 0);
  C3D::CompositePass::CompositePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::HDRAverageLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::HDRAverageLuminancePass::HDRAverageLuminancePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::HDRFrameLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::HDRFrameLuminancePass::HDRFrameLuminancePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::DownSampleBloomCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::DownSampleBloomCoCPass::DownSampleBloomCoCPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::GaussianBlurPass *C3D::RenderGraph::createPass<C3D::GaussianBlurPass,C3D::MainPass *&,C3D::GaussianBlurPass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::GaussianBlurPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 272, 16, 0);
  C3D::GaussianBlurPass::GaussianBlurPass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::GaussianBlurPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::CustomPass *C3D::RenderGraph::createPass<C3D::BloomDownSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::CustomPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 144, 8, 0);
  C3D::BloomDownSamplePass::BloomDownSamplePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::CustomPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::BloomUpSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::BloomUpSamplePass::BloomUpSamplePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::DOFDownsampleCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::DOFDownsampleCoCPass::DOFDownsampleCoCPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::DOFBlurCoCXPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::DOFBlurCoCXPass::DOFBlurCoCXPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::DOFBlurCoCYPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::DOFBlurCoCYPass::DOFBlurCoCYPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::DOFFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::DOFFinalBlurPass::DOFFinalBlurPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::MBTileMaxPass *C3D::RenderGraph::createPass<C3D::MBTileMaxPass,C3D::MainPass *&>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::MBTileMaxPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 120, 8, 0);
  C3D::MBTileMaxPass::MBTileMaxPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::MBTileMaxPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::MBNeighborMaxPass *C3D::RenderGraph::createPass<C3D::MBNeighborMaxPass,C3D::MainPass *&,BOOL>(uint64_t a1, C3D::Pass **a2, char *a3)
{
  Aligned = (C3D::MBNeighborMaxPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::MBNeighborMaxPass::MBNeighborMaxPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::MBNeighborMaxPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::MBFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::MBFinalBlurPass::MBFinalBlurPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

void C3D::PostProcessPassesComputeUniforms(uint64_t a1, uint64_t a2, C3D::DrawNodesPass *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,long long a28,uint64_t a29,float a30,float AverageGray,float a32,float a33,float a34,float ExposureAdaptationDuration,int8x8_t a36,float BloomThreshold,int a38,float BloomIntensity,int a40,float a41,float VignettingPower,float VignettingIntensity,float ColorFringeStrength,float ColorFringeIntensity,float Saturation,float Contrast,float a48,float a49,uint64_t a50,float32x2_t a51,float a52,int a53,int a54,unsigned int a55,unsigned int a56,unint64_t a57,float DepthOfFieldIntensity,int a59,float a60,float MotionBlurIntensity,float GrainIntensity,long long a63)
{
  a78 = *MEMORY[0x263EF8340];
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a1);
  CFNumberRef v74 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  CFStringRef v75 = (SCNMTLBufferPool *)-[SCNMTLRenderContext frameConstantBufferPool](RenderContext);
  PointOfView = C3DEngineContextGetPointOfView(a1);
  if (PointOfView)
  {
    CFDictionaryRef Camera = C3DNodeGetCamera((uint64_t)PointOfView);
    if (Camera)
    {
      uint64_t v78 = (uint64_t)Camera;
      float WhitePoint = C3DCameraGetWhitePoint((uint64_t)Camera);
      a30 = WhitePoint * C3DCameraGetWhitePoint(v78);
      AverageGray = C3DCameraGetAverageGray(v78);
      float ExposureOffset = C3DCameraGetExposureOffset(v78);
      a34 = exp2f(ExposureOffset);
      ExposureAdaptationDuration = C3DCameraGetExposureAdaptationDuration(v78);
      float ExposureAdaptationBrighteningSpeedFactor = C3DCameraGetExposureAdaptationBrighteningSpeedFactor(v78);
      float ExposureAdaptationDarkeningSpeedFactor = C3DCameraGetExposureAdaptationDarkeningSpeedFactor(v78);
      a36 = vbsl_s8((int8x8_t)vmovn_s64(vcgtq_f64(vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(ExposureAdaptationDarkeningSpeedFactor), LODWORD(ExposureAdaptationBrighteningSpeedFactor))), (float64x2_t)vdupq_n_s64(0x3F847AE147AE147BuLL))), (int8x8_t)__PAIR64__(LODWORD(ExposureAdaptationDarkeningSpeedFactor), LODWORD(ExposureAdaptationBrighteningSpeedFactor)), (int8x8_t)vdup_n_s32(0x3C23D70Au));
      float MinimumExposure = C3DCameraGetMinimumExposure(v78);
      a32 = exp2f(MinimumExposure);
      float MaximumExposure = C3DCameraGetMaximumExposure(v78);
      a33 = exp2f(MaximumExposure);
      BloomThreshold = C3DCameraGetBloomThreshold(v78);
      a40 = *(_DWORD *)(a2 + 24);
      a38 = 1056964608;
      Bloomfloat Intensity = C3DCameraGetBloomIntensity(v78);
      VignettingPower = C3DCameraGetVignettingPower(v78);
      Vignettingfloat Intensity = C3DCameraGetVignettingIntensity(v78);
      ColorFringeStrength = C3DCameraGetColorFringeStrength(v78);
      ColorFringefloat Intensity = C3DCameraGetColorFringeIntensity(v78);
      Saturation = C3DCameraGetSaturation(v78);
      Contrast = C3DCameraGetContrast(v78);
      float WhiteBalanceTemperature = C3DCameraGetWhiteBalanceTemperature(v78);
      a48 = WhiteBalanceTemperature;
      float WhiteBalanceTint = C3DCameraGetWhiteBalanceTint(v78);
      a49 = WhiteBalanceTint;
      double v86 = -[SCNMTLRenderContext renderTime](RenderContext);
      float v87 = floor(*(float *)&v86 * 30.0);
      float GrainScale = C3DCameraGetGrainScale(v78);
      if (GrainScale <= 0.0039062) {
        float v89 = 1.0;
      }
      else {
        float v89 = 0.0039062 / GrainScale;
      }
      BOOL v90 = -[SCNMTLRenderContext contentScaleFactor](RenderContext) <= 1.0;
      double v91 = 2.0;
      if (!v90) {
        double v91 = 1.0;
      }
      float v92 = v91 * v89;
      float v143 = v92;
      Grainfloat Intensity = C3DCameraGetGrainIntensity(v78);
      double v93 = v87;
      long double v94 = sin(v93 * 0.01);
      *(float *)&long double v94 = fmin(v94 * 4242.0 - floor(v94 * 4242.0), 1.0);
      unsigned int v140 = LODWORD(v94);
      long double v95 = sin(v93 * 0.1 + 0.05);
      *(float *)&long long v96 = v143;
      *((float *)&v96 + 1) = v143;
      *(float *)&long double v95 = fmin(v95 * 4242.0 - floor(v95 * 4242.0), 1.0);
      *((void *)&v96 + 1) = __PAIR64__(LODWORD(v95), v140);
      a63 = v96;
      float ARGrainSlice = C3DCameraGetARGrainSlice(v78);
      if (!*(unsigned char *)(a2 + 10)) {
        Bloomfloat Intensity = 0.0;
      }
      if (*(unsigned char *)(a2 + 11)) {
        MotionBlurfloat Intensity = C3DCameraGetMotionBlurIntensity(v78);
      }
      float Intensity = 0.0;
      if (*(unsigned char *)(a2 + 17))
      {
        ColorGradinguint64_t EffectSlot = C3DCameraGetColorGradingEffectSlot(v78, 0);
        if (ColorGradingEffectSlot)
        {
          uint64_t v99 = ColorGradingEffectSlot;
          if (C3DEffectSlotHasImageOrTexture(ColorGradingEffectSlot)) {
            [v74 renderResourceForEffectSlot:v99 withEngineContext:a1 didFallbackToDefaultTexture:0];
          }
          float Intensity = C3DEffectSlotGetIntensity(v99);
        }
      }
      a41 = Intensity;
      if (*(unsigned char *)(a2 + 22))
      {
        double v100 = WhiteBalanceTemperature;
        double v101 = -5.0;
        if (WhiteBalanceTemperature < -5.0) {
          double v100 = -5.0;
        }
        double v102 = v100 * 0.5;
        BOOL v103 = v100 < 5.0;
        double v104 = 2.5;
        if (!v103) {
          double v102 = 2.5;
        }
        float v105 = v102;
        if (WhiteBalanceTint >= -5.0) {
          double v101 = WhiteBalanceTint;
        }
        if (v101 < 5.0) {
          double v104 = v101 * 0.5;
        }
        float v106 = v104;
        float v107 = 0.31271 - v105 * dbl_20B5EDAC0[v105 < 0.0];
        float v108 = (float)((float)(v107 * -3.0) * v107) + v107 * 2.87 + -0.27509507;
        float v109 = v108 + v106 * 0.05;
        float v110 = v107 / v109;
        float v111 = (float)((float)(1.0 - v107) - v109) / v109;
        double v112 = v110;
        double v113 = v111;
        float v114 = v110 * 0.003 + 0.0136 + v113 * 0.9834;
        a52 = 1.0873 / v114;
        a51 = vdiv_f32((float32x2_t)0x3F8488A43F730132, vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64((float64x2_t)xmmword_20B5EDAE0, (float64x2_t)xmmword_20B5EDAD0, v112), (float64x2_t)xmmword_20B5EDAF0, v113)));
      }
      double v115 = *(double *)(C3D::DrawNodesPass::getCullingContext(a3) + 4744);
      double v116 = *(double *)(C3D::DrawNodesPass::getCullingContext(a3) + 4752);
      float v117 = C3DCameraGetFocalLength(v78) / 1000.0;
      double v118 = v117 + 0.01;
      float FocusDistance = C3DCameraGetFocusDistance(v78);
      if (v118 >= FocusDistance) {
        float v120 = v118;
      }
      else {
        float v120 = FocusDistance;
      }
      float FStop = C3DCameraGetFStop(v78);
      if (FStop <= 0.0001) {
        float v122 = 0.0001;
      }
      else {
        float v122 = FStop;
      }
      float v123 = C3DCameraGetAperture(v78) / 1000.0;
      BladeCFIndex Count = C3DCameraGetBladeCount(v78);
      float v125 = (float)((float)(v117 * v123) / (float)(v120 - v117)) / *(float *)a2;
      char v126 = *(unsigned char *)C3DCameraGetProjectionInfosPtr(v78);
      uint64_t v127 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a3);
      uint64_t v128 = C3D::PassDescriptor::outputAtIndex(v127, 0);
      uint64_t v130 = (_WORD *)(v128 + 16);
      if ((v126 & 0x20) == 0) {
        uint64_t v130 = (_WORD *)(v128 + 18);
      }
      LOWORD(v129) = *v130;
      float v131 = v125 * (float)v129;
      *(float *)&unsigned int v132 = (v116 - v115) * (float)(v120 * v131) / (v115 * v116);
      *(float *)&unsigned int v133 = (1.0 - v120 / v115) * v131;
      float v141 = *(float *)&v133;
      float v144 = *(float *)&v132;
      a57 = __PAIR64__(v133, v132);
      if ((C3DEngineContextGetCoordinatesSystemOptions(a1) & 8) != 0)
      {
        *(float *)&unint64_t v134 = -v144;
        *((float *)&v134 + 1) = v141 + v144;
        a57 = v134;
      }
      DepthOfFieldfloat Intensity = C3DCameraGetDepthOfFieldIntensity(v78);
      a60 = v122;
      if (BladeCount <= 5) {
        int v135 = 5;
      }
      else {
        int v135 = BladeCount;
      }
      a59 = v135;
      if (*(unsigned char *)(a2 + 9))
      {
        a54 = 1015580809;
        unsigned int FrameIndex = C3DEngineContextGetFrameIndex(a1);
        unsigned int v137 = FrameIndex + 1;
        double v138 = ExposureAdaptationDuration * 60.0;
        if (v138 < 1.0) {
          double v138 = 1.0;
        }
        double v139 = fmin(v138, 240.0);
        if (v139 > (double)v137) {
          double v139 = (double)v137;
        }
        a55 = FrameIndex % 0xF0;
        a56 = v139;
      }
      SCNMTLBufferPool::allocateAndCopy(v75, &a30, 0x100uLL, (void **)&a28);
      *(_OWORD *)(a2 + 32) = a28;
      *(void *)(a2 + 48) = a29;
      *(float *)(a2 + 64) = C3DCameraGetAverageGray(v78);
    }
  }
}

void vmesh::SubdivideMidPoint(std::vector<int>::size_type a1, int a2, int a3, std::vector<int> *a4, void *a5, void *a6)
{
  int v10 = a2;
  int v12 = a2 << (2 * a3);
  std::vector<ClippedCorner>::resize((uint64_t)a6, a3 + 1);
  CFNumberRef v13 = (_DWORD *)*a6;
  *CFNumberRef v13 = a1;
  v13[1] = v10;
  std::vector<vmesh::Triangle>::resize(a5, v12);
  if (a3 >= 1)
  {
    uint64_t v14 = 0;
    LODWORD(v15) = 0;
    uint64_t v56 = a3;
    do
    {
      uint64_t v57 = v14;
      std::vector<int>::size_type v58 = a1;
      __x[0] = 0;
      std::vector<int>::resize(a4, (int)a1 + 1, __x);
      uint64_t v16 = v10;
      if (v10 >= 1)
      {
        std::vector<int>::pointer begin = a4->__begin_;
        CFNumberRef v18 = (int *)(*a5 + 8);
        uint64_t v19 = v10;
        do
        {
          int v20 = *(v18 - 2);
          int v21 = *(v18 - 1);
          if (v20 <= v21) {
            int v22 = *(v18 - 1);
          }
          else {
            int v22 = *(v18 - 2);
          }
          int v24 = *v18;
          v18 += 3;
          int v23 = v24;
          ++begin[v22 + 1];
          if (v21 <= v24) {
            int v21 = v23;
          }
          ++begin[v21 + 1];
          if (v23 > v20) {
            int v20 = v23;
          }
          ++begin[v20 + 1];
          --v19;
        }
        while (v19);
      }
      if ((int)v15 >= (int)a1)
      {
        a1 = (int)a1;
        std::vector<int>::size_type v15 = v58;
      }
      else
      {
        a1 = (int)a1;
        CFNumberRef v25 = &a4->__begin_[(int)v15];
        int v28 = *v25;
        CFNumberRef v26 = v25 + 1;
        int v27 = v28;
        uint64_t v29 = (int)v58 - (uint64_t)(int)v15;
        do
        {
          v27 += *v26;
          *v26++ = v27;
          --v29;
        }
        while (v29);
        std::vector<int>::size_type v15 = v58;
      }
      std::vector<ClippedCorner>::resize((uint64_t)&a4[2], *(a4->__end_ - 1));
      __x[0] = 0;
      std::vector<int>::resize(a4 + 1, a1, __x);
      a1 = v15;
      if (v10 >= 1)
      {
        a1 = v15;
        do
        {
          uint64_t v30 = 0;
          int v31 = v16 - 1;
          uint64_t v32 = *a5;
          uint64_t v33 = *a5 + 12 * (v16 - 1);
          *(void *)__x = *(void *)v33;
          int v62 = *(_DWORD *)(v33 + 8);
          uint64_t v59 = -1;
          int v60 = -1;
          std::vector<int>::pointer v34 = a4->__begin_;
          std::vector<int>::pointer v35 = a4[1].__begin_;
          std::vector<int>::pointer v36 = a4[2].__begin_;
          do
          {
            std::vector<int>::value_type v37 = __x[v30];
            uint64_t v38 = v30 + 1;
            uint64_t v39 = (v30 + 1);
            if (v30 == 2) {
              uint64_t v39 = 0;
            }
            std::vector<int>::value_type v40 = __x[v39];
            if (v37 <= v40) {
              std::vector<int>::value_type v41 = v40;
            }
            else {
              std::vector<int>::value_type v41 = __x[v30];
            }
            if (v40 < v37) {
              std::vector<int>::value_type v37 = v40;
            }
            uint64_t v42 = v34[v41];
            uint64_t v43 = v35[v41];
            uint64_t v44 = v43 + v42;
            if ((int)v43 >= 1)
            {
              uint64_t v45 = &v36[2 * v42 + 1];
              while (*(v45 - 1) != v37)
              {
                ++v42;
                v45 += 2;
                if (v42 >= v44) {
                  goto LABEL_34;
                }
              }
              *((_DWORD *)&v59 + v30) = *v45;
            }
LABEL_34:
            if (*((_DWORD *)&v59 + v30) == -1)
            {
              if ((int)v44 >= v34[v41 + 1]) {
                vmesh::SubdivideMidPoint();
              }
              int v46 = &v36[2 * (int)v44];
              *int v46 = v37;
              v46[1] = a1;
              ++v35[v41];
              *((_DWORD *)&v59 + v30) = a1;
              a1 = (a1 + 1);
            }
            ++v30;
          }
          while (v38 != 3);
          uint64_t v47 = v32 + 48 * v31;
          *(void *)uint64_t v47 = v59;
          int v49 = HIDWORD(v59);
          int v48 = v60;
          *(_DWORD *)(v47 + 8) = v60;
          uint64_t v50 = (_DWORD *)(*a5 + 12 * ((4 * v31) | 1));
          int v51 = v59;
          _DWORD *v50 = __x[0];
          v50[1] = v51;
          v50[2] = v48;
          LODWORD(v47) = __x[1];
          int v52 = (_DWORD *)(*a5 + 12 * ((4 * v31) | 2));
          *int v52 = v51;
          v52[1] = v47;
          v52[2] = v49;
          LODWORD(v47) = v62;
          CFNumberRef v53 = (int *)(*a5 + 12 * ((4 * v31) | 3));
          int *v53 = v48;
          v53[1] = v49;
          v53[2] = v47;
        }
        while (v16-- > 1);
      }
      v10 *= 4;
      uint64_t v14 = v57 + 1;
      CFNumberRef v55 = (_DWORD *)(*a6 + 8 * (v57 + 1));
      *CFNumberRef v55 = a1;
      v55[1] = v10;
    }
    while (v57 + 1 != v56);
  }
}

void std::vector<vmesh::Triangle>::resize(void *a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 2);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<vmesh::Triangle>::__append((uint64_t)a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + 12 * a2;
  }
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz, std::vector<int>::const_reference __x)
{
  std::vector<int>::size_type v3 = this->__end_ - this->__begin_;
  if (__sz <= v3)
  {
    if (__sz < v3) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v3, __x);
  }
}

float32x4_t vmesh::TriangleMesh::computeNormals(vmesh::TriangleMesh *this, char a2)
{
  _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm((uint64_t)this + 48, (int)((uint64_t)(*((void *)this + 1) - *(void *)this) >> 4));
  CFNumberRef v5 = (void *)*((void *)this + 6);
  uint64_t v6 = *((void *)this + 7) - (void)v5;
  if (v6 >= 1) {
    bzero(v5, 16 * (((unint64_t)v6 >> 4) - ((unint64_t)v6 > 0xF)) + 16);
  }
  CFNumberRef v7 = (int *)*((void *)this + 9);
  CFNumberRef v8 = (int *)*((void *)this + 10);
  while (v7 != v8)
  {
    uint64_t v9 = *v7;
    float32x4_t v10 = *(float32x4_t *)(*(void *)this + 16 * v9);
    float32x4_t v11 = vsubq_f32(*(float32x4_t *)(*(void *)this + 16 * v7[1]), v10);
    float32x4_t v12 = vsubq_f32(*(float32x4_t *)(*(void *)this + 16 * v7[2]), v10);
    int8x16_t v13 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), vnegq_f32(v11)), v12, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL));
    float32x4_t v14 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), v13, 0xCuLL);
    *(float32x4_t *)(*((void *)this + 6) + 16 * v9) = vaddq_f32(*(float32x4_t *)(*((void *)this + 6) + 16 * v9), v14);
    *(float32x4_t *)(*((void *)this + 6) + 16 * v7[1]) = vaddq_f32(v14, *(float32x4_t *)(*((void *)this + 6) + 16 * v7[1]));
    uint64_t v15 = v7[2];
    uint64_t v16 = *((void *)this + 6);
    float32x4_t result = vaddq_f32(v14, *(float32x4_t *)(v16 + 16 * v15));
    *(float32x4_t *)(v16 + 16 * v15) = result;
    v7 += 3;
  }
  if (a2)
  {
    CFNumberRef v17 = (float32x4_t *)*((void *)this + 6);
    CFNumberRef v18 = (float32x4_t *)*((void *)this + 7);
    while (v17 != v18)
    {
      int32x4_t v19 = (int32x4_t)vmulq_f32(*v17, *v17);
      v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v19, 2), vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1))).u32[0];
      float32x2_t v20 = vrsqrte_f32((float32x2_t)v19.u32[0]);
      float32x2_t v21 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v20, v20)));
      float32x4_t result = vmulq_n_f32(*v17, vmul_f32(v21, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v21, v21))).f32[0]);
      *v17++ = result;
    }
  }
  return result;
}

void vmesh::TriangleMesh::subdivideMidPoint(void *a1, int a2, void **a3, long long *a4, void **a5, std::vector<int> *a6, void **p_p, std::vector<int> *a8)
{
  float32x4_t v14 = a1 + 9;
  int v15 = -1431655765 * ((a1[10] - a1[9]) >> 2);
  if (v15)
  {
    std::vector<int>::size_type v16 = (a1[1] - *a1) >> 4;
    if (v16)
    {
      __p = 0;
      std::vector<int>::pointer v36 = 0;
      uint64_t v37 = 0;
      uint64_t v34 = 0;
      long long v32 = 0u;
      long long v33 = 0u;
      CFNumberRef v17 = a3 ? a3 : &__p;
      CFNumberRef v18 = (std::vector<int> *)(a4 ? a4 : &v30);
      long long v30 = 0uLL;
      long long v31 = 0uLL;
      vmesh::SubdivideMidPoint(v16, v15, a2, v18, v14, v17);
      vmesh::StaticAdjacencyInformation<Pair>::optimize(v18);
      unint64_t v19 = *((int *)*v17 + 2 * a2);
      long long v38 = 0u;
      _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEmRKS1_((uint64_t)a1, v19, &v38);
      _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE((uint64_t)a1, v18);
      vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation((uint64_t)&v30);
      if (__p)
      {
        std::vector<int>::pointer v36 = __p;
        operator delete(__p);
      }
    }
  }
  int v20 = -1431655765 * ((a1[16] - a1[15]) >> 2);
  if (v20)
  {
    std::vector<int>::size_type v21 = (a1[7] - a1[6]) >> 4;
    if (v21)
    {
      __p = 0;
      std::vector<int>::pointer v36 = 0;
      uint64_t v37 = 0;
      uint64_t v34 = 0;
      long long v32 = 0u;
      long long v33 = 0u;
      if (!p_p) {
        p_p = &__p;
      }
      if (!a8) {
        a8 = (std::vector<int> *)&v30;
      }
      long long v30 = 0uLL;
      long long v31 = 0uLL;
      vmesh::SubdivideMidPoint(v21, v20, a2, a8, a1 + 15, p_p);
      vmesh::StaticAdjacencyInformation<Pair>::optimize(a8);
      unint64_t v22 = *((int *)*p_p + 2 * a2);
      long long v38 = 0u;
      _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEmRKS1_((uint64_t)(a1 + 6), v22, &v38);
      vmesh::InterpolateNormals((uint64_t)(a1 + 6), a8);
      vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation((uint64_t)&v30);
      if (__p)
      {
        std::vector<int>::pointer v36 = __p;
        operator delete(__p);
      }
    }
  }
  int v23 = a1 + 12;
  int v24 = -1431655765 * ((a1[13] - a1[12]) >> 2);
  if (v24)
  {
    uint64_t v25 = a1[3];
    uint64_t v26 = a1[4];
    uint64_t v27 = (uint64_t)(a1 + 3);
    std::vector<int>::size_type v28 = (unint64_t)(v26 - v25) >> 3;
    if (v28)
    {
      __p = 0;
      std::vector<int>::pointer v36 = 0;
      uint64_t v37 = 0;
      uint64_t v34 = 0;
      long long v32 = 0u;
      long long v33 = 0u;
      if (!a5) {
        a5 = &__p;
      }
      if (!a6) {
        a6 = (std::vector<int> *)&v30;
      }
      long long v30 = 0uLL;
      long long v31 = 0uLL;
      vmesh::SubdivideMidPoint(v28, v24, a2, a6, v23, a5);
      vmesh::StaticAdjacencyInformation<Pair>::optimize(a6);
      unint64_t v29 = *((int *)*a5 + 2 * a2);
      *(void *)&long long v38 = 0;
      _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE6resizeEmRKS1_(v27, v29, &v38);
      _ZN5vmesh19InterpolateMidPointIDv2_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE(v27, a6);
      vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation((uint64_t)&v30);
      if (__p)
      {
        std::vector<int>::pointer v36 = __p;
        operator delete(__p);
      }
    }
  }
}

void *vmesh::DisplacedSubdivisionMesh::preprocessForSCN(vmesh::DisplacedSubdivisionMesh *this, int a2)
{
  std::chrono::steady_clock::now();
  *(_DWORD *)this = a2;
  if (((*((void *)this + 11) - *((void *)this + 10)) & 0xFFFFFFFF0) == 0) {
    vmesh::TriangleMesh::computeNormals((vmesh::DisplacedSubdivisionMesh *)((char *)this + 32), 1);
  }
  unint64_t v4 = (void *)*((void *)this + 7);
  if (((*((void *)this + 8) - (void)v4) & 0x7FFFFFFF8) == 0)
  {
    uint64_t v5 = *((void *)this + 5) - *((void *)this + 4);
    std::vector<int>::size_type v21 = 0;
    uint64_t v22 = 0;
    uint64_t v20 = 0;
    if (((unint64_t)v5 >> 4))
    {
      unint64_t v7 = (int)(v5 >> 4);
      std::vector<Statement *>::__vallocate[abi:nn180100](&v20, v7);
      CFNumberRef v8 = (char *)v21;
      bzero(v21, 8 * v7);
      uint64_t v6 = &v8[8 * v7];
      std::vector<int>::size_type v21 = v6;
      unint64_t v4 = (void *)*((void *)this + 7);
      if (!v4)
      {
LABEL_9:
        uint64_t v9 = v22;
        *((void *)this + 7) = v20;
        *((void *)this + 8) = v6;
        *((void *)this + 9) = v9;
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v6 = 0;
      if (!v4) {
        goto LABEL_9;
      }
    }
    *((void *)this + 8) = v4;
    operator delete(v4);
    uint64_t v6 = (char *)v21;
    goto LABEL_9;
  }
LABEL_10:
  vmesh::TriangleMesh::subdivideMidPoint((void *)this + 4, a2, (void **)this + 1, (long long *)((char *)this + 392), 0, 0, 0, 0);
  std::chrono::steady_clock::now();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"preprocess() ", 13);
  float32x4_t v10 = (void *)std::ostream::operator<<();
  float32x4_t result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)" ms\n", 4);
  unint64_t v12 = *((void *)this + 2) - *((void *)this + 1);
  if ((int)(v12 >> 3) >= 1)
  {
    uint64_t v13 = 0;
    int v14 = 0;
    uint64_t v15 = v12 & 0x7FFFFFFF8;
    std::vector<int>::size_type v16 = (void *)MEMORY[0x263F8C100];
    do
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"\t LOD[", 6);
      CFNumberRef v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"] ", 2);
      CFNumberRef v18 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"V ", 2);
      unint64_t v19 = (void *)std::ostream::operator<<();
      float32x4_t result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"T\n", 2);
      ++v14;
      v13 += 8;
    }
    while (v15 != v13);
  }
  return result;
}

void vmesh::StaticAdjacencyInformation<Pair>::optimize(void *a1)
{
  unint64_t v2 = a1[4] - a1[3];
  unint64_t v3 = v2 >> 2;
  if ((int)(v2 >> 2) <= 0)
  {
    unint64_t v12 = (_DWORD *)*a1;
    *(_DWORD *)*a1 = 0;
  }
  else
  {
    int v4 = 0;
    int v5 = 0;
    do
    {
      int started = vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex(a1, v5);
      unint64_t v7 = vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex(a1, v5) - started;
      if ((int)v7 >= 1 && started != v4)
      {
        unint64_t v9 = 0;
        do
        {
          *(void *)(a1[6] + 8 * v4 + 8 * v9) = *(void *)(a1[6] + 8 * started + 8 * v9);
          ++v9;
        }
        while (v9 < v7);
      }
      v4 += v7;
      ++v5;
    }
    while (v5 != v3);
    unint64_t v10 = 0;
    float32x4_t v11 = (int *)a1[3];
    unint64_t v12 = (_DWORD *)*a1;
    *(_DWORD *)*a1 = 0;
    int v15 = *v11;
    uint64_t v13 = v11 + 1;
    int v14 = v15;
    do
    {
      v12[v10 / 4 + 1] = v14;
      v14 += v13[v10 / 4];
      v10 += 4;
    }
    while ((v2 & 0x3FFFFFFFCLL) != v10);
  }
  unint64_t v16 = (int)v12[(int)v3];

  std::vector<ClippedCorner>::resize((uint64_t)(a1 + 6), v16);
}

uint64_t _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE(uint64_t result, void *a2)
{
  unint64_t v2 = a2[4] - a2[3];
  if ((int)(v2 >> 2) >= 1)
  {
    int v4 = (void *)result;
    uint64_t v5 = 0;
    uint64_t v6 = (v2 >> 2);
    do
    {
      float32x4_t v15 = *(float32x4_t *)(*v4 + 16 * v5);
      int started = vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex(a2, v5);
      float32x4_t result = vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex(a2, v5);
      v8.i64[0] = 0x3F0000003F000000;
      v8.i64[1] = 0x3F0000003F000000;
      int v9 = result - started;
      if ((int)result > started)
      {
        uint64_t v10 = 8 * started;
        do
        {
          float32x4_t v11 = (unsigned int *)(a2[6] + v10);
          uint64_t v12 = *v11;
          if ((v12 & 0x80000000) != 0 || (uint64_t v13 = (v4[1] - *v4) >> 4, (int)v12 >= (int)v13)) {
            _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE_cold_2();
          }
          uint64_t v14 = v11[1];
          if ((v14 & 0x80000000) != 0 || (int)v14 >= (int)v13) {
            _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE_cold_1();
          }
          *(float32x4_t *)(*v4 + 16 * v14) = vmulq_f32(vaddq_f32(v15, *(float32x4_t *)(*v4 + 16 * v12)), v8);
          v10 += 8;
          --v9;
        }
        while (v9);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return result;
}

uint64_t vmesh::InterpolateNormals(uint64_t result, void *a2)
{
  unint64_t v2 = a2[4] - a2[3];
  if ((int)(v2 >> 2) >= 1)
  {
    int v4 = (uint64_t *)result;
    uint64_t v5 = 0;
    uint64_t v6 = (v2 >> 2);
    do
    {
      float32x4_t v20 = *(float32x4_t *)(*v4 + 16 * v5);
      int started = vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex(a2, v5);
      float32x4_t result = vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex(a2, v5);
      v8.i64[0] = 0x3F0000003F000000;
      v8.i64[1] = 0x3F0000003F000000;
      int v9 = result - started;
      if ((int)result > started)
      {
        uint64_t v10 = 8 * started;
        do
        {
          float32x4_t v11 = (unsigned int *)(a2[6] + v10);
          uint64_t v12 = *v11;
          if ((v12 & 0x80000000) != 0 || (uint64_t v13 = *v4, v14 = (unint64_t)(v4[1] - *v4) >> 4, (int)v12 >= (int)v14)) {
            vmesh::InterpolateNormals();
          }
          uint64_t v15 = v11[1];
          if ((v15 & 0x80000000) != 0 || (int)v15 >= (int)v14) {
            vmesh::InterpolateNormals();
          }
          float32x4_t v16 = vmulq_f32(vaddq_f32(v20, *(float32x4_t *)(v13 + 16 * v12)), v8);
          int32x4_t v17 = (int32x4_t)vmulq_f32(v16, v16);
          v17.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v17, 2), vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.i8, 1))).u32[0];
          float32x2_t v18 = vrsqrte_f32((float32x2_t)v17.u32[0]);
          float32x2_t v19 = vmul_f32(v18, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v18, v18)));
          *(float32x4_t *)(v13 + 16 * v15) = vmulq_n_f32(v16, vmul_f32(v19, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v19, v19))).f32[0]);
          v10 += 8;
          --v9;
        }
        while (v9);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return result;
}

uint64_t _ZN5vmesh19InterpolateMidPointIDv2_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE(uint64_t result, void *a2)
{
  unint64_t v2 = a2[4] - a2[3];
  if ((int)(v2 >> 2) >= 1)
  {
    int v4 = (void *)result;
    uint64_t v5 = 0;
    uint64_t v6 = (v2 >> 2);
    do
    {
      float32x2_t v7 = *(float32x2_t *)(*v4 + 8 * v5);
      int started = vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex(a2, v5);
      float32x4_t result = vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex(a2, v5);
      int v9 = result - started;
      if ((int)result > started)
      {
        uint64_t v10 = 8 * started;
        do
        {
          float32x4_t v11 = (unsigned int *)(a2[6] + v10);
          uint64_t v12 = *v11;
          if ((v12 & 0x80000000) != 0 || (uint64_t v13 = (v4[1] - *v4) >> 3, (int)v12 >= (int)v13)) {
            _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE_cold_2();
          }
          uint64_t v14 = v11[1];
          if ((v14 & 0x80000000) != 0 || (int)v14 >= (int)v13) {
            _ZN5vmesh19InterpolateMidPointIDv3_fEEvRNSt3__16vectorIT_NS2_9allocatorIS4_EEEERKNS_26StaticAdjacencyInformationI4PairEE_cold_1();
          }
          *(float32x2_t *)(*v4 + 8 * v14) = vmul_f32(vadd_f32(v7, *(float32x2_t *)(*v4 + 8 * v12)), (float32x2_t)0x3F0000003F000000);
          v10 += 8;
          --v9;
        }
        while (v9);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return result;
}

uint64_t vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex(void *a1, int a2)
{
  if ((int)((a1[4] - a1[3]) >> 2) <= a2) {
    vmesh::StaticAdjacencyInformation<Pair>::neighborsStartIndex();
  }
  return *(unsigned int *)(*a1 + 4 * a2);
}

uint64_t vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex(void *a1, int a2)
{
  uint64_t v2 = a1[3];
  if ((int)((unint64_t)(a1[4] - v2) >> 2) <= a2) {
    vmesh::StaticAdjacencyInformation<Pair>::neighborsEndIndex();
  }
  return (*(_DWORD *)(v2 + 4 * a2) + *(_DWORD *)(*a1 + 4 * a2));
}

char *vmesh::TriangleMesh::loadBaseMeshFromVectors(char **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = a2[1] - *a2;
  if (!v5) {
    vmesh::TriangleMesh::loadBaseMeshFromVectors();
  }
  uint64_t v11 = *a3;
  uint64_t v10 = a3[1];
  unint64_t v12 = v5 >> 4;
  uint64_t v14 = *a4;
  uint64_t v13 = a4[1];
  if (v10 != *a3)
  {
    if ((v10 - v11) >> 3 != v12) {
      vmesh::TriangleMesh::loadBaseMeshFromVectors();
    }
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE7reserveEm((void **)a1 + 3, v12);
  }
  if (v13 != v14)
  {
    if (v12 != (a4[1] - *a4) >> 4) {
      vmesh::TriangleMesh::loadBaseMeshFromVectors();
    }
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)a1 + 6, v12);
  }
  uint64_t v80 = a4;
  uint64_t v15 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v16 = 0;
    do
    {
      float32x2_t v18 = a1[1];
      unint64_t v17 = (unint64_t)a1[2];
      if ((unint64_t)v18 >= v17)
      {
        uint64_t v20 = (v18 - *a1) >> 4;
        if ((unint64_t)(v20 + 1) >> 60) {
          goto LABEL_92;
        }
        uint64_t v21 = v17 - (void)*a1;
        uint64_t v22 = v21 >> 3;
        if (v21 >> 3 <= (unint64_t)(v20 + 1)) {
          uint64_t v22 = v20 + 1;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v23) {
          int v24 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(a1 + 2), v23);
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = &v24[16 * v20];
        *(_OWORD *)uint64_t v25 = *(_OWORD *)(v15 + 16 * v16);
        float32x2_t v19 = v25 + 16;
        uint64_t v27 = *a1;
        uint64_t v26 = a1[1];
        if (v26 != *a1)
        {
          do
          {
            long long v28 = *((_OWORD *)v26 - 1);
            v26 -= 16;
            *((_OWORD *)v25 - 1) = v28;
            v25 -= 16;
          }
          while (v26 != v27);
          uint64_t v26 = *a1;
        }
        *a1 = v25;
        a1[1] = v19;
        a1[2] = &v24[16 * v23];
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        *(_OWORD *)float32x2_t v18 = *(_OWORD *)(v15 + 16 * v16);
        float32x2_t v19 = v18 + 16;
      }
      a1[1] = v19;
      if (v10 != v11)
      {
        uint64_t v29 = *a3;
        long long v31 = a1[4];
        unint64_t v30 = (unint64_t)a1[5];
        if ((unint64_t)v31 >= v30)
        {
          long long v33 = a1[3];
          uint64_t v34 = (v31 - v33) >> 3;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_92;
          }
          uint64_t v35 = v30 - (void)v33;
          uint64_t v36 = v35 >> 2;
          if (v35 >> 2 <= (unint64_t)(v34 + 1)) {
            uint64_t v36 = v34 + 1;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          if (v37) {
            long long v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)(a1 + 5), v37);
          }
          else {
            long long v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v29 + 8 * v16);
          long long v32 = v39 + 8;
          std::vector<int>::value_type v41 = a1[3];
          std::vector<int>::value_type v40 = a1[4];
          if (v40 != v41)
          {
            do
            {
              uint64_t v42 = *((void *)v40 - 1);
              v40 -= 8;
              *((void *)v39 - 1) = v42;
              v39 -= 8;
            }
            while (v40 != v41);
            std::vector<int>::value_type v40 = a1[3];
          }
          a1[3] = v39;
          a1[4] = v32;
          a1[5] = &v38[8 * v37];
          if (v40) {
            operator delete(v40);
          }
        }
        else
        {
          *(void *)long long v31 = *(void *)(v29 + 8 * v16);
          long long v32 = v31 + 8;
        }
        a1[4] = v32;
      }
      if (v13 != v14)
      {
        uint64_t v43 = *v80;
        uint64_t v45 = a1[7];
        unint64_t v44 = (unint64_t)a1[8];
        if ((unint64_t)v45 >= v44)
        {
          uint64_t v47 = a1[6];
          uint64_t v48 = (v45 - v47) >> 4;
          if ((unint64_t)(v48 + 1) >> 60) {
LABEL_92:
          }
            abort();
          uint64_t v49 = v44 - (void)v47;
          uint64_t v50 = v49 >> 3;
          if (v49 >> 3 <= (unint64_t)(v48 + 1)) {
            uint64_t v50 = v48 + 1;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v51 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v51 = v50;
          }
          if (v51) {
            int v52 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(a1 + 8), v51);
          }
          else {
            int v52 = 0;
          }
          CFNumberRef v53 = &v52[16 * v48];
          *(_OWORD *)CFNumberRef v53 = *(_OWORD *)(v43 + 16 * v16);
          int v46 = v53 + 16;
          CFNumberRef v55 = a1[6];
          CFNumberRef v54 = a1[7];
          if (v54 != v55)
          {
            do
            {
              long long v56 = *((_OWORD *)v54 - 1);
              v54 -= 16;
              *((_OWORD *)v53 - 1) = v56;
              v53 -= 16;
            }
            while (v54 != v55);
            CFNumberRef v54 = a1[6];
          }
          a1[6] = v53;
          a1[7] = v46;
          a1[8] = &v52[16 * v51];
          if (v54) {
            operator delete(v54);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v45 = *(_OWORD *)(v43 + 16 * v16);
          int v46 = v45 + 16;
        }
        a1[7] = v46;
      }
      ++v16;
      uint64_t v15 = *a2;
    }
    while (v16 < (a2[1] - *a2) >> 4);
  }
  uint64_t v57 = *a5;
  uint64_t v58 = a5[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v58 - *a5) >> 2) > 0x5555555555555555) {
    vmesh::TriangleMesh::loadBaseMeshFromVectors();
  }
  if (v58 == v57)
  {
    CFNumberRef v61 = a1[10];
  }
  else
  {
    unint64_t v59 = 0;
    int v60 = a1 + 11;
    CFNumberRef v61 = a1[10];
    do
    {
      int v62 = (int *)(v57 + 4 * v59);
      int v63 = *v62;
      int v64 = v62[1];
      int v65 = v62[2];
      if ((unint64_t)v61 >= *v60)
      {
        int v66 = a1[9];
        unint64_t v67 = 0xAAAAAAAAAAAAAAABLL * ((v61 - v66) >> 2);
        unint64_t v68 = v67 + 1;
        if (v67 + 1 > 0x1555555555555555) {
          goto LABEL_92;
        }
        if (0x5555555555555556 * ((uint64_t)(*v60 - (void)v66) >> 2) > v68) {
          unint64_t v68 = 0x5555555555555556 * ((uint64_t)(*v60 - (void)v66) >> 2);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v60 - (void)v66) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v69 = 0x1555555555555555;
        }
        else {
          unint64_t v69 = v68;
        }
        if (v69) {
          int v70 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<vmesh::Triangle>>((uint64_t)(a1 + 11), v69);
        }
        else {
          int v70 = 0;
        }
        int v71 = &v70[12 * v67];
        *(_DWORD *)int v71 = v63;
        *((_DWORD *)v71 + 1) = v64;
        *((_DWORD *)v71 + 2) = v65;
        CFNumberRef v73 = a1[9];
        CFNumberRef v72 = a1[10];
        CFNumberRef v74 = v71;
        if (v72 != v73)
        {
          do
          {
            uint64_t v75 = *(void *)(v72 - 12);
            v72 -= 12;
            int v76 = *((_DWORD *)v72 + 2);
            *(void *)(v74 - 12) = v75;
            v74 -= 12;
            *((_DWORD *)v74 + 2) = v76;
          }
          while (v72 != v73);
          CFNumberRef v72 = a1[9];
        }
        CFNumberRef v61 = v71 + 12;
        a1[9] = v74;
        a1[10] = v71 + 12;
        a1[11] = &v70[12 * v69];
        if (v72) {
          operator delete(v72);
        }
      }
      else
      {
        *(_DWORD *)CFNumberRef v61 = v63;
        *((_DWORD *)v61 + 1) = v64;
        *((_DWORD *)v61 + 2) = v65;
        v61 += 12;
      }
      a1[10] = v61;
      v59 += 3;
      uint64_t v57 = *a5;
    }
    while (v59 < (a5[1] - *a5) >> 2);
  }
  std::vector<vmesh::Triangle>::__assign_with_size[abi:nn180100]<vmesh::Triangle*,vmesh::Triangle*>((char *)a1 + 96, a1[9], (uint64_t)v61, 0xAAAAAAAAAAAAAAABLL * ((v61 - a1[9]) >> 2));
  CFNumberRef v77 = a1[9];
  uint64_t v78 = (uint64_t)a1[10];

  return std::vector<vmesh::Triangle>::__assign_with_size[abi:nn180100]<vmesh::Triangle*,vmesh::Triangle*>((char *)a1 + 120, v77, v78, 0xAAAAAAAAAAAAAAABLL * ((v78 - (uint64_t)v77) >> 2));
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  int v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(v3, a2);
    float32x2_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    int v9 = &v6[8 * v8];
    uint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    unint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  int v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    float32x2_t v7 = &v6[v5];
    int v9 = &v6[16 * v8];
    uint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    unint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 1);
        v10 -= 16;
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 16;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEmRKS1_(uint64_t a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEmRKS1_((void **)a1, a2 - v3, a3);
  }
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEmRKS1_(void **a1, unint64_t a2, _OWORD *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  float32x2_t v7 = v8;
  int v9 = *(_OWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 4)
  {
    if (a2)
    {
      uint64_t v16 = 16 * a2;
      unint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 16;
      }
      while (v16);
      int v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 4);
    if (v11 >> 60) {
      abort();
    }
    uint64_t v12 = v10 >> 4;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 3 > v11) {
      unint64_t v11 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v6, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    float32x2_t v18 = &v15[16 * v12];
    float32x2_t v19 = &v18[16 * a2];
    uint64_t v20 = 16 * a2;
    uint64_t v21 = v18;
    do
    {
      *(_OWORD *)uint64_t v21 = *a3;
      v21 += 16;
      v20 -= 16;
    }
    while (v20);
    uint64_t v22 = &v15[16 * v14];
    int v24 = (char *)*a1;
    unint64_t v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        long long v25 = *((_OWORD *)v23 - 1);
        v23 -= 16;
        *((_OWORD *)v18 - 1) = v25;
        v18 -= 16;
      }
      while (v23 != v24);
      unint64_t v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE6resizeEmRKS1_(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEmRKS1_((void **)a1, a2 - v3, a3);
  }
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEmRKS1_(void **a1, unint64_t a2, void *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  float32x2_t v7 = v8;
  int v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      unint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      int v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(v6, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    float32x2_t v18 = &v15[8 * v12];
    float32x2_t v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    uint64_t v21 = v18;
    do
    {
      *(void *)uint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    uint64_t v22 = &v15[8 * v14];
    int v24 = (char *)*a1;
    unint64_t v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *((void *)v18 - 1) = v25;
        v18 -= 8;
      }
      while (v23 != v24);
      unint64_t v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<vmesh::Triangle>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(12 * a2);
}

uint64_t vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  int v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

void std::vector<vmesh::Triangle>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  uint64_t v5 = v6;
  float32x2_t v7 = *(_DWORD **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v7) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v14 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      memset(*(void **)(v4 - 8), 255, v14);
      float32x2_t v7 = (_DWORD *)((char *)v7 + v14);
    }
    *(void *)(a1 + 8) = v7;
  }
  else
  {
    uint64_t v8 = *(_DWORD **)a1;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *(void *)a1) >> 2);
    unint64_t v10 = v9 + a2;
    if (v9 + a2 > 0x1555555555555555) {
      abort();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (uint64_t)v8) >> 2);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<vmesh::Triangle>>(v4, v12);
      uint64_t v8 = *(_DWORD **)a1;
      float32x2_t v7 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v15 = &v13[12 * v9];
    uint64_t v16 = &v13[12 * v12];
    size_t v17 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    memset(v15, 255, v17);
    float32x2_t v18 = &v15[v17];
    if (v7 != v8)
    {
      do
      {
        uint64_t v19 = *(void *)(v7 - 3);
        v7 -= 3;
        int v20 = v7[2];
        *(void *)(v15 - 12) = v19;
        v15 -= 12;
        *((_DWORD *)v15 + 2) = v20;
      }
      while (v7 != v8);
      uint64_t v8 = *(_DWORD **)a1;
    }
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v18;
    *(void *)(a1 + 16) = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  float32x2_t v7 = value;
  unint64_t v9 = p_end_cap[-1].__value_;
  if (__n <= value - v9)
  {
    if (__n)
    {
      std::vector<int>::size_type v16 = 4 * __n;
      size_t v17 = &v9[__n];
      do
      {
        *v9++ = *__x;
        v16 -= 4;
      }
      while (v16);
      unint64_t v9 = v17;
    }
    this->__end_ = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (char *)this->__begin_;
    unint64_t v11 = __n + (v10 >> 2);
    if (v11 >> 62) {
      abort();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = (char *)v7 - (char *)this->__begin_;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)p_end_cap, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    float32x2_t v18 = (int *)&v15[4 * v12];
    uint64_t v19 = &v18[__n];
    std::vector<int>::size_type v20 = 4 * __n;
    uint64_t v21 = v18;
    do
    {
      *v21++ = *__x;
      v20 -= 4;
    }
    while (v20);
    uint64_t v22 = (int *)&v15[4 * v14];
    std::vector<int>::pointer begin = this->__begin_;
    for (std::vector<int>::pointer i = this->__end_; i != begin; --i)
    {
      int v25 = *(i - 1);
      *--float32x2_t v18 = v25;
    }
    this->__begin_ = v18;
    this->__end_ = v19;
    this->__end_cap_.__value_ = v22;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

char *std::vector<vmesh::Triangle>::__assign_with_size[abi:nn180100]<vmesh::Triangle*,vmesh::Triangle*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  float32x2_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 2) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *float32x2_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x1555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    float32x4_t result = std::vector<vmesh::Triangle>::__vallocate[abi:nn180100](v7, v12);
    unint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    unint64_t v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      float32x2_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v13 = (void **)(result + 8);
  uint64_t v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 2) >= a4) {
    goto LABEL_16;
  }
  std::vector<int>::size_type v16 = &__src[4 * ((v15 - v9) >> 2)];
  if (v15 != v9)
  {
    float32x4_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    unint64_t v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    float32x2_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    float32x4_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v13 = &v9[v17];
  return result;
}

char *std::vector<vmesh::Triangle>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    abort();
  }
  float32x4_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<vmesh::Triangle>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8nn180100Em(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  float32x4_t result = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x210534ED0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = a2;
    }
    int v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v11 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v9, v8, v6, (char)v10)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x210534EE0](v13);
  return a1;
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      uint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void *std::string::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a2);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

C3D::RenderPass *C3D::DrawQuadPass::DrawQuadPass(C3D::DrawQuadPass *this, RenderGraph *a2, C3D::Pass *a3, __C3DFXPass *a4)
{
  float32x4_t result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)float32x4_t result = &unk_26BF6CDB0;
  *((void *)result + 30) = a4;
  *((void *)result + 31) = 0;
  return result;
}

const char *C3D::DrawQuadPass::name(C3D::DrawQuadPass *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (const char **)*((void *)this + 30);
  if (v4) {
    return C3D::CachedFXPassName((void **)this + 31, v4, *(__C3DFXPass **)(*((void *)this + 3) + 16), a4);
  }
  else {
    return "DrawQuadPass";
  }
}

double C3D::DrawQuadPass::execute(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(v1 + 16));
  v13[4] = 0;
  v13[5] = 0;
  uint64_t Scene = C3DEngineContextGetScene(*(void *)(v2 + 16));
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  uint64_t v6 = *(void *)(v2 + 16);
  v13[0] = EnginePipeline;
  v13[1] = v6;
  v13[3] = v2;
  bzero(v9, 0x1400uLL);
  v9[0] = *(void *)(v2 + 240);
  char v10 = 1;
  char v11 = 0;
  long long v12 = 0u;
  v13[2] = (uint64_t)v9;
  C3DEnginePipelineApplyNotificationQueue(v13);
  if (C3DFXPassGetUsesSceneBackgroundColor(*(void *)(v2 + 240)))
  {
    Backgrounduint64_t EffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0);
    if (BackgroundEffectSlot) {
      C3DEngineContextRenderBackgroundMap(*(void *)(v2 + 16), BackgroundEffectSlot, (uint64_t)v9);
    }
  }
  -[SCNMTLRenderContext startProcessingRendererElementsWithEngineIterationContext:](RenderContext, (uint64_t)v13);
  -[SCNMTLRenderContext drawFullScreenQuadForPass:](RenderContext, *(void *)(v2 + 240));
  return -[SCNMTLRenderContext stopProcessingRendererElements:](RenderContext, 0);
}

BOOL Tokenizer::NextChar(Tokenizer *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v1 = *((void *)this + 2);
  if (v1 < v2)
  {
    unint64_t v3 = *((void *)this + 3);
    *((unsigned char *)this + 64) = *((unsigned char *)this + 65);
    if (v3 >= v2)
    {
      int v5 = 0;
    }
    else
    {
      uint64_t v4 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      int v5 = *((unsigned __int8 *)v4 + v3);
    }
    *((unsigned char *)this + 65) = v5;
    *((void *)this + 3) = v3 + 1;
    ++*((_DWORD *)this + 18);
    if (v5 == 10) {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
  }
  return v1 < v2;
}

uint64_t Tokenizer::ParseNumber(Tokenizer *this)
{
  unint64_t v1 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  unint64_t v3 = *((void *)this + 3);
  if (v2 < v1)
  {
    *((unsigned char *)this + 64) = *((unsigned char *)this + 65);
    if (v3 >= v1)
    {
      unsigned int v5 = 0;
    }
    else
    {
      uint64_t v4 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      unsigned int v5 = *((unsigned __int8 *)v4 + v3);
    }
    *((unsigned char *)this + 65) = v5;
    *((void *)this + 3) = ++v3;
    int v6 = *((_DWORD *)this + 18) + 1;
    *((_DWORD *)this + 18) = v6;
    if (v5 == 10)
    {
      int v6 = 0;
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    uint64_t v7 = MEMORY[0x263EF8318];
    while (1)
    {
      while (1)
      {
        if (((v5 & 0x80) != 0 || (*(_DWORD *)(v7 + 4 * v5 + 60) & 0x400) == 0)
          && (v5 - 46 > 0x37 || ((1 << (v5 - 46)) & 0x80000000800001) == 0))
        {
          goto LABEL_21;
        }
        *((unsigned char *)this + 64) = v5;
        if (v3 < v1) {
          break;
        }
        unsigned int v5 = 0;
        *((unsigned char *)this + 65) = 0;
        *((void *)this + 3) = ++v3;
        ++v6;
LABEL_20:
        *((_DWORD *)this + 18) = v6;
      }
      size_t v8 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        size_t v8 = (void *)*v8;
      }
      unsigned int v5 = *((unsigned __int8 *)v8 + v3);
      *((unsigned char *)this + 65) = v5;
      *((void *)this + 3) = ++v3;
      *((_DWORD *)this + 18) = ++v6;
      if (v5 == 10)
      {
        int v6 = 0;
        ++*((_DWORD *)this + 17);
        unsigned int v5 = 10;
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  *((void *)this + 4) = *(void *)this;
  *((void *)this + 5) = v2;
  *((void *)this + 6) = v3 + ~v2;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 2) = v3 - 1;
  return (uint64_t)this + 32;
}

uint64_t Tokenizer::ParseString(Tokenizer *this)
{
  unint64_t v1 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  if (v2 >= v1)
  {
    int v5 = *((unsigned __int8 *)this + 65);
  }
  else
  {
    unint64_t v3 = *((void *)this + 3);
    *((unsigned char *)this + 64) = *((unsigned char *)this + 65);
    if (v3 >= v1)
    {
      int v5 = 0;
    }
    else
    {
      uint64_t v4 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      int v5 = *((unsigned __int8 *)v4 + v3);
    }
    *((unsigned char *)this + 65) = v5;
    *((void *)this + 3) = v3 + 1;
    ++*((_DWORD *)this + 18);
    if (v5 == 10)
    {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      goto LABEL_11;
    }
  }
  if (v5 == 34)
  {
LABEL_23:
    if (v2 >= v1)
    {
      unint64_t v6 = *((void *)this + 3);
    }
    else
    {
LABEL_24:
      unint64_t v9 = *((void *)this + 3);
      *((unsigned char *)this + 64) = v5;
      if (v9 >= v1)
      {
        int v11 = 0;
      }
      else
      {
        char v10 = *(void **)this;
        if (*(char *)(*(void *)this + 23) < 0) {
          char v10 = (void *)*v10;
        }
        int v11 = *((unsigned __int8 *)v10 + v9);
      }
      *((unsigned char *)this + 65) = v11;
      unint64_t v6 = v9 + 1;
      *((void *)this + 3) = v6;
      ++*((_DWORD *)this + 18);
      if (v11 == 10) {
        *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      }
    }
    unint64_t v12 = v6 + ~v2;
    goto LABEL_33;
  }
LABEL_11:
  unint64_t v6 = *((void *)this + 3);
  if (v6 <= v1) {
    unint64_t v7 = v1;
  }
  else {
    unint64_t v7 = *((void *)this + 3);
  }
  if (v6 >= v1) {
    goto LABEL_23;
  }
  while (v2 < v1)
  {
    *((unsigned char *)this + 64) = v5;
    size_t v8 = *(void **)this;
    if (*(char *)(*(void *)this + 23) < 0) {
      size_t v8 = (void *)*v8;
    }
    int v5 = *((unsigned __int8 *)v8 + v6);
    *((unsigned char *)this + 65) = v5;
    *((void *)this + 3) = ++v6;
    ++*((_DWORD *)this + 18);
    if (v5 == 10)
    {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    else if (v5 == 34)
    {
      goto LABEL_24;
    }
    if (v7 == v6) {
      goto LABEL_23;
    }
  }
  unint64_t v12 = ~v2 + v6;
LABEL_33:
  *((void *)this + 4) = *(void *)this;
  *((void *)this + 5) = v2;
  *((void *)this + 6) = v12;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 2) = v6 - 1;
  return (uint64_t)this + 32;
}

uint64_t Tokenizer::ParseMultiLineComment(Tokenizer *this)
{
  unint64_t v1 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  if (v2 >= v1)
  {
    int v6 = *((unsigned __int8 *)this + 65);
  }
  else
  {
    unint64_t v3 = *((void *)this + 3);
    *((unsigned char *)this + 64) = *((unsigned char *)this + 65);
    if (v3 >= v1)
    {
      int v5 = 0;
    }
    else
    {
      uint64_t v4 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      int v5 = *((unsigned __int8 *)v4 + v3);
    }
    *((unsigned char *)this + 65) = v5;
    unint64_t v7 = v3 + 1;
    *((void *)this + 3) = v3 + 1;
    int v8 = *((_DWORD *)this + 18) + 1;
    *((_DWORD *)this + 18) = v8;
    if (v5 == 10)
    {
      int v8 = 0;
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    *((unsigned char *)this + 64) = v5;
    if (v7 >= v1)
    {
      int v6 = 0;
      *((unsigned char *)this + 65) = 0;
      *((void *)this + 3) = v3 + 2;
      *((_DWORD *)this + 18) = v8 + 1;
    }
    else
    {
      unint64_t v9 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        unint64_t v9 = (void *)*v9;
      }
      int v6 = *((unsigned __int8 *)v9 + v7);
      *((unsigned char *)this + 65) = v6;
      *((void *)this + 3) = v3 + 2;
      *((_DWORD *)this + 18) = v8 + 1;
      if (v6 == 10) {
        *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      }
    }
  }
  unint64_t v10 = *((void *)this + 3);
  while (1)
  {
    if (v6 != 42)
    {
      if (v2 >= v1) {
        goto LABEL_32;
      }
      goto LABEL_24;
    }
    if (v2 >= v1) {
      goto LABEL_32;
    }
    int v11 = *(uint64_t **)this;
    uint64_t v12 = *(void *)this;
    if (*(char *)(*(void *)this + 23) < 0) {
      uint64_t v12 = *v11;
    }
    if (*(unsigned char *)(v12 + v10) == 47) {
      break;
    }
LABEL_24:
    *((unsigned char *)this + 64) = v6;
    if (v10 >= v1)
    {
      int v6 = 0;
    }
    else
    {
      uint64_t v13 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v13 = (void *)*v13;
      }
      int v6 = *((unsigned __int8 *)v13 + v10);
    }
    *((unsigned char *)this + 65) = v6;
    *((void *)this + 3) = ++v10;
    ++*((_DWORD *)this + 18);
    if (v6 == 10) {
      *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    if (v10 >= v1)
    {
LABEL_32:
      unint64_t v14 = v10 + ~v2;
      int v11 = *(uint64_t **)this;
      goto LABEL_33;
    }
  }
  *((unsigned char *)this + 64) = 42;
  if (v10 >= v1)
  {
    int v17 = 0;
  }
  else
  {
    std::vector<int>::size_type v16 = v11;
    if (*((char *)v11 + 23) < 0) {
      std::vector<int>::size_type v16 = (uint64_t *)*v11;
    }
    int v17 = *((unsigned __int8 *)v16 + v10);
  }
  *((unsigned char *)this + 65) = v17;
  *((void *)this + 3) = v10 + 1;
  int v18 = *((_DWORD *)this + 18) + 1;
  *((_DWORD *)this + 18) = v18;
  if (v17 == 10)
  {
    int v18 = 0;
    *(void *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
  }
  *((unsigned char *)this + 64) = v17;
  if (v10 + 1 >= v1)
  {
    *((unsigned char *)this + 65) = 0;
    v10 += 2;
    *((void *)this + 3) = v10;
    int v21 = v18 + 1;
LABEL_47:
    *((_DWORD *)this + 18) = v21;
  }
  else
  {
    uint64_t v19 = v11;
    if (*((char *)v11 + 23) < 0) {
      uint64_t v19 = (uint64_t *)*v11;
    }
    int v20 = *((unsigned __int8 *)v19 + v10 + 1);
    *((unsigned char *)this + 65) = v20;
    v10 += 2;
    *((void *)this + 3) = v10;
    *((_DWORD *)this + 18) = v18 + 1;
    if (v20 == 10)
    {
      int v21 = 0;
      ++*((_DWORD *)this + 17);
      goto LABEL_47;
    }
  }
  unint64_t v14 = v10 + ~v2;
LABEL_33:
  *((void *)this + 4) = v11;
  *((void *)this + 5) = v2;
  *((void *)this + 6) = v14;
  *((_DWORD *)this + 14) = 12;
  *((void *)this + 2) = v10 - 1;
  return (uint64_t)this + 32;
}

uint64_t Tokenizer::GetNextChar(Tokenizer *this)
{
  if (*((void *)this + 2) >= *((void *)this + 1)) {
    return 0;
  }
  else {
    return (char)*((unsigned char *)this + 65);
  }
}

uint64_t _C3DLODEnumerateSubEntities(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return result;
}

__CFArray *_C3DLODCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  unint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  int v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v5, @"name", @"LOD");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  unint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v23 = 0;
  int valuePtr = 7;
  uint64_t v22 = a1 + 72;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v9, @"name", @"threshold");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 0;
  int valuePtr = 2;
  uint64_t v22 = a1 + 76;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v13, @"name", @"thresholdType");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  int v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 0;
  int valuePtr = 2;
  uint64_t v22 = a1 + 48;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v17, @"name", @"sceneRef");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  return Mutable;
}

uint64_t C3DLODCreate(const void *a1, int a2, float a3)
{
  if (C3DLODGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLODGetTypeID_onceToken, &__block_literal_global_54);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DLODGetTypeID_typeID, 0x40uLL);
  *(_DWORD *)(Instance + 76) = a2;
  *(float *)(Instance + 72) = a3;
  CFNumberRef v7 = *(const void **)(Instance + 64);
  if (v7 != a1)
  {
    if (v7)
    {
      CFRelease(v7);
      *(void *)(Instance + 64) = 0;
    }
    if (a1) {
      CFTypeRef v8 = CFRetain(a1);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *(void *)(Instance + 64) = v8;
  }
  return Instance;
}

uint64_t C3DLODGetEntity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLODGetEntity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

uint64_t C3DLODGetThresholdType(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLODGetEntity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 76);
}

float C3DLODGetThreshold(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLODGetEntity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 72);
}

id _C3DLODCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 64);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 64) = 0;
  }

  return C3DEntityCFFinalize(a1);
}

CFStringRef _C3DLODCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLOD>");
}

CFStringRef _C3DLODCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLOD>");
}

C3D::DrawNodesPass *C3D::SSAODepthNormalPass::SSAODepthNormalPass(C3D::DrawNodesPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  uint64_t v7 = 0;
  long long v9 = 0u;
  uint64_t v10 = 0x20000;
  memset(v6, 0, sizeof(v6));
  uint64_t v8 = -1;
  BYTE8(v9) = 1;
  float32x4_t result = C3D::DrawNodesPass::DrawNodesPass(a1, a2, a3, (const Parameters *)v6);
  *(void *)float32x4_t result = &unk_26BF6DD50;
  *((void *)result + 670) = 0;
  *((void *)result + 671) = a4;
  return result;
}

const char *C3D::SSAODepthNormalPass::name(C3D::SSAODepthNormalPass *this)
{
  return "SSAODepthNormalPass";
}

const char *C3D::SSAODepthNormalPass::programHashCodeStoreName(C3D::SSAODepthNormalPass *this)
{
  return "SSAODepthNormalPass";
}

void C3D::SSAODepthNormalPass::setup(C3D::SSAODepthNormalPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  C3D::Pass::setOutputCount(this, 2u);
  uint64_t v3 = C3D::PassDescriptor::outputAtIndex((C3D::SSAODepthNormalPass *)((char *)this + 32), 0);
  *(void *)(v3 + 8) = "SSAO-DepthNormal";
  *(unsigned char *)(v3 + 65) = 0;
  *(_WORD *)(v3 + 28) = 115;
  uint64_t v4 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 671));
  *(_WORD *)(v3 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex(v4, 0) + 16);
  uint64_t v5 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 671));
  unsigned int v6 = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v5, 0) + 18);
  *(_WORD *)(v3 + 18) = v6;
  LOWORD(v7) = *(_WORD *)(v3 + 16);
  *(float *)&unint64_t v7 = fmax((double)v7, (double)v6);
  *(unsigned char *)(v3 + 30) = (int)(float)(floorf(log2f(*(float *)&v7)) + 1.0);
  __int16 v8 = *(_WORD *)(v3 + 66);
  *(_OWORD *)(v3 + 48) = xmmword_20B5EDB10;
  *(_WORD *)(v3 + 66) = v8 & 0xFFBC | 0x42;
  uint64_t v9 = C3D::PassDescriptor::outputAtIndex((C3D::SSAODepthNormalPass *)((char *)this + 32), 1u);
  *(unsigned char *)(v9 + 64) = 2;
  *(_WORD *)(v9 + 66) |= 8u;
  uint64_t v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 671));
  *(_WORD *)(v9 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex(v10, 0) + 16);
  CFNumberRef v11 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 671));
  *(_WORD *)(v9 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex(v11, 0) + 18);
  *(_WORD *)(v9 + 28) = 252;
  *(_WORD *)(v9 + 66) = *(_WORD *)(v9 + 66) & 0xFFFC | 2;
  *((unsigned char *)this + 296) = 0;
  *((void *)this + 31) = C3DEngineContextGetPointOfView(*((void *)this + 2));
  if (*(unsigned char *)(v3 + 24) == 5)
  {
    BOOL v12 = (-[SCNMTLRenderContext features](RenderContext) & 0x20) != 0;
    *((unsigned char *)this + 117) = v12;
    *((unsigned char *)this + 118) = v12;
    *((_WORD *)this + 19) = 6;
  }
  else if (C3DEngineContextGetEyeCount(*((void *)this + 2)) >= 2)
  {
    int PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(*((void *)this + 2));
    *((unsigned char *)this + 117) = PreferredRenderMode;
    *((unsigned char *)this + 118) = PreferredRenderMode != 0;
    *((_WORD *)this + 19) = C3DEngineContextGetEyeCount(*((void *)this + 2));
    *((unsigned char *)this + 120) = 1;
  }

  C3D::DrawNodesPass::setup(this);
}

void C3D::SSAODepthNormalPass::compile(C3D::SSAODepthNormalPass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::SSAODepthNormalPass *))(*(void *)this + 64))(this);
  uint64_t v3 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 670) = v3;
  if (!v3) {
    operator new();
  }
  *((void *)this + 32) = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v3 + 16);

  C3D::DrawNodesPass::compile(this);
}

void C3D::SSAODepthNormalPassResource::~SSAODepthNormalPassResource(C3D::SSAODepthNormalPassResource *this)
{
  *(void *)this = &unk_26BF6E5B0;
  CFAllocatorRef v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E5B0;
  CFAllocatorRef v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x210534FE0);
}

BOOL C3DGeometryOpenSubdivGetGPUCanBenefitFromSingleCreasePatches(uint64_t a1)
{
  return *(void *)(a1 + 144) && *(void *)(a1 + 152) != 0;
}

BOOL C3DSubdivisionGetPathTypeSupportsSingleCrease(int a1)
{
  return (a1 - 1) < 3;
}

uint64_t C3DSubdivisionOsdGPUGetTessellationPartitionMode(uint64_t a1)
{
  return 2 * *(unsigned __int8 *)(a1 + 4);
}

uint64_t C3DGeometryOpenSubdivGetGPUHasPatchOfType(uint64_t a1, int a2)
{
  uint64_t result = *(void *)(*(void *)(a1 + 168) + 24);
  if (result) {
    return __C3DSubdivisionOsdGPUHasPatchOfType(result, a2);
  }
  return result;
}

BOOL __C3DSubdivisionOsdGPUHasPatchOfType(uint64_t a1, int a2)
{
  int v3 = C3DPatchTypeToOsdPatchType(a2);
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(_DWORD **)(a1 + 40);
  if (*v5 == v3) {
    return 1;
  }
  unint64_t v7 = v5 + 4;
  uint64_t v8 = 1;
  do
  {
    unint64_t v9 = v8;
    if (v4 == v8) {
      break;
    }
    int v10 = *v7;
    v7 += 4;
    ++v8;
  }
  while (v10 != v3);
  return v9 < v4;
}

void *_C3DSubdivisionOsdGPURuntimeDataCFInit(void *result)
{
  result[11] = 0;
  result[12] = 0;
  result[13] = 0;
  return result;
}

void _C3DSubdivisionOsdGPURuntimeDataCFFinalize(char *a1)
{
  uint64_t v2 = *((void *)a1 + 15);
  if (v2)
  {
    unint64_t v7 = (void **)*((void *)a1 + 15);
    std::vector<std::vector<std::vector<CFRange>>>::__destroy_vector::operator()[abi:nn180100](&v7);
    MEMORY[0x210534FE0](v2, 0x20C40960023A9);
  }
  __C3DSubdivisionOsdGPUPatchTableDestroy((uint64_t)(a1 + 32));
  int v3 = (char **)*((void *)a1 + 11);
  if (v3)
  {
    unint64_t v4 = *v3;
    uint64_t v5 = v3[1];
    if (*v3 != v5)
    {
      do
      {
        __C3DSubdivisionOsdGPUPatchTableDestroy((uint64_t)v4);
        v4 += 56;
      }
      while (v4 != v5);
      int v3 = (char **)*((void *)a1 + 11);
      if (!v3) {
        goto LABEL_11;
      }
      unint64_t v4 = *v3;
    }
    if (v4)
    {
      v3[1] = v4;
      operator delete(v4);
    }
    MEMORY[0x210534FE0](v3, 0x20C40960023A9);
  }
LABEL_11:

  __C3DSubdivisionOsdGPURefinerDestroy((uint64_t)(a1 + 144));
  for (uint64_t i = 0; i != 80; i += 8)
}

__CFString *_C3DSubdivisionOsdGPURuntimeDataCFCopyDebugDescription(id *a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  CFStringAppendFormat(Mutable, 0, @"<C3DSubdivisionOsdGPURuntimeDataRef %p>", a1);
  uint64_t v57 = 0;
  uint64_t v58 = &v57;
  uint64_t v59 = 0x2020000000;
  uint64_t v60 = 0;
  uint64_t v3 = [a1[8] length];
  id v4 = a1[4];
  uint64_t v5 = [a1[6] length];
  uint64_t v6 = [a1[7] length];
  v58[3] += 16 * (void)v4 + v3 + v5 + v6;
  CFStringAppend(Mutable, @"\nVertex patch table:");
  uint64_t v7 = C3DGetByteCountDescriptionFromSize(16 * (void)v4);
  CFStringAppendFormat(Mutable, 0, @"\n  - Patch arrays (%@):", v7);
  if (a1[4])
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      int v10 = (char *)a1[5] + v8;
      uint64_t v11 = *((unsigned int *)v10 + 1);
      BOOL v12 = C3DGetPatchTypeDescription(*(_DWORD *)v10);
      CFStringAppendFormat(Mutable, 0, @"\n    - %d x %@", v11, v12);
      ++v9;
      v8 += 16;
    }
    while (v9 < (unint64_t)a1[4]);
  }
  id v13 = a1[8];
  uint64_t v14 = C3DGetByteCountDescriptionFromSize(v3);
  CFStringAppendFormat(Mutable, 0, @"\n  - Data buffer: %p (%@)", v13, v14);
  id v15 = a1[6];
  uint64_t v16 = C3DGetByteCountDescriptionFromSize(v5);
  CFStringAppendFormat(Mutable, 0, @"\n  - Patch index buffer: %p (%@)", v15, v16);
  id v17 = a1[7];
  uint64_t v18 = C3DGetByteCountDescriptionFromSize(v6);
  CFStringAppendFormat(Mutable, 0, @"\n  - Patch param buffer: %p (%@)", v17, v18);
  CFNumberRef v19 = a1[11];
  if (v19)
  {
    uint64_t v20 = *((void *)a1[11] + 1) - *v19;
    if (v20)
    {
      unint64_t v21 = 0;
      uint64_t v51 = 0x6DB6DB6DB6DB6DB7 * (v20 >> 3);
      int v52 = a1;
      do
      {
        CFStringAppendFormat(Mutable, 0, @"\nFVar patch table (channel %zu):", v21);
        uint64_t v22 = (uint64_t *)a1[11];
        uint64_t v23 = *v22;
        if (0x6DB6DB6DB6DB6DB7 * ((v22[1] - *v22) >> 3) <= v21) {
          abort();
        }
        int v24 = (unint64_t *)(v23 + 56 * v21);
        uint64_t v55 = [(id)v24[4] length];
        unint64_t v25 = *v24;
        uint64_t v54 = [(id)v24[2] length];
        uint64_t v26 = [(id)v24[3] length];
        v58[3] += 16 * v25 + v55 + v54 + v26;
        uint64_t v27 = C3DGetByteCountDescriptionFromSize(16 * v25);
        CFStringAppendFormat(Mutable, 0, @"\n  - Patch arrays (%@):", v27);
        uint64_t v53 = v26;
        if (*v24)
        {
          uint64_t v28 = 0;
          unint64_t v29 = 0;
          unint64_t v30 = (void *)(v23 + 56 * v21 + 8);
          do
          {
            uint64_t v31 = *v30 + v28;
            uint64_t v32 = *(unsigned int *)(v31 + 4);
            long long v33 = C3DGetPatchTypeDescription(*(_DWORD *)v31);
            CFStringAppendFormat(Mutable, 0, @"\n    - %d x %@", v32, v33);
            ++v29;
            v28 += 16;
          }
          while (v29 < *v24);
        }
        uint64_t v34 = v24[4];
        uint64_t v35 = C3DGetByteCountDescriptionFromSize(v55);
        CFStringAppendFormat(Mutable, 0, @"\n  - Data buffer: %p (%@)", v34, v35);
        uint64_t v36 = v24[2];
        uint64_t v37 = C3DGetByteCountDescriptionFromSize(v54);
        CFStringAppendFormat(Mutable, 0, @"\n  - Patch index buffer: %p (%@)", v36, v37);
        uint64_t v38 = v24[3];
        uint64_t v39 = C3DGetByteCountDescriptionFromSize(v53);
        CFStringAppendFormat(Mutable, 0, @"\n  - Patch param buffer: %p (%@)", v38, v39);
        ++v21;
        a1 = v52;
      }
      while (v21 != v51);
    }
  }
  if (a1[12] && a1[13])
  {
    CFStringAppend(Mutable, @"\nLegacy Gregory patch table:");
    uint64_t v40 = [a1[12] length];
    uint64_t v41 = [a1[13] length];
    v58[3] += v41 + v40;
    id v42 = a1[12];
    uint64_t v43 = C3DGetByteCountDescriptionFromSize(v40);
    CFStringAppendFormat(Mutable, 0, @"\n  - Vertex valence buffer: %p (%@)", v42, v43);
    id v44 = a1[13];
    uint64_t v45 = C3DGetByteCountDescriptionFromSize(v41);
    CFStringAppendFormat(Mutable, 0, @"\n  - Quad offsets buffer: %p (%@)", v44, v45);
  }
  v56[0] = MEMORY[0x263EF8330];
  v56[1] = 3221225472;
  v56[2] = ___ZL54_C3DSubdivisionOsdGPURuntimeDataCFCopyDebugDescriptionPKv_block_invoke;
  v56[3] = &unk_264007748;
  v56[4] = &v57;
  v56[5] = Mutable;
  CFStringAppend(Mutable, @"\nVertex Refiner:");
  ___ZL54_C3DSubdivisionOsdGPURuntimeDataCFCopyDebugDescriptionPKv_block_invoke((uint64_t)v56, (uint64_t)(a1 + 18));
  uint64_t v46 = [a1[44] length];
  v58[3] += v46;
  id v47 = a1[44];
  uint64_t v48 = C3DGetByteCountDescriptionFromSize(v46);
  CFStringAppendFormat(Mutable, 0, @"\n  - Skin/morph indexing table: %p (%@)", v47, v48);
  uint64_t v49 = C3DGetByteCountDescriptionFromSize(v58[3]);
  CFStringAppendFormat(Mutable, 0, @"\nTotal memory usage: %@", v49);
  _Block_object_dispose(&v57, 8);
  return Mutable;
}

void sub_20B38A1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z40C3DSubdivisionOsdGPURuntimeDataGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DSubdivisionOsdGPURuntimeDataGetTypeID(void)::typeID = result;
  return result;
}

uint64_t __C3DSubdivisionOsdGPURefine(__n128 *a1, void *a2)
{
  if (!a1[5].n128_u64[0])
  {
    id v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DSubdivisionOsdGPURefine(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v23 = 0;
  int v24 = 0;
  uint64_t v12 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](a1[5].n128_i64[0]);
  if (!OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils(v12, a1[2].n128_i64[1], &a1[3].n128_u32[2], a1[3].n128_i64[0], &a1[4].n128_i32[1], 0, (uint64_t)&v23, 0, *a1, v13, (uint64_t)&v23, a1->n128_u64[0], a1->n128_i64[1], a1[1].n128_i64[0], a1[1].n128_i64[1], 0, 0, 0, a1[2].n128_i32[0],
          a2))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      __C3DSubdivisionOsdGPURefine(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  return C3DSceneSourcePerformConsistencyCheck(a2);
}

void __C3DSubdivisionOsdGPUCreateSynchronizeCoarsePositionsPipeline(uint64_t a1, __C3DGeometry *a2, void *a3, id *a4)
{
  if (C3DGeometryGetEffectiveDataKindForRendering(a2))
  {
    *(void *)(a1 + 360) = (id)[a3 computePipelineStateForKernel:@"scn_osd_synchronize_coarse_positions_no_argument_buffer"];
    uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a2);
    uint64_t PositionOriginalToFirstDeindexedTable = C3DMeshGetPositionOriginalToFirstDeindexedTable(Mesh);
    var7 = a2->var10.var7;
    if (!var7)
    {
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        __C3DSubdivisionOsdGPUCreateSynchronizeCoarsePositionsPipeline(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }
    uint64_t v20 = var7[4];
    uint64_t v19 = var7[5];
    __p = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    unint64_t v21 = (v19 - v20) >> 2;
    if (v19 != v20)
    {
      std::vector<float>::__vallocate[abi:nn180100](&__p, (v19 - v20) >> 2);
      uint64_t v22 = (char *)v36;
      bzero(v36, v19 - v20);
      uint64_t v36 = &v22[v19 - v20];
    }
    if (v21 != *(_DWORD *)(a1 + 28))
    {
      uint64_t v23 = scn_default_log();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
        __C3DSubdivisionOsdGPUCreateSynchronizeCoarsePositionsPipeline(v23, v24, v25, v26, v27, v28, v29, v30);
      }
    }
    uint64_t v31 = __p;
    if (v19 != v20)
    {
      uint64_t v32 = 0;
      uint64_t v33 = var7[4];
      do
      {
        uint64_t v34 = *(unsigned int *)(v33 + 4 * v32);
        if (PositionOriginalToFirstDeindexedTable) {
          LODWORD(v34) = *(_DWORD *)(PositionOriginalToFirstDeindexedTable + 4 * v34);
        }
        v31[v32++] = v34;
      }
      while (v21 > v32);
    }
    *(void *)(a1 + 352) = [*a4 newBufferWithBytes:v31 length:(unsigned char *)v36 - (unsigned char *)v31 options:0];
    if (__p)
    {
      uint64_t v36 = __p;
      operator delete(__p);
    }
  }
  else
  {
    *(void *)(a1 + 352) = 0;
    *(void *)(a1 + 360) = (id)[a3 computePipelineStateForKernel:@"scn_osd_synchronize_indexed_coarse_positions_no_argument_buffer"];
  }
}

void sub_20B38A490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DSubdivisionOsdGPURuntimeDataCreateWithData(uint64_t a1, uint64_t a2, unsigned char *a3, SCNMTLResourceManager *a4, void *a5, uint64_t a6)
{
  uint64_t v9 = (NSKeyedUnarchiver *)[objc_alloc(MEMORY[0x263F08928]) initForReadingFromData:a1 error:0];
  uint64_t v10 = 0;
  if ([(NSKeyedUnarchiver *)v9 decodeInt32ForKey:@"version"] >= 2)
  {
    if (!a5)
    {
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        C3DSubdivisionOsdGPURuntimeDataCreateWithData(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }
    uint64_t v19 = (void *)[a5 commandBuffer];
    uint64_t v20 = (void *)[v19 computeCommandEncoder];
    v36.var0 = (id)[a5 device];
    v36.var1 = a5;
    v36.var2 = v19;
    v36.var3 = v20;
    if (C3DSubdivisionOsdGPURuntimeDataGetTypeID(void)::onceToken != -1) {
      dispatch_once(&C3DSubdivisionOsdGPURuntimeDataGetTypeID(void)::onceToken, &__block_literal_global_55);
    }
    uint64_t Instance = C3DTypeCreateInstance_(C3DSubdivisionOsdGPURuntimeDataGetTypeID(void)::typeID, 0x188uLL);
    uint64_t v35 = 0;
    *(_DWORD *)(Instance + 28) = [(NSKeyedUnarchiver *)v9 decodeInt32ForKey:@"coarseVertexCount"];
    __C3DSubdivisionOsdGPURuntimeDataDecodePatchTable(v9, &cfstr_Vertexpatchtab.isa, &v36, size);
    long long v22 = v38;
    *(_OWORD *)(Instance + 32) = *(_OWORD *)size;
    *(_OWORD *)(Instance + 48) = v22;
    *(_OWORD *)(Instance + 64) = v39;
    *(void *)(Instance + 80) = v40;
    uint64_t v33 = a6;
    if (-[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"fvarPatchTables" stringByAppendingString:@".count"]))
    {
      operator new();
    }
    *(void *)(Instance + 88) = 0;
    if (a3[6] == 2)
    {
      uint64_t v23 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(v9, (NSString *)[@"legacyGregoryPatchTable" stringByAppendingString:@".vertexValenceBuffer"], &v36, 0);
      uint64_t v24 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(v9, (NSString *)[@"legacyGregoryPatchTable" stringByAppendingString:@".quadOffsetsBuffer"], &v36, 0);
      int v25 = -[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"legacyGregoryPatchTable" stringByAppendingString:@".quadOffsetsBaseGregory"]);
      int v26 = -[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"legacyGregoryPatchTable" stringByAppendingString:@".quadOffsetsBaseGregoryBoundary"]);
    }
    else
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      int v25 = -1;
      int v26 = -1;
    }
    *(void *)(Instance + 96) = v23;
    *(void *)(Instance + 104) = v24;
    *(_DWORD *)(Instance + 112) = v25;
    *(_DWORD *)(Instance + 116) = v26;
    int32_t v27 = -[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"patchRangesTable" stringByAppendingString:@".elementCount"]);
    int32_t v28 = -[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"patchRangesTable" stringByAppendingString:@".patchArrayCount"]);
    if (v27 && v28) {
      operator new();
    }
    *(void *)(Instance + 120) = 0;
    __C3DSubdivisionOsdGPURuntimeDataDecodeRefiner(v9, &cfstr_Vertexrefiner.isa, a4, &v36, (uint64_t)size);
    long long v29 = v40;
    *(_OWORD *)(Instance + 176) = v39;
    *(_OWORD *)(Instance + 192) = v29;
    *(_OWORD *)(Instance + 208) = v41;
    *(void *)(Instance + 224) = v42;
    long long v30 = v38;
    *(_OWORD *)(Instance + 144) = *(_OWORD *)size;
    *(_OWORD *)(Instance + 160) = v30;
    *(void *)(Instance + 184) = *(id *)(Instance + 64);
    *(void *)(Instance + 192) = *(id *)(Instance + 64);
    __C3DSubdivisionOsdGPURefine((__n128 *)(Instance + 144), &v36);
    *(_DWORD *)(Instance + 16) = 0;
    if (-[NSKeyedUnarchiver decodeInt32ForKey:](v9, "decodeInt32ForKey:", [@"fvarRefiners" stringByAppendingString:@".count"]))
    {
      operator new();
    }
    uint64_t v35 = 0;
    uint64_t v10 = Instance;
    __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(Instance, a3, a4, &v36.var0);
    *(void *)(Instance + 352) = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(v9, &cfstr_Skinmorphsubdi.isa, &v36, 0);
    if ([(NSKeyedUnarchiver *)v9 containsValueForKey:@"synchronizeCoarsePositionsPipeline.functionName"])
    {
      *(void *)(Instance + 360) = [(SCNMTLResourceManager *)a4 computePipelineStateForKernel:[(NSKeyedUnarchiver *)v9 decodeObjectOfClass:objc_opt_class() forKey:@"synchronizeCoarsePositionsPipeline.functionName"]];
    }
    *(void *)(Instance + 128) = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(v9, &cfstr_Fvarchanneldes.isa, &v36, 0);
    *(void *)(Instance + 136) = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(v9, &cfstr_Fvarchannelspa.isa, &v36, 0);
    [v36.var3 endEncoding];
    [v36.var2 commit];
    [v36.var2 waitUntilCompleted];
    if ([v36.var2 status] == 4) {
      goto LABEL_24;
    }
    uint64_t v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      C3DSubdivisionOsdGPURuntimeDataCreateWithData(&v36.var2);
      if (!v33) {
        goto LABEL_23;
      }
    }
    else if (!v33)
    {
LABEL_23:
      CFRelease((CFTypeRef)Instance);
      uint64_t v10 = 0;
LABEL_24:
      __C3DSubdivisionOsdGPUSetupAdditionalDataDestroy(&v35);
      goto LABEL_25;
    }
    (*(void (**)(uint64_t, id, uint64_t))(v33 + 16))(v33, v36.var2, 1);
    goto LABEL_23;
  }
LABEL_25:
  [(NSKeyedUnarchiver *)v9 finishDecoding];

  return v10;
}

void sub_20B38ADE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void **a26)
{
}

uint64_t __C3DSubdivisionOsdGPURuntimeDataDecodePatchTable@<X0>(NSKeyedUnarchiver *a1@<X0>, NSString *a2@<X1>, MTLContext *a3@<X2>, size_t *a4@<X8>)
{
  size_t size = 0;
  uint64_t v8 = [(NSKeyedUnarchiver *)a1 decodeBytesForKey:[(NSString *)a2 stringByAppendingString:@".patchArrays"] returnedLength:&size];
  size_t v9 = size;
  *a4 = size >> 4;
  uint64_t v10 = malloc_type_malloc(v9, 0x4AECCD0DuLL);
  a4[1] = (size_t)v10;
  memcpy(v10, v8, size);
  a4[5] = [(NSKeyedUnarchiver *)a1 decodeInt32ForKey:[(NSString *)a2 stringByAppendingString:@".dataBufferOffset"]];
  a4[6] = [(NSKeyedUnarchiver *)a1 decodeInt32ForKey:[(NSString *)a2 stringByAppendingString:@".dataBufferCoarseDataSize"]];
  size_t v11 = [(NSKeyedUnarchiver *)a1 decodeInt32ForKey:[(NSString *)a2 stringByAppendingString:@".dataBufferFullDataSize"]];
  a4[2] = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)a2 stringByAppendingString:@".patchIndexBuffer"], a3, 0);
  a4[3] = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)a2 stringByAppendingString:@".patchParamBuffer"], a3, 0);
  uint64_t result = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)a2 stringByAppendingString:@".dataBuffer"], a3, v11);
  a4[4] = result;
  return result;
}

id __C3DSubdivisionOsdGPURuntimeDataDecodeRefiner@<X0>(NSKeyedUnarchiver *a1@<X0>, NSString *a2@<X1>, SCNMTLResourceManager *a3@<X2>, MTLContext *a4@<X3>, uint64_t a5@<X8>)
{
  *(void *)(a5 + 56) = 0;
  uint64_t v9 = a5 + 56;
  *(void *)(a5 + 64) = 0;
  *(void *)(a5 + 72) = 0;
  uint64_t v10 = [(NSString *)a2 stringByAppendingString:@".stencilTable"];
  uint64_t v11 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)v10 stringByAppendingString:@".sizesBuffer"], a4, 0);
  uint64_t v12 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)v10 stringByAppendingString:@".offsetsBuffer"], a4, 0);
  uint64_t v13 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)v10 stringByAppendingString:@".indicesBuffer"], a4, 0);
  uint64_t v14 = __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(a1, [(NSString *)v10 stringByAppendingString:@".weightsBuffer"], a4, 0);
  int32_t v15 = [(NSKeyedUnarchiver *)a1 decodeInt32ForKey:[(NSString *)v10 stringByAppendingString:@".numStencils"]];
  *(void *)a5 = v11;
  *(void *)(a5 + 8) = v12;
  *(void *)(a5 + 16) = v13;
  *(void *)(a5 + 24) = v14;
  *(_DWORD *)(a5 + 32) = v15;
  uint64_t v16 = [(NSString *)a2 stringByAppendingString:@".evaluatorInput"];
  long long v23 = 0uLL;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v17 = [(NSKeyedUnarchiver *)a1 decodeBytesForKey:[(NSString *)v16 stringByAppendingString:@".srcDesc"] returnedLength:&v26];
  uint64_t v18 = [(NSKeyedUnarchiver *)a1 decodeBytesForKey:[(NSString *)v16 stringByAppendingString:@".dstDesc"] returnedLength:&v25];
  if (v26 != 12) {
    __C3DSubdivisionOsdGPURuntimeDataDecodeRefiner();
  }
  if (v25 != 12) {
    __C3DSubdivisionOsdGPURuntimeDataDecodeRefiner();
  }
  *(_DWORD *)&v24[8] = *((_DWORD *)v17 + 2);
  *(void *)uint64_t v24 = *(void *)v17;
  *(void *)&v24[12] = *(void *)v18;
  int v19 = *((_DWORD *)v18 + 2);
  long long v20 = *(_OWORD *)v24;
  *(_OWORD *)(a5 + 40) = v23;
  *(_DWORD *)&v24[20] = v19;
  *(_OWORD *)(a5 + 56) = v20;
  *(void *)(a5 + 72) = *(void *)&v24[16];
  *(void *)&long long v23 = 0;
  DWORD2(v23) = 0;
  id result = [(SCNMTLResourceManager *)a3 computeEvaluatorWithContext:a4 srcDesc:v9 dstDesc:a5 + 68 duDesc:&v23 dvDesc:&v23];
  *(void *)(a5 + 80) = result;
  return result;
}

void __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(uint64_t a1, unsigned char *a2, void *a3, id *a4)
{
  int v8 = a2[4];
  BOOL IsVarying = C3DGeometryOsdGetColorIsVarying(*(_DWORD *)(a1 + 24));
  VaryingTextureCoordinatesCFIndex Count = C3DGeometryOsdGetVaryingTextureCoordinatesCount(*(_DWORD *)(a1 + 24));
  if (IsVarying) {
    int v11 = 16;
  }
  else {
    int v11 = 0;
  }
  if (*(void *)(a1 + 32))
  {
    int v43 = v8;
    uint64_t v45 = a4;
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    unsigned int v14 = 0;
    unint64_t v4 = 0;
    int v15 = v11 + 8 * VaryingTextureCoordinatesCount;
    do
    {
      uint64_t v16 = (int *)(*(void *)(a1 + 40) + v12);
      int v18 = *v16;
      int v17 = v16[1];
      unsigned int v19 = C3DPatchTypeFromOsdPatchType(*v16);
      __int16 v20 = 4;
      unint64_t v21 = 16;
      __int16 v22 = 16;
      switch(v18)
      {
        case 1:
        case 2:
LABEL_10:
          long long v23 = scn_default_log();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(&v48, v49);
          }
          break;
        case 3:
        case 7:
        case 8:
          goto LABEL_9;
        case 4:
          break;
        case 6:
LABEL_12:
          BOOL v24 = v19 >= 4 || a2[3] == 0;
          *(_WORD *)(a1 + 240) = 12 * v13;
          *(_WORD *)(a1 + 256) = v14;
          float v25 = 36.0;
          if (v24) {
            float v25 = 12.0;
          }
          unsigned int v14 = (float)((float)v14 + (float)((float)(v25 * (float)v17) * (float)v21)) + v17 * v15 * v22;
          break;
        case 9:
          *(_WORD *)(a1 + 246) = 12 * v13;
          *(_WORD *)(a1 + 262) = v14;
          v14 += 20 * v17 * v15 + 240 * v17;
          break;
        default:
          __int16 v20 = -1;
LABEL_9:
          __int16 v22 = v20;
          unint64_t v21 = v20;
          switch(v18)
          {
            case 0:
            case 1:
            case 2:
            case 5:
              goto LABEL_10;
            case 6:
              goto LABEL_12;
            case 7:
              *(_WORD *)(a1 + 242) = 12 * v13;
              *(_WORD *)(a1 + 258) = v14;
              goto LABEL_21;
            case 8:
              *(_WORD *)(a1 + 244) = 12 * v13;
              *(_WORD *)(a1 + 260) = v14;
LABEL_21:
              v14 += v17 * v15 * v20 + 60 * v17 * v20;
              break;
            default:
              goto LABEL_22;
          }
          break;
      }
LABEL_22:
      v13 += v17;
      ++v4;
      v12 += 16;
    }
    while (v4 < *(void *)(a1 + 32));
    if (v14)
    {
      a4 = v45;
      uint64_t v26 = [*v45 newBufferWithLength:v14 options:32];
    }
    else
    {
      uint64_t v26 = 0;
      a4 = v45;
    }
    int v8 = v43;
  }
  else
  {
    unsigned int v13 = 0;
    uint64_t v26 = 0;
  }
  *(void *)(a1 + 248) = v26;
  if (v8) {
    uint64_t v27 = [*a4 newBufferWithLength:80 * v13 options:32];
  }
  else {
    uint64_t v27 = 0;
  }
  *(void *)(a1 + 264) = v27;
  *(void *)(a1 + 232) = [*a4 newBufferWithLength:12 * v13 options:32];
  if (*(void *)(a1 + 32))
  {
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    uint64_t v44 = *(unsigned int *)(a1 + 24);
    unint64_t v46 = (unint64_t)a2[4] << 16;
    do
    {
      uint64_t v30 = *(void *)(a1 + 40);
      uint64_t v31 = *(unsigned int *)(v30 + v28);
      unsigned int v32 = C3DPatchTypeFromOsdPatchType(*(_DWORD *)(v30 + v28));
      if (a2[2])
      {
        unsigned int v33 = v32;
        int v34 = a2[3];
        id v35 = objc_alloc_init(MEMORY[0x263EFF9A0]);
        BOOL v36 = v33 >= 4 || v34 == 0;
        uint64_t v37 = 256;
        if (v36) {
          uint64_t v37 = 0;
        }
        unint64_t v4 = v4 & 0xFFFFFFFF00000000 | v44;
        uint64_t v38 = C3DSubdivisionOsdGPUGetProgramGeneratorResources(v37 | v46 | v33 | 0x2000000000, v4, v35);
        id v39 = objc_alloc_init(MEMORY[0x263F12838]);
        [v39 setLanguageVersion:SCNMetalLanguageVersion()];
        [v39 setFastMathEnabled:1];
        [v39 setPreprocessorMacros:v35];
        [v39 setAdditionalCompilerArguments:@" -w "];

        id v40 = [NSString alloc];
        uint64_t v41 = C3DSubdivisionOsdGPUGetPerPatchTypeSources(v33);
        if (__C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::onceToken != -1) {
          dispatch_once(&__C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::onceToken, &__block_literal_global_503);
        }
        uint64_t v42 = (void *)[v40 initWithFormat:@"%@%@%@", v38, v41, __C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::kC3DOpenSubdivComputeSource];
        *(void *)(a1 + 8 * v31 + 272) = objc_msgSend(a3, "newComputePipelineStateWithFunctionName:library:", @"compute_opensubdiv", objc_msgSend((id)-[SCNMTLResourceManager libraryManager]((uint64_t)a3), "libraryForSourceCode:options:", v42, v39));
      }
      ++v29;
      v28 += 16;
    }
    while (v29 < *(void *)(a1 + 32));
  }
}

uint64_t __C3DSubdivisionOsdGPURuntimeDataDecodeMTLBuffer(NSKeyedUnarchiver *a1, NSString *a2, MTLContext *a3, size_t a4)
{
  if (![(NSKeyedUnarchiver *)a1 containsValueForKey:a2]) {
    return 0;
  }
  size_t __n = 0;
  int v8 = [(NSKeyedUnarchiver *)a1 decodeBytesForKey:a2 returnedLength:&__n];
  if (__n >= a4) {
    return objc_msgSend(a3->var0, "newBufferWithBytes:length:options:", v8);
  }
  uint64_t v9 = malloc_type_malloc(a4, 0xEAE4FB69uLL);
  memcpy(v9, v8, __n);
  uint64_t v10 = [a3->var0 newBufferWithBytes:v9 length:a4 options:0];
  free(v9);
  return v10;
}

void __C3DSubdivisionOsdGPUSetupAdditionalDataDestroy(char ***a1)
{
  CFAllocatorRef v1 = *a1;
  if (*a1)
  {
    uint64_t v2 = *v1;
    uint64_t v3 = v1[1];
    if (*v1 == v3) {
      goto LABEL_6;
    }
    do
    {
      __C3DSubdivisionOsdGPURefinerDestroy((uint64_t)v2);
      v2 += 88;
    }
    while (v2 != v3);
    CFAllocatorRef v1 = *a1;
    if (*a1)
    {
      uint64_t v2 = *v1;
LABEL_6:
      if (v2)
      {
        v1[1] = v2;
        operator delete(v2);
      }
      JUMPOUT(0x210534FE0);
    }
  }
}

uint64_t C3DSubdivisionOsdGPUGetSharedSources()
{
  if (C3DSubdivisionOsdGPUGetSharedSources::onceToken != -1) {
    dispatch_once(&C3DSubdivisionOsdGPUGetSharedSources::onceToken, &__block_literal_global_41_0);
  }
  return C3DSubdivisionOsdGPUGetSharedSources::kSources;
}

void __C3DSubdivisionOsdGPUGetSharedSources_block_invoke()
{
  v0 = (OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource *)[NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetPatchBasisShaderSource((uint64_t *)__p, v0);
  if (v3 >= 0) {
    CFAllocatorRef v1 = __p;
  }
  else {
    CFAllocatorRef v1 = (void **)__p[0];
  }
  C3DSubdivisionOsdGPUGetSharedSources::kSources = [(OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource *)v0 initWithCString:v1 encoding:4];
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_20B38B888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DSubdivisionOsdGPUGetPerPatchTypeSources(int a1)
{
  switch(a1)
  {
    case 1:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_Quads(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_Quads(void)::onceToken, &__block_literal_global_514);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_Quads(void)::kSources;
      break;
    case 2:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_Triangles(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_Triangles(void)::onceToken, &__block_literal_global_516);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_Triangles(void)::kSources;
      break;
    case 3:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_Regular(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_Regular(void)::onceToken, &__block_literal_global_518);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_Regular(void)::kSources;
      break;
    case 4:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_Gregory(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_Gregory(void)::onceToken, &__block_literal_global_520);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_Gregory(void)::kSources;
      break;
    case 5:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBoundary(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBoundary(void)::onceToken, &__block_literal_global_522);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBoundary(void)::kSources;
      break;
    case 6:
      if (C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBasis(void)::onceToken != -1) {
        dispatch_once(&C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBasis(void)::onceToken, &__block_literal_global_524);
      }
      CFAllocatorRef v1 = &C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBasis(void)::kSources;
      break;
    default:
      C3DSubdivisionOsdGPUGetPerPatchTypeSources_cold_1();
  }
  return *v1;
}

uint64_t C3DSubdivisionOsdGPUGetProgramGeneratorResources(unint64_t a1, unsigned int a2, void *a3)
{
  int v6 = C3DPatchTypeToOsdPatchType(a1);
  uint64_t v7 = v6 - 3;
  if (v7 > 6) {
    unint64_t v8 = -1;
  }
  else {
    unint64_t v8 = qword_20B5EDB40[v7];
  }
  [a3 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"USE_OPENSUBDIV"];
  objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", (v6 - 5) < 5), @"OSD_IS_ADAPTIVE");
  double v100 = a3;
  unsigned int v95 = v6 - 5;
  switch(v6)
  {
    case 3:
      uint64_t v9 = (void *)MEMORY[0x263EFFA88];
      uint64_t v10 = @"OSD_PATCH_QUADS";
      goto LABEL_10;
    case 4:
      uint64_t v9 = (void *)MEMORY[0x263EFFA88];
      uint64_t v10 = @"OSD_PATCH_TRIANGLES";
      goto LABEL_10;
    case 5:
      int v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        C3DSubdivisionOsdGPUGetProgramGeneratorResources_cold_1(v11);
      }
      break;
    case 6:
      [a3 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"OSD_PATCH_REGULAR"];
      uint64_t v9 = &unk_26BFC1240;
      uint64_t v10 = @"CONTROL_POINTS_PER_PATCH";
LABEL_10:
      [a3 setObject:v9 forKeyedSubscript:v10];
      break;
    case 7:
      uint64_t v12 = MEMORY[0x263EFFA88];
      unsigned int v13 = @"OSD_PATCH_GREGORY";
      goto LABEL_14;
    case 8:
      uint64_t v12 = MEMORY[0x263EFFA88];
      unsigned int v13 = @"OSD_PATCH_GREGORY_BOUNDARY";
      goto LABEL_14;
    case 9:
      uint64_t v12 = MEMORY[0x263EFFA88];
      unsigned int v13 = @"OSD_PATCH_GREGORY_BASIS";
LABEL_14:
      [a3 setObject:v12 forKeyedSubscript:v13];
      [a3 setObject:&unk_26BFC1258 forKeyedSubscript:@"CONTROL_POINTS_PER_PATCH"];
      unint64_t v8 = 4;
      break;
    default:
      break;
  }
  unsigned int v14 = a2;
  BOOL IsVarying = C3DGeometryOsdGetColorIsVarying(a2);
  VaryingTextureCoordinatesCFIndex Count = C3DGeometryOsdGetVaryingTextureCoordinatesCount(v14);
  if (IsVarying) {
    char v17 = 4;
  }
  else {
    char v17 = 0;
  }
  BOOL IsFaceVarying = C3DGeometryOsdGetColorIsFaceVarying(v14);
  FaceVaryingTextureCoordinatesCFIndex Count = C3DGeometryOsdGetFaceVaryingTextureCoordinatesCount(v14);
  if (IsFaceVarying) {
    char v20 = 4;
  }
  else {
    char v20 = 0;
  }
  char v97 = v20;
  char v98 = FaceVaryingTextureCoordinatesCount;
  unsigned int HasMultipleFaceVaryingChannels = C3DGeometryOsdGetHasMultipleFaceVaryingChannels(v14);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v106);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_UV_CORRECTION if (t > 0.5) { ti += 0.01f; } else { ti += 0.01f; }\n",
    78);
  char v99 = v17 + 2 * VaryingTextureCoordinatesCount;
  if (v99)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"struct OsdInputVertexType { \n", 29);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"    metal::packed_float3 position; \n",
      36);
    for (int i = 0; i != 8; ++i)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, i) == 2)
      {
        __int16 v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"    metal::packed_float2 texcoord", 33);
        std::to_string(&v105, i);
        long long v23 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v105
            : (std::string *)v105.__r_.__value_.__r.__words[0];
        uint64_t v24 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(v105.__r_.__value_.__r.__words[2])
            : v105.__r_.__value_.__l.__size_;
        float v25 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)v23, v24);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)"; \n", 3);
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"    metal::packed_float4 color; \n",
    }
        33);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"}; \n", 4);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_DECLARE                             ", 61);
    for (int j = 0; j != 8; ++j)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, j) == 2)
      {
        uint64_t v27 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"float2 texcoord", 15);
        std::to_string(&v105, j);
        uint64_t v28 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v105
            : (std::string *)v105.__r_.__value_.__r.__words[0];
        uint64_t v29 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(v105.__r_.__value_.__r.__words[2])
            : v105.__r_.__value_.__l.__size_;
        uint64_t v30 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)v28, v29);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)"; ", 2);
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"float4 color; ", 14);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_DECLARE_PACKED                             ", 68);
    for (int k = 0; k != 8; ++k)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, k) == 2)
      {
        unsigned int v32 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"metal::packed_float2 texcoord", 29);
        std::to_string(&v105, k);
        unsigned int v33 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v105
            : (std::string *)v105.__r_.__value_.__r.__words[0];
        uint64_t v34 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(v105.__r_.__value_.__r.__words[2])
            : v105.__r_.__value_.__l.__size_;
        id v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)v33, v34);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)"; ", 2);
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"metal::packed_float4 color; ",
    }
        28);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_PER_VERTEX(in, out)                 ", 61);
    for (int m = 0; m != 8; ++m)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, m) == 2)
      {
        uint64_t v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.texcoord", 12);
        std::to_string(&v105, m);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v38 = &v105;
        }
        else {
          uint64_t v38 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v105.__r_.__value_.__l.__size_;
        }
        id v40 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)v38, size);
        uint64_t v41 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)" = in.texcoord", 14);
        std::to_string(&v104, m);
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v42 = &v104;
        }
        else {
          uint64_t v42 = (std::string *)v104.__r_.__value_.__r.__words[0];
        }
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v43 = HIBYTE(v104.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v43 = v104.__r_.__value_.__l.__size_;
        }
        uint64_t v44 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)v42, v43);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"; ", 2);
        if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v104.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.color = in.color; ",
    }
        22);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)          ", 61);
    for (int n = 0; n != 8; ++n)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, n) == 2)
      {
        unint64_t v46 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.texcoord", 12);
        std::to_string(&v105, n);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          id v47 = &v105;
        }
        else {
          id v47 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v48 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v48 = v105.__r_.__value_.__l.__size_;
        }
        uint64_t v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)v47, v48);
        uint64_t v50 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)" = in.texcoord", 14);
        std::to_string(&v104, n);
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v51 = &v104;
        }
        else {
          uint64_t v51 = (std::string *)v104.__r_.__value_.__r.__words[0];
        }
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v52 = HIBYTE(v104.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v52 = v104.__r_.__value_.__l.__size_;
        }
        uint64_t v53 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v50, (uint64_t)v51, v52);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"; ", 2);
        if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v104.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.color = in.color; ",
    }
        22);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out) ", 61);
    for (iint i = 0; ii != 8; ++ii)
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, ii) == 2)
      {
        uint64_t v55 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.texcoord", 12);
        std::to_string(&v105, ii);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v56 = &v105;
        }
        else {
          long long v56 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v57 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v57 = v105.__r_.__value_.__l.__size_;
        }
        uint64_t v58 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)v56, v57);
        uint64_t v59 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)" = mix(mix(a.texcoord", 21);
        std::to_string(&v104, ii);
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v60 = &v104;
        }
        else {
          uint64_t v60 = (std::string *)v104.__r_.__value_.__r.__words[0];
        }
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v61 = HIBYTE(v104.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v61 = v104.__r_.__value_.__l.__size_;
        }
        int v62 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)v60, v61);
        int v63 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v62, (uint64_t)", b.texcoord", 12);
        std::to_string(&v103, ii);
        if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v64 = &v103;
        }
        else {
          int v64 = (std::string *)v103.__r_.__value_.__r.__words[0];
        }
        if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v65 = HIBYTE(v103.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v65 = v103.__r_.__value_.__l.__size_;
        }
        int v66 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v63, (uint64_t)v64, v65);
        unint64_t v67 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)", UV.x), mix(c.texcoord", 23);
        std::to_string(&v102, ii);
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v68 = &v102;
        }
        else {
          unint64_t v68 = (std::string *)v102.__r_.__value_.__r.__words[0];
        }
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v69 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v69 = v102.__r_.__value_.__l.__size_;
        }
        int v70 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)v68, v69);
        int v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v70, (uint64_t)", d.texcoord", 12);
        std::to_string(&v101, ii);
        if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFNumberRef v72 = &v101;
        }
        else {
          CFNumberRef v72 = (std::string *)v101.__r_.__value_.__r.__words[0];
        }
        if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v73 = HIBYTE(v101.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v73 = v101.__r_.__value_.__l.__size_;
        }
        CFNumberRef v74 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)v72, v73);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)", UV.x), UV.y); ", 16);
        if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v101.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v102.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v103.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v104.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
      }
    }
    if (C3DGeometryOsdGetColorDataType(v14) == 2) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"out.color = mix(mix(a.color, b.color, UV.x), mix(c.color, d.color, UV.x), UV.y); ",
    }
        81);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"#define OSD_USER_VARYING_DECLARE_ATTRIBUTE                   ", 61);
    int v75 = 0;
    unsigned __int8 v76 = 11;
    do
    {
      if (C3DGeometryOsdGetTextureCoordinatesDataType(v14, v75) == 2)
      {
        CFNumberRef v77 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"float2 texcoord", 15);
        std::to_string(&v105, v75);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v78 = &v105;
        }
        else {
          uint64_t v78 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v79 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v79 = v105.__r_.__value_.__l.__size_;
        }
        uint64_t v80 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v77, (uint64_t)v78, v79);
        CFNumberRef v81 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)" [[attribute(", 13);
        std::to_string(&v104, v76);
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFNumberRef v82 = &v104;
        }
        else {
          CFNumberRef v82 = (std::string *)v104.__r_.__value_.__r.__words[0];
        }
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v83 = HIBYTE(v104.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v83 = v104.__r_.__value_.__l.__size_;
        }
        uint64_t v84 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v81, (uint64_t)v82, v83);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v84, (uint64_t)")]]; ", 5);
        if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v104.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
        ++v76;
      }
      ++v75;
    }
    while (v75 != 8);
    if (C3DGeometryOsdGetColorDataType(v14) == 2)
    {
      uint64_t v85 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"float4 color [[attribute(", 25);
      std::to_string(&v105, v76);
      double v86 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v105
          : (std::string *)v105.__r_.__value_.__r.__words[0];
      uint64_t v87 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? HIBYTE(v105.__r_.__value_.__r.__words[2])
          : v105.__r_.__value_.__l.__size_;
      CFNumberRef v88 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v85, (uint64_t)v86, v87);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v88, (uint64_t)")]]; ", 5);
      if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v105.__r_.__value_.__l.__data_);
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"\n", 1);
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"struct OsdInputVertexType { \n", 29);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"    metal::packed_float3 position; \n",
      36);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"}; \n", 4);
  }
  [v100 setObject:&unk_26BFC1270 forKeyedSubscript:@"VERTEX_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1288 forKeyedSubscript:@"PATCH_INDICES_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC12A0 forKeyedSubscript:@"CONTROL_INDICES_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC12B8 forKeyedSubscript:@"OSD_PATCHPARAM_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC12D0 forKeyedSubscript:@"OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC12E8 forKeyedSubscript:@"OSD_PERPATCHTESSFACTORS_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1300 forKeyedSubscript:@"OSD_VALENCE_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1318 forKeyedSubscript:@"OSD_QUADOFFSET_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1330 forKeyedSubscript:@"TRANSFORMS_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1348 forKeyedSubscript:@"TESSELLATION_LEVEL_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC12A0 forKeyedSubscript:@"INDICES_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1360 forKeyedSubscript:@"QUAD_TESSFACTORS_INDEX"];
  [v100 setObject:&unk_26BFC12D0 forKeyedSubscript:@"OSD_PERPATCHVERTEXGREGORY_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1378 forKeyedSubscript:@"OSD_PATCH_INDEX_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC1390 forKeyedSubscript:@"OSD_DRAWINDIRECT_BUFFER_INDEX"];
  [v100 setObject:&unk_26BFC13A8 forKeyedSubscript:@"OSD_KERNELLIMIT_BUFFER_INDEX"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", (a1 >> 8) & 1), @"OSD_PATCH_ENABLE_SINGLE_CREASE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", 0), @"OSD_FRACTIONAL_EVEN_SPACING");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", (a1 >> 16) & 1), @"OSD_FRACTIONAL_ODD_SPACING");
  [v100 setObject:&unk_26BFC1240 forKeyedSubscript:@"OSD_MAX_TESS_LEVEL"];
  [v100 setObject:&unk_26BFC13C0 forKeyedSubscript:@"USE_STAGE_IN"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", (a1 & 0x10000) == 0), @"USE_PTVS_FACTORS");
  [v100 setObject:&unk_26BFC13D8 forKeyedSubscript:@"USE_PTVS_SHARPNESS"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedShort:", WORD2(a1)), @"THREADS_PER_THREADGROUP");
  if (v8 / WORD2(a1) <= 1) {
    unint64_t v89 = 1;
  }
  else {
    unint64_t v89 = v8 / WORD2(a1);
  }
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v89), @"CONTROL_POINTS_PER_THREAD");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInteger:", v8), @"VERTEX_CONTROL_POINTS_PER_PATCH");
  [v100 setObject:&unk_26BFC13A8 forKeyedSubscript:@"OSD_MAX_VALENCE"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedChar:", (v99 + 3)), @"OSD_NUM_ELEMENTS");
  [v100 setObject:&unk_26BFC13C0 forKeyedSubscript:@"OSD_ENABLE_BACKPATCH_CULL"];
  [v100 setObject:&unk_26BFC13C0 forKeyedSubscript:@"OSD_USE_PATCH_INDEX_BUFFER"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", (a1 >> 16) & 1), @"OSD_ENABLE_SCREENSPACE_TESSELLATION");
  [v100 setObject:&unk_26BFC13C0 forKeyedSubscript:@"OSD_ENABLE_PATCH_CULL"];
  [v100 setObject:&unk_26BFC13D8 forKeyedSubscript:@"NEEDS_BARRIER"];
  if (v97 + 2 * v98)
  {
    objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedChar:", (v97 + 2 * v98)), @"OSD_FVAR_WIDTH");
    objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedChar:", HasMultipleFaceVaryingChannels), @"OSD_FVAR_USES_MULTIPLE_CHANNELS");
    [v100 setObject:&unk_26BFC13F0 forKeyedSubscript:@"OSD_FVAR_DATA_BUFFER_INDEX"];
    [v100 setObject:&unk_26BFC1408 forKeyedSubscript:@"OSD_FVAR_INDICES_BUFFER_INDEX"];
    if (v95 <= 4)
    {
      [v100 setObject:&unk_26BFC1240 forKeyedSubscript:@"OSD_FVAR_PATCHPARAM_BUFFER_INDEX"];
      [v100 setObject:&unk_26BFC1420 forKeyedSubscript:@"OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX"];
    }
    [v100 setObject:&unk_26BFC13F0 forKeyedSubscript:@"OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX"];
    [v100 setObject:&unk_26BFC1408 forKeyedSubscript:@"OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX"];
    [v100 setObject:&unk_26BFC1240 forKeyedSubscript:@"OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX"];
    [v100 setObject:&unk_26BFC1420 forKeyedSubscript:@"OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX"];
  }
  [v100 setObject:&unk_26BFC1438 forKeyedSubscript:@"OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING"];
  [v100 setObject:&unk_26BFC1450 forKeyedSubscript:@"OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING"];
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetColorDataType(v14)), @"OSD_COLOR_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 0)), @"OSD_TEXCOORD0_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 1)), @"OSD_TEXCOORD1_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 2)), @"OSD_TEXCOORD2_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 3)), @"OSD_TEXCOORD3_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 4)), @"OSD_TEXCOORD4_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 5)), @"OSD_TEXCOORD5_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 6)), @"OSD_TEXCOORD6_INTERPOLATION_MODE");
  objc_msgSend(v100, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", C3DGeometryOsdGetTextureCoordinatesDataType(v14, 7)), @"OSD_TEXCOORD7_INTERPOLATION_MODE");
  [v100 setObject:&unk_26BFC13C0 forKeyedSubscript:@"C3D_OPTIMIZE_OPENSUBDIV_STORAGE"];
  BOOL v90 = NSString;
  std::stringbuf::str();
  if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    double v91 = &v105;
  }
  else {
    double v91 = (std::string *)v105.__r_.__value_.__r.__words[0];
  }
  uint64_t v92 = [v90 stringWithCString:v91 encoding:4];
  if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v105.__r_.__value_.__l.__data_);
  }
  v106[0] = *MEMORY[0x263F8C2B8];
  uint64_t v93 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v106 + *(void *)(v106[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v107[0] = v93;
  v107[1] = MEMORY[0x263F8C318] + 16;
  if (v108 < 0) {
    operator delete((void *)v107[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x210534F80](&v109);
  return v92;
}

void sub_20B38CDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
}

uint64_t C3DPatchTypeToOsdPatchType(int a1)
{
  if ((a1 - 1) >= 6) {
    C3DPatchTypeToOsdPatchType();
  }
  return dword_20B5EDB78[(char)(a1 - 1)];
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  uint64_t v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  unint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_20B38D1DC(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x210534F80](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x210534F80](a1 + 128);
  return a1;
}

uint64_t C3DSubdivisionOsdGPUGetAllPossibleMacros(void *a1, const char *a2)
{
  return [a1 addObject:@"USE_OPENSUBDIV"];
}

char *C3DGeometryOpenSubdivGetGPUContext(uint64_t a1, int a2, uint64_t a3)
{
  C3DSubdivInitializeIfNeeded();
  uint64_t v6 = *(char **)(a1 + 168);
  if (v6) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = a2 == 0;
  }
  if (v7)
  {
    if (!v6) {
      return v6;
    }
    uint64_t v37 = a3;
    BOOL v8 = *((void *)v6 + 3) == 0;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 136))
    {
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        C3DGeometryOpenSubdivGetGPUContext_cold_2(v9, v10, v11, v12, v13, v14, v15, v16);
      }
    }
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    C3DGeometryGetTessellator(a1, &v39);
    BOOL v17 = (v40 & 0x100) != 0 && *(void *)(a1 + 144) && *(void *)(a1 + 152) != 0;
    char v18 = *(unsigned char *)(a1 + 136);
    char v19 = *(unsigned char *)(a1 + 137);
    int v20 = (BYTE1(v40) >> 1) & 1;
    uint64_t v37 = a3;
    BOOL HasFeatures = C3DEngineContextHasFeatures(a3, 64);
    __int16 v22 = *(_WORD *)(a1 + 139);
    uint64_t v23 = *(void *)(a1 + 152) ^ *(void *)(a1 + 144);
    uint64_t v6 = (char *)malloc_type_malloc(0x20uLL, 0x10200404C916D5DuLL);
    *(void *)(a1 + 168) = v6;
    *uint64_t v6 = v18;
    v6[1] = 0;
    _OWORD v6[2] = v19;
    v6[3] = v17;
    v6[4] = v20;
    v6[5] = HasFeatures;
    void v6[6] = 0;
    *(_WORD *)(v6 + 7) = v22;
    *((_DWORD *)v6 + 3) = 0;
    *(_DWORD *)(v6 + 9) = 0;
    BOOL v8 = 1;
    *((void *)v6 + 2) = v23;
    *((void *)v6 + 3) = 0;
  }
  if (v8 && a2 != 0)
  {
    if (!v37)
    {
      float v25 = scn_default_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
        C3DEngineContextGetStats_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
      }
    }
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v37);
    v38[0] = MEMORY[0x263EF8330];
    v38[1] = 3221225472;
    v38[2] = __C3DGeometryOpenSubdivGetGPUContext_block_invoke;
    void v38[3] = &unk_2640076D8;
    v38[4] = RenderContext;
    v38[5] = a1;
    v38[6] = v6;
    uint64_t v34 = (SCNMTLResourceManager *)-[SCNMTLRenderContext resourceManager](RenderContext);
    id v35 = (void *)-[SCNMTLRenderContext commandQueue](RenderContext);
    *((void *)v6 + 3) = C3DSubdivisionOsdGPURuntimeDataCreateWithGeometry(a1, v37, v6, v34, v35, (uint64_t)v38);
  }
  return v6;
}

void __C3DGeometryOpenSubdivGetGPUContext_block_invoke(uint64_t a1, uint64_t a2)
{
  [-[SCNMTLRenderContext commandBufferStatusMonitor](*(id **)(a1 + 32)) renderContext:*(void *)(a1 + 32) commandBufferDidCompleteWithError:a2];
  uint64_t v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    __C3DGeometryOpenSubdivGetGPUContext_block_invoke_cold_1(a1, v3);
  }
  uint64_t v4 = *(const void **)(*(void *)(a1 + 48) + 24);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(*(void *)(a1 + 48) + 24) = 0;
  }
}

uint64_t C3DSubdivisionOsdGPURuntimeDataCreateWithGeometry(uint64_t a1, uint64_t a2, unsigned char *a3, SCNMTLResourceManager *a4, void *a5, uint64_t a6)
{
  v39[5] = *MEMORY[0x263EF8340];
  C3DEntityGetName(a1);
  if (!a2
    || (uint64_t RenderCallbacks = C3DEngineContextGetRenderCallbacks(a2), !*(void *)(RenderCallbacks + 24))
    || (uint64_t v9 = RenderCallbacks,
        uint64_t Hash = C3DSubdivisionOsdGPURuntimeDataGetHash((__C3DGeometry *)a1),
        (uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 24))(a2, Hash)) == 0)
    || (uint64_t v13 = C3DSubdivisionOsdGPURuntimeDataCreateWithData(v11, v12, a3, a4, a5, a6)) == 0)
  {
    if (!a5)
    {
      uint64_t v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        C3DSubdivisionOsdGPURuntimeDataCreateWithData(v14, v15, v16, v17, v18, v19, v20, v21);
      }
    }
    os_variant_has_internal_diagnostics();
    __int16 v22 = (void *)[a5 commandBuffer];
    v39[0] = MEMORY[0x263EF8330];
    v39[1] = 3221225472;
    v39[2] = ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke;
    v39[3] = &unk_264007770;
    v39[4] = a6;
    [v22 addCompletedHandler:v39];
    uint64_t v23 = (void *)[v22 computeCommandEncoder];
    v38.var0 = (id)[a5 device];
    v38.var1 = a5;
    v38.var2 = v22;
    v38.var3 = v23;
    if (C3DGeometryInitSubdivTopologyInfoIfNeeded((__C3DGeometry *)a1))
    {
      uint64_t Mesh = C3DGeometryGetMesh(a1);
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners((void *)(a1 + 136), Mesh);
      long long v32 = 0u;
      long long v31 = 0u;
      *(_OWORD *)&v30[8] = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      uint64_t v37 = 0;
      C3DSubdivInitGPUPrimvarDescriptor((uint64_t)v30, a1 + 136, Mesh);
      C3DSubdivCreateRefiner(a1 + 136);
    }
    return 0;
  }
  return v13;
}

void sub_20B38E798(_Unwind_Exception *a1)
{
  OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::~Mesh((void *)(v1 + 320));
  C3DSubdivGPUPrimvarDescriptor::~C3DSubdivGPUPrimvarDescriptor((C3DSubdivGPUPrimvarDescriptor *)(v1 + 432));
  _Unwind_Resume(a1);
}

uint64_t C3DSubdivisionOsdGPUSynchroniseCoarseMeshForDeformers(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int32 a4)
{
  uint64_t v4 = *(__n128 **)(result + 24);
  if (v4)
  {
    unsigned __int32 v5 = v4[1].n128_u32[0];
    if (!v5 || v5 != a4)
    {
      uint64_t v9 = result;
      v4[1].n128_u32[0] = a4;
      unsigned __int32 v35 = v4[1].n128_u32[3];
      if (!v4[22].n128_u64[1])
      {
        uint64_t v10 = scn_default_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          C3DSubdivisionOsdGPUSynchroniseCoarseMeshForDeformers_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
        }
      }
      unint64_t v18 = [(id)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v4[22].n128_i64[1]) threadExecutionWidth];
      uint64_t v19 = (void *)-[SCNMTLRenderContext commandQueue](a3);
      uint64_t v20 = (void *)-[SCNMTLRenderContext resourceComputeEncoder](a3);
      bzero(v20, 0x678uLL);
      uint64_t v21 = (void *)v20[207];
      [v21 setComputePipelineState:-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v4[22].n128_i64[1])];
      BOOL IsVarying = C3DGeometryOsdGetColorIsVarying(v4[1].n128_u32[2]);
      VaryingTextureCoordinatesCFIndex Count = C3DGeometryOsdGetVaryingTextureCoordinatesCount(v4[1].n128_u32[2]);
      if (IsVarying) {
        char v24 = 4;
      }
      else {
        char v24 = 0;
      }
      int v34 = ((v24 + 2 * VaryingTextureCoordinatesCount) & 0xFE) + 3;
      [v21 setBuffer:a2 offset:0 atIndex:0];
      [v21 setBuffer:v4[4].n128_u64[0] offset:0 atIndex:1];
      [v21 setBuffer:v4[22].n128_u64[0] offset:0 atIndex:2];
      [v21 setBytes:&v34 length:4 atIndex:3];
      [v21 setBytes:&v35 length:4 atIndex:4];
      if (*(unsigned char *)(v9 + 5))
      {
        uint64_t v32 = v35;
        int64x2_t v33 = vdupq_n_s64(1uLL);
        unint64_t v30 = v18;
        int64x2_t v31 = v33;
        [v21 dispatchThreads:&v32 threadsPerThreadgroup:&v30];
      }
      else
      {
        unint64_t v28 = (v18 + v35 - 1) / v18;
        int64x2_t v29 = vdupq_n_s64(1uLL);
        unint64_t v26 = v18;
        int64x2_t v27 = v29;
        [v21 dispatchThreadgroups:&v28 threadsPerThreadgroup:&v26];
      }
      v25[0] = [v19 device];
      v25[1] = v19;
      v25[2] = 0;
      v25[3] = v21;
      return __C3DSubdivisionOsdGPURefine(v4 + 9, v25);
    }
  }
  return result;
}

BOOL C3DSubdivisionOsdGPURequiresTessellationFactorsInitialization(uint64_t a1)
{
  BOOL result = 0;
  if (*(unsigned char *)(a1 + 2))
  {
    uint64_t v1 = *(void *)(a1 + 24);
    if (v1)
    {
      if (!*(_DWORD *)(v1 + 20)) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t C3DSubdivisionOsdGPUComputeTessellationFactors(uint64_t result, uint64_t a2, uint64_t a3, int a4, float a5)
{
  if (*(unsigned char *)(result + 2))
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(result + 24);
    if (v6)
    {
      int v7 = *(_DWORD *)(v6 + 20);
      if (!v7 || v7 != a4)
      {
        *(_DWORD *)(v6 + 20) = a4;
        LOBYTE(a5) = *(unsigned char *)(result + 1);
        v46[0] = (float)LODWORD(a5);
        uint64_t v10 = (void *)-[SCNMTLRenderContext resourceComputeEncoder](a2);
        bzero(v10, 0x678uLL);
        uint64_t v11 = (void *)v10[207];
        [v11 setBuffer:*(void *)(v6 + 64) offset:*(void *)(v6 + 72) atIndex:5];
        [v11 setBuffer:*(void *)(v6 + 48) offset:0 atIndex:6];
        [v11 setBuffer:*(void *)(v6 + 56) offset:0 atIndex:8];
        [v11 setBuffer:*(void *)(v6 + 264) offset:0 atIndex:11];
        [v11 setBuffer:*(void *)(v6 + 232) offset:0 atIndex:19];
        [v11 setBytes:v46 length:4 atIndex:13];
        BOOL result = [v11 setBytes:a3 length:192 atIndex:22];
        if (*(unsigned char *)(v5 + 6) == 2)
        {
          [v11 setBuffer:*(void *)(v6 + 104) offset:0 atIndex:10];
          BOOL result = [v11 setBuffer:*(void *)(v6 + 96) offset:0 atIndex:9];
        }
        if (*(void *)(v6 + 32))
        {
          uint64_t v12 = 0;
          unint64_t v13 = 0;
          int64x2_t v29 = v43;
          int64x2_t v30 = vdupq_n_s64(1uLL);
          uint64_t v31 = v5;
          do
          {
            uint64_t v14 = (unsigned int *)(*(void *)(v6 + 40) + v12);
            uint64_t v16 = *v14;
            unsigned int v15 = v14[1];
            uint64_t v18 = (int)v14[2];
            uint64_t v17 = (int)v14[3];
            int v19 = 4;
            switch((int)v16)
            {
              case 1:
                int v19 = 1;
                break;
              case 2:
                int v19 = 2;
                break;
              case 3:
                break;
              case 4:
                int v19 = 3;
                break;
              case 6:
                [v11 setBuffer:*(void *)(v6 + 248) offset:0 atIndex:7];
                int v19 = 16;
                break;
              case 7:
              case 8:
                [v11 setBuffer:*(void *)(v6 + 248) offset:0 atIndex:7];
                if ((v16 - 7) >= 2) {
                  goto LABEL_13;
                }
                break;
              case 9:
                int v19 = 20;
                break;
              default:
LABEL_13:
                int v19 = 0xFFFF;
                break;
            }
            if (v16 == 9) {
              unsigned int v20 = 4;
            }
            else {
              unsigned int v20 = v19;
            }
            int v21 = v20 >> 5;
            if (v20 >> 5 <= 1) {
              int v21 = 1;
            }
            unsigned int v32 = v21;
            objc_msgSend(v11, "setBufferOffset:atIndex:", 12 * v17, 8, v29);
            [v11 setBufferOffset:4 * v18 atIndex:6];
            [v11 setComputePipelineState:-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](*(void *)(v6 + 8 * v16 + 272))];
            switch((int)v16)
            {
              case 0:
              case 1:
              case 2:
              case 5:
                __int16 v22 = scn_default_log();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                  __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(&v44, v45);
                }
                goto LABEL_29;
              case 3:
              case 4:
                uint64_t v23 = scn_default_log();
                if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
                  __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(&v42, v29);
                }
                goto LABEL_29;
              case 6:
                int v24 = v15 * v19;
                [v11 setBufferOffset:*(unsigned __int16 *)(v6 + 240) atIndex:19];
                uint64_t v25 = *(unsigned __int16 *)(v6 + 256);
                unint64_t v26 = v11;
                uint64_t v27 = 7;
                goto LABEL_35;
              case 7:
                int v24 = 4 * v15;
                [v11 setBufferOffset:*(unsigned __int16 *)(v6 + 242) atIndex:19];
                [v11 setBufferOffset:*(unsigned __int16 *)(v6 + 258) atIndex:7];
                uint64_t v28 = *(int *)(v6 + 112);
                goto LABEL_33;
              case 8:
                int v24 = 4 * v15;
                [v11 setBufferOffset:*(unsigned __int16 *)(v6 + 244) atIndex:19];
                [v11 setBufferOffset:*(unsigned __int16 *)(v6 + 260) atIndex:7];
                uint64_t v28 = *(int *)(v6 + 116);
LABEL_33:
                uint64_t v25 = 4 * v28;
                unint64_t v26 = v11;
                uint64_t v27 = 10;
                goto LABEL_35;
              case 9:
                int v24 = 4 * v15;
                uint64_t v25 = *(unsigned __int16 *)(v6 + 246);
                unint64_t v26 = v11;
                uint64_t v27 = 19;
LABEL_35:
                [v26 setBufferOffset:v25 atIndex:v27];
                break;
              default:
LABEL_29:
                int v24 = 0;
                break;
            }
            int v41 = v24;
            [v11 setBytes:&v41 length:4 atIndex:12];
            if (*(unsigned char *)(v31 + 5))
            {
              uint64_t v39 = v15 * v20;
              int64x2_t v40 = vdupq_n_s64(1uLL);
              long long v37 = xmmword_20B5EDB30;
              uint64_t v38 = 1;
              BOOL result = [v11 dispatchThreads:&v39 threadsPerThreadgroup:&v37];
            }
            else
            {
              int64x2_t v36 = v30;
              long long v33 = xmmword_20B5EDB30;
              uint64_t v34 = 1;
              unint64_t v35 = ((unint64_t)(v15 * v20 / v32) + 31) >> 5;
              BOOL result = [v11 dispatchThreadgroups:&v35 threadsPerThreadgroup:&v33];
            }
            ++v13;
            v12 += 16;
          }
          while (v13 < *(void *)(v6 + 32));
        }
      }
    }
  }
  return result;
}

void C3DSubdivisionOsdGPUDraw(uint64_t a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  if (!v5) {
    return;
  }
  if (!__C3DSubdivisionOsdGPUHasPatchOfType(*(void *)(a1 + 24), a3))
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DSubdivisionOsdGPUDraw_cold_4(v11);
    }
  }
  int v12 = C3DPatchTypeToOsdPatchType(a3);
  unint64_t v13 = (void *)v5[11];
  if (v13) {
    unsigned int v14 = -1227133513 * ((v13[1] - *v13) >> 3);
  }
  else {
    unsigned int v14 = 0;
  }
  unsigned int v62 = v14;
  unsigned int v74 = v14;
  uint64_t v15 = -[SCNMTLRenderContext renderEncoder](a2);
  LODWORD(v16) = 1.0;
  [*(id *)(v15 + 3392) setTessellationFactorScale:v16];
  uint64_t v18 = v5[8];
  uint64_t v19 = v5[6];
  if (!v18)
  {
    unsigned int v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      C3DSubdivisionOsdGPUDraw_cold_3(v20, v21, v22, v23, v24, v25, v26, v27);
    }
  }
  unsigned int v58 = v12 - 5;
  LOBYTE(v17) = *(unsigned char *)(a1 + 1);
  float v73 = (float)v17;
  SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v18, 0, 5);
  SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v19, 0, 6);
  SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v15, &v73, 4uLL, 13);
  SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[33], 0, 11);
  SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[7], 0, 8);
  int v64 = v13;
  if (v13)
  {
    if (v62 >= 2)
    {
      SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v15, &v74, 4uLL, 14);
      SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[16], 0, 15);
      uint64_t v28 = v5 + 17;
LABEL_17:
      SCNMTLRenderCommandEncoder::setVertexBuffer(v15, *v28, 0, 16);
      goto LABEL_18;
    }
    int64x2_t v29 = (uint64_t **)v5[11];
    int64x2_t v30 = *v29;
    if (v29[1] == *v29) {
LABEL_66:
    }
      abort();
    SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v30[4], v30[5], 14);
    SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v30[2], 0, 15);
    if (v58 <= 4)
    {
      uint64_t v28 = v30 + 3;
      goto LABEL_17;
    }
  }
LABEL_18:
  if (*(unsigned char *)(a1 + 6) == 2)
  {
    SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[13], 0, 10);
    SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[12], 0, 9);
  }
  unsigned int v72 = 0;
  unint64_t v31 = v5[4];
  unsigned int v32 = v64;
  if (v31)
  {
    LODWORD(v33) = 0;
    unint64_t v34 = 0;
    unint64_t v60 = a4;
    uint64_t v63 = v12 - 6;
    unint64_t v35 = (char *)v5 + 2 * v63;
    std::string::size_type v61 = (unsigned __int16 *)(v35 + 240);
    uint64_t v59 = (unsigned __int16 *)(v35 + 256);
    do
    {
      uint64_t v36 = v5[5];
      if (*(_DWORD *)(v36 + 16 * v34) != v12) {
        goto LABEL_64;
      }
      if (v63 <= 2) {
        SCNMTLRenderCommandEncoder::setVertexBuffer(v15, v5[31], 0, 7);
      }
      uint64_t v37 = v36 + 16 * v34;
      *(void *)(v15 + 216) = 12 * *(int *)(v37 + 12);
      objc_msgSend(*(id *)(v15 + 3392), "setVertexBufferOffset:atIndex:");
      *(void *)(v15 + 184) = 4 * *(int *)(v37 + 8);
      objc_msgSend(*(id *)(v15 + 3392), "setVertexBufferOffset:atIndex:");
      if (v32)
      {
        if (v62 >= 2)
        {
          uint64_t v38 = &v72;
          uint64_t v39 = (SCNMTLRenderCommandEncoder *)v15;
          size_t v40 = 4;
LABEL_31:
          SCNMTLRenderCommandEncoder::setVertexBytes(v39, v38, v40, 17);
          goto LABEL_32;
        }
        uint64_t v41 = *(void *)v5[11];
        if (*(void *)(v5[11] + 8) == v41) {
          goto LABEL_66;
        }
        uint64_t v42 = *(void *)(v41 + 8) + 16 * v72;
        *(void *)(v15 + 328) = 4 * *(int *)(v42 + 8);
        objc_msgSend(*(id *)(v15 + 3392), "setVertexBufferOffset:atIndex:");
        if (v58 <= 4)
        {
          *(void *)(v15 + 344) = 12 * *(int *)(v42 + 12);
          objc_msgSend(*(id *)(v15 + 3392), "setVertexBufferOffset:atIndex:");
          uint64_t v39 = (SCNMTLRenderCommandEncoder *)v15;
          uint64_t v38 = (_DWORD *)v42;
          size_t v40 = 16;
          goto LABEL_31;
        }
      }
LABEL_32:
      if ((v12 - 6) < 3)
      {
        *(void *)(v15 + 200) = *v59;
        objc_msgSend(*(id *)(v15 + 3392), "setVertexBufferOffset:atIndex:");
        [*(id *)(v15 + 3392) setTessellationFactorBuffer:v5[29] offset:*v61 instanceStride:0];
LABEL_39:
        int v44 = *(_DWORD *)(v36 + 16 * v34 + 4);
        uint64_t v45 = 4;
        switch(v12)
        {
          case 3:
          case 7:
          case 8:
            goto LABEL_44;
          case 4:
            uint64_t v45 = 3;
            break;
          case 6:
            uint64_t v45 = 16;
            break;
          default:
            goto LABEL_41;
        }
        goto LABEL_44;
      }
      if (v12 != 9)
      {
        if (v12 == 5)
        {
          std::string::size_type v43 = scn_default_log();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(&v70, v71);
          }
          int v44 = *(_DWORD *)(v36 + 16 * v34 + 4);
LABEL_41:
          uint64_t v45 = -1;
          goto LABEL_44;
        }
        goto LABEL_39;
      }
      [*(id *)(v15 + 3392) setTessellationFactorBuffer:v5[29] offset:*v61 instanceStride:0];
      int v44 = *(_DWORD *)(v36 + 16 * v34 + 4);
      uint64_t v45 = 20;
LABEL_44:
      unint64_t v46 = (uint64_t *)v5[15];
      if (v46)
      {
        uint64_t v47 = *v46;
        if (0xAAAAAAAAAAAAAAABLL * ((v46[1] - *v46) >> 3) <= v60) {
          goto LABEL_66;
        }
        uint64_t v48 = *(void *)(v47 + 24 * v60);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v47 + 24 * v60 + 8) - v48) >> 3) <= v72) {
          goto LABEL_66;
        }
        std::vector<CFRange>::vector(&v67, v48 + 24 * v72);
      }
      else
      {
        uint64_t v49 = v44;
        uint64_t v50 = (uint64_t *)operator new(0x10uLL);
        unint64_t v68 = v50 + 2;
        std::string::size_type v69 = v50 + 2;
        uint64_t *v50 = 0;
        v50[1] = v49;
        unint64_t v67 = v50;
      }
      switch(v12)
      {
        case 0:
        case 1:
        case 2:
        case 5:
          uint64_t v51 = scn_default_log();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            __C3DSubdivisionOsdGPURuntimeDataInitializePerPatchComputePipelines(&v65, v66);
          }
          break;
        case 3:
          uint64_t v53 = v67;
          long long v56 = v68;
          if (v67 == v68) {
            goto LABEL_61;
          }
          do
          {
            SCNMTLRenderCommandEncoder::drawPrimitives((SCNMTLRenderCommandEncoder *)v15, MTLPrimitiveTypeTriangle, 6 * *v53, 6 * v53[1], a5, 0);
            v53 += 2;
          }
          while (v53 != v56);
          break;
        case 4:
          uint64_t v53 = v67;
          std::string::size_type v57 = v68;
          if (v67 == v68) {
            goto LABEL_61;
          }
          do
          {
            SCNMTLRenderCommandEncoder::drawPrimitives((SCNMTLRenderCommandEncoder *)v15, MTLPrimitiveTypeTriangle, 3 * *v53, 3 * v53[1], a5, 0);
            v53 += 2;
          }
          while (v53 != v57);
          break;
        case 6:
        case 7:
        case 8:
        case 9:
          uint64_t v53 = v67;
          std::string::size_type v52 = v68;
          if (v67 == v68) {
            goto LABEL_61;
          }
          do
          {
            uint64_t v55 = *v53;
            uint64_t v54 = v53[1];
            SCNMTLRenderCommandEncoder::_bindPendingTextures((SCNMTLRenderCommandEncoder *)v15);
            SCNMTLRenderCommandEncoder::applyChangedStates((SCNMTLRenderCommandEncoder *)v15);
            [*(id *)(v15 + 3392) drawPatches:v45 patchStart:v55 patchCount:v54 patchIndexBuffer:0 patchIndexBufferOffset:0 instanceCount:*(unsigned int *)(v15 + 64) * (unint64_t)a5 baseInstance:0];
            v53 += 2;
          }
          while (v53 != v52);
          break;
        default:
          break;
      }
      uint64_t v53 = v67;
LABEL_61:
      unsigned int v32 = v64;
      if (v53)
      {
        unint64_t v68 = v53;
        operator delete(v53);
      }
      LODWORD(v33) = v72;
      unint64_t v31 = v5[4];
LABEL_64:
      unint64_t v33 = (v33 + 1);
      unsigned int v72 = v33;
      unint64_t v34 = v33;
    }
    while (v31 > v33);
  }
}

void sub_20B38F614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DOpenSubdivMetalVersion(void)
{
  return 65537;
}

uint64_t C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData(__C3DGeometry *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *((void *)a1->var10.var6 + 3);
  uint64_t EdgeCreasesSource = C3DGeometryOsdGetEdgeCreasesSource((uint64_t)a1);
  uint64_t result = C3DGeometryOsdGetEdgeCreasesElement((uint64_t)a1);
  if (!EdgeCreasesSource || !result) {
    return result;
  }
  uint64_t result = -[SCNMTLMesh bufferForAttribute:](a2, 0);
  uint64_t v11 = (MTLBuffer *)result;
  if (*(void *)(v8 + 392))
  {
    if (!a4) {
      return result;
    }
  }
  else
  {
    unint64_t v33 = (MTLBuffer *)result;
    uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a1);
    uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 0, 0);
    *(void *)(v8 + 368) = 0;
    ElementsCFIndex Count = C3DMeshGetElementsCount(Mesh);
    if ((uint64_t)ElementsCount >= 1)
    {
      CFArrayRef v15 = ElementsCount;
      for (CFIndex i = 0; (const __CFArray *)i != v15; ++i)
      {
        ElementAtIndex = C3DMeshGetElementAtIndex(Mesh, i, 0);
        uint64_t v43 = 0;
        long long v41 = 0u;
        __n128 v42 = 0u;
        long long v40 = 0u;
        C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v40);
        v38[0] = v40;
        v38[1] = v41;
        v38[2] = v42;
        uint64_t v39 = v43;
        v37[0] = MEMORY[0x263EF8330];
        v37[1] = 3221225472;
        v37[2] = __C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData_block_invoke;
        v37[3] = &__block_descriptor_40_e19_v32__0I8_I12I20_B24l;
        v37[4] = v8;
        C3DIndicesContentEnumeratePrimitives((uint64_t *)v38, (uint64_t)v37, v42);
      }
    }
    size_t v18 = *(void *)(v8 + 368) << 6;
    uint64_t v19 = malloc_type_malloc(v18, 0xA3857EEEuLL);
    if (C3DGeometryGetEffectiveDataKindForRendering(a1)) {
      C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData_cold_1();
    }
    size_t v20 = 8 * *(void *)(v8 + 368);
    uint64_t v21 = malloc_type_malloc(v20, 0x87ADD5F7uLL);
    *(void *)&long long v40 = 0;
    *((void *)&v40 + 1) = &v40;
    *(void *)&long long v41 = 0x2020000000;
    DWORD2(v41) = 0;
    v36[0] = MEMORY[0x263EF8330];
    v36[1] = 3221225472;
    v36[2] = __C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData_block_invoke_2;
    v36[3] = &unk_264007720;
    v36[4] = &v40;
    v36[5] = v19;
    v36[6] = v21;
    C3DGeometryOpenSubdivAuthoringEnvironmentEnumerateCreases((uint64_t)a1, (uint64_t)v36);
    uint64_t v11 = v33;
    if (*(void *)(v8 + 368) != *(_DWORD *)(*((void *)&v40 + 1) + 24)) {
      __assert_rtn("C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData", "C3DGeometryOpenSubdivSupport_Metal.mm", 3640, "currentEdgeIndex == osdRuntimeData->authoringData.creaseData.edgeCount");
    }
    uint64_t v22 = (void *)[(MTLBuffer *)v33 device];
    *(void *)(v8 + 376) = [v22 newBufferWithBytes:v19 length:v18 options:0];
    *(void *)(v8 + 384) = [v22 newBufferWithBytes:v21 length:v20 options:0];
    free(v19);
    free(v21);
    id v23 = objc_alloc_init(MEMORY[0x263F12A80]);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 0), "setFormat:", 30);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 0), "setOffset:", 0);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 0), "setBufferIndex:", 18);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 3), "setFormat:", 31);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 3), "setOffset:", 16);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "attributes"), "objectAtIndexedSubscript:", 3), "setBufferIndex:", 19);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "layouts"), "objectAtIndexedSubscript:", 18), "setStride:", 32);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "layouts"), "objectAtIndexedSubscript:", 18), "setStepFunction:", 1);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "layouts"), "objectAtIndexedSubscript:", 19), "setStride:", 32);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v23, "layouts"), "objectAtIndexedSubscript:", 19), "setStepFunction:", 1);
    *(void *)(v8 + 392) = v23;
    _Block_object_dispose(&v40, 8);
  }
  if (!*(void *)(v8 + 400)) {
    *(void *)(v8 + 400) = (id)[(id)-[SCNMTLRenderContext resourceManager](a3) computePipelineStateForKernel:@"scn_osd_synchronize_coarse_positions_authoring"];
  }
  uint64_t v24 = objc_msgSend((id)objc_msgSend((id)-[SCNMTLResourceManager commandQueue](a2), "attributes"), "objectAtIndexedSubscript:", 0);
  uint64_t v25 = objc_msgSend((id)objc_msgSend(*(id *)(v8 + 392), "attributes"), "objectAtIndexedSubscript:", 0);
  unsigned int v26 = [v24 offset];
  LODWORD(v40) = (unint64_t)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)-[SCNMTLResourceManager commandQueue](a2), "layouts"), "objectAtIndexedSubscript:", objc_msgSend(v24, "bufferIndex")), "stride") >> 2;
  unsigned int v27 = [v25 offset];
  unsigned int v34 = 2 * *(_DWORD *)(v8 + 368);
  int v35 = 8;
  uint64_t v28 = (SCNMTLComputeCommandEncoder *)-[SCNMTLRenderContext resourceComputeEncoder](a3);
  bzero(v28, 0x678uLL);
  if (v11)
  {
    v28->_buffers[0] = v11;
  }
  else if (!v26)
  {
    goto LABEL_18;
  }
  v28->_offsets[0] = v26;
  v28->_buffersToBind[0] |= 1uLL;
LABEL_18:
  int64x2_t v29 = *(MTLBuffer **)(v8 + 376);
  if (v29)
  {
    v28->_buffers[1] = v29;
LABEL_21:
    v28->_offsets[1] = v27;
    v28->_buffersToBind[0] |= 2uLL;
    goto LABEL_22;
  }
  if (v27) {
    goto LABEL_21;
  }
LABEL_22:
  int64x2_t v30 = *(MTLBuffer **)(v8 + 384);
  if (v30)
  {
    v28->_buffers[2] = v30;
    v28->_offsets[2] = 0;
    v28->_buffersToBind[0] |= 4uLL;
  }
  SCNMTLComputeCommandEncoder::setBytes(v28, &v40, 4uLL, 3uLL);
  SCNMTLComputeCommandEncoder::setBytes(v28, &v35, 4uLL, 4uLL);
  SCNMTLComputeCommandEncoder::setBytes(v28, &v34, 4uLL, 5uLL);
  uint64_t v31 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](*(void *)(v8 + 400));
  uint64_t v32 = v34;
  if (v28->_computePipelineState != (MTLComputePipelineState *)v31)
  {
    v28->_computePipelineState = (MTLComputePipelineState *)v31;
    [(MTLComputeCommandEncoder *)v28->_encoder setComputePipelineState:v31];
  }
  return SCNMTLComputeCommandEncoder::dispatchOnGrid1D(v28, v32);
}

void sub_20B38FBF8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t __C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  *(void *)(*(void *)(result + 32) + 368) += a4;
  return result;
}

unint64_t __C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData_block_invoke_2(void *a1, int a2, int a3, float a4)
{
  unint64_t result = C3DGeometryOpenSubdivAuthoringEnvironmentColorForSharpness(a4);
  uint64_t v8 = a1[5] + 32 * (2 * *(_DWORD *)(*(void *)(a1[4] + 8) + 24));
  *(void *)(v8 + 16) = result;
  *(void *)(v8 + 24) = v9;
  uint64_t v10 = a1[5] + 32 * ((2 * *(_DWORD *)(*(void *)(a1[4] + 8) + 24)) | 1u);
  *(void *)(v10 + 16) = result;
  *(void *)(v10 + 24) = v9;
  uint64_t v11 = a1[6];
  *(_DWORD *)(v11 + 4 * (2 * *(_DWORD *)(*(void *)(a1[4] + 8) + 24))) = a2;
  *(_DWORD *)(v11 + 4 * ((2 * (*(_DWORD *)(*(void *)(a1[4] + 8) + 24))++) | 1u)) = a3;
  return result;
}

void C3DGeometryOpenSubdivGPUDrawAuthoringEnvironment(uint64_t a1, uint64_t a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  v11[2] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(*(void *)(a2 + 168) + 24);
  int v7 = *(void **)(v6 + 392);
  if (v7)
  {
    uint64_t v9 = v6 + 368;
    uint64_t v8 = *(void *)(v6 + 368);
    v11[0] = *(void *)(v9 + 8);
    v11[1] = v11[0];
    long long v10 = 0u;
    C3DAuthoringEnvironmentDrawPrimitives(a1, MTLPrimitiveTypeLine, 2 * v8, (uint64_t)v11, (uint64_t)&v10, 18, 2uLL, v7, a3, a4, a5, a6, (__n128)0, 0);
  }
}

__CFString *C3DGetPatchTypeDescription(int a1)
{
  int v1 = a1 - 3;
  if ((a1 - 3) >= 7 || ((0x7Bu >> v1) & 1) == 0) {
    C3DGetPatchTypeDescription();
  }
  return off_264007828[v1];
}

void ___ZL54_C3DSubdivisionOsdGPURuntimeDataCFCopyDebugDescriptionPKv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)a2 length];
  uint64_t v5 = [*(id *)(a2 + 8) length];
  uint64_t v6 = [*(id *)(a2 + 16) length];
  uint64_t v7 = [*(id *)(a2 + 24) length];
  uint64_t v8 = *(__CFString **)(a1 + 40);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5 + v4 + v6 + v7;
  CFStringAppendFormat(v8, 0, @"\n  - Vertex stencil table (%d stencils)", *(unsigned int *)(a2 + 32));
  uint64_t v9 = *(__CFString **)(a1 + 40);
  id v10 = *(id *)a2;
  uint64_t v11 = C3DGetByteCountDescriptionFromSize(v4);
  CFStringAppendFormat(v9, 0, @"\n    - Sizes buffer: %p (%@)", v10, v11);
  int v12 = *(__CFString **)(a1 + 40);
  uint64_t v13 = *(void *)(a2 + 8);
  uint64_t v14 = C3DGetByteCountDescriptionFromSize(v5);
  CFStringAppendFormat(v12, 0, @"\n    - Offsets buffer: %p (%@)", v13, v14);
  CFArrayRef v15 = *(__CFString **)(a1 + 40);
  uint64_t v16 = *(void *)(a2 + 16);
  uint64_t v17 = C3DGetByteCountDescriptionFromSize(v6);
  CFStringAppendFormat(v15, 0, @"\n    - Indices buffer: %p (%@)", v16, v17);
  size_t v18 = *(__CFString **)(a1 + 40);
  uint64_t v19 = *(void *)(a2 + 24);
  uint64_t v20 = C3DGetByteCountDescriptionFromSize(v7);
  CFStringAppendFormat(v18, 0, @"\n    - Weights buffer: %p (%@)", v19, v20);
  uint64_t v21 = [*(id *)(a2 + 40) length];
  uint64_t v22 = [*(id *)(a2 + 40) length];
  id v23 = *(__CFString **)(a1 + 40);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v22 + v21;
  CFStringAppend(v23, @"\n  - Vertex evalutor input");
  uint64_t v24 = *(__CFString **)(a1 + 40);
  uint64_t v25 = *(void *)(a2 + 40);
  uint64_t v26 = *(unsigned int *)(a2 + 56);
  uint64_t v27 = *(unsigned int *)(a2 + 60);
  uint64_t v28 = *(unsigned int *)(a2 + 64);
  uint64_t v29 = C3DGetByteCountDescriptionFromSize(v21);
  CFStringAppendFormat(v24, 0, @"\n    - Src buffer: [offset:%d length:%d stride:%d] %p (%@)", v26, v27, v28, v25, v29);
  int64x2_t v30 = *(__CFString **)(a1 + 40);
  uint64_t v31 = *(void *)(a2 + 48);
  uint64_t v32 = *(unsigned int *)(a2 + 68);
  uint64_t v33 = *(unsigned int *)(a2 + 72);
  uint64_t v34 = *(unsigned int *)(a2 + 76);
  uint64_t v35 = C3DGetByteCountDescriptionFromSize(v22);
  CFStringAppendFormat(v30, 0, @"\n    - Dst buffer: [offset:%d length:%d stride:%d] %p (%@)", v32, v33, v34, v31, v35);
}

void std::vector<CFRange>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    uint64_t v9 = &v6[16 * v8];
    uint64_t v11 = (char *)*a1;
    id v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      id v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::vector<std::vector<CFRange>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<CFRange>>::__vallocate[abi:nn180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

char *std::vector<std::vector<CFRange>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  unint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::vector<std::vector<std::vector<CFRange>>>::vector(void *a1, unint64_t a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<CFRange>>::__vallocate[abi:nn180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    uint64_t v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      *uint64_t v6 = 0;
      v6[1] = 0;
      _OWORD v6[2] = 0;
      std::vector<std::vector<CFRange>>::__init_with_size[abi:nn180100]<std::vector<CFRange>*,std::vector<CFRange>*>(v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_20B3901B0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<CFRange>>::__init_with_size[abi:nn180100]<std::vector<CFRange>*,std::vector<CFRange>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<CFRange>>::__vallocate[abi:nn180100](result, a4);
    return std::vector<std::vector<CFRange>>::__construct_at_end<std::vector<CFRange>*,std::vector<CFRange>*>(v6, a2, a3);
  }
  return result;
}

void *std::vector<std::vector<CFRange>>::__construct_at_end<std::vector<CFRange>*,std::vector<CFRange>*>(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      unint64_t result = std::vector<CFRange>::vector((void *)(v4 + v7), a2 + v7);
      v7 += 24;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_20B390288(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<CFRange>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<CFRange>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<CFRange>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      size_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void *std::vector<C3DSubdivisionOsdGPURefiner>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<C3DSubdivisionOsdGPURefiner>::__vallocate[abi:nn180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 88 * ((88 * a2 - 88) / 0x58) + 88;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

char *std::vector<C3DSubdivisionOsdGPURefiner>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    abort();
  }
  unint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<C3DSubdivisionOsdGPURefiner>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[88 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<C3DSubdivisionOsdGPURefiner>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(88 * a2);
}

unint64_t C3DPatchTypeFromOsdPatchType(int a1)
{
  char v1 = a1 - 3;
  if ((a1 - 3) >= 7 || ((0x7Bu >> v1) & 1) == 0) {
    C3DPatchTypeFromOsdPatchType();
  }
  return (0x6050403010201uLL >> (8 * v1)) & 7;
}

id ___ZL42__C3DSubdivisionGetOpenSubdivComputeSourceP21SCNMTLResourceManager_block_invoke()
{
  __C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::kC3DOpenSubdivComputeSource = (uint64_t)C3DGetTextResourceWithNameAllowingHotReload(@"C3D-OpenSubdiv_compute.metal");
  v0 = (void *)[(id)__C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::kC3DOpenSubdivComputeSource stringByReplacingOccurrencesOfString:@"#import \"scn_metal\"" withString:C3DGetTextResourceWithNameAllowingHotReload(@"scn_metal")];
  __C3DSubdivisionGetOpenSubdivComputeSource(SCNMTLResourceManager *)::kC3DOpenSubdivComputeSource = (uint64_t)v0;

  return v0;
}

void __C3DSubdivisionOsdGPURefinerDestroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
}

void __C3DSubdivisionOsdGPUPatchTableDestroy(uint64_t a1)
{
  free(*(void **)(a1 + 8));

  uint64_t v2 = *(void **)(a1 + 32);
}

void std::vector<std::vector<std::vector<CFRange>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  char v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    size_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<std::vector<CFRange>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      size_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZL48C3DSubdivisionOsdGPUGetPerPatchTypeSources_Quadsv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(3);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_Quads(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B3906B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL52C3DSubdivisionOsdGPUGetPerPatchTypeSources_Trianglesv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(4);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_Triangles(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B39074C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL50C3DSubdivisionOsdGPUGetPerPatchTypeSources_Regularv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(6);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_Regular(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B3907E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL50C3DSubdivisionOsdGPUGetPerPatchTypeSources_Gregoryv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(7);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_Gregory(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B390874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL58C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBoundaryv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(8);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBoundary(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B390908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL55C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBasisv_block_invoke()
{
  id v0 = [NSString alloc];
  OpenSubdiv::v3_1_1::Osd::MTLPatchShaderSource::GetHullShaderSource(9);
  if (v3 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  C3DSubdivisionOsdGPUGetPerPatchTypeSources_GregoryBasis(void)::kSources = [v0 initWithCString:p_p encoding:4];
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_20B39099C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DSubdivisionOsdGPURuntimeDataGetHash(__C3DGeometry *a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  CC_SHA256_Init(&c);
  uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a1);
  uint64_t v3 = Mesh;
  if (Mesh)
  {
    ElementsCFIndex Count = C3DMeshGetElementsCount(Mesh);
    if ((uint64_t)ElementsCount >= 1)
    {
      CFArrayRef v5 = ElementsCount;
      for (CFIndex i = 0; (const __CFArray *)i != v5; ++i)
      {
        ElementAtIndex = C3DMeshGetElementAtIndex(v3, i, 0);
        char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
        if (C3DMeshElementTypeDefinesSurface(Type))
        {
          v26[0] = 0;
          CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, v26);
          if (Indexes)
          {
            CFDataRef v10 = Indexes;
            BytePtr = CFDataGetBytePtr(Indexes);
            CC_LONG Length = CFDataGetLength(v10);
            CC_SHA256_Update(&c, BytePtr, Length);
          }
          v24[0] = MEMORY[0x263EF8330];
          v24[1] = 3221225472;
          v24[2] = ___ZL38C3DSubdivisionOsdGPURuntimeDataGetHashP13__C3DGeometry_block_invoke;
          v24[3] = &__block_descriptor_40_e13_v24__0___qq_8l;
          v24[4] = &c;
          C3DMeshElementEnumeratePrimitiveRanges((uint64_t)ElementAtIndex, (uint64_t)v24);
        }
      }
    }
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = ___ZL38C3DSubdivisionOsdGPURuntimeDataGetHashP13__C3DGeometry_block_invoke_2;
  void v23[3] = &__block_descriptor_40_e201_v32__0____C3DMeshSource____C3DGenericSource____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DSourceAccessor________CFData__v_v_qb1b1b1_SCC_8c16q20C28l;
  v23[4] = &c;
  C3DMeshApplySources(v3, 0, (uint64_t)v23);
  CC_SHA256_Final(md, &c);
  uint64_t v13 = 0;
  uint64_t v14 = (char *)v26;
  v15.i64[0] = 0xA0A0A0A0A0A0A0A0;
  v15.i64[1] = 0xA0A0A0A0A0A0A0A0;
  v16.i64[0] = 0x3737373737373737;
  v16.i64[1] = 0x3737373737373737;
  v17.i64[0] = 0x3030303030303030;
  v17.i64[1] = 0x3030303030303030;
  v18.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v18.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  v19.i64[0] = 0xA0A0A0A0A0A0A0ALL;
  v19.i64[1] = 0xA0A0A0A0A0A0A0ALL;
  do
  {
    int8x16_t v20 = *(int8x16_t *)&md[v13];
    v30.val[0] = (int8x16_t)vsraq_n_u8((uint8x16_t)vbslq_s8((int8x16_t)vcgtq_u8(v15, (uint8x16_t)v20), v17, v16), (uint8x16_t)v20, 4uLL);
    int8x16_t v21 = vandq_s8(v20, v18);
    v30.val[1] = vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v19, (uint8x16_t)v21), v17, v16), v21);
    vst2q_s8(v14, v30);
    v14 += 32;
    v13 += 16;
  }
  while (v13 != 32);
  char v27 = 0;
  return [NSString stringWithFormat:@"%@-%s", C3DGeometryGetName((uint64_t)a1), v26];
}

uint64_t ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = [a2 status];
  if (result != 4)
  {
    CFArrayRef v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke_cold_1(a2);
    }
    uint64_t result = *(void *)(a1 + 32);
    if (result) {
      return (*(uint64_t (**)(uint64_t, void *, void))(result + 16))(result, a2, 0);
    }
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetFarPatchTable(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v9 = &v6[4 * v8];
    CFDataRef v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    int v12 = v7;
    if (v11 != *a1)
    {
      int v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::UpdateVertexBuffer(uint64_t a1, const float *a2, uint64_t a3, uint64_t a4)
{
  return OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::UpdateData(*(OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer **)(a1 + 32), a2, a3, a4, *(MTLContext **)(a1 + 104));
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetTopologyRefiner(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::BindVertexBuffer(uint64_t a1)
{
  return C3DRendererElementGetNode(*(void *)(a1 + 32));
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetVertexBuffer(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetPatchTable(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetMaxValence(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

CFTypeRef ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke_527(void *a1)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = (void *)a1[9];
  unint64_t v67 = (void *)[objc_alloc(MEMORY[0x263F08910]) initRequiringSecureCoding:0];
  if (!v2)
  {
    int64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DSubdivisionOsdGPURuntimeDataCreateWithData(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  unsigned int v62 = v4;
  uint64_t v69 = 0;
  char v70 = &v69;
  uint64_t v71 = 0x5012000000;
  unsigned int v72 = __Block_byref_object_copy__5;
  float v73 = __Block_byref_object_dispose__5;
  unsigned int v74 = "c";
  long long v75 = 0u;
  long long v76 = 0u;
  v68[0] = MEMORY[0x263EF8330];
  v68[1] = 3221225472;
  v68[2] = ___ZL51__C3DSubdivisionOsdGPURuntimeDataCreateArchivedDataP33__C3DSubdivisionOsdGPURuntimeDataPK39C3DSubdivisionOsdGPUSetupAdditionalDataPU26objcproto15MTLCommandQueue11objc_objectPU27objcproto16MTLCommandBuffer11objc_object_block_invoke;
  v68[3] = &unk_2640077E0;
  v68[4] = v2;
  v68[5] = &v69;
  [v67 encodeInt32:2 forKey:@"version"];
  [v67 encodeInt32:*(unsigned int *)(v3 + 28) forKey:@"coarseVertexCount"];
  __C3DSubdivisionOsdGPURuntimeDataEncodePatchTable(v67, @"vertexPatchTable", v3 + 32, (uint64_t)v68);
  uint64_t v63 = v3;
  int v13 = *(void **)(v3 + 88);
  if (v13)
  {
    uint64_t v14 = (uint64_t)(v13[1] - *v13) >> 3;
    uint64_t v15 = 0x6DB6DB6DB6DB6DB7 * v14;
    if (-1227133513 * v14)
    {
      [v67 encodeInt32:v15, objc_msgSend(@"fvarPatchTables", "stringByAppendingString:", @".count" forKey];
      uint64_t v16 = 0;
      unint64_t v17 = 0;
      while (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v13[1] - *v13) >> 3) > v17)
      {
        __C3DSubdivisionOsdGPURuntimeDataEncodePatchTable(v67, objc_msgSend(@"fvarPatchTables", "stringByAppendingFormat:", @".[%d]", v17++), *v13 + v16, (uint64_t)v68);
        v16 += 56;
        if (v15 == v17) {
          goto LABEL_9;
        }
      }
LABEL_47:
      abort();
    }
  }
LABEL_9:
  if (*(void *)(v63 + 96) && *(void *)(v63 + 104))
  {
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v67, [@"legacyGregoryPatchTable" stringByAppendingString:@".vertexValenceBuffer"], *(void **)(v63 + 96), (uint64_t)v68, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v67, [@"legacyGregoryPatchTable" stringByAppendingString:@".quadOffsetsBuffer"], *(void **)(v63 + 104), (uint64_t)v68, 0);
    [v67 encodeInt32:*(unsigned int *)(v63 + 112), objc_msgSend(@"legacyGregoryPatchTable", "stringByAppendingString:", @".quadOffsetsBaseGregory" forKey];
    [v67 encodeInt32:*(unsigned int *)(v63 + 116), objc_msgSend(@"legacyGregoryPatchTable", "stringByAppendingString:", @".quadOffsetsBaseGregoryBoundary" forKey];
  }
  int8x16_t v18 = *(uint64_t ***)(v63 + 120);
  if (v18)
  {
    int8x16_t v20 = *v18;
    uint8x16_t v19 = v18[1];
    uint64_t v22 = **v18;
    uint64_t v21 = (*v18)[1];
    [@"patchRangesTable" stringByAppendingString:@".elementCount"];
    unsigned int v65 = -1431655765 * ((unint64_t)((char *)v19 - (char *)v20) >> 3);
    objc_msgSend(v67, "encodeInt32:forKey:");
    [@"patchRangesTable" stringByAppendingString:@".patchArrayCount"];
    unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v22) >> 3);
    objc_msgSend(v67, "encodeInt32:forKey:");
    if (v65)
    {
      uint64_t v23 = 0;
      unsigned __int8 v66 = 0;
      while (!v64)
      {
LABEL_20:
        uint64_t v23 = ++v66;
        if (v66 >= v65) {
          goto LABEL_21;
        }
      }
      uint64_t v24 = 0;
      unint64_t v25 = 0;
      while (0xAAAAAAAAAAAAAAABLL * (v18[1] - *v18) > v66)
      {
        char v27 = &(*v18)[3 * v66];
        uint64_t v26 = *v27;
        if (0xAAAAAAAAAAAAAAABLL * ((v27[1] - *v27) >> 3) <= v25) {
          break;
        }
        [v67 encodeBytes:*(void *)(v26 + v24), *(void *)(v26 + v24 + 8) - *(void *)(v26 + v24), objc_msgSend(@"patchRangesTable", "stringByAppendingFormat:", @".[%d][%d]", v23, v25++) length forKey];
        v24 += 24;
        if (v64 == v25) {
          goto LABEL_20;
        }
      }
      goto LABEL_47;
    }
  }
LABEL_21:
  __C3DSubdivisionOsdGPURuntimeDataEncodeRefiner((uint64_t)v67, @"vertexRefiner", v63 + 144, (uint64_t)v68);
  uint64_t v28 = (void *)a1[6];
  if (v28)
  {
    uint64_t v29 = (uint64_t)(v28[1] - *v28) >> 3;
    uint64_t v30 = 0x2E8BA2E8BA2E8BA3 * v29;
    if (-1171354717 * v29)
    {
      [v67 encodeInt32:v30, objc_msgSend(@"fvarRefiners", "stringByAppendingString:", @".count" forKey];
      uint64_t v31 = 0;
      unint64_t v32 = 0;
      while (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v28[1] - *v28) >> 3) > v32)
      {
        __C3DSubdivisionOsdGPURuntimeDataEncodeRefiner((uint64_t)v67, objc_msgSend(@"fvarRefiners", "stringByAppendingFormat:", @".[%d]", v32++), *v28 + v31, (uint64_t)v68);
        v31 += 88;
        if (v30 == v32) {
          goto LABEL_26;
        }
      }
      goto LABEL_47;
    }
  }
LABEL_26:
  __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v67, @"skinMorphSubdivIndexToMetalIndexBuffer", *(void **)(v63 + 352), (uint64_t)v68, 0);
  uint64_t v33 = *(void *)(v63 + 360);
  if (v33) {
    objc_msgSend(v67, "encodeObject:forKey:", objc_msgSend((id)-[SCNMTLResourceManager commandQueue](v33), "name"), @"synchronizeCoarsePositionsPipeline.functionName");
  }
  __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v67, @"fvarChannelDescriptorsBuffer", *(void **)(v63 + 128), (uint64_t)v68, 0);
  __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v67, @"fvarChannelsPackedDataBuffer", *(void **)(v63 + 136), (uint64_t)v68, 0);
  if (!v70[6]) {
    goto LABEL_37;
  }
  if (!v70[9])
  {
    uint64_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke_527_cold_2(v34, v35, v36, v37, v38, v39, v40, v41);
    }
  }
  if (!v70[8])
  {
    __n128 v42 = scn_default_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      ___ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke_527_cold_1(v42, v43, v44, v45, v46, v47, v48, v49);
    }
  }
  [(id)v70[9] endEncoding];
  [(id)v70[8] commit];
  [(id)v70[8] waitUntilCompleted];
  if ([v62 status] != 4)
  {
    uint64_t v51 = scn_default_log();
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    int v52 = [v62 status];
    uint64_t v53 = [v62 error];
    uint64_t v54 = [v62 logs];
    *(_DWORD *)uint8_t buf = 67109634;
    int v78 = v52;
    __int16 v79 = 2112;
    uint64_t v80 = v53;
    __int16 v81 = 2112;
    uint64_t v82 = v54;
    uint64_t v55 = "Error: OpenSubdiv archiver dependency command buffer execution failed with status %d, error: %@\n%@";
    long long v56 = v51;
LABEL_46:
    _os_log_error_impl(&dword_20B249000, v56, OS_LOG_TYPE_ERROR, v55, buf, 0x1Cu);
    goto LABEL_41;
  }
  if ([(id)v70[8] status] == 4)
  {
LABEL_37:
    id v50 = (id)[v67 encodedData];
    goto LABEL_42;
  }
  std::string::size_type v57 = scn_default_log();
  if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
  {
    int v59 = [(id)v70[8] status];
    uint64_t v60 = [(id)v70[8] error];
    uint64_t v61 = [(id)v70[8] logs];
    *(_DWORD *)uint8_t buf = 67109634;
    int v78 = v59;
    __int16 v79 = 2112;
    uint64_t v80 = v60;
    __int16 v81 = 2112;
    uint64_t v82 = v61;
    uint64_t v55 = "Error: OpenSubdiv archiver command buffer execution failed with status %d, error: %@\n%@";
    long long v56 = v57;
    goto LABEL_46;
  }
LABEL_41:
  id v50 = 0;
LABEL_42:

  _Block_object_dispose(&v69, 8);
  if (v50) {
    return CFAutorelease(v50);
  }
  else {
    return 0;
  }
}

void sub_20B39152C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void C3DSubdivGPUPrimvarDescriptor::~C3DSubdivGPUPrimvarDescriptor(C3DSubdivGPUPrimvarDescriptor *this)
{
  uint64_t v6 = (void **)((char *)this + 112);
  std::vector<C3DSubdivGPUFVarPrimvarData>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    *((void *)this + 12) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    *((void *)this + 9) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
  int64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
}

uint64_t ___ZL38C3DSubdivisionOsdGPURuntimeDataGetHashP13__C3DGeometry_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return CC_SHA256_Update(*(CC_SHA256_CTX **)(a1 + 32), v4, 0x10u);
}

CFDataRef ___ZL38C3DSubdivisionOsdGPURuntimeDataGetHashP13__C3DGeometry_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  CFDataRef result = (const __CFData *)C3DSubdivSourceSemanticCanBePrimvar(a3, a4, 0);
  if (result)
  {
    CFDataRef result = (const __CFData *)C3DMeshSourceGetData(a2);
    if (result)
    {
      CFDataRef v7 = result;
      BytePtr = CFDataGetBytePtr(result);
      CC_LONG Length = CFDataGetLength(v7);
      uint64_t v10 = *(CC_SHA256_CTX **)(a1 + 32);
      return (const __CFData *)CC_SHA256_Update(v10, BytePtr, Length);
    }
  }
  return result;
}

void OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::Mesh(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = &unk_26BF6C5E0;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = a7;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = a8;
  if (a2)
  {
    char v9 = a5;
    int v10 = a4;
    int v11 = a3;
    if (a6) {
      OpenSubdiv::v3_1_1::Far::TopologyRefiner::RefineAdaptive((unsigned int *)a2, (16 * a6) & 0x300 | a5 & 0xF | (((a6 >> 3) & 1) << 10) | 0xF0, a3, a4, a5, a6, a7, a8, v13);
    }
    else {
      OpenSubdiv::v3_1_1::Far::TopologyRefiner::RefineUniform((unsigned int *)a2, a5 & 0xF | (32* ((int)((*(void *)(**(void **)(a2 + 40) + 464) - *(void *)(**(void **)(a2 + 40) + 456)) >> 3) > 0)), a3, a4, a5, a6, a7, a8, v13);
    }
    OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::initializeContext(a1, v11, v10, v9, a6);
  }
  OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::Mesh();
}

void OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::initializeContext(uint64_t a1, int a2, int a3, char a4, unint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint64_t v7 = ~(16 * *(unsigned __int8 *)(v6 + 8)) & 0x10;
    if (a2 >= 1) {
      OpenSubdiv::v3_1_1::Far::StencilTableFactory::Create(v6, v7 | 0x2A4);
    }
    if (a3 >= 1) {
      OpenSubdiv::v3_1_1::Far::StencilTableFactory::Create(*(void *)(a1 + 8), v7 | 0x2A5);
    }
    uint64_t v8 = -4294956288;
    uint64_t v9 = -4294956032;
    if ((a5 & 0x100) == 0) {
      uint64_t v9 = -4294956288;
    }
    if ((a5 & 0x80) == 0) {
      uint64_t v8 = v9;
    }
    if ((a5 & 0x40) != 0) {
      uint64_t v8 = -4294956544;
    }
    OpenSubdiv::v3_1_1::Far::PatchTableFactory::Create(*(void *)(a1 + 8), ((a5 << 10) & 0x3000 | (16 * (a4 & 0xF)) | (a5 >> 2) & 0xC) ^ v8, 0);
  }
  OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::initializeContext();
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::initializeVertexBuffers(uint64_t result, int a2, OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer *this, MTLContext *a4)
{
  if (this) {
    OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::Create(this, a2, *(void *)(result + 104), a4);
  }
  if (a4) {
    OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::Create((OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer *)a4, a2, *(void *)(result + 104), a4);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::~Mesh(void *a1)
{
  OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::~Mesh(a1);

  JUMPOUT(0x210534FE0);
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetNumVertices(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

void *OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::UpdateVaryingBuffer(uint64_t a1, const float *a2, uint64_t a3, uint64_t a4)
{
  return OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::UpdateData(*(OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer **)(a1 + 40), a2, a3, a4, *(MTLContext **)(a1 + 104));
}

BOOL OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::Refine(uint64_t a1)
{
  int v2 = *(_DWORD *)(**(void **)(*(void *)(a1 + 8) + 88) + 8);
  uint64_t v11 = *(void *)(a1 + 48);
  int v12 = *(_DWORD *)(a1 + 56);
  BufferDescriptor v10 = *(BufferDescriptor *)(a1 + 48);
  v10.var0 += v10.var2 * v2;
  uint64_t v3 = OpenSubdiv::v3_1_1::Osd::GetEvaluator<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLContext *>(*(uint64_t **)(a1 + 88), (OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *)&v11, &v10, *(BufferDescriptor **)(a1 + 104));
  BOOL result = OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable>(*(void *)(a1 + 32), (OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *)&v11, *(void *)(a1 + 32), &v10, *(__n128 **)(a1 + 72), (uint64_t)v3, *(BufferDescriptor **)(a1 + 104));
  if (*(int *)(a1 + 64) >= 1)
  {
    uint64_t v8 = *(void *)(a1 + 60);
    int v9 = *(_DWORD *)(a1 + 68);
    BufferDescriptor v7 = *(BufferDescriptor *)(a1 + 60);
    v7.var0 += v7.var2 * v2;
    int64_t v5 = OpenSubdiv::v3_1_1::Osd::GetEvaluator<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLContext *>(*(uint64_t **)(a1 + 88), (OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *)&v8, &v7, *(BufferDescriptor **)(a1 + 104));
    uint64_t v6 = *(void *)(a1 + 40);
    if (!v6) {
      uint64_t v6 = *(void *)(a1 + 32);
    }
    return OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable>(v6, (OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *)&v8, v6, &v7, *(__n128 **)(a1 + 80), (uint64_t)v5, *(BufferDescriptor **)(a1 + 104));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::Synchronize(uint64_t a1)
{
  return C3DSceneSourcePerformConsistencyCheck(*(void *)(a1 + 104));
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::BindVaryingBuffer(uint64_t a1)
{
  return C3DRendererElementGetNode(*(void *)(a1 + 40));
}

uint64_t OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::GetVaryingBuffer(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void OpenSubdiv::v3_1_1::Osd::MTLStencilTable::Create<OpenSubdiv::v3_1_1::Far::StencilTable const,OpenSubdiv::v3_1_1::Osd::MTLContext *>()
{
}

void sub_20B391C74(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1080C40ADB4D971);
  _Unwind_Resume(a1);
}

uint64_t *OpenSubdiv::v3_1_1::Osd::GetEvaluator<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLContext *>(uint64_t *result, OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *a2, BufferDescriptor *a3, BufferDescriptor *a4)
{
  if (result)
  {
    *(void *)&v5.var0 = 0;
    v5.var2 = 0;
    *(void *)&v4.var0 = 0;
    v4.var2 = 0;
    return (uint64_t *)OpenSubdiv::v3_1_1::Osd::EvaluatorCacheT<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator>::GetEvaluator<OpenSubdiv::v3_1_1::Osd::MTLContext>(result, a2, a3, &v5, &v4, a4);
  }
  return result;
}

BOOL OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable>(uint64_t a1, OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *this, uint64_t a3, BufferDescriptor *a4, __n128 *a5, uint64_t a6, BufferDescriptor *a7)
{
  if (!a6)
  {
    *(void *)&v9.var0 = 0;
    v9.var2 = 0;
    *(void *)&v8.var0 = 0;
    v8.var2 = 0;
    OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::Create(this, a4, &v9, &v8, a7, 0);
  }

  return OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable>(a6, a1, this, a3, &a4->var0, a5, a7);
}

uint64_t OpenSubdiv::v3_1_1::Osd::EvaluatorCacheT<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator>::GetEvaluator<OpenSubdiv::v3_1_1::Osd::MTLContext>(uint64_t *a1, OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator *this, BufferDescriptor *a3, BufferDescriptor *a4, BufferDescriptor *a5, BufferDescriptor *a6)
{
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  if (*a1 == v11) {
LABEL_43:
  }
    OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::Create(this, a3, a4, a5, a6, (MTLContext *)a6);
  int v13 = *((_DWORD *)this + 1);
  int v12 = *((_DWORD *)this + 2);
  int v14 = *(_DWORD *)this;
  int var1 = a3->var1;
  int var2 = a3->var2;
  int var0 = a3->var0;
  int v18 = a4->var1;
  int v19 = a4->var2;
  int v20 = a4->var0;
  int v22 = a5->var1;
  int v21 = a5->var2;
  int v23 = a5->var0;
  while (1)
  {
    int v24 = v12 ? v14 % v12 : 0;
    int v25 = *(_DWORD *)(v10 + 8);
    int v26 = v25 ? *(_DWORD *)v10 % v25 : 0;
    if (v24 == v26 && v12 == v25 && v13 == *(_DWORD *)(v10 + 4))
    {
      int v28 = var2 ? var0 % var2 : 0;
      int v29 = *(_DWORD *)(v10 + 20);
      int v30 = v29 ? *(_DWORD *)(v10 + 12) % v29 : 0;
      if (v28 == v30 && var2 == v29 && var1 == *(_DWORD *)(v10 + 16))
      {
        int v31 = v19 ? v20 % v19 : 0;
        int v32 = *(_DWORD *)(v10 + 32);
        int v33 = v32 ? *(_DWORD *)(v10 + 24) % v32 : 0;
        if (v31 == v33 && v19 == v32 && v18 == *(_DWORD *)(v10 + 28))
        {
          int v34 = v21 ? v23 % v21 : 0;
          int v35 = *(_DWORD *)(v10 + 44);
          int v36 = v35 ? *(_DWORD *)(v10 + 36) % v35 : 0;
          if (v34 == v36 && v21 == v35 && v22 == *(_DWORD *)(v10 + 40)) {
            return *(void *)(v10 + 48);
          }
        }
      }
    }
    v10 += 56;
    if (v10 == v11) {
      goto LABEL_43;
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::EvaluatorCacheT<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator>::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(56 * a2);
}

BOOL OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable>(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, int *a5, __n128 *a6, void *a7)
{
  uint64_t Node = C3DRendererElementGetNode(a2);
  uint64_t v14 = C3DRendererElementGetNode(a4);
  uint64_t v19 = 0;
  int v20 = 0;
  uint64_t v17 = 0;
  int v18 = 0;
  return OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator::EvalStencils(a1, Node, a3, v14, a5, 0, (uint64_t)&v19, 0, *a6, v15, (uint64_t)&v17, a6->n128_u64[0], a6->n128_i64[1], a6[1].n128_i64[0], a6[1].n128_i64[1], 0, 0, 0, a6[3].n128_i32[0],
           a7);
}

__n128 ___ZL51__C3DSubdivisionOsdGPURuntimeDataCreateArchivedDataP33__C3DSubdivisionOsdGPURuntimeDataPK39C3DSubdivisionOsdGPUSetupAdditionalDataPU26objcproto15MTLCommandQueue11objc_objectPU27objcproto16MTLCommandBuffer11objc_object_block_invoke@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  if (!*(void *)(v3 + 48))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = [*(id *)(a1 + 32) device];
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = *(void *)(a1 + 32);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8)+ 56) commandBuffer];
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 72) = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8)+ 64) blitCommandEncoder];
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  __n128 result = *(__n128 *)(v3 + 48);
  long long v6 = *(_OWORD *)(v3 + 64);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v6;
  return result;
}

void *__C3DSubdivisionOsdGPURuntimeDataEncodePatchTable(void *result, void *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    BufferDescriptor v7 = result;
    objc_msgSend(result, "encodeBytes:length:forKey:", *(void *)(a3 + 8), 16 * *(void *)a3, objc_msgSend(a2, "stringByAppendingString:", @".patchArrays"));
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [a2 stringByAppendingString:@".patchIndexBuffer"], *(void **)(a3 + 16), a4, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [a2 stringByAppendingString:@".patchParamBuffer"], *(void **)(a3 + 24), a4, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [a2 stringByAppendingString:@".dataBuffer"], *(void **)(a3 + 32), a4, *(void *)(a3 + 48));
    objc_msgSend(v7, "encodeInt32:forKey:", *(unsigned int *)(a3 + 40), objc_msgSend(a2, "stringByAppendingString:", @".dataBufferOffset"));
    objc_msgSend(v7, "encodeInt32:forKey:", *(unsigned int *)(a3 + 48), objc_msgSend(a2, "stringByAppendingString:", @".dataBufferCoarseDataSize"));
    uint64_t v8 = [*(id *)(a3 + 32) length];
    uint64_t v9 = [a2 stringByAppendingString:@".dataBufferFullDataSize"];
    return (void *)[v7 encodeInt32:v8 forKey:v9];
  }
  return result;
}

uint64_t __C3DSubdivisionOsdGPURuntimeDataEncodeRefiner(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    BufferDescriptor v7 = (void *)result;
    uint64_t v8 = (void *)[a2 stringByAppendingString:@".stencilTable"];
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [v8 stringByAppendingString:@".sizesBuffer"], *(void **)a3, a4, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [v8 stringByAppendingString:@".offsetsBuffer"], *(void **)(a3 + 8), a4, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [v8 stringByAppendingString:@".indicesBuffer"], *(void **)(a3 + 16), a4, 0);
    __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(v7, [v8 stringByAppendingString:@".weightsBuffer"], *(void **)(a3 + 24), a4, 0);
    objc_msgSend(v7, "encodeInt32:forKey:", *(unsigned int *)(a3 + 32), objc_msgSend(v8, "stringByAppendingString:", @".numStencils"));
    uint64_t v9 = (void *)[a2 stringByAppendingString:@".evaluatorInput"];
    objc_msgSend(v7, "encodeBytes:length:forKey:", a3 + 56, 12, objc_msgSend(v9, "stringByAppendingString:", @".srcDesc"));
    uint64_t v10 = [v9 stringByAppendingString:@".dstDesc"];
    return [v7 encodeBytes:a3 + 68 length:12 forKey:v10];
  }
  return result;
}

void __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer(void *a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5)
{
  if (a3)
  {
    unint64_t v5 = a5;
    if (!a5) {
      unint64_t v5 = [a3 length];
    }
    if (v5 > [a3 length]) {
      __C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer();
    }
    if ([a3 storageMode] == 2)
    {
      uint64_t v10 = objc_msgSend((id)objc_msgSend(a3, "device"), "newBufferWithLength:options:", v5, 0);
      (*(void (**)(void *__return_ptr, uint64_t))(a4 + 16))(v13, a4);
      [(id)v13[3] copyFromBuffer:a3 sourceOffset:0 toBuffer:v10 destinationOffset:0 size:v5];
      v12[0] = MEMORY[0x263EF8330];
      v12[1] = 3221225472;
      v12[2] = ___ZL48__C3DSubdivisionOsdGPURuntimeDataEncodeMTLBufferP15NSKeyedArchiverP8NSStringPU19objcproto9MTLBuffer11objc_objectU13block_pointerFN10OpenSubdiv6v3_1_13Osd10MTLContextEvEm_block_invoke;
      v12[3] = &unk_264007808;
      v12[4] = a1;
      v12[5] = v10;
      v12[6] = a2;
      v12[7] = v5;
      [(id)v13[2] addCompletedHandler:v12];
    }
    else
    {
      uint64_t v11 = [a3 contents];
      [a1 encodeBytes:v11 length:v5 forKey:a2];
    }
  }
}

uint64_t ___ZL48__C3DSubdivisionOsdGPURuntimeDataEncodeMTLBufferP15NSKeyedArchiverP8NSStringPU19objcproto9MTLBuffer11objc_objectU13block_pointerFN10OpenSubdiv6v3_1_13Osd10MTLContextEvEm_block_invoke(uint64_t a1)
{
  int v2 = *(void **)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 40) contents];
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 56);

  return [v2 encodeBytes:v3 length:v4 forKey:v5];
}

void *OpenSubdiv::v3_1_1::Osd::Mesh<OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer,OpenSubdiv::v3_1_1::Osd::MTLStencilTable,OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator,OpenSubdiv::v3_1_1::Osd::MTLPatchTable,OpenSubdiv::v3_1_1::Osd::MTLContext>::~Mesh(void *a1)
{
  *a1 = &unk_26BF6C5E0;
  int v2 = (OpenSubdiv::v3_1_1::Far::TopologyRefiner *)a1[1];
  if (v2)
  {
    OpenSubdiv::v3_1_1::Far::TopologyRefiner::~TopologyRefiner(v2);
    MEMORY[0x210534FE0]();
  }
  uint64_t v3 = (OpenSubdiv::v3_1_1::Far::PatchTable *)a1[2];
  if (v3)
  {
    OpenSubdiv::v3_1_1::Far::PatchTable::~PatchTable(v3);
    MEMORY[0x210534FE0]();
  }
  uint64_t v4 = (id *)a1[4];
  if (v4)
  {
    OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::~CPUMTLVertexBuffer(v4);
    MEMORY[0x210534FE0]();
  }
  uint64_t v5 = (id *)a1[5];
  if (v5)
  {
    OpenSubdiv::v3_1_1::Osd::CPUMTLVertexBuffer::~CPUMTLVertexBuffer(v5);
    MEMORY[0x210534FE0]();
  }
  long long v6 = (OpenSubdiv::v3_1_1::Osd::MTLStencilTable *)a1[9];
  if (v6)
  {
    OpenSubdiv::v3_1_1::Osd::MTLStencilTable::~MTLStencilTable(v6);
    MEMORY[0x210534FE0]();
  }
  BufferDescriptor v7 = (OpenSubdiv::v3_1_1::Osd::MTLStencilTable *)a1[10];
  if (v7)
  {
    OpenSubdiv::v3_1_1::Osd::MTLStencilTable::~MTLStencilTable(v7);
    MEMORY[0x210534FE0]();
  }
  uint64_t v8 = (OpenSubdiv::v3_1_1::Osd::MTLPatchTable *)a1[12];
  if (v8)
  {
    OpenSubdiv::v3_1_1::Osd::MTLPatchTable::~MTLPatchTable(v8);
    MEMORY[0x210534FE0]();
  }
  return a1;
}

void std::vector<C3DSubdivGPUFVarPrimvarData>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 8;
        std::allocator<C3DSubdivGPUFVarPrimvarData>::destroy[abi:nn180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<C3DSubdivGPUFVarPrimvarData>::destroy[abi:nn180100](uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[5];
  if (v3)
  {
    a2[6] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a2[2];
  if (v4)
  {
    a2[3] = v4;
    operator delete(v4);
  }
}

void *std::vector<C3DSubdivisionOsdGPUPatchTable>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<C3DSubdivisionOsdGPUPatchTable>::__vallocate[abi:nn180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

char *std::vector<C3DSubdivisionOsdGPUPatchTable>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::EvaluatorCacheT<OpenSubdiv::v3_1_1::Osd::MTLComputeEvaluator>::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

void *std::vector<CFRange>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8nn180100Em(a1, v5 >> 4);
    long long v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void sub_20B392C2C(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C403A34AA84);
  _Unwind_Resume(a1);
}

void sub_20B392D28(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C403A34AA84);
  _Unwind_Resume(a1);
}

BOOL SCNActionIsPaused(void *a1)
{
  return *(double *)([a1 caction] + 48) > 0.0;
}

uint64_t SCNActionHasKey(void *a1, void *a2)
{
  uint64_t v3 = *(void *)([a1 caction] + 96);

  return [a2 isEqualToString:v3];
}

uint64_t SCNActionApply(void *a1, id *a2, double a3)
{
  int64_t v5 = (SCNCAction *)[a1 caction];
  ObjCWrapper = (SCNNode *)C3DEntityGetObjCWrapper(a2);
  if (!ObjCWrapper) {
    return C3DIsRunningInEditor() ^ 1;
  }
  BufferDescriptor v7 = ObjCWrapper;
  if (!v5->var11) {
    SCNCAction::willStartWithTargetAtTime(v5, ObjCWrapper, a3);
  }
  if (v5->var4)
  {
    (*((void (**)(SCNCAction *, SCNNode *, double))v5->var0 + 7))(v5, v7, a3);
  }
  else
  {
    SCNCAction::updateWithTargetForTime(v5, v7, a3);
    if (!v5->var4)
    {
      int var10 = [v5->var3 finished];
      return var10 & ~C3DIsRunningInEditor();
    }
  }
  int var10 = v5->var10;
  return var10 & ~C3DIsRunningInEditor();
}

uint64_t SCNActionWasAddedToTargetAtTime(void *a1, SCNNode *a2)
{
  uint64_t v4 = (SCNCAction *)[a1 caction];
  C3DTransactionGetAtomicTime();
  SCNCAction::wasAddedToTargetAtTime(v4, a2, v5);
  uint64_t result = [(SCNNode *)a2 isPausedOrPausedByInheritance];
  if (result)
  {
    BufferDescriptor v7 = (SCNCAction *)[a1 caction];
    C3DTransactionGetAtomicTime();
    return SCNCAction::wasPausedWithTargetAtTime(v7, a2, v8);
  }
  return result;
}

uint64_t SCNActionWasPausedAtTime(void *a1, SCNNode *a2, double a3)
{
  double v5 = (SCNCAction *)[a1 caction];

  return SCNCAction::wasPausedWithTargetAtTime(v5, a2, a3);
}

uint64_t SCNActionWillResumeAtTime(void *a1, SCNNode *a2, double a3)
{
  double v5 = (SCNCAction *)[a1 caction];

  return SCNCAction::willResumeWithTargetAtTime(v5, a2, a3);
}

SCNNode *SCNActionWasRemovedFromTargetAtTime(void *a1, id *a2, double a3)
{
  double v5 = (SCNCAction *)[a1 caction];
  uint64_t result = (SCNNode *)C3DEntityGetObjCWrapper(a2);
  if (result)
  {
    return (SCNNode *)SCNCAction::wasRemovedFromTargetAtTime(v5, result, a3);
  }
  return result;
}

id *SCNActionDidFinish(void *a1, id *a2)
{
  uint64_t result = C3DEntityGetObjCWrapper(a2);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)([a1 caction] + 96);
    return (id *)[v4 _removeAction:a1 forKey:v5];
  }
  return result;
}

void SCNActionReleaseCachedState(uint64_t a1)
{
  uint64_t v1 = +[SCNNode nodeWithNodeRef:a1];

  objc_setAssociatedObject(v1, @"SCNActionCacheKey", 0, (void *)0x301);
}

uint64_t SCNActionsReset(void *a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t result = [a1 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)v8;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v8 != v4) {
          objc_enumerationMutation(a1);
        }
        uint64_t v6 = [*(id *)(*((void *)&v7 + 1) + 8 * v5) caction];
        (*(void (**)(uint64_t))(*(void *)v6 + 120))(v6);
        ++v5;
      }
      while (v3 != v5);
      uint64_t result = [a1 countByEnumeratingWithState:&v7 objects:v11 count:16];
      uint64_t v3 = result;
    }
    while (result);
  }
  return result;
}

id SCNActionRestoreState(uint64_t a1)
{
  uint64_t v1 = +[SCNNode nodeWithNodeRef:a1];
  id result = objc_getAssociatedObject(v1, @"SCNActionCacheKey");
  if (result)
  {
    uint64_t v3 = result;
    [result position];
    -[SCNNode setPosition:](v1, "setPosition:");
    [v3 scale];
    -[SCNNode setScale:](v1, "setScale:");
    if ([v3 usesEuler])
    {
      [v3 euler];
      -[SCNNode setEulerAngles:](v1, "setEulerAngles:");
    }
    else
    {
      [v3 rotation];
      -[SCNNode setRotation:](v1, "setRotation:");
    }
    [v3 opacity];
    double v5 = v4;
    return (id)[(SCNNode *)v1 setOpacity:v5];
  }
  return result;
}

void SCNActionSaveStateIfNeeded(uint64_t a1)
{
  uint64_t v1 = +[SCNNode nodeWithNodeRef:a1];
  if (!objc_getAssociatedObject(v1, @"SCNActionCacheKey"))
  {
    uint64_t v3 = objc_alloc_init(SCNActionTargetState);
    objc_setAssociatedObject(v1, @"SCNActionCacheKey", v3, (void *)0x301);
    [(SCNNode *)v1 opacity];
    *(float *)&double v2 = v2;
    [(SCNActionTargetState *)v3 setOpacity:v2];
    [(SCNNode *)v1 position];
    -[SCNActionTargetState setPosition:](v3, "setPosition:");
    [(SCNNode *)v1 scale];
    -[SCNActionTargetState setScale:](v3, "setScale:");
    if ([(SCNNode *)v1 rotationRepresentation])
    {
      [(SCNNode *)v1 rotation];
      -[SCNActionTargetState setRotation:](v3, "setRotation:");
    }
    else
    {
      [(SCNActionTargetState *)v3 setUsesEuler:1];
      [(SCNNode *)v1 eulerAngles];
      -[SCNActionTargetState setEuler:](v3, "setEuler:");
    }
  }
}

void sub_20B393E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23)
{
}

void sub_20B3941A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23)
{
}

void sub_20B394590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,void *a33)
{
}

void sub_20B394988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,void *a33)
{
}

void std::__tree<std::__value_type<SKNode *,std::vector<UITouch *>>,std::__map_value_compare<SKNode *,std::__value_type<SKNode *,std::vector<UITouch *>>,std::less<SKNode *>,true>,std::allocator<std::__value_type<SKNode *,std::vector<UITouch *>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<SKNode *,std::vector<UITouch *>>,std::__map_value_compare<SKNode *,std::__value_type<SKNode *,std::vector<UITouch *>>,std::less<SKNode *>,true>,std::allocator<std::__value_type<SKNode *,std::vector<UITouch *>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<SKNode *,std::vector<UITouch *>>,std::__map_value_compare<SKNode *,std::__value_type<SKNode *,std::vector<UITouch *>>,std::less<SKNode *>,true>,std::allocator<std::__value_type<SKNode *,std::vector<UITouch *>>>>::destroy(a1, a2[1]);
    float v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<SKNode *,std::vector<UITouch *>>,std::__map_value_compare<SKNode *,std::__value_type<SKNode *,std::vector<UITouch *>>,std::less<SKNode *>,true>,std::allocator<std::__value_type<SKNode *,std::vector<UITouch *>>>>::__emplace_unique_key_args<SKNode *,std::piecewise_construct_t const&,std::tuple<SKNode * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  long long v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        long long v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        long long v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        long long v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[4] = v12;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t C3DMeshSourceCreateMutable(CFDataRef theData, __int16 a2, uint64_t a3, uint64_t a4, int a5)
{
  if (!a5) {
    return 0;
  }
  if (theData)
  {
    CFIndex Length = CFDataGetLength(theData);
    MutableCopy = CFDataCreateMutableCopy(0, Length, theData);
  }
  else
  {
    CFIndex v13 = a4 * a3 * C3DSizeOfBaseType(a5);
    MutableCopy = CFDataCreateMutable(0, 0);
    CFDataSetLength(MutableCopy, v13);
  }
  uint64_t v14 = C3DSizeOfBaseType(a5);
  uint64_t MutableWithMutableData = C3DMeshSourceCreateMutableWithMutableData(a2, MutableCopy, a5, a4, a3, v14 * a4, 0);
  CFRelease(MutableCopy);
  return MutableWithMutableData;
}

uint64_t _C3DMeshSourceSetupNonInitializedComponents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t result = C3DSourceAccessorGetComponentsCountPerValue(v8);
  uint64_t v10 = result - a4;
  if (result > a4)
  {
    uint64_t v11 = (int)C3DMeshSourceGetSemantic(a1) - 1;
    float v12 = 1.0;
    float v13 = 1.0;
    if (v11 <= 5)
    {
      float v12 = flt_20B5EDB90[v11];
      float v13 = flt_20B5EDBA8[(int)v11];
    }
    uint64_t result = C3DSceneSourceGetLibrary(v8);
    if (a3 >= 1)
    {
      uint64_t v14 = result;
      uint64_t v15 = 0;
      uint64_t v16 = a2 + a4;
      uint64_t v17 = a2 + 8 * a4;
      uint64_t v18 = a2 + 4 * a4;
      do
      {
        uint64_t v19 = 0;
        do
        {
          if (v10 - 1 == v19) {
            float v20 = v13;
          }
          else {
            float v20 = v12;
          }
          uint64_t result = C3DSourceAccessorGetComponentsValueType(v8);
          if ((int)result > 5)
          {
            if (result != 6)
            {
              if (result != 16) {
                goto LABEL_19;
              }
LABEL_16:
              *(unsigned char *)(v16 + v19) = (int)v20;
              goto LABEL_19;
            }
            *(double *)(v17 + 8 * v19) = v20;
          }
          else if (result == 1)
          {
            *(float *)(v18 + 4 * v19) = v20;
          }
          else if (result == 4)
          {
            goto LABEL_16;
          }
LABEL_19:
          ++v19;
        }
        while (v10 != v19);
        ++v15;
        v16 += v14;
        v17 += v14;
        v18 += v14;
      }
      while (v15 != a3);
    }
  }
  return result;
}

void C3DMeshSourceSetValueAtIndexAsVector3(uint64_t a1, uint64_t a2, __n128 a3)
{
  if (!a1)
  {
    double v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  float v13 = *(void **)(a1 + 64);
  MutableValuePtrAtIndex = C3DSourceAccessorGetMutableValuePtrAtIndex(v13, a2);
  __n128 v15 = a3;
  v15.n128_u32[3] = 0;
  float32x4_t v18 = (float32x4_t)v15;
  Vectorchar Type = C3DSourceAccessorGetVectorType((uint64_t)v13);
  C3DConvertFloatingTypeFromFloat4(VectorType, (uint64_t)MutableValuePtrAtIndex, v18);
}

void C3DMeshSourceSetValueAtIndexAsVector4(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  if (!a1)
  {
    double v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  float v13 = *(void **)(a1 + 64);
  MutableValuePtrAtIndex = C3DSourceAccessorGetMutableValuePtrAtIndex(v13, a2);
  Vectorchar Type = C3DSourceAccessorGetVectorType((uint64_t)v13);
  C3DConvertFloatingTypeFromFloat4(VectorType, (uint64_t)MutableValuePtrAtIndex, a3);
}

__CFData *C3DMeshSourcePrepareAppend(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void **)(a1 + 64);
  CFDataRef Data = (const __CFData *)C3DSourceAccessorGetData((uint64_t)v12);
  uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)v12);
  if (!Data)
  {
    __n128 v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithData_cold_2(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  CFIndex Length = CFDataGetLength(Data);
  if (Length != C3DSourceAccessorGetCount((uint64_t)v12) * Library)
  {
    int v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourcePrepareAppend_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  CFIndex v32 = CFDataGetLength(Data);
  CFDataSetLength(Data, v32 + Library * a2);
  uint64_t Count = C3DSourceAccessorGetCount((uint64_t)v12);
  C3DSourceAccessorSetCount((uint64_t)v12, Count + a2);
  return C3DSourceAccessorGetMutableValuePtrAtIndex(v12, Count);
}

uint64_t C3DMeshSourceAppendVector3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 64);
  __n128 v15 = C3DMeshSourcePrepareAppend(a1, a3);
  uint64_t Library = C3DSceneSourceGetLibrary(v14);
  if (a3 >= 1)
  {
    uint64_t v17 = Library;
    uint64_t v18 = (float *)(a2 + 4);
    uint64_t v19 = a3;
    uint64_t v20 = v15;
    do
    {
      ComponentsValuechar Type = C3DSourceAccessorGetComponentsValueType(v14);
      if (ComponentsValueType > 5)
      {
        if (ComponentsValueType == 6)
        {
          *(double *)uint64_t v20 = *(v18 - 1);
          *((double *)v20 + 1) = *v18;
          *((double *)v20 + 2) = v18[1];
          goto LABEL_16;
        }
        if (ComponentsValueType != 16)
        {
LABEL_9:
          uint64_t v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            C3DMeshSourceAppendVector3_cold_1(&v24, v25);
          }
          goto LABEL_16;
        }
      }
      else
      {
        if (ComponentsValueType == 1)
        {
          *(float *)uint64_t v20 = *(v18 - 1);
          *((float *)v20 + 1) = *v18;
          *((float *)v20 + 2) = v18[1];
          goto LABEL_16;
        }
        if (ComponentsValueType != 4) {
          goto LABEL_9;
        }
      }
      *(unsigned char *)uint64_t v20 = (int)*(v18 - 1);
      *((unsigned char *)v20 + 1) = (int)*v18;
      *((unsigned char *)v20 + 2) = (int)v18[1];
LABEL_16:
      uint64_t v20 = (__CFData *)((char *)v20 + v17);
      v18 += 4;
      --v19;
    }
    while (v19);
  }
  return _C3DMeshSourceSetupNonInitializedComponents(a1, (uint64_t)v15, a3, 3);
}

uint64_t C3DMeshSourceAppendVector2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 64);
  __n128 v15 = C3DMeshSourcePrepareAppend(a1, a3);
  uint64_t Library = C3DSceneSourceGetLibrary(v14);
  if (a3 >= 1)
  {
    uint64_t v17 = Library;
    uint64_t v18 = (float *)(a2 + 4);
    uint64_t v19 = v15;
    for (uint64_t i = a3; i; --i)
    {
      ComponentsValuechar Type = C3DSourceAccessorGetComponentsValueType(v14);
      if (ComponentsValueType > 5)
      {
        if (ComponentsValueType == 6)
        {
          *(double *)uint64_t v19 = COERCE_FLOAT(*(void *)(v18 - 1));
          *((double *)v19 + 1) = *v18;
          goto LABEL_16;
        }
        if (ComponentsValueType != 16)
        {
LABEL_9:
          uint64_t v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            C3DMeshSourceAppendVector2_cold_1(&v24, v25);
          }
          goto LABEL_16;
        }
      }
      else
      {
        if (ComponentsValueType == 1)
        {
          *(_DWORD *)uint64_t v19 = *(void *)(v18 - 1);
          *((float *)v19 + 1) = *v18;
          goto LABEL_16;
        }
        if (ComponentsValueType != 4) {
          goto LABEL_9;
        }
      }
      *(unsigned char *)uint64_t v19 = (int)COERCE_FLOAT(*(void *)(v18 - 1));
      *((unsigned char *)v19 + 1) = (int)*v18;
LABEL_16:
      v18 += 2;
      uint64_t v19 = (__CFData *)((char *)v19 + v17);
    }
  }
  return _C3DMeshSourceSetupNonInitializedComponents(a1, (uint64_t)v15, a3, 2);
}

uint64_t C3DMeshSourceCreateVolatile(__int16 a1, uint64_t a2, unsigned int a3)
{
  if (a3 <= 0x15 && ((1 << a3) & 0x210052) != 0)
  {
    uint64_t v6 = C3DSizeOfBaseType(a3);
    uint64_t v7 = (const void *)C3DSourceAccessorCreate(a3, a2, 0, v6 * a2, 0);
    if (!v7)
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        C3DMeshSourceCreateVolatile_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
    uint64_t v16 = C3DMeshSourceCreateWithAccessor(v7, a1);
    if (!v16)
    {
      uint64_t v17 = scn_default_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
        C3DMeshSourceCreateWithAccessor_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
      }
    }
    C3DSourceAccessorSetSource((uint64_t)v7, v16);
    CFRelease(v7);
    *(unsigned char *)(v16 + 88) |= 4u;
  }
  else
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      C3DMeshSourceCreateVolatile_cold_1(v26);
    }
    return 0;
  }
  return v16;
}

void C3DMeshSourceSetVolatileData(uint64_t a1, uint64_t a2)
{
  if ((C3DGenericSourceIsVolatile(a1) & 1) == 0)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceSetVolatileData_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  C3DGenericSourceSetVolatileData(a1, a2);
}

BOOL C3DMeshSourceOwnsItsData(uint64_t a1)
{
  return C3DGenericSourceGetOwnData(a1) != 0;
}

void C3DMeshSourceSetInstancingDivisor(uint64_t a1, char a2)
{
  if (!a1)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframedAnimationCopy_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 98) = a2;
}

void _C3DEdgeArrayCFFinalize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1) {
    free(v1);
  }
}

CFStringRef _C3DEdgeArrayCFCopyFormatDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DEdgeArray>");
}

CFStringRef _C3DEdgeArrayCFCopyDebugDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DEdgeArray>");
}

uint64_t __C3DEdgeArrayGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DEdgeArrayGetTypeID_typeID = result;
  return result;
}

void *C3DEdgeArrayCreateFromMeshElement(uint64_t a1, CFIndex a2)
{
  if (C3DEdgeArrayGetTypeID_onceToken != -1) {
    dispatch_once(&C3DEdgeArrayGetTypeID_onceToken, &__block_literal_global_56);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DEdgeArrayGetTypeID_typeID, 0x18uLL);
  if (!Instance)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DEdgeArrayCreateFromMeshElement_cold_2(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  Instance[3] = 0;
  Instance[2] = 0;
  uint64_t v41 = Instance + 2;
  ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, a2, 1);
  Primitiveuint64_t Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
  PositionSource = C3DMeshGetPositionSource(a1, 1);
  uint64_t Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  int64_t v17 = (uint64_t)(float)(Count * Count);
  uint64_t v18 = malloc_type_calloc(1uLL, v17, 0xEFD97E85uLL);
  if (PrimitiveCount < 1)
  {
    Instance[3] = 0;
  }
  else
  {
    uint64_t v39 = Instance + 3;
    uint64_t v40 = Instance;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    do
    {
      uint64_t Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v19, 0, 0);
      uint64_t v22 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v19, 1, 0);
      uint64_t v23 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v19, 2, 0);
      if (Index >= v22) {
        uint64_t v24 = v22;
      }
      else {
        uint64_t v24 = Index;
      }
      if (Index <= v22) {
        uint64_t v25 = v22;
      }
      else {
        uint64_t v25 = Index;
      }
      uint64_t v26 = v25 + v24 * Count;
      if (!v18[v26])
      {
        v18[v26] = 1;
        ++v20;
      }
      if (v22 >= v23) {
        uint64_t v27 = v23;
      }
      else {
        uint64_t v27 = v22;
      }
      if (v22 <= v23) {
        uint64_t v28 = v23;
      }
      else {
        uint64_t v28 = v22;
      }
      uint64_t v29 = v28 + v27 * Count;
      if (!v18[v29])
      {
        v18[v29] = 1;
        ++v20;
      }
      if (v23 >= Index) {
        uint64_t v30 = Index;
      }
      else {
        uint64_t v30 = v23;
      }
      if (v23 <= Index) {
        uint64_t v31 = Index;
      }
      else {
        uint64_t v31 = v23;
      }
      uint64_t v32 = v31 + v30 * Count;
      if (!v18[v32])
      {
        v18[v32] = 1;
        ++v20;
      }
      ++v19;
    }
    while (PrimitiveCount != v19);
    uint64_t Instance = v40;
    *uint64_t v39 = v20;
    if (v20)
    {
      int v33 = (char *)malloc_type_malloc(16 * v20, 0x1000040451B5BE8uLL);
      *uint64_t v41 = v33;
      if (v17 < 1)
      {
        uint64_t v35 = 0;
      }
      else
      {
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        do
        {
          if (v18[v34])
          {
            int v36 = (uint64_t *)&v33[16 * v35];
            *int v36 = v34 / Count;
            v36[1] = v34 + -Count * (v34 / Count);
            ++v35;
          }
          ++v34;
        }
        while (v17 != v34);
      }
      if (v35 != *v39)
      {
        uint64_t v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          C3DEdgeArrayCreateFromMeshElement_cold_1(v39, v35, v37);
        }
      }
    }
  }
  free(v18);
  Instance[4] = Instance[3];
  return Instance;
}

uint64_t C3DEdgeArrayGetCount(uint64_t a1)
{
  if (!a1)
  {
    double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEdgeArrayCreateFromMeshElement_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

uint64_t C3DEdgeArrayGetEdgeAtIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEdgeArrayCreateFromMeshElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 24) <= a2)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DEdgeArrayGetEdgeAtIndex_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return *(void *)(a1 + 16) + 16 * a2;
}

void _C3DTriangulationInfoCFFinalize(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(const void **)(a1[3] + 8 * i);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(a1[3] + 8 * i) = 0;
        uint64_t v2 = a1[6];
      }
    }
  }
  uint64_t v5 = a1[5];
  if (v5 >= 1)
  {
    for (uint64_t j = 0; j < v5; ++j)
    {
      uint64_t v7 = *(const void **)(a1[2] + 8 * j);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1[2] + 8 * j) = 0;
        uint64_t v5 = a1[5];
      }
    }
  }
  uint64_t v8 = (void *)a1[3];
  if (v8) {
    free(v8);
  }
  uint64_t v9 = (void *)a1[2];
  if (v9) {
    free(v9);
  }
  uint64_t v10 = (void *)a1[4];
  if (v10)
  {
    free(v10);
  }
}

CFStringRef _C3DTriangulationInfoCFCopyFormatDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DTriangulationInfo>");
}

CFStringRef _C3DTriangulationInfoCFCopyDebugDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DTriangulationInfo>");
}

uint64_t __C3DTriangulationInfoGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DTriangulationInfoGetTypeID_typeID = result;
  return result;
}

void *C3DTriangulationInfoCreateFromMeshElement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&v42[5] = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererContextCreateBufferObjectForMeshElement_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DTriangulationInfoCreateFromMeshElement_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  size_t Count = C3DMeshSourceGetCount(a2);
  if (a3) {
    int64_t v23 = *(void *)(a3 + 24);
  }
  else {
    int64_t v23 = 0;
  }
  Primitivesize_t Count = C3DMeshElementGetPrimitiveCount(a1);
  if (!Count) {
    return 0;
  }
  int64_t v25 = PrimitiveCount;
  if (C3DTriangulationInfoGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTriangulationInfoGetTypeID_onceToken, &__block_literal_global_9);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DTriangulationInfoGetTypeID_typeID, 0x30uLL);
  Instance[2] = malloc_type_calloc(8uLL, Count, 0x23682DEBuLL);
  Instance[5] = Count;
  Instance[7] = v25;
  if (v25 >= 1)
  {
    for (uint64_t i = 0; i != v25; ++i)
    {
      for (uint64_t j = 0; j != 3; ++j)
      {
        uint64_t Index = C3DMeshElementGetIndex(a1, i, j, 0);
        uint64_t v30 = *(void *)(Instance[2] + 8 * Index);
        if (!v30)
        {
          *(void *)(Instance[2] + 8 * Index) = C3DIndexSetCreateMutable();
          uint64_t v30 = *(void *)(Instance[2] + 8 * Index);
        }
        C3DIndexSetAddIndex(v30, i);
      }
    }
  }
  if (v23)
  {
    Instance[3] = malloc_type_calloc(8uLL, v23, 0xA3723D5BuLL);
    Instance[6] = v23;
    Instance[4] = malloc_type_calloc(0x18uLL, v25, 0xF26B11FAuLL);
    uint64_t v31 = malloc_type_calloc(1uLL, v25, 0x7DF9CD46uLL);
    if (v23 >= 1)
    {
      for (uint64_t k = 0; k != v23; ++k)
      {
        EdgeAtuint64_t Index = (void *)C3DEdgeArrayGetEdgeAtIndex(a3, k);
        uint64_t IntersectionOfIndexSets = C3DIndexSetCreateIntersectionOfIndexSets(*(void *)(Instance[2] + 8 * *EdgeAtIndex), *(void *)(Instance[2] + 8 * EdgeAtIndex[1]));
        *(void *)(Instance[3] + 8 * k) = IntersectionOfIndexSets;
        uint64_t FirstIndex = C3DIndexSetGetFirstIndex(IntersectionOfIndexSets);
        if (FirstIndex != -1)
        {
          for (uint64_t m = FirstIndex; m != -1; uint64_t m = C3DIndexSetGetIndexGreaterThanIndex(IntersectionOfIndexSets, m))
          {
            if (v31[m] >= 3u)
            {
              uint64_t v37 = scn_default_log();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
                C3DTriangulationInfoCreateFromMeshElement_cold_1(v41, v42, v37);
              }
            }
            uint64_t v38 = v31[m];
            uint64_t v39 = Instance[4] + 24 * m;
            v31[m] = v38 + 1;
            *(void *)(v39 + 8 * v38) = k;
          }
        }
      }
    }
    free(v31);
  }
  return Instance;
}

uint64_t C3DTriangulationInfoGetEdgesAtFaceIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DTriangulationInfoGetEdgesAtFaceIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

void _C3DMeshElementEditorCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
}

CFStringRef _C3DMeshElementEditorCFCopyFormatDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DMeshElementEditor>");
}

CFStringRef _C3DMeshElementEditorCFCopyDebugDescription()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"<C3DMeshElementEditor>");
}

uint64_t __C3DMeshElementEditorGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DMeshElementEditorGetTypeID_typeID = result;
  return result;
}

uint64_t C3DMeshElementEditorCreate()
{
  if (C3DMeshElementEditorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DMeshElementEditorGetTypeID_onceToken, &__block_literal_global_57);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DMeshElementEditorGetTypeID_typeID, 0x28uLL);
  if (!Instance)
  {
    uint64_t v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementEditorCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  return Instance;
}

uint64_t C3DMeshElementEditorCreateWithMeshElementAndCapacity(const void *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextCreateBufferObjectForMeshElement_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DMeshElementGetType((uint64_t)a1))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      C3DMeshElementEditorCreateWithMeshElementAndCapacity_cold_1();
    }
    return 0;
  }
  else
  {
    uint64_t v13 = C3DMeshElementEditorCreate();
    CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)a1, (_DWORD *)(v13 + 40));
    *(void *)(v13 + 16) = CFRetain(a1);
    *(void *)(v13 + 48) = C3DMeshElementGetPrimitiveCount((uint64_t)a1);
    *(void *)(v13 + 32) = CFDataCreateMutableCopy(0, 3 * a2 * *(unsigned int *)(v13 + 40), Indexes);
  }
  return v13;
}

void _C3DMeshElementEditorIncreaseBytesPerIndexIfNeeded(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = 1;
  if (a2 > 0xFF) {
    uint64_t v3 = 2;
  }
  if (HIWORD(a2)) {
    unint64_t v4 = 4;
  }
  else {
    unint64_t v4 = v3;
  }
  if (v4 > *(unsigned int *)(a1 + 40))
  {
    CFIndex v6 = CFDataGetLength(*(CFDataRef *)(a1 + 32)) / *(unsigned int *)(a1 + 40);
    char v7 = 2;
    if (!HIWORD(a2)) {
      char v7 = a2 > 0xFF;
    }
    CFIndex v8 = v6 << v7;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v8);
    int v10 = *(_DWORD *)(a1 + 40);
    switch(v10)
    {
      case 4:
        CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
        uint64_t v14 = scn_default_log();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
        break;
      case 2:
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
        if (a2 >= 0x10000)
        {
          uint64_t v16 = BytePtr;
          MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
          if (v6 >= 1)
          {
            do
            {
              int v18 = *(unsigned __int16 *)v16;
              v16 += 2;
              *(_DWORD *)MutableBytePtr = v18;
              MutableBytePtr += 4;
              --v6;
            }
            while (v6);
          }
          goto LABEL_32;
        }
        uint64_t v20 = scn_default_log();
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
        break;
      case 1:
        uint64_t v11 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
        if (v4 == 4)
        {
          uint64_t v21 = CFDataGetMutableBytePtr(Mutable);
          if (v6 >= 1)
          {
            do
            {
              int v22 = *v11++;
              *(_DWORD *)uint64_t v21 = v22;
              v21 += 4;
              --v6;
            }
            while (v6);
          }
          goto LABEL_32;
        }
        if (v4 == 2)
        {
          uint64_t v12 = CFDataGetMutableBytePtr(Mutable);
          if (v6 >= 1)
          {
            do
            {
              __int16 v13 = *v11++;
              *(_WORD *)uint64_t v12 = v13;
              v12 += 2;
              --v6;
            }
            while (v6);
          }
          goto LABEL_32;
        }
        int64_t v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          break;
        }
LABEL_32:
        uint64_t v24 = *(const void **)(a1 + 32);
        if (v24) {
          CFRelease(v24);
        }
        *(_DWORD *)(a1 + 40) = v4;
        *(void *)(a1 + 32) = Mutable;
        return;
      default:
        uint64_t v19 = scn_default_log();
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
        break;
    }
    _C3DMeshElementEditorIncreaseBytesPerIndexIfNeeded_cold_1();
    goto LABEL_32;
  }
}

uint64_t C3DMeshElementEditorGetIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 32));
  uint64_t v7 = *(unsigned int *)(a1 + 40);
  int v8 = v7 - 1;
  uint64_t v9 = (3 * a2 + a3) * v7;
  switch(v8)
  {
    case 0:
      uint64_t result = MutableBytePtr[v9];
      break;
    case 1:
      uint64_t result = *(unsigned __int16 *)&MutableBytePtr[v9];
      break;
    case 3:
    case 7:
      uint64_t result = *(unsigned int *)&MutableBytePtr[v9];
      break;
    default:
      uint64_t v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        C3DMeshElementEditorGetIndex_cold_1();
      }
      uint64_t result = -1;
      break;
  }
  return result;
}

void _C3DMeshElementEditorSetIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _C3DMeshElementEditorIncreaseBytesPerIndexIfNeeded(a1, a4);
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 32));
  uint64_t v9 = *(unsigned int *)(a1 + 40);
  int v10 = v9 - 1;
  uint64_t v11 = (3 * a2 + a3) * v9;
  switch(v10)
  {
    case 0:
      MutableBytePtr[v11] = a4;
      break;
    case 1:
      *(_WORD *)&MutableBytePtr[v11] = a4;
      break;
    case 3:
      *(_DWORD *)&MutableBytePtr[v11] = a4;
      break;
    case 7:
      *(void *)&MutableBytePtr[v11] = a4;
      break;
    default:
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        C3DMeshElementEditorGetIndex_cold_1();
      }
      break;
  }
}

void C3DMeshElementEditorSubdivideTriangleAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
  {
    int v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementEditorSubdivideTriangleAtIndex_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  int v18 = *(const void **)(a1 + 24);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 24) = 0;
  }
  if (*(void *)(a1 + 48) >= a2)
  {
    uint64_t Index = C3DMeshElementEditorGetIndex(a1, a2, 1);
    uint64_t v21 = C3DMeshElementEditorGetIndex(a1, a2, 2);
    uint64_t v22 = *(void *)(a1 + 48);
    CFDataRef v23 = *(const __CFData **)(a1 + 32);
    CFIndex Length = CFDataGetLength(v23);
    CFDataSetLength(v23, Length + (9 * *(_DWORD *)(a1 + 40)));
    _C3DMeshElementEditorSetIndex(a1, a2, 1, a4);
    _C3DMeshElementEditorSetIndex(a1, a2, 2, a3);
    _C3DMeshElementEditorSetIndex(a1, v22, 0, a3);
    _C3DMeshElementEditorSetIndex(a1, v22, 1, a5);
    _C3DMeshElementEditorSetIndex(a1, v22, 2, v21);
    _C3DMeshElementEditorSetIndex(a1, v22 + 1, 0, a3);
    _C3DMeshElementEditorSetIndex(a1, v22 + 1, 1, a4);
    _C3DMeshElementEditorSetIndex(a1, v22 + 1, 2, a5);
    _C3DMeshElementEditorSetIndex(a1, v22 + 2, 0, a4);
    _C3DMeshElementEditorSetIndex(a1, v22 + 2, 1, Index);
    _C3DMeshElementEditorSetIndex(a1, v22 + 2, 2, a5);
    *(void *)(a1 + 48) += 3;
  }
  else
  {
    uint64_t v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      C3DMeshElementEditorSubdivideTriangleAtIndex_cold_1();
    }
  }
}

uint64_t C3DMeshElementEditorGenerateMeshElement(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementEditorSubdivideTriangleAtIndex_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void *)(a1 + 24);
  if (!v10)
  {
    uint64_t v10 = C3DMeshElementCreate();
    char DoubleSided = C3DMeshElementGetDoubleSided(*(void *)(a1 + 16));
    C3DMeshElementSetDoubleSided(v10, DoubleSided);
    CFDataRef Copy = CFDataCreateCopy(0, *(CFDataRef *)(a1 + 32));
    C3DMeshElementInit(v10, 0, *(void *)(a1 + 48), Copy, *(_DWORD *)(a1 + 40));
    CFRelease(Copy);
    *(void *)(a1 + 24) = v10;
  }
  return v10;
}

void sub_20B3977A8(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C4082928971);
  _Unwind_Resume(a1);
}

void sub_20B397A04(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C4082928971);
  _Unwind_Resume(a1);
}

void SCNCJavaScriptAction::SCNCJavaScriptAction(SCNCJavaScriptAction *this, SCNCAction *a2, NSString *a3)
{
  SCNCAction::SCNCAction((SCNCAction *)this);
  *(void *)uint64_t v6 = &unk_26BF6AF40;
  *(void *)(v6 + 24) = a2->var3;
  *(double *)(v6 + 56) = a2->var7;
  *(_OWORD *)(v6 + 40) = *(_OWORD *)&a2->var5;
  *(_WORD *)(v6 + 80) = *(_WORD *)&a2->var10;
  *(double *)(v6 + 64) = a2->var8;
  *(void *)(v6 + 104) = a2->var14;
  *(unsigned char *)(v6 + 32) = 1;
  if (SCNCJavaScriptAction::SCNCJavaScriptAction(SCNCAction *,NSString *)::onceToken != -1) {
    dispatch_once(&SCNCJavaScriptAction::SCNCJavaScriptAction(SCNCAction *,NSString *)::onceToken, &__block_literal_global_58);
  }
  *((void *)this + 18) = [(NSString *)a3 copy];
}

void sub_20B397BB8(_Unwind_Exception *a1)
{
  SCNCAction::~SCNCAction(v1);
  _Unwind_Resume(a1);
}

void ___ZN20SCNCJavaScriptActionC2EP10SCNCActionP8NSString_block_invoke()
{
  id v0 = NSClassFromString(&cfstr_Jscontext.isa);
  if (v0)
  {
    uint64_t v1 = (JSContext *)objc_alloc_init(v0);
    _uint64_t context = (uint64_t)v1;
    SCNExportJavaScriptModule(v1);
  }
}

void SCNCJavaScriptAction::~SCNCJavaScriptAction(SCNCAction *this)
{
  SCNCAction::~SCNCAction(this);

  JUMPOUT(0x210534FE0);
}

void SCNCJavaScriptAction::cpp_updateWithTargetForTime(SCNCAction *this, SCNNode *a2, double a3)
{
  double v7 = SCNCAction::cpp_ratioForTime(this, a3);
  if (this[1].var0) {
    BOOL v8 = _context == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    double v9 = v7 * this->var1;
    uint64_t v10 = (void *)[(id)_context globalObject];
    objc_msgSend(v10, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", v9), @"elapsedTime");
    [v10 setObject:a2 forKeyedSubscript:@"node"];
    [(id)_context setException:0];
    uint64_t v11 = (void *)[(id)_context evaluateScript:this[1].var0];
    if ([(id)_context exception]) {
      NSLog(&stru_26BF72B18.isa, [v11 toString]);
    }
  }
  float v12 = v7;
  if ((COERCE_UNSIGNED_INT(v12 + -1.0) & 0x60000000) == 0)
  {
    v6.n128_f64[0] = a3;
    SCNCAction::didFinishWithTargetAtTime(this, a2, v6);
  }
}

BOOL C3DGaussianSolve(uint64_t a1, unsigned int a2, int a3, void *a4)
{
  uint64_t v8 = a3;
  bzero(a4, 4 * a3);
  if ((int)a2 < 1)
  {
    BOOL v10 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    BOOL v10 = 0;
    int v11 = 0;
    uint64_t v12 = (a3 + 1);
    uint64_t v13 = 4 * a2;
    uint64_t v14 = 4 * (a2 - 1) * a2;
    uint64_t v15 = v14 + 4;
    uint64_t v16 = 1;
    uint64_t v17 = a1;
    uint64_t v18 = a1;
    do
    {
      unint64_t v19 = v9 + 1;
      uint64_t v20 = v9 * a2;
      if (v9 + 1 >= (unint64_t)a2)
      {
        int v22 = v9;
      }
      else
      {
        uint64_t v21 = 1;
        int v22 = v9;
        do
        {
          if (fabsf(*(float *)(v18 + 4 * v21)) > fabsf(*(float *)(a1 + 4 * (v20 + v22)))) {
            int v22 = v9 + v21;
          }
          ++v21;
        }
        while (v9 - a2 + v21);
      }
      if (v9 != v22 && v9 <= v8)
      {
        uint64_t v23 = 0;
        uint64_t v24 = v17 + 4 * v22;
        uint64_t v25 = v12;
        do
        {
          int v26 = *(_DWORD *)(v18 + v23);
          *(_DWORD *)(v18 + v23) = *(_DWORD *)(v24 + v23);
          *(_DWORD *)(v24 + v23) = v26;
          v23 += v13;
          --v25;
        }
        while (v25);
      }
      uint64_t v27 = v9 + (int)(v11 * a2);
      if (fabsf(*(float *)(a1 + 4 * v27)) >= 0.000001)
      {
        uint64_t v28 = v15;
        uint64_t v29 = v16;
        if (v19 < a2)
        {
          do
          {
            uint64_t v30 = a1;
            uint64_t v31 = a2;
            do
            {
              --v31;
              *(float *)(v30 + v28) = *(float *)(v30 + v28)
                                    - (float)((float)(*(float *)(v30 + v14) * *(float *)(a1 + 4 * (v29 + v20)))
                                            / *(float *)(a1 + 4 * v27));
              v30 -= 4 * a2;
            }
            while (v31 > v9);
            ++v29;
            v28 += 4;
          }
          while (v29 != a2);
        }
      }
      else if (v9 < v8)
      {
        return v10;
      }
      ++v11;
      --v12;
      ++v16;
      v18 += v13 + 4;
      v17 += v13;
      v15 += 4;
      v14 += 4;
      ++v9;
      BOOL v10 = v19 >= a2;
    }
    while (v19 != a2);
  }
  if (a3 >= 1)
  {
    uint64_t v32 = 0;
    uint64_t v33 = a1 + 4 * (v8 + (int)v8 * (uint64_t)(int)a2) - 4;
    uint64_t v34 = 4 * (int)a2;
    uint64_t v35 = v8;
    do
    {
      float v36 = 0.0;
      if (v35 < v8)
      {
        uint64_t v37 = (float *)v33;
        uint64_t v38 = v32;
        do
        {
          float v36 = v36 + (float)(*v37 * *((float *)a4 + v8 + v38));
          uint64_t v37 = (float *)((char *)v37 + v34);
          ++v38;
        }
        while (v38);
      }
      *((float *)a4 + v35 - 1) = (float)(*(float *)(a1 + 4 * (v35 - 1 + (int)(a3 * a2))) - v36)
                               / *(float *)(a1 + 4 * (int)((a2 + 1) * (v35 - 1)));
      --v32;
      v33 += v34 ^ 0xFFFFFFFFFFFFFFFCLL;
    }
    while (v35-- > 1);
  }
  return v10;
}

void C3D::CubeBlurPass::CubeBlurPass(C3D::CubeBlurPass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  C3D::ComputePass::ComputePass(this, a2, a3);
  *(void *)uint64_t v5 = &unk_26BF6CD40;
  uint64_t v6 = *(void *)&a4->var0;
  *(_DWORD *)(v5 + 116) = *(_DWORD *)&a4->var8;
  *(void *)(v5 + 108) = v6;
}

void C3D::CubeBlurPass::setup(C3D::CubeBlurPass *this)
{
  C3D::Pass::setInputCount(this, 1u);

  C3D::Pass::setOutputCount(this, 2u);
}

uint64_t C3D::CubeBlurPass::compile(C3D::CubeBlurPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::CubeBlurPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v3);
  *((void *)this + 15) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::CubeBlurPass::execute(uint64_t a1, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  uint64_t v5 = (void **)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 1u);
  char v6 = 0;
  char v7 = 1;
  do
  {
    char v20 = v7;
    if (v6)
    {
      uint64_t v8 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
      uint64_t v4 = v5;
    }
    else
    {
      uint64_t v8 = (MTLTexture *)v5;
    }
    uint64_t result = [v4 textureType];
    uint64_t v22 = result;
    unint64_t v10 = *(unsigned int *)(a1 + 112);
    if (v10 < *(_DWORD *)(a1 + 116) + (int)v10)
    {
      if (result == 5) {
        unsigned int v11 = 6;
      }
      else {
        unsigned int v11 = 1;
      }
      uint64_t v21 = v4;
      do
      {
        uint64_t v12 = (MTLTexture *)(id)objc_msgSend(v4, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), 5, v10, 1, 0, 6);
        unsigned __int16 v13 = 0;
        unsigned __int16 v23 = 0;
        if (v10) {
          BOOL v14 = 1;
        }
        else {
          BOOL v14 = v22 == 5;
        }
        int v15 = v14;
        uint64_t v16 = v8;
        do
        {
          uint64_t v17 = 16;
          if (v6) {
            uint64_t v17 = 64;
          }
          uint64_t v18 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](*(void *)(*(void *)(a1 + 120) + v17 + 8 * v13));
          if (v3->_computePipelineState != (MTLComputePipelineState *)v18)
          {
            v3->_computePipelineState = (MTLComputePipelineState *)v18;
            [(MTLComputeCommandEncoder *)v3->_encoder setComputePipelineState:v18];
          }
          if (v15)
          {
            uint64_t v19 = [(MTLTexture *)v8 pixelFormat];
            uint64_t v16 = (MTLTexture *)(id)-[MTLTexture newTextureViewWithPixelFormat:textureType:levels:slices:](v8, "newTextureViewWithPixelFormat:textureType:levels:slices:", v19, 2, v10, 1, v23, 1);
          }
          SCNMTLComputeCommandEncoder::setBytes(v3, &v23, 2uLL, 0);
          if (v3->_textures[0] != v16)
          {
            v3->_textures[0] = v16;
            v3->_texturesToBind[0] |= 1uLL;
          }
          if (v3->_textures[1] != v12)
          {
            v3->_textures[1] = v12;
            v3->_texturesToBind[0] |= 2uLL;
          }
          uint64_t result = SCNMTLComputeCommandEncoder::dispatchOnGrid2D(v3, [(MTLTexture *)v16 width], [(MTLTexture *)v16 height]);
          unsigned __int16 v13 = v23 + 1;
          unsigned __int16 v23 = v13;
        }
        while (v11 > v13);
        ++v10;
        uint64_t v4 = v21;
      }
      while (v10 < (*(_DWORD *)(a1 + 116) + *(_DWORD *)(a1 + 112)));
    }
    char v7 = 0;
    char v6 = 1;
    uint64_t v5 = (void **)v8;
  }
  while ((v20 & 1) != 0);
  return result;
}

const char *C3D::CubeBlurPass::name(C3D::CubeBlurPass *this)
{
  return "CubeBlurPass";
}

void C3D::CubeBlurPass::Resource::~Resource(C3D::CubeBlurPass::Resource *this)
{
  *(void *)this = &unk_26BF6CD20;
  for (uint64_t i = 104; i != 56; i -= 8)
  {
    uint64_t v3 = *(void **)((char *)this + i);
    if (v3) {
  }
    }
  do
  {
    uint64_t v4 = *(void **)((char *)this + i);
    if (v4) {

    }
    i -= 8;
  }
  while (i != 8);
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_26BF6CD20;
  uint64_t v2 = 104;
  while (1)
  {
    uint64_t v3 = *(void **)((char *)this + v2);
    if (v3) {

    }
    v2 -= 8;
    if (v2 == 56)
    {
      while (1)
      {
        uint64_t v4 = *(void **)((char *)this + v2);
        if (v4) {

        }
        v2 -= 8;
        if (v2 == 8)
        {
          JUMPOUT(0x210534FE0);
        }
      }
    }
  }
}

void *reorder<__C3DNode *>(void *a1, __int16 *a2, int a3)
{
  uint64_t v5 = a1;
  v16[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x270FA5388](a1);
  unint64_t v10 = (char *)v16 - v9;
  if (v8 >= 0x200) {
    unint64_t v8 = 512;
  }
  BOOL v11 = v8 >= 8 * v7;
  size_t v12 = v8 - 8 * v7;
  if (v11) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = 0;
  }
  bzero(&v10[8 * v7], v13);
  uint64_t result = memcpy(v10, v5, 8 * a3);
  if (a3 >= 1)
  {
    do
    {
      uint64_t v15 = *a2++;
      *v5++ = *(void *)&v10[8 * v15];
      --v6;
    }
    while (v6);
  }
  return result;
}

__n128 reorder<scn_sphere>(__n128 *a1, __int16 *a2, int a3)
{
  uint64_t v5 = a1;
  v10[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x270FA5388](a1);
  int v7 = &v10[-2 * v6];
  memcpy(v7, v5, 16 * a3);
  if (a3 >= 1)
  {
    do
    {
      uint64_t v9 = *a2++;
      __n128 result = *(__n128 *)&v7[2 * v9];
      *v5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

__n128 reorder<scn_cone>(_OWORD *a1, __int16 *a2, int a3)
{
  uint64_t v5 = a1;
  v14[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x270FA5388](a1);
  unint64_t v8 = &v14[-2 * v7];
  memcpy(v8, v5, 48 * v9);
  if (a3 >= 1)
  {
    do
    {
      int v11 = *a2++;
      size_t v12 = &v8[6 * v11];
      long long v13 = *((_OWORD *)v12 + 1);
      *uint64_t v5 = *(_OWORD *)v12;
      v5[1] = v13;
      __n128 result = *((__n128 *)v12 + 2);
      v5[2] = result;
      v5 += 3;
      --v6;
    }
    while (v6);
  }
  return result;
}

__n128 reorder<scn_obb>(_OWORD *a1, __int16 *a2, int a3)
{
  uint64_t v5 = a1;
  v14[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x270FA5388](a1);
  unint64_t v8 = &v14[-2 * v7];
  memcpy(v8, v5, 80 * v9);
  if (a3 >= 1)
  {
    do
    {
      int v11 = *a2++;
      size_t v12 = &v8[10 * v11];
      long long v13 = *((_OWORD *)v12 + 3);
      v5[2] = *((_OWORD *)v12 + 2);
      v5[3] = v13;
      v5[4] = *((_OWORD *)v12 + 4);
      __n128 result = *((__n128 *)v12 + 1);
      *uint64_t v5 = *(_OWORD *)v12;
      v5[1] = result;
      v5 += 5;
      --v6;
    }
    while (v6);
  }
  return result;
}

void *___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke(void *result, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v5 = *(unsigned int *)(*(void *)(result[4] + 8) + 24);
      if (v5 > 0xFF) {
        break;
      }
      uint64_t v6 = *a4++;
      *(void *)(result[5] + 8 * v5) = v6;
      uint64_t v7 = *a3++;
      uint64_t v8 = result[6];
      uint64_t v9 = *(void *)(result[4] + 8);
      uint64_t v10 = *(unsigned int *)(v9 + 24);
      *(_DWORD *)(v9 + 24) = v10 + 1;
      *(void *)(v8 + 8 * v10) = v7;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_2(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      uint64_t v6 = 0;
      uint64_t v7 = *(void *)(a5 + 16 * i);
      uint64_t v8 = *(void *)(a5 + 16 * i + 8);
      long long v9 = *(_OWORD *)(result + 80);
      v21[2] = *(_OWORD *)(result + 64);
      v21[3] = v9;
      long long v10 = *(_OWORD *)(result + 112);
      v21[4] = *(_OWORD *)(result + 96);
      v21[5] = v10;
      long long v11 = *(_OWORD *)(result + 48);
      v21[0] = *(_OWORD *)(result + 32);
      v21[1] = v11;
      v12.i64[0] = v7;
      v12.i64[1] = v8;
      while (1)
      {
        float32x4_t v13 = (float32x4_t)v21[v6];
        float32x4_t v14 = vmulq_f32(v13, v12);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1)))).f32[0] < (float)-*((float *)&v8 + 1))break; {
        if (++v6 == 6)
        }
        {
          unsigned int v15 = *(_DWORD *)(*(void *)(*(void *)(result + 128) + 8) + 24);
          if (v15 > 0xFF) {
            return result;
          }
          uint64_t v16 = (uint64_t *)(*(void *)(result + 136) + 16 * (v15 - *(_DWORD *)(result + 160)));
          uint64_t *v16 = v7;
          v16[1] = v8;
          *(void *)(*(void *)(result + 144)
                    + 8 * *(unsigned int *)(*(void *)(*(void *)(result + 128) + 8) + 24)) = *(void *)(a4 + 8 * i);
          uint64_t v17 = *(void *)(a3 + 8 * i);
          uint64_t v18 = *(void *)(result + 152);
          uint64_t v19 = *(void *)(*(void *)(result + 128) + 8);
          uint64_t v20 = *(unsigned int *)(v19 + 24);
          *(_DWORD *)(v19 + 24) = v20 + 1;
          *(void *)(v18 + 8 * v20) = v17;
          break;
        }
      }
    }
  }
  return result;
}

void ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_3(uint64_t a1, uint64_t *a2)
{
  Particlessize_t Count = C3DParticleSystemInstanceGetParticlesCount((uint64_t)a2);
  uint64_t v5 = a2[63];
  uint64_t v6 = a2[71];
  float32x4_t v27 = *(float32x4_t *)C3DParticleSystemGetParticleColor(a2[6]);
  Particlefloat Intensity = C3DParticleSystemGetParticleIntensity(a2[6]);
  float ParticleSize = C3DParticleSystemGetParticleSize(a2[6]);
  uint64_t v8 = a2[70];
  float LightEmissionRadiusFactor = C3DParticleSystemGetLightEmissionRadiusFactor(a2[6]);
  if (ParticlesCount)
  {
    uint64_t v10 = 0;
    float32x4_t v11 = vmulq_n_f32(v27, ParticleIntensity);
    float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3A83126Fu);
    do
    {
      if (v8) {
        float ParticleSize = *(float *)(v8 + 4 * v10);
      }
      uint64_t v13 = 0;
      float32x4_t v14 = *(float32x4_t *)(v5 + 16 * v10);
      float32x4_t v15 = v14;
      long long v16 = *(_OWORD *)(a1 + 80);
      v28[2] = *(_OWORD *)(a1 + 64);
      v28[3] = v16;
      long long v17 = *(_OWORD *)(a1 + 112);
      v28[4] = *(_OWORD *)(a1 + 96);
      v28[5] = v17;
      long long v18 = *(_OWORD *)(a1 + 48);
      v28[0] = *(_OWORD *)(a1 + 32);
      v28[1] = v18;
      while (1)
      {
        float32x4_t v19 = (float32x4_t)v28[v13];
        float32x4_t v20 = vmulq_f32(v14, v19);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1)))).f32[0] < (float)-(float)(LightEmissionRadiusFactor * ParticleSize))break; {
        if (++v13 == 6)
        }
        {
          unsigned int v21 = *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24);
          if (v21 > 0xFF) {
            return;
          }
          v15.f32[3] = LightEmissionRadiusFactor * ParticleSize;
          *(float32x4_t *)(*(void *)(a1 + 136) + 16 * (v21 - *(_DWORD *)(a1 + 168))) = v15;
          float32x4_t v22 = v11;
          if (v6) {
            float32x4_t v22 = *(float32x4_t *)(v6 + 16 * v10);
          }
          *(float32x4_t *)(*(void *)(a1 + 144)
                         + 16 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = vmulq_f32(v22, v12);
          *(void *)(*(void *)(a1 + 152) + 8 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = 0;
          uint64_t v23 = *(void *)(a1 + 160);
          uint64_t v24 = *(void *)(*(void *)(a1 + 128) + 8);
          uint64_t v25 = *(unsigned int *)(v24 + 24);
          *(_DWORD *)(v24 + 24) = v25 + 1;
          *(void *)(v23 + 8 * v25) = 0;
          break;
        }
      }
      ++v10;
    }
    while (v10 != ParticlesCount);
  }
}

void ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = (_OWORD *)(a1 + 32);
    __asm { FMOV            V0.4S, #1.0 }
    int8x16_t v50 = _Q0;
    uint64_t v16 = a2;
    do
    {
      if ((C3DLightGetCastsShadow(*(void *)(a4 + 8 * v9)) & 1) == 0
        && (C3DLightHasValidGobo(*(void *)(a4 + 8 * v9)) & 1) == 0
        && C3DLightGetAttenuationEndDistance(*(void *)(a4 + 8 * v9)) > 0.0)
      {
        uint64_t v17 = 0;
        uint64_t v18 = a5 + 48 * v9;
        float32x4_t v19 = *(float32x4_t *)v18;
        float32x4_t v20 = *(float32x4_t *)(v18 + 16);
        int32x2_t v21 = *(int32x2_t *)(v18 + 32);
        uint64_t v22 = *(void *)(v18 + 40);
        long long v23 = v10[3];
        v51[2] = v10[2];
        v51[3] = v23;
        long long v24 = v10[5];
        v51[4] = v10[4];
        v51[5] = v24;
        long long v25 = v10[1];
        v51[0] = *v10;
        v51[1] = v25;
        float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL);
        float32x4_t v27 = vmlaq_n_f32(v19, v20, *(float *)v21.i32);
        float32x4_t v28 = (float32x4_t)vdupq_lane_s32(v21, 1);
        while (1)
        {
          float32x4_t v29 = (float32x4_t)v51[v17];
          float32x4_t v30 = vmulq_f32(v19, v29);
          float v31 = v29.f32[3];
          v30.f32[0] = v29.f32[3]
                     + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
          int8x16_t v32 = (int8x16_t)vmlaq_f32(vmulq_f32(v26, vnegq_f32(v29)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL));
          float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), v32, 0xCuLL);
          float32x4_t v34 = vmlaq_f32(vmulq_f32(v26, vnegq_f32(v33)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL));
          float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL);
          float32x4_t v36 = vmulq_f32(v34, v34);
          v36.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v36)).u64[0];
          float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 0);
          float32x4_t v38 = vrsqrteq_f32(v37);
          float32x4_t v39 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
          int32x4_t v40 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v36.f32[0] != 0.0)), 0x1FuLL));
          v40.i32[3] = 0;
          float32x4_t v41 = vmulq_f32(v29, vmlsq_f32(v27, v28, vmulq_f32(v35, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v40), (int8x16_t)vmulq_f32(v39, vrsqrtsq_f32(v37, vmulq_f32(v39, v39))), v50))));
          v41.f32[0] = v31
                     + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0];
          float v42 = v30.f32[0] * v41.f32[0];
          float v43 = fminf(v30.f32[0], v41.f32[0]);
          if (v42 < 0.0) {
            float v43 = 0.0;
          }
          if (v43 < 0.0) {
            break;
          }
          if (++v17 == 6)
          {
            unsigned int v44 = *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24);
            if (v44 > 0xFF) {
              return;
            }
            uint64_t v45 = *(void *)(a1 + 136) + 48 * (v44 - *(_DWORD *)(a1 + 160));
            *(float32x4_t *)uint64_t v45 = v19;
            *(float32x4_t *)(v45 + 16) = v20;
            *(int32x2_t *)(v45 + 32) = v21;
            *(void *)(v45 + 40) = v22;
            *(void *)(*(void *)(a1 + 144) + 8 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = *(void *)(a4 + 8 * v9);
            uint64_t v46 = *(void *)(a3 + 8 * v9);
            uint64_t v47 = *(void *)(a1 + 152);
            uint64_t v48 = *(void *)(*(void *)(a1 + 128) + 8);
            uint64_t v49 = *(unsigned int *)(v48 + 24);
            *(_DWORD *)(v48 + 24) = v49 + 1;
            *(void *)(v47 + 8 * v49) = v46;
            break;
          }
        }
      }
      ++v9;
    }
    while (v9 != v16);
  }
}

void ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_5(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)((char *)&v44[1] + 4) = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = (_OWORD *)(a1 + 32);
    uint64_t v11 = a2;
    do
    {
      if (C3DLightGetProbeType(*(void *)(a4 + 8 * v9)) != 1)
      {
        float32x4_t v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_5_cold_1(v43, v44, v12);
        }
      }
      if (C3DLightGetIntensity(*(void *)(a4 + 8 * v9)) > 0.0)
      {
        uint64_t ProbeEnvironment = C3DLightGetProbeEnvironment(*(void *)(a4 + 8 * v9), 0);
        if (!ProbeEnvironment || C3DEffectSlotGetIntensity(ProbeEnvironment) > 0.0)
        {
          uint64_t v15 = 0;
          uint64_t v16 = (float32x4_t *)(a5 + 80 * v9);
          float32x4_t v17 = *v16;
          float32x4_t v18 = v16[1];
          float32x4_t v19 = v16[2];
          float32x4_t v20 = v16[3];
          float32x4_t v21 = v16[4];
          *(float *)v14.i32 = fmaxf(fmaxf(v21.f32[0], COERCE_FLOAT(v16[4].i64[1])), COERCE_FLOAT(HIDWORD(v16[4].i64[0])))* 0.1;
          float32x4_t v22 = vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(v14, 0));
          v22.i32[3] = v21.i32[3];
          long long v23 = v10[3];
          v42[2] = v10[2];
          v42[3] = v23;
          long long v24 = v10[5];
          v42[4] = v10[4];
          v42[5] = v24;
          long long v25 = v10[1];
          v42[0] = *v10;
          v42[1] = v25;
          while (1)
          {
            float32x4_t v26 = (float32x4_t)v42[v15];
            int32x4_t v27 = (int32x4_t)vmulq_f32(v18, v26);
            int32x4_t v28 = (int32x4_t)vmulq_f32(v19, v26);
            int32x4_t v29 = (int32x4_t)vmulq_f32(v20, v26);
            int32x4_t v30 = (int32x4_t)vmulq_f32(v17, v26);
            int32x4_t v31 = vzip1q_s32(v27, v29);
            int32x4_t v32 = vzip2q_s32(v27, v29);
            int32x4_t v33 = vzip1q_s32(v28, v30);
            int32x4_t v34 = vzip2q_s32(v28, v30);
            float32x4_t v35 = vaddq_f32((float32x4_t)vzip2q_s32(v32, v34), vaddq_f32((float32x4_t)vzip1q_s32(v32, v34), vaddq_f32((float32x4_t)vzip1q_s32(v31, v33), (float32x4_t)vzip2q_s32(v31, v33))));
            float32x4_t v36 = vabsq_f32(vmulq_f32(v22, v35));
            if (v35.f32[3] <= (float)-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1), v36)).f32[0])break; {
            if (++v15 == 6)
            }
            {
              float32x4_t v37 = (float32x4_t *)(*(void *)(a1 + 136)
                                  + 80
                                  * (*(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)
                                                 - *(_DWORD *)(a1 + 160)));
              float32x4_t *v37 = v17;
              v37[1] = v18;
              v37[2] = v19;
              v37[3] = v20;
              v37[4] = v22;
              *(void *)(*(void *)(a1 + 144)
                        + 8 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = *(void *)(a4 + 8 * v9);
              uint64_t v38 = *(void *)(a3 + 8 * v9);
              uint64_t v39 = *(void *)(a1 + 152);
              uint64_t v40 = *(void *)(*(void *)(a1 + 128) + 8);
              uint64_t v41 = *(unsigned int *)(v40 + 24);
              *(_DWORD *)(v40 + 24) = v41 + 1;
              *(void *)(v39 + 8 * v41) = v38;
              if (*(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24) > 0xFFu) {
                return;
              }
              break;
            }
          }
        }
      }
      ++v9;
    }
    while (v9 != v11);
  }
}

float32x4_t __computeFrustumExtrema(float32x4_t *a1, unsigned int a2, unsigned int a3, unsigned __int32 a4, float32x4_t *a5, uint32x4_t a6)
{
  a6.i64[0] = __PAIR64__(a3, a2);
  a6.i32[2] = a4;
  float32x4_t v6 = a1[1];
  float32x4_t v7 = vmulq_f32(v6, vcvtq_f32_u32(a6));
  float32x4_t result = vaddq_f32(v6, v7);
  float32x4_t v9 = vmlaq_laneq_f32(a1[35], vsubq_f32(a1[39], a1[35]), v7, 2);
  float32x4_t v10 = vmlaq_laneq_f32(a1[36], vsubq_f32(a1[40], a1[36]), v7, 2);
  float32x4_t v11 = vsubq_f32(vmlaq_laneq_f32(a1[33], vsubq_f32(a1[37], a1[33]), v7, 2), v9);
  float32x4_t v12 = vmlaq_lane_f32(v9, v11, *(float32x2_t *)v7.f32, 1);
  float32x4_t v13 = vsubq_f32(vmlaq_laneq_f32(a1[34], vsubq_f32(a1[38], a1[34]), v7, 2), v10);
  float32x4_t v14 = vmlaq_lane_f32(v9, v11, *(float32x2_t *)result.f32, 1);
  float32x4_t v15 = vsubq_f32(vmlaq_lane_f32(v10, v13, *(float32x2_t *)v7.f32, 1), v12);
  *a5 = vmlaq_n_f32(v12, v15, v7.f32[0]);
  a5[1] = vmlaq_n_f32(v12, v15, result.f32[0]);
  float32x4_t v16 = vsubq_f32(vmlaq_lane_f32(v10, v13, *(float32x2_t *)result.f32, 1), v14);
  a5[2] = vmlaq_n_f32(v14, v16, v7.f32[0]);
  a5[3] = vmlaq_n_f32(v14, v16, result.f32[0]);
  float32x4_t v17 = vmlaq_laneq_f32(a1[35], vsubq_f32(a1[39], a1[35]), result, 2);
  float32x4_t v18 = vmlaq_laneq_f32(a1[36], vsubq_f32(a1[40], a1[36]), result, 2);
  float32x4_t v19 = vsubq_f32(vmlaq_laneq_f32(a1[33], vsubq_f32(a1[37], a1[33]), result, 2), v17);
  float32x4_t v20 = vmlaq_lane_f32(v17, v19, *(float32x2_t *)v7.f32, 1);
  float32x4_t v21 = vsubq_f32(vmlaq_laneq_f32(a1[34], vsubq_f32(a1[38], a1[34]), result, 2), v18);
  float32x4_t v22 = vmlaq_lane_f32(v17, v19, *(float32x2_t *)result.f32, 1);
  float32x4_t v23 = vsubq_f32(vmlaq_lane_f32(v18, v21, *(float32x2_t *)v7.f32, 1), v20);
  a5[4] = vmlaq_n_f32(v20, v23, v7.f32[0]);
  a5[5] = vmlaq_n_f32(v20, v23, result.f32[0]);
  float32x4_t v24 = vsubq_f32(vmlaq_lane_f32(v18, v21, *(float32x2_t *)result.f32, 1), v22);
  a5[6] = vmlaq_n_f32(v22, v24, v7.f32[0]);
  a5[7] = vmlaq_n_f32(v22, v24, result.f32[0]);
  return result;
}

uint64_t __append(uint64_t a1, void *__src, size_t __n)
{
  int v3 = __n;
  *(void *)&v35[5] = *MEMORY[0x263EF8340];
  size_t v6 = __n;
  unsigned int v7 = *(_DWORD *)(a1 + 512);
  unsigned int v8 = v7 + __n;
  size_t v9 = *(unsigned int *)(a1 + 516);
  unsigned int v10 = v7;
  if (v8 >= v9)
  {
    if (v9) {
      int v11 = *(_DWORD *)(a1 + 516);
    }
    else {
      int v11 = 4096;
    }
    do
    {
      unsigned int v12 = v11;
      v11 *= 2;
    }
    while (v12 < v8);
    *(void *)(a1 + 504) = C3DStackAllocatorReallocate(*(void *)(a1 + 2784), *(void *)(a1 + 504), v9, v12, 16);
    *(void *)(a1 + 656) = C3DStackAllocatorReallocate(*(void *)(a1 + 2784), *(void *)(a1 + 656), 4 * *(unsigned int *)(a1 + 516), 4 * v12, 16);
    *(_DWORD *)(a1 + 516) = v12;
    unsigned int v10 = *(_DWORD *)(a1 + 512);
  }
  memcpy((void *)(*(void *)(a1 + 504) + v10), __src, v6);
  uint64_t v13 = *(unsigned int *)(a1 + 512);
  if (v13 < v8)
  {
    int v14 = v7 + v3 - v13;
    do
    {
      uint64_t v15 = *(void *)(a1 + 504);
      uint64_t v16 = *(unsigned __int8 *)(v15 + v13);
      uint64_t v17 = a1 + 4 * v16;
      int v18 = *(_DWORD *)(v17 + 664);
      if (v18)
      {
        if (*(unsigned __int8 *)(v15 + (v18 - 1)) != v16)
        {
          float32x4_t v19 = scn_default_log();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
            __append(v34, v35, v19);
          }
        }
        uint64_t v20 = a1 + 4 * v16;
        int v21 = *(_DWORD *)(v20 + 1688);
        if (!v21)
        {
          float32x4_t v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            __append(v32, &v33, v22);
          }
        }
        uint64_t v23 = (v21 - 1);
        if (*(unsigned __int8 *)(*(void *)(a1 + 504) + v23) != v16)
        {
          float32x4_t v24 = scn_default_log();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
            __append(v30, &v31, v24);
          }
        }
        uint64_t v25 = *(void *)(a1 + 656);
        *(_DWORD *)(v25 + 4 * v23) = v13 + 1;
        *(_DWORD *)(v25 + 4 * v13) = 0;
        *(_DWORD *)(v20 + 1688) = v13 + 1;
        if (*(_DWORD *)(v25 + 4 * v13) > v8)
        {
          float32x4_t v26 = scn_default_log();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
            __append(v28, &v29, v26);
          }
        }
      }
      else
      {
        *(_DWORD *)(v17 + 664) = v13 + 1;
        *(_DWORD *)(a1 + 4 * v16 + 1688) = v13 + 1;
        *(_DWORD *)(*(void *)(a1 + 656) + 4 * v13) = 0;
      }
      ++v13;
      --v14;
    }
    while (v14);
    LODWORD(v13) = *(_DWORD *)(a1 + 512);
  }
  *(_DWORD *)(a1 + 512) = v8;
  return (unsigned __int16)v13;
}

uint64_t __addFroxelLightIndicesInBuffer(uint64_t a1, unsigned __int8 *__src, size_t __n)
{
  *(void *)&v17[5] = *MEMORY[0x263EF8340];
  unsigned int v6 = *(_DWORD *)(a1 + 4 * *__src + 664);
  if (v6)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 512);
    uint64_t v8 = __n - 1;
    while (1)
    {
      uint64_t v9 = v6 - 1;
      if (__n < 2)
      {
        int v13 = 1;
      }
      else
      {
        uint64_t v10 = 0;
        unsigned int v11 = v7 - v6;
        if (v7 < v6) {
          unsigned int v11 = 0;
        }
        uint64_t v12 = v11 + 1 - 1;
        while (v12 != v10 && *(unsigned __int8 *)(*(void *)(a1 + 504) + v6 + v10) == __src[v10 + 1])
        {
          if (v8 == ++v10) {
            return (unsigned __int16)v9;
          }
        }
        int v13 = v10 + 1;
      }
      if (v13 == __n) {
        break;
      }
      if (*(_DWORD *)(*(void *)(a1 + 656) + 4 * v9) > v7)
      {
        int v14 = scn_default_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
          __addFroxelLightIndicesInBuffer(v16, v17, v14);
        }
      }
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 656) + 4 * v9);
      if (!v6) {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    LOWORD(v9) = __append(a1, __src, __n);
  }
  return (unsigned __int16)v9;
}

uint64_t __appendUnoptimized(uint64_t a1, char **a2, void *__src, size_t __n)
{
  unsigned int v4 = __n;
  int v8 = *((_DWORD *)a2 + 2);
  size_t v7 = *((unsigned int *)a2 + 3);
  unsigned int v9 = v8 + __n;
  if (v8 + (int)__n >= v7)
  {
    if (v7) {
      int v11 = *((_DWORD *)a2 + 3);
    }
    else {
      int v11 = 4096;
    }
    do
    {
      unsigned int v12 = v11;
      v11 *= 2;
    }
    while (v12 < v9);
    uint64_t v10 = (char *)C3DStackAllocatorReallocate(a1, (unint64_t)*a2, v7, v12, 16);
    *a2 = v10;
    *((_DWORD *)a2 + 3) = v12;
    int v8 = *((_DWORD *)a2 + 2);
  }
  else
  {
    uint64_t v10 = *a2;
  }
  memcpy(&v10[v8], __src, v4);
  uint64_t result = *((unsigned __int16 *)a2 + 4);
  *((_DWORD *)a2 + 2) = v9;
  return result;
}

_DWORD *__radixSortDecreasingNonZero(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a3;
  bzero(v19, 0x400uLL);
  unsigned int v7 = 0;
  if (v6)
  {
    uint64_t v8 = v6;
    unsigned int v9 = a2;
    do
    {
      unsigned int v11 = *v9++;
      uint64_t v10 = v11;
      if (v11) {
        ++v7;
      }
      ++v19[v10];
      --v8;
    }
    while (v8);
  }
  bzero(v18, 0x400uLL);
  uint64_t v12 = 0;
  int v13 = 0;
  do
  {
    v13 += v19[v12];
    v18[++v12] = v13;
  }
  while (v12 != 255);
  uint64_t result = C3DStackAllocatorAllocate(a1, 4 * v7);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v16 = a2[i];
      if (v16)
      {
        int v17 = v18[v16];
        v18[v16] = v17 + 1;
        result[(v6 + ~v17)] = i;
      }
    }
  }
  *a3 = v7;
  return result;
}

uint64_t __compactLightIndices(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)&void v24[5] = *MEMORY[0x263EF8340];
  int v6 = *(_DWORD *)a1 * *(_DWORD *)(a1 + 4);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = (v6 * v7);
  int v22 = v6 * v7;
  unsigned int v9 = (unsigned int *)C3DStackAllocatorAllocate(*(void *)(a1 + 2784), 4 * v8);
  uint64_t v10 = v9;
  if (v8)
  {
    if (a3 != 8 && a3 != 4) {
      __compactLightIndices();
    }
    unint64_t v11 = 0;
    do
    {
      if (a3 == 8) {
        int v12 = HIBYTE(*(unsigned __int16 *)(a2 + 2 * v11 + 2))
      }
            + *(_WORD *)(a2 + 2 * v11 + 2)
            + *(unsigned __int8 *)(a2 + 2 * v11 + 4);
      else {
        int v12 = HIBYTE(*(unsigned __int16 *)(a2 + v11 + 2)) + *(_WORD *)(a2 + v11 + 2);
      }
      v9[v11 / 4] = v12;
      v11 += 4;
      --v8;
    }
    while (v8);
  }
  uint64_t result = (uint64_t)__radixSortDecreasingNonZero(*(void *)(a1 + 2784), v9, (unsigned int *)&v22);
  uint64_t v14 = v22;
  if (v22)
  {
    uint64_t v15 = (unsigned int *)result;
    do
    {
      unsigned int v17 = *v15++;
      uint64_t v16 = v17;
      size_t v18 = v10[v17];
      if (!v18)
      {
        float32x4_t v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          __compactLightIndices(v23, v24, v19);
        }
      }
      if (a3 == 8)
      {
        uint64_t v20 = 8 * v16;
        int v21 = (unsigned __int8 *)(*(void *)(a1 + 488) + (unsigned __int16)*(void *)(a2 + 8 * v16));
      }
      else
      {
        if (a3 != 4) {
          __compactLightIndices();
        }
        uint64_t v20 = 4 * v16;
        int v21 = (unsigned __int8 *)(*(void *)(a1 + 488) + *(unsigned __int16 *)(a2 + 4 * v16));
      }
      uint64_t result = __addFroxelLightIndicesInBuffer(a1, v21, v18);
      *(_WORD *)(a2 + v20) = result;
      --v14;
    }
    while (v14);
  }
  return result;
}

float32x4_t *__computeLightsFlagsForAxis(float32x4_t *result, unsigned int a2)
{
  uint64_t v2 = &result->i32[a2 & 3];
  __int32 v3 = *v2;
  if (*v2)
  {
    unsigned int v4 = result;
    int v5 = 0;
    int v6 = (const float *)(v2 + 4);
    float32x4_t v7 = vld1q_dup_f32(v6);
    float32x4_t v52 = v7;
    float32x4_t v53 = result[((2 * a2) | 1) + 2];
    float32x4_t v8 = 0uLL;
    float32x4_t v51 = vsubq_f32(vnegq_f32(result[2 * a2 + 2]), v53);
    float32x4_t v9 = vmlaq_f32(v53, (float32x4_t)0, v51);
    int32x4_t v10 = (int32x4_t)vmulq_f32(v9, v9);
    v10.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))).u32[0];
    *(float32x2_t *)v7.f32 = vrsqrte_f32((float32x2_t)v10.u32[0]);
    *(float32x2_t *)v7.f32 = vmul_f32(*(float32x2_t *)v7.f32, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32)));
    int32x4_t v11 = (int32x4_t)vmulq_n_f32(v9, vmul_f32(*(float32x2_t *)v7.f32, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32))).f32[0]);
    int v12 = (uint64_t *)&result[171] + a2;
    uint64_t v13 = result[9].i64[0] + 32;
    do
    {
      uint64_t v14 = *v12;
      __int32 v15 = v4[173].i32[2];
      float32x4_t v56 = (float32x4_t)v11;
      float32x4_t v57 = vaddq_f32(v52, v8);
      float32x4_t v16 = vmlaq_f32(v53, v51, v57);
      int32x4_t v17 = (int32x4_t)vmulq_f32(v16, v16);
      v17.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v17, 2), vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.i8, 1))).u32[0];
      float32x2_t v18 = vrsqrte_f32((float32x2_t)v17.u32[0]);
      float32x2_t v19 = vmul_f32(v18, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v18, v18)));
      float32x4_t v55 = vmulq_n_f32(v16, vmul_f32(v19, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v19, v19))).f32[0]);
      v59[0] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0);
      v59[1] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 1);
      v59[2] = (float32x4_t)vdupq_laneq_s32(v11, 2);
      v59[3] = (float32x4_t)vdupq_laneq_s32(v11, 3);
      float32x4_t v54 = vnegq_f32(v55);
      uint64_t v20 = (char *)(v14 + 4 * (v15 * v5));
      v58[0] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0);
      v58[1] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1);
      v58[2] = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2);
      v58[3] = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
      bzero(v20, (4 * v15));
      scn_sphere_x4_filter((float32x4_t *)v4[9].i64[1], v4[10].i32[0], v59, v58, v4[10].i64[1]);
      memcpy(&v20[4 * v4[169].i64[1]], (const void *)v4[10].i64[1], v4[11].u32[0]);
      scn_cone_x4_filter((float32x4_t *)v4[11].i64[1], v4[12].i32[0], v59, v58, v4[12].i64[1]);
      uint64_t result = (float32x4_t *)memcpy(&v20[4 * v4[170].i64[0]], (const void *)v4[12].i64[1], v4[13].u32[0]);
      uint64_t v21 = v4[170].u32[3];
      if ((int)v21 >= 1)
      {
        uint64_t v22 = 0;
        uint64_t v23 = (float32x4_t *)v13;
        do
        {
          float32x4_t v24 = v23[-2];
          float32x4_t v25 = v23[-1];
          float32x4_t v26 = v23[1];
          float32x4_t v27 = v23[2];
          int32x4_t v28 = (int32x4_t)vmulq_f32(v56, v25);
          int32x4_t v29 = (int32x4_t)vmulq_f32(v56, *v23);
          int32x4_t v30 = (int32x4_t)vmulq_f32(v56, v26);
          int32x4_t v31 = (int32x4_t)vmulq_f32(v56, v24);
          int32x4_t v32 = vzip1q_s32(v28, v30);
          int32x4_t v33 = vzip2q_s32(v28, v30);
          int32x4_t v34 = vzip1q_s32(v29, v31);
          int32x4_t v35 = vzip2q_s32(v29, v31);
          float32x4_t v36 = vaddq_f32((float32x4_t)vzip2q_s32(v33, v35), vaddq_f32((float32x4_t)vzip1q_s32(v33, v35), vaddq_f32((float32x4_t)vzip1q_s32(v32, v34), (float32x4_t)vzip2q_s32(v32, v34))));
          float32x4_t v37 = vabsq_f32(vmulq_f32(v27, v36));
          BOOL v49 = v36.f32[3] > (float)-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1), v37)).f32[0];
          int32x4_t v38 = (int32x4_t)vmulq_f32(v25, v54);
          int32x4_t v39 = (int32x4_t)vmulq_f32(*v23, v54);
          int32x4_t v40 = (int32x4_t)vmulq_f32(v26, v54);
          int32x4_t v41 = (int32x4_t)vmulq_f32(v24, v54);
          int32x4_t v42 = vzip1q_s32(v38, v40);
          int32x4_t v43 = vzip2q_s32(v38, v40);
          int32x4_t v44 = vzip1q_s32(v39, v41);
          int32x4_t v45 = vzip2q_s32(v39, v41);
          float32x4_t v46 = vaddq_f32((float32x4_t)vzip2q_s32(v43, v45), vaddq_f32((float32x4_t)vzip1q_s32(v43, v45), vaddq_f32((float32x4_t)vzip1q_s32(v42, v44), (float32x4_t)vzip2q_s32(v42, v44))));
          float32x4_t v47 = vabsq_f32(vmulq_f32(v27, v46));
          float v48 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1), v47)).f32[0];
          BOOL v49 = v49 && v46.f32[3] > v48;
          if (v49)
          {
            int8x16_t v50 = &v20[4 * v4[170].i64[1]];
            v50[v22 >> 3] |= 1 << (v22 & 7);
          }
          ++v22;
          v23 += 5;
        }
        while (v21 != v22);
      }
      ++v5;
      int32x4_t v11 = (int32x4_t)v55;
      float32x4_t v8 = v57;
    }
    while (v5 != v3);
  }
  return result;
}

void SCNMTLClusterSystem::displayInfoDebug(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  unsigned int v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v107 = *MEMORY[0x263EF8340];
  AuthoringEnvironment = (uint64_t *)C3DEngineContextGetAuthoringEnvironment(v5, 0);
  if (!AuthoringEnvironment || !v2[1].i64[1]) {
    return;
  }
  unint64_t v67 = v4;
  uint64_t v68 = v6;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v6);
  unsigned int v74 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  unsigned int v12 = [(id)v2[1].i64[1] width];
  unsigned int v13 = [(id)v2[1].i64[1] height];
  unsigned int v14 = [(id)v2[1].i64[1] depth];
  uint64_t v15 = 0;
  float32x4_t v66 = v2[3];
  unsigned int v69 = v14;
  char v70 = v2 + 6;
  float32x4_t v16 = &v2[5].i64[1];
  unsigned int v79 = v13;
  uint64_t v72 = v8;
  float v73 = v2;
  uint64_t v71 = &v2[5].i64[1];
  do
  {
    int32x4_t v17 = v16;
    if (v15 != 2)
    {
      if (v15 != 3) {
        goto LABEL_25;
      }
      int32x4_t v17 = (uint64_t *)v70;
    }
    int v75 = (__int16)WORD2(*v17);
    if (v75 >= 1)
    {
      uint64_t v18 = v10 + 8 * v15;
      __int16 v77 = *v17;
      if (*(void *)(v18 + 128)) {
        goto LABEL_14;
      }
      if (v15 == 3)
      {
        uint64_t Cone = C3DMeshCreateCone(0, 12, 1, 0.0, 1.0, 1.0);
      }
      else
      {
        if (v15 != 2) {
          goto LABEL_14;
        }
        uint64_t Cone = C3DMeshCreateSphere(0, 12, 1, 1.0, 1.0);
      }
      *(void *)(v18 + 128) = Cone;
LABEL_14:
      uint64_t v20 = (uint64_t *)RenderContext;
      if (!*(void *)(v18 + 72))
      {
        if (v15 == 2)
        {
          uint64_t v21 = @"debug_omni_vert";
          goto LABEL_19;
        }
        if (v15 == 3)
        {
          uint64_t v21 = @"debug_spot_vert";
LABEL_19:
          *(void *)(v18 + 72) = C3DFXMetalProgramCreateFromDefaultLibrary(v21, @"debug_light_frag");
        }
      }
      uint64_t v22 = -[SCNMTLResourceManager renderResourceForMesh:dataKind:]((uint64_t)v74, *(void *)(v18 + 128), 1);
      uint64_t v23 = *(void *)(v18 + 72);
      uint64_t v24 = C3DBlendStatesDefaultOver();
      uint64_t v25 = -[SCNMTLResourceManager commandQueue]((uint64_t)v22);
      uint64_t v26 = -[SCNMTLMesh vertexDescriptorHash]((uint64_t)v22);
      long long v85 = 0u;
      long long v86 = 0u;
      uint64_t v84 = v23;
      uint64_t v87 = v24;
      uint64_t v88 = 0;
      int v89 = 16777231;
      int v90 = 0;
      uint64_t v91 = v25;
      uint64_t v92 = v26;
      long long v93 = 0u;
      long long v94 = 0u;
      uint64_t v95 = 0;
      uint64_t RenderContext = (uint64_t)v20;
      uint64_t v27 = objc_msgSend((id)objc_msgSend(v74, "renderResourceForProgramDesc:renderPassDescriptor:", &v84, -[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v20)), "state");
      uint64_t v8 = v72;
      if (*(void *)(v72 + 3376) != v27)
      {
        *(void *)(v72 + 3376) = v27;
        [*(id *)(v72 + 3392) setRenderPipelineState:v27];
      }
      -[SCNMTLRenderContext _setSceneBufferAtVertexIndex:fragmentIndex:](v20, 0, -1);
      uint64_t v2 = v73;
      SCNMTLRenderCommandEncoder::setVertexBuffer(v72, v73[7].i64[1], v73[8].i64[0] + ((uint64_t)v77 << 8), 1);
      CFArrayRef MeshElements = (const __CFArray *)C3DMeshGetMeshElements(*(void *)(v18 + 128), 1);
      unsigned int v13 = v79;
      float32x4_t v16 = v71;
      if (MeshElements)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(MeshElements, 0);
        if (ValueAtIndex)
        {
          int32x4_t v30 = -[SCNMTLResourceManager renderResourceForMeshElement:]((uint64_t)v74, (uint64_t)ValueAtIndex);
          -[SCNMTLRenderContext _setMeshBuffers:](RenderContext, (uint64_t)v22);
          -[SCNMTLRenderContext _drawMeshElement:instanceCount:](RenderContext, (uint64_t)v30, (unsigned __int16)v75);
        }
      }
    }
LABEL_25:
    ++v15;
  }
  while (v15 != 7);
  PointOfCulling = (float32x4_t *)C3DEngineContextGetPointOfCulling(v68);
  if (!PointOfCulling || PointOfCulling == C3DEngineContextGetPointOfView(v68))
  {
    float32x4_t v52 = (uint64_t *)RenderContext;
    float32x4_t v53 = *(void **)(v10 + 48);
    if (!v53
      || ([v53 matchesRenderPassDescriptor:-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52)] & 1) == 0)
    {
      uint64_t v54 = [(id)-[SCNMTLResourceManager libraryManager]((uint64_t)v74) frameworkLibrary];
      memset(&__src[8], 0, 232);
      memset(__src, 0, 120);
      __src[7].i64[1] = v54;
      __src[13].i64[1] = C3DBlendStatesDefaultOver();
      __src[19].i64[1] = @"scn_draw_fullscreen_quad_vertex";
      __src[20].i64[0] = @"debug_cluster_frag";
      float32x4_t v55 = (void *)-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52);
      SCNMTLRenderPipelineApplyRenderPassDescriptor((uint64_t)&__src[8], v55);

      memcpy(__dst, __src, sizeof(__dst));
      *(void *)(v10 + 48) = [v74 newRenderPipelineStateWithDesc:__dst];
    }
    float32x4_t v56 = *(void **)(v10 + 56);
    if (!v56
      || ([v56 matchesRenderPassDescriptor:-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52)] & 1) == 0)
    {
      uint64_t v57 = [(id)-[SCNMTLResourceManager libraryManager]((uint64_t)v74) frameworkLibrary];
      memset(&__src[8], 0, 232);
      memset(__src, 0, 120);
      __src[7].i64[1] = v57;
      __src[13].i64[1] = C3DBlendStatesDefaultOver();
      __src[19].i64[1] = @"scn_draw_fullscreen_quad_VR_pos_vertex";
      __src[20].i64[0] = @"debug_light_indices_8_buffer_frag";
      unsigned int v58 = (void *)-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52);
      SCNMTLRenderPipelineApplyRenderPassDescriptor((uint64_t)&__src[8], v58);

      memcpy(v82, __src, sizeof(v82));
      *(void *)(v10 + 56) = [v74 newRenderPipelineStateWithDesc:v82];
    }
    [*(id *)(v8 + 3392) setDepthStencilState:-[SCNMTLResourceManager depthAndStencilStateWithReadWriteDepthDisabled]((uint64_t)v74)];
    int v59 = *(void **)(v10 + 64);
    if (!v59
      || ([v59 matchesRenderPassDescriptor:-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52)] & 1) == 0)
    {
      uint64_t v60 = [(id)-[SCNMTLResourceManager libraryManager]((uint64_t)v74) frameworkLibrary];
      memset(&__src[8], 0, 232);
      memset(__src, 0, 120);
      __src[7].i64[1] = v60;
      __src[13].i64[1] = C3DBlendStatesDefaultOver();
      __src[19].i64[1] = @"scn_draw_fullscreen_quad_VR_pos_vertex";
      __src[20].i64[0] = @"debug_cluster_slices_frag";
      uint64_t v61 = (void *)-[SCNMTLRenderContext currentRenderPassDescriptor]((uint64_t)v52);
      SCNMTLRenderPipelineApplyRenderPassDescriptor((uint64_t)&__src[8], v61);

      memcpy(v81, __src, sizeof(v81));
      *(void *)(v10 + 64) = [v74 newRenderPipelineStateWithDesc:v81];
    }
    if (objc_msgSend(*(id *)(v10 + 48), "state", *(_OWORD *)&v66))
    {
      uint64_t v62 = [*(id *)(v10 + 48) state];
      if (*(void *)(v8 + 3376) != v62)
      {
        *(void *)(v8 + 3376) = v62;
        [*(id *)(v8 + 3392) setRenderPipelineState:v62];
      }
      SCNMTLRenderCommandEncoder::setFragmentTexture(v8, (void *)v2[1].i64[1], 0);
      -[SCNMTLRenderContext _setSceneBufferAtVertexIndex:fragmentIndex:](v52, -1, 0);
      SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v8, &v2[5], 8uLL, 1);
      SCNMTLRenderCommandEncoder::_bindPendingTextures((SCNMTLRenderCommandEncoder *)v8);
      SCNMTLRenderCommandEncoder::applyChangedStates((SCNMTLRenderCommandEncoder *)v8);
      [*(id *)(v8 + 3392) drawPrimitives:4 vertexStart:0 vertexCount:4];
    }
    if ([*(id *)(v10 + 64) state])
    {
      uint64_t v63 = [*(id *)(v10 + 64) state];
      if (*(void *)(v8 + 3376) != v63)
      {
        *(void *)(v8 + 3376) = v63;
        [*(id *)(v8 + 3392) setRenderPipelineState:v63];
      }
      unint64_t v64 = [(id)v2[1].i64[1] depth];
      v65.i32[0] = 0.5;
      v65.f32[1] = 0.5 / (float)v64;
      v65.i32[2] = 0;
      v65.f32[3] = 1.0 - v65.f32[1];
      __src[0] = v65;
      SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v8, __src, 0x10uLL, 0);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v8, (void *)v2[1].i64[1], 0);
      SCNMTLRenderCommandEncoder::_bindPendingTextures((SCNMTLRenderCommandEncoder *)v8);
      SCNMTLRenderCommandEncoder::applyChangedStates((SCNMTLRenderCommandEncoder *)v8);
      [*(id *)(v8 + 3392) drawPrimitives:4 vertexStart:0 vertexCount:4];
    }
  }
  else
  {
    v106[6] = xmmword_20B5EDC60;
    v106[7] = *(_OWORD *)"fff?333?";
    v106[8] = xmmword_20B5EDC80;
    void v106[2] = xmmword_20B5EDC20;
    v106[3] = unk_20B5EDC30;
    v106[4] = xmmword_20B5EDC40;
    v106[5] = unk_20B5EDC50;
    v106[0] = *(_OWORD *)"333?333?333?";
    v106[1] = unk_20B5EDC10;
    int32x4_t v32 = v67;
    scn_plane_intersect_3_planes(v67[10], v67[11], v67[4], v67[5], v67[2], v67[3], &v98);
    scn_plane_intersect_3_planes(v32[10], v32[11], *v32, v32[1], v32[4], v32[5], &v99);
    scn_plane_intersect_3_planes(v32[10], v32[11], v32[2], v32[3], v32[6], v32[7], &v100);
    scn_plane_intersect_3_planes(v32[10], v32[11], v32[6], v32[7], *v32, v32[1], &v101);
    scn_plane_intersect_3_planes(v32[8], v32[9], v32[4], v32[5], v32[2], v32[3], &v102);
    scn_plane_intersect_3_planes(v32[8], v32[9], *v32, v32[1], v32[4], v32[5], &v103);
    scn_plane_intersect_3_planes(v32[8], v32[9], v32[2], v32[3], v32[6], v32[7], &v104);
    scn_plane_intersect_3_planes(v32[8], v32[9], v32[6], v32[7], *v32, v32[1], v105);
    float32x4_t v33 = v66;
    __src[1] = v66;
    unsigned int v34 = v69;
    if (v69)
    {
      int v78 = 0;
      unsigned __int32 v35 = 0;
      int v36 = v2[6].i32[3];
      uint64_t v37 = v2->i64[0];
      int v76 = v13 * v12;
      do
      {
        unsigned int v38 = *(_DWORD *)(v10 + 40);
        if ((v38 == v35 || v38 >= v34) && v13 != 0)
        {
          unsigned int v41 = 0;
          int v42 = v78;
          do
          {
            unsigned int v43 = *(_DWORD *)(v10 + 36);
            if ((v43 == v41 || v43 >= v13) && v12 != 0)
            {
              unsigned int v46 = 0;
              do
              {
                unsigned int v47 = *(_DWORD *)(v10 + 32);
                if (v47 >= v12 || v46 == v47)
                {
                  uint64_t v49 = v42 + v46;
                  float32x4_t v33 = __computeFrustumExtrema(__src, v46, v41, v35, v96, (uint32x4_t)v33);
                  if (v36)
                  {
                    v33.i64[0] = *(void *)(v37 + 8 * v49);
                  }
                  else
                  {
                    int8x16_t v50 = (__int16 *)(v37 + 4 * v49);
                    v33.i16[3] = 0;
                    v33.i64[1] = 0;
                    v33.i16[0] = *v50;
                    *(__int32 *)((char *)v33.i32 + 2) = (unsigned __int16)v50[1];
                  }
                  unsigned int v51 = v33.u8[3];
                  if (v33.u8[2] > ((unsigned __int16)(v33.i16[1] & 0xFF00) >> 8)) {
                    unsigned int v51 = v33.u8[2];
                  }
                  if (v51 >= 8) {
                    unsigned int v51 = 8;
                  }
                  if (v51) {
                    C3DAuthoringEnvironmentAppendDebugAsymetricBox(AuthoringEnvironment, (uint64_t)v96, 0, (float *)&v106[v51]);
                  }
                }
                ++v46;
              }
              while (v12 != v46);
            }
            ++v41;
            v42 += v12;
            unsigned int v13 = v79;
          }
          while (v41 != v79);
        }
        ++v35;
        v78 += v76;
        unsigned int v34 = v69;
      }
      while (v35 != v69);
    }
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>(uint64_t result, __int16 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v10 = (__int16 *)result;
LABEL_2:
  int32x4_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          uint64_t v23 = *v11;
          if (*(float *)(*a3 + 4 * v22) > *(float *)(*a3 + 4 * v23))
          {
            __int16 *v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 47) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *,short *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    int32x4_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x101)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, &v11[v15 >> 1], a2 - 1, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11 + 1, v17 - 1, a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v17 - 1, v17, &v11[v16 + 1], a3);
      __int16 v18 = *v11;
      __int16 *v11 = *v17;
      __int16 *v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(&v11[v15 >> 1], v11, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(*a3 + 4 * *(v11 - 1)) <= *(float *)(*a3 + 4 * *v11))
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,short *,__SphereZComp &>(v11, a2, a3);
      int32x4_t v11 = (__int16 *)result;
      goto LABEL_19;
    }
LABEL_14:
    float32x2_t v19 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,short *,__SphereZComp &>(v11, a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, v19, a3);
    int32x4_t v11 = v19 + 1;
    uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v19 + 1, a2, a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>(v10, v19, a3, -v13, a5 & 1);
      int32x4_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, a2, a3);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(v11, a2, a3);
  }
}

__int16 *std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    __int32 v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *a3;
      char v6 = result;
      do
      {
        uint64_t v7 = v6[1];
        uint64_t v8 = *v6;
        char v6 = v3;
        float v9 = *(float *)(v5 + 4 * v7);
        if (v9 > *(float *)(v5 + 4 * v8))
        {
          __int16 v10 = v7;
          __int16 v11 = v8;
          uint64_t v12 = v4;
          while (1)
          {
            *(__int16 *)((char *)result + v12 + 2) = v11;
            if (!v12) {
              break;
            }
            __int16 v11 = *(__int16 *)((char *)result + v12 - 2);
            v12 -= 2;
            if (v9 <= *(float *)(v5 + 4 * v11))
            {
              uint64_t v13 = (__int16 *)((char *)result + v12 + 2);
              goto LABEL_10;
            }
          }
          uint64_t v13 = result;
LABEL_10:
          *uint64_t v13 = v10;
        }
        __int32 v3 = v6 + 1;
        v4 += 2;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

__int16 *std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    __int32 v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *a3;
      do
      {
        uint64_t v5 = result[1];
        uint64_t v6 = *result;
        uint64_t result = v3;
        float v7 = *(float *)(v4 + 4 * v5);
        if (v7 > *(float *)(v4 + 4 * v6))
        {
          __int16 v8 = v5;
          __int16 v9 = v6;
          __int16 v10 = result;
          do
          {
            *__int16 v10 = v9;
            __int16 v9 = *(v10 - 2);
            --v10;
          }
          while (v7 > *(float *)(v4 + 4 * v9));
          *__int16 v10 = v8;
        }
        __int32 v3 = result + 1;
      }
      while (result + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a4;
  float v6 = *(float *)(*a4 + 4 * *a2);
  float v7 = *(float *)(*a4 + 4 * v4);
  __int16 v8 = *a2;
  __int16 v9 = *a3;
  float v10 = *(float *)(*a4 + 4 * *a3);
  if (v6 > v7)
  {
    if (v10 > v6)
    {
      *a1 = v9;
      *a3 = v4;
      return 1;
    }
    *a1 = v8;
    *a2 = v4;
    uint64_t v13 = *a3;
    if (*(float *)(v5 + 4 * v13) <= v7) {
      return 1;
    }
    *a2 = v13;
    *a3 = v4;
    return 2;
  }
  if (v10 > v6)
  {
    *a2 = v9;
    *a3 = v8;
    uint64_t v11 = *a2;
    uint64_t v12 = *a1;
    if (*(float *)(v5 + 4 * v11) <= *(float *)(v5 + 4 * v12)) {
      return 1;
    }
    *a1 = v11;
    *a2 = v12;
    return 2;
  }
  return 0;
}

__int16 *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,short *,__SphereZComp &>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a3;
  float v5 = *(float *)(*a3 + 4 * v3);
  if (v5 <= *(float *)(*a3 + 4 * *(a2 - 1)))
  {
    __int16 v8 = a1 + 1;
    do
    {
      float v6 = v8;
      if (v8 >= a2) {
        break;
      }
      ++v8;
    }
    while (v5 <= *(float *)(v4 + 4 * *v6));
  }
  else
  {
    float v6 = a1;
    do
    {
      uint64_t v7 = v6[1];
      ++v6;
    }
    while (v5 <= *(float *)(v4 + 4 * v7));
  }
  if (v6 < a2)
  {
    do
      uint64_t v9 = *--a2;
    while (v5 > *(float *)(v4 + 4 * v9));
  }
  if (v6 < a2)
  {
    __int16 v10 = *v6;
    __int16 v11 = *a2;
    do
    {
      *float v6 = v11;
      *a2 = v10;
      do
      {
        uint64_t v12 = v6[1];
        ++v6;
        __int16 v10 = v12;
      }
      while (v5 <= *(float *)(v4 + 4 * v12));
      do
      {
        uint64_t v13 = *--a2;
        __int16 v11 = v13;
      }
      while (v5 > *(float *)(v4 + 4 * v13));
    }
    while (v6 < a2);
  }
  if (v6 - 1 != a1) {
    *a1 = *(v6 - 1);
  }
  *(v6 - 1) = v3;
  return v6;
}

__int16 *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,short *,__SphereZComp &>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  __int16 v4 = *a1;
  uint64_t v5 = *a3;
  float v6 = *(float *)(*a3 + 4 * *a1);
  do
    uint64_t v7 = a1[++v3];
  while (*(float *)(v5 + 4 * v7) > v6);
  __int16 v8 = &a1[v3];
  uint64_t v9 = &a1[v3 - 1];
  if (v3 == 1)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      uint64_t v11 = *--a2;
    }
    while (*(float *)(v5 + 4 * v11) <= v6);
  }
  else
  {
    do
      uint64_t v10 = *--a2;
    while (*(float *)(v5 + 4 * v10) <= v6);
  }
  if (v8 < a2)
  {
    __int16 v12 = v7;
    __int16 v13 = *a2;
    uint64_t v14 = v8;
    unint64_t v15 = a2;
    do
    {
      *uint64_t v14 = v13;
      *unint64_t v15 = v12;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
        __int16 v12 = v16;
      }
      while (*(float *)(v5 + 4 * v16) > v6);
      do
      {
        uint64_t v17 = *--v15;
        __int16 v13 = v17;
      }
      while (*(float *)(v5 + 4 * v17) <= v6);
    }
    while (v14 < v15);
    uint64_t v9 = v14 - 1;
  }
  if (v9 != a1) {
    *a1 = *v9;
  }
  *uint64_t v9 = v4;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*a3 + 4 * v8) > *(float *)(*a3 + 4 * v9))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 6;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    float v16 = *(float *)(v13 + 4 * v15);
    if (v16 > *(float *)(v13 + 4 * *v10))
    {
      __int16 v17 = *v10;
      uint64_t v18 = v14;
      while (1)
      {
        *(__int16 *)((char *)a1 + v18) = v17;
        uint64_t v19 = v18 - 2;
        if (v18 == 2) {
          break;
        }
        uint64_t v20 = *(__int16 *)((char *)a1 + v18 - 4);
        __int16 v17 = v20;
        float v21 = *(float *)(v13 + 4 * v20);
        uint64_t v18 = v19;
        if (v16 <= v21)
        {
          uint64_t v22 = (__int16 *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *uint64_t v22 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 2;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t *a5)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5;
  if (*(float *)(*a5 + 4 * v11) > *(float *)(*a5 + 4 * v12))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v14 = *a3;
    uint64_t v15 = *a2;
    if (*(float *)(v13 + 4 * v14) > *(float *)(v13 + 4 * v15))
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v16 = *a2;
      uint64_t v17 = *a1;
      if (*(float *)(v13 + 4 * v16) > *(float *)(v13 + 4 * v17))
      {
        *a1 = v16;
        *a2 = v17;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, uint64_t *a6)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *a6;
  if (*(float *)(*a6 + 4 * v13) > *(float *)(*a6 + 4 * v14))
  {
    *a4 = v13;
    *a5 = v14;
    uint64_t v16 = *a4;
    uint64_t v17 = *a3;
    if (*(float *)(v15 + 4 * v16) > *(float *)(v15 + 4 * v17))
    {
      *a3 = v16;
      *a4 = v17;
      uint64_t v18 = *a3;
      uint64_t v19 = *a2;
      if (*(float *)(v15 + 4 * v18) > *(float *)(v15 + 4 * v19))
      {
        *a2 = v18;
        *a3 = v19;
        uint64_t v20 = *a2;
        uint64_t v21 = *a1;
        if (*(float *)(v15 + 4 * v20) > *(float *)(v15 + 4 * v21))
        {
          *a1 = v20;
          *a2 = v21;
        }
      }
    }
  }
  return result;
}

__int16 *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *,short *>(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 3)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *v14;
        uint64_t v16 = *a1;
        if (*(float *)(*a4 + 4 * v15) > *(float *)(*a4 + 4 * v16))
        {
          *uint64_t v14 = v16;
          *a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 3)
    {
      uint64_t v17 = (unint64_t)v8 >> 1;
      uint64_t v18 = a2 - 1;
      do
      {
        __int16 v19 = *a1;
        uint64_t v20 = std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(a1, a4, v17);
        if (v18 == v20)
        {
          *uint64_t v20 = v19;
        }
        else
        {
          *uint64_t v20 = *v18;
          __int16 *v18 = v19;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>((uint64_t)a1, (uint64_t)(v20 + 1), a4, v20 + 1 - a1);
        }
        --v18;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(uint64_t result, uint64_t *a2, uint64_t a3, __int16 *a4)
{
  if (a3 >= 2)
  {
    __int16 v4 = (char *)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 1)
    {
      uint64_t v6 = (uint64_t)(v4 + 1);
      uint64_t v7 = (__int16 *)(result + 2 * (void)(v4 + 1));
      uint64_t v8 = (uint64_t)(v4 + 2);
      uint64_t v9 = *a2;
      if (v8 < a3 && *(float *)(v9 + 4 * *v7) > *(float *)(v9 + 4 * v7[1]))
      {
        ++v7;
        uint64_t v6 = v8;
      }
      uint64_t v10 = *a4;
      float v11 = *(float *)(v9 + 4 * v10);
      if (*(float *)(v9 + 4 * *v7) <= v11)
      {
        __int16 v12 = *v7;
        do
        {
          uint64_t v13 = v7;
          *a4 = v12;
          if (v5 < v6) {
            break;
          }
          uint64_t v14 = 2 * v6;
          uint64_t v6 = (2 * v6) | 1;
          uint64_t v7 = (__int16 *)(result + 2 * v6);
          uint64_t v15 = v14 + 2;
          if (v15 < a3 && *(float *)(v9 + 4 * *v7) > *(float *)(v9 + 4 * v7[1]))
          {
            ++v7;
            uint64_t v6 = v15;
          }
          __int16 v12 = *v7;
          a4 = v13;
        }
        while (*(float *)(v9 + 4 * *v7) <= v11);
        *uint64_t v13 = v10;
      }
    }
  }
  return result;
}

__int16 *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(__int16 *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  uint64_t v6 = *a2;
  do
  {
    uint64_t v7 = result;
    uint64_t v8 = 2 * v3 + 2;
    uint64_t result = (__int16 *)((char *)result + v8);
    uint64_t v3 = (2 * v3) | 1;
    if (v8 < a3 && *(float *)(v6 + 4 * *result) > *(float *)(v6 + 4 * result[1]))
    {
      ++result;
      uint64_t v3 = v8;
    }
    *uint64_t v7 = *result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,__SphereZComp &,short *>(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (__int16 *)(result + 2 * v4);
    uint64_t v6 = *v5;
    uint64_t v9 = *(__int16 *)(a2 - 2);
    uint64_t v7 = (_WORD *)(a2 - 2);
    __int16 v8 = v9;
    uint64_t v10 = *a3;
    float v11 = *(float *)(*a3 + 4 * v9);
    if (*(float *)(*a3 + 4 * v6) > v11)
    {
      do
      {
        __int16 v12 = v5;
        *uint64_t v7 = v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (__int16 *)(result + 2 * v4);
        LOWORD(v6) = *v5;
        uint64_t v7 = v12;
      }
      while (*(float *)(v10 + 4 * *v5) > v11);
      _WORD *v12 = v8;
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,__VolumeComp &,short *,false>(uint64_t result, __int16 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v10 = (__int16 *)result;
LABEL_2:
  float v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          uint64_t v23 = *v11;
          if (*(float *)(*a3 + 4 * v22) < *(float *)(*a3 + 4 * v23))
          {
            __int16 *v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 47) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *,short *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x101)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, &v11[v15 >> 1], a2 - 1, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11 + 1, v17 - 1, a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v17 - 1, v17, &v11[v16 + 1], a3);
      __int16 v18 = *v11;
      __int16 *v11 = *v17;
      __int16 *v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(&v11[v15 >> 1], v11, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(*a3 + 4 * *(v11 - 1)) >= *(float *)(*a3 + 4 * *v11))
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,short *,__VolumeComp &>(v11, a2, a3);
      float v11 = (__int16 *)result;
      goto LABEL_19;
    }
LABEL_14:
    __int16 v19 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,short *,__VolumeComp &>(v11, a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, v19, a3);
    float v11 = v19 + 1;
    uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v19 + 1, a2, a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,__VolumeComp &,short *,false>(v10, v19, a3, -v13, a5 & 1);
      float v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, a2, a3);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(v11, a2, a3);
  }
}

__int16 *std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *a3;
      char v6 = result;
      do
      {
        uint64_t v7 = v6[1];
        uint64_t v8 = *v6;
        char v6 = v3;
        float v9 = *(float *)(v5 + 4 * v7);
        if (v9 < *(float *)(v5 + 4 * v8))
        {
          __int16 v10 = v7;
          __int16 v11 = v8;
          uint64_t v12 = v4;
          while (1)
          {
            *(__int16 *)((char *)result + v12 + 2) = v11;
            if (!v12) {
              break;
            }
            __int16 v11 = *(__int16 *)((char *)result + v12 - 2);
            v12 -= 2;
            if (v9 >= *(float *)(v5 + 4 * v11))
            {
              uint64_t v13 = (__int16 *)((char *)result + v12 + 2);
              goto LABEL_10;
            }
          }
          uint64_t v13 = result;
LABEL_10:
          *uint64_t v13 = v10;
        }
        uint64_t v3 = v6 + 1;
        v4 += 2;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

__int16 *std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *a3;
      do
      {
        uint64_t v5 = result[1];
        uint64_t v6 = *result;
        uint64_t result = v3;
        float v7 = *(float *)(v4 + 4 * v5);
        if (v7 < *(float *)(v4 + 4 * v6))
        {
          __int16 v8 = v5;
          __int16 v9 = v6;
          __int16 v10 = result;
          do
          {
            *__int16 v10 = v9;
            __int16 v9 = *(v10 - 2);
            --v10;
          }
          while (v7 < *(float *)(v4 + 4 * v9));
          *__int16 v10 = v8;
        }
        uint64_t v3 = result + 1;
      }
      while (result + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a4;
  float v6 = *(float *)(*a4 + 4 * *a2);
  float v7 = *(float *)(*a4 + 4 * v4);
  __int16 v8 = *a2;
  __int16 v9 = *a3;
  float v10 = *(float *)(*a4 + 4 * *a3);
  if (v6 < v7)
  {
    if (v10 < v6)
    {
      *a1 = v9;
      *a3 = v4;
      return 1;
    }
    *a1 = v8;
    *a2 = v4;
    uint64_t v13 = *a3;
    if (*(float *)(v5 + 4 * v13) >= v7) {
      return 1;
    }
    *a2 = v13;
    *a3 = v4;
    return 2;
  }
  if (v10 < v6)
  {
    *a2 = v9;
    *a3 = v8;
    uint64_t v11 = *a2;
    uint64_t v12 = *a1;
    if (*(float *)(v5 + 4 * v11) >= *(float *)(v5 + 4 * v12)) {
      return 1;
    }
    *a1 = v11;
    *a2 = v12;
    return 2;
  }
  return 0;
}

__int16 *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,short *,__VolumeComp &>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a3;
  float v5 = *(float *)(*a3 + 4 * v3);
  if (v5 >= *(float *)(*a3 + 4 * *(a2 - 1)))
  {
    __int16 v8 = a1 + 1;
    do
    {
      float v6 = v8;
      if (v8 >= a2) {
        break;
      }
      ++v8;
    }
    while (v5 >= *(float *)(v4 + 4 * *v6));
  }
  else
  {
    float v6 = a1;
    do
    {
      uint64_t v7 = v6[1];
      ++v6;
    }
    while (v5 >= *(float *)(v4 + 4 * v7));
  }
  if (v6 < a2)
  {
    do
      uint64_t v9 = *--a2;
    while (v5 < *(float *)(v4 + 4 * v9));
  }
  if (v6 < a2)
  {
    __int16 v10 = *v6;
    __int16 v11 = *a2;
    do
    {
      *float v6 = v11;
      *a2 = v10;
      do
      {
        uint64_t v12 = v6[1];
        ++v6;
        __int16 v10 = v12;
      }
      while (v5 >= *(float *)(v4 + 4 * v12));
      do
      {
        uint64_t v13 = *--a2;
        __int16 v11 = v13;
      }
      while (v5 < *(float *)(v4 + 4 * v13));
    }
    while (v6 < a2);
  }
  if (v6 - 1 != a1) {
    *a1 = *(v6 - 1);
  }
  *(v6 - 1) = v3;
  return v6;
}

__int16 *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,short *,__VolumeComp &>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  __int16 v4 = *a1;
  uint64_t v5 = *a3;
  float v6 = *(float *)(*a3 + 4 * *a1);
  do
    uint64_t v7 = a1[++v3];
  while (*(float *)(v5 + 4 * v7) < v6);
  __int16 v8 = &a1[v3];
  uint64_t v9 = &a1[v3 - 1];
  if (v3 == 1)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      uint64_t v11 = *--a2;
    }
    while (*(float *)(v5 + 4 * v11) >= v6);
  }
  else
  {
    do
      uint64_t v10 = *--a2;
    while (*(float *)(v5 + 4 * v10) >= v6);
  }
  if (v8 < a2)
  {
    __int16 v12 = v7;
    __int16 v13 = *a2;
    uint64_t v14 = v8;
    unint64_t v15 = a2;
    do
    {
      *uint64_t v14 = v13;
      *unint64_t v15 = v12;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
        __int16 v12 = v16;
      }
      while (*(float *)(v5 + 4 * v16) < v6);
      do
      {
        uint64_t v17 = *--v15;
        __int16 v13 = v17;
      }
      while (*(float *)(v5 + 4 * v17) >= v6);
    }
    while (v14 < v15);
    uint64_t v9 = v14 - 1;
  }
  if (v9 != a1) {
    *a1 = *v9;
  }
  *uint64_t v9 = v4;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*a3 + 4 * v8) < *(float *)(*a3 + 4 * v9))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 6;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    float v16 = *(float *)(v13 + 4 * v15);
    if (v16 < *(float *)(v13 + 4 * *v10))
    {
      __int16 v17 = *v10;
      uint64_t v18 = v14;
      while (1)
      {
        *(__int16 *)((char *)a1 + v18) = v17;
        uint64_t v19 = v18 - 2;
        if (v18 == 2) {
          break;
        }
        uint64_t v20 = *(__int16 *)((char *)a1 + v18 - 4);
        __int16 v17 = v20;
        float v21 = *(float *)(v13 + 4 * v20);
        uint64_t v18 = v19;
        if (v16 >= v21)
        {
          uint64_t v22 = (__int16 *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *uint64_t v22 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 2;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t *a5)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5;
  if (*(float *)(*a5 + 4 * v11) < *(float *)(*a5 + 4 * v12))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v14 = *a3;
    uint64_t v15 = *a2;
    if (*(float *)(v13 + 4 * v14) < *(float *)(v13 + 4 * v15))
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v16 = *a2;
      uint64_t v17 = *a1;
      if (*(float *)(v13 + 4 * v16) < *(float *)(v13 + 4 * v17))
      {
        *a1 = v16;
        *a2 = v17;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, uint64_t *a6)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *a6;
  if (*(float *)(*a6 + 4 * v13) < *(float *)(*a6 + 4 * v14))
  {
    *a4 = v13;
    *a5 = v14;
    uint64_t v16 = *a4;
    uint64_t v17 = *a3;
    if (*(float *)(v15 + 4 * v16) < *(float *)(v15 + 4 * v17))
    {
      *a3 = v16;
      *a4 = v17;
      uint64_t v18 = *a3;
      uint64_t v19 = *a2;
      if (*(float *)(v15 + 4 * v18) < *(float *)(v15 + 4 * v19))
      {
        *a2 = v18;
        *a3 = v19;
        uint64_t v20 = *a2;
        uint64_t v21 = *a1;
        if (*(float *)(v15 + 4 * v20) < *(float *)(v15 + 4 * v21))
        {
          *a1 = v20;
          *a2 = v21;
        }
      }
    }
  }
  return result;
}

__int16 *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *,short *>(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 3)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *v14;
        uint64_t v16 = *a1;
        if (*(float *)(*a4 + 4 * v15) < *(float *)(*a4 + 4 * v16))
        {
          *uint64_t v14 = v16;
          *a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 3)
    {
      uint64_t v17 = (unint64_t)v8 >> 1;
      uint64_t v18 = a2 - 1;
      do
      {
        __int16 v19 = *a1;
        uint64_t v20 = std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(a1, a4, v17);
        if (v18 == v20)
        {
          *uint64_t v20 = v19;
        }
        else
        {
          *uint64_t v20 = *v18;
          __int16 *v18 = v19;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>((uint64_t)a1, (uint64_t)(v20 + 1), a4, v20 + 1 - a1);
        }
        --v18;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(uint64_t result, uint64_t *a2, uint64_t a3, __int16 *a4)
{
  if (a3 >= 2)
  {
    __int16 v4 = (char *)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 1)
    {
      uint64_t v6 = (uint64_t)(v4 + 1);
      uint64_t v7 = (__int16 *)(result + 2 * (void)(v4 + 1));
      uint64_t v8 = (uint64_t)(v4 + 2);
      uint64_t v9 = *a2;
      if (v8 < a3 && *(float *)(v9 + 4 * *v7) < *(float *)(v9 + 4 * v7[1]))
      {
        ++v7;
        uint64_t v6 = v8;
      }
      uint64_t v10 = *a4;
      float v11 = *(float *)(v9 + 4 * v10);
      if (*(float *)(v9 + 4 * *v7) >= v11)
      {
        __int16 v12 = *v7;
        do
        {
          uint64_t v13 = v7;
          *a4 = v12;
          if (v5 < v6) {
            break;
          }
          uint64_t v14 = 2 * v6;
          uint64_t v6 = (2 * v6) | 1;
          uint64_t v7 = (__int16 *)(result + 2 * v6);
          uint64_t v15 = v14 + 2;
          if (v15 < a3 && *(float *)(v9 + 4 * *v7) < *(float *)(v9 + 4 * v7[1]))
          {
            ++v7;
            uint64_t v6 = v15;
          }
          __int16 v12 = *v7;
          a4 = v13;
        }
        while (*(float *)(v9 + 4 * *v7) >= v11);
        *uint64_t v13 = v10;
      }
    }
  }
  return result;
}

__int16 *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(__int16 *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  uint64_t v6 = *a2;
  do
  {
    uint64_t v7 = result;
    uint64_t v8 = 2 * v3 + 2;
    uint64_t result = (__int16 *)((char *)result + v8);
    uint64_t v3 = (2 * v3) | 1;
    if (v8 < a3 && *(float *)(v6 + 4 * *result) < *(float *)(v6 + 4 * result[1]))
    {
      ++result;
      uint64_t v3 = v8;
    }
    *uint64_t v7 = *result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,__VolumeComp &,short *>(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (__int16 *)(result + 2 * v4);
    uint64_t v6 = *v5;
    uint64_t v9 = *(__int16 *)(a2 - 2);
    uint64_t v7 = (_WORD *)(a2 - 2);
    __int16 v8 = v9;
    uint64_t v10 = *a3;
    float v11 = *(float *)(*a3 + 4 * v9);
    if (*(float *)(*a3 + 4 * v6) < v11)
    {
      do
      {
        __int16 v12 = v5;
        *uint64_t v7 = v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (__int16 *)(result + 2 * v4);
        LOWORD(v6) = *v5;
        uint64_t v7 = v12;
      }
      while (*(float *)(v10 + 4 * *v5) < v11);
      _WORD *v12 = v8;
    }
  }
  return result;
}

__CFString *_C3DIndexSetCFCopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 256);
  CFStringAppend(Mutable, @"indexSet ");
  if (*(unsigned char *)(a1 + 16)) {
    goto LABEL_15;
  }
  if ((*(unsigned char *)(a1 + 16) & 2) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (*(void *)(v3 + 16))
    {
      uint64_t v4 = *(void *)(v3 + 8);
      CFStringAppendFormat(Mutable, 0, @"[number of indexes: %lu (in %lu ranges), indexes: ("), *(void *)(v3 + 16), v4;
      if (v4 < 1)
      {
        CFStringRef v9 = @"]");
        goto LABEL_16;
      }
      uint64_t v5 = v3 + 56;
      goto LABEL_8;
    }
LABEL_15:
    CFStringRef v9 = @"(no index)";
    goto LABEL_16;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6) {
    goto LABEL_15;
  }
  uint64_t v5 = a1 + 24;
  uint64_t v4 = 1;
  CFStringAppendFormat(Mutable, 0, @"[number of indexes: %lu (in %lu ranges), indexes: ("), v6, 1;
LABEL_8:
  uint64_t v7 = 0;
  __int16 v8 = (uint64_t *)(v5 + 8);
  CFStringRef v9 = @"]");
  do
  {
    if (v7) {
      CFStringAppend(Mutable, @" ");
    }
    uint64_t v10 = *(v8 - 1);
    uint64_t v11 = *v8;
    CFStringAppendFormat(Mutable, 0, @"%lu", v10);
    if (v11 >= 2) {
      CFStringAppendFormat(Mutable, 0, @"-%lu", v10 + v11 - 1);
    }
    ++v7;
    v8 += 2;
  }
  while (v4 != v7);
LABEL_16:
  CFStringAppend(Mutable, v9);
  return Mutable;
}

double _setContentToContentFromIndexSet(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    char v4 = *(unsigned char *)(a1 + 16);
    *(unsigned char *)(a1 + 16) = v4 | 3;
    if ((*(unsigned char *)(a2 + 16) & 1) == 0)
    {
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        long long v6 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 24) = v6;
        *(unsigned char *)(a1 + 16) = v4 & 0xFC | 2;
      }
      else
      {
        *(unsigned char *)(a1 + 16) = v4 & 0xFC | 2;
        if (*(unsigned char *)(a2 + 16))
        {
          uint64_t v5 = 0;
        }
        else if ((*(unsigned char *)(a2 + 16) & 2) != 0)
        {
          uint64_t v5 = 1;
        }
        else
        {
          uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 8);
        }
        *(unsigned char *)(a1 + 16) = v4 & 0xFC;
        uint64_t v7 = malloc_type_calloc(16 * v5 + 56, 1uLL, 0xF8F96908uLL);
        *(void *)(a1 + 24) = v7;
        uint64_t v8 = a1 + 24;
        v7[6] = 0;
        **(void **)(a1 + 24) = v5;
        *(void *)(*(void *)(a1 + 24) + 8) = v5;
        *(void *)(*(void *)(a1 + 24) + 16) = 0;
        uint64_t v9 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
          uint64_t v9 = *(void *)v8 + 56;
        }
        uint64_t v10 = (void *)(a2 + 24);
        if ((*(unsigned char *)(a2 + 16) & 2) == 0) {
          uint64_t v10 = (void *)(*v10 + 56);
        }
        if (v5 >= 1)
        {
          uint64_t v11 = (void *)(v9 + 8);
          do
          {
            long long v12 = *(_OWORD *)v10;
            v10 += 2;
            *(void *)&long long v6 = v12;
            *(_OWORD *)(v11 - 1) = v12;
            *(void *)&long long v12 = *v11;
            v11 += 2;
            *(void *)(*(void *)v8 + 16) += v12;
            --v5;
          }
          while (v5);
        }
      }
    }
  }
  return *(double *)&v6;
}

uint64_t C3DIndexSetGetCount(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    uint64_t v1 = a1 + 32;
  }
  else {
    uint64_t v1 = *(void *)(a1 + 24) + 16;
  }
  return *(void *)v1;
}

uint64_t C3DIndexSetGetIndexGreaterThanIndex(uint64_t a1, uint64_t a2)
{
  return _indexClosestToIndex(a1, a2, 0, 1);
}

uint64_t _indexClosestToIndex(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  char v5 = a3;
  uint64_t v6 = a2;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v10 = *(void **)(a1 + 24);
    uint64_t v15 = (char *)v10 + *(void *)(a1 + 32);
    uint64_t v16 = (uint64_t)(v15 - 1);
    if (a4)
    {
      if (a3)
      {
        if ((uint64_t)v10 < a2)
        {
          if ((uint64_t)v15 > a2) {
            return v6;
          }
          pthread_t v8 = 0;
LABEL_47:
          uint64_t v27 = _indexOfRangeAfterOrContainingIndex(a1, v6);
          if (v27 == -1) {
            return -1;
          }
          uint64_t v28 = a1 + 24;
          if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
            int32x4_t v29 = (void *)(a1 + 24);
          }
          else {
            int32x4_t v29 = v10 + 7;
          }
          uint64_t v30 = v29[2 * v27];
          if (v6 <= v30) {
            uint64_t v16 = v30;
          }
          else {
            uint64_t v16 = v6;
          }
          if ((pthread_t)v10[6] == v8)
          {
            v10[4] = v27;
            *(void *)(*(void *)v28 + 40) = v16 - v30;
            uint64_t v26 = *(void *)v28;
            goto LABEL_56;
          }
          return v16;
        }
      }
      else if ((uint64_t)v10 <= a2)
      {
        if (v16 > a2) {
          return a2 + 1;
        }
        pthread_t v8 = 0;
LABEL_45:
        if (v6 == 0x7FFFFFFFFFFFFFFFLL) {
          return -1;
        }
        ++v6;
        goto LABEL_47;
      }
      return *(void *)(a1 + 24);
    }
    if (a3)
    {
      if (v16 <= a2) {
        return v16;
      }
      uint64_t v16 = a2;
      if ((uint64_t)v10 <= a2) {
        return v16;
      }
      goto LABEL_32;
    }
    if ((uint64_t)v15 <= a2) {
      return v16;
    }
    if ((uint64_t)v10 < a2) {
      return a2 - 1;
    }
    goto LABEL_30;
  }
  pthread_t v8 = pthread_self();
  uint64_t v9 = a1 + 24;
  uint64_t v10 = *(void **)(a1 + 24);
  if ((pthread_t)v10[6] == v8 && v10[3] == v6)
  {
    if ((v5 & 1) == 0)
    {
      uint64_t v11 = v10 + 7;
      if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
        uint64_t v11 = (void *)(a1 + 24);
      }
      if (a4)
      {
        uint64_t v12 = v10[4];
        if (v11[2 * v12 + 1] - 1 > v10[5])
        {
          v10[3] = v6 + 1;
          uint64_t v13 = *(void *)v9;
          uint64_t v14 = *(void *)(*(void *)v9 + 40) + 1;
LABEL_59:
          *(void *)(v13 + 40) = v14;
          return *(void *)(*(void *)v9 + 24);
        }
        uint64_t v31 = (*(unsigned char *)(a1 + 16) & 1) == 0;
        if ((*(unsigned char *)(a1 + 16) & 3) == 0) {
          uint64_t v31 = v10[1];
        }
        uint64_t v32 = v12 + 1;
        if (v32 < v31)
        {
          v10[4] = v32;
          uint64_t v33 = v11[2 * *(void *)(*(void *)v9 + 32)];
          *(void *)(*(void *)v9 + 40) = 0;
          *(void *)(*(void *)v9 + 24) = v33;
          return *(void *)(*(void *)v9 + 24);
        }
      }
      else
      {
        if ((uint64_t)v10[5] >= 1)
        {
          v10[3] = v6 - 1;
          uint64_t v13 = *(void *)v9;
          uint64_t v14 = *(void *)(*(void *)v9 + 40) - 1;
          goto LABEL_59;
        }
        uint64_t v34 = v10[4];
        BOOL v35 = v34 < 1;
        uint64_t v36 = v34 - 1;
        if (!v35)
        {
          v10[4] = v36;
          uint64_t v37 = &v11[2 * *(void *)(*(void *)v9 + 32)];
          uint64_t v38 = *v37;
          *(void *)(*(void *)v9 + 40) = v37[1] - 1;
          *(void *)(*(void *)v9 + 24) = *(void *)(*(void *)v9 + 40) + v38;
          return *(void *)(*(void *)v9 + 24);
        }
      }
      v10[6] = 0;
      return -1;
    }
    return v6;
  }
  if (a4)
  {
    if (v5) {
      goto LABEL_47;
    }
    goto LABEL_45;
  }
  if ((v5 & 1) == 0)
  {
LABEL_30:
    if (!v6) {
      return -1;
    }
    --v6;
  }
LABEL_32:
  uint64_t v17 = _indexOfRangeBeforeOrContainingIndex(a1, v6);
  if (v17 == -1) {
    return -1;
  }
  uint64_t v18 = v17;
  uint64_t v19 = a1 + 24;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    uint64_t v20 = (void *)(a1 + 24);
  }
  else {
    uint64_t v20 = v10 + 7;
  }
  uint64_t v21 = &v20[2 * v17];
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1] + *v21;
  if (v6 >= v23) {
    uint64_t v16 = v23 - 1;
  }
  else {
    uint64_t v16 = v6;
  }
  pthread_t v24 = pthread_self();
  uint64_t v25 = *(void *)(a1 + 24);
  if (*(pthread_t *)(v25 + 48) == v24)
  {
    *(void *)(v25 + 32) = v18;
    *(void *)(*(void *)v19 + 40) = v16 - v22;
    uint64_t v26 = *(void *)v19;
LABEL_56:
    *(void *)(v26 + 24) = v16;
  }
  return v16;
}

uint64_t C3DIndexSetContainsIndex(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v4 = a1 + 24;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    if (*(void *)v4 <= a2) {
      return *(void *)(a1 + 32) + *(void *)v4 > a2;
    }
    return 0;
  }
  char v5 = *(_opaque_pthread_t **)(*(void *)v4 + 48);
  if (v5 != pthread_self())
  {
    char v6 = *(unsigned char *)(a1 + 16);
    goto LABEL_5;
  }
  uint64_t v12 = *(void *)v4;
  if (*(void *)(*(void *)v4 + 24) != a2)
  {
    char v6 = *(unsigned char *)(a1 + 16);
    uint64_t v13 = v12 + 56;
    if ((v6 & 2) != 0) {
      uint64_t v13 = v4;
    }
    uint64_t v14 = (void *)(v13 + 16 * *(void *)(v12 + 32));
    if (*v14 > a2 || v14[1] + *v14 <= a2)
    {
LABEL_5:
      if ((v6 & 1) == 0)
      {
        if ((v6 & 2) != 0) {
          goto LABEL_9;
        }
        uint64_t v7 = *(void *)(*(void *)v4 + 8);
        if (v7 >= 1)
        {
          uint64_t v4 = *(void *)v4 + 56;
          uint64_t v8 = v7 - 1;
          if (v7 != 1)
          {
            uint64_t v15 = 0;
            do
            {
              uint64_t v16 = v15 + v8;
              if (v15 + v8 < 0 != __OFADD__(v15, v8)) {
                ++v16;
              }
              uint64_t v9 = v16 >> 1;
              uint64_t v17 = (void *)(v4 + 16 * v9);
              if (*v17 <= a2)
              {
                if (v17[1] + *v17 > a2) {
                  return v9 != -1;
                }
                uint64_t v15 = v9 + 1;
              }
              else
              {
                uint64_t v8 = v9;
              }
            }
            while (v15 < v8);
            uint64_t v9 = v15;
LABEL_10:
            uint64_t v10 = (void *)(v4 + 16 * v9);
            if (*v10 <= a2 && v10[1] + *v10 > a2) {
              return v9 != -1;
            }
            goto LABEL_12;
          }
LABEL_9:
          uint64_t v9 = 0;
          goto LABEL_10;
        }
      }
LABEL_12:
      uint64_t v9 = -1;
      return v9 != -1;
    }
  }
  return 1;
}

void C3DIndexSetAddIndexes(uint64_t a1, uint64_t a2)
{
  if (a2 && a2 != a1)
  {
    if ((*(unsigned char *)(a1 + 16) & 1) == 0 && ((*(unsigned char *)(a1 + 16) & 2) != 0 || *(void *)(*(void *)(a1 + 24) + 8)))
    {
      if (*(unsigned char *)(a2 + 16)) {
        return;
      }
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        uint64_t v4 = 1;
      }
      else
      {
        uint64_t v4 = *(void *)(*(void *)(a2 + 24) + 8);
        if (v4 < 1) {
          return;
        }
      }
      for (uint64_t i = 0; i != v4; ++i)
      {
        uint64_t v6 = rangeAtIndex(a2, i);
        C3DIndexSetAddIndexesInRange(a1, v6, v7);
      }
    }
    else
    {
      C3DIndexSetRemoveAllIndexes(a1);
      _setContentToContentFromIndexSet(a1, a2);
    }
  }
}

uint64_t rangeAtIndex(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v4 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v4 < a2)
  {
    char v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      rangeAtIndex_cold_1();
    }
  }
  uint64_t v6 = (void *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
    uint64_t v6 = (void *)(*v6 + 56);
  }
  return v6[2 * a2];
}

void C3DIndexSetRemoveIndexes(uint64_t a1, uint64_t a2)
{
  if (a2
    && (*(unsigned char *)(a1 + 16) & 1) == 0
    && ((*(unsigned char *)(a1 + 16) & 2) != 0 || *(uint64_t *)(*(void *)(a1 + 24) + 8) >= 1))
  {
    if (a2 == a1)
    {
      C3DIndexSetRemoveAllIndexes(a2);
    }
    else
    {
      if (*(unsigned char *)(a2 + 16)) {
        return;
      }
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        uint64_t v4 = 1;
      }
      else
      {
        uint64_t v4 = *(void *)(*(void *)(a2 + 24) + 8);
        if (v4 < 1) {
          return;
        }
      }
      for (uint64_t i = 0; i != v4; ++i)
      {
        uint64_t v6 = rangeAtIndex(a2, i);
        C3DIndexSetRemoveIndexesInRange(a1, v6, v7);
      }
    }
  }
}

uint64_t C3DIndexSetCreateIntersectionOfIndexSets(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = C3DIndexSetCreate();
  *(unsigned char *)(v4 + 16) |= 0xBu;
  char v5 = (unsigned char *)C3DIndexSetCreate();
  v5[16] |= 0xBu;
  C3DIndexSetAddIndexes(v4, a1);
  C3DIndexSetAddIndexes((uint64_t)v5, a1);
  C3DIndexSetRemoveIndexes((uint64_t)v5, a2);
  C3DIndexSetRemoveIndexes(v4, (uint64_t)v5);
  CFRelease(v5);
  return v4;
}

void btC3DMotionState::btC3DMotionState(btC3DMotionState *this, __C3DNode *a2, float a3)
{
  *(void *)this = &unk_26BF6A5A8;
  *((float *)this + 16) = a3;
  *((void *)this + 9) = a2;
}

__n128 *btC3DMotionState::setOffset(__n128 *result, __n128 a2)
{
  result[3] = a2;
  return result;
}

float32x4_t btC3DMotionState::getWorldTransform(btC3DMotionState *this, btTransform *a2)
{
  WorldMatrix = C3DNodeGetWorldMatrix(*((float32x4_t **)this + 9));
  v5.i64[0] = WorldMatrix[3].i64[0];
  v6.i32[0] = WorldMatrix->i32[0];
  v6.i32[1] = WorldMatrix[1].i32[0];
  v6.i64[1] = WorldMatrix[2].u32[0];
  float32x4_t v23 = v6;
  v6.i32[0] = WorldMatrix->i32[1];
  v6.i32[1] = WorldMatrix[1].i32[1];
  v6.i32[2] = WorldMatrix[2].i32[1];
  float32x4_t v22 = v6;
  v6.i32[0] = WorldMatrix->i32[2];
  v6.i32[1] = WorldMatrix[1].i32[2];
  v6.i32[2] = WorldMatrix[2].i32[2];
  float32x4_t v21 = v6;
  v5.i64[1] = WorldMatrix[3].u32[2];
  float32x4_t v24 = v5;
  C3DMatrix4x4GetScale(WorldMatrix, (float32x4_t *)this + 1);
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)v12.f32 = vdiv_f32(_D1, *(float32x2_t *)((char *)this + 16));
  v12.f32[2] = 1.0 / *((float *)this + 6);
  v12.i32[3] = 0;
  float32x4_t v13 = vmulq_f32(v21, v12);
  float32x4_t v14 = vmulq_f32(v22, v12);
  float32x4_t v15 = vmulq_f32(v23, v12);
  float32x4_t v16 = *((float32x4_t *)this + 3);
  int8x16_t v17 = (int8x16_t)vmulq_f32(v16, v13);
  v16.i32[3] = 0;
  int8x16_t v18 = (int8x16_t)vmulq_f32(v16, v15);
  float32x4_t v19 = vmulq_f32(v16, v14);
  v17.i32[3] = 0;
  *(float32x2_t *)v19.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, *(float32x2_t *)v19.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL)));
  *(float32x2_t *)&v19.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL)), 0);
  v17.i32[0] = *((_DWORD *)this + 16);
  a2->var0.var0[0] = (btVector3)v15;
  a2->var0.var0[1] = (btVector3)v14;
  float32x4_t result = vmulq_n_f32(vaddq_f32(v24, v19), *(float *)v17.i32);
  a2->var0.var0[2] = (btVector3)v13;
  a2->int var1 = (btVector3)result;
  return result;
}

void btC3DMotionState::setWorldTransform(btC3DMotionState *this, const btTransform *a2)
{
  float32x4_t v3 = (float32x4_t)a2->var0.var0[1];
  float32x4_t v4 = (float32x4_t)a2->var0.var0[2];
  float32x4_t v5 = *((float32x4_t *)this + 3);
  int8x16_t v6 = (int8x16_t)vmulq_f32(v4, v5);
  v5.i32[3] = 0;
  int8x16_t v7 = (int8x16_t)vmulq_f32((float32x4_t)a2->var0.var0[0], v5);
  float32x4_t v8 = vmulq_f32(v3, v5);
  v6.i32[3] = 0;
  *(float32x2_t *)v8.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v8.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL)));
  *(float32x2_t *)&v8.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)), 0);
  int8x16_t v9 = (int8x16_t)vtrn1q_s32((int32x4_t)a2->var0.var0[0], (int32x4_t)v3);
  v10.i64[0] = vextq_s8(v9, v9, 8uLL).u64[0];
  v9.i64[1] = v4.u32[0];
  *(int32x2_t *)v11.f32 = vzip2_s32(*(int32x2_t *)a2->var0.var0[0].var0.var0, *(int32x2_t *)v3.f32);
  *(int32x2_t *)&v11.u32[2] = vzip2_s32(*(int32x2_t *)v4.f32, 0);
  v10.i64[1] = vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u32[0];
  float32x4_t v12 = vsubq_f32(vmulq_n_f32((float32x4_t)a2->var1, 1.0 / *((float *)this + 16)), v8);
  v17[0] = (float32x4_t)v9;
  v17[1] = v11;
  v17[2] = v10;
  uint64_t v18 = v12.i64[0];
  __int32 v19 = v12.i32[2];
  int v20 = 1065353216;
  C3DMatrix4x4Scale(v17, (float32x2_t *)this + 2);
  uint64_t Parent = C3DNodeGetParent(*((void *)this + 9));
  if (Parent)
  {
    float32x4_t v14 = (float32x4_t *)Parent;
    if (C3DNodeGetParent(Parent))
    {
      WorldMatrix = (simd_float4x4 *)C3DNodeGetWorldMatrix(v14);
      C3DMatrix4x4Invert(WorldMatrix, &v16);
      C3DMatrix4x4Mult((uint64_t)v17, (float32x4_t *)&v16, v17);
    }
  }
  C3DNodeSetMatrix(*((float32x4_t **)this + 9), (uint64_t)v17);
}

btRigidBody *__modifyCollisionFlagsFromType(btRigidBody *this, SCNPhysicsBodyType a2)
{
  uint64_t v2 = this;
  unsigned int v3 = *((_DWORD *)this + 58) & 0xFFFFFFFC;
  if (a2 == SCNPhysicsBodyTypeKinematic)
  {
    unsigned int v4 = v3 | 2;
    this = (btRigidBody *)btCollisionObject::setActivationState((btCollisionObject *)this, 4);
  }
  else if (a2)
  {
    unsigned int v4 = *((_DWORD *)this + 58) & 0xFFFFFFFC;
  }
  else
  {
    unsigned int v4 = v3 | 1;
  }
  uint64_t v5 = *((void *)v2 + 26);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 + 8);
    if (v6 == 21) {
      int v7 = v4 | 8;
    }
    else {
      int v7 = v4;
    }
    if (v6 == 22) {
      v4 |= 8u;
    }
    else {
      unsigned int v4 = v7;
    }
  }
  *((_DWORD *)v2 + 58) = v4;
  return this;
}

uint64_t __updateCCDRadiusIfNeeded(uint64_t result)
{
  if (*(float *)(result + 288) > 0.0)
  {
    uint64_t v1 = result;
    float32x4_t result = *(void *)(result + 208);
    int v4 = 0;
    if (result)
    {
      float32x4_t result = (*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(void *)result + 24))(result, &v3, &v4);
      int v2 = v4;
    }
    else
    {
      int v2 = 0;
    }
    *(_DWORD *)(v1 + 284) = v2;
  }
  return result;
}

btCollisionShape *__integrateCenterOfMassOffsetIfNeeded(btQuaternion *a1, btVector3 a2, uint64_t a3)
{
  uint64_t v3 = (btCollisionShape *)a1;
  if (a1)
  {
    if (*(float *)a3 != 0.0 || *(float *)(a3 + 4) != 0.0 || *(float *)(a3 + 8) != 0.0)
    {
      Identity = btQuaternion::getIdentity(a1);
      v7.i64[0] = 0x8000000080000000;
      v7.i64[1] = 0x8000000080000000;
      btVector3 v9 = (btVector3)veorq_s8(*(int8x16_t *)a3, v7);
      btMatrix3x3::setRotation(&v10.var0, (float32x4_t *)Identity);
      v10.int var1 = v9;
      if (v3->var1 == 31 && v3->var2 == (void *)2880154539)
      {
        btCompoundShape::updateChildTransform(v3, 0, &v10, 1);
        return v3;
      }
      uint64_t v5 = (btCompoundShape *)btAlignedAllocInternal(128, 16);
      btCompoundShape::btCompoundShape(v5, 1);
      *((void *)v5 + 2) = 2880154539;
      btCompoundShape::addChildShape(v5, &v10, v3, 0);
      return (btCollisionShape *)v5;
    }
    if (LODWORD(a1->var0.var0[2]) == 31 && *(void *)a1[1].var0.var0 == 2880154539)
    {
      uint64_t v5 = *(btCompoundShape **)(*(void *)&a1[2].var0.var0[2] + 64);
      (*(void (**)(btQuaternion *))(*(void *)a1->var0.var0 + 8))(a1);
      return (btCollisionShape *)v5;
    }
  }
  return v3;
}

void sub_20B39DD08(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

long long *btQuaternion::getIdentity(btQuaternion *this)
{
  {
    btQuaternion::getIdentity(void)::identityQuat = xmmword_20B5CB530;
  }
  return &btQuaternion::getIdentity(void)::identityQuat;
}

void __setCollisionShape(uint64_t a1, btQuaternion *a2, unsigned long long *a3, long long *a4, double a5, float a6, float a7, float a8)
{
  long long v13 = *a4;
  int v11 = v13;
  float32x4_t v12 = __integrateCenterOfMassOffsetIfNeeded(a2, *(btVector3 *)(&a6 - 1), (uint64_t)&v13);
  (*(void (**)(uint64_t, btCollisionShape *))(*(void *)a1 + 24))(a1, v12);
  __updateCCDRadiusIfNeeded(a1);
  __updateMassAndLocalInertia((btRigidBody *)a1, v12, a3, a5);
  if (v12)
  {
    if ((v12->var1 - 21) <= 1) {
      *(_DWORD *)(a1 + 232) |= 8u;
    }
  }
}

void __updateMassAndLocalInertia(btRigidBody *this, _DWORD *a2, unsigned long long *a3, double a4)
{
  unsigned long long v13 = 0uLL;
  if (a3)
  {
    unsigned long long v6 = *a3;
    HIDWORD(v6) = 0;
    unsigned long long v13 = v6;
  }
  else if (a2 && (*((unsigned char *)this + 232) & 1) == 0)
  {
    unsigned int v8 = a2[2];
    BOOL v9 = v8 > 0x1C;
    int v10 = (1 << v8) & 0x10608000;
    if (v9 || v10 == 0)
    {
      float v12 = a4;
      (*(void (**)(_DWORD *, unsigned long long *, float))(*(void *)a2 + 64))(a2, &v13, v12);
    }
  }
  float v7 = a4;
  btRigidBody::setMassProps(this, v7, (const btVector3 *)&v13);
  btRigidBody::updateInertiaTensor(this);
}

void sub_20B39E188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20B39E2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20B39E5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DNodePhysicsBodyIsAtRest(uint64_t a1)
{
  uint64_t v1 = [+[SCNNode nodeWithNodeRef:a1] physicsBody];

  return [(SCNPhysicsBody *)v1 isResting];
}

BOOL C3DNodePhysicsBodyIsDynamic(uint64_t a1)
{
  return [(SCNPhysicsBody *)[+[SCNNode nodeWithNodeRef:a1] physicsBody] type] == SCNPhysicsBodyTypeDynamic;
}

__n128 __copy_helper_block_e16_48c14_ZTS9btVector3(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void _recreateProxy(btDynamicsWorld *a1, btCollisionObject *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    (*(void (**)(btDynamicsWorld *))(*(void *)a1 + 184))(a1);
    (*(void (**)(btDynamicsWorld *, btCollisionObject *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 176))(a1, a2, a4, a3, a5);
    btCollisionObject::activate(a2, 0);
  }
  else
  {
    int v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v11 = 0;
      _os_log_impl(&dword_20B249000, v10, OS_LOG_TYPE_DEFAULT, "Warning: cannot change collision bit masks without physics world", v11, 2u);
    }
  }
}

float32x4_t btRigidBody::applyImpulse(btRigidBody *this, float32x4_t *a2, int8x16_t *a3)
{
  result.i32[0] = *((_DWORD *)this + 96);
  if (result.f32[0] != 0.0)
  {
    float32x4_t v4 = *((float32x4_t *)this + 25);
    float32x4_t v5 = vmulq_n_f32(vmulq_f32(*a2, v4), result.f32[0]);
    v5.i32[3] = 0;
    float32x4_t v6 = *((float32x4_t *)this + 21);
    *((float32x4_t *)this + 22) = vaddq_f32(*((float32x4_t *)this + 22), v5);
    float32x4_t v7 = vmulq_f32(v4, *a2);
    *(int8x8_t *)v8.f32 = vext_s8(*(int8x8_t *)a3->i8, (int8x8_t)*(_OWORD *)&vextq_s8(*a3, *a3, 8uLL), 4uLL);
    v8.i64[1] = a3->i64[0];
    v9.i64[0] = vextq_s8((int8x16_t)v7, (int8x16_t)v7, 4uLL).u64[0];
    v9.i64[1] = v7.i64[0];
    int8x16_t v10 = (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)a3, v9), vmulq_f32(v7, v8));
    v4.i64[0] = vextq_s8(v10, v10, 4uLL).u64[0];
    v4.i64[1] = v10.i64[0];
    float32x4_t v11 = v4;
    v11.i32[3] = 0;
    int8x16_t v12 = (int8x16_t)vmulq_f32(v6, v4);
    int8x16_t v13 = (int8x16_t)vmulq_f32(*((float32x4_t *)this + 19), v11);
    float32x4_t v14 = vmulq_f32(*((float32x4_t *)this + 20), v11);
    v12.i32[3] = 0;
    *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v14.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
    *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)), 0);
    float32x4_t result = vaddq_f32(*((float32x4_t *)this + 23), vmulq_f32(*((float32x4_t *)this + 39), v14));
    *((float32x4_t *)this + 23) = result;
  }
  return result;
}

void sub_20B3A0DBC(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

C3D::DrawNodesPass *C3D::PickedObjectPass::PickedObjectPass(C3D::PickedObjectPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  uint64_t v5 = 0;
  long long v7 = 0u;
  uint64_t v8 = 0x20000;
  memset(v4, 0, sizeof(v4));
  uint64_t v6 = -1;
  BYTE8(v7) = 1;
  float32x4_t result = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, (const Parameters *)v4);
  *(void *)float32x4_t result = &unk_26BF6D800;
  return result;
}

const char *C3D::PickedObjectPass::name(C3D::PickedObjectPass *this)
{
  return "PickedObjectPass";
}

const char *C3D::PickedObjectPass::programHashCodeStoreName(C3D::PickedObjectPass *this)
{
  return "PickedObjectPass";
}

void C3D::PickedObjectPass::setup(C3D::PickedObjectPass *this)
{
  C3D::Pass::setOutputCount(this, 2u);
  *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0) + 8) = "COLOR_PICKED";
  *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0) + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v10);
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0);
  *(_OWORD *)(v2 + 16) = v10;
  *(_DWORD *)(v2 + 32) = v11;
  uint64_t v3 = C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0);
  *(_WORD *)(v3 + 66) = *(_WORD *)(v3 + 66) & 0xFFFC | 2;
  uint64_t v4 = C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0);
  *(_WORD *)(v4 + 66) |= 0x40u;
  *(_OWORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 0) + 48) = xmmword_20B5CB530;
  *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 1u) + 8) = "DEPTH_PICKED";
  *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 1u) + 64) = 2;
  C3D::Pass::parentDepthDesc(this, (uint64_t)&v10);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 1u);
  *(_OWORD *)(v5 + 16) = v10;
  *(_DWORD *)(v5 + 32) = v11;
  uint64_t v6 = C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)this + 32), 1u);
  *(_WORD *)(v6 + 66) = *(_WORD *)(v6 + 66) & 0xFFFC | 2;
  *((unsigned char *)this + 296) = 0;
  *((_WORD *)this + 149) |= 0x20u;
  AuthoringEnvironment = (void *)C3DEngineContextGetAuthoringEnvironment(*((void *)this + 2), 0);
  SelectedNodes = (C3D *)C3DAuthoringEnvironmentGetSelectedNodes(AuthoringEnvironment);
  *((void *)this + 34) = C3D::flattenedNodesForSelectedNodes(SelectedNodes, *((const __CFArray **)this + 2), *(__C3DEngineContext **)(*((void *)this + 3) + 16), v9);
  C3D::DrawNodesPass::setup(this);
}

void C3D::PickedObjectPass::compile(C3D::PickedObjectPass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::PickedObjectPass *))(*(void *)this + 64))(this);
  uint64_t v3 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 670) = v3;
  if (!v3) {
    operator new();
  }
  *((void *)this + 32) = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v3 + 16);

  C3D::DrawNodesPass::compile(this);
}

BOOL C3D::PickedObjectPass::_shouldPushNodeToVisible(C3D::PickedObjectPass *this, __C3DNode *a2)
{
  if (C3DNodeGetFloor((uint64_t)a2)) {
    return 0;
  }

  return C3D::DrawNodesPass::_shouldPushNodeToVisible(this, a2);
}

void C3D::PickedObjectPassResource::~PickedObjectPassResource(C3D::PickedObjectPassResource *this)
{
  *(void *)this = &unk_26BF6E4B0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E4B0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x210534FE0);
}

id _C3DAnimationCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[15];
  if (v2)
  {
    CFRelease(v2);
    a1[15] = 0;
  }
  uint64_t v3 = (const void *)a1[12];
  if (v3)
  {
    CFRelease(v3);
    a1[12] = 0;
  }
  uint64_t v4 = (const void *)a1[8];
  if (v4)
  {
    CFRelease(v4);
    a1[8] = 0;
  }

  return C3DEntityCFFinalize((uint64_t)a1);
}

uint64_t _C3DAnimationInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityInitWithPropertyList(a1, a2);
  if (v14)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"duration");
    if (Value)
    {
      CFNumberRef v16 = Value;
      CFTypeID v17 = CFGetTypeID(Value);
      if (v17 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v16, kCFNumberDoubleType, &valuePtr);
        float v18 = valuePtr;
        *(float *)(a1 + 72) = v18;
      }
    }
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"repeatCount");
    if (v19)
    {
      CFNumberRef v20 = v19;
      CFTypeID v21 = CFGetTypeID(v19);
      if (v21 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v20, kCFNumberFloatType, &valuePtr);
        *(_DWORD *)(a1 + 76) = LODWORD(valuePtr);
      }
    }
    CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a2, @"autoreverses");
    if (v22)
    {
      CFNumberRef v23 = v22;
      CFTypeID v24 = CFGetTypeID(v22);
      if (v24 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v23, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFE | LOBYTE(valuePtr) & 1;
      }
    }
    CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(a2, @"additive");
    if (v25)
    {
      CFNumberRef v26 = v25;
      CFTypeID v27 = CFGetTypeID(v25);
      if (v27 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = (2 * (LOBYTE(valuePtr) & 1)) | *(_WORD *)(a1 + 84) & 0xFFFD;
      }
    }
    CFNumberRef v28 = (const __CFNumber *)CFDictionaryGetValue(a2, @"cumulative");
    if (v28)
    {
      CFNumberRef v29 = v28;
      CFTypeID v30 = CFGetTypeID(v28);
      if (v30 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v29, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = (4 * (LOBYTE(valuePtr) & 1)) | *(_WORD *)(a1 + 84) & 0xFFFB;
      }
    }
    CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(a2, @"isAnimationClip");
    if (v31)
    {
      CFNumberRef v32 = v31;
      CFTypeID v33 = CFGetTypeID(v31);
      if (v33 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = ((LOBYTE(valuePtr) & 1) << 8) | *(_WORD *)(a1 + 84) & 0xFEFF;
      }
    }
    CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(a2, @"removeOnCompletion");
    if (v34)
    {
      CFNumberRef v35 = v34;
      CFTypeID v36 = CFGetTypeID(v34);
      if (v36 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v35, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = (16 * (LOBYTE(valuePtr) & 1)) | *(_WORD *)(a1 + 84) & 0xFFEF;
      }
    }
    CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(a2, @"sceneTimeBased");
    if (v37)
    {
      CFNumberRef v38 = v37;
      CFTypeID v39 = CFGetTypeID(v37);
      if (v39 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v38, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = (8 * (LOBYTE(valuePtr) & 1)) | *(_WORD *)(a1 + 84) & 0xFFF7;
      }
    }
    CFNumberRef v40 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fillModeMask");
    if (v40)
    {
      CFNumberRef v41 = v40;
      CFTypeID v42 = CFGetTypeID(v40);
      if (v42 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v41, kCFNumberIntType, &valuePtr);
        *(_WORD *)(a1 + 84) = ((LOBYTE(valuePtr) & 3) << 6) | *(_WORD *)(a1 + 84) & 0xFF3F;
      }
    }
    CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(a2, @"timeOffset");
    if (v43)
    {
      CFNumberRef v44 = v43;
      CFTypeID v45 = CFGetTypeID(v43);
      if (v45 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v44, kCFNumberDoubleType, &valuePtr);
        *(double *)(a1 + 136) = valuePtr;
      }
    }
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(a2, @"beginTime");
    if (v46)
    {
      CFNumberRef v47 = v46;
      CFTypeID v48 = CFGetTypeID(v46);
      if (v48 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v47, kCFNumberDoubleType, &valuePtr);
        *(double *)(a1 + 128) = valuePtr;
      }
    }
    CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(a2, @"speed");
    if (v49)
    {
      CFNumberRef v50 = v49;
      CFTypeID v51 = CFGetTypeID(v49);
      if (v51 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v50, kCFNumberCGFloatType, &valuePtr);
        float v52 = valuePtr;
        *(float *)(a1 + 80) = v52;
      }
    }
    CFNumberRef v53 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fadeInDuration");
    if (v53)
    {
      CFNumberRef v54 = v53;
      CFTypeID v55 = CFGetTypeID(v53);
      if (v55 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v54, kCFNumberCGFloatType, &valuePtr);
        float v56 = valuePtr;
        *(float *)(a1 + 108) = v56;
      }
    }
    CFNumberRef v57 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fadeOutDuration");
    if (v57)
    {
      CFNumberRef v58 = v57;
      CFTypeID v59 = CFGetTypeID(v57);
      if (v59 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v58, kCFNumberCGFloatType, &valuePtr);
        float v60 = valuePtr;
        *(float *)(a1 + 112) = v60;
      }
    }
    if (a3)
    {
      uint64_t v61 = CFDictionaryGetValue(a3, @"kSceneSourceAnimationLoadingMode");
      if (v61)
      {
        uint64_t v62 = v61;
        BOOL v63 = CFEqual(v61, @"playUsingSceneTime") != 0;
        C3DAnimationSetIsSceneTimeBased(a1, v63);
        BOOL v64 = CFEqual(v62, @"playUsingSceneTime") == 0;
        C3DAnimationSetRemoveOnCompletion(a1, v64);
        int v65 = CFEqual(v62, @"playRepeatedly");
        float v66 = INFINITY;
        if (!v65) {
          float v66 = 0.0;
        }
        C3DAnimationSetRepeatCount(a1, v66);
      }
    }
    unint64_t v67 = CFDictionaryGetValue(a2, @"timingFunction");
    if (v67) {
      *(void *)(a1 + 120) = C3DTimingFunctionCreateWithPropertyList(v67);
    }
  }
  else
  {
    uint64_t v68 = scn_default_log();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      _C3DAnimationInitWithPropertyList_cold_1(v68);
    }
  }
  return v14;
}

void C3DAnimationSetIsSceneTimeBased(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 8;
  }
  else {
    __int16 v12 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFF7 | v12;
}

void C3DAnimationSetRemoveOnCompletion(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 16;
  }
  else {
    __int16 v12 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFEF | v12;
}

void C3DAnimationSetRepeatCount(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 76) = a2;
}

const void *C3DAnimationCreateWithPropertyList(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"type");
  if (CFStringCompare(Value, @"simpleAnimation", 0))
  {
    if (CFStringCompare(Value, @"keyframedAnimation", 0))
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        C3DAnimationCreateWithPropertyList_cold_1((uint64_t)Value, v7);
      }
      return 0;
    }
    uint64_t v8 = (const void *)C3DKeyframedAnimationCreate();
  }
  else
  {
    uint64_t v8 = (const void *)C3DSimpleAnimationCreate();
  }
  uint64_t v9 = v8;
  if (v8 && (C3DInitWithPropertyList(v8, (uint64_t)a1, a2, a3) & 1) == 0)
  {
    CFRelease(v9);
    return 0;
  }
  return v9;
}

uint64_t C3DSimpleAnimationCreate()
{
  if (C3DSimpleAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSimpleAnimationGetTypeID_onceToken, &__block_literal_global_58);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DSimpleAnimationGetTypeID_typeID, 0x170uLL);
  *(_DWORD *)(result + 104) = 1065353216;
  *(_DWORD *)(result + 80) = 1065353216;
  *(_WORD *)(result + 84) |= 0xD0u;
  return result;
}

__CFDictionary *_C3DAnimationCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFNumberRef v16 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  double valuePtr = *(float *)(a1 + 72);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionaryAddValue(v16, @"duration", v17);
  CFRelease(v17);
  LODWORD(valuePtr) = *(_DWORD *)(a1 + 76);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  CFDictionaryAddValue(v16, @"repeatCount", v18);
  CFRelease(v18);
  LODWORD(valuePtr) = *(_WORD *)(a1 + 84) & 1;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"autoreverses", v19);
  CFRelease(v19);
  unsigned int v20 = *(unsigned __int16 *)(a1 + 84);
  if ((v20 & 0x100) != 0)
  {
    LODWORD(valuePtr) = (v20 >> 8) & 1;
    CFNumberRef v21 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v16, @"isAnimationClip", v21);
    CFRelease(v21);
    unsigned int v20 = *(unsigned __int16 *)(a1 + 84);
  }
  LODWORD(valuePtr) = (v20 >> 1) & 1;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"additive", v22);
  CFRelease(v22);
  LODWORD(valuePtr) = (*(unsigned __int16 *)(a1 + 84) >> 2) & 1;
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"cumulative", v23);
  CFRelease(v23);
  LODWORD(valuePtr) = (*(unsigned __int16 *)(a1 + 84) >> 4) & 1;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"removeOnCompletion", v24);
  CFRelease(v24);
  LODWORD(valuePtr) = (*(unsigned __int16 *)(a1 + 84) >> 3) & 1;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"sceneTimeBased", v25);
  CFRelease(v25);
  LODWORD(valuePtr) = *(_WORD *)(a1 + 84) >> 6;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v16, @"fillModeMask", v26);
  CFRelease(v26);
  double valuePtr = *(double *)(a1 + 136);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionaryAddValue(v16, @"timeOffset", v27);
  CFRelease(v27);
  double valuePtr = *(double *)(a1 + 128);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionaryAddValue(v16, @"beginTime", v28);
  CFRelease(v28);
  double valuePtr = *(float *)(a1 + 80);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(v16, @"speed", v29);
  CFRelease(v29);
  double valuePtr = *(float *)(a1 + 112);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(v16, @"fadeOutDuration", v30);
  CFRelease(v30);
  double valuePtr = *(float *)(a1 + 108);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(v16, @"fadeInDuration", v31);
  CFRelease(v31);
  CFNumberRef v32 = *(const void **)(a1 + 120);
  if (v32)
  {
    CFTypeID v33 = (const void *)C3DCopyPropertyList(v32, a2, a3, a4);
    CFDictionaryAddValue(v16, @"timingFunction", v33);
    if (v33) {
      CFRelease(v33);
    }
  }
  return v16;
}

uint64_t C3DAnimationCommonInit(uint64_t result)
{
  *(_DWORD *)(result + 104) = 1065353216;
  *(_DWORD *)(result + 80) = 1065353216;
  *(_WORD *)(result + 84) |= 0xD0u;
  return result;
}

uint64_t C3DAnimationEvaluate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 88))();
}

const void *C3DAnimationCopyTarget(uint64_t a1, float32x4_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFArrayRef v12 = *(const __CFArray **)(a1 + 64);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = C3DCFTypeCopyModelInfoAtSplittedPath(a2, v12, 0, 1);
  uint64_t v14 = (const void *)v13;
  if (v13 && !C3DModelTargetGetTargetAddress(v13))
  {
    CFRelease(v14);
    return 0;
  }
  return v14;
}

CFTypeRef C3DAnimationSetKeyPath(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 64);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 64) = result;
  }
  return result;
}

uint64_t C3DAnimationGetKeyPath(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

BOOL C3DAnimationIsGroup(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  return v1 == C3DAnimationGroupGetTypeID();
}

void C3DAnimationSetDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 72) = a2;
}

float C3DAnimationGetDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 72);
}

float C3DAnimationGetTotalDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  float v10 = *(float *)(a1 + 76);
  if (v10 == INFINITY || v10 == 3.4028e38) {
    return 3.4028e38;
  }
  float v13 = 1.0;
  if (v10 == 0.0) {
    float v10 = 1.0;
  }
  float v14 = v10 * *(float *)(a1 + 72);
  if (*(_WORD *)(a1 + 84)) {
    float v13 = 2.0;
  }
  return v14 * v13;
}

float C3DAnimationGetRepeatCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 76);
}

void C3DAnimationSetAutoreverses(uint64_t a1, __int16 a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFE | a2;
}

uint64_t C3DAnimationGetAutoreverses(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_WORD *)(a1 + 84) & 1;
}

CFTypeRef C3DAnimationSetTimingFunction(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 120);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 120) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 120) = result;
  }
  return result;
}

uint64_t C3DAnimationGetTimingFunction(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 120);
}

void C3DAnimationSetAdditive(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 2;
  }
  else {
    __int16 v12 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFD | v12;
}

uint64_t C3DAnimationGetCumulative(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 2) & 1;
}

void C3DAnimationSetCumulative(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 4;
  }
  else {
    __int16 v12 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFB | v12;
}

uint64_t C3DAnimationGetAdditive(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 1) & 1;
}

uint64_t C3DAnimationGetRemoveOnCompletion(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 4) & 1;
}

uint64_t C3DAnimationGetIsSceneTimeBased(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 3) & 1;
}

CFStringRef C3DAnimationSetName(uint64_t a1, CFStringRef theString)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntitySetName(a1, theString);
}

uint64_t C3DAnimationGetName(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetName(a1);
}

void C3DAnimationSetTimeOffset(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 136) = a2;
}

double C3DAnimationGetTimeOffset(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 136);
}

void C3DAnimationSetSpeed(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 80) = a2;
}

float C3DAnimationGetSpeed(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 80);
}

void C3DAnimationSetFadeInDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 108) = a2;
}

float C3DAnimationGetFadeInDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 108);
}

void C3DAnimationSetFadeOutDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 112) = a2;
}

float C3DAnimationGetFadeOutDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 112);
}

void C3DAnimationSetWeight(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 104) = a2;
}

float C3DAnimationGetWeight(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 104);
}

uint64_t C3DAnimationSetCommitWhenDone(_WORD *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 32;
  }
  else {
    __int16 v12 = 0;
  }
  a1[42] = a1[42] & 0xFFDF | v12;
  CFTypeID v13 = CFGetTypeID(a1);
  uint64_t result = C3DAnimationGroupGetTypeID();
  if (v13 == result)
  {
    uint64_t result = C3DAnimationGroupGetAnimationCount((uint64_t)a1);
    if (result >= 1)
    {
      uint64_t v15 = result;
      for (CFIndex i = 0; i != v15; ++i)
      {
        AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex((uint64_t)a1, i);
        uint64_t result = C3DAnimationSetCommitWhenDone(AnimationAtIndex, a2);
      }
    }
  }
  return result;
}

uint64_t C3DAnimationGetCommitWhenDone(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 5) & 1;
}

BOOL _C3DAnimationReadsDestinationBuffer(unsigned char *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (C3DSimpleAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSimpleAnimationGetTypeID_onceToken, &__block_literal_global_58);
  }
  if (v2 != C3DSimpleAnimationGetTypeID_typeID) {
    return 0;
  }
  if (a1[372]) {
    return 1;
  }
  return a1[373] != 0;
}

uint64_t C3DSimpleAnimationGetTypeID()
{
  if (C3DSimpleAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSimpleAnimationGetTypeID_onceToken, &__block_literal_global_58);
  }
  return C3DSimpleAnimationGetTypeID_typeID;
}

uint64_t C3DAnimationGetAnimationCallbacks(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 144;
}

uint64_t C3DAnimationGetDelegate(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 160);
}

void C3DAnimationSetDelegate(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 160) = a2;
}

uint64_t C3DAnimationGetAnimationEvents(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 96);
}

CFTypeRef C3DAnimationSetAnimationEvents(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 96);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 96) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 96) = result;
  }
  return result;
}

void C3DAnimationSetIsImplicit(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    __int16 v12 = 512;
  }
  else {
    __int16 v12 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFDFF | v12;
}

uint64_t C3DAnimationGetIsImplicit(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 9) & 1;
}

uint64_t C3DAnimationGetFillModeMask(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_WORD *)(a1 + 84) >> 6;
}

void C3DAnimationSetFillModeMask(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFF3F | ((a2 & 3) << 6);
}

uint64_t C3DAnimationSetup(CFTypeRef cf, uint64_t a2)
{
  if (!cf)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeID v12 = CFGetTypeID(cf);
  if (C3DSimpleAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSimpleAnimationGetTypeID_onceToken, &__block_literal_global_58);
  }
  if (v12 == C3DSimpleAnimationGetTypeID_typeID)
  {
    *((void *)cf + 11) = C3DSimpleAnimationEvaluate;
    return C3DSimpleAnimationSetup((uint64_t)cf, a2);
  }
  else if (v12 == C3DKeyframedAnimationGetTypeID())
  {
    *((void *)cf + 11) = C3DKeyframedAnimationEvaluate;
    return C3DKeyframedAnimationSetup((uint64_t)cf);
  }
  else
  {
    float v14 = scn_default_log();
    uint64_t result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (result)
    {
      C3DAnimationSetup_cold_1();
      return 0;
    }
  }
  return result;
}

BOOL C3DSimpleAnimationEvaluate(uint64_t a1, int a2, float32x2_t *a3, double a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DSimpleAnimationEvaluate_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  CFNumberRef v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DSimpleAnimationEvaluate_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t v24 = *(void *)(a1 + 376);
  if (v24)
  {
    if (*(unsigned char *)(a1 + 372)) {
      CFNumberRef v25 = a3;
    }
    else {
      CFNumberRef v25 = (float32x2_t *)(a1 + 176);
    }
    if (*(unsigned char *)(a1 + 373))
    {
      uint64_t v26 = (uint64_t)a3;
      if ((*(unsigned char *)(a1 + 374) & 4) != 0)
      {
        uint64_t v26 = a1 + 304;
        C3DAddBaseType(*(__int16 *)(a1 + 368), v25, (float32x2_t *)(a1 + 240), (float32x4_t *)(a1 + 304));
      }
    }
    else
    {
      uint64_t v26 = a1 + 304;
    }
    CFNumberRef v28 = *(void (**)(float32x2_t *, float32x2_t *, void, void, void, uint64_t, float32x2_t *, __n128))(a1 + 376);
    uint64_t Additive = C3DAnimationGetAdditive(a1);
    if (a2)
    {
      v30.n128_f64[0] = 1.0 - a4;
      CFNumberRef v31 = (float32x2_t *)v26;
      CFNumberRef v32 = v25;
    }
    else
    {
      v30.n128_f64[0] = a4;
      CFNumberRef v31 = v25;
      CFNumberRef v32 = (float32x2_t *)v26;
    }
    v28(v31, v32, 0, 0, 0, Additive, a3, v30);
  }
  else
  {
    CFNumberRef v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      C3DSimpleAnimationEvaluate_cold_1();
    }
  }
  return v24 != 0;
}

uint64_t C3DSimpleAnimationSetup(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_4;
    }
  }
  else if (a2)
  {
LABEL_4:
    Basechar Type = C3DModelTargetGetBaseType(a2);
    TypeSemantiCC_SHA256_CTX c = C3DModelTargetGetTypeSemantic(a2);
    goto LABEL_7;
  }
  TypeSemantiCC_SHA256_CTX c = 0;
  Basechar Type = *(_WORD *)(a1 + 368);
LABEL_7:
  int v14 = BaseType;
  uint64_t v15 = C3DKeyFrameInterpolatorForType(BaseType, TypeSemantic, 0, 0, 1);
  *(void *)(a1 + 376) = v15;
  if (!v15) {
    return 0;
  }
  int v16 = *(unsigned __int8 *)(a1 + 374);
  if ((~v16 & 3) != 0)
  {
    if ((~v16 & 5) == 0)
    {
      C3DAddBaseType(*(__int16 *)(a1 + 368), (float32x2_t *)(a1 + 176), (float32x2_t *)(a1 + 240), (float32x4_t *)(a1 + 304));
      return 1;
    }
    if ((~v16 & 6) == 0)
    {
      C3DSubBaseType(*(__int16 *)(a1 + 368), (float32x2_t *)(a1 + 304), (float32x2_t *)(a1 + 240), (float32x4_t *)(a1 + 176));
      return 1;
    }
    if (v16)
    {
      uint64_t v17 = 1;
      *(unsigned char *)(a1 + 373) = 1;
      return v17;
    }
    if ((v16 & 2) != 0)
    {
      uint64_t v17 = 1;
      *(unsigned char *)(a1 + 372) = 1;
      return v17;
    }
    if ((v16 & 4) != 0)
    {
      *(_WORD *)(a1 + 372) = 257;
      return 1;
    }
    uint64_t TargetAddress = C3DModelTargetGetTargetAddress(a2);
    if (TargetAddress)
    {
      uint64_t v19 = (const void *)TargetAddress;
      uint64_t v17 = 1;
      uint64_t v20 = (const void *)C3DValueCreate(v14, 1);
      Target = (const void *)C3DModelTargetGetTarget(a2);
      Bytes = (void *)C3DValueGetBytes((uint64_t)v20);
      size_t Length = C3DValueGetLength((uint64_t)v20);
      uint64_t v24 = C3DModelTargetGetTypeSemantic(a2);
      Componentuint64_t Index = C3DModelTargetGetComponentIndex(a2);
      C3DGetValue(Target, v19, Bytes, Length, v24, ComponentIndex);
      C3DSimpleAnimationSetStartValue(a1, (uint64_t)v20);
      *(unsigned char *)(a1 + 373) = 1;
      CFRelease(v20);
      return v17;
    }
    return 0;
  }
  return 1;
}

__n128 C3DAnimationCopySettingsToAnimation(uint64_t a1, __n128 *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DKeyframedAnimationCopy_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationForKey_cold_4(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFStringRef Name = (const __CFString *)C3DAnimationGetName(a1);
  C3DAnimationSetName((uint64_t)a2, Name);
  C3DAnimationSetKeyPath((uint64_t)a2, *(CFTypeRef *)(a1 + 64));
  Duratioint n = C3DAnimationGetDuration(a1);
  C3DAnimationSetDuration((uint64_t)a2, Duration);
  Repeatsize_t Count = C3DAnimationGetRepeatCount(a1);
  C3DAnimationSetRepeatCount((uint64_t)a2, RepeatCount);
  __int16 Autoreverses = C3DAnimationGetAutoreverses(a1);
  C3DAnimationSetAutoreverses((uint64_t)a2, Autoreverses);
  TimingFunctioint n = (const void *)C3DAnimationGetTimingFunction(a1);
  C3DAnimationSetTimingFunction((uint64_t)a2, TimingFunction);
  int Additive = C3DAnimationGetAdditive(a1);
  C3DAnimationSetAdditive((uint64_t)a2, Additive);
  int Cumulative = C3DAnimationGetCumulative(a1);
  C3DAnimationSetCumulative((uint64_t)a2, Cumulative);
  int IsSceneTimeBased = C3DAnimationGetIsSceneTimeBased(a1);
  C3DAnimationSetIsSceneTimeBased((uint64_t)a2, IsSceneTimeBased);
  int v28 = C3DAnimationGetRemoveOnCompletion(a1);
  C3DAnimationSetRemoveOnCompletion((uint64_t)a2, v28);
  double PauseTime = C3DAnimationNodeGetPauseTime(a1);
  C3DAnimationNodeSetPauseTime((uint64_t)a2, PauseTime);
  double TimeOffset = C3DAnimationGetTimeOffset(a1);
  C3DAnimationSetTimeOffset((uint64_t)a2, TimeOffset);
  float Speed = C3DAnimationGetSpeed(a1);
  C3DAnimationSetSpeed((uint64_t)a2, Speed);
  uint64_t CommitWhenDone = C3DAnimationGetCommitWhenDone(a1);
  C3DAnimationSetCommitWhenDone(a2, CommitWhenDone);
  FillModeMasuint64_t k = C3DAnimationGetFillModeMask(a1);
  C3DAnimationSetFillModeMask((uint64_t)a2, FillModeMask);
  float Weight = C3DAnimationGetWeight(a1);
  C3DAnimationSetWeight((uint64_t)a2, Weight);
  FadeInDuratioint n = C3DAnimationGetFadeInDuration(a1);
  C3DAnimationSetFadeInDuration((uint64_t)a2, FadeInDuration);
  FadeOutDuratioint n = C3DAnimationGetFadeOutDuration(a1);
  C3DAnimationSetFadeOutDuration((uint64_t)a2, FadeOutDuration);
  AnimationEvents = (const void *)C3DAnimationGetAnimationEvents(a1);
  C3DAnimationSetAnimationEvents((uint64_t)a2, AnimationEvents);
  uint64_t Delegate = C3DAnimationGetDelegate(a1);
  C3DAnimationSetDelegate((uint64_t)a2, Delegate);
  a2[5].n128_u16[2] = a2[5].n128_u16[2] & 0xFEFF | *(_WORD *)(a1 + 84) & 0x100;
  __n128 result = *(__n128 *)(a1 + 144);
  a2[9] = result;
  return result;
}

CFTypeRef *C3DAnimationCreateCopy(CFTypeRef cf)
{
  if (!cf)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (C3DSimpleAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSimpleAnimationGetTypeID_onceToken, &__block_literal_global_58);
  }
  if (v10 == C3DSimpleAnimationGetTypeID_typeID)
  {
    uint64_t v11 = (CFTypeRef *)C3DSimpleAnimationCreate();
    C3DSimpleAnimationCopy((uint64_t)cf, (uint64_t)v11);
  }
  else if (v10 == C3DKeyframedAnimationGetTypeID())
  {
    uint64_t v11 = (CFTypeRef *)C3DKeyframedAnimationCreate();
    C3DKeyframedAnimationCopy((uint64_t)cf, (uint64_t)v11);
  }
  else if (v10 == C3DAnimationGroupGetTypeID())
  {
    uint64_t v11 = (CFTypeRef *)C3DAnimationGroupCreate();
    C3DAnimationGroupCopy((uint64_t)cf, (uint64_t)v11);
  }
  else
  {
    if (v10 != C3DAnimationClusterGetTypeID())
    {
      C3DEntityCopyTo((uint64_t)cf, 0);
      return 0;
    }
    uint64_t v11 = (CFTypeRef *)C3DAnimationClusterCreate();
    C3DAnimationClusterCopy((uint64_t)cf, (uint64_t)v11);
  }
  C3DEntityCopyTo((uint64_t)cf, v11);
  if (v11) {
    C3DAnimationCopySettingsToAnimation((uint64_t)cf, (__n128 *)v11);
  }
  return v11;
}

void *C3DSimpleAnimationCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DKeyframedAnimationCopy_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DSimpleAnimationCopy_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  *(void *)(a2 + 376) = *(void *)(a1 + 376);
  memcpy((void *)(a2 + 176), (const void *)(a1 + 176), *(__int16 *)(a1 + 370));
  memcpy((void *)(a2 + 304), (const void *)(a1 + 304), *(__int16 *)(a1 + 370));
  __n128 result = memcpy((void *)(a2 + 240), (const void *)(a1 + 240), *(__int16 *)(a1 + 370));
  char v21 = *(unsigned char *)(a2 + 374) & 0xFE | *(unsigned char *)(a1 + 374) & 1;
  *(unsigned char *)(a2 + 374) = v21;
  char v22 = v21 & 0xFD | (2 * ((*(unsigned char *)(a1 + 374) & 2) != 0));
  *(unsigned char *)(a2 + 374) = v22;
  *(unsigned char *)(a2 + 374) = v22 & 0xFB | *(unsigned char *)(a1 + 374) & 4;
  *(_DWORD *)(a2 + 370) = *(_DWORD *)(a1 + 370);
  *(_WORD *)(a2 + 368) = *(_WORD *)(a1 + 368);
  return result;
}

double __C3DSimpleAnimationGetTypeID_block_invoke()
{
  C3DSimpleAnimationGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DSimpleAnimationContextClassSerializable;
  unk_26B467378 = kC3DC3DSimpleAnimationContextClassSerializable;
  unk_26B467388 = *(_OWORD *)&off_26BF71648;
  return result;
}

size_t C3DSimpleAnimationSetEndValue(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 368) = C3DValueGetType(a2);
  *(unsigned char *)(a1 + 374) |= 2u;
  return C3DValueCopyTo(a2, (void *)(a1 + 304));
}

uint64_t C3DSimpleAnimationCopyEndValue(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 374) & 2) == 0) {
    return 0;
  }
  uint64_t v10 = C3DValueCreate(*(__int16 *)(a1 + 368), 1);
  C3DValueInitFrom(v10, (const void *)(a1 + 304));
  return v10;
}

size_t C3DSimpleAnimationSetStartValue(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 368) = C3DValueGetType(a2);
  *(unsigned char *)(a1 + 374) |= 1u;
  return C3DValueCopyTo(a2, (void *)(a1 + 176));
}

uint64_t C3DSimpleAnimationCopyStartValue(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 374) & 1) == 0) {
    return 0;
  }
  uint64_t v10 = C3DValueCreate(*(__int16 *)(a1 + 368), 1);
  C3DValueInitFrom(v10, (const void *)(a1 + 176));
  return v10;
}

size_t C3DSimpleAnimationSetByValue(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 368) = C3DValueGetType(a2);
  *(unsigned char *)(a1 + 374) |= 4u;
  return C3DValueCopyTo(a2, (void *)(a1 + 240));
}

uint64_t C3DSimpleAnimationCopyByValue(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 374) & 4) == 0) {
    return 0;
  }
  uint64_t v10 = C3DValueCreate(*(__int16 *)(a1 + 368), 1);
  C3DValueInitFrom(v10, (const void *)(a1 + 240));
  return v10;
}

CFStringRef _C3DSimpleAnimationCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DSimpleAnimation>");
}

CFStringRef _C3DSimpleAnimationCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DSimpleAnimation>");
}

BOOL _C3DSimpleAnimationInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if ((_C3DAnimationInitWithPropertyList(a1, a2, a3) & 1) == 0)
  {
    uint64_t v13 = scn_default_log();
    BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DSimpleAnimationInitWithPropertyList_cold_2();
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"baseType");
  if (!Value)
  {
    uint64_t v14 = scn_default_log();
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DSimpleAnimationInitWithPropertyList_cold_1();
    return 0;
  }
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v17 = 0u;
  int valuePtr = 0;
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  uint64_t v6 = (char **)C3DValueCreate((__int16)valuePtr, 1);
  uint64_t v7 = C3DSizeOfBaseType((__int16)valuePtr);
  unint64_t v8 = C3DSizeOfBaseType((__int16)valuePtr);
  CFDataRef v9 = (const __CFData *)CFDictionaryGetValue(a2, @"startValue");
  if (v9)
  {
    v21.locatioint n = 0;
    v21.length = v7;
    CFDataGetBytes(v9, v21, buffer);
    C3DConvertFromPlatformIndependentData((char *)buffer, v6[3], v7, v8, (__int16)valuePtr, 1, 1, 0, 0);
    C3DSimpleAnimationSetStartValue(a1, (uint64_t)v6);
  }
  CFDataRef v10 = (const __CFData *)CFDictionaryGetValue(a2, @"byValue");
  if (v10)
  {
    v22.locatioint n = 0;
    v22.length = v7;
    CFDataGetBytes(v10, v22, buffer);
    C3DConvertFromPlatformIndependentData((char *)buffer, v6[3], v7, v8, (__int16)valuePtr, 1, 1, 0, 0);
    C3DSimpleAnimationSetByValue(a1, (uint64_t)v6);
  }
  CFDataRef v11 = (const __CFData *)CFDictionaryGetValue(a2, @"endValue");
  if (v11)
  {
    v23.locatioint n = 0;
    v23.length = v7;
    CFDataGetBytes(v11, v23, buffer);
    C3DConvertFromPlatformIndependentData((char *)buffer, v6[3], v7, v8, (__int16)valuePtr, 1, 1, 0, 0);
    C3DSimpleAnimationSetEndValue(a1, (uint64_t)v6);
  }
  CFRelease(v6);
  return 1;
}

__CFDictionary *_C3DSimpleAnimationCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v5 = _C3DAnimationCopyPropertyList(a1, a2, a3, a4);
  CFDictionaryAddValue(v5, @"type", @"simpleAnimation");
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)bytes = 0u;
  long long v15 = 0u;
  int valuePtr = *(__int16 *)(a1 + 368);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v5, @"baseType", v6);
  CFRelease(v6);
  uint64_t v7 = C3DSizeOfBaseType((__int16)valuePtr);
  char v8 = *(unsigned char *)(a1 + 374);
  if ((v8 & 1) == 0)
  {
    if ((*(unsigned char *)(a1 + 374) & 4) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    C3DConvertToPlatformIndependentData((char *)(a1 + 240), (char *)bytes, *(__int16 *)(a1 + 370), v7, *(__int16 *)(a1 + 368), 1, 1, 0, 0);
    CFDataRef v12 = CFDataCreate(0, bytes, v7);
    CFDictionaryAddValue(v5, @"byValue", v12);
    CFRelease(v12);
    if ((*(unsigned char *)(a1 + 374) & 2) == 0) {
      return v5;
    }
    goto LABEL_4;
  }
  C3DConvertToPlatformIndependentData((char *)(a1 + 176), (char *)bytes, *(__int16 *)(a1 + 370), v7, *(__int16 *)(a1 + 368), 1, 1, 0, 0);
  CFDataRef v11 = CFDataCreate(0, bytes, v7);
  CFDictionaryAddValue(v5, @"startValue", v11);
  CFRelease(v11);
  char v8 = *(unsigned char *)(a1 + 374);
  if ((v8 & 4) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v8 & 2) != 0)
  {
LABEL_4:
    C3DConvertToPlatformIndependentData((char *)(a1 + 304), (char *)bytes, *(__int16 *)(a1 + 370), v7, *(__int16 *)(a1 + 368), 1, 1, 0, 0);
    CFDataRef v9 = CFDataCreate(0, bytes, v7);
    CFDictionaryAddValue(v5, @"endValue", v9);
    CFRelease(v9);
  }
  return v5;
}

uint64_t _C3DSimpleAnimationFinalizeDeserialization()
{
  return 1;
}

C3D::DrawNodesPass *C3D::SSRDepthBackFacePass::SSRDepthBackFacePass(C3D::SSRDepthBackFacePass *this, RenderGraph *a2, C3D::Pass *a3)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  long long v6 = xmmword_20B5CBBE0;
  char v7 = 0;
  uint64_t v8 = 0;
  char v9 = 2;
  BOOL result = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, (const Parameters *)v4);
  *(void *)BOOL result = &unk_26BF6DF40;
  return result;
}

const char *C3D::SSRDepthBackFacePass::name(C3D::SSRDepthBackFacePass *this)
{
  return "SSRDepthBackFacePass";
}

const char *C3D::SSRDepthBackFacePass::programHashCodeStoreName(C3D::SSRDepthBackFacePass *this)
{
  return "SSRDepthBackFacePass";
}

void C3D::SSRDepthBackFacePass::setup(C3D::SSRDepthBackFacePass *this)
{
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::SSRDepthBackFacePass *)((char *)this + 32), 0);
  *(unsigned char *)(v2 + 64) = 2;
  *(void *)(v2 + 8) = "BackDepth";
  C3D::Pass::parentDepthDesc(this, (uint64_t)&v3);
  *(_OWORD *)(v2 + 16) = v3;
  *(_DWORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 66) = *(_WORD *)(v2 + 66) & 0xFFFC | 2;
  C3D::DrawNodesPass::setup(this);
}

void C3D::SSRDepthBackFacePass::compile(C3D::SSRDepthBackFacePass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::SSRDepthBackFacePass *))(*(void *)this + 64))(this);
  uint64_t v3 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 670) = v3;
  if (!v3) {
    operator new();
  }
  *((void *)this + 32) = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v3 + 16);
  C3D::DrawNodesPass::compile(this);
}

void C3D::SSRDepthBackFacePass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a2;
  if (!*(unsigned char *)(*(void *)a2 + 73) && *(void *)(v2 + 16) != 1)
  {
    *(void *)(v2 + 16) = 1;
    *(unsigned char *)(v2 + 41) = 1;
  }
  *(unsigned char *)(v2 + 73) = 1;
  C3D::DrawNodesPass::execute(a1, a2);
}

void C3D::SSRDepthBackFacePass::Resource::~Resource(C3D::SSRDepthBackFacePass::Resource *this)
{
  *(void *)this = &unk_26BF6DF20;
  CFAllocatorRef v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6DF20;
  CFAllocatorRef v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x210534FE0);
}

void __C3DLightDidChange(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DGetScene(a1);
  if (v10)
  {
    LightingSysteuint64_t m = C3DSceneGetLightingSystem(v10);
    if (LightingSystem)
    {
      uint64_t v12 = LightingSystem;
      C3DLightingSystemLightDidUpdate(LightingSystem, a1);
      if (C3DLightGetTechnique((uint64_t)a1)) {
        C3DLightingSystemAddToLightsWithTechnique(v12, a1);
      }
    }
  }
}

uint64_t C3DLightGetTechnique(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 216);
}

void __C3DLightProbeEnvironmentDidChange(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    ++*(_DWORD *)(a1 + 324);
  }
}

uint64_t C3DLightCreate()
{
  if (C3DLightGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLightGetTypeID_onceToken, &__block_literal_global_60);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DLightGetTypeID_typeID, 0x140uLL);
  __n128 v7 = 0uLL;
  if (C3DWasLinkedBeforeMajorOSYear2014()) {
    int v1 = 0;
  }
  else {
    int v1 = 2;
  }
  C3DLightSetType(Instance, v1);
  C3DColor4Make((float *)&v7, 1.0, 1.0, 1.0, 1.0);
  C3DLightSetColor(Instance, (float *)&v7);
  if (C3DWasLinkedBeforeMajorOSYear2016()) {
    float v2 = 0.5;
  }
  else {
    float v2 = 1.0;
  }
  C3DColor4Make((float *)&v7, 0.0, 0.0, 0.0, v2);
  C3DLightSetShadowColor((__n128 *)Instance, &v7);
  *(void *)(Instance + 192) = 0x3FF0000000000000;
  *(_OWORD *)(Instance + 176) = xmmword_20B5EDCD0;
  *(void *)(Instance + 136) = 0x404000003F800000;
  *(_DWORD *)(Instance + 96) = 1148846080;
  *(void *)(Instance + 160) = -1;
  *(unsigned char *)(Instance + 169) = *(unsigned char *)(Instance + 169) & 0xFE | C3DWasLinkedBeforeMajorOSYear2014();
  *(unsigned char *)(Instance + 156) = 0;
  *(_DWORD *)(Instance + 100) = 1170939904;
  *(_DWORD *)(Instance + 84) = 0;
  *(_DWORD *)(Instance + 88) = 0;
  *(_DWORD *)(Instance + 92) = 0x40000000;
  int v3 = C3DWasLinkedBeforeMajorOSYear2017();
  char v4 = *(unsigned char *)(Instance + 169);
  if (v3) {
    char v5 = 0;
  }
  else {
    char v5 = 32;
  }
  *(unsigned char *)(Instance + 157) = 1;
  *(unsigned char *)(Instance + 169) = v5 & 0xE0 | v4 & 0x1F;
  *(_DWORD *)(Instance + 152) = 0;
  *(void *)(Instance + 144) = 0x3E19999A42C80000;
  C3DLightInitializePerTypeParameters(Instance);
  return Instance;
}

void C3DLightSetType(uint64_t a1, int a2)
{
  if (!a1)
  {
    char v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) != a2)
  {
    C3DLightDestroyPerTypeParameters(a1);
    *(_DWORD *)(a1 + 80) = a2;
    C3DLightInitializePerTypeParameters(a1);
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

void C3DLightSetColor(uint64_t a1, float *a2)
{
  if (!a1 && (char v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DCGColorGetComponentsInColorSpace_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  if (!C3DColor4IsEqualToColor4(a2, (float *)(a1 + 64)))
  {
    IsBlacuint64_t k = C3DColor4IsBlack((float *)(a1 + 64));
    BOOL v21 = C3DColor4IsBlack(a2);
    float32x4_t v28 = *(float32x4_t *)a2;
    *(_OWORD *)(a1 + 64) = *(_OWORD *)a2;
    if (IsBlack || v21) {
      __C3DLightDidChange((void *)a1);
    }
    if (*(_DWORD *)(a1 + 80) == 6) {
      __C3DLightUpdateAreaVisualisationGeometryMaterial(a1, v28, v22, v23, v24, v25, v26, v27);
    }
  }
}

__n128 C3DLightSetShadowColor(__n128 *a1, __n128 *a2)
{
  if (!a1)
  {
    char v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *a2;
  a1[7] = *a2;
  return result;
}

double C3DLightInitializePerTypeParameters(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 80))
  {
    case 3:
      *(void *)&double result = 1110704128;
      *(void *)(a1 + 240) = 1110704128;
      *(_DWORD *)(a1 + 248) = 1065353216;
      break;
    case 4:
      *(void *)(a1 + 240) = 0;
      *(void *)(a1 + 320) = 0x1FFFFFFFFLL;
      *(_WORD *)(a1 + 328) = 0;
      double result = 0.0;
      __asm { FMOV            V1.4S, #10.0 }
      *(_OWORD *)(a1 + 256) = _Q1;
      *(_OWORD *)(a1 + 272) = 0u;
      *(unsigned char *)(a1 + 330) = 0;
      __asm { FMOV            V1.4S, #1.0 }
      *(_OWORD *)(a1 + 288) = _Q1;
      *(_OWORD *)(a1 + 304) = 0u;
      break;
    case 5:
      *(void *)(a1 + 240) = 0;
      double result = 2.19902369e13;
      *(void *)(a1 + 248) = 0x42B4000042C80000;
      break;
    case 6:
      *(unsigned char *)(a1 + 240) = *(unsigned char *)(a1 + 240) & 0xFC | 2;
      double result = *(double *)&kDefaultAreaDescription;
      *(_OWORD *)(a1 + 256) = kDefaultAreaDescription;
      *(_OWORD *)(a1 + 272) = unk_20B5EDE90;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t C3DLightGetGobo(uint64_t a1, int a2)
{
  if (!a1)
  {
    char v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = *(void *)(a1 + 200);
  if (a2)
  {
    if (!result)
    {
      uint64_t result = C3DEffectSlotCreate(a1, 22);
      *(void *)(a1 + 200) = result;
    }
  }
  return result;
}

uint64_t C3DLightGetProbeEnvironment(uint64_t a1, int a2)
{
  if (!a1)
  {
    char v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = *(void *)(a1 + 208);
  if (a2)
  {
    if (!result)
    {
      uint64_t result = C3DEffectSlotCreate(a1, 25);
      *(void *)(a1 + 208) = result;
    }
  }
  return result;
}

void C3DLightDestroyPerTypeParameters(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 80);
  if (v2 == 4)
  {
LABEL_4:
    int v3 = *(const void **)(a1 + 240);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 240) = 0;
    }
    return;
  }
  if (v2 != 6)
  {
    if (v2 != 5) {
      return;
    }
    goto LABEL_4;
  }
  char v4 = *(const void **)(a1 + 288);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 288) = 0;
  }
  if (*(unsigned char *)(a1 + 256) == 4)
  {
    uint64_t v5 = *(void **)(a1 + 280);
    free(v5);
  }
}

void C3DLightSetAreaDescription(uint64_t a1, unsigned __int8 *a2)
{
  if (!a1)
  {
    char v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6)
  {
    int v12 = *(unsigned __int8 *)(a1 + 256);
    int v13 = *a2;
    if (v12 != 4 || v13 == 4)
    {
      if (v13 == 4)
      {
        unint64_t v15 = a2[16];
        if (v15 > 2)
        {
          uint64_t v17 = (void *)*((void *)a2 + 3);
          if (v12 == 4) {
            uint64_t v18 = *(void **)(a1 + 280);
          }
          else {
            uint64_t v18 = 0;
          }
          uint64_t v19 = malloc_type_realloc(v18, 8 * v15, 0x196E245CuLL);
          uint64_t v20 = 0;
          *((void *)a2 + 3) = v19;
          float v21 = 0.0;
          do
          {
            uint64_t v22 = v17[v20];
            uint64_t v23 = v20 + 1;
            if (v15 - 1 == v20) {
              int v24 = 0;
            }
            else {
              int v24 = v20 + 1;
            }
            float v21 = v21
                + vmlas_n_f32((float)-*((float *)&v22 + 1) * COERCE_FLOAT(v17[v24]), COERCE_FLOAT(HIDWORD(v17[v24])), *(float *)&v22);
            uint64_t v20 = v23;
          }
          while (v15 != v23);
          if (v21 >= 0.0)
          {
            memcpy(v19, v17, 8 * v15);
          }
          else
          {
            do
              *v19++ = v17[(int)--v15];
            while (v15);
          }
        }
        else
        {
          *a2 = 1;
          *((void *)a2 + 2) = 0x3F0000003F000000;
        }
      }
    }
    else
    {
      free(*(void **)(a1 + 280));
    }
    long long v16 = *((_OWORD *)a2 + 1);
    *(_OWORD *)(a1 + 256) = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 272) = v16;
    __C3DLightUpdateAreaVisualisationGeometryMesh(a1);
    __C3DLightAreaDidChange((void *)a1);
  }
}

uint64_t C3DLightGetDistanceAttenuationType(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 80) & 0xFFFFFFFE) != 2) {
    return 0;
  }
  float AttenuationStartDistance = C3DLightGetAttenuationStartDistance(a1);
  float AttenuationEndDistance = C3DLightGetAttenuationEndDistance(a1);
  float AttenuationFalloffExponent = C3DLightGetAttenuationFalloffExponent(a1);
  if (AttenuationEndDistance <= 0.0 && AttenuationStartDistance <= 0.0) {
    return 0;
  }
  uint64_t result = 1;
  if (AttenuationEndDistance > AttenuationStartDistance && AttenuationFalloffExponent != 0.0)
  {
    if (fabsf(AttenuationFalloffExponent + -1.0) >= 0.01)
    {
      if (fabsf(AttenuationFalloffExponent + -2.0) >= 0.01) {
        return 4;
      }
      else {
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

float C3DLightGetAttenuationStartDistance(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 84);
}

float C3DLightGetAttenuationEndDistance(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 88);
}

float C3DLightGetAttenuationFalloffExponent(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 92);
}

uint64_t C3DLightGetProgramHashCode(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 80);
  DistanceAttenuationchar Type = C3DLightGetDistanceAttenuationType(a1);
  if (v2 == 6)
  {
    int v8 = 0;
    int v7 = (*(unsigned char *)(a1 + 256) & 7) << 13;
  }
  else if (v2 == 3)
  {
    float SpotInnerAngle = C3DLightGetSpotInnerAngle(a1);
    float SpotOuterAngle = C3DLightGetSpotOuterAngle(a1);
    float SpotFalloffExponent = C3DLightGetSpotFalloffExponent(a1);
    int v7 = 0;
    int v8 = 64;
    if (SpotOuterAngle > SpotInnerAngle && SpotFalloffExponent != 0.0)
    {
      int v7 = 0;
      if (fabsf(SpotFalloffExponent + -1.0) >= 0.01)
      {
        if (fabsf(SpotFalloffExponent + -2.0) >= 0.01) {
          int v8 = 256;
        }
        else {
          int v8 = 192;
        }
      }
      else
      {
        int v8 = 128;
      }
    }
  }
  else
  {
    int v8 = 0;
    int v7 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 200);
  if (v9) {
    BOOL HasImageOrTexture = C3DEffectSlotHasImageOrTexture(v9);
  }
  else {
    BOOL HasImageOrTexture = 0;
  }
  if (C3DLightTypeSupportsShadow(a1) && C3DLightGetCastsShadow(a1)) {
    int v11 = C3DLightGetUsesDeferredShadows(a1) ^ 1;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 124);
  if (C3DLightGetEffectiveShadowSampleCount(a1) > 0x1E) {
    LOBYTE(v13) = 31;
  }
  else {
    LOBYTE(v13) = C3DLightGetEffectiveShadowSampleCount(a1);
  }
  int v14 = v2 & 7;
  if ((*(unsigned char *)(a1 + 169) & 2) != 0 && HasImageOrTexture | v11) {
    int v15 = v14 | 0x1000;
  }
  else {
    int v15 = (8 * (DistanceAttenuationType & 7)) | v8 | v14;
  }
  if (HasImageOrTexture) {
    int v16 = 512;
  }
  else {
    int v16 = 0;
  }
  if (v11) {
    int v17 = 1024;
  }
  else {
    int v17 = 0;
  }
  uint64_t v18 = v16 | v7 | v17 | v15;
  if (v11)
  {
    unsigned int v19 = v18 | ((v12 < 1.0) << 11);
    if (C3DLightGetShadowRadius(a1) == 0.0)
    {
      int v13 = (int)fminf(ceilf(sqrtf((float)v13)), 8.0);
      v19 |= 0x4000000u;
    }
    uint64_t v18 = ((v13 & 0x1F) << 16) | v19;
    if (C3DLightSupportsShadowCascades(a1))
    {
      ShadowCascadesize_t Count = C3DLightGetShadowCascadeCount(a1);
      uint64_t v18 = ((ShadowCascadeCount & 7) << 21) | v18;
      if (ShadowCascadeCount >= 2) {
        return v18 | ((*(float *)(a1 + 152) != 0.0) << 25) | 0x1000000;
      }
    }
  }
  return v18;
}

float C3DLightGetSpotInnerAngle(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  float result = 0.0;
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 244);
  }
  return result;
}

float C3DLightGetSpotOuterAngle(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 240);
  }
  else {
    return 45.0;
  }
}

float C3DLightGetSpotFalloffExponent(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  float result = 1.0;
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 248);
  }
  return result;
}

uint64_t C3DLightHasValidGobo(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 200);
  if (result) {
    return C3DEffectSlotHasImageOrTexture(result);
  }
  return result;
}

uint64_t C3DLightTypeSupportsShadow(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80) - 1;
  uint64_t result = 1;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = C3DWasLinkedBeforeMajorOSYear2018() ^ 1;
      break;
    case 2:
      float v4 = *(float *)(a1 + 240);
      goto LABEL_6;
    case 4:
      float v4 = *(float *)(a1 + 252);
LABEL_6:
      uint64_t result = v4 < 180.0;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t C3DLightGetCastsShadow(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 168);
}

uint64_t C3DLightGetUsesDeferredShadows(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 169) & 1;
}

uint64_t C3DLightGetEffectiveShadowSampleCount(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned __int8 *)(a1 + 156) >= 0x40u) {
    unsigned int v10 = 64;
  }
  else {
    unsigned int v10 = *(unsigned __int8 *)(a1 + 156);
  }
  if (*(unsigned char *)(a1 + 156)) {
    return v10;
  }
  else {
    return 1;
  }
}

float C3DLightGetShadowRadius(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 140);
}

BOOL C3DLightSupportsShadowCascades(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_DWORD *)(a1 + 80) == 1;
}

uint64_t C3DLightGetShadowCascadeCount(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 157);
}

uint64_t C3DLightGetColor(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 64;
}

uint64_t C3DLightGetShadowColor(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 112);
}

void C3DLightSetIESProfileURL(uint64_t a1, void *cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 5)
  {
    float v12 = *(const void **)(a1 + 240);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(void *)(a1 + 240) = 0;
      }
      if (cf) {
        CFTypeRef v13 = CFRetain(cf);
      }
      else {
        CFTypeRef v13 = 0;
      }
      *(void *)(a1 + 240) = v13;
    }
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    if (C3DIESInfoLoad(cf, &v16))
    {
      int v14 = DWORD1(v17);
      *(_DWORD *)(a1 + 248) = DWORD1(v16);
      *(_DWORD *)(a1 + 252) = v14;
    }
    else
    {
      int v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        C3DLightSetIESProfileURL_cold_1((uint64_t)cf, v15);
      }
    }
    C3DIESInfoDestroy((void **)&v16);
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

void __C3DLightInvalidatePasses(void *a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  uint64_t v3 = (const void *)C3DGetScene(a1);

  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v3, 0, 1u);
}

uint64_t C3DLightGetIESProfileURL(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) != 5)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DLightGetIESProfileURL_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  return *(void *)(a1 + 240);
}

float C3DLightGetIESSpotAngle(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) != 5)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DLightGetIESProfileURL_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  return *(float *)(a1 + 252);
}

uint64_t C3DLightGetProjectionInfo(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DLightGetProjectionInfo_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  if (*(_DWORD *)(a1 + 80) == 5)
  {
    BOOL v20 = 0;
    float SpotOuterAngle = *(float *)(a1 + 252);
  }
  else
  {
    float SpotOuterAngle = C3DLightGetSpotOuterAngle(a1);
    if (SpotOuterAngle >= 180.0 || SpotOuterAngle <= 0.0) {
      float SpotOuterAngle = 60.0;
    }
    BOOL v20 = *(_DWORD *)(a1 + 80) == 1;
  }
  char v23 = *(unsigned char *)a2 & 0xF6 | v20;
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(unsigned char *)a2 = v23 & 0x8F;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  __asm { FMOV            V1.2S, #1.0 }
  *(void *)(a2 + 40) = _D1;
  double v29 = *(double *)(a1 + 176);
  double v30 = *(double *)(a1 + 184);
  if (v30 == 0.0) {
    double v30 = 100.0;
  }
  *(double *)(a2 + 8) = v29;
  *(double *)(a2 + 16) = v30;
  if (v29 == 0.0) {
    *(void *)(a2 + 8) = 0x3FF0000000000000;
  }
  *(float *)(a2 + 56) = SpotOuterAngle;
  *(unsigned char *)a2 = v23 & 0x81;
  *(double *)(a2 + 48) = *(float *)(a1 + 136);
  return 1;
}

float C3DLightComputeDistanceAttenuations(float *a1, int a2, float a3)
{
  float v3 = fmaxf(a1[21] * a3, 0.0);
  float v4 = a1[22] * a3;
  float v5 = fmaxf(v4, 0.0);
  if (v3 < v5 && fmaxf(a1[23], 0.0) != 0.0) {
    return -1.0 / (float)(v5 - v3);
  }
  if (a2)
  {
    float v7 = -1.0 / v4;
    BOOL v8 = v4 <= 0.0;
    float result = 0.0;
    if (!v8) {
      return v7;
    }
  }
  else if (v3 <= v5)
  {
    return v5;
  }
  else
  {
    return v3;
  }
  return result;
}

void C3DLightComputeSpotAttenuations(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  if (v1 == 3)
  {
    float v2 = fminf(*(float *)(a1 + 240), 180.0);
    float v4 = v2 + -0.1;
    if (*(float *)(a1 + 244) < (float)(v2 + -0.1)) {
      float v4 = *(float *)(a1 + 244);
    }
    double v3 = (float)(v4 * 0.5);
  }
  else
  {
    float v2 = 0.0;
    double v3 = 0.0;
    if (v1 == 5) {
      float v2 = *(float *)(a1 + 252);
    }
  }
  float v5 = v3 / 180.0 * 3.14159265;
  cosf(v5);
  float v6 = (float)(v2 * 0.5) / 180.0 * 3.14159265;
  fmaxf(cosf(v6), 0.0);
}

void C3DLightSetTechnique(void *a1, CFTypeRef cf)
{
  if (!a1)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = (CFTypeRef)a1[27];
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      a1[27] = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    a1[27] = v13;
    uint64_t v14 = C3DGetScene(a1);
    if (v14)
    {
      LightingSysteuint64_t m = C3DSceneGetLightingSystem(v14);
      if (LightingSystem)
      {
        if (cf) {
          C3DLightingSystemAddToLightsWithTechnique(LightingSystem, a1);
        }
        else {
          C3DLightingSystemRemoveFromLightsWithTechnique(LightingSystem, a1);
        }
      }
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    uint64_t v17 = (const void *)C3DGetScene(a1);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v17, 0, 1u);
  }
}

int8x8_t C3DLightGetRealShadowMapSize(uint64_t a1)
{
  int8x8_t v1 = (int8x8_t)vrndm_f32(COERCE_FLOAT32X2_T(C3DLightGetShadowMapSize(a1)));
  if (*(float *)&v1.i32[1] > 0.0 && *(float *)v1.i32 > 0.0) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  return vbsl_s8((int8x8_t)vdup_n_s32(v3), (int8x8_t)vdup_n_s32(0x44800000u), v1);
}

double C3DLightGetShadowMapSize(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 128);
}

void C3DLightSetAttenuationFalloffExponent(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 92) = a2;
}

void C3DLightSetAttenuationStartDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 84) = a2;
}

uint64_t C3DLightGetBaked(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 169) >> 2) & 1;
}

void C3DLightSetBaked(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  char v12 = *(unsigned char *)(a1 + 169);
  if (((((v12 & 4) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      char v13 = 4;
    }
    else {
      char v13 = 0;
    }
    *(unsigned char *)(a1 + 169) = v12 & 0xFB | v13;
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

void C3DLightSetCastsShadow(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 168) != a2)
  {
    *(unsigned char *)(a1 + 168) = a2;
    __C3DLightInvalidatePasses((void *)a1);
    __C3DLightDidChange((void *)a1);
  }
}

uint64_t C3DLightGetCategoryBitMask(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 160);
}

void C3DLightSetCategoryBitMask(void *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a1[20] != a2)
  {
    a1[20] = a2;
    __C3DLightDidChange(a1);
  }
}

float C3DLightGetIntensity(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 96);
}

void C3DLightSetIntensity(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  unsigned __int32 v8 = a2.i32[0];
  if (!a1)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  *(_DWORD *)(a1 + 96) = v8;
  if (*(_DWORD *)(a1 + 80) == 6) {
    __C3DLightUpdateAreaVisualisationGeometryMaterial(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

float C3DLightGetOrthographicScale(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 136);
}

void C3DLightSetOrthographicScale(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 136) = a2;
}

double C3DLightGetShadowBias(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 192);
}

void C3DLightSetShadowBias(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 192) = a2;
}

void C3DLightSetShadowMapSize(float32x2_t *a1, float32x2_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint32x2_t v12 = (uint32x2_t)vceq_f32(a1[16], a2);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) == 0)
  {
    a1[16] = a2;
    __C3DLightInvalidatePasses(a1);
    uint64_t v13 = C3DGetScene(a1);
    if (v13)
    {
      LightingSysteuint64_t m = C3DSceneGetLightingSystem(v13);
      if (LightingSystem) {
        C3DLightingSystemInvalidateShadowTechniqueForLight(LightingSystem, a1);
      }
    }
  }
}

void C3DLightSetShadowRadius(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 140);
  if (v12 != a2)
  {
    *(float *)(a1 + 140) = a2;
    if (a2 == 0.0 || v12 == 0.0)
    {
      __C3DLightInvalidatePasses((void *)a1);
      __C3DLightDidChange((void *)a1);
    }
  }
}

uint64_t C3DLightGetShadowSampleCount(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 156);
}

void C3DLightSetShadowSampleCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 156) != a2)
  {
    *(unsigned char *)(a1 + 156) = a2;
    __C3DLightInvalidatePasses((void *)a1);
    __C3DLightDidChange((void *)a1);
  }
}

void C3DLightSetSpotFalloffExponent(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    *(float *)(a1 + 248) = a2;
  }
}

void C3DLightSetSpotInnerAngle(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    *(float *)(a1 + 244) = a2;
  }
}

void C3DLightSetSpotOuterAngle(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    *(float *)(a1 + 240) = a2;
  }
}

float C3DLightGetTemperature(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 100);
}

void C3DLightSetTemperature(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  unsigned __int32 v8 = a2.i32[0];
  if (!a1)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  *(_DWORD *)(a1 + 100) = v8;
  if (*(_DWORD *)(a1 + 80) == 6) {
    __C3DLightUpdateAreaVisualisationGeometryMaterial(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t C3DLightGetType(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 80);
}

void C3DLightSetUsesDeferredShadows(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  char v12 = *(unsigned char *)(a1 + 169);
  if (((((v12 & 1) == 0) ^ a2) & 1) == 0)
  {
    *(unsigned char *)(a1 + 169) = v12 & 0xFE | a2;
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

uint64_t C3DLightGetUsesModulatedMode(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 169) >> 1) & 1;
}

void C3DLightSetUsesModulatedMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  char v12 = *(unsigned char *)(a1 + 169);
  if (((((v12 & 2) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      char v13 = 2;
    }
    else {
      char v13 = 0;
    }
    *(unsigned char *)(a1 + 169) = v12 & 0xFD | v13;
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

double C3DLightGetZFar(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 184);
}

void C3DLightSetZFar(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 184) = a2;
}

double C3DLightGetZNear(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 176);
}

void C3DLightSetZNear(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 176) = a2;
}

uint64_t C3DLightGetAreaVisualisationGeometry(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) != 6 || (*(unsigned char *)(a1 + 240) & 2) == 0) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 288);
  if (!v2)
  {
    uint64_t v2 = C3DGeometryCreate();
    *(void *)(a1 + 288) = v2;
    uint64_t v4 = (void *)C3DMaterialCreate();
    uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)v4);
    C3DEffectCommonProfileSetLightingModel(CommonProfile, 0);
    C3DMaterialSetCullMode((uint64_t)v4, 1);
    C3DGeometryAppendMaterial(v2, v4);
    if (v4) {
      CFRelease(v4);
    }
    __C3DLightUpdateAreaVisualisationGeometryMesh(a1);
    __C3DLightUpdateAreaVisualisationGeometryMaterial(a1, v6, v7, v8, v9, v10, v11, v12);
  }
  return v2;
}

void __C3DLightUpdateAreaVisualisationGeometryMesh(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 288);
  if (v1)
  {
    switch(*(unsigned char *)(a1 + 256))
    {
      case 0:
        float v3 = *(float *)(a1 + 272);
        *(float *)bytes = -v3;
        uint64_t v26 = 0;
        *(float *)__n128 v27 = v3;
        *(void *)&v27[4] = 0;
        *(_WORD *)int v24 = 256;
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        CFDataRef v5 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 24);
        values = (void *)C3DMeshSourceCreate(v5, 0, 2, 3, 1);
        CFRelease(v5);
        CFDataRef v6 = CFDataCreate(v4, v24, 2);
        long long v22 = (void *)C3DMeshElementCreate();
        C3DMeshElementInit((uint64_t)v22, 2, 1, v6, 1);
        CFRelease(v6);
        char v21 = 0;
        float32x4_t v7 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
        CFArrayRef v8 = CFArrayCreate(v4, (const void **)&values, 1, MEMORY[0x263EFFF70]);
        CFArrayRef v9 = CFArrayCreate(v4, (const void **)&v22, 1, v7);
        Shape = (uint64_t *)C3DMeshCreateWithMeshSourcesAndMeshElements(v8, v9, (uint64_t)&v21);
        C3DEntitySetName((uint64_t)Shape, @"Area Light - Line");
        CFRelease(v9);
        CFRelease(v8);
        double v11 = v22;
        goto LABEL_18;
      case 1:
        uint64_t Plane = C3DMeshCreatePlane(0, 1, 1, 0, (float)(COERCE_FLOAT(*(void *)(a1 + 272)) + COERCE_FLOAT(*(void *)(a1 + 272))), (float)(COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272))) + COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272)))), 0.0);
        Shape = (uint64_t *)Plane;
        CFStringRef v14 = @"Area light - Rectangle";
        goto LABEL_10;
      case 2:
        uint64_t Plane = C3DMeshCreatePlane(0, 1, 1, 0, (float)(COERCE_FLOAT(*(void *)(a1 + 272)) + COERCE_FLOAT(*(void *)(a1 + 272))), (float)(COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272))) + COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272)))), 0.0);
        Shape = (uint64_t *)Plane;
        CFStringRef v14 = @"Area Light - Ellipse";
        goto LABEL_10;
      case 3:
        uint64_t Plane = C3DMeshCreateChamferBox(0, 1, 1, 1, 0, 0, (float)(*(float *)(a1 + 272) + *(float *)(a1 + 272)), (float)(*(float *)(a1 + 276) + *(float *)(a1 + 276)), (float)(*(float *)(a1 + 280) + *(float *)(a1 + 280)), 0.0);
        Shape = (uint64_t *)Plane;
        CFStringRef v14 = @"Area Light - Ellipsoid";
LABEL_10:
        C3DEntitySetName(Plane, v14);
        goto LABEL_19;
      case 4:
        CFMutableDictionaryRef Mutable = CGPathCreateMutable();
        if (*(unsigned char *)(a1 + 272))
        {
          unint64_t v16 = 0;
          do
          {
            float32x2_t v17 = vmul_f32(*(float32x2_t *)(*(void *)(a1 + 280) + 8 * v16), (float32x2_t)0x3F800000BF800000);
            double v18 = v17.f32[0];
            double v19 = v17.f32[1];
            if (v16) {
              CGPathAddLineToPoint(Mutable, 0, v18, v19);
            }
            else {
              CGPathMoveToPoint(Mutable, 0, v18, v19);
            }
            ++v16;
          }
          while (v16 < *(unsigned __int8 *)(a1 + 272));
        }
        CGPathCloseSubpath(Mutable);
        *(float *)bytes = 0.0;
        uint64_t v26 = 1065353216;
        *(void *)__n128 v27 = 0;
        *(_DWORD *)&v27[8] = 2139095039;
        float32x4_t v28 = Mutable;
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        BOOL v20 = (const void *)C3DShapeCreate((uint64_t)bytes);
        *(float *)bytes = 0.0;
        uint64_t v26 = 1065353216;
        *(void *)__n128 v27 = 0;
        *(_DWORD *)&v27[8] = 2139095039;
        float32x4_t v28 = Mutable;
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        Shape = (uint64_t *)C3DMeshCreateShape((uint64_t)v20, (long long *)bytes);
        C3DEntitySetName((uint64_t)Shape, @"Area light - Polygon");
        CFRelease(v20);
        double v11 = Mutable;
LABEL_18:
        CFRelease(v11);
LABEL_19:
        C3DGeometrySetMesh(v1, Shape);
        if (Shape) {
          CFRelease(Shape);
        }
        break;
      default:
        uint64_t v12 = *(void *)(a1 + 288);
        C3DGeometrySetMesh(v12, 0);
        break;
    }
  }
}

void __C3DLightUpdateAreaVisualisationGeometryMaterial(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  uint64_t v8 = *(void *)(a1 + 288);
  if (v8)
  {
    *(__n128 *)bytes = __renderColor(a1, a2, a3, a4, a5, a6, a7, a8);
    MaterialAtuint64_t Index = C3DGeometryGetMaterialAtIndex(v8, 0);
    C3DMaterialSetDoubleSided((uint64_t)MaterialAtIndex, *(unsigned char *)(a1 + 240) & 1);
    switch(*(unsigned char *)(a1 + 256))
    {
      case 0:
      case 1:
      case 4:
        uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
        C3DEffectCommonProfileSetColor(CommonProfile, 2, (float *)bytes);
        break;
      case 2:
        unint64_t v16 = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"area_shape_vert", @"area_shape_ellipse_frag");
        C3DMaterialSetupSinglePassTechniqueWithProgram((uint64_t)MaterialAtIndex, v16);
        CFRelease(v16);
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        float32x2_t v17 = (__int16 *)CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 16);
        C3DEntitySetValueForKey((uint64_t)MaterialAtIndex, @"color", v17);
        CFRelease(v17);
        *(void *)&long long v15 = *(void *)(a1 + 272);
        goto LABEL_6;
      case 3:
        C3DMaterialSetDoubleSided((uint64_t)MaterialAtIndex, 1);
        uint64_t v12 = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"area_shape_vert", @"area_shape_ellipsoid_frag");
        C3DMaterialSetupSinglePassTechniqueWithProgram((uint64_t)MaterialAtIndex, v12);
        CFRelease(v12);
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        CFStringRef v14 = (__int16 *)CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 16);
        C3DEntitySetValueForKey((uint64_t)MaterialAtIndex, @"color", v14);
        CFRelease(v14);
        long long v15 = *(_OWORD *)(a1 + 272);
        HIDWORD(v15) = 0;
LABEL_6:
        long long v19 = v15;
        double v18 = (__int16 *)CFDataCreate(v13, (const UInt8 *)&v19, 16);
        C3DEntitySetValueForKey((uint64_t)MaterialAtIndex, @"halfExtents", v18);
        CFRelease(v18);
        break;
      default:
        return;
    }
  }
}

void C3DLightSetDrawsArea(uint64_t a1, int a2)
{
  if (!a1)
  {
    CFAllocatorRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6)
  {
    if (a2) {
      char v12 = 2;
    }
    else {
      char v12 = 0;
    }
    *(unsigned char *)(a1 + 240) = *(unsigned char *)(a1 + 240) & 0xFD | v12;
    if ((a2 & 1) == 0)
    {
      CFAllocatorRef v13 = *(const void **)(a1 + 288);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(a1 + 288) = 0;
      }
    }
    __C3DLightAreaDidChange((void *)a1);
  }
}

void __C3DLightAreaDidChange(void *a1)
{
  __C3DLightDidChange(a1);
  uint64_t v2 = C3DGetScene(a1);

  C3DScenePostPipelineEvent(v2, 9, a1, 0);
}

uint64_t C3DLightGetDrawsArea(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6) {
    return (*(unsigned __int8 *)(a1 + 240) >> 1) & 1;
  }
  else {
    return 0;
  }
}

void C3DLightSetDoubleSided(uint64_t a1, char a2, float32x4_t a3, float32x4_t a4, double a5, double a6, double a7, double a8, __n128 a9)
{
  if (!a1)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6)
  {
    *(unsigned char *)(a1 + 240) = *(unsigned char *)(a1 + 240) & 0xFE | a2;
    __C3DLightUpdateAreaVisualisationGeometryMaterial(a1, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t C3DLightGetDoubleSided(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6) {
    return *(unsigned char *)(a1 + 240) & 1;
  }
  else {
    return 0;
  }
}

__n128 C3DLightGetAreaDescription@<Q0>(uint64_t a1@<X0>, long long *a2@<X8>)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 6) {
    uint64_t v12 = (long long *)(a1 + 256);
  }
  else {
    uint64_t v12 = &kDefaultAreaDescription;
  }
  __n128 result = (__n128)*v12;
  long long v14 = v12[1];
  *a2 = *v12;
  a2[1] = v14;
  return result;
}

BOOL C3DLightHasValidIES(uint64_t a1)
{
  return *(_DWORD *)(a1 + 80) == 5;
}

BOOL C3DLightIsBlack(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 96) == 0.0 || C3DColor4IsBlack((float *)(a1 + 64));
}

double C3DLightGetColorModulatedByIntensity(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  *(void *)&double result = __renderColor(a1, a2, a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

__n128 __renderColor(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  a2.i32[0] = *(_DWORD *)(a1 + 100);
  if (a2.f32[0] == 0.0)
  {
    float32x4_t v9 = (float32x4_t)xmmword_20B5CB820;
  }
  else
  {
    a3.i32[0] = 1170939904;
    int8x16_t v10 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a3, a2)), 0);
    float32x4_t v11 = vaddq_f32((float32x4_t)vbslq_s8(v10, (int8x16_t)xmmword_20B5EDCF0, (int8x16_t)xmmword_20B5EDCE0), vdivq_f32((float32x4_t)vbslq_s8(v10, (int8x16_t)xmmword_20B5EDD10, (int8x16_t)xmmword_20B5EDD00), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v10, (int8x16_t)xmmword_20B5EDD30, (int8x16_t)xmmword_20B5EDD20))));
    v11.i32[3] = 0;
    float32x4_t v12 = vmaxnmq_f32(v11, (float32x4_t)0);
    v12.i32[3] = 0;
    float32x4_t v9 = vminnmq_f32(v12, (float32x4_t)xmmword_20B5CC200);
  }
  a8.n128_u32[2] = *(_DWORD *)(a1 + 72);
  unsigned __int32 v21 = *(_DWORD *)(a1 + 76);
  float32x4_t v22 = v9;
  float32x4_t v13 = v9;
  v13.i32[3] = 0;
  float32x4_t v24 = v13;
  a8.n128_u64[0] = *(void *)(a1 + 64);
  __n128 v25 = a8;
  if (C3DLinearRenderingIsEnabled())
  {
    result.n128_u32[2] = v22.u32[2];
    float32x4_t v15 = v22;
    if (v22.f32[0] <= 0.04045)
    {
      result.n128_f32[0] = v22.f32[0] / 12.92;
    }
    else
    {
      result.n128_f32[0] = powf((float)(v22.f32[0] + 0.055) / 1.055, 2.4);
      float32x4_t v15 = v22;
    }
    unsigned __int32 v20 = result.n128_u32[0];
    if (v15.f32[1] <= 0.04045)
    {
      float v18 = v15.f32[1] / 12.92;
    }
    else
    {
      result.n128_f32[0] = powf((float)(v15.f32[1] + 0.055) / 1.055, 2.4);
      v15.i32[2] = v22.i32[2];
      float v18 = result.n128_f32[0];
    }
    if (v15.f32[2] <= 0.04045)
    {
      result.n128_f32[0] = v15.f32[2] / 12.92;
    }
    else
    {
      float v23 = v18;
      result.n128_f32[0] = powf((float)(v15.f32[2] + 0.055) / 1.055, 2.4);
      float v18 = v23;
    }
    float32x4_t v16 = (float32x4_t)v25;
    v17.i64[0] = __PAIR64__(LODWORD(v18), v20);
    v17.i64[1] = __PAIR64__(v24.u32[3], result.n128_u32[0]);
  }
  else
  {
    float32x4_t v17 = v24;
    float32x4_t v16 = (float32x4_t)v25;
  }
  float32x4_t v19 = vmulq_f32(v16, v17);
  if (*(_DWORD *)(a1 + 80) == 5) {
    float32x4_t v19 = vmulq_n_f32(v19, *(float *)(a1 + 248) / 1000.0);
  }
  v19.i32[3] = v21;
  result.n128_u64[0] = vmulq_n_f32(v19, *(float *)(a1 + 96) / 1000.0).u64[0];
  result.n128_u32[3] = v21;
  return result;
}

void C3DLightSetAttenuationEndDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 88);
  *(float *)(a1 + 88) = a2;
  if ((a2 == 0.0) != (v12 == 0.0)) {
    __C3DLightDidChange((void *)a1);
  }
}

void C3DLightSetIrradianceSH(void *a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = (CFTypeRef)a1[28];
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      a1[28] = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    a1[28] = v13;
    __C3DLightDidChange(a1);
  }
}

uint64_t C3DLightGetIrradianceSH(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 224);
}

void C3DLightSetProbeType(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4)
  {
    *(unsigned char *)(a1 + 328) = a2;
    __C3DLightDidChange((void *)a1);
  }
}

uint64_t C3DLightGetProbeType(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(unsigned __int8 *)(a1 + 328);
  }
  else {
    return 0;
  }
}

void C3DLightSetProbeUpdateType(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    *(unsigned char *)(a1 + 329) = a2;
  }
}

uint64_t C3DLightGetProbeUpdateType(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(unsigned __int8 *)(a1 + 329);
  }
  else {
    return 0;
  }
}

void C3DLightSetParallaxCorrectionEnabled(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    *(unsigned char *)(a1 + 330) = a2;
  }
}

BOOL C3DLightGetParallaxCorrectionEnabled(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_DWORD *)(a1 + 80) == 4 && *(unsigned char *)(a1 + 330) != 0;
}

void C3DLightSetParallaxCenterOffset(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      __C3DLightDidChange_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[19] = a2;
  }
}

__n128 C3DLightGetParallaxCenterOffset(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  result.n128_u64[0] = 0;
  if (a1[5].n128_u32[0] == 4) {
    return a1[19];
  }
  return result;
}

void C3DLightSetParallaxExtentsFactor(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      __C3DLightDidChange_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[18] = a2;
  }
}

__n128 C3DLightGetParallaxExtentsFactor(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (a1[5].n128_u32[0] == 4) {
    return a1[18];
  }
  else {
    __asm { FMOV            V0.4S, #1.0 }
  }
  return result;
}

float32x4_t C3DLightSetProbeExtents(float32x4_t *a1, float32x4_t result)
{
  if (!a1)
  {
    float32x4_t v12 = result;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    __n128 result = v12;
    if (v4)
    {
      __C3DLightDidChange_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      __n128 result = v12;
    }
  }
  if (a1[5].i32[0] == 4)
  {
    result.i32[3] = 0;
    __n128 result = vminnmq_f32(result, (float32x4_t)xmmword_20B5EDD40);
    a1[16] = result;
  }
  return result;
}

__n128 C3DLightGetProbeExtents(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (a1[5].n128_u32[0] == 4) {
    return a1[16];
  }
  else {
    __asm { FMOV            V0.4S, #10.0 }
  }
  return result;
}

void C3DLightSetProbeOffset(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      __C3DLightDidChange_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[17] = a2;
  }
}

__n128 C3DLightGetProbeOffset(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  result.n128_u64[0] = 0;
  if (a1[5].n128_u32[0] == 4) {
    return a1[17];
  }
  return result;
}

void C3DLightSetRadianceProbeIndex(uint64_t a1, __int16 a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    *(_WORD *)(a1 + 320) = a2;
  }
}

uint64_t C3DLightGetRadianceProbeIndex(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(__int16 *)(a1 + 320);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t C3DLightGetProbeEnvironmentTimeStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(unsigned int *)(a1 + 324);
  }
  else {
    return 1;
  }
}

float C3DLightGetAttenuationAtPoint(uint64_t a1, float32x4_t *a2, float32x4_t a3)
{
  WorldMatrix = C3DNodeGetWorldMatrix(a2);
  int v5 = *(_DWORD *)(a1 + 80);
  float v6 = 1.0;
  if ((v5 & 0xFFFFFFFE) == 2)
  {
    float32x4_t v7 = vsubq_f32(WorldMatrix[3], a3);
    float v8 = *(float *)(a1 + 88);
    if (v8 > 0.0)
    {
      *(float *)&unsigned int v9 = v8 * v8;
      float32x2_t v10 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 * v8));
      _S0 = vmul_f32(v10, vrecps_f32((float32x2_t)v9, v10)).u32[0];
      float32x4_t v12 = vmulq_f32(v7, v7);
      _S1 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0];
      float v14 = 1.0 / _S1;
      if (_S1 < 0.0001) {
        float v14 = 10000.0;
      }
      __asm { FMLS            S4, S0, V1.S[0] }
      if (_S4 < 1.0) {
        float v20 = _S4;
      }
      else {
        float v20 = 1.0;
      }
      if (v20 <= 0.0) {
        float v20 = 0.0;
      }
      float v6 = v14 * (float)(v20 * v20);
    }
    if (v5 == 3)
    {
      float32x4_t v30 = v7;
      float32x4_t v32 = vnegq_f32(WorldMatrix[2]);
      C3DLightComputeSpotAttenuations(a1);
      int32x4_t v21 = (int32x4_t)vmulq_f32(v30, v30);
      v21.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v21, 2), vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1))).u32[0];
      float32x2_t v22 = vrsqrte_f32((float32x2_t)v21.u32[0]);
      float32x2_t v23 = vmul_f32(v22, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v22, v22)));
      float32x4_t v24 = vmulq_f32(vmulq_n_f32(v30, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v23, v23))).f32[0]), v32);
      float v27 = vmlas_n_f32(v26, v25, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0]);
      float v28 = 1.0;
      if (v27 < 1.0) {
        float v28 = v27;
      }
      if (v28 <= 0.0) {
        float v28 = 0.0;
      }
      return v6 * (float)(v28 * v28);
    }
  }
  return v6;
}

void C3DLightAddLightSHContribution(uint64_t a1, float32x4_t *a2, uint64_t a3, float32x4_t *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  if (!a3 && (uint64_t v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
  {
    __C3DLightDidChange_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    if (!a4)
    {
LABEL_4:
      float32x4_t v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        C3DLightAddLightSHContribution_cold_5(v19, v20, v21, v22, v23, v24, v25, v26);
      }
    }
  }
  else if (!a4)
  {
    goto LABEL_4;
  }
  WorldMatrix = C3DNodeGetWorldMatrix(a4);
  float32x4_t v67 = WorldMatrix[2];
  float32x4_t v69 = WorldMatrix[3];
  v75.i32[2] = 0;
  v75.i64[0] = 0;
  *(double *)v28.i64 = C3DNodeGetWorldPosition(a2, (__n128 *)&v75);
  __n128 v72 = __renderColor(a3, v28, v29, v30, v31, v32, v33, v34);
  float32x4_t v35 = vmulq_n_f32((float32x4_t)v72, C3DLightGetAttenuationAtPoint(a3, a4, v75));
  switch(*(_DWORD *)(a3 + 80))
  {
    case 0:
      C3DLightAddLightSHContribution_cold_1();
    case 1:
      if (a5 - 7 >= 0xFFFFFFFB)
      {
        switch(a5)
        {
          case 4u:
            float32x4_t v74 = v35;
            sh_eval_basis_3((uint64_t)&v77, v67.f32[0], v67.f32[1], v67.f32[2]);
            float32x4_t v35 = v74;
            break;
          case 3u:
            int v77 = 1049652923;
            float v48 = v67.f32[2] * 0.488602512;
            float v49 = (float)(v67.f32[2] * v67.f32[2]) * 0.946174696 + -0.315391565;
            float v78 = v67.f32[1] * -0.4886;
            float v79 = v48;
            float v50 = v67.f32[2] * -1.09254843;
            float v82 = v67.f32[1] * v50;
            float v83 = v49;
            float v80 = v67.f32[0] * -0.4886;
            float v81 = (float)((float)(v67.f32[0] * v67.f32[1]) + (float)(v67.f32[0] * v67.f32[1])) * 0.54627;
            float v84 = v67.f32[0] * v50;
            float v85 = (float)((float)(v67.f32[0] * v67.f32[0]) - (float)(v67.f32[1] * v67.f32[1])) * 0.54627;
            break;
          case 2u:
            int v77 = 1049652923;
            float v36 = v67.f32[2] * 0.488602512;
            float v78 = v67.f32[1] * -0.4886;
            float v79 = v36;
            float v80 = v67.f32[0] * -0.4886;
            break;
          default:
            C3DLightAddLightSHContribution_cold_2();
        }
        uint64_t v51 = 0;
        float v52 = flt_20B5EDDA8[a5 > 2];
        float v54 = v52 * v35.f32[0];
        float v55 = vmuls_lane_f32(v52, *(float32x2_t *)v35.f32, 1);
        float v56 = vmuls_lane_f32(v52, v35, 2);
        do
        {
          float v57 = *(float *)((char *)&v77 + v51);
          *(float *)(a6 + v51) = *(float *)(a6 + v51) + (float)(v57 * v54);
          *(float *)(a6 + 4 * a5 * a5 + v51) = *(float *)(a6 + 4 * a5 * a5 + v51) + (float)(v57 * v55);
          uint64_t v53 = a6 + 8 * a5 * a5;
          *(float *)(v53 + v51) = *(float *)(v53 + v51) + (float)(v57 * v56);
          v51 += 4;
        }
        while (4 * a5 * a5 != v51);
      }
      return;
    case 2:
      float32x4_t v37 = vsubq_f32(v69, v75);
      float32x4_t v38 = vmulq_f32(v37, v37);
      float32x4_t v39 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1);
      v39.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, v39)).f32[0]);
      long long v86 = xmmword_20B5EDD50;
      uint64_t v87 = 0x3F88CF6B3F973FD9;
      float32x4_t v73 = v35;
      if (v39.f32[0] <= 0.1)
      {
        float v40 = 1.5708;
      }
      else
      {
        uint64_t v68 = v39.i64[0];
        float32x4_t v70 = v37;
        float v40 = asinf(0.1 / v39.f32[0]);
        v39.i64[0] = v68;
        float32x4_t v37 = v70;
      }
      float32x4_t v71 = vdivq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
      __float2 v41 = __sincosf_stret(v40);
      v76[0] = 1.7725 - (float)(v41.__cosval * 1.7725);
      v76[1] = (float)((float)(v41.__sinval * v41.__sinval) * 3.07) * 0.5;
      if (a5 < 3)
      {
        float32x4_t v46 = v73;
        if (a5 != 2) {
          return;
        }
        int v77 = 1049652923;
        float v47 = v71.f32[2] * 0.488602512;
        float v78 = vmuls_lane_f32(-0.4886, *(float32x2_t *)v71.f32, 1);
        float v79 = v47;
        float v80 = -0.4886 * v71.f32[0];
        goto LABEL_30;
      }
      v76[2] = (float)((float)(v41.__cosval * -3.9633) * (float)((float)(v41.__cosval * v41.__cosval) + -1.0)) * 0.5;
      if (a5 == 3)
      {
        float32x2_t v42 = *(float32x2_t *)v71.f32;
        int v77 = 1049652923;
        float v43 = v71.f32[2] * 0.488602512;
        float v44 = vmuls_lane_f32(v71.f32[2], v71, 2) * 0.946174696 + -0.315391565;
        float v78 = vmuls_lane_f32(-0.4886, *(float32x2_t *)v71.f32, 1);
        float v79 = v43;
        float v45 = v71.f32[2] * -1.09254843;
        float v82 = vmuls_lane_f32(v45, *(float32x2_t *)v71.f32, 1);
        float v83 = v44;
        float v80 = -0.4886 * v71.f32[0];
        float v81 = vmlas_n_f32(vmuls_lane_f32(v42.f32[0], v42, 1), v71.f32[1], v71.f32[0]) * 0.54627;
        float v84 = v45 * v71.f32[0];
        float v85 = vmlas_n_f32(vmuls_lane_f32(-v71.f32[1], *(float32x2_t *)v71.f32, 1), v42.f32[0], v42.f32[0]) * 0.54627;
LABEL_29:
        float32x4_t v46 = v73;
LABEL_30:
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v61 = 1;
        do
        {
          uint64_t v62 = (2 * (v59 & 0x7FFFFFFF)) | 1;
          float32x4_t v63 = vmulq_n_f32(v46, v76[v59] * *((float *)&v86 + v59));
          uint64_t v64 = v58;
          do
          {
            uint64_t v65 = 4 * v64;
            float v66 = *(float *)((char *)&v77 + v65);
            *(float *)(a6 + v65) = *(float *)(a6 + v65) + (float)(v66 * v63.f32[0]);
            *(float *)(a6 + 4 * a5 * a5 + v65) = *(float *)(a6 + 4 * a5 * a5 + v65) + (float)(v66 * v63.f32[1]);
            uint64_t v60 = a6 + 8 * a5 * a5;
            *(float *)(v60 + v65) = *(float *)(v60 + v65) + (float)(v66 * v63.f32[2]);
            ++v64;
            --v62;
          }
          while (v62);
          ++v59;
          v58 += v61;
          v61 += 2;
        }
        while (v59 != a5);
        return;
      }
      v76[3] = (float)((float)((float)(v41.__cosval * v41.__cosval) * 3.5171)
                     + (float)((float)((float)(v41.__cosval * v41.__cosval) * (float)(v41.__cosval * v41.__cosval))
                             * -2.9309))
             + -0.58618;
      if (a5 < 5)
      {
        sh_eval_basis_3((uint64_t)&v77, v71.f32[0], v71.f32[1], v71.f32[2]);
        goto LABEL_29;
      }
      if (a5 - 2 < 5) {
        C3DLightAddLightSHContribution_cold_3();
      }
      return;
    case 3:
      C3DLightAddLightSHContribution_cold_4();
    default:
      return;
  }
}

void C3DLightSetAutomaticallyAdjustsShadowProjection(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  char v12 = *(unsigned char *)(a1 + 169);
  if (((((v12 & 0x20) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      char v13 = 32;
    }
    else {
      char v13 = 0;
    }
    *(unsigned char *)(a1 + 169) = v12 & 0xDF | v13;
    if (C3DLightGetShadowCascadeCount(a1) >= 2) {
      __C3DLightInvalidatePasses((void *)a1);
    }
  }
}

uint64_t C3DLightGetAutomaticallyAdjustsShadowProjection(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 169) >> 5) & 1;
}

BOOL C3DLightShouldAdjustsShadowProjection(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  BOOL v10 = C3DLightSupportsShadowCascades(a1) && *(unsigned __int8 *)(a1 + 157) > 1u;
  return ((*(unsigned char *)(a1 + 169) & 0x20) != 0 || v10) && *(_DWORD *)(a1 + 80) == 1;
}

void C3DLightSetShadowCascadeCount(uint64_t a1, unsigned int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 <= 1) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = a2;
  }
  if (v12 >= 4) {
    unsigned int v12 = 4;
  }
  if (v12 != *(unsigned __int8 *)(a1 + 157))
  {
    *(unsigned char *)(a1 + 157) = v12;
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

void C3DLightSetMaximumShadowDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 144) = a2;
}

void C3DLightSetShadowCascadeSplittingFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 148) = a2;
}

float C3DLightGetShadowCascadeSplittingFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 148);
}

void C3DLightSetShadowCascadeDebugFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL v12 = *(float *)(a1 + 152) != 0.0;
  *(float *)(a1 + 152) = a2;
  if ((a2 != 0.0) != v12)
  {
    __C3DLightDidChange((void *)a1);
    __C3DLightInvalidatePasses((void *)a1);
  }
}

float C3DLightGetShadowCascadeDebugFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 152);
}

void C3DLightSetForceCasterBackFaceOnly(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 64;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 169) = *(unsigned char *)(a1 + 169) & 0xBF | v12;
}

uint64_t C3DLightGetForceCasterBackFaceOnly(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 169) >> 6) & 1;
}

void C3DLightSetEnableSampleDistributed(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 0x80;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 169) = v12 & 0x80 | *(unsigned char *)(a1 + 169) & 0x7F;
}

uint64_t C3DLightGetEnableSampleDistributed(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 169) >> 7;
}

float32x2_t C3DLightScaleUnits(uint64_t a1, float a2)
{
  *(float64x2_t *)(a1 + 176) = vmulq_n_f64(*(float64x2_t *)(a1 + 176), a2);
  float32x2_t result = vmul_n_f32(*(float32x2_t *)(a1 + 84), a2);
  *(float32x2_t *)(a1 + 84) = result;
  return result;
}

float32x4_t *C3DLightComputeShadowKernel(uint64_t a1, float32x4_t *a2, int a3, uint64_t a4)
{
  char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(a4);
  float v8 = -2.0;
  if (CoordinatesSystemOptions)
  {
    char v9 = CoordinatesSystemOptions;
    char ForceCasterBackFaceOnly = C3DLightGetForceCasterBackFaceOnly(a1);
    float v11 = 0.5;
    if ((v9 & 8) == 0) {
      float v11 = -0.5;
    }
    if (ForceCasterBackFaceOnly) {
      float v8 = 0.0;
    }
    else {
      float v8 = v11;
    }
  }

  return C3DSetupHaltonFilterKernelConic(a2, a3, 1.0, 1.0, v8);
}

id _C3DLightCFFinalize(void *a1)
{
  C3DLightDestroyPerTypeParameters((uint64_t)a1);
  uint64_t v2 = (const void *)a1[25];
  if (v2)
  {
    CFRelease(v2);
    a1[25] = 0;
  }
  uint64_t v3 = (const void *)a1[26];
  if (v3)
  {
    CFRelease(v3);
    a1[26] = 0;
  }
  uint64_t v4 = (const void *)a1[28];
  if (v4)
  {
    CFRelease(v4);
    a1[28] = 0;
  }

  return C3DEntityCFFinalize((uint64_t)a1);
}

CFStringRef _C3DLightCFCopyDebugDescription(unsigned __int8 *a1)
{
  int v2 = a1[168];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = _C3DLightTypeDescription((uint64_t)a1);
  if (v2) {
    return CFStringCreateWithFormat(v3, 0, @"<C3DLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)", a1, v4, a1[156], a1[157]);
  }
  else {
    return CFStringCreateWithFormat(v3, 0, @"<C3DLight %p> Type:%@", a1, v4);
  }
}

__CFString *_C3DLightTypeDescription(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  float32x2_t result = @"Ambient";
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      float32x2_t result = @"Directional";
      break;
    case 2:
      float32x2_t result = @"Omni";
      break;
    case 3:
      float32x2_t result = @"Spot";
      break;
    case 4:
      int v4 = *(unsigned __int8 *)(a1 + 328);
      uint64_t v5 = @"IES";
      if (v4 == 1) {
        uint64_t v5 = @"Radiance";
      }
      if (v4) {
        float32x2_t result = v5;
      }
      else {
        float32x2_t result = @"Irradiance";
      }
      break;
    case 5:
      float32x2_t result = @"IES";
      break;
    case 6:
      unint64_t v6 = *(char *)(a1 + 256);
      if (v6 >= 5) {
        goto LABEL_13;
      }
      float32x2_t result = off_264007BA0[v6];
      break;
    default:
LABEL_13:
      float32x2_t result = @"Unknown";
      break;
  }
  return result;
}

BOOL _C3DLightInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  if (!a1)
  {
    float v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if ((C3DEntityInitWithPropertyList(a1, a2) & 1) == 0)
  {
    float32x4_t v19 = scn_default_log();
    BOOL result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DLightInitWithPropertyList_cold_5(v19);
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"property3");
  if (Value)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(Value, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 240) = v53.n128_u32[0];
  }
  CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"property4");
  if (v17)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v17, kCFNumberFloatType, &v53);
    float v18 = v53.n128_f32[0];
  }
  else
  {
    float v18 = *(float *)(a1 + 244);
  }
  *(float *)(a1 + 244) = *(float *)(a1 + 240) * v18;
  CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(a2, @"type");
  if (!v21)
  {
    __float2 v41 = scn_default_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      _C3DLightInitWithPropertyList_cold_1();
      if (!a4) {
        return 0;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*a4)
    {
      CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
      BOOL result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
  v53.n128_u32[0] = 0;
  if (!CFNumberGetValue(v21, kCFNumberIntType, &v53))
  {
    float v43 = scn_default_log();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      _C3DLightInitWithPropertyList_cold_2();
      if (!a4) {
        return 0;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*a4) {
      *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
    return 0;
  }
  *(_DWORD *)(a1 + 80) = v53.n128_u32[0];
  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a2, @"castShadow");
  if (v22)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v22, kCFNumberIntType, &v53);
    *(unsigned char *)(a1 + 168) = v53.n128_u32[0] != 0;
  }
  CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(a2, @"znear");
  if (v23)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v23, kCFNumberFloatType, &v53);
    *(double *)(a1 + 176) = v53.n128_f32[0];
  }
  CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zfar");
  if (v24)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v24, kCFNumberFloatType, &v53);
    *(double *)(a1 + 184) = v53.n128_f32[0];
  }
  CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(a2, @"orthographicScale");
  if (v25)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v25, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 136) = v53.n128_u32[0];
  }
  CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"shadowSoftenFactor");
  if (v26)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v26, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 140) = v53.n128_u32[0];
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(a2, @"category");
  if (v27)
  {
    v53.n128_u64[0] = 0;
    CFNumberGetValue(v27, kCFNumberNSIntegerType, &v53);
    *(void *)(a1 + 160) = v53.n128_u64[0];
  }
  CFNumberRef v28 = (const __CFNumber *)CFDictionaryGetValue(a2, @"attenuationStart");
  if (v28)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v28, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 84) = v53.n128_u32[0];
  }
  CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(a2, @"attenuationEnd");
  if (v29)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v29, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 88) = v53.n128_u32[0];
  }
  CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(a2, @"attenuationFalloffExponent");
  if (v30)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v30, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 92) = v53.n128_u32[0];
  }
  CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(a2, @"spotInnerAngle");
  if (v31)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v31, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 244) = v53.n128_u32[0];
  }
  CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(a2, @"spotOuterAngle");
  if (v32)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v32, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 240) = v53.n128_u32[0];
  }
  CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(a2, @"spotFalloffExponent");
  if (v33)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v33, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 248) = v53.n128_u32[0];
  }
  CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(a2, @"intensity");
  if (v34)
  {
    v53.n128_u32[0] = 0;
    CFNumberGetValue(v34, kCFNumberFloatType, &v53);
    *(_DWORD *)(a1 + 96) = v53.n128_u32[0];
  }
  float32x4_t v35 = CFDictionaryGetValue(a2, @"color");
  if (v35)
  {
    if (!C3DColor4InitWithPropertyList(a1 + 64, (uint64_t)v35, a3, a4))
    {
      float v44 = scn_default_log();
      BOOL result = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _C3DLightInitWithPropertyList_cold_4(v44);
      return 0;
    }
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToLinear((float32x4_t *)(a1 + 64));
    }
  }
  float v36 = CFDictionaryGetValue(a2, @"shadowColor");
  if (v36)
  {
    uint64_t v37 = (uint64_t)v36;
    CFTypeID v38 = CFGetTypeID(v36);
    if (v38 == CFNumberGetTypeID())
    {
      CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(a2, @"shadowColor");
      if (v39)
      {
        v53.n128_u32[0] = 0;
        CFNumberGetValue(v39, kCFNumberFloatType, &v53);
        unsigned __int32 v40 = v53.n128_u32[0];
      }
      else
      {
        unsigned __int32 v40 = 1.0;
      }
      __asm { FMOV            V1.4S, #1.0 }
      _Q1.i32[0] = v40;
      int32x4_t v52 = vzip1q_s32(_Q1, _Q1);
      v52.i32[2] = v40;
      __n128 v53 = (__n128)v52;
      if (C3DLinearRenderingIsEnabled()) {
        C3DColor4ConvertToLinear((float32x4_t *)&v53);
      }
      C3DLightSetShadowColor((__n128 *)a1, &v53);
      return 1;
    }
    float v45 = (float32x4_t *)(a1 + 112);
    if (C3DColor4InitWithPropertyList((uint64_t)v45, v37, a3, a4))
    {
      if (C3DLinearRenderingIsEnabled()) {
        C3DColor4ConvertToLinear(v45);
      }
      return 1;
    }
    float32x4_t v46 = scn_default_log();
    BOOL result = os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DLightInitWithPropertyList_cold_3(v46);
    return 0;
  }
  return 1;
}

__CFDictionary *_C3DLightCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    unint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (v14)
  {
    valuePtr.i32[0] = *(_DWORD *)(a1 + 80);
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"type", v15);
    CFRelease(v15);
    if (*(unsigned char *)(a1 + 168))
    {
      valuePtr.i32[0] = *(unsigned __int8 *)(a1 + 168);
      CFNumberRef v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v14, @"castShadow", v16);
      CFRelease(v16);
    }
    double v17 = *(double *)(a1 + 176);
    if (v17 != 0.0)
    {
      float32_t v18 = v17;
      valuePtr.f32[0] = v18;
      CFNumberRef v19 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"znear", v19);
      CFRelease(v19);
    }
    double v20 = *(double *)(a1 + 184);
    if (v20 != 0.0)
    {
      float32_t v21 = v20;
      valuePtr.f32[0] = v21;
      CFNumberRef v22 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"zfar", v22);
      CFRelease(v22);
    }
    valuePtr.i32[0] = *(_DWORD *)(a1 + 136);
    CFNumberRef v23 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"orthographicScale", v23);
    CFRelease(v23);
    valuePtr.i32[0] = *(_DWORD *)(a1 + 240);
    CFNumberRef v24 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"spotOuterAngle", v24);
    CFRelease(v24);
    if (*(float *)(a1 + 84) != 0.0)
    {
      valuePtr.i32[0] = *(_DWORD *)(a1 + 84);
      CFNumberRef v25 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"attenuationStart", v25);
      CFRelease(v25);
    }
    if (*(float *)(a1 + 88) != 0.0)
    {
      valuePtr.i32[0] = *(_DWORD *)(a1 + 88);
      CFNumberRef v26 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"attenuationEnd", v26);
      CFRelease(v26);
    }
    valuePtr.i32[0] = *(_DWORD *)(a1 + 92);
    CFNumberRef v27 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"attenuationFalloffExponent", v27);
    CFRelease(v27);
    if (*(float *)(a1 + 240) != 0.0)
    {
      valuePtr.i32[0] = *(_DWORD *)(a1 + 244);
      CFNumberRef v28 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"spotInnerAngle", v28);
      CFRelease(v28);
    }
    valuePtr.i32[0] = *(_DWORD *)(a1 + 248);
    CFNumberRef v29 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"spotFalloffExponent", v29);
    CFRelease(v29);
    valuePtr.i32[0] = *(_DWORD *)(a1 + 140);
    CFNumberRef v30 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"shadowSoftenFactor", v30);
    CFRelease(v30);
    valuePtr.i64[0] = *(void *)(a1 + 160);
    CFNumberRef v31 = CFNumberCreate(0, kCFNumberNSIntegerType, &valuePtr);
    CFDictionaryAddValue(v14, @"category", v31);
    CFRelease(v31);
    valuePtr.i32[0] = *(_DWORD *)(a1 + 96);
    CFNumberRef v32 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"intensity", v32);
    CFRelease(v32);
    float32x4_t valuePtr = *(float32x4_t *)(a1 + 64);
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToNonLinear(&valuePtr);
    }
    CFNumberRef v33 = (const void *)C3DColor4CopyPropertyList((uint64_t)&valuePtr);
    if (v33)
    {
      CFNumberRef v34 = v33;
      CFDictionaryAddValue(v14, @"color", v33);
      CFRelease(v34);
    }
    float32x4_t v38 = *(float32x4_t *)(a1 + 112);
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToNonLinear(&v38);
    }
    float32x4_t v35 = (const void *)C3DColor4CopyPropertyList((uint64_t)&v38);
    if (v35)
    {
      float v36 = v35;
      CFDictionaryAddValue(v14, @"shadowColor", v35);
      CFRelease(v36);
    }
  }
  return v14;
}

uint64_t _C3DLightFinalizeDeserialization()
{
  return 1;
}

__CFArray *_C3DLightCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFAllocatorRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  int v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 13;
  uint64_t v102 = a1 + 64;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v4, @"name", @"Color");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  uint64_t v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v9 = a1;
  uint64_t v102 = a1 + 96;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v8, @"name", @"intensity");
  CFDictionarySetValue(v8, @"type", v10);
  CFDictionarySetValue(v8, @"address", v12);
  CFDictionarySetValue(v8, @"semantic", v11);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v11);
  CFRelease(v8);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v14 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 2;
  uint64_t v102 = v9 + 80;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v14, @"name", @"type");
  CFDictionarySetValue(v14, @"type", v15);
  CFDictionarySetValue(v14, @"address", v17);
  CFDictionarySetValue(v14, @"semantic", v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  float32_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFNumberRef v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v13);
  int v103 = 0;
  int valuePtr = 3;
  uint64_t v102 = v9 + 168;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v19, @"name", @"castShadow");
  CFDictionarySetValue(v19, @"type", v20);
  CFDictionarySetValue(v19, @"address", v22);
  CFDictionarySetValue(v19, @"semantic", v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  CFNumberRef v23 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v101 = v9 + 112;
  uint64_t v102 = v9 + 112;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v23, @"name", @"shadowColor");
  CFDictionarySetValue(v23, @"type", v24);
  CFDictionarySetValue(v23, @"address", v26);
  CFDictionarySetValue(v23, @"semantic", v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  CFNumberRef v27 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v103 = 0;
  int valuePtr = 6;
  uint64_t v102 = v9 + 176;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v27, @"name", @"zNear");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  CFNumberRef v31 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v103 = 0;
  int valuePtr = 6;
  uint64_t v102 = v9 + 184;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v31, @"name", @"zFar");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  float32x4_t v35 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  float v36 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v9 + 140;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v36, @"name", @"shadowSoftenFactor");
  CFDictionarySetValue(v36, @"type", v37);
  CFDictionarySetValue(v36, @"address", v39);
  CFDictionarySetValue(v36, @"semantic", v38);
  CFArrayAppendValue(Mutable, v36);
  CFRelease(v38);
  CFRelease(v36);
  CFRelease(v39);
  CFRelease(v37);
  unsigned __int32 v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v35);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v9 + 84;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v40, @"name", @"attenuationStart");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  float v44 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v35);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v9 + 88;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v44, @"name", @"attenuationEnd");
  CFDictionarySetValue(v44, @"type", v45);
  CFDictionarySetValue(v44, @"address", v47);
  CFDictionarySetValue(v44, @"semantic", v46);
  CFArrayAppendValue(Mutable, v44);
  CFRelease(v46);
  CFRelease(v44);
  CFRelease(v47);
  CFRelease(v45);
  float v48 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  float v49 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v35);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v9 + 92;
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v49, @"name", @"attenuationFalloffExponent");
  CFDictionarySetValue(v49, @"type", v50);
  CFDictionarySetValue(v49, @"address", v52);
  CFDictionarySetValue(v49, @"semantic", v51);
  CFArrayAppendValue(Mutable, v49);
  CFRelease(v51);
  CFRelease(v49);
  CFRelease(v52);
  CFRelease(v50);
  __n128 v53 = CFDictionaryCreateMutable(0, 4, v48, v35);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v100 = v9;
  uint64_t v102 = v9 + 244;
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v53, @"name", @"spotInnerAngle");
  CFDictionarySetValue(v53, @"type", v54);
  CFDictionarySetValue(v53, @"address", v56);
  CFDictionarySetValue(v53, @"semantic", v55);
  float v57 = Mutable;
  CFArrayAppendValue(Mutable, v53);
  CFRelease(v55);
  CFRelease(v53);
  CFRelease(v56);
  CFRelease(v54);
  uint64_t v58 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v9 + 240;
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v58, @"name", @"spotOuterAngle");
  CFDictionarySetValue(v58, @"type", v59);
  CFDictionarySetValue(v58, @"address", v61);
  CFDictionarySetValue(v58, @"semantic", v60);
  CFArrayAppendValue(Mutable, v58);
  CFRelease(v60);
  CFRelease(v58);
  CFRelease(v61);
  CFRelease(v59);
  uint64_t v62 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  float32x4_t v63 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v64 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v100 + 248;
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v64, @"name", @"spotFalloffExponent");
  CFDictionarySetValue(v64, @"type", v65);
  CFDictionarySetValue(v64, @"address", v67);
  CFDictionarySetValue(v64, @"semantic", v66);
  CFArrayAppendValue(v57, v64);
  CFRelease(v66);
  CFRelease(v64);
  CFRelease(v67);
  CFRelease(v65);
  uint64_t v68 = CFDictionaryCreateMutable(0, 4, v62, v63);
  int v103 = 0;
  int valuePtr = 13;
  uint64_t v102 = v101;
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v68, @"name", @"shadowColor");
  CFDictionarySetValue(v68, @"type", v69);
  CFDictionarySetValue(v68, @"address", v71);
  CFDictionarySetValue(v68, @"semantic", v70);
  CFArrayAppendValue(v57, v68);
  CFRelease(v70);
  CFRelease(v68);
  CFRelease(v71);
  CFRelease(v69);
  __n128 v72 = CFDictionaryCreateMutable(0, 4, v62, v63);
  int v103 = 0;
  int valuePtr = 6;
  uint64_t v102 = v100 + 192;
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v75 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v72, @"name", @"shadowBias");
  CFDictionarySetValue(v72, @"type", v73);
  CFDictionarySetValue(v72, @"address", v75);
  CFDictionarySetValue(v72, @"semantic", v74);
  CFArrayAppendValue(v57, v72);
  CFRelease(v74);
  CFRelease(v72);
  CFRelease(v75);
  CFRelease(v73);
  int v76 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v63);
  int v103 = 0;
  int valuePtr = 8;
  uint64_t v102 = v100 + 128;
  CFNumberRef v77 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v78 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v79 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v76, @"name", @"shadowMapSize");
  CFDictionarySetValue(v76, @"type", v77);
  CFDictionarySetValue(v76, @"address", v79);
  CFDictionarySetValue(v76, @"semantic", v78);
  CFArrayAppendValue(v57, v76);
  CFRelease(v78);
  CFRelease(v76);
  CFRelease(v79);
  CFRelease(v77);
  float v80 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  float v81 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v100 + 136;
  CFNumberRef v82 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v83 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v84 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v81, @"name", @"directionalExtent");
  CFDictionarySetValue(v81, @"type", v82);
  CFDictionarySetValue(v81, @"address", v84);
  CFDictionarySetValue(v81, @"semantic", v83);
  CFArrayAppendValue(v57, v81);
  CFRelease(v83);
  CFRelease(v81);
  CFRelease(v84);
  CFRelease(v82);
  float v85 = v80;
  long long v86 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v87 = CFDictionaryCreateMutable(0, 4, v85, MEMORY[0x263EFFF90]);
  int v103 = 0;
  int valuePtr = 1;
  uint64_t v102 = v100 + 156;
  CFNumberRef v88 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v89 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v90 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v87, @"name", @"shadowMaxSampleCount");
  CFDictionarySetValue(v87, @"type", v88);
  CFDictionarySetValue(v87, @"address", v90);
  CFDictionarySetValue(v87, @"semantic", v89);
  CFArrayAppendValue(v57, v87);
  CFRelease(v89);
  CFRelease(v87);
  CFRelease(v90);
  CFRelease(v88);
  uint64_t v91 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v86);
  int v103 = 0;
  int valuePtr = 2;
  uint64_t v102 = v100 + 160;
  CFNumberRef v92 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v93 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v94 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v91, @"name", @"categoryBitMask");
  CFDictionarySetValue(v91, @"type", v92);
  CFDictionarySetValue(v91, @"address", v94);
  CFDictionarySetValue(v91, @"semantic", v93);
  CFArrayAppendValue(v57, v91);
  CFRelease(v93);
  CFRelease(v91);
  CFRelease(v94);
  CFRelease(v92);
  uint64_t v95 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v103 = 2;
  int valuePtr = 5;
  uint64_t v102 = v100 + 200;
  CFNumberRef v96 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v97 = CFNumberCreate(0, kCFNumberSInt32Type, &v103);
  CFNumberRef v98 = CFNumberCreate(0, kCFNumberLongType, &v102);
  CFDictionarySetValue(v95, @"name", @"gobo");
  CFDictionarySetValue(v95, @"type", v96);
  CFDictionarySetValue(v95, @"address", v98);
  CFDictionarySetValue(v95, @"semantic", v97);
  CFArrayAppendValue(v57, v95);
  CFRelease(v97);
  CFRelease(v95);
  CFRelease(v98);
  CFRelease(v96);
  return v57;
}

void _C3DLightSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 168) == __dst)
  {
    int v9 = *(unsigned __int8 *)__src;
    C3DLightSetCastsShadow(a1, v9);
  }
  else if ((void *)(a1 + 88) == __dst)
  {
    float v10 = *__src;
    C3DLightSetAttenuationEndDistance(a1, v10);
  }
  else if (a1 + 64 > (unint64_t)__dst || a1 + 76 < (unint64_t)__dst)
  {
    memcpy(__dst, __src, __n);
  }
  else
  {
    IsBlacuint64_t k = C3DColor4IsBlack((float *)(a1 + 64));
    memcpy(__dst, __src, __n);
    if (IsBlack != C3DColor4IsBlack((float *)(a1 + 64)))
    {
      __C3DLightDidChange((void *)a1);
    }
  }
}

uint64_t _C3DLightSearchByID(uint64_t a1, const void *a2)
{
  ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

float sh_eval_basis_3(uint64_t a1, float a2, float a3, float a4)
{
  float v4 = a4 * a4;
  *(_DWORD *)a1 = 1049652923;
  double v5 = a4;
  float v6 = v5 * 0.488602512;
  double v7 = v4;
  float v8 = v7 * 0.946174696 + -0.315391565;
  float v9 = (v7 * 1.86588166 + -1.119529) * v5;
  *(float *)(a1 + 4) = a3 * -0.4886;
  *(float *)(a1 + 8) = v6;
  float v10 = v5 * -1.09254843;
  *(float *)(a1 + 20) = v10 * a3;
  *(float *)(a1 + 24) = v8;
  *(float *)&double v7 = v7 * -2.285229 + 0.457045799;
  *(float *)(a1 + 44) = *(float *)&v7 * a3;
  *(float *)(a1 + 48) = v9;
  float v11 = (float)(a2 * a3) + (float)(a2 * a3);
  *(float *)(a1 + 12) = a2 * -0.4886;
  *(float *)(a1 + 16) = v11 * 0.54627;
  float v12 = (float)(a2 * a2) - (float)(a3 * a3);
  *(float *)(a1 + 28) = v10 * a2;
  *(float *)(a1 + 32) = v12 * 0.54627;
  *(float *)&double v5 = v5 * 1.44530572;
  *(float *)(a1 + 52) = *(float *)&v7 * a2;
  *(float *)(a1 + 56) = v12 * *(float *)&v5;
  *(float *)(a1 + 36) = (float)((float)(v12 * a3) + (float)(a2 * v11)) * -0.59004;
  *(float *)(a1 + 40) = v11 * *(float *)&v5;
  float result = (float)((float)(a2 * v12) - (float)(v11 * a3)) * -0.59004;
  *(float *)(a1 + 60) = result;
  return result;
}

C3D::Pass *C3D::SSRPassesCreateIfNeeded(C3D *this, C3D::RenderGraph *a2, C3D::MainPass *a3)
{
  CFNumberRef v22 = a2;
  PointOfView = C3DEngineContextGetPointOfView(*((void *)this + 1));
  if (PointOfView && C3DNodeGetCamera((uint64_t)PointOfView))
  {
    uint64_t v6 = (*(uint64_t (**)(C3D::RenderGraph *))(*(void *)a2 + 88))(a2);
    uint64_t Aligned = C3DScratchAllocatorAllocateAligned(*((void *)this + 2), 16, 8, 0);
    *(void *)uint64_t Aligned = 0;
    *(void *)(Aligned + 8) = 0;
    uint64_t v21 = Aligned;
    *(_DWORD *)(Aligned + 4) = 2;
    *(_WORD *)uint64_t Aligned = (int)fmaxf(*(float *)(v6 + 8) * 0.5, 1.0);
    *(_WORD *)(Aligned + 2) = (int)fmaxf(*(float *)(v6 + 12) * 0.5, 1.0);
    long long v19 = *(_OWORD *)(C3D::DrawNodesPass::getCullingContext(a2) + 4744);
    uint64_t CullingContext = C3D::DrawNodesPass::getCullingContext(a2);
    *(void *)&v9.f64[0] = v19;
    v9.f64[1] = *(float64_t *)(CullingContext + 4752);
    *(float32x2_t *)(Aligned + 8) = vcvt_f32_f64(v9);
    float v10 = C3D::RenderGraph::createPass<C3D::SSRDepthBackFacePass,C3D::MainPass *&>((uint64_t)this, &v22);
    float v11 = C3D::RenderGraph::createPass<C3D::SSRDownSampleColorDepthPass,C3D::MainPass *&,C3D::SSRPassData *&>((uint64_t)this, &v22, &v21);
    float v12 = C3D::RenderGraph::createPass<C3D::SSRRaytracePass,C3D::MainPass *&,C3D::SSRPassData *&>((uint64_t)this, &v22, &v21);
    char v20 = 0;
    uint64_t v13 = C3D::RenderGraph::createPass<C3D::SSRBlurPass,C3D::MainPass *&,C3D::SSRPassData *&,BOOL>((uint64_t)this, &v22, &v21, &v20);
    char v20 = 1;
    uint64_t v14 = C3D::RenderGraph::createPass<C3D::SSRBlurPass,C3D::MainPass *&,C3D::SSRPassData *&,BOOL>((uint64_t)this, &v22, &v21, &v20);
    CFNumberRef v15 = C3D::RenderGraph::createPass<C3D::SSRCompositePass,C3D::MainPass *&,C3D::SSRPassData *&>((uint64_t)this, &v22, &v21);
    C3D::Pass::addDependency(v11, v22);
    C3D::Pass::addDependency(v11, v10);
    C3D::Pass::addDependency(v12, v22);
    C3D::Pass::addDependency(v12, v11);
    C3D::Pass::addDependency(v13, v12);
    C3D::Pass::addDependency(v14, v13);
    C3D::Pass::addDependency(v14, v12);
    C3D::Pass::addDependency(v15, v14);
    CFNumberRef v16 = v22;
    if (v16 != (C3D::ScenePass *)C3D::ScenePass::lastPass(v22))
    {
      Pass = (C3D::Pass *)C3D::ScenePass::lastPass(v22);
      C3D::Pass::addDependency(v15, Pass);
    }
    C3D::Pass::addDependency(v15, v22);
    C3D::Pass::addDependency(v15, v12);
    return v15;
  }
  else
  {
    return (C3D::Pass *)C3D::ScenePass::lastPass(a2);
  }
}

C3D::SSRDepthBackFacePass *C3D::RenderGraph::createPass<C3D::SSRDepthBackFacePass,C3D::MainPass *&>(uint64_t a1, C3D::Pass **a2)
{
  uint64_t Aligned = (C3D::SSRDepthBackFacePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5376, 16, 0);
  C3D::SSRDepthBackFacePass::SSRDepthBackFacePass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::SSRDepthBackFacePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::SSRDownSampleColorDepthPass,C3D::MainPass *&,C3D::SSRPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  uint64_t Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::SSRDownSampleColorDepthPass::SSRDownSampleColorDepthPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::SSRRaytracePass,C3D::MainPass *&,C3D::SSRPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  uint64_t Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 400, 16, 0);
  C3D::SSRRaytracePass::SSRRaytracePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::SSRBlurPass,C3D::MainPass *&,C3D::SSRPassData *&,BOOL>(uint64_t a1, C3D::Pass **a2, uint64_t *a3, char *a4)
{
  uint64_t Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::SSRBlurPass::SSRBlurPass(Aligned, (RenderGraph *)a1, *a2, *a3, *a4);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::SSRCompositePass,C3D::MainPass *&,C3D::SSRPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  uint64_t Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::SSRCompositePass::SSRCompositePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

void __invalidatePassIfNeeded(void *a1, uint64_t a2)
{
  BOOL v4 = C3DCameraNeedsPostProcess((uint64_t)a1);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  if (v4 != C3DCameraNeedsPostProcess((uint64_t)a1))
  {
    _C3DCameraInvalidatePasses(a1);
  }
}

BOOL C3DCameraNeedsPostProcess(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  BOOL result = 1;
  if ((*(unsigned char *)(a1 + 312) & 2) == 0
    && *(float *)(a1 + 460) == 0.0
    && *(float *)(a1 + 456) == 1.0
    && *(float *)(a1 + 452) == 0.0
    && (*(float *)(a1 + 448) <= 0.0 || C3DWasLinkedBeforeMajorOSYear2017())
    && *(float *)(a1 + 472) <= 0.0
    && (*(float *)(a1 + 476) == 0.0 || *(float *)(a1 + 480) == 0.0)
    && *(float *)(a1 + 484) == 0.0
    && *(float *)(a1 + 488) == 0.0)
  {
    uint64_t v11 = *(void *)(a1 + 520);
    if (!v11 || !C3DEffectSlotHasImageOrTexture(v11)) {
      return 0;
    }
  }
  return result;
}

void _C3DCameraInvalidatePasses(void *a1)
{
  values = a1;
  CFDictionaryRef v1 = CFDictionaryCreate(0, (const void **)kC3DCameraKey, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  uint64_t v3 = (const void *)C3DGetScene(values);
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v3, v1, 1u);
  CFRelease(v1);
}

void C3DCameraSetMotionBlurIntensity(float *a1, float a2)
{
  values = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = a1[118];
  float v13 = 0.0;
  if (a2 >= 0.0) {
    float v13 = a2;
  }
  a1[118] = v13;
  if (a2 != 0.0 && v12 == 0.0 || a2 == 0.0 && v12 != 0.0)
  {
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)kC3DCameraKey, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    CFNumberRef v16 = (const void *)C3DGetScene(values);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v16, v14, 1u);
    CFRelease(v14);
  }
}

void C3DCameraSetDepthOfFieldIntensity(float *a1, float a2)
{
  values = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = a1[112];
  float v13 = 0.0;
  if (a2 >= 0.0) {
    float v13 = a2;
  }
  a1[112] = v13;
  if (v13 != 0.0 && v12 == 0.0 || v13 == 0.0 && v12 != 0.0)
  {
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)kC3DCameraKey, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    CFNumberRef v16 = (const void *)C3DGetScene(values);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v16, v14, 1u);
    CFRelease(v14);
  }
}

void C3DCameraSetWantsHDR(void *a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetWantsHDR_block_invoke;
  v12[3] = &__block_descriptor_tmp_2_1;
  v12[4] = a1;
  char v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

uint64_t __C3DCameraSetWantsHDR_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 312) = *(unsigned char *)(*(void *)(result + 32) + 312) & 0xFD | (2 * *(unsigned char *)(result + 40));
  return result;
}

__n128 C3DCameraSetProjectionTransform(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *(__n128 *)a2;
  long long v13 = *(_OWORD *)(a2 + 16);
  long long v14 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 256) = v14;
  *(__n128 *)(a1 + 208) = result;
  *(_OWORD *)(a1 + 224) = v13;
  *(unsigned char *)(a1 + 64) |= 8u;
  return result;
}

void C3DCameraSetScreenSpaceAmbientOcclusionIntensity(float *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 >= 0.0) {
    float v12 = a2;
  }
  else {
    float v12 = 0.0;
  }
  float v13 = a1[123];
  a1[123] = v12;
  if (v12 != 0.0 && v13 == 0.0 || v12 == 0.0 && v13 != 0.0) {
    _C3DCameraInvalidatePasses(a1);
  }
}

void C3DCameraSetScreenSpaceAmbientOcclusionRadius(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 496) = a2;
}

void C3DCameraSetScreenSpaceAmbientOcclusionBias(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 500) = a2;
}

void C3DCameraSetScreenSpaceAmbientOcclusionDepthThreshold(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 504) = a2;
}

void C3DCameraSetScreenSpaceAmbientOcclusionNormalThreshold(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 508) = a2;
}

void C3DCameraSetScreenSpaceAmbientOcclusionSampleCount(_DWORD *a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a1[128] != a2)
  {
    a1[128] = a2;
    _C3DCameraInvalidatePasses(a1);
  }
}

void C3DCameraSetScreenSpaceAmbientOcclusionDownSample(_DWORD *a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a1[129] != a2)
  {
    a1[129] = a2;
    _C3DCameraInvalidatePasses(a1);
  }
}

uint64_t C3DCameraGetAutomaticallyAdjustsZRange(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 1) & 1;
}

void C3DCameraSetAutomaticallyAdjustsZRange(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFD | v12;
}

void C3DCameraSetAverageGray(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 388) = a2;
}

void C3DCameraSetBloomBlurRadius(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 440) = a2;
}

void C3DCameraSetBloomIntensity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 424) = a2;
}

void C3DCameraSetBloomThreshold(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 428) = a2;
}

void C3DCameraSetBloomIteration(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 432) = a2;
}

void C3DCameraSetBloomIterationSpread(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 436) = a2;
}

void C3DCameraSetCategoryBitMask(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 528) = a2;
}

void C3DCameraSetColorFringeStrength(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetColorFringeStrength_block_invoke;
  v12[3] = &__block_descriptor_tmp_3_1;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetColorFringeStrength_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 452) = result;
  return result;
}

void C3DCameraSetColorFringeIntensity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 444) = a2;
}

void C3DCameraSetContrast(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetContrast_block_invoke;
  v12[3] = &__block_descriptor_tmp_4_1;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetContrast_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 460) = result;
  return result;
}

void C3DCameraSetGrainIntensity(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetGrainIntensity_block_invoke;
  v12[3] = &__block_descriptor_tmp_5_1;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetGrainIntensity_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 464) = result;
  return result;
}

void C3DCameraSetGrainScale(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 468) = a2;
}

void C3DCameraSetGrainIsColored(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 16;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a1 + 312) & 0xEF | v12;
}

CFTypeRef C3DCameraSetARGrainTexture(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 544);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 544) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 544) = result;
  }
  return result;
}

void C3DCameraSetARGrainSlice(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 552) = a2;
}

void C3DCameraSetWhiteBalanceTemperature(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetWhiteBalanceTemperature_block_invoke;
  v12[3] = &__block_descriptor_tmp_6_1;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetWhiteBalanceTemperature_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 484) = result;
  return result;
}

void C3DCameraSetWhiteBalanceTint(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetWhiteBalanceTint_block_invoke;
  v12[3] = &__block_descriptor_tmp_7_2;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetWhiteBalanceTint_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 488) = result;
  return result;
}

void C3DCameraSetExposureAdaptationBrighteningSpeedFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 400) = a2;
}

void C3DCameraSetExposureAdaptationDarkeningSpeedFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 404) = a2;
}

void C3DCameraSetExposureAdaptationDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 396) = a2;
}

void C3DCameraSetExposureAdaptationHistogramRangeHighProbability(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 408) = a2;
}

void C3DCameraSetExposureAdaptationHistogramRangeLowProbability(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 412) = a2;
}

void C3DCameraSetExposureAdaptationMode(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 313) = a2;
}

void C3DCameraSetExposureOffset(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 392) = a2;
}

void C3DCameraSetMaximumExposure(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 420) = a2;
}

void C3DCameraSetMinimumExposure(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 416) = a2;
}

double C3DCameraGetOrthographicScale(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 112);
}

void C3DCameraSetSaturation(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetSaturation_block_invoke;
  v12[3] = &__block_descriptor_tmp_8_0;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetSaturation_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 456) = result;
  return result;
}

uint64_t C3DCameraGetUsesOrthographicProjection(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 64) & 1;
}

void C3DCameraSetVignettingIntensity(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetVignettingIntensity_block_invoke;
  v12[3] = &__block_descriptor_tmp_9_0;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetVignettingIntensity_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 480) = result;
  return result;
}

void C3DCameraSetVignettingPower(void *a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = __C3DCameraSetVignettingPower_block_invoke;
  v12[3] = &__block_descriptor_tmp_10;
  v12[4] = a1;
  float v13 = a2;
  __invalidatePassIfNeeded(a1, (uint64_t)v12);
}

float __C3DCameraSetVignettingPower_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 476) = result;
  return result;
}

void C3DCameraSetWantsExposureAdaptation(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 4;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a1 + 312) & 0xFB | v12;
}

void C3DCameraSetWhitePoint(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 384) = a2;
}

double C3DCameraGetXFov(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 272);
}

double C3DCameraGetYFov(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 280);
}

double C3DCameraGetZFar(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 80);
}

double C3DCameraGetZNear(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 72);
}

void C3DCameraSetFocalLength(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 292) = a2;
  _updateFov(a1);
}

float _updateFov(uint64_t a1)
{
  long double v2 = atan(*(float *)(a1 + 300) * 0.5 / *(float *)(a1 + 292));
  *(float *)&long double v2 = v2 + v2;
  float result = *(float *)&v2 / 3.14159265 * 180.0;
  *(float *)(a1 + 120) = result;
  *(unsigned char *)(a1 + 64) &= ~0x10u;
  return result;
}

float C3DCameraSetFov(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 120) = a2;
  *(unsigned char *)(a1 + 64) &= ~0x10u;
  float v12 = a2 / 180.0 * 3.14159265;
  double v13 = *(float *)(a1 + 300) * 0.5;
  float result = v13 / tanf(v12 * 0.5);
  *(float *)(a1 + 292) = result;
  return result;
}

double C3DCameraSetAspectRatio(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  double result = a2;
  *(double *)(a1 + 128) = a2;
  *(unsigned char *)(a1 + 64) &= ~0x10u;
  return result;
}

void C3DCameraSetFocusDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 288) = a2;
}

void C3DCameraSetLensShift(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 88) = a2;
}

void C3DCameraSetPostProjectionTransformTranslation(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 96) = a2;
}

void C3DCameraSetPostProjectionTransformScale(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 104) = a2;
}

float C3DCameraGetAperture(uint64_t a1)
{
  if (!a1)
  {
    long double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 300) / *(float *)(a1 + 296);
}

void C3DCameraSetFStop(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 296) = a2;
}

void C3DCameraSetBladeCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 304) = a2;
}

void C3DCameraSetDofSampleCount(_DWORD *a1, int a2)
{
  values = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a1[77] != a2)
  {
    a1[77] = a2;
    CFDictionaryRef v12 = CFDictionaryCreate(0, (const void **)kC3DCameraKey, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    long long v14 = (const void *)C3DGetScene(values);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v14, v12, 1u);
    CFRelease(v12);
  }
}

float C3DCameraSetSensorSize(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = 0.0001;
  if (a2 >= 0.0001) {
    float v12 = a2;
  }
  *(float *)(a1 + 300) = v12;
  *(unsigned char *)(a1 + 64) &= ~0x10u;
  float v13 = *(float *)(a1 + 120) / 180.0 * 3.14159265;
  float result = v12 * 0.5 / tanf(v13 * 0.5);
  *(float *)(a1 + 292) = result;
  return result;
}

void C3DCameraSetFovHorizontal(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 32;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xDF | v12;
}

uint64_t C3DCameraGetLetterboxMode(uint64_t a1)
{
  if (!a1)
  {
    long double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 3) & 1;
}

void C3DCameraSetLetterboxMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 8;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a1 + 312) & 0xF7 | v12;
  if (a2) {
    char v13 = 64;
  }
  else {
    char v13 = 0;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xAF | v13;
}

void C3DCameraGetEffectiveFovForAspectRatio(uint64_t a1, float *a2, float *a3, float a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  double v16 = *(double *)(a1 + 272);
  double v17 = *(double *)(a1 + 280);
  if (v16 == 0.0)
  {
    float v19 = v17;
    if (v17 == 0.0) {
      float v19 = 60.0;
    }
    *a2 = v19 * a4;
  }
  else if (v17 == 0.0)
  {
    float v18 = v16;
    *a2 = v18;
    float v19 = v16 / a4;
  }
  else
  {
    double v20 = tan(v16 / 180.0 * 3.14159265);
    long double v21 = v20 / tan(v17 / 180.0 * 3.14159265);
    double v22 = a4;
    if (v21 <= a4) {
      double v16 = v17 * v22;
    }
    else {
      double v17 = v16 / v22;
    }
    float v23 = v16;
    *a2 = v23;
    float v19 = v17;
  }
  *a3 = v19;
}

void C3DCameraSetOrthographicScale(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 112) = a2;
  *(unsigned char *)(a1 + 64) &= ~8u;
}

void C3DCameraSetUsesOrthographicProjection(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xF6 | a2;
}

void C3DCameraSetXFov(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 272) = a2;
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xE7 | 0x10;
}

void C3DCameraSetYFov(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 280) = a2;
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xE7 | 0x10;
}

void C3DCameraSetZFar(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 80) = a2;
  *(unsigned char *)(a1 + 64) &= ~8u;
}

void C3DProjectionInfosSetZFar(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 16) = a2;
  *(unsigned char *)a1 &= ~8u;
}

void C3DCameraSetZNear(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 == 0.0 && (*(unsigned char *)(a1 + 64) & 1) == 0)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl(&dword_20B249000, v12, OS_LOG_TYPE_INFO, "Info: invalid zNear value (0) set to camera", v13, 2u);
    }
  }
  *(double *)(a1 + 72) = a2;
  *(unsigned char *)(a1 + 64) &= ~8u;
}

void C3DProjectionInfosSetZNear(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 8) = a2;
  *(unsigned char *)a1 &= ~8u;
}

double C3DCameraGetFrontDirection()
{
  return 0.0;
}

void C3DCameraSetTechnique(void *a1, CFTypeRef cf)
{
  values = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCameraNeedsPostProcess_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = (CFTypeRef)a1[67];
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      a1[67] = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    a1[67] = v13;
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)kC3DCameraKey, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    double v16 = (const void *)C3DGetScene(values);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v16, v14, 1u);
    CFRelease(v14);
  }
}

double C3DProjectionInfosGetXFov(uint64_t a1)
{
  if (!a1)
  {
    long double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 208);
}

double C3DProjectionInfosGetYFov(uint64_t a1)
{
  if (!a1)
  {
    long double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 216);
}

double C3DProjectionInfosGetEffectiveFov(uint64_t a1)
{
  if (!a1)
  {
    long double v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)a1 & 0x10) == 0) {
    return *(float *)(a1 + 56);
  }
  uint64_t v11 = 208;
  if ((*(unsigned char *)a1 & 0x20) == 0) {
    uint64_t v11 = 216;
  }
  return *(double *)(a1 + v11);
}

uint64_t C3DProjectionInfosUnproject(uint64_t a1, uint64_t a2, int a3, char a4, _OWORD *a5, __n128 a6)
{
  LODWORD(v8) = a3;
  __n128 v54 = a6;
  if ((a4 & 8) != 0 || (char v11 = *(unsigned char *)a1, (*(unsigned char *)a1 & 0x19) != 0))
  {
    simd_float4x4 v55 = *(simd_float4x4 *)C3DProjectionInfosGetMatrix((char *)a1, (uint64_t)&v54, a4);
    simd_float4x4 v56 = __invert_f4(v55);
    float32x4_t v47 = (float32x4_t)v56.columns[1];
    float32x4_t v48 = (float32x4_t)v56.columns[0];
    float32x4_t v45 = (float32x4_t)v56.columns[3];
    float32x4_t v46 = (float32x4_t)v56.columns[2];
    if (v54.n128_f32[2] == 0.0 || v54.n128_f32[3] == 0.0)
    {
      CFNumberRef v42 = scn_default_log();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        C3DProjectionInfosUnproject_cold_2(v42);
      }
      return 0;
    }
    uint64_t v30 = 1;
    if (!v8) {
      return v30;
    }
    uint64_t v8 = v8;
    CFNumberRef v32 = (float *)(a2 + 8);
    LODWORD(v31) = 1.0;
    while (1)
    {
      float v34 = *(v32 - 2);
      float v33 = *(v32 - 1);
      __n128 v35 = v54;
      if ((a4 & 8) != 0)
      {
        long long v50 = v31;
        char v37 = C3DWasLinkedBeforeMajorOSYear2021();
        float v36 = *v32;
        if ((v37 & 1) == 0)
        {
          float v38 = 1.0 - v36;
          long long v31 = v50;
          goto LABEL_22;
        }
        long long v31 = v50;
      }
      else
      {
        float v36 = *v32;
      }
      float v38 = (float)(v36 * 2.0) + -1.0;
LABEL_22:
      HIDWORD(v39) = v45.i32[3];
      float32x4_t v40 = vaddq_f32(v45, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v47, (float)((float)((float)(v33 - v35.n128_f32[1]) + (float)(v33 - v35.n128_f32[1])) / v35.n128_f32[3])+ -1.0), v48, (float)((float)((float)(v34 - v35.n128_f32[0]) + (float)(v34 - v35.n128_f32[0])) / v35.n128_f32[2])+ -1.0), v46, v38));
      if (v40.f32[3] == 0.0)
      {
        if ((C3DProjectionInfosUnproject_done & 1) == 0)
        {
          float32x4_t v44 = v40;
          long long v51 = v31;
          C3DProjectionInfosUnproject_done = 1;
          CFNumberRef v41 = scn_default_log();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
            C3DProjectionInfosUnproject_cold_1(&buf, v53, v41);
          }
          long long v31 = v51;
          float32x4_t v40 = v44;
        }
      }
      else
      {
        *(float *)&long long v31 = 1.0 / v40.f32[3];
      }
      *(float32x2_t *)&long long v39 = vmul_n_f32(*(float32x2_t *)v40.f32, *(float *)&v31);
      DWORD2(v39) = vmuls_lane_f32(*(float *)&v31, v40, 2);
      *a5++ = v39;
      v32 += 4;
      if (!--v8) {
        return 1;
      }
    }
  }
  float v13 = *(float *)(a1 + 56) / 180.0 * 3.14159265;
  float32x4_t v49 = (float32x4_t)a6;
  float v14 = tanf(v13 * 0.5);
  float32x4_t v16 = vdivq_f32(v49, (float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3));
  if ((v11 & 0x20) != 0) {
    v16.f32[0] = v14;
  }
  else {
    v16.f32[0] = v16.f32[2] * v14;
  }
  if ((v11 & 0x20) != 0) {
    float v14 = v14 / v16.f32[2];
  }
  if (v8)
  {
    v16.f32[1] = v14;
    float v17 = *(double *)(a1 + 8);
    float v18 = *(double *)(a1 + 16);
    float v19 = v17 * v18;
    float v20 = v17 - v18;
    uint64_t v21 = v8;
    float32x2_t v22 = (float32x2_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL).u64[0];
    float v23 = (float *)(a2 + 8);
    __asm { FMOV            V5.2S, #-1.0 }
    do
    {
      float v29 = v19 / (float)(v18 + (float)(*v23 * v20));
      *(float32x2_t *)&long long v15 = vsub_f32(*(float32x2_t *)(v23 - 2), *(float32x2_t *)v49.f32);
      *(float32x2_t *)&long long v15 = vmul_n_f32(vmul_f32(*(float32x2_t *)v16.f32, vadd_f32(vdiv_f32(vadd_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15), v22), _D5)), v29);
      *((float *)&v15 + 2) = -v29;
      *a5++ = v15;
      v23 += 4;
      --v21;
    }
    while (v21);
  }
  return 1;
}

void _C3DCameraCFFinalize(void *a1)
{
  C3DEntityCFFinalize((uint64_t)a1);
  long double v2 = (const void *)a1[65];
  if (v2)
  {
    CFRelease(v2);
    a1[65] = 0;
  }
  uint64_t v3 = (const void *)a1[67];
  if (v3)
  {
    CFRelease(v3);
    a1[67] = 0;
  }
  uint64_t v4 = (const void *)a1[68];
  if (v4)
  {
    CFRelease(v4);
    a1[68] = 0;
  }
}

CFStringRef _C3DCameraCFCopyDebugDescription(unsigned char *cf)
{
  char v2 = cf[64];
  if ((v2 & 8) != 0)
  {
    long long v15 = *((_OWORD *)cf + 15);
    long long v16 = *((_OWORD *)cf + 16);
    long long v13 = *((_OWORD *)cf + 13);
    long long v14 = *((_OWORD *)cf + 14);
    CFAllocatorRef v11 = CFGetAllocator(cf);
    uint64_t Name = C3DEntityGetName((uint64_t)cf);
    return CFStringCreateWithFormat(v11, 0, @"<C3DCamera:%p \"%@\" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>",
             cf,
             Name,
             *(float *)&v13,
             *((float *)&v13 + 1),
             *((float *)&v13 + 2),
             *((float *)&v13 + 3),
             *(float *)&v14,
             *((float *)&v14 + 1),
             *((float *)&v14 + 2),
             *((float *)&v14 + 3),
             *(float *)&v15,
             *((float *)&v15 + 1),
             *((float *)&v15 + 2),
             *((float *)&v15 + 3),
             *(float *)&v16,
             *((float *)&v16 + 1),
             *((float *)&v16 + 2),
             *((float *)&v16 + 3));
  }
  else
  {
    uint64_t v3 = *((void *)cf + 9);
    uint64_t v4 = *((void *)cf + 10);
    uint64_t v5 = *((void *)cf + 14);
    float v6 = *((float *)cf + 30);
    CFAllocatorRef v7 = CFGetAllocator(cf);
    uint64_t v8 = C3DEntityGetName((uint64_t)cf);
    if (v2)
    {
      return CFStringCreateWithFormat(v7, 0, @"<C3DCamera:%p \"%@\" ortho, near:%.3f far:%.3f scale: %.3f>", cf, v8, v3, v4, v5);
    }
    else
    {
      uint64_t v9 = "horizontal";
      if ((v2 & 0x20) == 0) {
        uint64_t v9 = "vertical";
      }
      return CFStringCreateWithFormat(v7, 0, @"<C3DCamera:%p \"%@\" persp, near:%.3f far:%.3f %s-fov:%.3f>", cf, v8, v3, v4, v9, v6);
    }
  }
}

float _C3DCameraSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 448) == __dst)
  {
    float v7 = *__src;
    C3DCameraSetDepthOfFieldIntensity((float *)a1, v7);
  }
  else if ((void *)(a1 + 472) == __dst)
  {
    float v8 = *__src;
    C3DCameraSetMotionBlurIntensity((float *)a1, v8);
  }
  else if ((void *)(a1 + 120) == __dst)
  {
    float v9 = *__src;
    return C3DCameraSetFov(a1, v9);
  }
  else if ((void *)(a1 + 272) == __dst)
  {
    double v10 = *(double *)__src;
    C3DCameraSetXFov(a1, v10);
  }
  else if ((void *)(a1 + 280) == __dst)
  {
    double v11 = *(double *)__src;
    C3DCameraSetYFov(a1, v11);
  }
  else
  {
    if (a1 + 448 > (unint64_t)__dst || a1 + 480 < (unint64_t)__dst)
    {
      memcpy(__dst, __src, __n);
    }
    else
    {
      v12[0] = MEMORY[0x263EF8330];
      v12[1] = 0x40000000;
      v12[2] = ___C3DCameraSetValue_block_invoke;
      v12[3] = &__block_descriptor_tmp_169;
      v12[4] = __dst;
      void v12[5] = __src;
      v12[6] = __n;
      __invalidatePassIfNeeded((void *)a1, (uint64_t)v12);
    }
    if ((void *)(a1 + 300) == __dst || (void *)(a1 + 292) == __dst)
    {
      *(unsigned char *)(a1 + 64) &= ~0x10u;
      return _updateFov(a1);
    }
  }
  return result;
}

uint64_t _C3DCameraInitWithPropertyList(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = C3DEntityInitWithPropertyList(a1, a2);
  if (v12)
  {
    *(void *)(a1 + 272) = 0;
    *(void *)(a1 + 280) = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"ortho");
    if (Value)
    {
      v55[0] = 0.0;
      CFNumberGetValue(Value, kCFNumberIntType, v55);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFE | (LODWORD(v55[0]) != 0);
    }
    CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a2, @"letterbox");
    if (v14)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v14, kCFNumberIntType, v55);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xBF | ((LODWORD(v55[0]) != 0) << 6);
    }
    CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fovHorizontal");
    if (v15)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v15, kCFNumberIntType, v55);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xDF | (32 * (LODWORD(v55[0]) != 0));
    }
    CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(a2, @"customProj");
    if (v16)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v16, kCFNumberIntType, v55);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xF7 | (8 * (LODWORD(v55[0]) != 0));
    }
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"autoZRange");
    if (v17)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v17, kCFNumberIntType, v55);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFD | (2 * (LODWORD(v55[0]) != 0));
    }
    CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(a2, @"xfov");
    if (v18)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v18, kCFNumberDoubleType, v55);
      *(void *)(a1 + 272) = *(void *)v55;
    }
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"yfov");
    if (v19)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v19, kCFNumberDoubleType, v55);
      *(void *)(a1 + 280) = *(void *)v55;
    }
    CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(a2, @"xMag");
    if (v20)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v20, kCFNumberDoubleType, v55);
      *(void *)(a1 + 112) = *(void *)v55;
    }
    CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(a2, @"znear");
    if (v21)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v21, kCFNumberDoubleType, v55);
      *(void *)(a1 + 72) = *(void *)v55;
    }
    CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zfar");
    if (v22)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v22, kCFNumberDoubleType, v55);
      *(void *)(a1 + 80) = *(void *)v55;
    }
    CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(a2, @"aspectRatio");
    if (v23)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v23, kCFNumberDoubleType, v55);
      *(void *)(a1 + 128) = *(void *)v55;
    }
    CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(a2, @"focusDistance");
    if (v24)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v24, kCFNumberFloatType, v55);
      *(float *)(a1 + 288) = v55[0];
    }
    CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fstop");
    if (v25)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v25, kCFNumberFloatType, v55);
      *(float *)(a1 + 296) = v55[0];
    }
    CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bladeCount");
    if (v26)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v26, kCFNumberIntType, v55);
      *(float *)(a1 + 304) = v55[0];
    }
    CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(a2, @"dofSampleCount");
    if (v27)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v27, kCFNumberIntType, v55);
      *(float *)(a1 + 308) = v55[0];
    }
    CFNumberRef v28 = (const __CFNumber *)CFDictionaryGetValue(a2, @"sensorSize");
    if (v28)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v28, kCFNumberFloatType, v55);
      *(float *)(a1 + 300) = v55[0];
    }
    CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(a2, @"dofIntensity");
    if (v29)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v29, kCFNumberFloatType, v55);
      *(float *)(a1 + 448) = v55[0];
    }
    CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(a2, @"category");
    if (v30)
    {
      *(void *)simd_float4x4 v55 = 0;
      CFNumberGetValue(v30, kCFNumberNSIntegerType, v55);
      *(void *)(a1 + 528) = *(void *)v55;
    }
    CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(a2, @"whitePoint");
    if (v31)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v31, kCFNumberFloatType, v55);
      *(float *)(a1 + 384) = v55[0];
    }
    CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(a2, @"averageGray");
    if (v32)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v32, kCFNumberFloatType, v55);
      *(float *)(a1 + 388) = v55[0];
    }
    CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(a2, @"exposureAdaptationDuration");
    if (v33)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v33, kCFNumberFloatType, v55);
      *(float *)(a1 + 396) = v55[0];
    }
    CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(a2, @"exposureAdaptationBrighteningSpeedFactor");
    if (v34)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v34, kCFNumberFloatType, v55);
      *(float *)(a1 + 400) = v55[0];
    }
    CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(a2, @"exposureAdaptationDarkeningSpeedFactor");
    if (v35)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v35, kCFNumberFloatType, v55);
      *(float *)(a1 + 404) = v55[0];
    }
    CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(a2, @"minimumExposure");
    if (v36)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v36, kCFNumberFloatType, v55);
      *(float *)(a1 + 416) = v55[0];
    }
    CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(a2, @"maximumExposure");
    if (v37)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v37, kCFNumberFloatType, v55);
      *(float *)(a1 + 420) = v55[0];
    }
    CFNumberRef v38 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bloomIntensity");
    if (v38)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v38, kCFNumberFloatType, v55);
      *(float *)(a1 + 424) = v55[0];
    }
    CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bloomThreshold");
    if (v39)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v39, kCFNumberFloatType, v55);
      *(float *)(a1 + 428) = v55[0];
    }
    CFNumberRef v40 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bloomIteration");
    if (v40)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v40, kCFNumberIntType, v55);
      *(float *)(a1 + 432) = v55[0];
    }
    CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bloomIterationSpread");
    if (v41)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v41, kCFNumberFloatType, v55);
      *(_DWORD *)(a1 + 432) = (int)v55[0];
    }
    CFNumberRef v42 = (const __CFNumber *)CFDictionaryGetValue(a2, @"bloomBlurRadius");
    if (v42)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v42, kCFNumberFloatType, v55);
      *(float *)(a1 + 440) = v55[0];
    }
    CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(a2, @"motionBlurIntensity");
    if (v43)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v43, kCFNumberFloatType, v55);
      *(float *)(a1 + 472) = v55[0];
    }
    CFNumberRef v44 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionIntensity");
    if (v44)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v44, kCFNumberFloatType, v55);
      *(float *)(a1 + 492) = v55[0];
    }
    CFNumberRef v45 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionRadius");
    if (v45)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v45, kCFNumberFloatType, v55);
      *(float *)(a1 + 496) = v55[0];
    }
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionBias");
    if (v46)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v46, kCFNumberFloatType, v55);
      *(float *)(a1 + 500) = v55[0];
    }
    CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionDepthThreshold");
    if (v47)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v47, kCFNumberFloatType, v55);
      *(float *)(a1 + 504) = v55[0];
    }
    CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionNormalThreshold");
    if (v48)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v48, kCFNumberFloatType, v55);
      *(float *)(a1 + 508) = v55[0];
    }
    CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionSampleCount");
    if (v49)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v49, kCFNumberIntType, v55);
      *(float *)(a1 + 512) = v55[0];
    }
    CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(a2, @"screenSpaceAmbientOcclusionDownSample");
    if (v50)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v50, kCFNumberIntType, v55);
      *(float *)(a1 + 516) = v55[0];
    }
    *(unsigned char *)(a1 + 64) |= 0x10u;
    CFNumberRef v51 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fov");
    if (v51)
    {
      v55[0] = 0.0;
      CFNumberGetValue(v51, kCFNumberFloatType, v55);
      C3DCameraSetFov(a1, v55[0]);
    }
    if (*(double *)(a1 + 72) == 0.0 && (*(unsigned char *)(a1 + 64) & 1) == 0)
    {
      CFNumberRef v52 = scn_default_log();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
      {
        LOWORD(v55[0]) = 0;
        _os_log_impl(&dword_20B249000, v52, OS_LOG_TYPE_INFO, "Info: loaded camera has an invalid zNear value (0)", (uint8_t *)v55, 2u);
      }
    }
  }
  else
  {
    __n128 v53 = scn_default_log();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      _C3DCameraInitWithPropertyList_cold_1(v53);
    }
  }
  return v12;
}

__CFDictionary *_C3DCameraCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFNumberRef v14 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (v14)
  {
    LODWORD(valuePtr) = *(unsigned char *)(a1 + 64) & 1;
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"ortho", v15);
    CFRelease(v15);
    LODWORD(valuePtr) = (*(unsigned __int8 *)(a1 + 312) >> 3) & 1;
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"letterbox", v16);
    CFRelease(v16);
    LODWORD(valuePtr) = (*(unsigned __int8 *)(a1 + 64) >> 5) & 1;
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"fovHorizontal", v17);
    CFRelease(v17);
    LODWORD(valuePtr) = (*(unsigned __int8 *)(a1 + 64) >> 1) & 1;
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"autoZRange", v18);
    CFRelease(v18);
    LODWORD(valuePtr) = (*(unsigned __int8 *)(a1 + 64) >> 3) & 1;
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"customProj", v19);
    CFRelease(v19);
    if ((*(unsigned char *)(a1 + 64) & 0x10) != 0)
    {
      if (*(double *)(a1 + 272) != 0.0)
      {
        uint64_t valuePtr = *(void *)(a1 + 272);
        CFNumberRef v23 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFDictionaryAddValue(v14, @"xfov", v23);
        CFRelease(v23);
      }
      if (*(double *)(a1 + 280) != 0.0)
      {
        uint64_t valuePtr = *(void *)(a1 + 280);
        CFNumberRef v24 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFDictionaryAddValue(v14, @"yfov", v24);
        CFRelease(v24);
      }
    }
    else
    {
      LODWORD(valuePtr) = *(_DWORD *)(a1 + 120);
      CFNumberRef v20 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionaryAddValue(v14, @"fov", v20);
      CFRelease(v20);
      LODWORD(valuePtr) = (*(unsigned __int8 *)(a1 + 64) >> 5) & 1;
      CFNumberRef v21 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v14, @"fovHorizontal", v21);
      CFRelease(v21);
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v14, @"sensorSize");
      if (Value)
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
        *(_DWORD *)(a1 + 300) = valuePtr;
      }
    }
    uint64_t valuePtr = *(void *)(a1 + 112);
    CFNumberRef v25 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue(v14, @"xMag", v25);
    CFRelease(v25);
    uint64_t valuePtr = *(void *)(a1 + 72);
    CFNumberRef v26 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue(v14, @"znear", v26);
    CFRelease(v26);
    uint64_t valuePtr = *(void *)(a1 + 80);
    CFNumberRef v27 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue(v14, @"zfar", v27);
    CFRelease(v27);
    uint64_t valuePtr = *(void *)(a1 + 128);
    CFNumberRef v28 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue(v14, @"aspectRatio", v28);
    CFRelease(v28);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 296);
    CFNumberRef v29 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"fstop", v29);
    CFRelease(v29);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 304);
    CFNumberRef v30 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"bladeCount", v30);
    CFRelease(v30);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 308);
    CFNumberRef v31 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"dofSampleCount", v31);
    CFRelease(v31);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 288);
    CFNumberRef v32 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"focusDistance", v32);
    CFRelease(v32);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 448);
    CFNumberRef v33 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"dofIntensity", v33);
    CFRelease(v33);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 492);
    CFNumberRef v34 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionIntensity", v34);
    CFRelease(v34);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 496);
    CFNumberRef v35 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionRadius", v35);
    CFRelease(v35);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 500);
    CFNumberRef v36 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionBias", v36);
    CFRelease(v36);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 504);
    CFNumberRef v37 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionDepthThreshold", v37);
    CFRelease(v37);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 508);
    CFNumberRef v38 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionNormalThreshold", v38);
    CFRelease(v38);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 512);
    CFNumberRef v39 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionSampleCount", v39);
    CFRelease(v39);
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 516);
    CFNumberRef v40 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v14, @"screenSpaceAmbientOcclusionDownSample", v40);
    CFRelease(v40);
    uint64_t valuePtr = *(void *)(a1 + 528);
    CFNumberRef v41 = CFNumberCreate(0, kCFNumberNSIntegerType, &valuePtr);
    CFDictionaryAddValue(v14, @"category", v41);
    CFRelease(v41);
  }
  return v14;
}

uint64_t _C3DCameraFinalizeDeserialization()
{
  return 1;
}

__CFArray *_C3DCameraCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 6;
  uint64_t v180 = a1 + 128;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v5, @"name", @"aspectRatio");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  LOBYTE(v5) = *(unsigned char *)(a1 + 64);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  if ((v5 & 0x10) != 0)
  {
    int v181 = 0;
    int valuePtr = 6;
    uint64_t v180 = a1 + 272;
    CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v37 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v9, @"name", @"xfov");
    CFDictionarySetValue(v9, @"type", v35);
    CFDictionarySetValue(v9, @"address", v37);
    CFDictionarySetValue(v9, @"semantic", v36);
    CFArrayAppendValue(Mutable, v9);
    CFRelease(v36);
    CFRelease(v9);
    CFRelease(v37);
    CFRelease(v35);
    CFNumberRef v38 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 6;
    uint64_t v180 = a1 + 280;
    CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v40 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v38, @"name", @"yfov");
    CFDictionarySetValue(v38, @"type", v30);
    CFDictionarySetValue(v38, @"address", v40);
    CFDictionarySetValue(v38, @"semantic", v39);
    CFNumberRef v33 = Mutable;
    CFArrayAppendValue(Mutable, v38);
    CFRelease(v39);
    CFRelease(v38);
    CFNumberRef v34 = v40;
  }
  else
  {
    int v181 = 0;
    int valuePtr = 1;
    uint64_t v180 = a1 + 120;
    CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v9, @"name", @"fieldOfView");
    CFDictionarySetValue(v9, @"type", v10);
    CFDictionarySetValue(v9, @"address", v12);
    CFDictionarySetValue(v9, @"semantic", v11);
    CFArrayAppendValue(Mutable, v9);
    CFRelease(v11);
    CFRelease(v9);
    CFRelease(v12);
    CFRelease(v10);
    uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 1;
    uint64_t v180 = a1 + 300;
    CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v13, @"name", @"sensorHeight");
    CFDictionarySetValue(v13, @"type", v14);
    CFDictionarySetValue(v13, @"address", v16);
    CFDictionarySetValue(v13, @"semantic", v15);
    CFArrayAppendValue(Mutable, v13);
    CFRelease(v15);
    CFRelease(v13);
    CFRelease(v16);
    CFRelease(v14);
    CFNumberRef v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 1;
    uint64_t v180 = a1 + 292;
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v17, @"name", @"focalLength");
    CFDictionarySetValue(v17, @"type", v18);
    CFDictionarySetValue(v17, @"address", v20);
    CFDictionarySetValue(v17, @"semantic", v19);
    CFArrayAppendValue(Mutable, v17);
    CFRelease(v19);
    CFRelease(v17);
    CFRelease(v20);
    CFRelease(v18);
    CFNumberRef v21 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 8;
    uint64_t v180 = a1 + 88;
    CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v21, @"name", @"lensShift");
    CFDictionarySetValue(v21, @"type", v22);
    CFDictionarySetValue(v21, @"address", v24);
    CFDictionarySetValue(v21, @"semantic", v23);
    CFArrayAppendValue(Mutable, v21);
    CFRelease(v23);
    CFRelease(v21);
    CFRelease(v24);
    CFRelease(v22);
    CFNumberRef v25 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 8;
    uint64_t v180 = a1 + 96;
    CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v25, @"name", @"postProjectionTransformTranslation");
    CFDictionarySetValue(v25, @"type", v26);
    CFDictionarySetValue(v25, @"address", v28);
    CFDictionarySetValue(v25, @"semantic", v27);
    CFArrayAppendValue(Mutable, v25);
    CFRelease(v27);
    CFRelease(v25);
    CFRelease(v28);
    CFRelease(v26);
    CFNumberRef v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v181 = 0;
    int valuePtr = 8;
    uint64_t v180 = a1 + 104;
    CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
    CFNumberRef v32 = CFNumberCreate(0, kCFNumberLongType, &v180);
    CFDictionarySetValue(v29, @"name", @"postProjectionTransformScale");
    CFDictionarySetValue(v29, @"type", v30);
    CFDictionarySetValue(v29, @"address", v32);
    CFDictionarySetValue(v29, @"semantic", v31);
    CFNumberRef v33 = Mutable;
    CFArrayAppendValue(Mutable, v29);
    CFRelease(v31);
    CFRelease(v29);
    CFNumberRef v34 = v32;
  }
  CFRelease(v34);
  CFRelease(v30);
  CFNumberRef v41 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 6;
  uint64_t v180 = a1 + 112;
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v44 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v41, @"name", @"orthoScale");
  CFDictionarySetValue(v41, @"type", v42);
  CFDictionarySetValue(v41, @"address", v44);
  CFDictionarySetValue(v41, @"semantic", v43);
  CFNumberRef v45 = v33;
  CFArrayAppendValue(v33, v41);
  CFRelease(v43);
  CFRelease(v41);
  CFRelease(v44);
  CFRelease(v42);
  CFNumberRef v46 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFNumberRef v47 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 6;
  uint64_t v180 = a1 + 80;
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v47, @"name", @"zfar");
  CFDictionarySetValue(v47, @"type", v48);
  CFDictionarySetValue(v47, @"address", v50);
  CFDictionarySetValue(v47, @"semantic", v49);
  CFArrayAppendValue(v45, v47);
  CFRelease(v49);
  CFRelease(v47);
  CFRelease(v50);
  CFRelease(v48);
  CFNumberRef v51 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v46);
  int v181 = 0;
  int valuePtr = 6;
  uint64_t v180 = a1 + 72;
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v51, @"name", @"znear");
  CFDictionarySetValue(v51, @"type", v52);
  CFDictionarySetValue(v51, @"address", v54);
  CFDictionarySetValue(v51, @"semantic", v53);
  CFArrayAppendValue(v45, v51);
  CFRelease(v53);
  CFRelease(v51);
  CFRelease(v54);
  CFRelease(v52);
  simd_float4x4 v55 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v46);
  int v181 = 0;
  int valuePtr = 11;
  uint64_t v180 = a1 + 144;
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v55, @"name", @"matrix");
  CFDictionarySetValue(v55, @"type", v56);
  CFDictionarySetValue(v55, @"address", v58);
  CFDictionarySetValue(v55, @"semantic", v57);
  CFArrayAppendValue(v45, v55);
  CFRelease(v57);
  CFRelease(v55);
  CFRelease(v58);
  CFRelease(v56);
  CFNumberRef v59 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v46);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 288;
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v59, @"name", @"focusDistance");
  CFDictionarySetValue(v59, @"type", v60);
  CFDictionarySetValue(v59, @"address", v62);
  CFDictionarySetValue(v59, @"semantic", v61);
  CFArrayAppendValue(v45, v59);
  CFRelease(v61);
  CFRelease(v59);
  CFRelease(v62);
  CFRelease(v60);
  float32x4_t v63 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v64 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v46);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 296;
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v64, @"name", @"fStop");
  CFDictionarySetValue(v64, @"type", v65);
  CFDictionarySetValue(v64, @"address", v67);
  CFDictionarySetValue(v64, @"semantic", v66);
  CFArrayAppendValue(v45, v64);
  CFRelease(v66);
  CFRelease(v64);
  CFRelease(v67);
  CFRelease(v65);
  uint64_t v68 = CFDictionaryCreateMutable(0, 4, v63, v46);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = a1 + 304;
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v68, @"name", @"bladeCount");
  CFDictionarySetValue(v68, @"type", v69);
  CFDictionarySetValue(v68, @"address", v71);
  CFDictionarySetValue(v68, @"semantic", v70);
  CFArrayAppendValue(v45, v68);
  CFRelease(v70);
  CFRelease(v68);
  CFRelease(v71);
  CFRelease(v69);
  __n128 v72 = CFDictionaryCreateMutable(0, 4, v63, v46);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = a1 + 308;
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v75 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v72, @"name", @"dofSampleCount");
  CFDictionarySetValue(v72, @"type", v73);
  CFDictionarySetValue(v72, @"address", v75);
  CFDictionarySetValue(v72, @"semantic", v74);
  CFArrayAppendValue(v45, v72);
  CFRelease(v74);
  CFRelease(v72);
  CFRelease(v75);
  CFRelease(v73);
  int v76 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFNumberRef v77 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFNumberRef v78 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 448;
  CFNumberRef v79 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v80 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v81 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v78, @"name", @"dofIntensity");
  CFDictionarySetValue(v78, @"type", v79);
  CFDictionarySetValue(v78, @"address", v81);
  CFDictionarySetValue(v78, @"semantic", v80);
  CFArrayAppendValue(v45, v78);
  CFRelease(v80);
  CFRelease(v78);
  CFRelease(v81);
  CFRelease(v79);
  CFNumberRef v82 = CFDictionaryCreateMutable(0, 4, v76, v77);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = a1 + 528;
  CFNumberRef v83 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v84 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v85 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v82, @"name", @"categoryBitMask");
  CFDictionarySetValue(v82, @"type", v83);
  CFDictionarySetValue(v82, @"address", v85);
  CFDictionarySetValue(v82, @"semantic", v84);
  CFArrayAppendValue(v45, v82);
  CFRelease(v84);
  CFRelease(v82);
  CFRelease(v85);
  CFRelease(v83);
  long long v86 = CFDictionaryCreateMutable(0, 4, v76, v77);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 384;
  CFNumberRef v87 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v88 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v89 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v86, @"name", @"whitePoint");
  CFDictionarySetValue(v86, @"type", v87);
  CFDictionarySetValue(v86, @"address", v89);
  CFDictionarySetValue(v86, @"semantic", v88);
  CFArrayAppendValue(v45, v86);
  CFRelease(v88);
  CFRelease(v86);
  CFRelease(v89);
  CFRelease(v87);
  CFNumberRef v90 = CFDictionaryCreateMutable(0, 4, v76, v77);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 388;
  CFNumberRef v91 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v92 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v93 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v90, @"name", @"averageGray");
  CFDictionarySetValue(v90, @"type", v91);
  CFDictionarySetValue(v90, @"address", v93);
  CFDictionarySetValue(v90, @"semantic", v92);
  CFArrayAppendValue(v45, v90);
  CFRelease(v92);
  CFRelease(v90);
  CFRelease(v93);
  CFRelease(v91);
  CFNumberRef v94 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v77);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 396;
  CFNumberRef v95 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v96 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v97 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v94, @"name", @"exposureAdaptationDuration");
  CFDictionarySetValue(v94, @"type", v95);
  CFDictionarySetValue(v94, @"address", v97);
  CFDictionarySetValue(v94, @"semantic", v96);
  CFArrayAppendValue(v45, v94);
  CFRelease(v96);
  CFRelease(v94);
  CFRelease(v97);
  CFRelease(v95);
  CFNumberRef v98 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  float32x4_t v99 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v100 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 404;
  CFNumberRef v101 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v102 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v103 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v100, @"name", @"exposureAdaptationDarkeningSpeedFactor");
  CFDictionarySetValue(v100, @"type", v101);
  CFDictionarySetValue(v100, @"address", v103);
  CFDictionarySetValue(v100, @"semantic", v102);
  CFArrayAppendValue(v45, v100);
  CFRelease(v102);
  CFRelease(v100);
  CFRelease(v103);
  CFRelease(v101);
  float32x4_t v104 = CFDictionaryCreateMutable(0, 4, v98, v99);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 400;
  CFNumberRef v105 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v106 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v107 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v104, @"name", @"exposureAdaptationBrighteningSpeedFactor");
  CFDictionarySetValue(v104, @"type", v105);
  CFDictionarySetValue(v104, @"address", v107);
  CFDictionarySetValue(v104, @"semantic", v106);
  CFArrayAppendValue(v45, v104);
  CFRelease(v106);
  CFRelease(v104);
  CFRelease(v107);
  CFRelease(v105);
  char v108 = CFDictionaryCreateMutable(0, 4, v98, v99);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 416;
  CFNumberRef v109 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v110 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v111 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v108, @"name", @"minimumExposure");
  CFDictionarySetValue(v108, @"type", v109);
  CFDictionarySetValue(v108, @"address", v111);
  CFDictionarySetValue(v108, @"semantic", v110);
  double v112 = v45;
  CFArrayAppendValue(v45, v108);
  CFRelease(v110);
  CFRelease(v108);
  CFRelease(v111);
  CFRelease(v109);
  double v113 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  float v114 = CFDictionaryCreateMutable(0, 4, v98, MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 420;
  CFNumberRef v115 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v116 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v117 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v114, @"name", @"maximumExposure");
  CFDictionarySetValue(v114, @"type", v115);
  CFDictionarySetValue(v114, @"address", v117);
  CFDictionarySetValue(v114, @"semantic", v116);
  CFArrayAppendValue(v112, v114);
  CFRelease(v116);
  CFRelease(v114);
  CFRelease(v117);
  CFRelease(v115);
  double v118 = CFDictionaryCreateMutable(0, 4, v98, v113);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 424;
  CFNumberRef v119 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v120 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v121 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v118, @"name", @"bloomIntensity");
  CFDictionarySetValue(v118, @"type", v119);
  CFDictionarySetValue(v118, @"address", v121);
  CFDictionarySetValue(v118, @"semantic", v120);
  CFArrayAppendValue(v112, v118);
  CFRelease(v120);
  CFRelease(v118);
  CFRelease(v121);
  CFRelease(v119);
  float v122 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v113);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 428;
  CFNumberRef v123 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v124 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v125 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v122, @"name", @"bloomThreshold");
  CFDictionarySetValue(v122, @"type", v123);
  CFDictionarySetValue(v122, @"address", v125);
  CFDictionarySetValue(v122, @"semantic", v124);
  char v126 = v112;
  CFArrayAppendValue(v112, v122);
  CFRelease(v124);
  CFRelease(v122);
  CFRelease(v125);
  CFRelease(v123);
  uint64_t v127 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v128 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  unsigned int v129 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = a1 + 432;
  CFNumberRef v130 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v131 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v132 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v129, @"name", @"bloomIteration");
  CFDictionarySetValue(v129, @"type", v130);
  CFDictionarySetValue(v129, @"address", v132);
  CFDictionarySetValue(v129, @"semantic", v131);
  CFArrayAppendValue(v126, v129);
  CFRelease(v131);
  CFRelease(v129);
  CFRelease(v132);
  CFRelease(v130);
  unsigned int v133 = v127;
  unint64_t v134 = v128;
  int v135 = CFDictionaryCreateMutable(0, 4, v133, v128);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v136 = a1;
  uint64_t v180 = a1 + 436;
  CFNumberRef v137 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v138 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v139 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v135, @"name", @"bloomIterationSpread");
  CFDictionarySetValue(v135, @"type", v137);
  CFDictionarySetValue(v135, @"address", v139);
  CFDictionarySetValue(v135, @"semantic", v138);
  CFArrayAppendValue(v126, v135);
  CFRelease(v138);
  CFRelease(v135);
  CFRelease(v139);
  CFRelease(v137);
  unsigned int v140 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v134);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = a1 + 472;
  CFNumberRef v141 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v142 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v143 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v140, @"name", @"motionBlurIntensity");
  CFDictionarySetValue(v140, @"type", v141);
  CFDictionarySetValue(v140, @"address", v143);
  CFDictionarySetValue(v140, @"semantic", v142);
  float v144 = v126;
  CFArrayAppendValue(v126, v140);
  CFRelease(v142);
  CFRelease(v140);
  CFRelease(v143);
  CFRelease(v141);
  BOOL v145 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  BOOL v146 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  BOOL v147 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = v136 + 492;
  CFNumberRef v148 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v149 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v150 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v147, @"name", @"screenSpaceAmbientOcclusionIntensity");
  CFDictionarySetValue(v147, @"type", v148);
  CFDictionarySetValue(v147, @"address", v150);
  CFDictionarySetValue(v147, @"semantic", v149);
  CFArrayAppendValue(v144, v147);
  CFRelease(v149);
  CFRelease(v147);
  CFRelease(v150);
  CFRelease(v148);
  BOOL v151 = CFDictionaryCreateMutable(0, 4, v145, v146);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = v136 + 496;
  CFNumberRef v152 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v153 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v154 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v151, @"name", @"screenSpaceAmbientOcclusionRadius");
  CFDictionarySetValue(v151, @"type", v152);
  CFDictionarySetValue(v151, @"address", v154);
  CFDictionarySetValue(v151, @"semantic", v153);
  unsigned int v155 = v144;
  CFArrayAppendValue(v144, v151);
  CFRelease(v153);
  CFRelease(v151);
  CFRelease(v154);
  CFRelease(v152);
  v156 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  v157 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = v136 + 500;
  CFNumberRef v158 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v159 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v160 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v157, @"name", @"screenSpaceAmbientOcclusionBias");
  CFDictionarySetValue(v157, @"type", v158);
  CFDictionarySetValue(v157, @"address", v160);
  CFDictionarySetValue(v157, @"semantic", v159);
  CFArrayAppendValue(v144, v157);
  CFRelease(v159);
  CFRelease(v157);
  CFRelease(v160);
  CFRelease(v158);
  uint64_t v161 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v156);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = v136 + 504;
  CFNumberRef v162 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v163 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v164 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v161, @"name", @"screenSpaceAmbientOcclusionDepthThreshold");
  CFDictionarySetValue(v161, @"type", v162);
  CFDictionarySetValue(v161, @"address", v164);
  CFDictionarySetValue(v161, @"semantic", v163);
  CFArrayAppendValue(v144, v161);
  CFRelease(v163);
  CFRelease(v161);
  CFRelease(v164);
  CFRelease(v162);
  v165 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  v166 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 1;
  uint64_t v180 = v136 + 508;
  CFNumberRef v167 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v168 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v169 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v166, @"name", @"screenSpaceAmbientOcclusionNormalThreshold");
  CFDictionarySetValue(v166, @"type", v167);
  CFDictionarySetValue(v166, @"address", v169);
  CFDictionarySetValue(v166, @"semantic", v168);
  CFArrayAppendValue(v144, v166);
  CFRelease(v168);
  CFRelease(v166);
  CFRelease(v169);
  CFRelease(v167);
  v170 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  v171 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v165);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = v136 + 512;
  CFNumberRef v172 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v173 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v174 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v171, @"name", @"screenSpaceAmbientOcclusionSampleCount");
  CFDictionarySetValue(v171, @"type", v172);
  CFDictionarySetValue(v171, @"address", v174);
  CFDictionarySetValue(v171, @"semantic", v173);
  CFArrayAppendValue(v155, v171);
  CFRelease(v173);
  CFRelease(v171);
  CFRelease(v174);
  CFRelease(v172);
  v175 = CFDictionaryCreateMutable(0, 4, v170, MEMORY[0x263EFFF90]);
  int v181 = 0;
  int valuePtr = 2;
  uint64_t v180 = v136 + 516;
  CFNumberRef v176 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v177 = CFNumberCreate(0, kCFNumberSInt32Type, &v181);
  CFNumberRef v178 = CFNumberCreate(0, kCFNumberLongType, &v180);
  CFDictionarySetValue(v175, @"name", @"screenSpaceAmbientOcclusionDownSample");
  CFDictionarySetValue(v175, @"type", v176);
  CFDictionarySetValue(v175, @"address", v178);
  CFDictionarySetValue(v175, @"semantic", v177);
  CFArrayAppendValue(v155, v175);
  CFRelease(v177);
  CFRelease(v175);
  CFRelease(v178);
  CFRelease(v176);
  return v155;
}

uint64_t _C3DCameraSearchByID(uint64_t a1, const void *a2)
{
  ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void C3DNodeUpdateCullingSystemMembership(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1) {
    __UpdateCullingHandle(a1, v1);
  }
}

float32x4_t C3DTransformBoundingBox(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5)
{
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  float32x4_t v6 = vmulq_f32(vaddq_f32(*a1, *a2), v5);
  float32x4_t v7 = vmulq_f32(vsubq_f32(*a2, *a1), v5);
  float32x4_t v8 = v7;
  v8.i32[3] = 0;
  float32x4_t v9 = a5[1];
  float32x4_t v10 = a5[2];
  float32x4_t v11 = vaddq_f32(a5[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v9, *(float32x2_t *)v6.f32, 1), *a5, v6.f32[0]), v10, v6, 2));
  v11.i32[3] = 1.0;
  float32x4_t v12 = (float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), (int32x4_t)v8);
  float32x4_t v13 = (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v8, (int32x4_t)v8), (int32x4_t)v8);
  v8.i32[1] = v7.i32[0];
  v8.i32[2] = v7.i32[0];
  float32x4_t v14 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(*a5, v8)), vabsq_f32(vmulq_f32(v9, v12))), vabsq_f32(vmulq_f32(v10, v13)));
  *a3 = vsubq_f32(v11, v14);
  float32x4_t result = vaddq_f32(v11, v14);
  *a4 = result;
  return result;
}

uint64_t C3DNodeIsBoundingBoxFixed(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 220) >> 2) & 1;
}

void C3DNodeSetBoundingBox(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a1 + 220);
  if (a3 != 2 || (v5 & 4) == 0)
  {
    if (a2)
    {
      long long v6 = a2[1];
      *(_OWORD *)(a1 + 272) = *a2;
      *(_OWORD *)(a1 + 288) = v6;
    }
    else
    {
      __C3DComputeLocalBoundingBox(a1);
      unsigned int v5 = *(_DWORD *)(a1 + 220);
    }
    if (a3 != 2)
    {
      unsigned int v5 = v5 & 0xFFFFFFFB | (4 * (a3 == 1));
      *(_DWORD *)(a1 + 220) = v5;
    }
    if ((v5 & 4) != 0) {
      *(_DWORD *)(a1 + 220) = v5 & 0xFFFFFFFC;
    }
    C3DNodeBoundingBoxDidUpdate(a1);
  }
}

BOOL C3DNodeGetBoundingBoxOmittingFloor(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (C3DNodeIsHidden(a1)) {
    return 0;
  }
  uint64_t v19 = 0;
  CFNumberRef v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 0;
  uint64_t Floor = C3DNodeGetFloor(a1);
  LOBYTE(v8) = 0;
  if (!Floor)
  {
    long long v9 = *(_OWORD *)(a1 + 288);
    *a2 = *(_OWORD *)(a1 + 272);
    a2[1] = v9;
    unsigned int v8 = vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) >> 31;
  }
  char v22 = v8;
  uint64_t v10 = *(void *)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = 0;
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    float32x4_t v14 = __C3DNodeGetBoundingBoxOmittingFloor_block_invoke;
    CFNumberRef v15 = &unk_264007DD0;
    CFNumberRef v16 = &v19;
    uint64_t v17 = a3;
    CFNumberRef v18 = a2;
    do
    {
      ((void (*)(void *, uint64_t, uint64_t))v14)(v13, v10, v11++);
      uint64_t v10 = *(void *)(v10 + 80);
    }
    while (v10);
  }
  BOOL v6 = *((unsigned char *)v20 + 24) != 0;
  _Block_object_dispose(&v19, 8);
  return v6;
}

BOOL C3DNodeHasChildren(uint64_t a1)
{
  return *(void *)(a1 + 72) != 0;
}

void __C3DNodeGetBoundingBoxOmittingFloor_block_invoke(void *a1, uint64_t a2)
{
  float32x4_t v25 = 0u;
  int32x4_t v26 = 0u;
  uint64_t Floor = C3DNodeGetFloor(a2);
  unsigned int v5 = (unsigned char *)a1[5];
  if (Floor)
  {
    if (v5) {
      *unsigned int v5 = 1;
    }
  }
  else if (C3DNodeGetBoundingBoxOmittingFloor(a2, &v25, v5))
  {
    float32x4_t v23 = 0u;
    float32x4_t v24 = 0u;
    float32x4_t v21 = 0u;
    float32x4_t v22 = 0u;
    C3DNodeGetMatrix(a2, (uint64_t)&v21);
    float32x4_t v6 = vaddq_f32(v24, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v22, *(float32x2_t *)v25.f32, 1), v21, v25.f32[0]), v23, v25, 2));
    float32x4_t v7 = v6;
    v7.i32[3] = 1.0;
    float32x4_t v8 = (float32x4_t)v26;
    v8.i32[1] = v26.i32[0];
    v8.i32[2] = v26.i32[0];
    float32x4_t v9 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v21, v8)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), v26), v22))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32(v26, v26), v26), v23)));
    float32x4_t v25 = v7;
    int32x4_t v26 = (int32x4_t)v9;
    uint64_t v10 = *(void *)(a1[4] + 8);
    if (*(unsigned char *)(v10 + 24))
    {
      uint64_t v11 = (float32x4_t *)a1[6];
      float32x4_t v12 = v11[1];
      float32x4_t v13 = vsubq_f32(*v11, v12);
      float32x4_t v14 = vsubq_f32(v6, v9);
      v13.i32[3] = 0;
      v14.i32[3] = 0;
      float32x4_t v15 = vminnmq_f32(v13, v14);
      float32x4_t v16 = vaddq_f32(*v11, v12);
      float32x4_t v17 = vaddq_f32(v6, v9);
      v16.i32[3] = 0;
      v17.i32[3] = 0;
      float32x4_t v18 = vmaxnmq_f32(v16, v17);
      v16.i64[0] = 0x3F0000003F000000;
      v16.i64[1] = 0x3F0000003F000000;
      float32x4_t v19 = vmulq_f32(vaddq_f32(v15, v18), v16);
      float32x4_t v20 = vmulq_f32(vsubq_f32(v18, v15), v16);
      v19.i32[3] = 1.0;
      v20.i32[3] = 0;
      float32x4_t *v11 = v19;
    }
    else
    {
      *(unsigned char *)(v10 + 24) = 1;
      uint64_t v11 = (float32x4_t *)a1[6];
      float32x4_t v20 = (float32x4_t)v26;
      float32x4_t *v11 = v25;
    }
    v11[1] = v20;
  }
}

uint64_t __computeSubBox(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2 = a1[18];
  *a2 = a1[17];
  a2[1] = v2;
  unsigned int v3 = vminvq_u32((uint32x4_t)vcgezq_f32(a1[18])) >> 31;
  for (uint64_t i = a1[4].i64[1]; i; uint64_t i = *(void *)(i + 80))
  {
    float32x4_t v22 = 0u;
    float32x4_t v23 = 0u;
    if (__computeSubBox(i, &v22))
    {
      C3DNodeGetMatrix(i, (uint64_t)&v18);
      float32x4_t v6 = vaddq_f32(v21, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v19, *(float32x2_t *)v22.f32, 1), v18, v22.f32[0]), v20, v22, 2));
      float32x4_t v7 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_n_f32(v18, v23.f32[0])), vabsq_f32(vmulq_lane_f32(v19, *(float32x2_t *)v23.f32, 1))), vabsq_f32(vmulq_laneq_f32(v20, v23, 2)));
      float32x4_t v8 = a2[1];
      float32x4_t v9 = vsubq_f32(v6, v7);
      float32x4_t v10 = vsubq_f32(*a2, v8);
      v9.i32[3] = 0;
      v10.i32[3] = 0;
      float32x4_t v11 = vminnmq_f32(v9, v10);
      float32x4_t v12 = vaddq_f32(v6, v7);
      float32x4_t v13 = vaddq_f32(*a2, v8);
      v12.i32[3] = 0;
      v13.i32[3] = 0;
      float32x4_t v14 = vmaxnmq_f32(v12, v13);
      v8.i64[0] = 0x3F0000003F000000;
      v8.i64[1] = 0x3F0000003F000000;
      float32x4_t v15 = vmulq_f32(vaddq_f32(v11, v14), v8);
      v15.i32[3] = 1.0;
      float32x4_t v16 = vmulq_f32(vsubq_f32(v14, v11), v8);
      v16.i32[3] = 0;
      *a2 = v15;
      a2[1] = v16;
      LOBYTE(v3) = 1;
    }
  }
  return v3 & 1;
}

uint64_t C3DNodeComputeHierarchicalBoundingBox(float32x4_t *a1, int a2, float32x4_t *a3)
{
  if ((a1[13].i16[7] & 0x380) == 0 && (uint64_t v13 = a1[3].i64[0]) != 0 && (CullingSystem = C3DSceneGetCullingSystem(v13)) != 0)
  {
    *(__n128 *)a3 = C3DCullingSystemComputeHierarchicalAABB(CullingSystem, a1, a2);
    a3[1] = v15;
    return vminvq_u32((uint32x4_t)vcgezq_f32(v15)) >> 31;
  }
  else
  {
    uint64_t result = __computeSubBox(a1, a3);
    if (result)
    {
      if ((a2 & 1) == 0)
      {
        WorldMatrix = C3DNodeGetWorldMatrix(a1);
        float32x4_t v8 = WorldMatrix[1];
        float32x4_t v9 = WorldMatrix[2];
        float32x4_t v10 = vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v8, *(float32x2_t *)a3->f32, 1), *WorldMatrix, COERCE_FLOAT(*a3)), v9, *a3, 2));
        v10.i32[3] = 1.0;
        float32x4_t v11 = a3[1];
        v11.i32[1] = v11.i32[0];
        v11.i32[2] = (__int32)a3[1];
        float32x4_t v12 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(*WorldMatrix, v11)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)a3[1].f32, 1), (int32x4_t)a3[1]), v8))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)a3[1], (int32x4_t)a3[1]), (int32x4_t)a3[1]), v9)));
        *a3 = v10;
        a3[1] = v12;
        return 1;
      }
    }
  }
  return result;
}

uint64_t C3DNodeCopyNode(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DNodeCreate();
  long long v11 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v10 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v10 + 112) = v11;
  long long v12 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 128);
  long long v13 = *(_OWORD *)(a1 + 144);
  *(_OWORD *)(v10 + 160) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v10 + 176) = v12;
  *(_OWORD *)(v10 + 128) = v14;
  *(_OWORD *)(v10 + 144) = v13;
  if (C3DNodeGetHasPivot(a1))
  {
    PivotMatrix = (long long *)C3DNodeGetPivotMatrix(a1);
    C3DNodeSetPivotMatrix((float32x4_t *)v10, PivotMatrix);
  }
  float Opacity = C3DNodeGetOpacity(a1);
  C3DNodeSetOpacity(v10, Opacity);
  IsHiddeint n = C3DNodeIsHidden(a1);
  C3DNodeSetHidden(v10, IsHidden);
  float32x4_t v18 = *(__C3DGeometry **)(a1 + 240);
  if (v18) {
    C3DNodeSetGeometry(v10, v18);
  }
  C3DEntityCopyTo(a1, (CFTypeRef *)v10);
  unsigned int v19 = *(_DWORD *)(v10 + 220) & 0xFFFFFBFF | (((*(_DWORD *)(a1 + 220) >> 10) & 1) << 10);
  *(_DWORD *)(v10 + 220) = v19;
  unsigned int v20 = v19 & 0xFFFEFFFF | ((HIWORD(*(_DWORD *)(a1 + 220)) & 1) << 16);
  *(_DWORD *)(v10 + 220) = v20;
  unsigned int v21 = v20 & 0xFFFFBFFF | (((*(_DWORD *)(a1 + 220) >> 14) & 1) << 14);
  *(_DWORD *)(v10 + 220) = v21;
  unsigned int v22 = v21 & 0xFFFFEFFF | (((*(_DWORD *)(a1 + 220) >> 12) & 1) << 12);
  *(_DWORD *)(v10 + 220) = v22;
  unsigned int v23 = v22 & 0xFFFFFDFF | (((*(_DWORD *)(a1 + 220) >> 9) & 1) << 9);
  *(_DWORD *)(v10 + 220) = v23;
  CFDataRef Copy = *(void **)(a1 + 248);
  if (Copy)
  {
    CFDataRef Copy = (void *)C3DDeformerStackCreateCopy(Copy, v10);
    unsigned int v23 = *(_DWORD *)(v10 + 220);
  }
  *(void *)(v10 + 248) = Copy;
  unsigned int v25 = v23 & 0xFFFFDFFF | (((*(_DWORD *)(a1 + 220) >> 13) & 1) << 13);
  *(_DWORD *)(v10 + 220) = v25;
  unsigned int v26 = v25 & 0xFFFFF7FF | (((*(_DWORD *)(a1 + 220) >> 11) & 1) << 11);
  *(_DWORD *)(v10 + 220) = v26;
  long long v27 = *(_OWORD *)(a1 + 288);
  *(_OWORD *)(v10 + 272) = *(_OWORD *)(a1 + 272);
  *(_OWORD *)(v10 + 288) = v27;
  unsigned int v28 = v26 & 0xFFFFFFFB | (4 * ((*(_DWORD *)(a1 + 220) >> 2) & 1));
  *(_DWORD *)(v10 + 220) = v28;
  *(void *)(v10 + 208) = *(void *)(a1 + 208);
  *(_DWORD *)(v10 + 220) = v28 & 0xFFBFFFFF | (((*(_DWORD *)(a1 + 220) >> 22) & 1) << 22);
  return v10;
}

void C3DNodeSetPivotMatrix(float32x4_t *a1, long long *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  long long v12 = (_OWORD *)a1[12].i64[0];
  if (!v12)
  {
    long long v12 = C3DMalloc(0x80uLL);
    a1[12].i64[0] = (uint64_t)v12;
  }
  long long v13 = *a2;
  long long v14 = a2[1];
  long long v15 = a2[3];
  v12[2] = a2[2];
  v12[3] = v15;
  _OWORD *v12 = v13;
  v12[1] = v14;
  uint64_t v16 = a1[12].i64[0];
  if (v16) {
    *(_DWORD *)(v16 + 124) = 0;
  }
  __C3DNodeTransformDidChange(a1);
}

uint64_t C3DNodeGetPivotMatrix(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 192);
}

void C3DNodeSetHidden(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 200) != a2)
  {
    *(unsigned char *)(a1 + 200) = a2;
    __UpdateNodeVisibilityIfNeeded(a1, a2 ^ 1);
  }
}

uint64_t C3DNodeCreateCopy(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = C3DNodeCopyNode(a1);
  uint64_t v13 = v12;
  if (a2)
  {
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 0x40000000;
    float32x4_t v18 = __C3DNodeCreateCopy_block_invoke;
    unsigned int v19 = &__block_descriptor_tmp_8_1;
    char v21 = a2;
    uint64_t v20 = v12;
    uint64_t v14 = *(void *)(a1 + 72);
    if (v14)
    {
      uint64_t v15 = 0;
      do
      {
        ((void (*)(void *, uint64_t, uint64_t))v18)(v17, v14, v15++);
        uint64_t v14 = *(void *)(v14 + 80);
      }
      while (v14);
    }
  }
  return v13;
}

void __C3DNodeCreateCopy_block_invoke(uint64_t a1, uint64_t a2)
{
  CFDataRef Copy = (float32x4_t *)C3DNodeCreateCopy(a2, *(unsigned __int8 *)(a1 + 40));
  C3DNodeAddChildNode(*(void *)(a1 + 32), Copy);

  CFRelease(Copy);
}

uint64_t C3DNodeAddChildNode(uint64_t a1, float32x4_t *cf)
{
  if (cf)
  {
    uint64_t v4 = *(void *)(a1 + 72);
    if (!v4)
    {
      *(void *)(a1 + 72) = CFRetain(cf);
      return __FixupParent(a1, cf);
    }
    goto LABEL_7;
  }
  uint64_t v5 = scn_default_log();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddChildNode_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  }
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4)
  {
    do
    {
LABEL_7:
      uint64_t v13 = v4;
      uint64_t v4 = *(void *)(v4 + 80);
    }
    while (v4);
    if (cf) {
      *(void *)(v13 + 80) = CFRetain(cf);
    }
  }
  return __FixupParent(a1, cf);
}

__C3DGeometry *__createSubdividedGeometryCopy(const void *a1, const void *a2, unsigned __int8 a3)
{
  uint64_t Copy = C3DGeometryCreateCopy(a1);
  uint64_t v6 = (__C3DGeometry *)Copy;
  if (a2)
  {
    uint64_t Mesh = C3DGeometryGetMesh(Copy);
    C3DMeshSetMeshElements(Mesh, a2);
  }
  int SubdivisionSettings = C3DGeometryOsdGetSubdivisionSettings((uint64_t)v6);
  C3DGeometryOsdSetSubdivisionSettings((uint64_t)v6, SubdivisionSettings & 0xFFFFFF00);
  C3DGeometryOsdSetSubdivisionLevel(v6, a3);
  CPUSubdividedC3Duint64_t Mesh = (void *)C3DGeometryOsdGetCPUSubdividedC3DMesh((uint64_t)v6);
  CFRetain(CPUSubdividedC3DMesh);
  C3DGeometryOsdSetSubdivisionLevel(v6, 0);
  C3DGeometrySetMesh((uint64_t)v6, (uint64_t *)CPUSubdividedC3DMesh);
  CFRelease(CPUSubdividedC3DMesh);
  return v6;
}

CFTypeRef *C3DNodeCreateSubdividedCopy(uint64_t a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DNodeCreateSubdividedCopy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t Copy = (CFTypeRef *)C3DNodeCreateCopy(a1, 0);
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)Copy);
  if (Geometry)
  {
    uint64_t v14 = (const void *)Geometry;
    uint64_t Morpher = C3DNodeGetMorpher(a1);
    SubdividedGeometryuint64_t Copy = __createSubdividedGeometryCopy(v14, 0, v2);
    C3DNodeSetGeometry((uint64_t)Copy, SubdividedGeometryCopy);
    CFRelease(SubdividedGeometryCopy);
    if (Morpher)
    {
      CFNumberRef v49 = Copy;
      float32x4_t v17 = C3DMorpherCreateCopy(Morpher);
      C3DMorpherSetBaseGeometry((uint64_t)v17, SubdividedGeometryCopy);
      CFNumberRef v47 = (uint64_t *)v17;
      uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)v17);
      if (C3DMorphIsUsingSparseTargets(OverrideMaterial)) {
        C3DMorphConvertToSparse(OverrideMaterial, (uint64_t)v14, 0, 0);
      }
      uint64_t v48 = Morpher;
      if (C3DMorphGetCalculationMode(OverrideMaterial)) {
        C3DMorphConvertToCalculationMode(OverrideMaterial, (uint64_t)v14, 0, 0);
      }
      uint64_t Mesh = C3DGeometryGetMesh((uint64_t)v14);
      CFArrayRef MeshElements = (const void *)C3DMeshGetMeshElements(Mesh, 0);
      CFArrayRef v21 = (const __CFArray *)C3DGeometryGetOverrideMaterial(OverrideMaterial);
      uint64_t Count = CFArrayGetCount(v21);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], Count, MEMORY[0x263EFFF70]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtuint64_t Index = CFArrayGetValueAtIndex(v21, i);
          unsigned int v26 = __createSubdividedGeometryCopy(ValueAtIndex, MeshElements, v2);
          CFArrayAppendValue(Mutable, v26);
          CFRelease(v26);
        }
      }
      C3DMorphSetTargets(OverrideMaterial, Mutable, 0);
      uint64_t Copy = v49;
      C3DNodeSetMorpher(v49, v47);
      CFRelease(v47);
      uint64_t Morpher = v48;
    }
    uint64_t v27 = *(void *)(a1 + 248);
    if (v27)
    {
      uint64_t Skinner = C3DDeformerStackGetSkinner(v27);
      if (Skinner)
      {
        uint64_t v29 = Skinner;
        uint64_t v30 = C3DGeometryGetOverrideMaterial(Skinner);
        uint64_t v31 = C3DGeometryGetMesh((uint64_t)v14);
        CFNumberRef v32 = (uint64_t *)C3DMeshCreateCopy(v31);
        CFNumberRef v33 = (__C3DGeometry *)C3DGeometryCreate();
        C3DGeometrySetMesh((uint64_t)v33, v32);
        if (v32) {
          CFRelease(v32);
        }
        if (Morpher)
        {
          int SubdivisionSettings = C3DGeometryOsdGetSubdivisionSettings((uint64_t)v33);
          C3DGeometryOsdSetSubdivisionSettings((uint64_t)v33, SubdivisionSettings & 0xFFFFFF00);
        }
        C3DGeometryOsdSetSubdivisionLevel(v33, v2);
        CPUSubdividedC3Duint64_t Mesh = C3DGeometryOsdGetCPUSubdividedC3DMesh((uint64_t)v33);
        CFArrayRef Joints = (const __CFArray *)C3DSkinnerGetJoints(v29);
        CFArrayRef v37 = Joints;
        if (Joints) {
          LOWORD(Joints) = CFArrayGetCount(Joints);
        }
        CFNumberRef v38 = (void *)C3DSkinCreateWithSkinnableMesh((uint64_t)CPUSubdividedC3DMesh, (__int16)Joints);
        CFRelease(v33);
        if (v38)
        {
          DefaultShapeMatrix = (long long *)C3DSkinGetDefaultShapeMatrix(v30);
          long long v40 = *DefaultShapeMatrix;
          long long v41 = DefaultShapeMatrix[1];
          long long v42 = DefaultShapeMatrix[3];
          v50[2] = DefaultShapeMatrix[2];
          v50[3] = v42;
          v50[0] = v40;
          v50[1] = v41;
          C3DSkinSetDefaultShapeMatrix((uint64_t)v38, v50);
          InverseBindMatricesPtr = (void *)C3DSkinGetInverseBindMatricesPtr(v30);
          C3DSkinCopyInverseBindMatricesPtr((uint64_t)v38, InverseBindMatricesPtr);
          CFNumberRef v44 = (uint64_t *)C3DSkinnerCreateWithSkin(v38);
          CFRelease(v38);
          if (v37)
          {
            CFArrayRef v45 = CFArrayCreateCopy(0, v37);
            C3DSkinnerSetJoints((uint64_t)v44, v45);
            CFRelease(v45);
          }
          C3DNodeSetSkinner(Copy, v44);
          CFRelease(v44);
        }
      }
    }
  }
  return Copy;
}

void C3DNodeSetMorpher(CFTypeRef *a1, uint64_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t Morpher = C3DNodeGetMorpher((uint64_t)a1);
  if ((uint64_t *)Morpher != a2)
  {
    uint64_t v13 = (void *)Morpher;
    if (Morpher)
    {
      uint64_t v14 = C3DGetSceneRef((uint64_t)a1);
      C3DRemoveSceneRef(v13, v14);
    }
    if (a2)
    {
      uint64_t v15 = (uint64_t)a1[6];
      if (v15) {
        C3DAddSceneRef(a2, v15);
      }
      float32x4_t v17 = a1 + 31;
      uint64_t v16 = a1[31];
      if (!v16)
      {
        uint64_t v16 = (void *)C3DDeformerStackCreate((uint64_t)a1);
        a1[31] = v16;
        if (!v16) {
          goto LABEL_17;
        }
      }
    }
    else
    {
      float32x4_t v17 = a1 + 31;
      uint64_t v16 = a1[31];
      if (!v16)
      {
LABEL_17:
        if (C3DGetSceneRef((uint64_t)a1))
        {
          Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
          C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
        }
        C3DNodeGeometryDidUpdate((uint64_t *)a1);
        return;
      }
    }
    C3DDeformerStackSetMorpher((uint64_t)v16, a2);
    if (C3DDeformerStackIsEmpty(v16) && *v17)
    {
      CFRelease(*v17);
      CFTypeRef *v17 = 0;
    }
    goto LABEL_17;
  }
}

void C3DNodeSetSkinner(void *a1, uint64_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = a1[31];
  if (!v12)
  {
    if (!a2) {
      return;
    }
LABEL_12:
    uint64_t v17 = a1[6];
    if (v17) {
      C3DAddSceneRef(a2, v17);
    }
    C3DSkinnerSetOwnerNode((uint64_t)a2, (uint64_t)a1);
    uint64_t v16 = (void *)a1[31];
    if (!v16)
    {
      uint64_t v16 = (void *)C3DDeformerStackCreate((uint64_t)a1);
      a1[31] = v16;
      if (!v16) {
        goto LABEL_19;
      }
    }
    goto LABEL_16;
  }
  uint64_t Skinner = C3DDeformerStackGetSkinner(v12);
  if ((uint64_t *)Skinner == a2) {
    return;
  }
  uint64_t v14 = (void *)Skinner;
  if (Skinner)
  {
    uint64_t v15 = C3DGetSceneRef((uint64_t)a1);
    C3DRemoveSceneRef(v14, v15);
    C3DSkinnerSetOwnerNode((uint64_t)v14, 0);
  }
  if (a2) {
    goto LABEL_12;
  }
  uint64_t v16 = (void *)a1[31];
  if (v16)
  {
LABEL_16:
    C3DDeformerStackSetSkinner(v16, a2);
    if (C3DDeformerStackIsEmpty(v16))
    {
      float32x4_t v18 = (const void *)a1[31];
      if (v18)
      {
        CFRelease(v18);
        a1[31] = 0;
      }
    }
  }
LABEL_19:
  if (C3DGetSceneRef((uint64_t)a1))
  {
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
  }
  C3DNodeGeometryDidUpdate(a1);
}

uint64_t C3DNodeGetChildNodesCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (!v1) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    uint64_t result = (result + 1);
    uint64_t v1 = *(void *)(v1 + 80);
  }
  while (v1);
  return result;
}

BOOL C3DNodeApplyChildrenInterruptible(uint64_t a1, uint64_t a2)
{
  char v7 = 0;
  uint64_t v2 = *(void *)(a1 + 72);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  do
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(a2 + 16))(a2, v2, v4++, &v7);
    uint64_t v2 = *(void *)(v2 + 80);
    BOOL result = v7 != 0;
    if (v7) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v2 == 0;
    }
  }
  while (!v6);
  return result;
}

uint64_t C3DNodeGetName(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetName(a1);
}

uint64_t C3DNodeApplyHierarchySkippingHiddenNodes(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = result;
    do
    {
LABEL_3:
      uint64_t v5 = (void *)v4;
      if (*(unsigned char *)(v4 + 200)) {
        break;
      }
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v4);
      if (v6 == 2) {
        return 1;
      }
      uint64_t v4 = v5[9];
    }
    while (v6 != 1 && v4 != 0);
    while (v5 != v3)
    {
      uint64_t v4 = v5[10];
      if (v4) {
        goto LABEL_3;
      }
      uint64_t v5 = (void *)v5[8];
    }
    return 0;
  }
  return result;
}

uint64_t C3DNodeGetChildNodeAtIndex(uint64_t a1, unsigned int a2)
{
  uint64_t result = *(void *)(a1 + 72);
  if (a2 && result)
  {
    unsigned int v3 = 1;
    do
    {
      uint64_t result = *(void *)(result + 80);
      if (v3 >= a2) {
        break;
      }
      ++v3;
    }
    while (result);
  }
  return result;
}

uint64_t C3DNodeInsertChildNodeAtIndex(uint64_t a1, float32x4_t *cf, int a3)
{
  if (cf[5].i64[0])
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DNodeInsertChildNodeAtIndex_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (cf[4].i64[0])
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      C3DNodeInsertChildNodeAtIndex_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
      if (a3) {
        goto LABEL_7;
      }
LABEL_11:
      cf[5].i64[0] = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = cf;
      CFRetain(cf);
      return __FixupParent(a1, cf);
    }
  }
  if (!a3) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v22 = *(void *)(a1 + 72);
  uint64_t v23 = (a3 - 1);
  if (a3 != 1)
  {
    do
    {
      uint64_t v22 = *(void *)(v22 + 80);
      --v23;
    }
    while (v23);
  }
  uint64_t v24 = *(void *)(v22 + 80);
  *(void *)(v22 + 80) = cf;
  CFRetain(cf);
  cf[5].i64[0] = v24;
  return __FixupParent(a1, cf);
}

void C3DNodeRemoveFromParentNode(void *cf)
{
  *(void *)&v15[5] = *MEMORY[0x263EF8340];
  uint64_t v1 = cf[8];
  if (v1)
  {
    unsigned int v3 = *(void **)(v1 + 72);
    if (v3 == cf)
    {
      *(void *)(v1 + 72) = cf[10];
    }
    else
    {
      if (!v3)
      {
        uint64_t v4 = scn_default_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
          C3DNodeRemoveFromParentNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
        }
      }
      for (CFIndex i = (void *)v3[10]; i != cf; CFIndex i = (void *)v3[10])
      {
        unsigned int v3 = i;
        if (!i)
        {
          uint64_t v13 = scn_default_log();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
            C3DNodeRemoveFromParentNode_cold_1(v14, v15, v13);
          }
        }
      }
      v3[10] = cf[10];
    }
    cf[10] = 0;
    cf[8] = 0;
    C3DRemoveSceneRef(cf, cf[6]);
    CFRelease(cf);
  }
}

uint64_t C3DNodeGetIndexOfChildNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 == 0;
  unsigned int v5 = 0;
  while (!v3 && v2 != a2)
  {
    ++v5;
    uint64_t v2 = *(void *)(v2 + 80);
    BOOL v3 = v2 == 0;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

double C3DNodeGetWorldPosition(float32x4_t *a1, __n128 *a2)
{
  if (!a1 && (BOOL v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeGetWorldPosition_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix(a1);
  *(void *)&double result = C3DMatrix4x4GetTranslation(WorldMatrix, a2).n128_u64[0];
  return result;
}

void C3DNodeGetWorldOrientation(float32x4_t *a1, _OWORD *a2)
{
  if (!a1 && (BOOL v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeGetWorldOrientation_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  WorldMatrix = C3DNodeGetWorldMatrix(a1);
  float32x4_t v21 = *WorldMatrix;
  float32x4_t v22 = WorldMatrix[1];
  float32x4_t v23 = WorldMatrix[3];
  v25[2] = WorldMatrix[2];
  v25[3] = v23;
  v25[0] = v21;
  v25[1] = v22;
  *(double *)&long long v24 = C3DMatrix4x4GetRotation(v25);
  *a2 = v24;
}

double C3DNodeGetPosition(__n128 *a1)
{
  *(void *)&double result = C3DTransformGetPosition(a1 + 6).n128_u64[0];
  return result;
}

double C3DNodeGetScale(__n128 *a1)
{
  *(void *)&double result = C3DTransformGetScale(a1 + 6).n128_u64[0];
  return result;
}

void C3DNodeGetQuaternion(uint64_t a1)
{
}

void C3DNodeGetAxisAngle(float32x4_t *a1)
{
}

void C3DNodeSetAxisAngle(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetAxisAngle((uint64_t)&a1[6], a2);

  __C3DNodeTransformDidChange(a1);
}

double C3DNodeGetEuler(float32x4_t *a1)
{
  *(void *)&double result = C3DTransformGetEuler(a1 + 6).n128_u64[0];
  return result;
}

void C3DNodeSetEuler(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetEuler((uint64_t)&a1[6], a2);

  __C3DNodeTransformDidChange(a1);
}

uint64_t C3DNodeGetTransform(uint64_t a1)
{
  return a1 + 96;
}

void C3DNodeSetMatrix(float32x4_t *a1, uint64_t a2)
{
  C3DTransformSetMatrix((uint64_t)&a1[6], a2);

  __C3DNodeTransformDidChange(a1);
}

double C3DNodeGetLocalNoPivotMatrix@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!a1)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)&double result = C3DTransformGetMatrix(a1 + 96, a2).n128_u64[0];
  return result;
}

double C3DNodeGetPivotPosition(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  v12.n128_u32[2] = 0;
  v12.n128_u64[0] = 0;
  uint64_t v10 = *(__n128 **)(a1 + 192);
  if (!v10) {
    return 0.0;
  }
  C3DMatrix4x4GetTranslation(v10, &v12);
  return v12.n128_f64[0];
}

void C3DNodeSetPivotPosition(float32x4_t *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v14 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v14;
    if (v4)
    {
      C3DGeometryTrackNode_cold_2(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v14;
    }
  }
  __n128 v12 = (__n128 *)a1[12].i64[0];
  if (v12)
  {
    C3DMatrix4x4SetTranslation(v12, a2);
  }
  else
  {
    memset(v15, 0, sizeof(v15));
    C3DMatrix4x4SetTranslation(v15, a2);
    C3DNodeSetPivotMatrix(a1, (long long *)v15);
  }
  uint64_t v13 = a1[12].i64[0];
  if (v13) {
    *(_DWORD *)(v13 + 124) = 0;
  }
  __C3DNodeTransformDidChange(a1);
}

__n128 C3DNodeComputeWorldTransform(float32x4_t *a1, uint64_t a2)
{
  if (!a2)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DNodeComputeWorldMatrix_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a1[5].i32[2] == -1)
  {
    WorldMatrix = C3DNodeGetWorldMatrix(a1);
    __n128 result = (__n128)WorldMatrix[2];
    float32x4_t v23 = WorldMatrix[3];
    float32x4_t v25 = *WorldMatrix;
    float32x4_t v24 = WorldMatrix[1];
    *(__n128 *)(a2 + 32) = result;
    *(float32x4_t *)(a2 + 48) = v23;
    *(float32x4_t *)a2 = v25;
    *(float32x4_t *)(a2 + 16) = v24;
  }
  else
  {
    C3DNodeGetMatrix((uint64_t)a1, (uint64_t)&v34);
    long long v13 = v34;
    __n128 result = v35;
    long long v14 = v36;
    long long v15 = v37;
    uint64_t v16 = a1[4].i64[0];
    if (v16)
    {
      float32x4_t v32 = 0u;
      float32x4_t v33 = 0u;
      float32x4_t v30 = 0u;
      float32x4_t v31 = 0u;
      long long v26 = v34;
      __n128 v27 = v35;
      long long v28 = v36;
      long long v29 = v37;
      C3DNodeComputeWorldTransform(v16, &v30);
      uint64_t v17 = 0;
      float32x4_t v18 = v30;
      float32x4_t v19 = v31;
      float32x4_t v20 = v32;
      float32x4_t v21 = v33;
      v38[0] = v26;
      v38[1] = v27;
      v38[2] = v28;
      _OWORD v38[3] = v29;
      long long v39 = 0u;
      __n128 v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      do
      {
        *(long long *)((char *)&v39 + v17 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v18, COERCE_FLOAT(v38[v17])), v19, *(float32x2_t *)&v38[v17], 1), v20, (float32x4_t)v38[v17], 2), v21, (float32x4_t)v38[v17], 3);
        ++v17;
      }
      while (v17 != 4);
      long long v13 = v39;
      __n128 result = v40;
      long long v14 = v41;
      long long v15 = v42;
    }
    *(_OWORD *)a2 = v13;
    *(__n128 *)(a2 + 16) = result;
    *(_OWORD *)(a2 + 32) = v14;
    *(_OWORD *)(a2 + 48) = v15;
  }
  return result;
}

uint64_t C3DNodeGetID(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DEntityGetID(a1);
}

uint64_t C3DNodeGetNodeWithName(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  __n128 v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeGetNodeWithName_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t v23 = 0;
  float32x4_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v26 = 0;
  v22[0] = MEMORY[0x263EF8330];
  v22[1] = 0x40000000;
  v22[2] = __C3DNodeGetNodeWithName_block_invoke;
  v22[3] = &unk_264007E38;
  v22[4] = &v23;
  v22[5] = a2;
  C3DNodeApplyHierarchy(a1, (uint64_t)v22);
  uint64_t v20 = v24[3];
  _Block_object_dispose(&v23, 8);
  return v20;
}

uint64_t __C3DNodeGetNodeWithName_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = C3DNodeGetName(a2);
  if (result)
  {
    if (CFEqual((CFTypeRef)result, *(CFTypeRef *)(a1 + 40)))
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
      return 2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t __C3DNodeCopyNodesWithAttribute_block_invoke(uint64_t a1, const void *a2)
{
  if (C3DNodeGetGeometry((uint64_t)a2) && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2), *(unsigned char *)(a1 + 40))) {
    return 2;
  }
  else {
    return 0;
  }
}

uint64_t __C3DNodeCopyNodesWithAttribute_block_invoke_2(uint64_t a1, const void *a2)
{
  if (C3DNodeGetDeformerStack((uint64_t)a2)
    && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2), *(unsigned char *)(a1 + 40)))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

__CFArray *C3DNodeCopyChildNodesPassingTest(const void *a1, uint64_t a2, int a3)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  _C3DNodeCopyChildNodesPassingTest(a1, a2, a3, Mutable);
  return Mutable;
}

BOOL _C3DNodeCopyChildNodesPassingTest(const void *a1, uint64_t a2, int a3, __CFArray *a4)
{
  unsigned __int8 v13 = 1;
  if ((*(unsigned int (**)(uint64_t, const void *, unsigned __int8 *))(a2 + 16))(a2, a1, &v13)) {
    CFArrayAppendValue(a4, a1);
  }
  int v8 = v13;
  if (v13) {
    BOOL v9 = a3 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    v11[2] = ___C3DNodeCopyChildNodesPassingTest_block_invoke;
    void v11[3] = &unk_264007F30;
    char v12 = a3;
    v11[4] = a2;
    v11[5] = a4;
    C3DNodeApplyChildrenInterruptible((uint64_t)a1, (uint64_t)v11);
    int v8 = v13;
  }
  return v8 != 0;
}

CFStringRef C3DNodeSetName(uint64_t a1, CFStringRef theString)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntitySetName(a1, theString);
}

CFTypeRef C3DNodeSetID(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3DEntitySetID(a1, cf);
}

BOOL C3DNodeIsAncestor(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  char v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeIsAncestor_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  do
LABEL_6:
    uint64_t v3 = *(void *)(v3 + 64);
  while (v3 != a2 && v3 != 0);
  return v3 != 0;
}

void *C3DNodeFindCommonAncestor(CFArrayRef theArray)
{
  if (!theArray)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DNodeFindCommonAncestor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    return 0;
  }
  uint64_t v11 = Count;
  ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, 0);
  if (v11 >= 2)
  {
    for (CFIndex i = 1; i != v11; ++i)
    {
      uint64_t v14 = CFArrayGetValueAtIndex(theArray, i);
      if (!ValueAtIndex) {
        break;
      }
      while (!v14)
      {
LABEL_12:
        ValueAtuint64_t Index = (void *)ValueAtIndex[8];
        if (!ValueAtIndex) {
          return ValueAtIndex;
        }
      }
      uint64_t v15 = v14;
      while (v15 != ValueAtIndex)
      {
        uint64_t v15 = (void *)v15[8];
        if (!v15) {
          goto LABEL_12;
        }
      }
    }
  }
  return ValueAtIndex;
}

void C3DNodeSetRenderingOrder(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DNodeGetRenderingOrder(a1) != a2)
  {
    if (a2)
    {
      CFDictionaryRef valuePtr = a2;
      CFDictionaryRef v12 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
      C3DEntitySetAttribute((CFTypeRef *)a1, @"kRenderingPriorityKey", v12);
      CFRelease(v12);
    }
    else
    {
      C3DEntitySetAttribute((CFTypeRef *)a1, @"kRenderingPriorityKey", 0);
    }
    C3DScenePostPipelineEvent(*(void *)(a1 + 48), 5, (const void *)a1, 0);
  }
}

void C3DNodeSetCastsShadow(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  int v12 = *(_DWORD *)(a1 + 220);
  if (((((v12 & 0x200000) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      int v13 = 0x200000;
    }
    else {
      int v13 = 0;
    }
    *(_DWORD *)(a1 + 220) = v12 & 0xFFDFFFFF | v13;
    C3DScenePostPipelineEvent(*(void *)(a1 + 48), 5, (const void *)a1, 0);
    __UpdateCullingSystemFlags(a1, 0);
  }
}

void C3DNodeSetUsesDepthPrePass(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  int v12 = *(_DWORD *)(a1 + 220);
  if (((((v12 & 0x4000000) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      int v13 = 0x4000000;
    }
    else {
      int v13 = 0;
    }
    *(_DWORD *)(a1 + 220) = v12 & 0xFBFFFFFF | v13;
    uint64_t v14 = *(void *)(a1 + 48);
    C3DScenePostPipelineEvent(v14, 8, (const void *)a1, 0);
    C3DScenePostPipelineEvent(v14, 5, (const void *)a1, 0);
    __UpdateCullingSystemFlags(a1, 0);
  }
}

__C3DCullingSystem *C3DNodeSetCategoryBitMask(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 208) = a2;
  return __UpdateCullingSystemFlags(a1, 0);
}

void C3DNodeSetMovability(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned int v12 = *(_DWORD *)(a1 + 220);
  if (((v12 >> 22) & 1) != a2)
  {
    *(_DWORD *)(a1 + 220) = v12 & 0xFFBFFFFF | ((a2 & 1) << 22);
    __UpdateCullingSystemFlags(a1, 0);
  }
}

uint64_t C3DNodeGetHittable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 220) >> 3) & 1;
}

uint64_t C3DNodeSetHittable(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 8;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFFFFF7 | v2;
  return result;
}

uint64_t C3DNodeSetIsJoint(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 256;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFFFEFF | v2;
  return result;
}

uint64_t C3DNodeHasLight(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 221) >> 1) & 1;
}

void C3DNodeSetLight(float32x4_t *a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned int v12 = (const void *)a1[3].i64[0];
  if (v12)
  {
    CFDictionaryRef Light = C3DNodeGetLight((uint64_t)a1);
    if (Light)
    {
      C3DRemoveSceneRef(Light, a1[3].i64[0]);
      LightingSysteuint64_t m = C3DSceneGetLightingSystem((uint64_t)v12);
      C3DLightingSystemRemove(LightingSystem, a1);
    }
  }
  BOOL v15 = C3DGetSceneRef((uint64_t)a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, @"kLightKey", a2, v15);
  if (a2)
  {
    uint64_t v16 = a1[3].i64[0];
    if (v16) {
      C3DAddSceneRef((uint64_t *)a2, v16);
    }
  }
  a1[13].i32[3] = a1[13].i32[3] & 0xFFFFFDFF | ((a2 != 0) << 9);
  if (a2 && v12)
  {
    uint64_t v17 = C3DSceneGetLightingSystem((uint64_t)v12);
    C3DLightingSystemAdd(v17, a1);
    C3DLightingSystemLightDidUpdate(v17, a2);
  }
  else if (!a2)
  {
    return;
  }
  if (C3DLightTypeSupportsShadow((uint64_t)a2))
  {
    if (C3DLightGetCastsShadow((uint64_t)a2))
    {
      Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v12, 0, 1u);
    }
  }
}

void C3DNodeSetPostMorphingDeformers(void *a1, const __CFArray *cf)
{
  uint64_t v4 = (void *)a1[31];
  if (cf && !v4)
  {
    uint64_t v4 = (void *)C3DDeformerStackCreate((uint64_t)a1);
    a1[31] = v4;
  }
  if (v4)
  {
    C3DDeformerStackSetPostMorphingDeformers(v4, cf);
    if (C3DDeformerStackIsEmpty(v4))
    {
      uint64_t v5 = (const void *)a1[31];
      if (v5)
      {
        CFRelease(v5);
        a1[31] = 0;
      }
    }
    if (a1[6])
    {
      Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
    }
  }
}

void C3DNodeSetPostSkinningDeformers(void *a1, const __CFArray *cf)
{
  uint64_t v4 = (void *)a1[31];
  if (cf && !v4)
  {
    uint64_t v4 = (void *)C3DDeformerStackCreate((uint64_t)a1);
    a1[31] = v4;
  }
  if (v4)
  {
    C3DDeformerStackSetPostSkinningDeformers(v4, cf);
    if (C3DDeformerStackIsEmpty(v4))
    {
      uint64_t v5 = (const void *)a1[31];
      if (v5)
      {
        CFRelease(v5);
        a1[31] = 0;
      }
    }
    if (a1[6])
    {
      Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
    }
  }
}

void C3DNodeSetLightmapInfo(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL v12 = C3DGetSceneRef(a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, @"kLightmapInfoKey", a2, v12);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFF7FF | ((a2 != 0) << 11);
}

void C3DNodeSetRendererDelegate(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3 = a1;
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL v12 = C3DGetSceneRef(v3) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)v3, @"rendererDelegate", a2, v12);
  if ((a2 != 0) == ((*(_DWORD *)(v3 + 220) & 0x2000) == 0))
  {
    *(_DWORD *)(v3 + 220) = *(_DWORD *)(v3 + 220) & 0xFFFFDFFF | ((a2 != 0) << 13);
    __UpdateCullingSystemFlags(v3, 0);
    do
    {
      *(_DWORD *)(v3 + 220) |= 2u;
      uint64_t v3 = *(void *)(v3 + 64);
    }
    while (v3);
  }
}

CFIndex C3DNodeGetCountOfParticleSystems(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 222) & 4) == 0) {
    return 0;
  }
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kParticleSystem");
  return CFArrayGetCount(Attribute);
}

void C3DNodeAddParticleSystem(uint64_t a1, void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  BOOL v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CountOfCFArrayRef ParticleSystems = C3DNodeGetCountOfParticleSystems(a1);
  C3DNodeInsertParticleSystemAtIndex(a1, a2, CountOfParticleSystems);
}

void C3DNodeInsertParticleSystemAtIndex(uint64_t a1, void *a2, CFIndex a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDictionaryRef Attribute = C3DEntityGetAttribute(a1, @"kParticleSystem");
  if (!Attribute)
  {
    CFDictionaryRef Attribute = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    C3DEntitySetAttribute((CFTypeRef *)a1, @"kParticleSystem", Attribute);
    CFRelease(Attribute);
  }
  CFArrayInsertValueAtIndex(Attribute, a3, a2);
  *(_DWORD *)(a1 + 220) |= 0x40000u;
  uint64_t v23 = *(void *)(a1 + 48);
  if (v23)
  {
    ParticleManager = C3DSceneGetParticleManager(*(void *)(a1 + 48), 1);
    if (ParticleManager) {
      C3DParticleManagerAddSystem((uint64_t)ParticleManager, (float32x4_t *)a1, a2, 0);
    }
    C3DAddSceneRef((uint64_t *)a2, v23);
  }
}

void C3DNodeRemoveAllParticleSystems(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void *)(a1 + 48);
  if (v10) {
    ParticleManager = C3DSceneGetParticleManager(v10, 1);
  }
  else {
    ParticleManager = 0;
  }
  if (C3DGetSceneRef(a1))
  {
    CFArrayRef ParticleSystems = C3DNodeGetParticleSystems(a1);
    if (ParticleSystems)
    {
      CFArrayRef v13 = ParticleSystems;
      CFIndex Count = CFArrayGetCount(ParticleSystems);
      if (Count >= 1)
      {
        CFIndex v15 = Count;
        for (CFIndex i = 0; i != v15; ++i)
        {
          ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(v13, i);
          uint64_t v18 = C3DGetSceneRef(a1);
          C3DRemoveSceneRef(ValueAtIndex, v18);
        }
      }
    }
  }
  C3DEntitySetAttribute((CFTypeRef *)a1, @"kParticleSystem", 0);
  if (ParticleManager) {
    C3DParticleManagerRemoveAllInstanceOfSystemsOnNode((uint64_t)ParticleManager, a1);
  }
  *(_DWORD *)(a1 + 220) &= ~0x40000u;
}

void C3DNodeRemoveParticleSystem(uint64_t a1, const void *a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kParticleSystem");
  if (Attribute)
  {
    CFArrayRef v23 = Attribute;
    v25.length = CFArrayGetCount(Attribute);
    v25.locatioint n = 0;
    FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v23, v25, a2);
    C3DNodeRemoveParticleSystemAtIndex(a1, FirstIndexOfValue, a3);
  }
}

void C3DNodeRemoveParticleSystemAtIndex(uint64_t a1, CFIndex a2, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kParticleSystem");
  if (Attribute)
  {
    CFArrayRef v15 = Attribute;
    if (a2 < 0 || CFArrayGetCount(Attribute) <= a2)
    {
      ValueAtuint64_t Index = 0;
    }
    else
    {
      ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(v15, a2);
      CFArrayRemoveValueAtIndex(v15, a2);
    }
    if (CFArrayGetCount(v15)) {
      *(_DWORD *)(a1 + 220) &= ~0x40000u;
    }
    if (ValueAtIndex)
    {
      uint64_t v17 = C3DGetSceneRef(a1);
      C3DRemoveSceneRef(ValueAtIndex, v17);
      if (a3)
      {
        uint64_t v18 = *(void *)(a1 + 48);
        if (v18)
        {
          ParticleManager = C3DSceneGetParticleManager(v18, 0);
          if (ParticleManager) {
            C3DParticleManagerRemoveSystem((uint64_t)ParticleManager, a1, (uint64_t)ValueAtIndex);
          }
        }
      }
    }
  }
}

void C3DNodeReplaceParticleSystemAtIndex(uint64_t a1, void *cf, CFIndex a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (cf) {
      goto LABEL_4;
    }
  }
  else if (cf)
  {
LABEL_4:
    CFRetain(cf);
    C3DNodeRemoveParticleSystemAtIndex(a1, a3, 1);
    C3DNodeInsertParticleSystemAtIndex(a1, cf, a3);
    CFRelease(cf);
    return;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  C3DNodeRemoveParticleSystemAtIndex(a1, a3, 1);
  C3DNodeInsertParticleSystemAtIndex(a1, 0, a3);
}

CFIndex C3DNodeGetCountOfAudioPlayers(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 222) & 8) == 0) {
    return 0;
  }
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kAudioPlayer");
  return CFArrayGetCount(Attribute);
}

uint64_t C3DNodeAddAudioPlayer(uint64_t a1, void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddAudioPlayer_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFIndex CountOfAudioPlayers = C3DNodeGetCountOfAudioPlayers(a1);
  C3DNodeInsertAudioPlayerAtIndex(a1, a2, CountOfAudioPlayers);
  uint64_t result = C3DNodeIsHiddenOrIsHiddenByAncestor(a1);
  if ((result & 1) == 0) {
    return C3DAudioPlayerPlay(a2);
  }
  return result;
}

uint64_t C3DNodeInsertAudioPlayerAtIndex(uint64_t a1, void *a2, CFIndex a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddAudioPlayer_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDictionaryRef Attribute = C3DEntityGetAttribute(a1, @"kAudioPlayer");
  if (!Attribute)
  {
    CFDictionaryRef Attribute = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    C3DEntitySetAttribute((CFTypeRef *)a1, @"kAudioPlayer", Attribute);
    CFRelease(Attribute);
  }
  CFArrayInsertValueAtIndex(Attribute, a3, a2);
  *(_DWORD *)(a1 + 220) |= 0x80000u;
  WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix((float32x4_t *)a1);
  C3DAudioPlayerSetTransform(a2, WorldMatrix);
  return C3DAudioManagerAddVoice(a2);
}

void C3DNodeRemoveAllAudioPlayers(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kAudioPlayer");
  if (Attribute)
  {
    CFIndex Count = CFArrayGetCount(Attribute);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      do
      {
        C3DNodeRemoveAudioPlayerAtIndex(a1, 0, 1);
        --v12;
      }
      while (v12);
    }
    C3DEntitySetAttribute((CFTypeRef *)a1, @"kAudioPlayer", 0);
  }
  *(_DWORD *)(a1 + 220) &= ~0x80000u;
}

void C3DNodeRemoveAudioPlayerAtIndex(uint64_t a1, CFIndex a2, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kAudioPlayer");
  if (Attribute)
  {
    uint64_t v15 = Attribute;
    ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(Attribute, a2);
    uint64_t v17 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
    CFArrayRemoveValueAtIndex(v15, a2);
    if (CFArrayGetCount(v15)) {
      *(_DWORD *)(a1 + 220) &= ~0x80000u;
    }
    if (a3) {
      C3DAudioManagerRemoveVoice(v17);
    }
    SCNAudioPlayerWasRemovedFromNode((uint64_t)v17);
    if (v17) {
      CFRelease(v17);
    }
  }
}

void C3DNodeRemoveAudioPlayer(uint64_t a1, const void *a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFArrayRef Attribute = C3DEntityGetAttribute(a1, @"kAudioPlayer");
  if (Attribute)
  {
    CFArrayRef v23 = Attribute;
    v25.length = CFArrayGetCount(Attribute);
    v25.locatioint n = 0;
    FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v23, v25, a2);
    if (FirstIndexOfValue != -1) {
      C3DNodeRemoveAudioPlayerAtIndex(a1, FirstIndexOfValue, a3);
    }
  }
}

void C3DNodeReplaceAudioPlayerAtIndex(float32x4_t *a1, void *cf, CFIndex a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (cf) {
      goto LABEL_4;
    }
  }
  else if (cf)
  {
LABEL_4:
    CFRetain(cf);
    C3DNodeRemoveAudioPlayerAtIndex((uint64_t)a1, a3, 1);
    C3DNodeInsertAudioPlayerAtIndex((uint64_t)a1, cf, a3);
    WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix(a1);
    C3DAudioPlayerSetTransform(cf, WorldMatrix);
    CFRelease(cf);
    return;
  }
  uint64_t v15 = scn_default_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
    C3DNodeAddParticleSystem_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
  }
  C3DNodeRemoveAudioPlayerAtIndex((uint64_t)a1, a3, 1);
  C3DNodeInsertAudioPlayerAtIndex((uint64_t)a1, 0, a3);
  CFArrayRef v23 = (__n128 *)C3DNodeGetWorldMatrix(a1);
  C3DAudioPlayerSetTransform(0, v23);
}

uint64_t C3DNodeHasConstraints(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 222) & 1;
}

void C3DNodeSetConstraints(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DGetSceneRef(a1))
  {
    CFArrayRef Constraints = C3DNodeGetConstraints(a1);
    if (Constraints)
    {
      CFArrayRef v13 = Constraints;
      CFIndex Count = CFArrayGetCount(Constraints);
      if (Count >= 1)
      {
        CFIndex v15 = Count;
        for (CFIndex i = 0; i != v15; ++i)
        {
          ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(v13, i);
          uint64_t v18 = C3DGetSceneRef(a1);
          C3DRemoveSceneRef(ValueAtIndex, v18);
        }
      }
    }
  }
  BOOL v19 = C3DGetSceneRef(a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, @"kConstraints", a2, v19);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFEFFFF | ((a2 != 0) << 16);
  uint64_t v20 = *(void *)(a1 + 48);
  if (v20)
  {
    C3DSceneRegisterNodeConstrains(*(void *)(a1 + 48), (float32x4_t *)a1);
    if (a2)
    {
      CFIndex v21 = CFArrayGetCount(a2);
      if (v21 >= 1)
      {
        CFIndex v22 = v21;
        for (CFIndex j = 0; j != v22; ++j)
        {
          float32x4_t v24 = (uint64_t *)CFArrayGetValueAtIndex(a2, j);
          C3DAddSceneRef(v24, v20);
        }
      }
    }
  }
}

void C3DNodeSetHasPhysicsBody(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    int v12 = 64;
  }
  else {
    int v12 = 0;
  }
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFFBF | v12;
}

uint64_t C3DNodeGetHasPhysicsBody(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 220) >> 6) & 1;
}

void C3DNodeSetHasPhysicsField(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    int v12 = 0x100000;
  }
  else {
    int v12 = 0;
  }
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFEFFFFF | v12;
}

uint64_t C3DNodeGetHasPhysicsField(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 222) >> 4) & 1;
}

void C3DNodeSetFilters(uint64_t a1, CFArrayRef theArray)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (theArray) {
      goto LABEL_4;
    }
  }
  else if (theArray)
  {
LABEL_4:
    int v12 = (CFArrayGetCount(theArray) > 0) << 14;
    goto LABEL_7;
  }
  int v12 = 0;
LABEL_7:
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFBFFF | v12;
  long long v17 = kC3DCIFilterParamControllerCallbacks;
  uint64_t v18 = off_26B466268;
  CFDictionaryRef v13 = (const __CFDictionary *)C3DAnimatableParamControllerCreate(theArray, &v17);
  BOOL v14 = C3DGetSceneRef(a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, @"kFilterKey", v13, v14);
  CFRelease(v13);
  __PropagateFlagsToChildren(a1, (*(_DWORD *)(a1 + 220) >> 14) & 1, (*(_DWORD *)(a1 + 220) >> 23) & 7);
  uint64_t v15 = *(void *)(a1 + 48);
  if (v15)
  {
    C3DSceneRegisterNodeFilters(*(CFTypeRef **)(a1 + 48), (const void *)a1);
    __UpdateCullingHandle(a1, v15);
    uint64_t EnginePipeline = C3DSceneGetEnginePipeline(v15);
    C3DEnginePipelineRemoveNodeFromRendering(EnginePipeline, a1);
    __UpdateNodeVisibilityIfNeeded(a1, 1);
  }
}

CFDictionaryRef C3DNodeGetFiltersParamController(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if ((*(unsigned char *)(a1 + 221) & 0x40) != 0) {
    return C3DEntityGetAttribute(a1, @"kFilterKey");
  }
  else {
    return 0;
  }
}

uint64_t C3DNodeGetRendererElementSpan(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 224);
}

void C3DNodeSetLayerIndex(uint64_t a1, int a2)
{
  char v2 = a2;
  if (a2 >= 4)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DNodeSetLayerIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFC7FFFFF | ((v2 & 7) << 23);
}

id _C3DNodeCFFinalize(uint64_t a1)
{
  uint64_t Geometry = C3DNodeGetGeometry(a1);
  if (Geometry) {
    C3DGeometryUntrackNode(Geometry, (const void *)a1);
  }
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationNodeWillDie", (const void *)a1, 0, 1u);
  uint64_t v4 = *(void **)(a1 + 192);
  if (v4) {
    free(v4);
  }
  if ((*(unsigned char *)(a1 + 222) & 8) != 0) {
    C3DNodeRemoveAllAudioPlayers(a1);
  }
  uint64_t v5 = *(void **)(a1 + 72);
  if (v5)
  {
    do
    {
      uint64_t v6 = v5[8];
      if (v6 == a1)
      {
        v5[8] = 0;
      }
      else if (v6)
      {
        uint64_t v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          _C3DNodeCFFinalize_cold_1(&v14, v15, v7);
        }
      }
      uint64_t v8 = (void *)v5[10];
      v5[10] = 0;
      CFRelease(v5);
      uint64_t v5 = v8;
    }
    while (v8);
  }
  uint64_t v9 = *(const void **)(a1 + 80);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 240);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 248);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 248) = 0;
  }
  int v12 = *(void **)(a1 + 232);
  if (v12) {
    free(v12);
  }
  return C3DEntityCFFinalize(a1);
}

__CFString *_C3DNodeCFCopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t Name = C3DNodeGetName(a1);
  CFStringAppendFormat(Mutable, 0, @"<C3DNode:%p \"%@\"\n", a1, Name);
  uint64_t Geometry = C3DNodeGetGeometry(a1);
  CFStringAppendFormat(Mutable, 0, @"  geometry: %@\n", Geometry);
  int v5 = *(_DWORD *)(a1 + 220);
  if ((v5 & 0x200) != 0)
  {
    CFDictionaryRef Light = C3DNodeGetLight(a1);
    CFStringAppendFormat(Mutable, 0, @"  light: %@\n", Light);
    int v5 = *(_DWORD *)(a1 + 220);
  }
  if ((v5 & 0x400) != 0)
  {
    CFDictionaryRef Camera = C3DNodeGetCamera(a1);
    CFStringAppendFormat(Mutable, 0, @"  camera: %@\n", Camera);
  }
  uint64_t v8 = *(void *)(a1 + 248);
  if (v8)
  {
    uint64_t Skinner = C3DDeformerStackGetSkinner(v8);
    if (Skinner) {
      CFStringAppendFormat(Mutable, 0, @"  skinner: %@\n", Skinner);
    }
  }
  uint64_t Morpher = C3DNodeGetMorpher(a1);
  if (Morpher) {
    CFStringAppendFormat(Mutable, 0, @"  morpher: %@\n", Morpher);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

BOOL _C3DNodeInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  __int16 valuePtr = 0;
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if ((C3DEntityInitWithPropertyList(a1, a2) & 1) == 0)
  {
    __n128 v35 = scn_default_log();
    BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DNodeInitWithPropertyList_cold_9(v35, v37, v38, v39, v40, v41, v42, v43);
    return 0;
  }
  CFDictionaryRef Attributes = (const __CFDictionary *)C3DEntityGetAttributes(a1);
  if (Attributes)
  {
    CFDictionaryRef v25 = Attributes;
    CFIndex Count = CFDictionaryGetCount(Attributes);
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, Count, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    float32x4_t context = (float32x4_t)(unint64_t)Mutable;
    CFDictionaryApplyFunction(v25, (CFDictionaryApplierFunction)_fillPatchedDictionay, &context);
    if (context.i64[1])
    {
      if (!Mutable) {
        goto LABEL_12;
      }
      C3DEntitySetAttributes(a1, Mutable);
      C3DEntityGetAttributes(a1);
    }
    CFRelease(Mutable);
LABEL_12:
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"attributes");
    if (Value)
    {
      CFDictionaryRef v29 = Value;
      float32x4_t v30 = CFDictionaryGetValue(Value, @"kSkinnerKey");
      if (v30)
      {
        uint64_t v31 = (uint64_t)v30;
        C3DSkinnerCreate();
        float32x4_t v33 = v32;
        int v34 = C3DInitWithPropertyList(v32, v31, a3, (uint64_t)a4);
        if (v34) {
          C3DNodeSetSkinner((void *)a1, v33);
        }
        CFRelease(v33);
      }
      else
      {
        int v34 = 1;
      }
      CFNumberRef v44 = CFDictionaryGetValue(v29, @"kMorpherKey");
      if (v44)
      {
        uint64_t v45 = (uint64_t)v44;
        CFNumberRef v46 = (const void *)C3DMorphCreate();
        CFNumberRef v47 = (uint64_t *)C3DMorpherCreateWith(v46);
        CFRelease(v46);
        if ((v34 & C3DInitWithPropertyList(v47, v45, a3, (uint64_t)a4)) == 1) {
          C3DNodeSetMorpher((CFTypeRef *)a1, v47);
        }
        CFRelease(v47);
      }
    }
  }
  CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(a2, @"hidden");
  if (v48)
  {
    CFNumberGetValue(v48, kCFNumberShortType, &valuePtr);
    *(unsigned char *)(a1 + 200) = valuePtr != 0;
  }
  CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(a2, @"alpha");
  if (v49) {
    CFNumberGetValue(v49, kCFNumberFloatType, (void *)(a1 + 204));
  }
  CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(a2, @"category");
  if (v50) {
    CFNumberGetValue(v50, kCFNumberNSIntegerType, (void *)(a1 + 208));
  }
  CFBooleanRef v51 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"isJoint");
  if (v51) {
    unsigned int v52 = *(_DWORD *)(a1 + 220) & 0xFFFFFEFF | ((CFBooleanGetValue(v51) & 1) << 8);
  }
  else {
    unsigned int v52 = *(_DWORD *)(a1 + 220) & 0xFFFFFEFF;
  }
  *(_DWORD *)(a1 + 220) = v52;
  CFDictionaryRef v53 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"transforms");
  if (!v53) {
    goto LABEL_40;
  }
  CFDictionaryRef v54 = v53;
  v95.n128_u32[2] = 0;
  v95.n128_u64[0] = 0;
  __n128 v94 = 0uLL;
  float32x4_t v99 = 0u;
  float32x4_t v100 = 0u;
  float32x4_t context = 0u;
  float32x4_t v98 = 0u;
  simd_float4x4 v55 = CFDictionaryGetValue(v53, @"matrix4x4");
  if (!v55)
  {
    CFNumberRef v57 = CFDictionaryGetValue(v54, @"position");
    if (v57 && C3DVector3InitWithPropertyList((uint64_t)&v95, (uint64_t)v57, a3, (uint64_t)a4))
    {
      C3DTransformSetPosition((__n128 *)(a1 + 96), v95);
      char v58 = 1;
    }
    else
    {
      char v58 = 0;
    }
    CFNumberRef v66 = CFDictionaryGetValue(v54, @"scale");
    if (v66 && C3DVector3InitWithPropertyList((uint64_t)&v95, (uint64_t)v66, a3, (uint64_t)a4)) {
      C3DTransformSetScale(a1 + 96, v95);
    }
    else {
      char v58 = 0;
    }
    CFDictionaryRef v67 = (const __CFDictionary *)CFDictionaryGetValue(v54, @"rotation");
    if (!v67) {
      goto LABEL_67;
    }
    CFDictionaryRef v68 = v67;
    CFNumberRef v69 = CFDictionaryGetValue(v67, @"quaternion");
    if (v69)
    {
      if ((C3DVector3InitWithPropertyList((uint64_t)&v94, (uint64_t)v69, a3, (uint64_t)a4) & 1) == 0)
      {
        CFNumberRef v73 = scn_default_log();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
          _C3DNodeInitWithPropertyList_cold_7();
        }
        return 0;
      }
      uint64_t v70 = a1 + 96;
      __n128 v71 = v94;
    }
    else
    {
      __n128 v72 = CFDictionaryGetValue(v68, @"euler");
      if (v72)
      {
        if ((C3DVector3InitWithPropertyList((uint64_t)&v95, (uint64_t)v72, a3, (uint64_t)a4) & 1) == 0)
        {
          CFNumberRef v82 = scn_default_log();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
            _C3DNodeInitWithPropertyList_cold_6();
          }
          return 0;
        }
        C3DTransformSetEuler(a1 + 96, v95);
        goto LABEL_66;
      }
      CFNumberRef v74 = CFDictionaryGetValue(v68, @"axisAngle");
      if (v74)
      {
        if ((C3DVector3InitWithPropertyList((uint64_t)&v94, (uint64_t)v74, a3, (uint64_t)a4) & 1) == 0)
        {
          CFNumberRef v84 = scn_default_log();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
            _C3DNodeInitWithPropertyList_cold_5();
          }
          return 0;
        }
        C3DTransformSetAxisAngle(a1 + 96, v94);
        goto LABEL_66;
      }
      CFNumberRef v83 = CFDictionaryGetValue(v68, @"matrix4x4");
      if (!v83)
      {
        CFNumberRef v85 = scn_default_log();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
          _C3DNodeInitWithPropertyList_cold_2((uint64_t)a2, v85, v86, v87, v88, v89, v90, v91);
        }
        return 0;
      }
      if ((C3DMatrix4x4InitWithPropertyList((uint64_t)&context, (uint64_t)v83, a3, (uint64_t)a4) & 1) == 0)
      {
        CFNumberRef v92 = scn_default_log();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
          _C3DNodeInitWithPropertyList_cold_4();
        }
        return 0;
      }
      v93[0] = context;
      v93[1] = v98;
      v93[2] = v99;
      v93[3] = v100;
      v71.n128_f64[0] = C3DMatrix4x4GetRotation(v93);
      __n128 v94 = v71;
      uint64_t v70 = a1 + 96;
    }
    C3DTransformSetQuaternion(v70, v71);
LABEL_66:
    if (v58)
    {
LABEL_37:
      if (CFDictionaryGetValue(v54, @"pivot"))
      {
        CFNumberRef v56 = scn_default_log();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          _C3DNodeInitWithPropertyList_cold_3();
        }
      }
LABEL_40:
      __C3DNodeTransformDidChange((float32x4_t *)a1);
      return 1;
    }
LABEL_67:
    CFNumberRef v75 = scn_default_log();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      _C3DNodeInitWithPropertyList_cold_1((uint64_t)a2, v75, v76, v77, v78, v79, v80, v81);
      if (!a4) {
        return 0;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*a4) {
      *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
    return 0;
  }
  if (C3DMatrix4x4InitWithPropertyList((uint64_t)&context, (uint64_t)v55, a3, (uint64_t)a4))
  {
    C3DTransformSetMatrix(a1 + 96, (uint64_t)&context);
    goto LABEL_37;
  }
  CFNumberRef v59 = scn_default_log();
  if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
    _C3DNodeInitWithPropertyList_cold_8((uint64_t)a2, v59, v60, v61, v62, v63, v64, v65);
  }
  return 0;
}

__CFDictionary *_C3DNodeCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 valuePtr = 0;
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryRef Attributes = (const __CFDictionary *)C3DEntityGetAttributes(a1);
  CFDictionaryRef Morpher = (const __CFDictionary *)C3DNodeGetMorpher(a1);
  if (Morpher) {
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kMorpherKey", Morpher, 0);
  }
  uint64_t v16 = *(void *)(a1 + 248);
  if (v16 && (CFDictionaryRef Skinner = (const __CFDictionary *)C3DDeformerStackGetSkinner(v16)) != 0)
  {
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kSkinnerKey", Skinner, 0);
    char v18 = 0;
  }
  else
  {
    char v18 = 1;
  }
  uint64_t v19 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (Morpher) {
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kMorpherKey", 0, 0);
  }
  if ((v18 & 1) == 0) {
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kSkinnerKey", 0, 0);
  }
  if (v19)
  {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(v19, @"attributes");
    if (!Value)
    {
      CFDictionaryRef Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      CFDictionaryAddValue(v19, @"attributes", Value);
      CFRelease(Value);
    }
    _serializeNodeAttribute(a1, Attributes, @"kMeshKey", a2, (__CFDictionary *)Value);
    _serializeNodeAttribute(a1, Attributes, @"kCameraKey", a2, (__CFDictionary *)Value);
    _serializeNodeAttribute(a1, Attributes, @"kLightKey", a2, (__CFDictionary *)Value);
    _serializeNodeAttribute(a1, Attributes, @"kLightmapInfoKey", a2, (__CFDictionary *)Value);
    __int16 valuePtr = *(unsigned __int8 *)(a1 + 200);
    CFNumberRef v21 = CFNumberCreate(0, kCFNumberShortType, &valuePtr);
    CFDictionaryAddValue(v19, @"hidden", v21);
    CFRelease(v21);
    CFNumberRef v22 = CFNumberCreate(0, kCFNumberFloatType, (const void *)(a1 + 204));
    CFDictionaryAddValue(v19, @"alpha", v22);
    CFRelease(v22);
    CFNumberRef v23 = CFNumberCreate(0, kCFNumberNSIntegerType, (const void *)(a1 + 208));
    CFDictionaryAddValue(v19, @"category", v23);
    CFRelease(v23);
    if (*(unsigned char *)(a1 + 221)) {
      CFDictionaryAddValue(v19, @"isJoint", (const void *)*MEMORY[0x263EFFB40]);
    }
    memset(v28, 0, sizeof(v28));
    C3DNodeGetMatrix(a1, (uint64_t)v28);
    uint64_t v24 = C3DMatrix4x4CopyPropertyList((uint64_t)v28);
    if (v24)
    {
      CFDictionaryRef v25 = (const void *)v24;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      CFDictionaryAddValue(v19, @"transforms", Mutable);
      CFDictionaryAddValue(Mutable, @"matrix4x4", v25);
      CFRelease(v25);
      CFRelease(Mutable);
    }
  }
  return v19;
}

BOOL _C3DNodeFinalizeDeserialization(uint64_t a1, uint64_t a2, const __CFDictionary *a3, CFErrorRef *a4)
{
  int valuePtr = 0;
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFDictionaryRef Attributes = (const void *)C3DEntityGetAttributes(a1);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, @"attributes");
  if (!Attributes) {
    return 1;
  }
  CFDictionaryRef v18 = Value;
  CFRetain(Attributes);
  CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Attributes, @"kMeshKey");
  if (v19)
  {
    CFNumberRef v20 = v19;
    CFTypeID v21 = CFGetTypeID(v19);
    if (v21 == CFNumberGetTypeID())
    {
      if (!CFNumberGetValue(v20, kCFNumberIntType, &valuePtr))
      {
        __n128 v27 = scn_default_log();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          _C3DNodeFinalizeDeserialization_cold_3();
          if (a4) {
            goto LABEL_35;
          }
          goto LABEL_37;
        }
        goto LABEL_34;
      }
      uint64_t v22 = valuePtr;
      uint64_t TypeID = C3DGeometryGetTypeID();
      int valuePtr = C3DLibraryGetRemappedID(a2, v22, TypeID);
      uint64_t v24 = (void *)C3DGeometryGetTypeID();
      Entry = (__C3DGeometry *)C3DLibraryGetEntry(a2, v24, (const void *)valuePtr);
      if (Entry)
      {
        C3DNodeSetGeometry(a1, Entry);
      }
      else
      {
        long long v28 = scn_default_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint8_t buf = 0;
          _os_log_impl(&dword_20B249000, v28, OS_LOG_TYPE_DEFAULT, "Warning: Node<->attribute inconsistency finalizing deserialization", buf, 2u);
        }
        _C3DEntitySetAttribute((CFTypeRef *)a1, @"kMeshKey", 0, 0);
      }
    }
  }
  CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Attributes, @"kCameraKey");
  if (v29)
  {
    CFNumberRef v30 = v29;
    CFTypeID v31 = CFGetTypeID(v29);
    if (v31 == CFNumberGetTypeID())
    {
      if (!CFNumberGetValue(v30, kCFNumberIntType, &valuePtr))
      {
        long long v36 = scn_default_log();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          _C3DNodeFinalizeDeserialization_cold_3();
          if (a4) {
            goto LABEL_35;
          }
          goto LABEL_37;
        }
        goto LABEL_34;
      }
      uint64_t v32 = valuePtr;
      uint64_t v33 = C3DCameraGetTypeID();
      int valuePtr = C3DLibraryGetRemappedID(a2, v32, v33);
      int v34 = (void *)C3DCameraGetTypeID();
      CFDictionaryRef v35 = (const __CFDictionary *)C3DLibraryGetEntry(a2, v34, (const void *)valuePtr);
      if (v35)
      {
        C3DNodeSetCamera(a1, v35);
      }
      else
      {
        uint64_t v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__n128 v72 = 0;
          _os_log_impl(&dword_20B249000, v37, OS_LOG_TYPE_DEFAULT, "Warning: Node<->attribute inconsistency finalizing deserialization", v72, 2u);
        }
        _C3DEntitySetAttribute((CFTypeRef *)a1, @"kCameraKey", 0, 0);
      }
    }
  }
  CFNumberRef v38 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Attributes, @"kLightKey");
  if (!v38) {
    goto LABEL_41;
  }
  CFNumberRef v39 = v38;
  CFTypeID v40 = CFGetTypeID(v38);
  if (v40 != CFNumberGetTypeID()) {
    goto LABEL_41;
  }
  if (!CFNumberGetValue(v39, kCFNumberIntType, &valuePtr))
  {
    uint64_t v45 = scn_default_log();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      _C3DNodeFinalizeDeserialization_cold_3();
      if (a4)
      {
LABEL_35:
        if (!*a4) {
          *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
        }
      }
LABEL_37:
      CFRelease(Attributes);
      return 0;
    }
LABEL_34:
    if (a4) {
      goto LABEL_35;
    }
    goto LABEL_37;
  }
  uint64_t v41 = valuePtr;
  uint64_t v42 = C3DLightGetTypeID();
  int valuePtr = C3DLibraryGetRemappedID(a2, v41, v42);
  uint64_t v43 = (void *)C3DLightGetTypeID();
  CFDictionaryRef v44 = (const __CFDictionary *)C3DLibraryGetEntry(a2, v43, (const void *)valuePtr);
  if (v44)
  {
    C3DNodeSetLight((float32x4_t *)a1, v44);
  }
  else
  {
    CFNumberRef v46 = scn_default_log();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__n128 v71 = 0;
      _os_log_impl(&dword_20B249000, v46, OS_LOG_TYPE_DEFAULT, "Warning: Node<->attribute inconsistency finalizing deserialization", v71, 2u);
    }
    _C3DEntitySetAttribute((CFTypeRef *)a1, @"kLightKey", 0, 0);
  }
LABEL_41:
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFBFF | ((C3DEntityGetAttribute(a1, @"kCameraKey") != 0) << 10);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFDFF | ((C3DEntityGetAttribute(a1, @"kLightKey") != 0) << 9);
  CFDictionaryRef v47 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)Attributes, @"kLightmapInfoKey");
  CFRelease(Attributes);
  if (!v47) {
    goto LABEL_46;
  }
  CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(v47, @"image");
  if (!v48 || !CFNumberGetValue(v48, kCFNumberIntType, &valuePtr))
  {
    uint64_t v62 = scn_default_log();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
      _C3DNodeFinalizeDeserialization_cold_1();
    }
LABEL_53:
    if (a4 && !*a4)
    {
      CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
      BOOL result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
  uint64_t v49 = valuePtr;
  uint64_t v50 = C3DImageGetTypeID();
  int valuePtr = C3DLibraryGetRemappedID(a2, v49, v50);
  CFBooleanRef v51 = (void *)C3DImageGetTypeID();
  unsigned int v52 = C3DLibraryGetEntry(a2, v51, (const void *)valuePtr);
  if (!v52)
  {
    uint64_t v65 = scn_default_log();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      _C3DNodeFinalizeDeserialization_cold_2();
    }
    goto LABEL_53;
  }
  CFDictionaryRef v53 = v52;
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v47);
  CFDictionarySetValue(MutableCopy, @"image", v53);
  C3DNodeSetLightmapInfo(a1, MutableCopy);
  CFRelease(MutableCopy);
LABEL_46:
  uint64_t v55 = *(void *)(a1 + 248);
  if (v55)
  {
    CFDictionaryRef Skinner = (const void *)C3DDeformerStackGetSkinner(v55);
    if (Skinner)
    {
      CFNumberRef v57 = CFDictionaryGetValue(v18, @"kSkinnerKey");
      int v58 = C3DFinalizeDeserialization(Skinner, a2, (uint64_t)v57, (uint64_t)a4) & 1;
      uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)Skinner);
      if (OverrideMaterial)
      {
        uint64_t Joints = C3DSkinnerGetJoints(OverrideMaterial);
        uint64_t v61 = Joints ? (uint64_t *)C3DGeometryGetMesh(Joints) : 0;
        uint64_t Geometry = C3DNodeGetGeometry(a1);
        if (Geometry)
        {
          if (v61) {
            C3DGeometrySetMesh(Geometry, v61);
          }
        }
      }
      __C3DComputeLocalBoundingBox(a1);
      char v63 = 0;
      goto LABEL_66;
    }
  }
  else
  {
    CFDictionaryRef Skinner = 0;
  }
  char v63 = 1;
  int v58 = 1;
LABEL_66:
  uint64_t Morpher = C3DNodeGetMorpher(a1);
  if (Morpher)
  {
    CFDictionaryRef v68 = (const void *)Morpher;
    CFNumberRef v69 = CFDictionaryGetValue(v18, @"kMorpherKey");
    v58 &= C3DFinalizeDeserialization(v68, a2, (uint64_t)v69, (uint64_t)a4);
    if ((v63 & 1) == 0)
    {
      uint64_t v70 = C3DGeometryGetOverrideMaterial((uint64_t)Skinner);
      if (v70) {
        C3DSkinSetInfluencingMorpher(v70, v68);
      }
    }
  }
  return v58 != 0;
}

void _C3DNodeFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if ((*(unsigned char *)(a1 + 222) & 2) == 0)
  {
    if (C3DEntityGetAttributes(a1))
    {
      CFDictionaryRef Attributes = (const __CFDictionary *)C3DEntityGetAttributes(a1);
      CFDictionaryRef Value = CFDictionaryGetValue(Attributes, @"kLightKey");
      if (Value)
      {
        uint64_t v16 = Value;
        C3DLibraryAddEntry(a2, Value);
        C3DFillLibraryForSerialization(v16, a2, a3);
      }
    }
    if (C3DEntityGetAttributes(a1))
    {
      CFDictionaryRef v17 = (const __CFDictionary *)C3DEntityGetAttributes(a1);
      CFDictionaryRef v18 = CFDictionaryGetValue(v17, @"kCameraKey");
      if (v18)
      {
        CFNumberRef v19 = v18;
        C3DLibraryAddEntry(a2, v18);
        C3DFillLibraryForSerialization(v19, a2, a3);
      }
    }
    CFNumberRef v20 = *(const void **)(a1 + 240);
    if (v20)
    {
      C3DLibraryAddEntry(a2, v20);
      C3DFillLibraryForSerialization(*(const void **)(a1 + 240), a2, a3);
    }
    uint64_t v21 = *(void *)(a1 + 248);
    if (v21)
    {
      CFDictionaryRef Skinner = (const void *)C3DDeformerStackGetSkinner(v21);
      if (Skinner) {
        C3DFillLibraryForSerialization(Skinner, a2, a3);
      }
    }
    uint64_t Morpher = (const void *)C3DNodeGetMorpher(a1);
    if (Morpher) {
      C3DFillLibraryForSerialization(Morpher, a2, a3);
    }
    CFDictionaryRef LightmapInfo = C3DNodeGetLightmapInfo(a1);
    if (LightmapInfo)
    {
      CFDictionaryRef v25 = CFDictionaryGetValue(LightmapInfo, @"image");
      if (v25)
      {
        uint64_t v26 = v25;
        uint64_t TypeID = C3DImageGetTypeID();
        if (TypeID == CFGetTypeID(v26))
        {
          C3DLibraryAddEntry(a2, v26);
          C3DFillLibraryForSerialization(v26, a2, a3);
        }
      }
    }
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 0x40000000;
    CFTypeID v31 = ___C3DNodeFillLibraryForSerialization_block_invoke;
    uint64_t v32 = &__block_descriptor_tmp_121;
    uint64_t v33 = a2;
    uint64_t v34 = a3;
    uint64_t v28 = *(void *)(a1 + 72);
    if (v28)
    {
      uint64_t v29 = 0;
      do
      {
        ((void (*)(void *, uint64_t, uint64_t))v31)(v30, v28, v29++);
        uint64_t v28 = *(void *)(v28 + 80);
      }
      while (v28);
    }
  }
}

void _fillPatchedDictionay(CFStringRef theString, void *value, uint64_t a3)
{
  int v5 = *(__CFDictionary **)a3;
  if (theString
    && CFStringHasPrefix(theString, @"kC3D")
    && (v10.length = CFStringGetLength(theString) - 4,
        v10.locatioint n = 4,
        CFStringRef v7 = CFStringCreateWithSubstring(0, theString, v10),
        CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"k%@", v7),
        CFRelease(v7),
        v8))
  {
    *(void *)(a3 + 8) = 1;
    CFDictionaryAddValue(v5, v8, value);
    CFRelease(v8);
  }
  else
  {
    CFDictionaryAddValue(v5, theString, value);
  }
}

void _serializeNodeAttribute(uint64_t a1, const __CFDictionary *a2, __CFString *theString1, uint64_t a4, __CFDictionary *a5)
{
  if (CFStringCompare(theString1, @"kLightmapInfoKey", 0))
  {
    if (@"kMeshKey" == theString1)
    {
      CFDictionaryRef Value = *(const void **)(a1 + 240);
      if (!Value) {
        return;
      }
    }
    else
    {
      if (!a2) {
        return;
      }
      CFDictionaryRef Value = CFDictionaryGetValue(a2, theString1);
      if (!Value) {
        return;
      }
    }
    unsigned int EntryID = C3DLibraryGetEntryID(a4, Value);
    if (!EntryID) {
      return;
    }
    CFNumberRef v26 = CFNumberCreate(0, kCFNumberIntType, &EntryID);
    CFDictionarySetValue(a5, theString1, v26);
    CFNumberRef v25 = v26;
LABEL_18:
    CFRelease(v25);
    return;
  }
  if (a2)
  {
    CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kLightmapInfoKey");
    if (v11)
    {
      Mutableuint64_t Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v11);
      uint64_t v13 = CFDictionaryGetValue(MutableCopy, @"image");
      if (v13)
      {
        uint64_t v14 = v13;
        CFTypeID v15 = CFGetTypeID(v13);
        if (v15 == C3DImageGetTypeID())
        {
          unsigned int valuePtr = C3DLibraryGetEntryID(a4, v14);
          if (!valuePtr)
          {
            uint64_t v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
              _serializeNodeAttribute_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
            }
          }
          CFNumberRef v24 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(MutableCopy, @"image", v24);
          CFRelease(v24);
          CFDictionarySetValue(a5, @"kLightmapInfoKey", MutableCopy);
        }
      }
      CFNumberRef v25 = MutableCopy;
      goto LABEL_18;
    }
  }
}

__CFArray *_C3DNodeCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  int v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0x500000001;
  uint64_t ID = C3DEntityGetID(a1);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v5, @"name", @"id");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  uint64_t valuePtr = 0x500000001;
  uint64_t ID = C3DEntityGetName(a1);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v9, @"name", @"name");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  uint64_t valuePtr = 0x500000001;
  uint64_t ID = C3DEntityGetAttributes(a1);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v13, @"name", @"attributes");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0xB00000000;
  uint64_t ID = a1 + 96;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v17, @"name", @"transforms");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0x500000002;
  uint64_t ID = a1 + 72;
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v22, @"name", @"firstChild");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(Mutable, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  CFNumberRef v26 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  __n128 v27 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v21);
  uint64_t valuePtr = 0x500000002;
  uint64_t ID = a1 + 80;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v27, @"name", @"nextSibling");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  CFTypeID v31 = CFDictionaryCreateMutable(0, 4, v26, MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0x100000000;
  uint64_t ID = a1 + 204;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v31, @"name", @"opacity");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  CFDictionaryRef v35 = CFDictionaryCreateMutable(0, 4, v26, MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0x300000000;
  uint64_t ID = a1 + 200;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v35, @"name", @"hidden");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  CFNumberRef v39 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFTypeID v40 = CFDictionaryCreateMutable(0, 4, v26, MEMORY[0x263EFFF90]);
  uint64_t ID = a1 + 64;
  uint64_t valuePtr = 0;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v40, @"name", @"parent");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  CFDictionaryRef v44 = CFDictionaryCreateMutable(0, 4, v26, v39);
  uint64_t valuePtr = 0x500000002;
  uint64_t ID = a1 + 240;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v44, @"name", @"geometry");
  CFDictionarySetValue(v44, @"type", v45);
  CFDictionarySetValue(v44, @"address", v47);
  CFDictionarySetValue(v44, @"semantic", v46);
  CFArrayAppendValue(Mutable, v44);
  CFRelease(v46);
  CFRelease(v44);
  CFRelease(v47);
  CFRelease(v45);
  CFNumberRef v48 = CFDictionaryCreateMutable(0, 4, v26, MEMORY[0x263EFFF90]);
  uint64_t valuePtr = 0x200000000;
  uint64_t ID = a1 + 208;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberLongType, &ID);
  CFDictionarySetValue(v48, @"name", @"categoryBitMask");
  CFDictionarySetValue(v48, @"type", v49);
  CFDictionarySetValue(v48, @"address", v51);
  CFDictionarySetValue(v48, @"semantic", v50);
  CFArrayAppendValue(Mutable, v48);
  CFRelease(v50);
  CFRelease(v48);
  CFRelease(v51);
  CFRelease(v49);
  if (C3DNodeGetMorpher(a1))
  {
    unsigned int v52 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    uint64_t valuePtr = 0x500000001;
    uint64_t ID = C3DNodeGetMorpher(a1);
    CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v55 = CFNumberCreate(0, kCFNumberLongType, &ID);
    CFDictionarySetValue(v52, @"name", @"morpher");
    CFDictionarySetValue(v52, @"type", v53);
    CFDictionarySetValue(v52, @"address", v55);
    CFDictionarySetValue(v52, @"semantic", v54);
    CFArrayAppendValue(Mutable, v52);
    CFRelease(v54);
    CFRelease(v52);
    CFRelease(v55);
    CFRelease(v53);
  }
  uint64_t v56 = *(void *)(a1 + 248);
  if (v56 && C3DDeformerStackGetSkinner(v56))
  {
    CFNumberRef v57 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    uint64_t valuePtr = 0x500000001;
    uint64_t Skinner = *(void *)(a1 + 248);
    if (Skinner) {
      uint64_t Skinner = C3DDeformerStackGetSkinner(Skinner);
    }
    uint64_t ID = Skinner;
    CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v61 = CFNumberCreate(0, kCFNumberLongType, &ID);
    CFDictionarySetValue(v57, @"name", @"skinner");
    CFDictionarySetValue(v57, @"type", v59);
    CFDictionarySetValue(v57, @"address", v61);
    CFDictionarySetValue(v57, @"semantic", v60);
    CFArrayAppendValue(Mutable, v57);
    CFRelease(v60);
    CFRelease(v57);
    CFRelease(v61);
    CFRelease(v59);
  }
  return Mutable;
}

uint64_t _C3DNodeGetBoundingBox(float32x4_t *a1, int a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t v10 = 0u;
  float32x4_t v11 = 0u;
  if (a2)
  {
    if (C3DNodeComputeHierarchicalBoundingBox(a1, 1, &v10))
    {
LABEL_3:
      float32x4_t v6 = v10;
      float32x4_t v7 = v11;
      *a3 = vsubq_f32(v10, v11);
      *a4 = vaddq_f32(v6, v7);
      return 1;
    }
  }
  else
  {
    float32x4_t v9 = a1[18];
    float32x4_t v10 = a1[17];
    float32x4_t v11 = v9;
    if ((vminvq_u32((uint32x4_t)vcgezq_f32(a1[18])) & 0x80000000) != 0) {
      goto LABEL_3;
    }
  }
  return 0;
}

uint64_t _C3DNodeGetBoundingSphere(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  if (!a3)
  {
    float32x4_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DNodeGetBoundingSphere_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  float32x4_t v31 = 0uLL;
  float32x4_t v30 = 0uLL;
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a1);
  if (!Geometry)
  {
LABEL_8:
    if (!a2) {
      goto LABEL_27;
    }
    goto LABEL_11;
  }
  uint64_t v15 = a1[15].i64[1];
  if (v15)
  {
    uint64_t Skinner = C3DDeformerStackGetSkinner(v15);
    if (Skinner)
    {
      float32x4_t v26 = 0u;
      float32x4_t v27 = 0u;
      C3DSkinnerGetBoundingBox(Skinner, a1, (uint64_t)&v26);
      LOBYTE(Geometry) = v17;
      float32x4_t v18 = v26;
      v18.i32[3] = vmaxvq_f32(v27);
      float32x4_t v31 = v18;
      goto LABEL_8;
    }
  }
  LOBYTE(Geometry) = C3DGetBoundingSphere((CFTypeRef)Geometry, a2, (uint64_t)&v31);
  if (!a2) {
    goto LABEL_27;
  }
LABEL_11:
  uint64_t v19 = a1[4].i64[1];
  if (v19)
  {
    LODWORD(v20) = 0;
    do
    {
      uint64_t v20 = (v20 + 1);
      uint64_t v19 = *(void *)(v19 + 80);
    }
    while (v19);
    if (v20)
    {
      for (uint64_t i = 0; i != v20; ++i)
      {
        uint64_t v22 = (__n128 *)a1[4].i64[1];
        if (i && v22)
        {
          unsigned int v23 = 1;
          do
          {
            uint64_t v22 = (__n128 *)v22[5].n128_u64[0];
            if (v23 >= i) {
              break;
            }
            ++v23;
          }
          while (v22);
        }
        if (C3DGetBoundingSphere(v22, 1, (uint64_t)&v30))
        {
          long long v28 = 0u;
          long long v29 = 0u;
          float32x4_t v26 = 0u;
          float32x4_t v27 = 0u;
          C3DNodeGetMatrix((uint64_t)v22, (uint64_t)&v26);
          __n128 Scale = C3DTransformGetScale(v22 + 6);
          C3DTransformBoundingSphere(&v30, &v26, (__n128 *)&v30, Scale);
          if (Geometry) {
            C3DSphereMakeByMergingSpheres(&v31, &v30, &v31);
          }
          else {
            float32x4_t v31 = v30;
          }
          LOBYTE(Geometry) = 1;
        }
      }
    }
  }
LABEL_27:
  if ((Geometry & 1) == 0) {
    return 0;
  }
  *a3 = v31;
  return 1;
}

void _C3DNodeSetValue(uint64_t a1, __n128 *__dst, long long *__src, size_t __n, int a5, unsigned int a6, __n128 a7)
{
  if ((__n128 *)(a1 + 96) == __dst)
  {
    C3DTransformSetValue(__dst, __src, __n, a5, a6, a7);
    __C3DNodeTransformDidChange((float32x4_t *)a1);
  }
  else if (*(__n128 **)(a1 + 192) == __dst)
  {
    C3DNodeSetPivotMatrix((float32x4_t *)a1, __src);
  }
  else if ((__n128 *)(a1 + 204) == __dst)
  {
    float v8 = *(float *)__src;
    C3DNodeSetOpacity(a1, v8);
  }
  else if ((__n128 *)(a1 + 200) == __dst)
  {
    int v9 = *(unsigned __int8 *)__src;
    C3DNodeSetHidden(a1, v9);
  }
  else
  {
    memcpy(__dst, __src, __n);
  }
}

void _C3DNodeWillRemoveFromScene(uint64_t a1, uint64_t a2)
{
  C3DSceneNodeWillBeRemoved(a2, a1);
  if (*(_DWORD *)(a1 + 88) != -1)
  {
    TransformTree = (__C3DTransformTree *)C3DSceneGetTransformTree(a2);
    if (TransformTree) {
      C3DTransformTreeRemoveNode(TransformTree, *(unsigned int *)(a1 + 88));
    }
    *(_DWORD *)(a1 + 88) = -1;
  }
  if (*(_DWORD *)(a1 + 216) != -1)
  {
    CullingSysteuint64_t m = (__C3DCullingSystem *)C3DSceneGetCullingSystem(a2);
    if (CullingSystem) {
      C3DCullingSystemRemove(CullingSystem, *(_DWORD *)(a1 + 216));
    }
    *(_DWORD *)(a1 + 216) = -1;
  }
}

uint64_t _C3DNodeSearchByID(uint64_t a1, const void *a2)
{
  uint64_t ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  uint64_t Name = (const void *)C3DEntityGetName(a1);
  if (Name)
  {
    if (C3DEqual(Name, a2)) {
      return a1;
    }
  }
  uint64_t Geometry = (const void *)C3DNodeGetGeometry(a1);
  uint64_t v6 = C3DSearchByID(Geometry, (uint64_t)a2);
  if (!v6)
  {
    CFDictionaryRef Light = C3DNodeGetLight(a1);
    uint64_t v6 = C3DSearchByID(Light, (uint64_t)a2);
    if (!v6)
    {
      uint64_t Morpher = (const void *)C3DNodeGetMorpher(a1);
      uint64_t v6 = C3DSearchByID(Morpher, (uint64_t)a2);
      if (!v6)
      {
        uint64_t Skinner = *(const void **)(a1 + 248);
        if (Skinner) {
          uint64_t Skinner = (const void *)C3DDeformerStackGetSkinner((uint64_t)Skinner);
        }
        uint64_t v6 = C3DSearchByID(Skinner, (uint64_t)a2);
        if (!v6)
        {
          uint64_t Floor = (const void *)C3DNodeGetFloor(a1);
          uint64_t v6 = C3DSearchByID(Floor, (uint64_t)a2);
          if (!v6)
          {
            CFDictionaryRef Camera = C3DNodeGetCamera(a1);
            uint64_t v6 = C3DSearchByID(Camera, (uint64_t)a2);
            if (!v6)
            {
              uint64_t v15 = 0;
              CFNumberRef v16 = &v15;
              uint64_t v17 = 0x2000000000;
              uint64_t v18 = 0;
              v14[0] = MEMORY[0x263EF8330];
              v14[1] = 0x40000000;
              void v14[2] = ___C3DNodeSearchByID_block_invoke;
              v14[3] = &unk_264007F08;
              uint8_t v14[4] = &v15;
              v14[5] = a2;
              C3DNodeApplyChildrenInterruptible(a1, (uint64_t)v14);
              uint64_t v6 = v16[3];
              _Block_object_dispose(&v15, 8);
            }
          }
        }
      }
    }
  }
  return v6;
}

void sub_20B3BA05C(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C40DB73C136);
  _Unwind_Resume(a1);
}

void sub_20B3BA21C(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C40DB73C136);
  _Unwind_Resume(a1);
}

void SCNCActionFade::~SCNCActionFade(SCNCActionFade *this)
{
  SCNCAction::~SCNCAction((SCNCAction *)this);

  JUMPOUT(0x210534FE0);
}

SCNCAction *SCNCActionFade::cpp_updateWithTargetForTime(SCNCActionFade *this, SCNNode *a2, double a3)
{
  float v6 = SCNCAction::cpp_ratioForTime((SCNCAction *)this, a3);
  if (this->var22)
  {
    [(SCNNode *)a2 opacity];
    *(float *)&double v7 = v7;
    float v8 = this->var19 * v6;
    BOOL result = (SCNCAction *)[(SCNNode *)a2 setOpacity:(float)(v8 + (float)(*(float *)&v7 - this->var21))];
    this->var21 = v8;
  }
  else
  {
    BOOL result = (SCNCAction *)[(SCNNode *)a2 setOpacity:(float)((float)(this->var19 * v6) + (float)(this->var21 * (float)(1.0 - v6)))];
  }
  if ((COERCE_UNSIGNED_INT(v6 + -1.0) & 0x60000000) == 0)
  {
    v10.n128_f64[0] = a3;
    return SCNCAction::didFinishWithTargetAtTime((SCNCAction *)this, a2, v10);
  }
  return result;
}

SCNCAction *SCNCActionFade::cpp_willStartWithTargetAtTime(SCNCActionFade *this, SCNNode *a2, double a3)
{
  BOOL result = SCNCAction::cpp_willStartWithTargetAtTime((SCNCAction *)this, a2, a3);
  float v6 = 0.0;
  if (!this->var22)
  {
    BOOL result = (SCNCAction *)[(SCNNode *)a2 opacity];
    float v6 = v7;
  }
  this->var21 = v6;
  return result;
}

void *__DropOriginalTopology(uint64_t a1)
{
  if (!*(void *)(a1 + 112))
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __DropOriginalTopology_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (!*(void *)(a1 + 144))
  {
    __n128 v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      __DropOriginalTopology_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  CFTypeRef v18 = *(CFTypeRef *)(a1 + 64);
  CFTypeRef v19 = *(CFTypeRef *)(a1 + 112);
  if (v18 != v19)
  {
    if (v18)
    {
      CFRelease(*(CFTypeRef *)(a1 + 64));
      *(void *)(a1 + 64) = 0;
      CFTypeRef v19 = *(CFTypeRef *)(a1 + 112);
    }
    if (v19) {
      CFTypeRef v19 = CFRetain(v19);
    }
    *(void *)(a1 + 64) = v19;
  }
  CFTypeRef v20 = *(CFTypeRef *)(a1 + 96);
  CFTypeRef v21 = *(CFTypeRef *)(a1 + 144);
  if (v20 != v21)
  {
    if (v20)
    {
      CFRelease(*(CFTypeRef *)(a1 + 96));
      *(void *)(a1 + 96) = 0;
      CFTypeRef v21 = *(CFTypeRef *)(a1 + 144);
    }
    if (v21) {
      CFTypeRef v21 = CFRetain(v21);
    }
    *(void *)(a1 + 96) = v21;
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a1 + 120);
  *(_WORD *)(a1 + 88) = *(_WORD *)(a1 + 136);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
  free(*(void **)(a1 + 104));
  unsigned int v23 = malloc_type_malloc(Count, 0xB789394DuLL);
  *(void *)(a1 + 104) = v23;
  return memcpy(v23, *(const void **)(a1 + 152), Count);
}

uint64_t _C3DMeshFinalizeDeserialization(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFErrorRef *a4)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  unsigned __int8 v49 = 1;
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"sources");
  if (!Value)
  {
    long long v28 = scn_default_log();
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    _C3DMeshFinalizeDeserialization_cold_1((uint64_t)theDict, v28, v29, v30, v31, v32, v33, v34);
    if (!a4) {
      return 0;
    }
    goto LABEL_33;
  }
  CFArrayRef v17 = Value;
  if (CFArrayGetCount(Value) < 1)
  {
    char v19 = 1;
LABEL_22:
    CFDictionaryRef v35 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"primarySourcesInfo");
    if (v35)
    {
      *(void *)&long long buf = a2;
      *((void *)&buf + 1) = &v49;
      CFNumberRef v51 = a4;
      CFDictionaryApplyFunction(v35, (CFDictionaryApplierFunction)__DeserializePrimarySource, &buf);
      char v19 = v49;
      if (!v49)
      {
        CFNumberRef v47 = scn_default_log();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          _C3DMeshFinalizeDeserialization_cold_4();
        }
        return 0;
      }
    }
    if (v19 == 1
      && (CFArrayRef v36 = (const __CFArray *)CFDictionaryGetValue(theDict, @"geometryElements")) != 0
      && (v37 = v36, CFIndex Count = CFArrayGetCount(v36), Count >= 1))
    {
      CFIndex v39 = Count;
      CFIndex v40 = 0;
      while (1)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(v37, v40);
        CFNumberRef v42 = (const void *)C3DMeshElementCreate();
        int v43 = C3DInitWithPropertyList(v42, (uint64_t)ValueAtIndex, 0, (uint64_t)a4);
        unsigned __int8 v49 = v43;
        if (!v43) {
          break;
        }
        C3DMeshAppendElement(a1, v42);
        CFRelease(v42);
        if (v39 == ++v40) {
          goto LABEL_30;
        }
      }
      CFNumberRef v48 = scn_default_log();
      uint64_t result = os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
      if (result)
      {
        _C3DMeshFinalizeDeserialization_cold_3();
        return 0;
      }
    }
    else
    {
LABEL_30:
      C3DMeshBuildRenderableData(a1, 1);
      return v49;
    }
    return result;
  }
  CFIndex v18 = 0;
  char v19 = 1;
  while (1)
  {
    CFTypeRef v20 = CFArrayGetValueAtIndex(v17, v18);
    CFTypeID v21 = CFGetTypeID(v20);
    if (v21 != CFNumberGetTypeID())
    {
      CFNumberRef v24 = (const void *)_C3DMeshSourceCreate();
      CFNumberRef v25 = CFArrayGetValueAtIndex(v17, v18);
      int v26 = C3DInitWithPropertyList(v24, (uint64_t)v25, 0, (uint64_t)a4);
      char v19 = v26;
      unsigned __int8 v49 = v26;
      if (v26) {
        __C3DMeshAddSourceWithDataKind(a1, v24, 0, 0, 0);
      }
      CFRelease(v24);
      goto LABEL_14;
    }
    SourceWithuint64_t ID = __FindSourceWithID(a2, (CFNumberRef)v20);
    if (!SourceWithID) {
      break;
    }
    unsigned int v23 = SourceWithID;
    if ((C3DMeshSourceGetSemantic((uint64_t)SourceWithID) - 7) > 0xFDu)
    {
      float32x4_t v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v23;
        _os_log_impl(&dword_20B249000, v27, OS_LOG_TYPE_INFO, "Info: Mesh deserialization: Skipped a source that will be recreated at runtime : %@", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      __C3DMeshAddSourceWithDataKind(a1, v23, 0, 0, 0);
    }
LABEL_14:
    if (++v18 >= CFArrayGetCount(v17)) {
      goto LABEL_22;
    }
  }
  CFNumberRef v45 = scn_default_log();
  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
  {
    _C3DMeshFinalizeDeserialization_cold_2();
    if (!a4) {
      return 0;
    }
LABEL_33:
    if (*a4) {
      return 0;
    }
    CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
    uint64_t result = 0;
    *a4 = MalformedDocumentError;
    return result;
  }
LABEL_32:
  if (a4) {
    goto LABEL_33;
  }
  return 0;
}

void *__FindSourceWithID(uint64_t a1, CFNumberRef number)
{
  int valuePtr = 0;
  if (!CFNumberGetValue(number, kCFNumberIntType, &valuePtr)) {
    return 0;
  }
  uint64_t v3 = valuePtr;
  uint64_t TypeID = C3DMeshSourceGetTypeID();
  uint64_t result = (void *)C3DLibraryGetRemappedID(a1, v3, TypeID);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = (void *)C3DMeshSourceGetTypeID();
    return C3DLibraryGetEntry(a1, v7, v6);
  }
  return result;
}

void __DeserializePrimarySource(const __CFString *a1, CFDictionaryRef theDict, uint64_t *a3)
{
  *(void *)&v31[5] = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v6 = (unsigned char *)a3[1];
  uint64_t v7 = (CFErrorRef *)a3[2];
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"data");
  CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(theDict, @"subIDs");
  IntCFDataRef Value = CFStringGetIntValue(a1);
  uint64_t TypeID = C3DMeshSourceGetTypeID();
  Remappeduint64_t ID = (const void *)C3DLibraryGetRemappedID(v5, IntValue, TypeID);
  uint64_t v13 = (void *)C3DMeshSourceGetTypeID();
  Entry = C3DLibraryGetEntry(v5, v13, RemappedID);
  if (Entry)
  {
    uint64_t v15 = (uint64_t)Entry;
    theCFDataRef Data = Value;
    CFIndex Count = CFArrayGetCount(v9);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x263EFFF70]);
    CFIndex v18 = CFArrayGetCount(v9);
    if (v18 >= 1)
    {
      CFIndex v19 = v18;
      CFIndex v20 = 0;
      while (1)
      {
        ValueAtuint64_t Index = (const __CFNumber *)CFArrayGetValueAtIndex(v9, v20);
        SourceWithuint64_t ID = __FindSourceWithID(v5, ValueAtIndex);
        if (!SourceWithID) {
          break;
        }
        Accessor = (const void *)C3DGenericSourceGetAccessor((uint64_t)SourceWithID);
        if (C3DSceneSourceGetURL((uint64_t)Accessor) != v15)
        {
          CFNumberRef v24 = scn_default_log();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
            __DeserializePrimarySource_cold_3(v30, v31, v24);
          }
        }
        CFArrayAppendValue(Mutable, Accessor);
        if (v19 == ++v20) {
          goto LABEL_9;
        }
      }
      *uint64_t v6 = 0;
      if (v7 && !*v7) {
        *uint64_t v7 = C3DSceneSourceCreateMalformedDocumentError(0);
      }
      long long v28 = scn_default_log();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        __DeserializePrimarySource_cold_2();
        if (!Mutable) {
          return;
        }
      }
      else if (!Mutable)
      {
        return;
      }
      int v26 = Mutable;
      goto LABEL_24;
    }
LABEL_9:
    DeserializedDataWithAccessors = C3DGenericSourceCreateDeserializedDataWithAccessors(v15, theData, Mutable);
    C3DGenericSourceSetData(v15, DeserializedDataWithAccessors);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (DeserializedDataWithAccessors)
    {
      int v26 = DeserializedDataWithAccessors;
LABEL_24:
      CFRelease(v26);
    }
  }
  else
  {
    *uint64_t v6 = 0;
    if (v7 && !*v7) {
      *uint64_t v7 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
    float32x4_t v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      __DeserializePrimarySource_cold_1();
    }
  }
}

uint64_t C3DMeshCreateVolatile()
{
  uint64_t result = C3DMeshCreate();
  *(unsigned char *)(result + 200) |= 1u;
  return result;
}

uint64_t C3DMeshCreateCopy(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMeshCreate();
  __C3DMeshCopy(a1, v10, 0);
  return v10;
}

void __C3DMeshCopy(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  __C3DMeshCopySources(a1, a2, a3);
  if (a3)
  {
    ElementsCFIndex Count = (CFIndex)C3DMeshGetElementsCount(a1);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, ElementsCount, MEMORY[0x263EFFF70]);
    if (ElementsCount >= 1)
    {
      for (CFIndex i = 0; i != ElementsCount; ++i)
      {
        ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, i, 0);
        Deepuint64_t Copy = (const void *)C3DMeshElementCreateDeepCopy((uint64_t)ElementAtIndex);
        CFArrayAppendValue(Mutable, DeepCopy);
        CFRelease(DeepCopy);
      }
    }
    C3DMeshSetMeshElements(a2, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    float32x4_t v27 = *(const void **)(a2 + 96);
    if (v27)
    {
      CFRelease(v27);
      *(void *)(a2 + 96) = 0;
    }
    long long v28 = *(const void **)(a2 + 144);
    if (v28)
    {
      CFRelease(v28);
      *(void *)(a2 + 144) = 0;
    }
    CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    *(void *)(a2 + 96) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, *(CFArrayRef *)(a1 + 96));
    CFArrayRef v30 = *(const __CFArray **)(a1 + 144);
    if (v30) {
      Mutableuint64_t Copy = CFArrayCreateMutableCopy(v29, 0, v30);
    }
    else {
      Mutableuint64_t Copy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
    }
    *(void *)(a2 + 144) = MutableCopy;
  }
  *(unsigned char *)(a2 + 200) = *(unsigned char *)(a2 + 200) & 0x87 | *(unsigned char *)(a1 + 200) & 0x78;
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
}

uint64_t C3DMeshCreateDeepCopy(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMeshCreate();
  __C3DMeshCopy(a1, v10, 1);
  return v10;
}

uint64_t C3DMeshCreateRenderableCopy(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = C3DMeshCreate();
  __C3DMeshCopy(a1, v10, 1);
  C3DMeshBuildRenderableData(v10, 1);
  __DropOriginalTopology(v10);
  return v10;
}

uint64_t C3DMeshGetBoundingSphere(uint64_t a1, _OWORD *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(_OWORD **)(a1 + 184);
  if (v12) {
    goto LABEL_24;
  }
  long long v36 = 0uLL;
  v39.i32[2] = 0;
  v39.i64[0] = 0;
  v38.i32[2] = 0;
  v38.i64[0] = 0;
  C3DMeshGetBoundingBox(a1, &v39, &v38);
  *(double *)&long long v13 = C3DVector3MidVector(v38, v39);
  float32x4_t v35 = (float32x4_t)v13;
  long long v37 = v13;
  SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
  if (SourceWithSemanticAtIndex)
  {
    uint64_t result = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
    if (!result) {
      return result;
    }
    uint64_t v20 = result;
    uint64_t v21 = v16;
    if ((v16 & 0xFF000000000000) == 0x1000000000000)
    {
      if (v16)
      {
        unsigned int v22 = 0;
        float v23 = 0.0;
        do
        {
          uint64_t v24 = result + v22;
          v17.i64[0] = *(void *)v24;
          v17.i32[2] = *(_DWORD *)(v24 + 8);
          float32x4_t v25 = vsubq_f32(v17, v35);
          float32x4_t v26 = vmulq_f32(v25, v25);
          float32x4_t v17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)));
          if (v17.f32[0] > v23) {
            float v23 = v17.f32[0];
          }
          v22 += BYTE5(v16);
          --v21;
        }
        while (v21);
        goto LABEL_22;
      }
    }
    else if (v16)
    {
      unsigned int v28 = 0;
      int v29 = BYTE4(v16);
      int v30 = BYTE5(v16);
      float v23 = 0.0;
      do
      {
        *(double *)v31.i64 = C3DConvertFloatingTypeToFloat4(v29, (float *)(v20 + v28), v17, v18.f32[0], v19.f32[0]);
        float32x4_t v32 = vsubq_f32(v31, v35);
        float32x4_t v33 = vmulq_f32(v32, v32);
        float32x4_t v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1);
        float32x4_t v19 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2);
        float32x4_t v17 = vaddq_f32(v19, vaddq_f32(v33, v18));
        if (v17.f32[0] > v23) {
          float v23 = v17.f32[0];
        }
        v28 += v30;
        --v21;
      }
      while (v21);
      goto LABEL_22;
    }
    float v23 = 0.0;
LABEL_22:
    float v27 = sqrtf(v23);
    goto LABEL_23;
  }
  float v27 = 0.0;
LABEL_23:
  C3DSphereMake(&v36, &v37, v27);
  uint64_t v34 = C3DMalloc(0x10uLL);
  *(void *)(a1 + 184) = v34;
  *uint64_t v34 = v36;
  uint64_t v12 = *(_OWORD **)(a1 + 184);
LABEL_24:
  *a2 = *v12;
  return 1;
}

void C3DMeshCopyBoundingVolumes(uint64_t a1, uint64_t a2)
{
  C3DMeshGetBoundingBox(a1, &v22, &v21);
  uint64_t v4 = *(_OWORD **)(a2 + 192);
  if (!v4)
  {
    uint64_t v4 = C3DMalloc(0x20uLL);
    *(void *)(a2 + 192) = v4;
  }
  *uint64_t v4 = *(_OWORD *)*(void *)(a1 + 192);
  *(_OWORD *)(*(void *)(a2 + 192) + 16) = *(_OWORD *)(*(void *)(a1 + 192) + 16);
  long long v20 = 0uLL;
  C3DMeshGetBoundingSphere(a1, &v20);
  uint64_t v5 = *(_OWORD **)(a2 + 184);
  if (!v5)
  {
    uint64_t v5 = C3DMalloc(0x10uLL);
    *(void *)(a2 + 184) = v5;
  }
  *uint64_t v5 = v20;
  _C3DUpdateMeshElementsBBoxIfNeeded(a1);
  ElementsCFIndex Count = C3DMeshGetElementsCount(a1);
  CFArrayRef v7 = C3DMeshGetElementsCount(a2);
  if (ElementsCount != v7)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DMeshCopyBoundingVolumes_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if ((uint64_t)ElementsCount >= (uint64_t)v7) {
    uint64_t v16 = (uint64_t)v7;
  }
  else {
    uint64_t v16 = (uint64_t)ElementsCount;
  }
  if (v16 >= 1)
  {
    for (CFIndex i = 0; i != v16; ++i)
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, i, 0);
      float32x4_t v19 = C3DMeshGetElementAtIndex(a2, i, 0);
      v19[11] = ElementAtIndex[11];
      v19[12] = ElementAtIndex[12];
    }
  }
  *(unsigned char *)(a2 + 200) |= 2u;
}

void __C3DMeshRemoveSourceWithSemanticAtIndex(CFArrayRef *a1, int a2, uint64_t a3, int a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a4 == 1)
  {
    C3DMeshBuildRenderableData((uint64_t)a1, 1);
    uint64_t v16 = a1 + 14;
  }
  else if (a4)
  {
    float32x4_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = a1 + 8;
  }
  float32x4_t v25 = (char *)v16 + 2 * a2;
  uint64_t v28 = v25[8];
  float v27 = v25 + 8;
  uint64_t v26 = v28;
  if (v28 != -1 && v27[1] > a3)
  {
    CFIndex v29 = v26 + a3;
    CFIndex Count = CFArrayGetCount(*v16);
    if (v29 >= Count)
    {
      float32x4_t v31 = scn_default_log();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
        __C3DMeshRemoveSourceWithSemanticAtIndex_cold_1(v31, v32, v33, v34, v35, v36, v37, v38);
      }
    }
    CFArrayRemoveValueAtIndex(*v16, v29);
    CFArrayRef v39 = a1[19];
    if (v39)
    {
      free(v39);
      a1[19] = 0;
    }
    if (a4)
    {
      __BuildSemanticInfosForData((uint64_t)a1, (uint64_t)v16);
    }
    else
    {
      if (Count - 1 > v29)
      {
        do
        {
          *((unsigned char *)a1[13] + v29) = *((unsigned char *)a1[13] + v29 + 1);
          ++v29;
        }
        while (Count - 1 != v29);
      }
      __BuildSemanticInfosForData((uint64_t)a1, (uint64_t)v16);
      __UpdateSourcesMutability((uint64_t)a1);
      __C3DMeshInvalidateRenderableData((uint64_t)a1);
    }
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", a1, 0, 1u);
    a1[26] = (CFArrayRef)((char *)a1[26] + 1);
  }
}

uint64_t C3DMeshSetSourceWithInputSet(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  return __C3DMeshSetSourceWithInputSetAndDataKind(a1, a2, a3, a4, 0);
}

uint64_t C3DMeshGetInputSetForSource(uint64_t a1, const void *a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationCopy_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (a3 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v22 = (CFArrayRef *)(a1 + 112);
  }
  else if (a3)
  {
    uint64_t v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      C3DMeshApplySources_cold_1(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    uint64_t v22 = 0;
  }
  else
  {
    uint64_t v22 = (CFArrayRef *)(a1 + 64);
  }
  float32x4_t v31 = (char *)v22 + 2 * (int)C3DMeshSourceGetSemantic((uint64_t)a2);
  uint64_t v34 = v31[8];
  uint64_t v32 = v31 + 8;
  uint64_t v33 = v34;
  if (v34 == -1) {
    return -1;
  }
  uint64_t v35 = v32[1];
  if (!v32[1]) {
    return -1;
  }
  uint64_t v36 = 0;
  while (CFArrayGetValueAtIndex(*v22, v33 + v36) != a2)
  {
    if (v35 == ++v36) {
      return -1;
    }
  }
  return v36;
}

BOOL C3DMeshHasSourcesWithSemantic(uint64_t a1, int a2, int a3, int a4)
{
  void v9[3] = *MEMORY[0x263EF8340];
  if (a3 == 1)
  {
    if (a4) {
      C3DMeshBuildRenderableData(a1, 1);
    }
    uint64_t v7 = (void *)(a1 + 112);
  }
  else
  {
    if (a3) {
      C3DMeshHasSourcesWithSemantic_cold_1((uint64_t)v9);
    }
    uint64_t v7 = (void *)(a1 + 64);
  }
  return *v7 && __indexOfSourceWithSemanticAtIndex(a1, a2, 0, a3) != -1;
}

BOOL __C3DMeshHasSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3, int a4, void *a5)
{
  v10[3] = *MEMORY[0x263EF8340];
  if (a4 == 1)
  {
    uint64_t v6 = (CFArrayRef *)(a1 + 112);
  }
  else
  {
    if (a4) {
      C3DMeshHasSourcesWithSemantic_cold_1((uint64_t)v10);
    }
    uint64_t v6 = (CFArrayRef *)(a1 + 64);
  }
  if (*v6)
  {
    CFIndex v7 = __indexOfSourceWithSemanticAtIndex(a1, a2, a3, a4);
    if (v7 == -1)
    {
      ValueAtuint64_t Index = 0;
      if (!a5) {
        return ValueAtIndex != 0;
      }
    }
    else
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*v6, v7);
      if (!a5) {
        return ValueAtIndex != 0;
      }
    }
    *a5 = ValueAtIndex;
    return ValueAtIndex != 0;
  }
  BOOL result = 0;
  *a5 = 0;
  return result;
}

void C3DMeshRemoveSourceWithSemanticAtIndex(CFArrayRef *a1, int a2, uint64_t a3)
{
}

void C3DMeshRemoveSource(CFArrayRef *a1, const void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationCopy_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t InputSetForSource = C3DMeshGetInputSetForSource((uint64_t)a1, a2, 0);
  if (InputSetForSource != -1)
  {
    uint64_t v21 = InputSetForSource;
    SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)a2);
    __C3DMeshRemoveSourceWithSemanticAtIndex(a1, Semantic, v21, 0);
  }
}

const void *C3DMeshRemoveSourcesWithSemantic(CFArrayRef *a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  while (1)
  {
    BOOL result = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a1, a2, 0, 0);
    if (!result) {
      break;
    }
    __C3DMeshRemoveSourceWithSemanticAtIndex(a1, a2, 0, 0);
  }
  return result;
}

void C3DMeshClearCPURepresentation(uint64_t a1)
{
  if (!a1)
  {
    char v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef v10 = *(const __CFArray **)(a1 + 64);
  if (v10)
  {
    CFIndex Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(v10, i);
        uint64_t v15 = (const void *)ValueAtIndex[9];
        if (v15 && (ValueAtIndex[11] & 4) == 0 && !ValueAtIndex[10])
        {
          CFRelease(v15);
          ValueAtIndex[9] = 0;
        }
      }
    }
  }
}

void C3DMeshCopySources(uint64_t a1, void *a2)
{
  __C3DMeshCopySources(a1, (uint64_t)a2, 0);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", a2, 0, 1u);
  ++a2[26];
}

void __C3DMeshCopySources(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  long long v22 = *(_OWORD *)(a1 + 72);
  *(_WORD *)(a2 + 88) = *(_WORD *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v22;
  long long v23 = *(_OWORD *)(a1 + 120);
  *(_WORD *)(a2 + 136) = *(_WORD *)(a1 + 136);
  *(_OWORD *)(a2 + 120) = v23;
  uint64_t v24 = *(const void **)(a2 + 64);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a2 + 64) = 0;
  }
  uint64_t v25 = *(const void **)(a2 + 112);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a2 + 112) = 0;
  }
  CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  *(void *)(a2 + 64) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, *(CFArrayRef *)(a1 + 64));
  CFArrayRef v27 = *(const __CFArray **)(a1 + 112);
  if (v27) {
    Mutableuint64_t Copy = CFArrayCreateMutableCopy(v26, 0, v27);
  }
  else {
    Mutableuint64_t Copy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a2 + 112) = MutableCopy;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  CFArrayRef v30 = *(const __CFArray **)(a1 + 112);
  if (v30)
  {
    CFIndex v31 = CFArrayGetCount(v30);
    if (!a3) {
      goto LABEL_23;
    }
  }
  else
  {
    CFIndex v31 = 0;
    if (!a3) {
      goto LABEL_23;
    }
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      uint64_t Copy = (const void *)C3DMeshSourceCreateCopy((uint64_t)ValueAtIndex);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 64), i, Copy);
      CFRelease(Copy);
    }
  }
  if (v31 >= 1)
  {
    for (CFIndex j = 0; j != v31; ++j)
    {
      uint64_t v36 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 112), j);
      uint64_t v37 = (const void *)C3DMeshSourceCreateCopy((uint64_t)v36);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 112), j, v37);
      CFRelease(v37);
    }
  }
LABEL_23:
  uint64_t v38 = *(const void **)(a1 + 104);
  free(*(void **)(a2 + 104));
  CFArrayRef v39 = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);
  *(void *)(a2 + 104) = v39;
  if (v38) {
    memcpy(v39, v38, Count);
  }
  CFIndex v40 = *(const void **)(a1 + 152);
  free(*(void **)(a2 + 152));
  CFNumberRef v41 = malloc_type_calloc(v31, 1uLL, 0x100004077774924uLL);
  *(void *)(a2 + 152) = v41;
  if (v40) {
    memcpy(v41, v40, v31);
  }
  *(_DWORD *)(a2 + 160) = *(_DWORD *)(a1 + 160);
  uint64_t v42 = *(unsigned int *)(a1 + 160);
  if (v42)
  {
    size_t v43 = 4 * v42;
    CFDictionaryRef v44 = malloc_type_realloc(*(void **)(a2 + 168), 4 * v42, 0xD55099CAuLL);
    *(void *)(a2 + 168) = v44;
    memcpy(v44, *(const void **)(a1 + 168), v43);
  }
  else
  {
    free(*(void **)(a2 + 168));
    *(void *)(a2 + 168) = 0;
  }
  if (*(void *)(a1 + 176))
  {
    SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
    size_t v46 = 4 * C3DMeshSourceGetCount((uint64_t)SourceWithSemanticAtIndex);
    CFNumberRef v47 = malloc_type_realloc(*(void **)(a2 + 176), v46, 0x992941DFuLL);
    *(void *)(a2 + 176) = v47;
    memcpy(v47, *(const void **)(a1 + 176), v46);
    if (!a3) {
      return;
    }
    goto LABEL_32;
  }
  free(*(void **)(a2 + 176));
  *(void *)(a2 + 176) = 0;
  if (a3) {
LABEL_32:
  }
    __C3DMeshFixAccessorLinks(a1, a2);
}

CFIndex C3DMeshUsesSameChannelForAllSources(uint64_t a1, void *a2)
{
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (result)
  {
    uint64_t v5 = *(unsigned __int8 **)(a1 + 104);
    uint64_t v6 = *v5;
    if (result < 2)
    {
LABEL_6:
      if (a2) {
        *a2 = v6;
      }
      return 1;
    }
    else
    {
      CFIndex v7 = result - 1;
      uint64_t v8 = v5 + 1;
      while (1)
      {
        int v9 = *v8++;
        if (v9 != v6) {
          return 0;
        }
        if (!--v7) {
          goto LABEL_6;
        }
      }
    }
  }
  return result;
}

void __C3DMeshCopyByAddingOriginalSourcesWithPositionChannel(uint64_t a1, uint64_t a2, const void **a3)
{
  if (!a2 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  long long v22 = *(const void **)(a1 + 64);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 64) = 0;
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, *(CFArrayRef *)(a2 + 64));
  *(void *)(a1 + 64) = MutableCopy;
  CFIndex Count = CFArrayGetCount(MutableCopy);
  memcpy(*(void **)(a1 + 104), *(const void **)(a2 + 104), Count);
  __int16 v25 = *(_WORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_WORD *)(a1 + 88) = v25;
  CFAllocatorRef v26 = *(const void **)(a1 + 96);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 96) = 0;
  }
  *(void *)(a1 + 96) = CFArrayCreateMutableCopy(allocator, 0, *(CFArrayRef *)(a2 + 96));
  char ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a2, 0, 0);
  uint64_t v28 = *a3;
  if (*a3)
  {
    int v29 = 0;
    char v30 = ChannelForSourceWithSemanticAtIndex;
    do
    {
      __C3DMeshAddSourceWithDataKind(a1, v28, v30, 0, 0);
      uint64_t v28 = a3[++v29];
    }
    while (v28);
  }
  CFIndex v31 = *(const void **)(a1 + 112);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 112) = 0;
  }
  CFArrayRef v32 = *(const __CFArray **)(a2 + 112);
  if (v32) {
    CFArrayRef Mutable = CFArrayCreateMutableCopy(allocator, 0, v32);
  }
  else {
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 112) = Mutable;
  if (*(void *)(a2 + 112)) {
    CFIndex v34 = CFArrayGetCount(Mutable);
  }
  else {
    CFIndex v34 = 0;
  }
  free(*(void **)(a1 + 152));
  *(void *)(a1 + 152) = malloc_type_calloc(v34, 1uLL, 0x100004077774924uLL);
  __int16 v35 = *(_WORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_WORD *)(a1 + 136) = v35;
  uint64_t v36 = *(const void **)(a1 + 144);
  if (v36)
  {
    CFRelease(v36);
    *(void *)(a1 + 144) = 0;
  }
  CFArrayRef v37 = *(const __CFArray **)(a2 + 144);
  if (v37) {
    CFMutableArrayRef v38 = CFArrayCreateMutableCopy(allocator, 0, v37);
  }
  else {
    CFMutableArrayRef v38 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 144) = v38;
  uint64_t v68 = 0;
  if (__C3DMeshHasSourceWithSemanticAtIndex(a2, 0, 0, 1, &v68))
  {
    unsigned int v39 = C3DMeshSourceGetCount(v68);
    CFIndex v40 = *a3;
    if (*a3)
    {
      int v41 = 0;
      uint64_t v42 = v39;
      CFAllocatorRef bytesDeallocator = (const __CFAllocator *)*MEMORY[0x263EFFB18];
      uint64_t v62 = a3;
      uint64_t v43 = 4 * v39;
      uint64_t v63 = a1;
      do
      {
        if (*(void *)(a2 + 168))
        {
          SemantiCC_SHA256_CTX c = C3DMeshSourceGetSemantic((uint64_t)v40);
          ComponentsCountPerCFDataRef Value = C3DMeshSourceGetComponentsCountPerValue((uint64_t)v40);
          Valuechar Type = C3DMeshSourceGetValueType((uint64_t)v40);
          Accessor = (void *)C3DMeshSourceGetAccessor(v40);
          Valuesize_t Length = C3DSourceAccessorGetValueLength((uint64_t)Accessor);
          CFIndex v46 = ValueLength * v42;
          CFNumberRef v47 = (const UInt8 *)malloc_type_malloc(ValueLength * v42, 0xFD373020uLL);
          CFNumberRef v48 = v47;
          uint64_t v49 = v42;
          if (v42)
          {
            uint64_t v50 = 0;
            CFNumberRef v51 = (UInt8 *)v47;
            do
            {
              ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(Accessor, *(unsigned int *)(*(void *)(a2 + 168) + v50));
              if (ValuePtrAtIndex) {
                memcpy(v51, ValuePtrAtIndex, ValueLength);
              }
              else {
                bzero(v51, ValueLength);
              }
              v50 += 4;
              v51 += ValueLength;
            }
            while (v43 != v50);
          }
          CFDataRef v53 = CFDataCreateWithBytesNoCopy(allocator, v48, v46, bytesDeallocator);
          uint64_t v42 = v49;
          CFNumberRef v54 = (const void *)C3DMeshSourceCreate(v53, Semantic, v49, ComponentsCountPerValue, ValueType);
          CFRelease(v53);
          a1 = v63;
          __C3DMeshAddSourceWithDataKind(v63, v54, 0, 0, 1);
          CFRelease(v54);
          a3 = v62;
        }
        else
        {
          __C3DMeshAddSourceWithDataKind(a1, v40, 0, 0, 1);
        }
        CFIndex v40 = a3[++v41];
      }
      while (v40);
    }
  }
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  size_t v55 = 4 * *(unsigned int *)(a2 + 160);
  free(*(void **)(a1 + 168));
  uint64_t v56 = malloc_type_malloc(v55, 0x4BEE6E77uLL);
  *(void *)(a1 + 168) = v56;
  memcpy(v56, *(const void **)(a2 + 168), v55);
  free(*(void **)(a1 + 176));
  *(void *)(a1 + 176) = 0;
  if (*(void *)(a2 + 176))
  {
    SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a2, 0, 0, 0);
    size_t v58 = 4 * C3DMeshSourceGetCount((uint64_t)SourceWithSemanticAtIndex);
    CFNumberRef v59 = malloc_type_malloc(v58, 0x8566F5E9uLL);
    *(void *)(a1 + 176) = v59;
    memcpy(v59, *(const void **)(a2 + 176), v58);
  }
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", (const void *)a1, 0, 1u);
  ++*(void *)(a1 + 208);
}

CFMutableArrayRef C3DMeshCopyRenderableSourceAndElements(uint64_t a1, uint64_t a2)
{
  if (!a2 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  C3DMeshBuildRenderableData(a2, 1);
  long long v20 = *(_OWORD *)(a2 + 120);
  *(_WORD *)(a1 + 88) = *(_WORD *)(a2 + 136);
  *(_OWORD *)(a1 + 72) = v20;
  long long v21 = *(_OWORD *)(a2 + 120);
  *(_WORD *)(a1 + 136) = *(_WORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v21;
  long long v22 = *(const void **)(a1 + 64);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 64) = 0;
  }
  long long v23 = *(const void **)(a1 + 112);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 112) = 0;
  }
  CFArrayRef v24 = *(const __CFArray **)(a2 + 112);
  __int16 v25 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
  if (v24) {
    Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, v24);
  }
  else {
    Mutableuint64_t Copy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 64) = MutableCopy;
  CFArrayRef v27 = *(const __CFArray **)(a2 + 112);
  if (v27) {
    CFArrayRef Mutable = CFArrayCreateMutableCopy(*v25, 0, v27);
  }
  else {
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 112) = Mutable;
  CFIndex Count = CFArrayGetCount(Mutable);
  free(*(void **)(a1 + 104));
  *(void *)(a1 + 104) = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);
  free(*(void **)(a1 + 152));
  *(void *)(a1 + 152) = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);
  char v30 = *(const void **)(a1 + 96);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 96) = 0;
  }
  CFIndex v31 = *(const void **)(a1 + 144);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 144) = 0;
  }
  CFArrayRef v32 = *(const __CFArray **)(a2 + 144);
  if (v32) {
    CFMutableArrayRef v33 = CFArrayCreateMutableCopy(*v25, 0, v32);
  }
  else {
    CFMutableArrayRef v33 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 96) = v33;
  CFArrayRef v34 = *(const __CFArray **)(a2 + 144);
  if (v34) {
    CFMutableArrayRef result = CFArrayCreateMutableCopy(*v25, 0, v34);
  }
  else {
    CFMutableArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB28], 0, MEMORY[0x263EFFF70]);
  }
  *(void *)(a1 + 144) = result;
  return result;
}

CFArrayRef C3DMeshCopyAllSources(uint64_t a1, int a2)
{
  v14[3] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    uint64_t v12 = (CFArrayRef *)(a1 + 112);
  }
  else
  {
    if (a2) {
      C3DMeshHasSourcesWithSemantic_cold_1((uint64_t)v14);
    }
    uint64_t v12 = (CFArrayRef *)(a1 + 64);
  }
  return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB28], *v12);
}

uint64_t C3DMeshMakeOriginalSourceMutable(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 && (C3DMeshSourceIsMutable(a2) & 1) != 0) {
    return v2;
  }
  uint64_t v4 = (char *)C3DMeshCreate();
  uint64_t v5 = 0;
  char v6 = 0;
  do
  {
    uint64_t v7 = a1 + 2 * v5;
    uint64_t v8 = *(unsigned __int8 *)(v7 + 73);
    if (*(unsigned char *)(v7 + 73))
    {
      for (uint64_t i = 0; v8 != i; ++i)
      {
        SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, (char)v5, i, 0);
        unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, (char)v5, i);
        if (v2)
        {
          if (SourceWithSemanticAtIndex == (const void *)v2) {
            goto LABEL_12;
          }
        }
        else if (!C3DMeshSourceIsMutable(SourceWithSemanticAtIndex) || !SourceWithSemanticAtIndex)
        {
LABEL_12:
          Mutableuint64_t Copy = (const void *)C3DMeshSourceCreateMutableCopy((uint64_t)SourceWithSemanticAtIndex);
          __C3DMeshSetSourceWithInputSetAndDataKind((uint64_t)v4, MutableCopy, i, ChannelForSourceWithSemanticAtIndex, 0);
          CFRelease(MutableCopy);
          if (v2) {
            uint64_t v2 = (uint64_t)MutableCopy;
          }
          else {
            uint64_t v2 = 0;
          }
          char v6 = 1;
          continue;
        }
        __C3DMeshSetSourceWithInputSetAndDataKind((uint64_t)v4, SourceWithSemanticAtIndex, i, ChannelForSourceWithSemanticAtIndex, 0);
      }
    }
    ++v5;
  }
  while (v5 != 9);
  if (v6)
  {
    __C3DMeshFixAccessorLinks(a1, (uint64_t)v4);
    for (uint64_t j = 0; j != 9; ++j)
    {
      uint64_t v14 = &v4[2 * j];
      uint64_t v15 = v14[73];
      if (v14[73])
      {
        uint64_t v16 = 0;
        do
        {
          uint64_t v17 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v4, (char)j, v16, 0);
          unsigned __int8 v18 = C3DMeshGetChannelForSourceWithSemanticAtIndex((uint64_t)v4, (char)j, v16);
          __C3DMeshSetSourceWithInputSetAndDataKind(a1, v17, v16++, v18, 0);
        }
        while (v15 != v16);
      }
    }
    CFRelease(v4);
    if (v2)
    {
      for (uint64_t k = 0; k != 9; ++k)
      {
        uint64_t v20 = a1 + 2 * k;
        uint64_t v21 = *(unsigned __int8 *)(v20 + 73);
        if (*(unsigned char *)(v20 + 73))
        {
          uint64_t v22 = 0;
          do
          {
            long long v23 = C3DMeshGetSourceWithSemanticAtIndex(a1, (char)k, v22, 0);
            if (C3DGenericSourcesHaveSharedData(v2, (uint64_t)v23)) {
              C3DGenericSourceMarkMutable((uint64_t)v23);
            }
            ++v22;
          }
          while (v21 != v22);
        }
      }
    }
    *(unsigned char *)(a1 + 200) |= 4u;
  }
  else
  {
    CFRelease(v4);
  }
  return v2;
}

void __C3DMeshFixAccessorLinks(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      uint64_t Accessor = C3DGenericSourceGetAccessor((uint64_t)ValueAtIndex);
      if (Accessor)
      {
        uint64_t v9 = *(const void **)(Accessor + 16);
        if (v9 != ValueAtIndex)
        {
          CFIndex v10 = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
          if (v10 < 1) {
            goto LABEL_15;
          }
          CFIndex v11 = v10;
          if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 0) == v9)
          {
            CFIndex v15 = 0;
          }
          else
          {
            CFIndex v12 = 1;
            while (1)
            {
              CFIndex v13 = v12;
              if (v11 == v12) {
                break;
              }
              uint64_t v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v12);
              CFIndex v12 = v13 + 1;
              if (v14 == v9)
              {
                CFIndex v15 = v13;
                goto LABEL_13;
              }
            }
            CFIndex v15 = 0;
LABEL_13:
            if (v13 >= v11)
            {
LABEL_15:
              if ((__C3DMeshFixAccessorLinks_done & 1) == 0)
              {
                __C3DMeshFixAccessorLinks_done = 1;
                uint64_t v19 = scn_default_log();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  __C3DMeshFixAccessorLinks_cold_1(&v20, v21, v19);
                }
              }
              continue;
            }
          }
          uint64_t v16 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), i);
          uint64_t v17 = C3DGenericSourceGetAccessor((uint64_t)v16);
          unsigned __int8 v18 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), v15);
          C3DSourceAccessorSetSource(v17, (uint64_t)v18);
        }
      }
    }
  }
}

uint64_t C3DMeshGetPositionDeindexedToOriginalTable(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 160);
  }
  return *(void *)(a1 + 168);
}

uint64_t C3DMeshGetPositionOriginalToFirstDeindexedTable(uint64_t a1)
{
  return *(void *)(a1 + 176);
}

CFIndex C3DMeshGetIndexOfElement(uint64_t a1, const void *a2, int a3)
{
  if (!a1)
  {
    char v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!*(void *)(a1 + 96))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshGetElementAtIndex_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (a3 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v22.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
    CFArrayRef v23 = *(const __CFArray **)(a1 + 144);
    goto LABEL_11;
  }
  if (!a3)
  {
    v22.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
    CFArrayRef v23 = *(const __CFArray **)(a1 + 96);
LABEL_11:
    v22.locatioint n = 0;
    return CFArrayGetFirstIndexOfValue(v23, v22, a2);
  }
  __int16 v25 = scn_default_log();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
    C3DMeshGetIndexOfElement_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
  }
  return -1;
}

uint64_t C3DMeshGetMeshElements(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    return *(void *)(a1 + 144);
  }
  else if (a2)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      C3DMeshGetMeshElements_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
    return 0;
  }
  else
  {
    return *(void *)(a1 + 96);
  }
}

void C3DMeshSetMeshElements(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 96);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 96) = 0;
    }
    if (cf)
    {
      CFAllocatorRef v13 = CFGetAllocator(cf);
      *(void *)(a1 + 96) = CFArrayCreateMutableCopy(v13, 0, (CFArrayRef)cf);
    }
    *(unsigned char *)(a1 + 200) &= ~2u;
    __C3DMeshInvalidateRenderableData(a1);
  }
}

void C3DMeshRemoveAllElements(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 200) &= ~2u;
  __C3DMeshInvalidateRenderableData(a1);
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 96));
}

void C3DMeshSetOriginalElementType(uint64_t a1, uint64_t a2)
{
  ElementsCFIndex Count = C3DMeshGetElementsCount(a1);
  if ((uint64_t)ElementsCount < 1) {
    return;
  }
  CFArrayRef v5 = ElementsCount;
  CFIndex v6 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  while (1)
  {
    ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, v6, 1);
    if ((int)C3DMeshElementGetType((uint64_t)ElementAtIndex) != a2) {
      break;
    }
LABEL_27:
    if ((const __CFArray *)++v6 == v5) {
      return;
    }
  }
  if ((unint64_t)(a2 - 4) > 0xFFFFFFFFFFFFFFFDLL)
  {
    if (C3DMeshElementGetType((uint64_t)ElementAtIndex))
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 size_4 = 0;
        _os_log_impl(&dword_20B249000, v8, OS_LOG_TYPE_DEFAULT, "Warning: Can only convert from triangle array to another element type", (uint8_t *)&size_4, 2u);
      }
      goto LABEL_27;
    }
    unsigned int size = 0;
    CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, &size);
    PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
    if (size == 2)
    {
      BytePtr = CFDataGetBytePtr(Indexes);
      if (a2 != 3)
      {
        if (a2 == 2)
        {
          int v23 = 3 * PrimitiveCount;
          uint64_t v12 = 6 * PrimitiveCount;
          CFAllocatorRef v13 = (UInt8 *)malloc_type_calloc(6 * PrimitiveCount, size, 0xA5C2A6B3uLL);
          uint64_t v16 = v13;
          if (PrimitiveCount >= 1)
          {
            do
            {
              *(_WORD *)uint64_t v16 = *(_WORD *)BytePtr;
              *((_WORD *)v16 + 1) = *((_WORD *)BytePtr + 1);
              *((_WORD *)v16 + 2) = *((_WORD *)BytePtr + 1);
              *((_WORD *)v16 + 3) = *((_WORD *)BytePtr + 2);
              *((_WORD *)v16 + 4) = *((_WORD *)BytePtr + 2);
              __int16 v17 = *(_WORD *)BytePtr;
              BytePtr += 6;
              *((_WORD *)v16 + 5) = v17;
              v16 += 12;
              --PrimitiveCount;
            }
            while (PrimitiveCount);
          }
          goto LABEL_24;
        }
        goto LABEL_26;
      }
    }
    else if (size == 1)
    {
      BytePtr = CFDataGetBytePtr(Indexes);
      if (a2 != 3)
      {
        if (a2 == 2)
        {
          int v23 = 3 * PrimitiveCount;
          uint64_t v12 = 6 * PrimitiveCount;
          CFAllocatorRef v13 = (UInt8 *)malloc_type_calloc(6 * PrimitiveCount, size, 0x1B8307DFuLL);
          uint64_t v14 = v13;
          if (PrimitiveCount >= 1)
          {
            do
            {
              *uint64_t v14 = *BytePtr;
              v14[1] = BytePtr[1];
              void v14[2] = BytePtr[1];
              v14[3] = BytePtr[2];
              void v14[4] = BytePtr[2];
              UInt8 v15 = *BytePtr;
              BytePtr += 3;
              v14[5] = v15;
              v14 += 6;
              --PrimitiveCount;
            }
            while (PrimitiveCount);
          }
LABEL_24:
          CFDataRef v20 = CFDataCreate(allocator, v13, v12 * size);
          C3DMeshElementInit((uint64_t)ElementAtIndex, 2, v23, v20, size);
          CFRelease(v20);
          free(v13);
          goto LABEL_26;
        }
        goto LABEL_26;
      }
    }
    else
    {
      BytePtr = CFDataGetBytePtr(Indexes);
      if (a2 != 3)
      {
        if (a2 == 2)
        {
          int v23 = 3 * PrimitiveCount;
          uint64_t v12 = 6 * PrimitiveCount;
          CFAllocatorRef v13 = (UInt8 *)malloc_type_calloc(6 * PrimitiveCount, size, 0x486EC831uLL);
          uint64_t v18 = v13;
          if (PrimitiveCount >= 1)
          {
            do
            {
              *(_DWORD *)uint64_t v18 = *(_DWORD *)BytePtr;
              *((_DWORD *)v18 + 1) = *((_DWORD *)BytePtr + 1);
              *((_DWORD *)v18 + 2) = *((_DWORD *)BytePtr + 1);
              *((_DWORD *)v18 + 3) = *((_DWORD *)BytePtr + 2);
              *((_DWORD *)v18 + 4) = *((_DWORD *)BytePtr + 2);
              int v19 = *(_DWORD *)BytePtr;
              BytePtr += 12;
              *((_DWORD *)v18 + 5) = v19;
              v18 += 24;
              --PrimitiveCount;
            }
            while (PrimitiveCount);
          }
          goto LABEL_24;
        }
LABEL_26:
        __C3DMeshInvalidateRenderableData(a1);
        goto LABEL_27;
      }
    }
    CFDataRef v21 = CFDataCreate(allocator, BytePtr, 3 * PrimitiveCount * size);
    C3DMeshElementInit((uint64_t)ElementAtIndex, 3, 3 * PrimitiveCount, v21, size);
    CFRelease(v21);
    goto LABEL_26;
  }
  CFRange v22 = scn_default_log();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_20B249000, v22, OS_LOG_TYPE_DEFAULT, "Warning: Can only convert to lines or points element type", buf, 2u);
  }
}

uint64_t C3DMeshGetMorphableSourceMask(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 200) >> 3) & 0xF;
}

void C3DMeshMarkMutable(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 200) |= 4u;
}

void C3DMeshDidMutate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(void *)(a1 + 216);
}

uint64_t C3DMeshGetMutabilityTimeStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 216);
}

uint64_t C3DMeshIsVolatile(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned char *)(a1 + 200) & 1;
}

uint64_t C3DMeshGetLayoutTimeStamp(uint64_t a1)
{
  return *(void *)(a1 + 208);
}

BOOL __processTrianglesBatch(float32x4_t *a1, unsigned int a2, unsigned int a3, float32x4_t a4, float a5, float32x4_t a6, double a7, double a8, __n128 a9, __n128 a10)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  unsigned int v10 = a3 - a2;
  if (a3 <= a2)
  {
    return 0;
  }
  else
  {
    uint64_t v12 = a1[3].i64[1];
    int v13 = a1[4].u8[5];
    uint64_t v14 = a2;
    int v62 = a1[4].u8[6];
    int v15 = a1[4].u8[4];
    unint64_t v61 = a3;
    a4.i64[0] = 67109120;
    BOOL v16 = 1;
    do
    {
      int v17 = a1[1].u8[10];
      if (a1[1].i8[10])
      {
        if (v14) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = 2;
        }
        if (v14) {
          uint64_t v19 = 2;
        }
        else {
          uint64_t v19 = 1;
        }
        uint64_t v20 = v17 != 5;
        BOOL v21 = v17 == 1;
        if (v17 == 1) {
          uint64_t v20 = 1;
        }
        uint64_t v22 = 1;
        if (v17 == 1) {
          uint64_t v23 = v18;
        }
        else {
          uint64_t v23 = 2;
        }
        if (v21) {
          uint64_t v24 = v19;
        }
        else {
          uint64_t v24 = 1;
        }
      }
      else
      {
        uint64_t v20 = 3;
        uint64_t v22 = 3;
        uint64_t v23 = 2;
        uint64_t v24 = 1;
      }
      uint64_t v25 = a1->i64[0];
      if (a1->i64[0])
      {
        int v26 = a1[1].u8[11];
        uint64_t v27 = a1[2].i64[1];
        uint64_t v28 = a1[3].i64[0];
        switch(v26)
        {
          case 4:
            int v29 = *(_DWORD *)(v25 + 4 * (v27 + v28 * v14 * v20));
            uint64_t v34 = v22 * v14;
            int v31 = *(_DWORD *)(v25 + 4 * (v27 + (v24 + v34) * v28));
            int v32 = *(_DWORD *)(v25 + 4 * (v27 + (v34 + v23) * v28));
            break;
          case 2:
            int v29 = *(unsigned __int16 *)(v25 + 2 * (v27 + v28 * v14 * v20));
            uint64_t v35 = v22 * v14;
            int v31 = *(unsigned __int16 *)(v25 + 2 * (v27 + (v24 + v35) * v28));
            int v32 = *(unsigned __int16 *)(v25 + 2 * (v27 + (v35 + v23) * v28));
            break;
          case 1:
            int v29 = *(unsigned __int8 *)(v25 + v27 + v28 * v14 * v20);
            uint64_t v30 = v22 * v14;
            int v31 = *(unsigned __int8 *)(v25 + v27 + (v24 + v30) * v28);
            int v32 = *(unsigned __int8 *)(v25 + v27 + (v30 + v23) * v28);
            break;
          default:
            uint64_t v36 = scn_default_log();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              int v64 = v26;
              _os_log_error_impl(&dword_20B249000, v36, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
            }
            int v32 = 0;
            int v31 = 0;
            int v29 = 0;
            break;
        }
      }
      else
      {
        int v29 = v14 * v20;
        int v33 = v22 * v14;
        int v31 = v24 + v33;
        int v32 = v33 + v23;
      }
      uint64_t v37 = v12 + (v29 * v13);
      if (v62 == 1)
      {
        a9.n128_u64[0] = *(void *)v37;
        a9.n128_u32[2] = *(_DWORD *)(v37 + 8);
        uint64_t v38 = v12 + (v31 * v13);
        a10.n128_u64[0] = *(void *)v38;
        a10.n128_u32[2] = *(_DWORD *)(v38 + 8);
        uint64_t v39 = v12 + (v32 * v13);
        a4.i64[0] = *(void *)v39;
        a4.i32[2] = *(_DWORD *)(v39 + 8);
      }
      else
      {
        *(double *)v40.i64 = C3DConvertFloatingTypeToFloat4(v15, (float *)v37, a4, a5, a6.f32[0]);
        __n128 v60 = (__n128)v40;
        *(double *)v43.i64 = C3DConvertFloatingTypeToFloat4(v15, (float *)(v12 + (v31 * v13)), v40, v41, v42);
        __n128 v59 = (__n128)v43;
        *(double *)a4.i64 = C3DConvertFloatingTypeToFloat4(v15, (float *)(v12 + (v32 * v13)), v43, v44, v45);
        a10 = v59;
        a9 = v60;
      }
      float32x4_t v46 = (float32x4_t)a10;
      v46.i32[3] = 0;
      float32x4_t v47 = a4;
      v47.i32[3] = 0;
      float32x4_t v48 = vminnmq_f32(v46, v47);
      float32x4_t v49 = (float32x4_t)a9;
      v49.i32[3] = 0;
      v48.i32[3] = 0;
      float32x4_t v50 = vminnmq_f32(v49, v48);
      float32x4_t v51 = vmaxnmq_f32(v46, v47);
      v51.i32[3] = 0;
      float32x4_t v52 = vmaxnmq_f32(v49, v51);
      v49.i64[0] = 0x3F0000003F000000;
      v49.i64[1] = 0x3F0000003F000000;
      float32x4_t v53 = vmulq_f32(vaddq_f32(v50, v52), v49);
      v53.i32[3] = 1.0;
      float32x4_t v54 = vmulq_f32(vsubq_f32(v52, v50), v49);
      v54.i32[3] = 0;
      a6 = vabdq_f32(a1[5], v53);
      uint32x4_t v55 = (uint32x4_t)vcgeq_f32(vaddq_f32(a1[6], v54), a6);
      v55.i32[3] = v55.i32[2];
      a5 = COERCE_FLOAT(vminvq_u32(v55));
      if ((LODWORD(a5) & 0x80000000) != 0)
      {
        unsigned __int32 v56 = a1[200].u32[0];
        a1[200].i32[0] = v56 + 1;
        CFNumberRef v57 = (__n128 *)&a1[3 * v56];
        v57[8] = a9;
        v57[9] = a10;
        v57[10] = (__n128)a4;
        if (a1[200].i32[0] == 64)
        {
          a1[200].i32[0] = 0;
          if ((*(uint64_t (**)(void))(a1[7].i64[0] + 16))()) {
            break;
          }
        }
      }
      BOOL v16 = ++v14 < v61;
      --v10;
    }
    while (v10);
  }
  return v16;
}

uint64_t C3DMeshQueryTrianglesIntersectingBox(uint64_t a1, uint64_t a2, float32x4_t a3, float32x4_t a4)
{
  SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
  uint64_t result = C3DMeshSourceGetCount((uint64_t)SourceWithSemanticAtIndex);
  if (result)
  {
    uint64_t result = (uint64_t)C3DMeshGetElementsCount(a1);
    if (result)
    {
      uint64_t v8 = result;
      memset(v46, 0, 384);
      long long v45 = 0u;
      long long v42 = 0u;
      float32x4_t v39 = 0u;
      uint64_t v40 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      uint64_t result = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
      uint64_t v41 = result;
      *(void *)&long long v42 = v9;
      float32x4_t v43 = a3;
      float32x4_t v44 = a4;
      int v47 = 0;
      *(void *)&long long v45 = a2;
      if (v8 >= 1)
      {
        for (CFIndex i = 0; i != v8; ++i)
        {
          ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, i, 0);
          C3DMeshElementGetContent((uint64_t)ElementAtIndex, 0, (uint64_t)&v33);
          long long v37 = v33;
          long long v38 = v34;
          float32x4_t v39 = v35;
          uint64_t v40 = v36;
          if (DWORD2(v33) < 0x101)
          {
            uint64_t result = __processTrianglesBatch((float32x4_t *)&v37, 0, DWORD2(v33), v35, *(float *)&v34, v12, v13, v14, v15, v16);
            if (result) {
              return result;
            }
          }
          else
          {
            unsigned int v32 = 0;
            long long v33 = v37;
            long long v34 = v38;
            float32x4_t v35 = v39;
            uint64_t v36 = v40;
            uint64_t result = C3DMeshElementGetPrimitiveGroupBoundingBoxes((uint64_t)ElementAtIndex, &v33, v41, v42, &v32);
            unint64_t v20 = v32;
            if (v32)
            {
              uint64_t v21 = result;
              uint64_t v22 = 0;
              for (unint64_t j = 0; j < v20; ++j)
              {
                float32x4_t v24 = *(float32x4_t *)(v21 + v22);
                float32x4_t v25 = *(float32x4_t *)(v21 + v22 + 16);
                float32x4_t v26 = vaddq_f32(v44, v25);
                float32x4_t v27 = (float32x4_t)vcgeq_f32(v26, vabdq_f32(v43, v24));
                v27.i32[3] = v27.i32[2];
                v27.i32[0] = vminvq_u32((uint32x4_t)v27);
                uint64_t v28 = v22 + 32;
                if (v27.i32[0] < 0)
                {
                  if (v28 >= DWORD2(v37)) {
                    unsigned int v29 = DWORD2(v37);
                  }
                  else {
                    unsigned int v29 = v22 + 32;
                  }
                  uint64_t result = __processTrianglesBatch((float32x4_t *)&v37, v22, v29, v27, v26.f32[0], v24, *(double *)v25.i64, v17, v18, v19);
                  if (result) {
                    return result;
                  }
                  unint64_t v20 = v32;
                }
                uint64_t v22 = v28;
              }
            }
          }
        }
        if (v47) {
          return (*(uint64_t (**)(uint64_t, unsigned char *))(a2 + 16))(a2, v46);
        }
      }
    }
  }
  return result;
}

id _C3DMeshCFFinalize(uint64_t a1)
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshWillDie", (const void *)a1, 0, 1u);
  ++*(void *)(a1 + 208);
  uint64_t v3 = *(const void **)(a1 + 96);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 64);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 144);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 112);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 112) = 0;
  }
  free(*(void **)(a1 + 104));
  free(*(void **)(a1 + 152));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  uint64_t v7 = *(void **)(a1 + 192);
  if (v7) {
    free(v7);
  }
  uint64_t v8 = *(void **)(a1 + 184);
  if (v8) {
    free(v8);
  }

  return C3DEntityCFFinalize(a1);
}

__CFString *_C3DMeshCFCopyDebugDescription(uint64_t a1)
{
  CFArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t Name = C3DEntityGetName(a1);
  CFStringAppendFormat(Mutable, 0, @"<C3DMesh %p \"%@\"\n", a1, Name);
  if ((uint64_t)C3DMeshGetElementsCount(a1) >= 1)
  {
    CFIndex v4 = 0;
    do
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a1, v4, 0);
      CFStringAppendFormat(Mutable, 0, @"  element%d: %@\n", v4++, ElementAtIndex);
    }
    while (v4 < (uint64_t)C3DMeshGetElementsCount(a1));
  }
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 0x40000000;
  void v10[2] = ___C3DMeshCFCopyDebugDescription_block_invoke;
  v10[3] = &__block_descriptor_tmp_45_1;
  void v10[4] = Mutable;
  C3DMeshApplySources(a1, 0, (uint64_t)v10);
  if (*(void *)(a1 + 112))
  {
    if ((uint64_t)C3DMeshGetElementsCount(a1) >= 1)
    {
      CFIndex v6 = 0;
      do
      {
        uint64_t v7 = C3DMeshGetElementAtIndex(a1, v6, 1);
        CFStringAppendFormat(Mutable, 0, @"  renderable element%d: %@\n", v6++, v7);
      }
      while (v6 < (uint64_t)C3DMeshGetElementsCount(a1));
    }
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 0x40000000;
    v9[2] = ___C3DMeshCFCopyDebugDescription_block_invoke_2;
    void v9[3] = &__block_descriptor_tmp_55;
    void v9[4] = Mutable;
    C3DMeshApplySources(a1, 1, (uint64_t)v9);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

uint64_t _C3DMeshInitWithPropertyList(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    CFIndex v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = C3DEntityInitWithPropertyList(a1, a2);
  if (v12)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"baseSourceLocators");
    if (Value)
    {
      CFArrayRef v14 = Value;
      *(unsigned char *)(a1 + 200) &= 0x87u;
      CFIndex Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        CFIndex v16 = Count;
        for (CFIndex i = 0; i != v16; ++i)
        {
          uint64_t valuePtr = 0;
          ValueAtuint64_t Index = (const __CFNumber *)CFArrayGetValueAtIndex(v14, i);
          if (!CFNumberGetValue(ValueAtIndex, kCFNumberCFIndexType, &valuePtr)
            && (_C3DMeshInitWithPropertyList_done & 1) == 0)
          {
            _C3DMeshInitWithPropertyList_done = 1;
            __n128 v19 = scn_default_log();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              CFDictionaryRef v32 = a2;
              _os_log_error_impl(&dword_20B249000, v19, OS_LOG_TYPE_ERROR, "Error: Could not deserialize a source locator in %@", buf, 0xCu);
            }
          }
          *(unsigned char *)(a1 + 200) |= 8 * ((1 << SBYTE1(valuePtr)) & 0xF);
        }
      }
    }
    else
    {
      CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(a2, @"verticesMask");
      if (v29)
      {
        *(_DWORD *)long long buf = 0;
        CFNumberGetValue(v29, kCFNumberIntType, buf);
        *(unsigned char *)(a1 + 200) = (8 * (buf[0] & 0xF)) | *(unsigned char *)(a1 + 200) & 0x87;
      }
    }
  }
  else
  {
    unint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      _C3DMeshInitWithPropertyList_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    }
  }
  return v12;
}

__CFDictionary *_C3DMeshCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&v68[5] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DCreateTangentsWithGeometryOptimized_cold_8(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFIndex v16 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  double v17 = v16;
  if (v16)
  {
    uint64_t v56 = a3;
    uint64_t v57 = a4;
    size_t v58 = v16;
    __n128 v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
    __n128 v19 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
    CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    theDict = CFDictionaryCreateMutable(0, 0, v18, v19);
    uint64_t v21 = CFDictionaryCreateMutable(0, 0, v18, v19);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
        unsigned int EntryID = C3DLibraryGetEntryID(a2, ValueAtIndex);
        int v26 = (int)EntryID;
        if ((unint64_t)EntryID >> 31)
        {
          uint64_t v27 = scn_default_log();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
            _C3DMeshCopyPropertyList_cold_3(v65, &v66, v27);
          }
        }
        int valuePtr = v26;
        CFNumberRef v28 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v21, ValueAtIndex, v28);
        if (C3DGenericSourceIsPrimary((uint64_t)ValueAtIndex))
        {
          CFNumberRef v29 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
          CFMutableArrayRef v30 = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
          CFMutableArrayRef v31 = CFArrayCreateMutable(0, 0, v29);
          CFDictionaryAddValue(Mutable, ValueAtIndex, v30);
          CFDictionaryAddValue(theDict, ValueAtIndex, v31);
          CFRelease(v30);
          CFRelease(v31);
          URL = ValueAtIndex;
        }
        else
        {
          uint64_t Accessor = C3DGenericSourceGetAccessor((uint64_t)ValueAtIndex);
          URL = (const void *)C3DSceneSourceGetURL(Accessor);
        }
        if (!C3DGenericSourceIsPrimary((uint64_t)URL))
        {
          long long v34 = scn_default_log();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
            _C3DMeshCopyPropertyList_cold_2(v63, &v64, v34);
          }
        }
        CFArrayRef Value = (__CFArray *)CFDictionaryGetValue(Mutable, URL);
        uint64_t v36 = (__CFArray *)CFDictionaryGetValue(theDict, URL);
        long long v37 = (const void *)C3DGenericSourceGetAccessor((uint64_t)ValueAtIndex);
        CFArrayAppendValue(Value, v37);
        CFArrayAppendValue(v36, v28);
        CFRelease(v28);
      }
    }
    CFDictionaryRef v60 = Mutable;
    long long v38 = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    __n128 v59 = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (Count >= 1)
    {
      for (CFIndex j = 0; j != Count; ++j)
      {
        uint64_t v40 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), j);
        uint64_t v41 = CFDictionaryGetValue(v21, v40);
        CFArrayAppendValue(v38, v41);
        if (C3DGenericSourceIsPrimary((uint64_t)v40))
        {
          long long v42 = CFDictionaryGetValue(theDict, v40);
          CFArrayRef v43 = (const __CFArray *)CFDictionaryGetValue(v60, v40);
          if (!v40)
          {
            float32x4_t v44 = scn_default_log();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
              _C3DMeshCopyPropertyList_cold_1((uint8_t *)&valuePtr, v68, v44);
            }
          }
          CFDataRef SerializedDataWithAccessors = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v40, v43);
          float32x4_t v46 = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
          CFDictionaryAddValue(v46, @"data", SerializedDataWithAccessors);
          CFDictionaryAddValue(v46, @"subIDs", v42);
          CFStringRef v47 = CFStringCreateWithFormat(0, 0, @"%@", v41);
          CFDictionaryAddValue(v59, v47, v46);
          CFRelease(v47);
          CFRelease(SerializedDataWithAccessors);
          CFRelease(v46);
        }
      }
    }
    double v17 = v58;
    CFDictionarySetValue(v58, @"sources", v38);
    CFDictionarySetValue(v58, @"primarySourcesInfo", v59);
    CFRelease(v38);
    CFRelease(v59);
    CFRelease(theDict);
    CFRelease(v60);
    CFRelease(v21);
    float32x4_t v48 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
    CFIndex v49 = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
    if (v49 >= 1)
    {
      CFIndex v50 = v49;
      for (CFIndex k = 0; k != v50; ++k)
      {
        float32x4_t v52 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), k);
        float32x4_t v53 = (const void *)C3DCopyPropertyList(v52, 0, v56, v57);
        CFArrayAppendValue(v48, v53);
        CFRelease(v53);
      }
    }
    CFDictionarySetValue(v58, @"geometryElements", v48);
    CFRelease(v48);
    int v62 = (*(unsigned __int8 *)(a1 + 200) >> 3) & 0xF;
    CFNumberRef v54 = CFNumberCreate(0, kCFNumberIntType, &v62);
    CFDictionarySetValue(v58, @"verticesMask", v54);
    CFRelease(v54);
  }
  return v17;
}

uint64_t _C3DMeshFillLibraryForSerialization(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (result >= 1)
  {
    uint64_t v5 = result;
    for (CFIndex i = 0; i != v5; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      uint64_t result = (uint64_t)C3DLibraryAddEntry(a2, ValueAtIndex);
    }
  }
  return result;
}

__CFArray *_C3DMeshCopyInstanceVariables(uint64_t a1)
{
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFIndex v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v5, @"name", @"sources");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v23 = 0;
  int valuePtr = 5;
  uint64_t v22 = a1 + 184;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v9, @"name", @"boundingSphere");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 0;
  int valuePtr = 5;
  uint64_t v22 = a1 + 192;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v13, @"name", @"boundingBox");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  double v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 96;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v17, @"name", @"meshElements");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  return Mutable;
}

uint64_t _C3DMeshSearchByID(uint64_t a1, const void *a2)
{
  uint64_t ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void OUTLINED_FUNCTION_3_3(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_error_impl(a1, v5, OS_LOG_TYPE_ERROR, a4, v4, 0xCu);
}

BOOL OUTLINED_FUNCTION_6_2(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_ERROR);
}

void C3D::MBNeighborMaxPass::MBNeighborMaxPass(C3D::MBNeighborMaxPass *this, RenderGraph *a2, C3D::Pass *a3, char a4)
{
  C3D::ComputePass::ComputePass(this, a2, a3);
  *(void *)uint64_t v5 = &unk_26BF6DA50;
  *(unsigned char *)(v5 + 120) = a4;
}

const char *C3D::MBNeighborMaxPass::name(C3D::MBNeighborMaxPass *this)
{
  return "MBNeighborMaxPass";
}

float C3D::MBNeighborMaxPass::setup(C3D::MBNeighborMaxPass *this)
{
  C3D::Pass::setInputCount(this, 1u);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = (C3D::MBNeighborMaxPass *)((char *)this + 32);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::MBNeighborMaxPass *)((char *)this + 32), 0) + 8) = "MB-TileMax";
  uint64_t v3 = (*(uint64_t (**)(C3D::MBNeighborMaxPass *))(*(void *)this + 88))(this);
  uint64_t v4 = C3D::PassDescriptor::outputAtIndex(v2, 0);
  *(void *)(v4 + 8) = "MB-TileMax";
  *(_WORD *)(v4 + 16) = (int)(float)(*(float *)(v3 + 8) * 0.015625);
  float result = *(float *)(v3 + 12) * 0.015625;
  *(_WORD *)(v4 + 18) = (int)result;
  *(_WORD *)(v4 + 28) = 115;
  return result;
}

uint64_t C3D::MBNeighborMaxPass::compile(C3D::MBNeighborMaxPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = *(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128);
  uint64_t v4 = (*(uint64_t (**)(C3D::MBNeighborMaxPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(v3, v4);
  *((void *)this + 14) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::MBNeighborMaxPass::execute(uint64_t a1, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  if ((void **)v3->_textures[0] != v4)
  {
    v3->_textures[0] = (MTLTexture *)v4;
    v3->_texturesToBind[0] |= 1uLL;
  }
  uint64_t v5 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  if (v3->_textures[1] != v5)
  {
    v3->_textures[1] = v5;
    v3->_texturesToBind[0] |= 2uLL;
  }
  int v6 = *(unsigned __int8 *)(a1 + 120);
  CFNumberRef v7 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = v8 + 16;
  uint64_t v10 = v8 + 24;
  if (v6) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = v9;
  }
  uint64_t v12 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v11);
  uint64_t v13 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v12);

  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v7, v13);
}

void C3D::MBNeighborMaxPassResource::~MBNeighborMaxPassResource(C3D::MBNeighborMaxPassResource *this)
{
  *(void *)this = &unk_26BF6E530;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E530;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

const char *C3D::TemporalAAPass::name(C3D::TemporalAAPass *this)
{
  return "TemporalAA";
}

void C3D::TemporalAAPass::setup(C3D::TemporalAAPass *this)
{
  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 0);
  *(void *)(v2 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v4);
  *(_OWORD *)(v2 + 16) = v4;
  *(_DWORD *)(v2 + 32) = v5;
  *(unsigned char *)(v2 + 31) = 0;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 1u) + 8) = "VELOCITY";
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 2u) + 64) = 2;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 2u) + 8) = "DEPTH";
  uint64_t v3 = C3D::PassDescriptor::outputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 0);
  *(void *)(v3 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v4);
  *(_OWORD *)(v3 + 16) = v4;
  *(_DWORD *)(v3 + 32) = v5;
  if (*(_WORD *)(v3 + 28) == 81) {
    *(_WORD *)(v3 + 28) = 80;
  }
  *((unsigned char *)this + 121) = 0;
}

uint64_t C3D::TemporalAAPass::compile(C3D::TemporalAAPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = C3D::PassDescriptor::outputAtIndex((C3D::TemporalAAPass *)((char *)this + 32), 0);
  *((unsigned char *)this + 120) = (-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](RenderContext) & 1) == 0;
  unint64_t v4 = *(int *)(v3 + 16) | ((unint64_t)*(unsigned __int16 *)(v3 + 28) << 32);
  unint64_t v5 = 0xC6A4A7935BD1E995
     * (C3D::Pass::hashName(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995
                                                          * ((0xC6A4A7935BD1E995 * v4) ^ ((0xC6A4A7935BD1E995 * v4) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47));
  *((void *)this + 14) = result;
  if (!result)
  {
    *((unsigned char *)this + 121) = 1;
    operator new();
  }
  return result;
}

void *C3D::TemporalAAPass::execute(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t result = C3DEngineContextGetPointOfView(*(void *)(a1 + 16));
  if (result)
  {
    uint64_t result = C3DNodeGetCamera((uint64_t)result);
    if (result)
    {
      uint64_t v5 = (uint64_t)result;
      ViewportAtuint64_t Index = C3DEngineContextGetViewportAtIndex(*(void *)(a1 + 16), *(unsigned __int16 *)(a2 + 8));
      int v6 = *(SCNMTLComputeCommandEncoder **)a2;
      CFNumberRef v7 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
      if ((void **)v6->_textures[0] != v7)
      {
        v6->_textures[0] = (MTLTexture *)v7;
        v6->_texturesToBind[0] |= 1uLL;
      }
      uint64_t v8 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
      if ((void **)v6->_textures[1] != v8)
      {
        v6->_textures[1] = (MTLTexture *)v8;
        v6->_texturesToBind[0] |= 2uLL;
      }
      uint64_t v9 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 2u);
      if ((void **)v6->_textures[2] != v9)
      {
        v6->_textures[2] = (MTLTexture *)v9;
        v6->_texturesToBind[0] |= 4uLL;
      }
      uint64_t v10 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*(void *)(a1 + 112) + 8 * (*(unsigned char *)(a1 + 120) == 0) + 16);
      if (v6->_textures[3] != (MTLTexture *)v10)
      {
        v6->_textures[3] = (MTLTexture *)v10;
        v6->_texturesToBind[0] |= 8uLL;
      }
      uint64_t v11 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*(void *)(a1 + 112) + 8 * *(unsigned __int8 *)(a1 + 120) + 16);
      if (v6->_textures[4] != (MTLTexture *)v11)
      {
        v6->_textures[4] = (MTLTexture *)v11;
        v6->_texturesToBind[0] |= 0x10uLL;
      }
      uint64_t v12 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
      if (v6->_textures[5] != v12)
      {
        v6->_textures[5] = v12;
        v6->_texturesToBind[0] |= 0x20uLL;
      }
      uint64_t v13 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(a1 + 32), 0);
      float32x2_t TAAJitter = C3DEngineContextGetTAAJitter(*(float32x2_t **)(a1 + 16), 0);
      unsigned int v15 = *(unsigned __int16 *)(v13 + 16);
      v16.f32[0] = (float)v15;
      unsigned int v17 = *(unsigned __int16 *)(v13 + 18);
      v16.f32[1] = (float)v17;
      *(float *)&uint64_t v18 = 1.0 / (double)v15;
      float v19 = 1.0 / (double)v17;
      *((float *)&v18 + 1) = v19;
      v34[0] = vmul_f32(vmul_f32(TAAJitter, (float32x2_t)0xBF0000003F000000), v16);
      v34[1] = v18;
      MotionBlurfloat Intensity = C3DCameraGetMotionBlurIntensity(v5);
      if (MotionBlurIntensity <= 0.0) {
        float v21 = 1.0;
      }
      else {
        float v21 = 1.0 / MotionBlurIntensity;
      }
      float v36 = v21;
      char v35 = *(unsigned char *)(a1 + 121);
      SCNMTLComputeCommandEncoder::setBytes(v6, v34, 0x20uLL, 0);
      uint64_t v22 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*(void *)(a1 + 112) + 40);
      int v23 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v22);
      __asm { FMOV            V1.2S, #16.0 }
      float32x2_t v29 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)ViewportAtIndex, (int8x16_t)ViewportAtIndex, 8uLL), _D1);
      __asm { FMOV            V1.2S, #-1.0 }
      *(uint64x2_t *)&v33.width = vcvtq_u64_f64(vcvtq_f64_f32(vmul_f32(vadd_f32(v29, _D1), (float32x2_t)vdup_n_s32(0x3D800000u))));
      v33.depth = 1;
      *(int64x2_t *)&v32.width = vdupq_n_s64(0x10uLL);
      v32.depth = 1;
      return (void *)SCNMTLComputeCommandEncoder::dispatch(v6, v23, &v33, &v32);
    }
  }
  return result;
}

void C3D::TemporalAAPassResource::~TemporalAAPassResource(C3D::TemporalAAPassResource *this)
{
  *(void *)this = &unk_26BF6E340;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  for (uint64_t i = 24; i != 8; i -= 8)
  {
    uint64_t v5 = *(void **)((char *)this + i);
    if (v5) {
  }
    }
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E340;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {

  }
  unint64_t v4 = 24;
  while (1)
  {
    uint64_t v5 = *(void **)((char *)this + v4);
    if (v5) {

    }
    v4 -= 8;
    if (v4 == 8)
    {
      JUMPOUT(0x210534FE0);
    }
  }
}

C3D::ScratchAllocator *C3D::flattenedNodesForSelectedNodes(C3D *this, const __CFArray *a2, __C3DEngineContext *a3, void *a4)
{
  if (!this && (CFNumberRef v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    C3D::flattenedNodesForSelectedNodes(v7, v8, v9, v10, v11, v12, v13, v14);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  unsigned int v15 = scn_default_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
    C3DEngineContextGetStats_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
  }
LABEL_6:
  if (!a3)
  {
    int v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      C3D::flattenedNodesForSelectedNodes(v23, v24, v25, v26, v27, v28, v29, v30);
    }
  }
  uint64_t Scene = C3DEngineContextGetScene((uint64_t)a2);
  uint64_t Aligned = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(a3, 24, 8, 0);
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(Aligned, a3);
  CFIndex Count = CFArrayGetCount(this);
  C3D::Array<__C3DNode *,0u,C3D::ScratchAllocator>::reserve(Aligned, Count);
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator((uint64_t)a2);
  C3DStackAllocatorPushFrame(StackAllocator);
  char v35 = C3DStackAllocatorAllocate(StackAllocator, 0x28uLL);
  uint64_t v42 = StackAllocator;
  *(void *)char v35 = StackAllocator;
  C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate((uint64_t)v35, 32);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(this, i);
      if (C3DGetScene(ValueAtIndex) == Scene)
      {
        v43[0] = MEMORY[0x263EF8330];
        v43[1] = 3221225472;
        v43[2] = ___ZN3C3D30flattenedNodesForSelectedNodesEPK9__CFArrayP18__C3DEngineContextPv_block_invoke;
        v43[3] = &__block_descriptor_40_e20_q16__0____C3DNode__8l;
        uint8_t v43[4] = v35;
        C3DNodeApplyHierarchy((uint64_t)ValueAtIndex, (uint64_t)v43);
      }
    }
  }
  int v38 = v35[9];
  if (v38 != -15)
  {
    uint64_t v39 = 0;
    unint64_t v40 = 0;
    do
    {
      if (*(_WORD *)(*((void *)v35 + 3) + 2 * v40))
      {
        C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::push_back<C3D::Pass *&>(Aligned, (void *)(*((void *)v35 + 2) + v39));
        int v38 = v35[9];
      }
      ++v40;
      v39 += 8;
    }
    while (v40 < (v38 + 15));
  }
  C3DStackAllocatorPopFrame(v42);
  return Aligned;
}

void *C3D::Array<__C3DNode *,0u,C3D::ScratchAllocator>::reserve(void *result, unsigned int a2)
{
  if (*((_DWORD *)result + 3) < a2)
  {
    uint64_t v3 = result;
    unint64_t v4 = (const void *)result[2];
    uint64_t Aligned = (void *)C3DScratchAllocatorAllocateAligned(*result, 8 * a2, 8, 0);
    uint64_t result = memcpy(Aligned, v4, 8 * *((unsigned int *)v3 + 2));
    v3[2] = Aligned;
    *((_DWORD *)v3 + 3) = a2;
  }
  return result;
}

BOOL ___ZN3C3D30flattenedNodesForSelectedNodesEPK9__CFArrayP18__C3DEngineContextPv_block_invoke(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a2)
  {
    if (C3DNodeIsHiddenOrTransparent(a2)) {
      return 1;
    }
    unint64_t v4 = 0xC6A4A7935BD1E995
       * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * a2) ^ ((0xC6A4A7935BD1E995 * a2) >> 47))) ^ 0x35253C9ADE8F4CA8);
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v7 = a2;
    if (!C3D::Hash<__C3DNode *,C3D::StackAllocator>::insert(v5, (0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) >> 47), &v7))return 1; {
  }
    }
  return result;
}

uint64_t C3D::Hash<__C3DNode *,C3D::StackAllocator>::insert(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      uint64_t v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          *(void *)(v26 + 8 * v15) = *(void *)(v26 + 8 * v21);
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      *(void *)(*(void *)(a1 + 16) + 8 * v21) = *a3;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v28 = *(void *)(a1 + 24);
      *(_WORD *)(v28 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v28 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<__C3DNode *,C3D::StackAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 8 * v10) = *a3;
  return result;
}

void C3D::Hash<__C3DNode *,C3D::StackAllocator>::_grow(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<__C3DNode *,C3D::StackAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 8;
      --v6;
    }
    while (v6);
  }
}

uint64_t _C3DMaterialFinalizeDeserialization(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"effectID");
  if (Value)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(Value, kCFNumberLongType, &valuePtr);
    CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%ld", valuePtr);
    CFDictionaryRef Data = (const __CFDictionary *)C3DSceneSourceGetData(a2);
    CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(Data, @"effect");
    theDict = (CFDictionaryRef)CFDictionaryGetValue(v19, v17);
    CFRelease(v17);
  }
  uint64_t CommonProfile = (const void *)C3DMaterialGetCommonProfile(a1);
  uint64_t v21 = CFDictionaryGetValue(theDict, @"commonProfile");
  return C3DFinalizeDeserialization(CommonProfile, a2, (uint64_t)v21, a4);
}

__CFDictionary *C3DMaterialCopyEffectPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t CommonProfile = (const void *)C3DMaterialGetCommonProfile(a1);
  if (CommonProfile)
  {
    unsigned int v18 = (const void *)C3DCopyPropertyList(CommonProfile, a2, a3, a4);
    if (v18)
    {
      CFDictionaryRef v19 = v18;
      CFDictionarySetValue(Mutable, @"commonProfile", v18);
      CFRelease(v19);
    }
  }
  return Mutable;
}

uint64_t C3DMaterialCopyForFlatShading(uint64_t a1)
{
  long long v7 = xmmword_20B5CD380;
  long long v8 = xmmword_20B5CB530;
  uint64_t v2 = C3DMaterialCreate();
  C3DEffectCommonProfileCopy(*(void *)(a1 + 64), *(void *)(v2 + 64));
  int v3 = 0;
  uint64_t v4 = *(void *)(v2 + 64);
  do
  {
    C3DEffectCommonProfileSetImage(v4, (char)v3, 0);
    C3DEffectCommonProfileSetColor(*(void *)(v2 + 64), (char)v3++, (float *)&v8);
    uint64_t v4 = *(void *)(v2 + 64);
  }
  while (v3 != 15);
  C3DEffectCommonProfileSetLightingModel(v4, 0);
  C3DEffectCommonProfileSetImage(*(void *)(v2 + 64), 2, 0);
  C3DEffectCommonProfileSetColor(*(void *)(v2 + 64), 2, (float *)&v7);
  C3DEffectCommonProfileSetImage(*(void *)(v2 + 64), 6, 0);
  C3DEffectCommonProfileSetColor(*(void *)(v2 + 64), 6, (float *)&v7);
  C3DMaterialSetFillMode(v2, 1u);
  C3DMaterialSetBlendMode(v2, 5);
  C3DMaterialSetColorBufferWriteMask(v2, 15);
  Ischar DoubleSided = C3DMaterialIsDoubleSided(a1);
  C3DMaterialSetDoubleSided(v2, IsDoubleSided);
  return v2;
}

void C3DMaterialSetFillMode(uint64_t a1, unsigned int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 >= 2)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMaterialSetFillMode_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  if (*(unsigned __int8 *)(a1 + 91) != a2)
  {
    *(unsigned char *)(a1 + 91) = a2;
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetBlendMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 92) != a2)
  {
    *(unsigned char *)(a1 + 92) = a2;
    uint64_t v12 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v12, 3, (const void *)a1, 0);
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetColorBufferWriteMask(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 93) != a2)
  {
    *(unsigned char *)(a1 + 93) = a2;
    uint64_t v12 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v12, 3, (const void *)a1, 0);
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetDoubleSided(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 100) != a2)
  {
    *(unsigned char *)(a1 + 100) = a2;
    uint64_t v12 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v12, 3, (const void *)a1, 0);
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetCullMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 90) != a2)
  {
    *(unsigned char *)(a1 + 90) = a2;
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetEnableWriteInDepthBuffer(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 88) != a2)
  {
    *(unsigned char *)(a1 + 88) = a2;
    uint64_t v12 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v12, 3, (const void *)a1, 0);
    __RasterizerStatesDidChange(a1);
  }
}

void C3DMaterialSetEnableReadFromDepthBuffer(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 89) != a2)
  {
    *(unsigned char *)(a1 + 89) = a2;
    uint64_t v12 = C3DGetScene((void *)a1);
    C3DScenePostPipelineEvent(v12, 3, (const void *)a1, 0);
    __RasterizerStatesDidChange(a1);
  }
}

CFTypeRef C3DMaterialSetTechnique(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 72) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 72) = result;
  }
  return result;
}

CFTypeRef C3DMaterialSetupSinglePassTechniqueWithProgram(uint64_t a1, const void *a2)
{
  Technique = (void *)C3DMaterialGetTechnique(a1);
  if (!Technique)
  {
    Technique = (void *)C3DFXTechniqueCreateWithCapacity(1uLL);
    C3DMaterialSetTechnique(a1, Technique);
    CFRelease(Technique);
  }
  if (C3DFXTechniqueGetPassCount((uint64_t)Technique) < 1)
  {
    PassAtuint64_t Index = (const void *)C3DFXPassCreate();
    C3DFXTechniqueAppendPass(Technique, PassAtIndex);
    CFRelease(PassAtIndex);
  }
  else
  {
    PassAtuint64_t Index = (const void *)C3DFXTechniqueGetPassAtIndex((uint64_t)Technique, 0);
  }
  C3DFXPassSetDrawInstruction((uint64_t)PassAtIndex, 2);

  return C3DFXPassSetProgram((uint64_t)PassAtIndex, a2);
}

__CFString *_C3DMaterialCFCopyDebugDescription(uint64_t a1)
{
  CFArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t Name = C3DEntityGetName(a1);
  CFStringAppendFormat(Mutable, 0, @"<C3DMaterial %p : \"%@\", ", a1, Name);
  uint64_t CommonProfileIfNoTechnique = C3DMaterialGetCommonProfileIfNoTechnique(a1);
  if (CommonProfileIfNoTechnique) {
    CFStringAppendFormat(Mutable, 0, @"common profile %@", CommonProfileIfNoTechnique);
  }
  else {
    CFStringAppendFormat(Mutable, 0, @"custom %@", *(void *)(a1 + 72));
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

uint64_t _C3DMaterialInitWithPropertyList(unsigned char *a1, const __CFDictionary *a2, const __CFDictionary *a3, uint64_t a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t v24 = C3DEntityInitWithPropertyList((uint64_t)a1, a2);
  if (v24)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"name");
    if (Value) {
      C3DMaterialSetName((uint64_t)a1, Value);
    }
    CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"effectID");
    CFDictionaryRef v27 = a2;
    if (v26)
    {
      *(void *)uint64_t valuePtr = 0;
      CFNumberGetValue(v26, kCFNumberLongType, valuePtr);
      CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%ld", *(void *)valuePtr);
      uint64_t v29 = CFDictionaryGetValue(a3, @"__library__");
      CFDictionaryRef Data = (const __CFDictionary *)C3DSceneSourceGetData((uint64_t)v29);
      CFDictionaryRef v31 = (const __CFDictionary *)CFDictionaryGetValue(Data, @"effect");
      CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(v31, v28);
      CFRelease(v28);
    }
    MTLSize v32 = CFDictionaryGetValue(v27, @"commonProfile");
    if (v32)
    {
      uint64_t v33 = (uint64_t)v32;
      uint64_t CommonProfile = (const void *)C3DMaterialGetCommonProfile((uint64_t)a1);
      if ((C3DInitWithPropertyList(CommonProfile, v33, (uint64_t)a3, a4) & 1) == 0)
      {
        char v35 = scn_default_log();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t valuePtr = 0;
          _os_log_impl(&dword_20B249000, v35, OS_LOG_TYPE_DEFAULT, "Warning: Could not deserialize an effect", valuePtr, 2u);
        }
      }
    }
    CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(a2, @"enableWriteInDepthBuffer");
    if (v36)
    {
      CFNumberRef v37 = v36;
      CFTypeID v38 = CFGetTypeID(v36);
      if (v38 == CFNumberGetTypeID())
      {
        *(_DWORD *)uint64_t valuePtr = 0;
        CFNumberGetValue(v37, kCFNumberIntType, valuePtr);
        a1[88] = valuePtr[0];
      }
    }
    CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(a2, @"enableReadsFromDepthBuffer");
    if (v39)
    {
      CFNumberRef v40 = v39;
      CFTypeID v41 = CFGetTypeID(v39);
      if (v41 == CFNumberGetTypeID())
      {
        *(_DWORD *)uint64_t valuePtr = 0;
        CFNumberGetValue(v40, kCFNumberIntType, valuePtr);
        a1[89] = valuePtr[0];
      }
    }
    CFNumberRef v42 = (const __CFNumber *)CFDictionaryGetValue(a2, @"doubleSided");
    if (v42)
    {
      CFNumberRef v43 = v42;
      CFTypeID v44 = CFGetTypeID(v42);
      if (v44 == CFNumberGetTypeID())
      {
        *(_DWORD *)uint64_t valuePtr = 0;
        CFNumberGetValue(v43, kCFNumberIntType, valuePtr);
        a1[100] = *(_DWORD *)valuePtr != 0;
      }
    }
    CFNumberRef v45 = (const __CFNumber *)CFDictionaryGetValue(a2, @"cullMode");
    if (v45)
    {
      CFNumberRef v46 = v45;
      CFTypeID v47 = CFGetTypeID(v45);
      if (v47 == CFNumberGetTypeID())
      {
        *(_DWORD *)uint64_t valuePtr = 0;
        CFNumberGetValue(v46, kCFNumberIntType, valuePtr);
        a1[90] = valuePtr[0];
      }
    }
    CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(a2, @"fillMode");
    if (v48)
    {
      CFNumberRef v49 = v48;
      CFTypeID v50 = CFGetTypeID(v48);
      if (v50 == CFNumberGetTypeID())
      {
        *(_DWORD *)uint64_t valuePtr = 0;
        CFNumberGetValue(v49, kCFNumberIntType, valuePtr);
        a1[91] = valuePtr[0];
      }
    }
    a1[91] = C3DFillModeFromColladaFillMode[a1[91]];
  }
  else
  {
    float32x4_t v51 = scn_default_log();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      _C3DMaterialInitWithPropertyList_cold_1(v51);
    }
  }
  return v24;
}

__CFDictionary *_C3DMaterialCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  uint64_t valuePtr = C3DLibraryGetEntryID(a2, (CFTypeRef)a1);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  CFDictionarySetValue(v14, @"effectID", v15);
  CFRelease(v15);
  if (C3DMaterialGetName(a1))
  {
    uint64_t Name = (const void *)C3DMaterialGetName(a1);
    CFDictionarySetValue(v14, @"name", Name);
  }
  uint64_t v17 = (const void *)*MEMORY[0x263EFFB40];
  uint64_t v18 = (const void *)*MEMORY[0x263EFFB38];
  if (*(unsigned char *)(a1 + 88)) {
    uint64_t v19 = (const void *)*MEMORY[0x263EFFB40];
  }
  else {
    uint64_t v19 = (const void *)*MEMORY[0x263EFFB38];
  }
  CFDictionarySetValue(v14, @"enableWriteInDepthBuffer", v19);
  if (*(unsigned char *)(a1 + 89)) {
    uint64_t v20 = v17;
  }
  else {
    uint64_t v20 = v18;
  }
  CFDictionarySetValue(v14, @"enableReadsFromDepthBuffer", v20);
  if (*(unsigned char *)(a1 + 100)) {
    uint64_t v21 = v17;
  }
  else {
    uint64_t v21 = v18;
  }
  CFDictionarySetValue(v14, @"doubleSided", v21);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberCharType, (const void *)(a1 + 90));
  CFDictionarySetValue(v14, @"cullMode", v22);
  CFRelease(v22);
  char v25 = C3DFillModeToColladaFillMode[*(unsigned __int8 *)(a1 + 91)];
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberCharType, &v25);
  CFDictionarySetValue(v14, @"fillMode", v23);
  CFRelease(v23);
  return v14;
}

void *_C3DMaterialFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t CommonProfile = (const void *)C3DMaterialGetCommonProfile(a1);
  return C3DFillLibraryForSerialization(CommonProfile, a2, a3);
}

__CFArray *_C3DMaterialCopyInstanceVariables(uint64_t a1)
{
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  int v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t Name = C3DMaterialGetName(a1);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v5, @"name", @"name");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t Name = C3DMaterialGetCommonProfile(a1);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v9, @"name", @"commonProfile");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 4;
  uint64_t Name = a1 + 90;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v13, @"name", @"cullMode");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 4;
  uint64_t Name = a1 + 91;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v17, @"name", @"fillMode");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFNumberRef v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 3;
  uint64_t Name = a1 + 89;
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v22, @"name", @"enableReadsFromDepthBuffer");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(Mutable, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  CFNumberRef v26 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFDictionaryRef v27 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v21);
  int v41 = 0;
  int valuePtr = 3;
  uint64_t Name = a1 + 88;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v27, @"name", @"enableWriteInDepthBuffer");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  CFDictionaryRef v31 = CFDictionaryCreateMutable(0, 4, v26, MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 3;
  uint64_t Name = a1 + 100;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v31, @"name", @"doubleSided");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  char v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t Name = a1 + 48;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v35, @"name", @"sceneRef");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

uint64_t _C3DMaterialSearchByID(uint64_t a1, const void *a2)
{
  uint64_t ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void OUTLINED_FUNCTION_0_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void OUTLINED_FUNCTION_3_4(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void C3DSceneRegisterNodeConstrains(uint64_t a1, float32x4_t *a2)
{
  CFArrayRef Constraints = C3DNodeGetConstraints((uint64_t)a2);
  uint64_t ControllerManager = C3DSceneGetControllerManager(a1);
  CFNumberRef v6 = (const char *)CFStringCreateWithFormat(0, 0, @"nodeConstraints-%p", a2);
  C3DConstraintManagerSetConstraintsForKey(ControllerManager, Constraints, a2, v6);

  CFRelease(v6);
}

uint64_t C3DSceneGetControllerManager(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 80);
}

void C3DSceneUnregisterNodeParticleSystem(uint64_t a1, uint64_t a2)
{
  ParticleManager = C3DSceneGetParticleManager(a1, 0);
  if (ParticleManager)
  {
    C3DParticleManagerUnregisterSystem((uint64_t)ParticleManager, a2);
  }
}

void C3DSceneRegisterNodeFilters(CFTypeRef *a1, const void *a2)
{
  CFArrayRef Filters = C3DNodeGetFilters((uint64_t)a2);
  if (Filters && CFArrayGetCount(Filters) >= 1)
  {
    CFArrayRef Mutable = (__CFSet *)a1[13];
    if (!Mutable)
    {
      CFArrayRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x263EFFFA0]);
      a1[13] = Mutable;
    }
    CFSetAddValue(Mutable, a2);
  }
  else
  {
    uint64_t v6 = (__CFSet *)a1[13];
    if (v6)
    {
      CFSetRemoveValue(v6, a2);
      if (!CFSetGetCount((CFSetRef)a1[13]))
      {
        CFRelease(a1[13]);
        a1[13] = 0;
      }
    }
  }
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();

  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", a1, 0, 1u);
}

uint64_t C3DSceneGetRegisteredNodeFilters(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 104);
}

CFDictionaryRef C3DSceneGetRegisteredCIFilterTechniqueForNode(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 112);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

void C3DSceneRegisterCIFilterTechniqueForNode(uint64_t a1, void *key, void *value)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFArrayRef Mutable = *(__CFDictionary **)(a1 + 112);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
    *(void *)(a1 + 112) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
}

void C3DSceneClearRegisteredCIFilterTechniques(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(__CFDictionary **)(a1 + 112);
  if (v10) {
    CFDictionaryRemoveAllValues(v10);
  }
}

id *C3DSceneNodeWillBeRemovedOrHidden(uint64_t a1, float32x4_t *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 120);
  if (v12) {
    C3DEnginePipelineRemoveNodeFromRendering(v12, (uint64_t)a2);
  }
  if (C3DNodeGetConstraints((uint64_t)a2))
  {
    uint64_t ControllerManager = C3DSceneGetControllerManager(a1);
    CFNumberRef v14 = (const char *)CFStringCreateWithFormat(0, 0, @"nodeConstraints-%p", a2);
    C3DConstraintManagerSetConstraintsForKey(ControllerManager, 0, a2, v14);
    CFRelease(v14);
  }
  if (C3DNodeIsJoint((uint64_t)a2)) {
    C3DEnginePipelineInvalidateAllSkinnersTransfromTreeHandles(*(void *)(a1 + 120));
  }
  if (C3DNodeGetHasPhysicsBody((uint64_t)a2)) {
    C3DSceneUnregisterNodePhysicsBody((id *)a1, (id *)a2);
  }
  if (C3DNodeGetHasPhysicsField((uint64_t)a2)) {
    C3DSceneUnregisterNodePhysicsField((id *)a1, (id *)a2);
  }
  if (C3DNodeGetParticleSystems((uint64_t)a2)) {
    C3DSceneUnregisterNodeParticleSystem(a1, (uint64_t)a2);
  }
  if (*(void *)(a1 + 128) && C3DNodeHasLight((uint64_t)a2)) {
    C3DLightingSystemRemove(*(void *)(a1 + 128), a2);
  }
  if (C3DNodeGetFilters((uint64_t)a2))
  {
    CFNumberRef v15 = *(__CFSet **)(a1 + 104);
    if (v15)
    {
      CFSetRemoveValue(v15, a2);
      if (!CFSetGetCount(*(CFSetRef *)(a1 + 104)))
      {
        CFRelease(*(CFTypeRef *)(a1 + 104));
        *(void *)(a1 + 104) = 0;
      }
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", (const void *)a1, 0, 1u);
  }
  C3DNodeRemoveAllAudioPlayers((uint64_t)a2);
  CFDictionaryRef result = *(id **)(a1 + 416);
  if (result) {
    return C3DAuthoringEnvironment2NodeRemovedFromScene(result, (id *)a2);
  }
  return result;
}

uint64_t C3DSceneCreateCopy(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (C3DSceneGetTypeID_onceToken != -1) {
    dispatch_once(&C3DSceneGetTypeID_onceToken, &__block_literal_global_66);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DSceneGetTypeID_typeID, 0x1A0uLL);
  if (Instance)
  {
    *(void *)(Instance + 72) = C3DAnimationManagerCreate();
    *(void *)(Instance + 80) = C3DConstraintManagerCreate(Instance);
    *(void *)(Instance + 96) = C3DModelValueStorageCreate();
    *(void *)(Instance + 128) = C3DLightingSystemCreate(Instance);
    *(void *)(Instance + 136) = C3DDynamicBatchingSystemCreate();
    *(void *)(Instance + 192) = *(void *)(a1 + 192);
    *(_OWORD *)(Instance + 208) = *(_OWORD *)(a1 + 208);
    *(void *)(Instance + 328) = *(void *)(a1 + 328);
    *(_DWORD *)(Instance + 336) = *(_DWORD *)(a1 + 336);
    *(_OWORD *)(Instance + 352) = *(_OWORD *)(a1 + 352);
    *(unsigned char *)(Instance + 368) = *(unsigned char *)(a1 + 368);
    *(_WORD *)(Instance + 370) = *(_WORD *)(a1 + 370);
    *(_DWORD *)(Instance + 372) = *(_DWORD *)(a1 + 372);
    *(_DWORD *)(Instance + 376) = *(_DWORD *)(a1 + 376);
    *(void *)(Instance + 120) = C3DEnginePipelineCreate(Instance);
    uint64_t v3 = (__C3DTransformTree *)C3DTransformTreeCreate(a1);
    *(void *)(Instance + 152) = v3;
    C3DCullingSystemCreate(v3);
    *(void *)(Instance + 144) = v4;
    C3DAnimationManagerSetModelValueStorage(*(void *)(Instance + 72), *(CFTypeRef *)(Instance + 96));
    CFDictionaryRef Attribute = C3DEntityGetAttribute(a1, @"defaultLight");
    if (Attribute == (const __CFDictionary *)*MEMORY[0x263EFFB40]) {
      C3DEntitySetAttribute((CFTypeRef *)Instance, @"defaultLight", Attribute);
    }
    v9.__sig = 0;
    *(void *)v9.__opaque = 0;
    pthread_mutexattr_init(&v9);
    pthread_mutexattr_settype(&v9, 2);
    pthread_mutex_init((pthread_mutex_t *)(Instance + 232), &v9);
    pthread_mutexattr_destroy(&v9);
    uint64_t v6 = *(void *)(a1 + 64);
    if (v6)
    {
      uint64_t Copy = (uint64_t *)C3DNodeCreateCopy(v6, 1);
      C3DSceneSetRootNode(Instance, Copy);
      if (Copy) {
        CFRelease(Copy);
      }
    }
  }
  return Instance;
}

double C3DSceneGetStartTime(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 176);
}

double C3DSceneGetEndTime(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 184);
}

void C3DSceneSetStartTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 176) = a2;
}

void C3DSceneSetEndTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 184) = a2;
}

float C3DSceneGetFrameRate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 192);
}

void C3DSceneSetFrameRate(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 192) = a2;
}

float C3DSceneGetPlaybackSpeed(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 196);
}

void C3DSceneSetPlaybackSpeed(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 196) = a2;
}

float C3DSceneGetUnit(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 224);
}

void C3DSceneSetUnit(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 224) = a2;
}

__n128 C3DSceneSetUpAxis(__n128 *a1, __n128 *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *a2;
  a1[13] = *a2;
  return result;
}

void C3DSceneBumpFrameStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(_DWORD *)(a1 + 296);
  C3DLightingSystemNextFrame(*(void *)(a1 + 128));
  if (!*(unsigned char *)(a1 + 382)) {
    C3DTransformTreeNextFrame(*(__C3DTransformTree **)(a1 + 152));
  }
}

uint64_t C3DSceneGetFrameStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 296);
}

uint64_t C3DSceneGetStateStamp(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 300);
}

void C3DSceneSetFogDensityExponent(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 336) = a2;
}

void C3DSceneSetFogEndDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 332) = a2;
}

void C3DSceneSetFogStartDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 328) = a2;
}

void C3DSceneSetWantsSSR(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 368) = a2;
}

void C3DSceneSetSSRSampleCount(uint64_t a1, __int16 a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_WORD *)(a1 + 370) = a2;
}

void C3DSceneSetSSRMaxRayDistance(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 372) = a2;
}

void C3DSceneSetSSRStride(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 376) = a2;
}

uint64_t C3DSceneIsPausedForEditing(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 381);
}

void C3DSceneSetPausedForEditing(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 381) = 1;
}

uint64_t C3DSceneIsPaused(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 382);
}

uint64_t C3DSceneSetPaused(uint64_t result, char a2)
{
  *(unsigned char *)(result + 382) = a2;
  return result;
}

__n128 C3DSceneComputeWorldToCubemapMatrix(__n128 *a1)
{
  float32x4_t v14 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  float32x4_t v15 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  float32x4_t v17 = *(float32x4_t *)MEMORY[0x263EF89A8];
  v18.n128_u32[2] = 0;
  v18.n128_u64[0] = 0;
  C3DSceneGetUpAxis(a1, &v18);
  if (v18.n128_f32[2] == 1.0)
  {
    __float2 v1 = __sincosf_stret(-1.5708);
    unint64_t v2 = 0;
    float32x4_t v3 = v15;
    v3.i32[1] = LODWORD(v1.__cosval);
    v3.i32[2] = LODWORD(v1.__sinval);
    float32x4_t v4 = v14;
    v4.f32[1] = -v1.__sinval;
    v4.i32[2] = LODWORD(v1.__cosval);
    float32x4_t v19 = v17;
    float32x4_t v20 = v15;
    float32x4_t v21 = v14;
    float32x4_t v22 = v16;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    do
    {
      *(long long *)((char *)&v23 + v2) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(_OWORD *)((char *)&v19 + v2))), v3, *(float32x2_t *)&v19.f32[v2 / 4], 1), v4, *(float32x4_t *)((char *)&v19 + v2), 2), v16, *(float32x4_t *)((char *)&v19 + v2), 3);
      v2 += 16;
    }
    while (v2 != 64);
    return (__n128)v23;
  }
  if (v18.n128_f32[2] == -1.0)
  {
    __float2 v5 = __sincosf_stret(1.5708);
    unint64_t v6 = 0;
    float32x4_t v7 = v15;
    v7.i32[1] = LODWORD(v5.__cosval);
    v7.i32[2] = LODWORD(v5.__sinval);
    float32x4_t v8 = v14;
    v8.f32[1] = -v5.__sinval;
    v8.i32[2] = LODWORD(v5.__cosval);
    float32x4_t v19 = v17;
    float32x4_t v20 = v15;
    float32x4_t v21 = v14;
    float32x4_t v22 = v16;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    do
    {
      *(long long *)((char *)&v23 + v6) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(_OWORD *)((char *)&v19 + v6))), v7, *(float32x2_t *)&v19.f32[v6 / 4], 1), v8, *(float32x4_t *)((char *)&v19 + v6), 2), v16, *(float32x4_t *)((char *)&v19 + v6), 3);
      v6 += 16;
    }
    while (v6 != 64);
    return (__n128)v23;
  }
  if (v18.n128_f32[1] == -1.0)
  {
    __float2 v9 = __sincosf_stret(3.1416);
    unint64_t v10 = 0;
    float32x4_t v11 = v15;
    v11.i32[1] = LODWORD(v9.__cosval);
    v11.i32[2] = LODWORD(v9.__sinval);
    float32x4_t v12 = v14;
    v12.f32[1] = -v9.__sinval;
    v12.i32[2] = LODWORD(v9.__cosval);
    float32x4_t v19 = v17;
    float32x4_t v20 = v15;
    float32x4_t v21 = v14;
    float32x4_t v22 = v16;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    do
    {
      *(long long *)((char *)&v23 + v10) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(_OWORD *)((char *)&v19 + v10))), v11, *(float32x2_t *)&v19.f32[v10 / 4], 1), v12, *(float32x4_t *)((char *)&v19 + v10), 2), v16, *(float32x4_t *)((char *)&v19 + v10), 3);
      v10 += 16;
    }
    while (v10 != 64);
    return (__n128)v23;
  }
  return (__n128)v17;
}

uint64_t C3DSceneGetAuthoringEnvironment2(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    __n128 result = *(void *)(result + 416);
    if (result) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = a2 == 0;
    }
    if (!v3)
    {
      __n128 result = C3DAuthoringEnvironment2Create(v2);
      *(void *)(v2 + 416) = result;
    }
  }
  return result;
}

void C3DSceneSetLayerRootNode(uint64_t a1, int a2, void *cf)
{
  if (!a1)
  {
    unint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (a2 >= 4)
  {
    float32x4_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DSceneSetLayerRootNode_cold_1();
    }
  }
  uint64_t v15 = a1 + 8 * a2;
  float32x4_t v16 = *(const void **)(v15 + 384);
  if (v16 != cf)
  {
    float32x4_t v17 = (void *)(v15 + 384);
    if (v16)
    {
      CFRelease(v16);
      void *v17 = 0;
    }
    if (cf) {
      CFTypeRef v18 = CFRetain(cf);
    }
    else {
      CFTypeRef v18 = 0;
    }
    void *v17 = v18;
  }
  C3DNodeSetLayerIndex((uint64_t)cf, a2);
  if (cf) {
    C3DAddSceneRef((uint64_t *)cf, a1);
  }
}

uint64_t C3DSceneGetAllowsDefaultLightingEnvironmentFallback(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 324);
}

void C3DSceneSetAllowsDefaultLightingEnvironmentFallback(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 324) = a2;
}

id _C3DSceneCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 144);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 152);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 152) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 128);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 128) = 0;
  }
  for (uint64_t i = 384; i != 416; i += 8)
  {
    uint64_t v6 = *(void *)(a1 + i);
    if (v6)
    {
      if (C3DGetSceneRef(v6) != *(void *)(a1 + 48))
      {
        uint64_t v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v24 = 0;
          _os_log_impl(&dword_20B249000, v7, OS_LOG_TYPE_DEFAULT, "Warning: RootNode is not retained by the scene", v24, 2u);
        }
      }
      C3DRemoveSceneRef(*(void **)(a1 + i), a1);
    }
  }
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8) {
    *(void *)(v8 + 24) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 64);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 72);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 96);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 80);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v13 = *(const void **)(a1 + 88);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 88) = 0;
  }
  float32x4_t v14 = *(const void **)(a1 + 104);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 104) = 0;
  }
  uint64_t v15 = *(const void **)(a1 + 112);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 112) = 0;
  }
  float32x4_t v16 = *(const void **)(a1 + 304);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 304) = 0;
  }
  float32x4_t v17 = *(const void **)(a1 + 312);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 312) = 0;
  }
  CFTypeRef v18 = *(const void **)(a1 + 136);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 136) = 0;
  }
  float32x4_t v19 = *(const void **)(a1 + 416);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 416) = 0;
  }
  for (uint64_t j = 384; j != 416; j += 8)
  {
    float32x4_t v21 = *(const void **)(a1 + j);
    if (v21)
    {
      CFRelease(v21);
      *(void *)(a1 + j) = 0;
    }
  }
  float32x4_t v22 = *(const void **)(a1 + 120);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 120) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 232));
  return C3DEntityCFFinalize(a1);
}

CFStringRef _C3DSceneCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DScene>");
}

CFStringRef _C3DSceneCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DScene>");
}

BOOL _C3DSceneInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float32x4_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if ((C3DEntityInitWithPropertyList(a1, a2) & 1) == 0)
  {
    CFDictionaryRef v31 = scn_default_log();
    BOOL result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _C3DSceneInitWithPropertyList_cold_2(v31);
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"startTime");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberDoubleType, (void *)(a1 + 176));
  }
  CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(a2, @"endTime");
  if (v25) {
    CFNumberGetValue(v25, kCFNumberDoubleType, (void *)(a1 + 184));
  }
  CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"frameRate");
  if (v26) {
    CFNumberGetValue(v26, kCFNumberFloatType, (void *)(a1 + 192));
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(a2, @"unit");
  if (v27) {
    CFNumberGetValue(v27, kCFNumberFloatType, (void *)(a1 + 224));
  }
  v33.n128_u32[2] = 0;
  v33.n128_u64[0] = 0;
  CFNumberRef v28 = CFDictionaryGetValue(a2, @"upAxis");
  if (v28 && C3DVector3InitWithPropertyList((uint64_t)&v33, (uint64_t)v28, a3, a4)) {
    C3DSceneSetUpAxis((__n128 *)a1, &v33);
  }
  CFNumberRef v29 = CFDictionaryGetValue(a2, @"animations");
  if (!v29 || (C3DInitWithPropertyList(*(const void **)(a1 + 72), (uint64_t)v29, a3, a4) & 1) != 0) {
    return 1;
  }
  CFNumberRef v32 = scn_default_log();
  BOOL result = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  if (result)
  {
    _C3DSceneInitWithPropertyList_cold_1();
    return 0;
  }
  return result;
}

__CFDictionary *_C3DSceneCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  float32x4_t v16 = C3DEntityCopyPropertyList((void *)a1, a2, a3);
  if (v16)
  {
    uint64_t v17 = (const void *)C3DCopyPropertyList(*(const void **)(a1 + 72), a2, a3, a4);
    if (v17)
    {
      uint64_t v18 = v17;
      CFDictionaryAddValue(v16, @"animations", v17);
      CFRelease(v18);
    }
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(a1 + 176));
    CFDictionaryAddValue(v16, @"startTime", v19);
    CFRelease(v19);
    CFNumberRef v20 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(a1 + 184));
    CFDictionaryAddValue(v16, @"endTime", v20);
    CFRelease(v20);
    CFNumberRef v21 = CFNumberCreate(0, kCFNumberFloatType, (const void *)(a1 + 192));
    CFDictionaryAddValue(v16, @"frameRate", v21);
    CFRelease(v21);
    uint64_t v22 = (const void *)C3DVector3CopyPropertyList(a1 + 208);
    if (v22)
    {
      uint64_t v23 = v22;
      CFDictionaryAddValue(v16, @"upAxis", v22);
      CFRelease(v23);
    }
    CFNumberRef v24 = CFNumberCreate(0, kCFNumberFloatType, (const void *)(a1 + 224));
    CFDictionaryAddValue(v16, @"unit", v24);
    CFRelease(v24);
    CFNumberRef v25 = *(const void **)(a1 + 64);
    if (v25)
    {
      CFNumberRef v26 = _copySerializedHierarchy(v25, a2);
      if (v26)
      {
        CFNumberRef v27 = v26;
        CFDictionaryAddValue(v16, @"nodeTree", v26);
        CFRelease(v27);
      }
    }
  }
  return v16;
}

uint64_t _C3DSceneFinalizeDeserialization(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFErrorRef *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float32x4_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DSceneFinalizeDeserialization_cold_3(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"nodeTree");
  if (Value)
  {
    CFNumberRef v32 = 0;
    if (_deserializeHierarchy(Value, &v32, a2))
    {
      C3DSceneSetRootNode(a1, v32);
    }
    else
    {
      CFNumberRef v25 = scn_default_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFDictionaryRef v31 = 0;
        _os_log_impl(&dword_20B249000, v25, OS_LOG_TYPE_DEFAULT, "Warning: Some nodes failed to be deserialized", v31, 2u);
      }
      if (!*(void *)(a1 + 64))
      {
        CFNumberRef v30 = scn_default_log();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          _C3DSceneFinalizeDeserialization_cold_2();
          if (!a4) {
            return 0;
          }
        }
        else if (!a4)
        {
          return 0;
        }
        if (!*a4) {
          *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
        }
        return 0;
      }
    }
  }
  CFNumberRef v26 = CFDictionaryGetValue(theDict, @"animations");
  if (!v26 || C3DFinalizeDeserialization(*(const void **)(a1 + 72), a2, (uint64_t)v26, (uint64_t)a4)) {
    return 1;
  }
  CFNumberRef v28 = scn_default_log();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    _C3DSceneFinalizeDeserialization_cold_1();
    if (!a4) {
      return 0;
    }
  }
  else if (!a4)
  {
    return 0;
  }
  if (!*a4)
  {
    CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
    uint64_t result = 0;
    *a4 = MalformedDocumentError;
    return result;
  }
  return 0;
}

void *_C3DSceneFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DSceneFinalizeDeserialization_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  Rootuint64_t Node = (const void *)C3DSceneGetRootNode(a1);
  if (RootNode)
  {
    uint64_t v23 = RootNode;
    C3DLibraryAddEntry(a2, RootNode);
    C3DFillLibraryForSerialization(v23, a2, a3);
  }
  uint64_t result = *(void **)(a1 + 72);
  if (result) {
    return C3DFillLibraryForSerialization(result, a2, a3);
  }
  return result;
}

__CFDictionary *_copySerializedHierarchy(const void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFArrayRef Mutable = CFDictionaryCreateMutable(v4, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  unsigned int EntryID = C3DLibraryGetEntryID(a2, a1);
  int v7 = (int)EntryID;
  if (EntryID)
  {
    if ((unint64_t)EntryID >= 0x7FFFFFFF)
    {
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        _copySerializedHierarchy_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
  }
  else
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      _copySerializedHierarchy_cold_1();
    }
  }
  int valuePtr = v7;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"nodeID", v17);
  CFRelease(v17);
  if (C3DNodeHasChildren((uint64_t)a1))
  {
    ChildNodesCFIndex Count = C3DNodeGetChildNodesCount((uint64_t)a1);
    CFAllocatorRef v19 = CFGetAllocator(a1);
    CFMutableArrayRef v20 = CFArrayCreateMutable(v19, ChildNodesCount, MEMORY[0x263EFFF70]);
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 0x40000000;
    v22[2] = ___copySerializedHierarchy_block_invoke;
    v22[3] = &__block_descriptor_tmp_65;
    v22[4] = a2;
    v22[5] = v20;
    C3DNodeApplyChildren((uint64_t)a1, (uint64_t)v22);
    CFDictionaryAddValue(Mutable, @"childs", v20);
    CFRelease(v20);
  }
  return Mutable;
}

void ___copySerializedHierarchy_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)_copySerializedHierarchy(a2, *(void *)(a1 + 32));
  if (v3)
  {
    CFAllocatorRef v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v3);
    CFRelease(v4);
  }
}

uint64_t _deserializeHierarchy(const __CFDictionary *a1, void *a2, uint64_t a3)
{
  CFDictionaryRef v3 = a1;
  if (!a1) {
    return (uint64_t)v3;
  }
  unsigned int valuePtr = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"nodeID");
  if (!Value)
  {
    CFMutableArrayRef v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      _deserializeHierarchy_cold_1();
    }
    return 0;
  }
  uint64_t v7 = (uint64_t)Value;
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  uint64_t v8 = valuePtr;
  uint64_t TypeID = C3DNodeGetTypeID();
  unsigned int valuePtr = C3DLibraryGetRemappedID(a3, v8, TypeID);
  if (!valuePtr)
  {
    uint64_t v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      _deserializeHierarchy_cold_2(v7, v21);
    }
    return 0;
  }
  uint64_t v10 = (void *)C3DNodeGetTypeID();
  Entry = C3DLibraryGetEntry(a3, v10, (const void *)valuePtr);
  if (!Entry)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      _deserializeHierarchy_cold_3();
    }
    return 0;
  }
  uint64_t v12 = (uint64_t)Entry;
  *a2 = Entry;
  CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue(v3, @"childs");
  if (!v13) {
    return 1;
  }
  CFArrayRef v14 = v13;
  CFIndex Count = CFArrayGetCount(v13);
  if (Count < 1) {
    return 1;
  }
  CFIndex v16 = Count;
  CFIndex v17 = 0;
  LODWORD(v3) = 1;
  do
  {
    ValueAtuint64_t Index = CFArrayGetValueAtIndex(v14, v17);
    CFTypeRef cf = 0;
    int v19 = _deserializeHierarchy(ValueAtIndex, &cf, a3);
    if (cf) {
      C3DNodeAddChildNode(v12, (float32x4_t *)cf);
    }
    CFDictionaryRef v3 = (const __CFDictionary *)(v3 & v19);
    ++v17;
  }
  while (v16 != v17);
  return (uint64_t)v3;
}

uint64_t _C3DSceneSearchByID(uint64_t a1, const void *a2)
{
  uint64_t ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  Rootuint64_t Node = (const void *)C3DSceneGetRootNode(a1);

  return C3DSearchByID(RootNode, (uint64_t)a2);
}

void _C3DSceneEnumerateSubEntities()
{
  id v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    _C3DSceneEnumerateSubEntities_cold_1();
  }
}

__CFArray *_C3DSceneCopyInstanceVariables(uint64_t a1)
{
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFDictionaryRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFAllocatorRef v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v5, @"name", @"root");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v62 = 0;
  int valuePtr = 6;
  uint64_t v61 = a1 + 176;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v9, @"name", @"startTime");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  CFArrayRef v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v62 = 0;
  int valuePtr = 6;
  uint64_t v61 = a1 + 184;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v13, @"name", @"endTime");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  CFIndex v17 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v62 = 0;
  int valuePtr = 7;
  uint64_t v61 = a1 + 192;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v17, @"name", @"frameRate");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v62 = 0;
  int valuePtr = 7;
  uint64_t v61 = a1 + 196;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v21, @"name", @"playbackSpeed");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  CFNumberRef v25 = v3;
  CFNumberRef v26 = v4;
  CFNumberRef v27 = CFDictionaryCreateMutable(0, 4, v25, v4);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 200;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v27, @"name", @"attributes");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  CFDictionaryRef v31 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFNumberRef v32 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v26);
  int v62 = 0;
  int valuePtr = 9;
  uint64_t v61 = a1 + 208;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v32, @"name", @"upAxis");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  CFNumberRef v36 = CFDictionaryCreateMutable(0, 4, v31, v26);
  int v62 = 0;
  int valuePtr = 1;
  uint64_t v61 = a1 + 224;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v36, @"name", @"unit");
  CFDictionarySetValue(v36, @"type", v37);
  CFDictionarySetValue(v36, @"address", v39);
  CFDictionarySetValue(v36, @"semantic", v38);
  CFArrayAppendValue(Mutable, v36);
  CFRelease(v38);
  CFRelease(v36);
  CFRelease(v39);
  CFRelease(v37);
  CFNumberRef v40 = CFDictionaryCreateMutable(0, 4, v31, v26);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 72;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v40, @"name", @"animationManager");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  CFTypeID v44 = CFDictionaryCreateMutable(0, 4, v31, v26);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 304;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v44, @"name", @"background");
  CFDictionarySetValue(v44, @"type", v45);
  CFDictionarySetValue(v44, @"address", v47);
  CFDictionarySetValue(v44, @"semantic", v46);
  CFArrayAppendValue(Mutable, v44);
  CFRelease(v46);
  CFRelease(v44);
  CFRelease(v47);
  CFRelease(v45);
  CFNumberRef v48 = CFDictionaryCreateMutable(0, 4, v31, v26);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 312;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v48, @"name", @"environment");
  CFDictionarySetValue(v48, @"type", v49);
  CFDictionarySetValue(v48, @"address", v51);
  CFDictionarySetValue(v48, @"semantic", v50);
  CFArrayAppendValue(Mutable, v48);
  CFRelease(v50);
  CFRelease(v48);
  CFRelease(v51);
  CFRelease(v49);
  float32x4_t v52 = CFDictionaryCreateMutable(0, 4, v31, v26);
  int v62 = 0;
  int valuePtr = 2;
  uint64_t v61 = a1 + 48;
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v52, @"name", @"sceneRef");
  CFDictionarySetValue(v52, @"type", v53);
  CFDictionarySetValue(v52, @"address", v55);
  CFDictionarySetValue(v52, @"semantic", v54);
  CFArrayAppendValue(Mutable, v52);
  CFRelease(v54);
  CFRelease(v52);
  CFRelease(v55);
  CFRelease(v53);
  uint64_t v56 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], v26);
  int v62 = 2;
  int valuePtr = 5;
  uint64_t v61 = a1 + 128;
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt32Type, &v62);
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberLongType, &v61);
  CFDictionarySetValue(v56, @"name", @"lightingSystem");
  CFDictionarySetValue(v56, @"type", v57);
  CFDictionarySetValue(v56, @"address", v59);
  CFDictionarySetValue(v56, @"semantic", v58);
  CFArrayAppendValue(Mutable, v56);
  CFRelease(v58);
  CFRelease(v56);
  CFRelease(v59);
  CFRelease(v57);
  return Mutable;
}

void sub_20B3C4340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, char a12)
{
  if (a11)
  {
    if (a12) {
      btAlignedFreeInternal(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t __preTickCallback(id *a1, float a2)
{
  return [a1[17] _preTick:a2];
}

void sub_20B3C4594(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

uint64_t btC3DCollisionDispatcher::setDelegate(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v3 = (unsigned char *)(a1 + 10528);
  *(void *)(a1 + 10520) = a2;
  *(unsigned char *)(a1 + 10528) = objc_opt_respondsToSelector() & 1;
  v3[1] = objc_opt_respondsToSelector() & 1;
  uint64_t result = objc_opt_respondsToSelector();
  v3[2] = result & 1;
  *(_DWORD *)(a1 + 10504) = 0;
  if (*v3) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v3[1] == 0;
  }
  if (!v5 || (result & 1) != 0)
  {
    if (v3[1]) {
      int v6 = 3;
    }
    else {
      int v6 = 1;
    }
    if (result) {
      int v7 = 4;
    }
    else {
      int v7 = 0;
    }
    *(_DWORD *)(a1 + 10504) = v6 | v7;
  }
  return result;
}

uint64_t btC3DSupportInternalEdgesCustomCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, int a6, int a7)
{
  return 1;
}

SCNHitTestResult *_hitTestResult(const btCollisionObject *a1, float32x4_t *a2, float32x4_t *a3)
{
  if (!a1 || *((_DWORD *)a1 + 66) != 2) {
    return 0;
  }
  CFDictionaryRef v3 = (const void *)C3DHitTestResultCreateFromBulletResults(*(float32x4_t **)(*((void *)a1 + 67) + 72), *a2, *a3);
  CFAllocatorRef v4 = [[SCNHitTestResult alloc] initWithResult:v3];
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

void sub_20B3C5964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void btC3DRayResultCallback::~btC3DRayResultCallback(btC3DRayResultCallback *this)
{
  *(void *)this = &unk_26BF6B438;
  uint64_t v2 = (char *)this + 144;
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 240);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 208);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 176);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)v2);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_26BF6B438;
  uint64_t v2 = (char *)this + 144;
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 240);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 208);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 176);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)v2);

  JUMPOUT(0x210534FE0);
}

void *__contact(const btCollisionObject *a1, const btCollisionObject *a2, const btVector3 *a3, const btVector3 *a4, float a5, float a6)
{
  int v6 = 0;
  if (a1 && (*((_DWORD *)a1 + 66) & 2) != 0)
  {
    id v13 = (id)objc_opt_new();
    if ((*((unsigned char *)a1 + 264) & 2) != 0
      && (uint64_t v14 = *((void *)a1 + 67)) != 0
      && (int v6 = v13, (v15 = C3DEntityGetObjCWrapper(*(id **)(v14 + 72))) != 0))
    {
      CFNumberRef v22 = v15;
      if (a2 && (*((unsigned char *)a2 + 264) & 2) != 0 && (uint64_t v23 = *((void *)a2 + 67)) != 0) {
        ObjCWrapper = C3DEntityGetObjCWrapper(*(id **)(v23 + 72));
      }
      else {
        ObjCWrapper = 0;
      }
      *(float *)&double v16 = a3->var0.var0[0];
      *(float *)&double v17 = a3->var0.var0[1];
      *(float *)&double v18 = a3->var0.var0[2];
      *(float *)&double v19 = a4->var0.var0[0];
      *(float *)&double v20 = a4->var0.var0[1];
      *(float *)&double v21 = a4->var0.var0[2];
      objc_msgSend(v6, "_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:", v22, ObjCWrapper, v16, v17, v18, v19, v20, v21, (float)-a5, a6);
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t C3DPhysicsWorldAddBodyToWorld(uint64_t result, uint64_t a2, __C3DNode *a3, uint64_t a4, uint64_t a5, uint64_t a6, __n128 a7)
{
  if (a2)
  {
    uint64_t v12 = result;
    float v13 = *(float *)(result + 228);
    uint64_t v14 = *(void *)(a2 + 536);
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    CFNumberRef v15 = (btC3DMotionState *)btAlignedAllocInternal(80, 16);
    btC3DMotionState::btC3DMotionState(v15, a3, v13);
    btC3DMotionState::setOffset((__n128 *)v15, a7);
    *(void *)(a2 + 536) = v15;
    if (v15) {
      (*(void (**)(btC3DMotionState *, uint64_t))(*(void *)v15 + 16))(v15, a2 + 16);
    }
    uint64_t result = C3DNodeIsHidden((uint64_t)a3);
    if ((result & 1) == 0)
    {
      if (C3DNodeIsHidden((uint64_t)a3))
      {
        double v16 = scn_default_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          C3DPhysicsWorldAddBodyToWorld(v16, v17, v18, v19, v20, v21, v22, v23);
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 176))(v12, a2, a4, a5, a6);
    }
  }
  return result;
}

void sub_20B3C64DC(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

void btC3DCollisionDispatcher::dispatchContactsToDelegate(btC3DCollisionDispatcher *this)
{
  uint64_t v2 = *((unsigned int *)this + 2635);
  if ((int)v2 <= 0)
  {
    long long v12 = 0uLL;
    if ((v2 & 0x80000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_15;
  }
  uint64_t v3 = 0;
  uint64_t v4 = 16 * v2;
  do
  {
    uint64_t v5 = *((void *)this + 1319) + v3;
    int v6 = *(void **)v5;
    int v7 = *(_DWORD *)(v5 + 8);
    switch(v7)
    {
      case 2:
        [*((id *)this + 1315) physicsWorld:*((void *)this + 1314) didEndContact:v6];
        break;
      case 1:
        if ([v6 _shouldPostUpdate]) {
          [*((id *)this + 1315) physicsWorld:*((void *)this + 1314) didUpdateContact:v6];
        }
        break;
      case 0:
        [*((id *)this + 1315) physicsWorld:*((void *)this + 1314) didBeginContact:v6];
        break;
    }

    v3 += 16;
  }
  while (v4 != v3);
  LODWORD(v2) = *((_DWORD *)this + 2635);
  long long v12 = 0uLL;
  if ((int)v2 <= 0 && (v2 & 0x80000000) != 0)
  {
LABEL_15:
    if ((*((_DWORD *)this + 2636) & 0x80000000) != 0)
    {
      CFNumberRef v8 = (void **)*((void *)this + 1319);
      if (v8 && *((unsigned char *)this + 10560)) {
        btAlignedFreeInternal(v8);
      }
      *((unsigned char *)this + 10560) = 1;
      *((void *)this + 1319) = 0;
      *((_DWORD *)this + 2636) = 0;
    }
    uint64_t v9 = 16 * (int)v2;
    uint64_t v10 = (int)v2 + 1;
    do
    {
      *(_OWORD *)(*((void *)this + 1319) + v9) = v12;
      v9 += 16;
    }
    while (v10++);
  }
LABEL_22:
  *((_DWORD *)this + 2635) = 0;
}

id *C3DSceneRegisterNodePhysicsBody(id *a1, id *a2)
{
  uint64_t result = C3DEntityGetObjCWrapper(a1);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = C3DEntityGetObjCWrapper(a2);
    if (result)
    {
      uint64_t result = (id *)[result physicsBody];
      if (result)
      {
        uint64_t v5 = result;
        int v6 = (void *)[v4 physicsWorld];
        uint64_t v7 = [v5 categoryBitMask];
        uint64_t v8 = [v5 collisionBitMask];
        uint64_t v9 = [v5 contactTestBitMask];
        return (id *)[v6 addPhysicsBody:v5 nodeRef:a2 colGroup:v7 colMask:v8 colTest:v9];
      }
    }
  }
  return result;
}

id *C3DSceneUnregisterNodePhysicsBody(id *a1, id *a2)
{
  uint64_t result = C3DEntityGetObjCWrapper(a1);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = C3DEntityGetObjCWrapper(a2);
    if (result)
    {
      uint64_t result = (id *)[result physicsBody];
      if (result)
      {
        uint64_t v5 = result;
        uint64_t v6 = [result _handle];
        uint64_t v7 = (void *)[v4 physicsWorld];
        return (id *)[v7 removePhysicsBody:v5 handle:v6];
      }
    }
  }
  return result;
}

uint64_t btC3DCollisionDispatcher::btC3DCollisionDispatcher(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = btCollisionDispatcher::btCollisionDispatcher(a1, a2);
  *(void *)uint64_t v5 = &unk_26BF6B9B8;
  *(void *)(v5 + 10496) = &unk_26BF6BA68;
  *(void *)(v5 + 10512) = a3;
  *(unsigned char *)(v5 + 10560) = 1;
  *(void *)(v5 + 10552) = 0;
  *(void *)(v5 + 10540) = 0;
  btC3DCollisionDispatcher::setDelegate(v5, 0);
  return a1;
}

void sub_20B3C7538(_Unwind_Exception *a1)
{
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)v1 + 10536);
  btCollisionDispatcher::~btCollisionDispatcher(v1);
  _Unwind_Resume(a1);
}

void btC3DCollisionDispatcher::~btC3DCollisionDispatcher(btC3DCollisionDispatcher *this)
{
  btC3DCollisionDispatcher::~btC3DCollisionDispatcher(this);

  JUMPOUT(0x210534FE0);
}

{
  int v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  btManifoldPoint *v6;
  uint64_t vars8;

  *(void *)this = &unk_26BF6B9B8;
  *((void *)this + 1312) = &unk_26BF6BA68;
  if (*((void *)this + 1315))
  {
    uint64_t v2 = *((_DWORD *)this + 5);
    if (v2 >= 1)
    {
      for (uint64_t i = 0; i < v2; ++i)
      {
        uint64_t v4 = *(void *)(*((void *)this + 4) + 8 * i);
        if (v4)
        {
          if (*(int *)(v4 + 800) >= 1)
          {
            uint64_t v5 = 0;
            uint64_t v6 = (btManifoldPoint *)(v4 + 16);
            do
            {
              btPersistentManifold::clearUserCache((btPersistentManifold *)v4, v6);
              ++v5;
              ++v6;
            }
            while (v5 < *(int *)(v4 + 800));
            uint64_t v2 = *((_DWORD *)this + 5);
          }
          *(_DWORD *)(v4 + 800) = 0;
        }
      }
    }
  }
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 10536);

  btCollisionDispatcher::~btCollisionDispatcher(this);
}

uint64_t btC3DCollisionDispatcher::getNewManifold(btC3DCollisionDispatcher *this, const btCollisionObject *a2, const btCollisionObject *a3)
{
  uint64_t result = btCollisionDispatcher::getNewManifold(this, a2, a3);
  if (*((_DWORD *)this + 2626)) {
    *(void *)(result + 824) = (char *)this + 10496;
  }
  return result;
}

uint64_t btCollisionDispatcher::getNumManifolds(btCollisionDispatcher *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t btCollisionDispatcher::getManifoldByIndexInternal(btCollisionDispatcher *this, int a2)
{
  return *(void *)(*((void *)this + 4) + 8 * a2);
}

uint64_t btCollisionDispatcher::getInternalManifoldPointer(btCollisionDispatcher *this)
{
  if (*((_DWORD *)this + 5)) {
    return *((void *)this + 4);
  }
  else {
    return 0;
  }
}

uint64_t btCollisionDispatcher::getInternalManifoldPool(btCollisionDispatcher *this)
{
  return *((void *)this + 14);
}

{
  return *((void *)this + 14);
}

void btC3DCollisionDispatcher::addContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
  uint64_t v5 = (char *)this + 10528;
  if (*((_WORD *)this + 5264) || *((unsigned char *)this + 10530))
  {
    uint64_t v6 = a3;
    *(void *)&a2->var1[a3].var14 = objc_alloc_init(SCNPhysicsContact);
    if (*v5)
    {
      var3 = a2->var3;
      if (var3) {
        var3 = (btCollisionObject *)*((void *)var3 + 25);
      }
      uint64_t v8 = *(void *)&a2->var4;
      if (v8)
      {
        BOOL v9 = 0;
        if (var3)
        {
          uint64_t v10 = *(void *)(v8 + 200);
          if (v10) {
            BOOL v9 = (*(void *)(v10 + 8) & *((void *)var3 + 3)) != 0
          }
              || (*(void *)(v10 + 24) & *((void *)var3 + 1)) != 0;
        }
      }
      else
      {
        BOOL v9 = 0;
      }
      if (v9 | C3DWasLinkedBeforeMajorOSYear2015())
      {
        id v11 = +[SCNPhysicsContact _contactWithManifold:a2 index:v6];
        int v12 = *((_DWORD *)this + 2635);
        if (v12 == *((_DWORD *)this + 2636))
        {
          int v13 = v12 ? 2 * v12 : 1;
          if (v12 < v13)
          {
            if (v13)
            {
              uint64_t v14 = btAlignedAllocInternal(16 * v13, 16);
              int v12 = *((_DWORD *)this + 2635);
            }
            else
            {
              uint64_t v14 = 0;
            }
            if (v12 >= 1)
            {
              uint64_t v15 = 0;
              uint64_t v16 = 16 * v12;
              do
              {
                *(_OWORD *)(v14 + v15) = *(_OWORD *)(*((void *)this + 1319) + v15);
                v15 += 16;
              }
              while (v16 != v15);
            }
            uint64_t v17 = (void **)*((void *)this + 1319);
            if (v17)
            {
              if (v5[32]) {
                btAlignedFreeInternal(v17);
              }
            }
            v5[32] = 1;
            *((void *)this + 1319) = v14;
            *((_DWORD *)this + 2636) = v13;
            int v12 = *((_DWORD *)this + 2635);
          }
        }
        uint64_t v18 = *((void *)this + 1319) + 16 * v12;
        *(void *)uint64_t v18 = v11;
        *(_DWORD *)(v18 + 8) = 0;
        ++*((_DWORD *)this + 2635);
      }
    }
  }
}

uint64_t btC3DCollisionDispatcher::updateContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
  uint64_t v6 = (char *)this + 10529;
  if (!*((unsigned char *)this + 10529))
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      btC3DCollisionDispatcher::updateContact(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  var3 = a2->var3;
  uint64_t v16 = *(void *)&a2->var4;
  if (var3) {
    var3 = (btCollisionObject *)*((void *)var3 + 25);
  }
  BOOL v17 = 0;
  if (v16)
  {
    if (var3)
    {
      uint64_t v18 = *(void *)(v16 + 200);
      if (v18) {
        BOOL v17 = (*(void *)(v18 + 8) & *((void *)var3 + 3)) != 0
      }
           || (*(void *)(v18 + 24) & *((void *)var3 + 1)) != 0;
    }
  }
  uint64_t result = C3DWasLinkedBeforeMajorOSYear2015();
  if (v17 | result)
  {
    id v20 = +[SCNPhysicsContact _contactWithManifold:a2 index:a3];
    int v21 = *((_DWORD *)this + 2635);
    if (v21 == *((_DWORD *)this + 2636))
    {
      int v22 = v21 ? 2 * v21 : 1;
      if (v21 < v22)
      {
        if (v22)
        {
          uint64_t v23 = btAlignedAllocInternal(16 * v22, 16);
          int v21 = *((_DWORD *)this + 2635);
        }
        else
        {
          uint64_t v23 = 0;
        }
        if (v21 >= 1)
        {
          uint64_t v24 = 0;
          uint64_t v25 = 16 * v21;
          do
          {
            *(_OWORD *)(v23 + v24) = *(_OWORD *)(*((void *)this + 1319) + v24);
            v24 += 16;
          }
          while (v25 != v24);
        }
        CFNumberRef v26 = (void **)*((void *)this + 1319);
        if (v26)
        {
          if (v6[31]) {
            btAlignedFreeInternal(v26);
          }
        }
        v6[31] = 1;
        *((void *)this + 1319) = v23;
        *((_DWORD *)this + 2636) = v22;
        int v21 = *((_DWORD *)this + 2635);
      }
    }
    uint64_t v27 = *((void *)this + 1319) + 16 * v21;
    *(void *)uint64_t v27 = v20;
    *(_DWORD *)(v27 + 8) = 1;
    ++*((_DWORD *)this + 2635);
    return [v20 _prepareUpdate];
  }
  return result;
}

void btC3DCollisionDispatcher::deleteContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
  uint64_t v6 = (char *)this + 10530;
  if (*((unsigned char *)this + 10530)) {
    goto LABEL_5;
  }
  uint64_t v7 = scn_default_log();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
    btC3DCollisionDispatcher::deleteContact(v7, v8, v9, v10, v11, v12, v13, v14);
  }
  if (*v6)
  {
LABEL_5:
    var3 = a2->var3;
    if (var3) {
      var3 = (btCollisionObject *)*((void *)var3 + 25);
    }
    uint64_t v16 = *(void *)&a2->var4;
    if (v16)
    {
      BOOL v17 = 0;
      if (var3)
      {
        uint64_t v18 = *(void *)(v16 + 200);
        if (v18) {
          BOOL v17 = (*(void *)(v18 + 8) & *((void *)var3 + 3)) != 0
        }
             || (*(void *)(v18 + 24) & *((void *)var3 + 1)) != 0;
      }
    }
    else
    {
      BOOL v17 = 0;
    }
    if (v17 | C3DWasLinkedBeforeMajorOSYear2015())
    {
      id v19 = +[SCNPhysicsContact _contactWithManifold:a2 index:a3];
      int v20 = *((_DWORD *)this + 2635);
      if (v20 == *((_DWORD *)this + 2636))
      {
        int v21 = v20 ? 2 * v20 : 1;
        if (v20 < v21)
        {
          if (v21)
          {
            uint64_t v22 = btAlignedAllocInternal(16 * v21, 16);
            int v20 = *((_DWORD *)this + 2635);
          }
          else
          {
            uint64_t v22 = 0;
          }
          if (v20 >= 1)
          {
            uint64_t v23 = 0;
            uint64_t v24 = 16 * v20;
            do
            {
              *(_OWORD *)(v22 + v23) = *(_OWORD *)(*((void *)this + 1319) + v23);
              v23 += 16;
            }
            while (v24 != v23);
          }
          uint64_t v25 = (void **)*((void *)this + 1319);
          if (v25)
          {
            if (v6[30]) {
              btAlignedFreeInternal(v25);
            }
          }
          v6[30] = 1;
          *((void *)this + 1319) = v22;
          *((_DWORD *)this + 2636) = v21;
          int v20 = *((_DWORD *)this + 2635);
        }
      }
      uint64_t v26 = *((void *)this + 1319) + 16 * v20;
      *(void *)uint64_t v26 = v19;
      *(_DWORD *)(v26 + 8) = 2;
      ++*((_DWORD *)this + 2635);
    }
  }
}

uint64_t btC3DCollisionDispatcher::destroyContactUserData(btC3DCollisionDispatcher *this, const void *a2)
{
  return MEMORY[0x270F9A758](this, a2);
}

void non-virtual thunk to'btC3DCollisionDispatcher::addContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
}

uint64_t non-virtual thunk to'btC3DCollisionDispatcher::updateContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
  return btC3DCollisionDispatcher::updateContact((btC3DCollisionDispatcher *)((char *)this - 10496), a2, a3);
}

void non-virtual thunk to'btC3DCollisionDispatcher::deleteContact(btC3DCollisionDispatcher *this, const btPersistentManifold *a2, int a3)
{
}

uint64_t non-virtual thunk to'btC3DCollisionDispatcher::destroyContactUserData(btC3DCollisionDispatcher *this, const void *a2)
{
  return MEMORY[0x270F9A758](this, a2);
}

void sub_20B3C7C08(_Unwind_Exception *a1)
{
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)v1 + 10536);
  btCollisionDispatcher::~btCollisionDispatcher(v1);
  _Unwind_Resume(a1);
}

void btC3DDebugDraw::~btC3DDebugDraw(btC3DDebugDraw *this)
{
}

void btC3DDebugDraw::drawLine(btC3DDebugDraw *this, float32x4_t *a2, float32x4_t *a3, const btVector3 *a4)
{
  var3 = this->var3;
  if (var3)
  {
    float var2 = this->var2;
    float32x4_t v7 = vmulq_n_f32(*a2, var2);
    float32x4_t v8 = vmulq_n_f32(*a3, var2);
    uint64_t v9 = *(void *)a4->var0.var0;
    float v10 = a4->var0.var0[2];
    int v11 = 1065353216;
    C3DAuthoringEnvironmentAppendDebugSegment((uint64_t)var3, 0, (float *)&v9, 0, v7, v8);
  }
}

void btC3DDebugDraw::drawLine(btC3DDebugDraw *this, float32x4_t *a2, float32x4_t *a3, const btVector3 *a4, const btVector3 *a5)
{
  var3 = (uint64_t *)this->var3;
  if (var3)
  {
    float var2 = this->var2;
    float32x4_t v8 = vmulq_n_f32(*a2, var2);
    __n128 v9 = (__n128)vmulq_n_f32(*a3, var2);
    uint64_t v13 = *(void *)a4->var0.var0;
    float v14 = a4->var0.var0[2];
    int v15 = 1065353216;
    uint64_t v10 = *(void *)a5->var0.var0;
    float v11 = a5->var0.var0[2];
    int v12 = 1065353216;
    C3DAuthoringEnvironmentAppendDebugSegment2(var3, 0, (float *)&v13, (float *)&v10, 0, v8, v9);
  }
}

void btC3DDebugDraw::drawSphere(btC3DDebugDraw *this, float a2, const btTransform *a3, const btVector3 *a4)
{
  var3 = this->var3;
  if (var3)
  {
    *(void *)&long long v20 = *(void *)a4->var0.var0;
    DWORD2(v20) = LODWORD(a4->var0.var0[2]);
    HIDWORD(v20) = 1065353216;
    int32x4_t v7 = (int32x4_t)a3->var0.var0[1];
    int8x16_t v8 = (int8x16_t)a3->var0.var0[2];
    btVector3 var1 = a3->var1;
    int8x16_t v10 = (int8x16_t)vtrn1q_s32((int32x4_t)a3->var0.var0[0], v7);
    v11.n128_u64[0] = vextq_s8(v10, v10, 8uLL).u64[0];
    v10.i64[1] = v8.u32[0];
    v12.n128_u64[0] = (unint64_t)vzip2_s32(*(int32x2_t *)a3->var0.var0[0].var0.var0, *(int32x2_t *)v7.i8);
    *(int32x2_t *)&v12.n128_i8[8] = vzip2_s32(*(int32x2_t *)v8.i8, 0);
    v11.n128_u64[1] = vextq_s8(v8, v8, 8uLL).u32[0];
    v16[0] = (__n128)v10;
    v16[1] = v12;
    void v16[2] = v11;
    uint64_t v17 = *(void *)var1.var0.var0;
    float v18 = var1.var0.var0[2];
    int v19 = 1065353216;
    if (this->var2 == 1.0)
    {
      double var2 = 1.0;
    }
    else
    {
      v15.i32[2] = 0;
      v15.i64[0] = 0;
      C3DMatrix4x4GetTranslation(v16, (__n128 *)&v15);
      float32x4_t v15 = vmulq_n_f32(v15, this->var2);
      C3DMatrix4x4SetTranslation(v16, (__n128)v15);
      var3 = this->var3;
      double var2 = this->var2;
    }
    *(float *)&unsigned int v14 = a2 * 1.02 * var2;
    C3DAuthoringEnvironmentAppendDebugBoundingSphere((uint64_t)var3, 0, (unint64_t)v14 << 32, (float32x4_t *)v16, &v20);
  }
}

uint64_t btIDebugDraw::drawSphere(btIDebugDraw *this, const btVector3 *a2, float a3, const btVector3 *a4)
{
  v6[0] = xmmword_20B5CB820;
  v6[1] = xmmword_20B5CB7D0;
  long long v4 = (__int128)*a2;
  _OWORD v6[2] = xmmword_20B5CB520;
  v6[3] = v4;
  return (*(uint64_t (**)(btIDebugDraw *, _OWORD *, const btVector3 *, float))(*(void *)this + 32))(this, v6, a4, a3);
}

uint64_t btIDebugDraw::drawTriangle(btIDebugDraw *this, const btVector3 *a2, const btVector3 *a3, const btVector3 *a4, const btVector3 *a5, const btVector3 *a6, const btVector3 *a7, const btVector3 *a8, float a9)
{
  return (*(uint64_t (**)(btIDebugDraw *, const btVector3 *, const btVector3 *, const btVector3 *, const btVector3 *, float))(*(void *)this + 56))(this, a2, a3, a4, a8, a9);
}

uint64_t btIDebugDraw::drawTriangle(btIDebugDraw *this, const btVector3 *a2, const btVector3 *a3, const btVector3 *a4, const btVector3 *a5, float a6)
{
  (*(void (**)(btIDebugDraw *, const btVector3 *, const btVector3 *, const btVector3 *, float))(*(void *)this + 16))(this, a2, a3, a5, a6);
  (*(void (**)(btIDebugDraw *, const btVector3 *, const btVector3 *, const btVector3 *))(*(void *)this
                                                                                                  + 16))(this, a3, a4, a5);
  __n128 v11 = *(uint64_t (**)(btIDebugDraw *, const btVector3 *, const btVector3 *, const btVector3 *))(*(void *)this + 16);

  return v11(this, a4, a2, a5);
}

void btC3DDebugDraw::drawContactPoint(btC3DDebugDraw *this, float32x4_t *a2, float32x4_t *a3, float a4, int a5, const btVector3 *a6)
{
  var3 = this->var3;
  if (var3)
  {
    float var2 = this->var2;
    float32x4_t v9 = vmulq_n_f32(*a2, var2);
    float32x4_t v10 = vmlaq_n_f32(v9, vmulq_n_f32(*a3, a4), var2);
    uint64_t v11 = *(void *)a6->var0.var0;
    float v12 = a6->var0.var0[2];
    int v13 = 1065353216;
    C3DAuthoringEnvironmentAppendDebugSegment((uint64_t)var3, 0, (float *)&v11, 0, v9, v10);
  }
}

void btC3DDebugDraw::reportErrorWarning(btC3DDebugDraw *this, const char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = a2;
    _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: PhysicsWarn: %s", (uint8_t *)&v4, 0xCu);
  }
}

btC3DDebugDraw *btC3DDebugDraw::setDebugMode(btC3DDebugDraw *this, int a2)
{
  this->btVector3 var1 = a2;
  return this;
}

uint64_t btC3DDebugDraw::getDebugMode(btC3DDebugDraw *this)
{
  return this->var1;
}

uint64_t btIDebugDraw::drawAabb(btIDebugDraw *this, float32x4_t *a2, float32x4_t *a3, const btVector3 *a4)
{
  unint64_t v6 = 0;
  v7.i64[0] = 0x3F0000003F000000;
  v7.i64[1] = 0x3F0000003F000000;
  float32x4_t v8 = vmulq_f32(vsubq_f32(*a3, *a2), v7);
  float32x4_t v9 = vmulq_f32(vaddq_f32(*a3, *a2), v7);
  v9.i32[3] = 0;
  long long v21 = xmmword_20B5CC200;
  float v10 = v8.f32[2];
  float32x4_t v17 = v9;
  uint64_t v18 = v8.i64[0];
  do
  {
    uint64_t v11 = 0;
    float32x2_t v12 = (float32x2_t)v21;
    float v13 = *((float *)&v21 + 2);
    do
    {
      *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v8.f32, v12);
      *(float *)((char *)&v21 + v11) = -*(float *)((char *)&v21 + v11);
      v14.f32[2] = v10 * v13;
      float32x2_t v12 = (float32x2_t)v21;
      *(float32x2_t *)v15.f32 = vmul_f32(*(float32x2_t *)v8.f32, *(float32x2_t *)&v21);
      float v13 = *((float *)&v21 + 2);
      v15.f32[2] = v10 * *((float *)&v21 + 2);
      v14.i32[3] = 0;
      v15.i32[3] = 0;
      float32x4_t v19 = vaddq_f32(v15, v9);
      float32x4_t v20 = vaddq_f32(v14, v9);
      uint64_t result = (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v20, &v19, a4);
      float32x4_t v9 = v17;
      v8.i64[0] = v18;
      v11 += 4;
    }
    while (v11 != 12);
    long long v21 = xmmword_20B5EDFA0;
    if (v6 <= 2) {
      *((float *)&v21 + v6) = -*((float *)&v21 + v6);
    }
    ++v6;
  }
  while (v6 != 4);
  return result;
}

uint64_t btIDebugDraw::drawTransform(btIDebugDraw *this, const btTransform *a2, float a3)
{
  btVector3 var1 = a2->var1;
  int8x16_t v6 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), (float32x4_t)a2->var0.var0[0]);
  int8x16_t v7 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), (float32x4_t)a2->var0.var0[1]);
  int8x16_t v8 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), (float32x4_t)a2->var0.var0[2]);
  v8.i32[3] = 0;
  *(float32x2_t *)v9.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v6.i8, *(float32x2_t *)v7.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  *(float32x2_t *)&v9.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)), 0);
  float32x4_t v21 = vaddq_f32((float32x4_t)var1, v9);
  btVector3 v22 = var1;
  long long v20 = xmmword_20B5EDFB0;
  (*(void (**)(btIDebugDraw *, btVector3 *, float32x4_t *, long long *))(*(void *)this + 16))(this, &v22, &v21, &v20);
  LODWORD(v10) = 0;
  *((float *)&v10 + 1) = a3;
  float32x4_t v11 = vmulq_f32((float32x4_t)v10, (float32x4_t)a2->var0.var0[0]);
  int8x16_t v12 = (int8x16_t)vmulq_f32((float32x4_t)v10, (float32x4_t)a2->var0.var0[1]);
  int8x16_t v13 = (int8x16_t)vmulq_f32((float32x4_t)v10, (float32x4_t)a2->var0.var0[2]);
  v13.i32[3] = 0;
  *(float32x2_t *)v11.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v12.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)));
  *(float32x2_t *)&v11.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL)), 0);
  long long v20 = xmmword_20B5EDFC0;
  float32x4_t v21 = vaddq_f32(v11, (float32x4_t)v22);
  (*(void (**)(btIDebugDraw *, btVector3 *, float32x4_t *, long long *))(*(void *)this + 16))(this, &v22, &v21, &v20);
  v14.i64[0] = 0;
  v14.i64[1] = LODWORD(a3);
  float32x4_t v15 = vmulq_f32(v14, (float32x4_t)a2->var0.var0[0]);
  int8x16_t v16 = (int8x16_t)vmulq_f32(v14, (float32x4_t)a2->var0.var0[1]);
  int8x16_t v17 = (int8x16_t)vmulq_f32(v14, (float32x4_t)a2->var0.var0[2]);
  v17.i32[3] = 0;
  *(float32x2_t *)v15.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v16.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)));
  *(float32x2_t *)&v15.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL)), 0);
  long long v20 = xmmword_20B5EDFD0;
  float32x4_t v21 = vaddq_f32(v15, (float32x4_t)v22);
  return (*(uint64_t (**)(btIDebugDraw *, btVector3 *, float32x4_t *, long long *))(*(void *)this + 16))(this, &v22, &v21, &v20);
}

void btIDebugDraw::drawArc(btIDebugDraw *this, float32x4_t *a2, int8x16_t *a3, float32x4_t *a4, float a5, float a6, float a7, float a8, const btVector3 *a9, int a10, float a11)
{
  float32x4_t v17 = *a4;
  *(int8x8_t *)v18.f32 = vext_s8(*(int8x8_t *)a3->i8, (int8x8_t)*(_OWORD *)&vextq_s8(*a3, *a3, 8uLL), 4uLL);
  v18.i64[1] = a3->i64[0];
  *(int8x8_t *)v19.f32 = vext_s8(*(int8x8_t *)a4->f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL), 4uLL);
  v19.i64[1] = a4->i64[0];
  int8x16_t v20 = (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)a3, v19), vmulq_f32(*a4, v18));
  v19.i64[0] = vextq_s8(v20, v20, 4uLL).u64[0];
  v19.i64[1] = v20.u32[0];
  float32x4_t v34 = v19;
  float v21 = a8 - a7;
  if ((int)(float)((float)(a8 - a7) / (float)(a11 * 0.017453)) <= 1) {
    int v22 = 1;
  }
  else {
    int v22 = (int)(float)((float)(a8 - a7) / (float)(a11 * 0.017453));
  }
  float32x4_t v32 = vmulq_n_f32(v17, a5);
  __float2 v23 = __sincosf_stret(a7);
  float32x4_t v24 = vmulq_n_f32(v32, v23.__cosval);
  v24.i32[3] = 0;
  float32x4_t v35 = vmulq_n_f32(v34, a6);
  float32x4_t v25 = vmulq_n_f32(v35, v23.__sinval);
  v25.i32[3] = 0;
  float32x4_t v40 = vaddq_f32(vaddq_f32(*a2, v24), v25);
  if (a10) {
    (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, a2, &v40, a9);
  }
  float v26 = a5;
  if (v22 >= 1)
  {
    int v27 = 0;
    float32x4_t v28 = v35;
    v28.i32[3] = 0;
    float32x4_t v36 = v28;
    do
    {
      ++v27;
      float32x4_t v38 = vmulq_n_f32(*a4, v26);
      __float2 v29 = __sincosf_stret((float)((float)(v21 * (float)v27) / (float)v22) + a7);
      float32x4_t v30 = vmulq_n_f32(v38, v29.__cosval);
      v30.i32[3] = 0;
      float32x4_t v31 = vmulq_n_f32(v36, v29.__sinval);
      v31.i32[3] = 0;
      float32x4_t v39 = vaddq_f32(vaddq_f32(*a2, v30), v31);
      (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v40, &v39, a9);
      float v26 = a5;
      float32x4_t v40 = v39;
    }
    while (v22 != v27);
  }
  if (a10) {
    (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, a2, &v40, a9);
  }
}

void btIDebugDraw::drawSpherePatch(btIDebugDraw *this, float32x4_t *a2, float32x4_t *a3, int8x16_t *a4, float a5, float a6, float a7, float a8, float a9, const btVector3 *a10, float a11)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  float32x4_t v13 = *a3;
  float32x4_t v14 = vmulq_n_f32(*a3, a5);
  float32x4_t v16 = vsubq_f32(*a2, v14);
  v14.i32[3] = 0;
  float32x4_t v17 = vaddq_f32(*a2, v14);
  v16.i32[3] = 0;
  float32x4_t v67 = v16;
  float32x4_t v68 = v17;
  float v18 = a11 * 0.017453;
  *(int8x8_t *)v19.f32 = vext_s8(*(int8x8_t *)v13.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), 4uLL);
  v19.i64[1] = v13.i64[0];
  *(int8x8_t *)v20.f32 = vext_s8(*(int8x8_t *)a4->i8, (int8x8_t)*(_OWORD *)&vextq_s8(*a4, *a4, 8uLL), 4uLL);
  v20.i64[1] = a4->i64[0];
  int8x16_t v21 = (int8x16_t)vsubq_f32(vmulq_f32(v13, v20), vmulq_f32(v19, *(float32x4_t *)a4));
  v22.i64[0] = vextq_s8(v21, v21, 4uLL).u64[0];
  v22.i64[1] = v21.i64[0];
  BOOL v58 = a6 <= -1.5708;
  if (a6 > -1.5708) {
    float v23 = a6;
  }
  else {
    float v23 = v18 + -1.5708;
  }
  BOOL v59 = a7 >= 1.5708;
  if (a7 < 1.5708) {
    float v24 = a7;
  }
  else {
    float v24 = 1.5708 - v18;
  }
  if (v23 > v24)
  {
    BOOL v58 = 1;
    BOOL v59 = 1;
    float v24 = 1.5708 - v18;
    float v23 = v18 + -1.5708;
  }
  int v25 = 0;
  float32x4_t v26 = v22;
  v26.i32[3] = 0;
  float32x4_t v65 = v26;
  float v27 = v24 - v23;
  if ((int)(float)(v27 / v18) <= 1) {
    int v28 = 1;
  }
  else {
    int v28 = (int)(float)(v27 / v18);
  }
  BOOL v29 = a8 <= a9;
  BOOL v30 = a8 > a9;
  float v31 = 3.1416;
  if (a8 <= a9) {
    float v31 = a9;
  }
  float v32 = a9 - a8;
  if (v29) {
    float v33 = a8;
  }
  else {
    float v33 = v18 + -3.1416;
  }
  if (v32 >= 6.2832) {
    BOOL v30 = 1;
  }
  BOOL v62 = v30;
  int v34 = (int)(float)((float)(v31 - v33) / v18);
  if (v34 <= 1) {
    int v34 = 1;
  }
  float v35 = v27 / (float)v28;
  float v36 = (float)(v31 - v33) / (float)v34;
  uint64_t v37 = 16 * v34;
  float32x4_t v38 = &v69;
  float32x4_t v39 = &v70;
  int v56 = v28;
  while (2)
  {
    uint64_t v61 = v39;
    __float2 v40 = __sincosf_stret(v23 + (float)((float)v25 * v35));
    int v41 = 0;
    unint64_t v42 = 0;
    float v43 = v40.__cosval * a5;
    BOOL v44 = v25 == 0;
    BOOL v45 = v25 == v28;
    BOOL v46 = v25 == v28 && v58;
    if (v45) {
      BOOL v44 = 1;
    }
    BOOL v60 = v44;
    do
    {
      __float2 v47 = __sincosf_stret(v33 + (float)((float)v41 * v36));
      float32x4_t v48 = vmulq_n_f32(*(float32x4_t *)a4, v43 * v47.__cosval);
      v48.i32[3] = 0;
      float32x4_t v49 = vmulq_n_f32(v65, v43 * v47.__sinval);
      v49.i32[3] = 0;
      float32x4_t v50 = vaddq_f32(vaddq_f32(*a2, v48), v49);
      float32x4_t v51 = vmulq_n_f32(*a3, v40.__sinval * a5);
      v51.i32[3] = 0;
      *(float32x4_t *)&v38[v42] = vaddq_f32(v50, v51);
      if (v25)
      {
        float32x4_t v52 = (float32x4_t *)&v61[v42];
      }
      else
      {
        if (!v59) {
          goto LABEL_34;
        }
        float32x4_t v52 = &v67;
      }
      (*(void (**)(btIDebugDraw *, float32x4_t *, char *, const btVector3 *))(*(void *)this + 16))(this, v52, &v38[v42], a10);
LABEL_34:
      if (v42)
      {
        (*(void (**)(btIDebugDraw *, char *, char *, const btVector3 *))(*(void *)this + 16))(this, &v38[v42 - 16], &v38[v42], a10);
        if (!v46) {
          goto LABEL_37;
        }
LABEL_36:
        (*(void (**)(btIDebugDraw *, float32x4_t *, char *, const btVector3 *))(*(void *)this + 16))(this, &v68, &v38[v42], a10);
        goto LABEL_37;
      }
      long long v66 = *(_OWORD *)v38;
      if (v46) {
        goto LABEL_36;
      }
LABEL_37:
      if (v62)
      {
        if (v37 != v42) {
          goto LABEL_47;
        }
        CFNumberRef v53 = (float32x4_t *)&v66;
LABEL_46:
        (*(void (**)(btIDebugDraw *, float32x4_t *, char *, const btVector3 *))(*(void *)this + 16))(this, v53, &v38[v42], a10);
        goto LABEL_47;
      }
      if (v42) {
        BOOL v54 = v37 == v42;
      }
      else {
        BOOL v54 = 1;
      }
      BOOL v55 = v60;
      if (!v54) {
        BOOL v55 = 0;
      }
      CFNumberRef v53 = a2;
      if (v55) {
        goto LABEL_46;
      }
LABEL_47:
      v42 += 16;
      ++v41;
    }
    while (v37 + 16 != v42);
    float32x4_t v39 = v38;
    float32x4_t v38 = v61;
    int v28 = v56;
    BOOL v45 = v25++ == v56;
    if (!v45) {
      continue;
    }
    break;
  }
}

uint64_t btIDebugDraw::drawBox(btIDebugDraw *this, const btVector3 *a2, const btVector3 *a3, const btVector3 *a4)
{
  float v8 = a2->var0.var0[1];
  float v29 = a2->var0.var0[0];
  *(float *)&unint64_t v30 = v8;
  HIDWORD(v30) = LODWORD(a2->var0.var0[2]);
  int v31 = 0;
  *(float *)float v27 = a3->var0.var0[0];
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), LODWORD(v8));
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *))(*(void *)this + 16))(this, &v29, v27);
  float v9 = a2->var0.var0[2];
  *(float *)&unint64_t v30 = a2->var0.var0[1];
  *((float *)&v30 + 1) = v9;
  int v31 = 0;
  uint64_t v10 = *(void *)a3->var0.var0;
  LODWORD(v29) = *(void *)a3->var0.var0;
  *(void *)float v27 = v10;
  *(float *)&v27[8] = v9;
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v11 = a3->var0.var0[1];
  float v29 = a3->var0.var0[0];
  *(float *)&unint64_t v30 = v11;
  HIDWORD(v30) = LODWORD(a2->var0.var0[2]);
  int v31 = 0;
  *(float *)float v27 = a2->var0.var0[0];
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), LODWORD(v11));
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v12 = a2->var0.var0[2];
  *(float *)&unint64_t v30 = a3->var0.var0[1];
  *((float *)&v30 + 1) = v12;
  int v31 = 0;
  uint64_t v13 = *(void *)a2->var0.var0;
  LODWORD(v29) = *(void *)a2->var0.var0;
  *(void *)float v27 = v13;
  *(float *)&v27[8] = v12;
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v29 = a2->var0.var0[0];
  unint64_t v30 = *(void *)&a2->var0.var0[1];
  int v31 = 0;
  *(float *)float v27 = v29;
  *(_DWORD *)&v27[4] = v30;
  *(float *)&v27[8] = a3->var0.var0[2];
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v29 = a3->var0.var0[0];
  unint64_t v30 = *(void *)&a2->var0.var0[1];
  int v31 = 0;
  *(float *)float v27 = v29;
  *(_DWORD *)&v27[4] = v30;
  *(float *)&v27[8] = a3->var0.var0[2];
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v14 = a3->var0.var0[0];
  float v15 = a2->var0.var0[2];
  int v31 = 0;
  *(float *)float v27 = v14;
  uint64_t v16 = *(void *)&a3->var0.var0[1];
  float v29 = v14;
  unint64_t v30 = __PAIR64__(LODWORD(v15), v16);
  *(void *)&v27[4] = v16;
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v17 = a2->var0.var0[0];
  float v18 = a2->var0.var0[2];
  int v31 = 0;
  *(float *)float v27 = v17;
  uint64_t v19 = *(void *)&a3->var0.var0[1];
  float v29 = v17;
  unint64_t v30 = __PAIR64__(LODWORD(v18), v19);
  *(void *)&v27[4] = v19;
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v20 = a2->var0.var0[1];
  float v29 = a2->var0.var0[0];
  *(float *)&unint64_t v30 = v20;
  HIDWORD(v30) = LODWORD(a3->var0.var0[2]);
  int v31 = 0;
  *(float *)float v27 = a3->var0.var0[0];
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), LODWORD(v20));
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v21 = a3->var0.var0[2];
  *(float *)&unint64_t v30 = a2->var0.var0[1];
  *((float *)&v30 + 1) = v21;
  int v31 = 0;
  uint64_t v22 = *(void *)a3->var0.var0;
  LODWORD(v29) = *(void *)a3->var0.var0;
  *(void *)float v27 = v22;
  *(float *)&v27[8] = v21;
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v23 = a3->var0.var0[1];
  float v29 = a3->var0.var0[0];
  *(float *)&unint64_t v30 = v23;
  HIDWORD(v30) = LODWORD(a3->var0.var0[2]);
  int v31 = 0;
  *(float *)float v27 = a2->var0.var0[0];
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), LODWORD(v23));
  int v28 = 0;
  (*(void (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
  float v24 = a3->var0.var0[2];
  *(float *)&unint64_t v30 = a3->var0.var0[1];
  *((float *)&v30 + 1) = v24;
  int v31 = 0;
  uint64_t v25 = *(void *)a2->var0.var0;
  LODWORD(v29) = *(void *)a2->var0.var0;
  *(void *)float v27 = v25;
  *(float *)&v27[8] = v24;
  int v28 = 0;
  return (*(uint64_t (**)(btIDebugDraw *, float *, unsigned char *, const btVector3 *))(*(void *)this + 16))(this, &v29, v27, a4);
}

uint64_t btIDebugDraw::drawBox(btIDebugDraw *this, float32x4_t *a2, float32x4_t *a3, const btTransform *a4, const btVector3 *a5)
{
  float32x4_t v10 = *a2;
  float v11 = a2->f32[2];
  float32x4_t v12 = *a2;
  v12.f32[2] = v11;
  float32x4_t v13 = (float32x4_t)a4->var0.var0[2];
  btVector3 var1 = a4->var1;
  int8x16_t v15 = (int8x16_t)vmulq_f32(v12, v13);
  v12.i32[3] = 0;
  float32x4_t v16 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v17 = (float32x4_t)a4->var0.var0[1];
  int8x16_t v18 = (int8x16_t)vmulq_f32((float32x4_t)a4->var0.var0[0], v12);
  float32x4_t v19 = vmulq_f32(v12, v17);
  v15.i32[3] = 0;
  float v20 = &a2->f32[1];
  *(float32x2_t *)v19.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, *(float32x2_t *)v19.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL)));
  *(float32x2_t *)&v19.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v19, (float32x4_t)var1);
  v19.i32[0] = a3->i32[0];
  float v21 = &a3->f32[1];
  v19.i32[1] = v10.i32[1];
  uint64_t v22 = &a2->f32[2];
  v19.i64[1] = LODWORD(v11);
  float32x4_t v23 = vmulq_f32(v16, v19);
  int8x16_t v24 = (int8x16_t)vmulq_f32(v17, v19);
  int8x16_t v25 = (int8x16_t)vmulq_f32(v13, v19);
  v25.i32[3] = 0;
  *(float32x2_t *)v23.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v24.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)));
  *(float32x2_t *)&v23.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)var1, v23);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float v26 = a2->f32[2];
  float32x4_t v27 = *a3;
  v27.i32[3] = 0;
  float32x4_t v28 = v27;
  v28.f32[1] = *v20;
  v28.f32[2] = v26;
  float32x4_t v29 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v30 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v31 = vmulq_f32((float32x4_t)a4->var0.var0[0], v28);
  int8x16_t v32 = (int8x16_t)vmulq_f32(v30, v28);
  float32x4_t v33 = (float32x4_t)a4->var0.var0[2];
  btVector3 v34 = a4->var1;
  int8x16_t v35 = (int8x16_t)vmulq_f32(v28, v33);
  v35.i32[3] = 0;
  *(float32x2_t *)v31.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v32.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)));
  *(float32x2_t *)&v31.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)), 0);
  v27.i32[1] = HIDWORD(a3->i64[0]);
  float32x4_t v162 = vaddq_f32(v31, (float32x4_t)v34);
  v27.f32[2] = v26;
  float32x4_t v36 = vmulq_f32(v29, v27);
  int8x16_t v37 = (int8x16_t)vmulq_f32(v30, v27);
  int8x16_t v38 = (int8x16_t)vmulq_f32(v33, v27);
  v38.i32[3] = 0;
  *(float32x2_t *)v36.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v37.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)));
  *(float32x2_t *)&v36.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v34, v36);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v39 = *a3;
  __int32 v40 = a2->i32[2];
  v41.i32[0] = a2->i32[0];
  v41.i32[1] = HIDWORD(a3->i64[0]);
  v39.i32[2] = v40;
  float32x4_t v42 = v39;
  v42.i32[3] = 0;
  float32x4_t v43 = (float32x4_t)a4->var0.var0[2];
  btVector3 v44 = a4->var1;
  int8x16_t v45 = (int8x16_t)vmulq_f32(v39, v43);
  float32x4_t v46 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v47 = (float32x4_t)a4->var0.var0[1];
  int8x16_t v48 = (int8x16_t)vmulq_f32((float32x4_t)a4->var0.var0[0], v42);
  float32x4_t v49 = vmulq_f32(v42, v47);
  v45.i32[3] = 0;
  *(float32x2_t *)v49.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v48.i8, *(float32x2_t *)v49.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL)));
  *(float32x2_t *)&v49.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v49, (float32x4_t)v44);
  v41.i32[2] = v40;
  float32x4_t v50 = vmulq_f32(v46, v41);
  int8x16_t v51 = (int8x16_t)vmulq_f32(v47, v41);
  int8x16_t v52 = (int8x16_t)vmulq_f32(v43, v41);
  v52.i32[3] = 0;
  *(float32x2_t *)v50.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v50.f32, *(float32x2_t *)v51.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL)));
  *(float32x2_t *)&v50.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v44, v50);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v53 = *a2;
  v53.i32[3] = 0;
  float32x4_t v54 = v53;
  v54.f32[1] = *v21;
  v54.i32[2] = a2->i64[1];
  float32x4_t v55 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v56 = vmulq_f32((float32x4_t)a4->var0.var0[0], v54);
  int8x16_t v57 = (int8x16_t)vmulq_f32(v55, v54);
  float32x4_t v58 = (float32x4_t)a4->var0.var0[2];
  btVector3 v59 = a4->var1;
  int8x16_t v60 = (int8x16_t)vmulq_f32(v54, v58);
  v60.i32[3] = 0;
  *(float32x2_t *)v56.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v56.f32, *(float32x2_t *)v57.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)));
  *(float32x2_t *)&v56.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL)), 0);
  v53.i32[0] = (__int32)*a2;
  float32x4_t v61 = vmulq_f32((float32x4_t)a4->var0.var0[0], v53);
  int8x16_t v62 = (int8x16_t)vmulq_f32(v55, v53);
  int8x16_t v63 = (int8x16_t)vmulq_f32(v58, v53);
  v63.i32[3] = 0;
  *(float32x2_t *)v61.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v61.f32, *(float32x2_t *)v62.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v61, (int8x16_t)v61, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL)));
  *(float32x2_t *)&v61.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v63.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v59, v61);
  float32x4_t v162 = vaddq_f32(v56, (float32x4_t)v59);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v64 = *a2;
  v64.i32[3] = 0;
  float32x4_t v65 = v64;
  v65.i32[2] = a2->i64[1];
  float32x4_t v66 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v67 = vmulq_f32((float32x4_t)a4->var0.var0[0], v65);
  int8x16_t v68 = (int8x16_t)vmulq_f32(v66, v65);
  float32x4_t v69 = (float32x4_t)a4->var0.var0[2];
  btVector3 v70 = a4->var1;
  int8x16_t v71 = (int8x16_t)vmulq_f32(v65, v69);
  v71.i32[3] = 0;
  *(float32x2_t *)v67.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v67.f32, *(float32x2_t *)v68.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)));
  *(float32x2_t *)&v67.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL)), 0);
  v64.i32[2] = a3->i32[2];
  float32x4_t v72 = vmulq_f32((float32x4_t)a4->var0.var0[0], v64);
  int8x16_t v73 = (int8x16_t)vmulq_f32(v66, v64);
  int8x16_t v74 = (int8x16_t)vmulq_f32(v69, v64);
  v74.i32[3] = 0;
  *(float32x2_t *)v72.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v72.f32, *(float32x2_t *)v73.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL)));
  *(float32x2_t *)&v72.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v70, v72);
  float32x4_t v162 = vaddq_f32(v67, (float32x4_t)v70);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v75 = *a3;
  v75.f32[1] = *v20;
  v75.i32[3] = 0;
  float32x4_t v76 = v75;
  v76.f32[2] = *v22;
  float32x4_t v77 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v78 = vmulq_f32((float32x4_t)a4->var0.var0[0], v76);
  int8x16_t v79 = (int8x16_t)vmulq_f32(v77, v76);
  float32x4_t v80 = (float32x4_t)a4->var0.var0[2];
  btVector3 v81 = a4->var1;
  int8x16_t v82 = (int8x16_t)vmulq_f32(v76, v80);
  v82.i32[3] = 0;
  *(float32x2_t *)v78.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v78.f32, *(float32x2_t *)v79.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v78, (int8x16_t)v78, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL)));
  *(float32x2_t *)&v78.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL)), 0);
  v75.i32[2] = a3->i64[1];
  float32x4_t v83 = vmulq_f32((float32x4_t)a4->var0.var0[0], v75);
  int8x16_t v84 = (int8x16_t)vmulq_f32(v77, v75);
  int8x16_t v85 = (int8x16_t)vmulq_f32(v80, v75);
  v85.i32[3] = 0;
  *(float32x2_t *)v83.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v83.f32, *(float32x2_t *)v84.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v83, (int8x16_t)v83, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v84, v84, 8uLL)));
  *(float32x2_t *)&v83.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v81, v83);
  float32x4_t v162 = vaddq_f32(v78, (float32x4_t)v81);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v86 = *a3;
  v86.i32[3] = 0;
  float32x4_t v87 = v86;
  v87.f32[2] = *v22;
  float32x4_t v88 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v89 = vmulq_f32((float32x4_t)a4->var0.var0[0], v87);
  int8x16_t v90 = (int8x16_t)vmulq_f32(v88, v87);
  float32x4_t v91 = (float32x4_t)a4->var0.var0[2];
  btVector3 v92 = a4->var1;
  int8x16_t v93 = (int8x16_t)vmulq_f32(v87, v91);
  v93.i32[3] = 0;
  *(float32x2_t *)v89.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v89.f32, *(float32x2_t *)v90.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v89, (int8x16_t)v89, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL)));
  *(float32x2_t *)&v89.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v93, v93, 8uLL)), 0);
  v86.i32[2] = a3->i64[1];
  float32x4_t v94 = vmulq_f32((float32x4_t)a4->var0.var0[0], v86);
  int8x16_t v95 = (int8x16_t)vmulq_f32(v88, v86);
  int8x16_t v96 = (int8x16_t)vmulq_f32(v91, v86);
  v96.i32[3] = 0;
  *(float32x2_t *)v94.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v94.f32, *(float32x2_t *)v95.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL)));
  *(float32x2_t *)&v94.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v96, v96, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v92, v94);
  float32x4_t v162 = vaddq_f32(v89, (float32x4_t)v92);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v97 = *a2;
  v97.f32[1] = *v21;
  v97.i32[3] = 0;
  float32x4_t v98 = v97;
  v98.i32[2] = a2->i64[1];
  float32x4_t v99 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v100 = vmulq_f32((float32x4_t)a4->var0.var0[0], v98);
  int8x16_t v101 = (int8x16_t)vmulq_f32(v99, v98);
  float32x4_t v102 = (float32x4_t)a4->var0.var0[2];
  btVector3 v103 = a4->var1;
  int8x16_t v104 = (int8x16_t)vmulq_f32(v98, v102);
  v104.i32[3] = 0;
  *(float32x2_t *)v100.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v101.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v101, v101, 8uLL)));
  *(float32x2_t *)&v100.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v104.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL)), 0);
  v97.i32[2] = a3->i32[2];
  float32x4_t v105 = vmulq_f32((float32x4_t)a4->var0.var0[0], v97);
  int8x16_t v106 = (int8x16_t)vmulq_f32(v99, v97);
  int8x16_t v107 = (int8x16_t)vmulq_f32(v102, v97);
  v107.i32[3] = 0;
  *(float32x2_t *)v105.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v105.f32, *(float32x2_t *)v106.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v105, (int8x16_t)v105, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL)));
  *(float32x2_t *)&v105.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v107.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v107, v107, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v103, v105);
  float32x4_t v162 = vaddq_f32(v100, (float32x4_t)v103);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v108 = *a2;
  __int32 v109 = a3->i32[2];
  v110.i32[0] = a3->i32[0];
  v110.i32[1] = HIDWORD(a2->i64[0]);
  v108.i32[2] = v109;
  float32x4_t v111 = v108;
  v111.i32[3] = 0;
  float32x4_t v112 = (float32x4_t)a4->var0.var0[2];
  btVector3 v113 = a4->var1;
  int8x16_t v114 = (int8x16_t)vmulq_f32(v108, v112);
  float32x4_t v115 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v116 = (float32x4_t)a4->var0.var0[1];
  int8x16_t v117 = (int8x16_t)vmulq_f32((float32x4_t)a4->var0.var0[0], v111);
  float32x4_t v118 = vmulq_f32(v111, v116);
  v114.i32[3] = 0;
  *(float32x2_t *)v118.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v117.i8, *(float32x2_t *)v118.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v117, v117, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v118, (int8x16_t)v118, 8uLL)));
  *(float32x2_t *)&v118.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v114.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v114, v114, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v118, (float32x4_t)v113);
  v110.i32[2] = v109;
  float32x4_t v119 = vmulq_f32(v115, v110);
  int8x16_t v120 = (int8x16_t)vmulq_f32(v116, v110);
  int8x16_t v121 = (int8x16_t)vmulq_f32(v112, v110);
  v121.i32[3] = 0;
  *(float32x2_t *)v119.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v119.f32, *(float32x2_t *)v120.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL)));
  *(float32x2_t *)&v119.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v121.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v121, v121, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v113, v119);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v122 = *a3;
  v122.i32[3] = 0;
  float32x4_t v123 = v122;
  v123.f32[1] = *v20;
  v123.i32[2] = a3->i64[1];
  float32x4_t v124 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v125 = vmulq_f32((float32x4_t)a4->var0.var0[0], v123);
  int8x16_t v126 = (int8x16_t)vmulq_f32(v124, v123);
  float32x4_t v127 = (float32x4_t)a4->var0.var0[2];
  btVector3 v128 = a4->var1;
  int8x16_t v129 = (int8x16_t)vmulq_f32(v123, v127);
  v129.i32[3] = 0;
  *(float32x2_t *)v125.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v125.f32, *(float32x2_t *)v126.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v125, (int8x16_t)v125, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v126, v126, 8uLL)));
  *(float32x2_t *)&v125.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v129.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v129, v129, 8uLL)), 0);
  v122.i32[0] = (__int32)*a3;
  float32x4_t v130 = vmulq_f32((float32x4_t)a4->var0.var0[0], v122);
  int8x16_t v131 = (int8x16_t)vmulq_f32(v124, v122);
  int8x16_t v132 = (int8x16_t)vmulq_f32(v127, v122);
  v132.i32[3] = 0;
  *(float32x2_t *)v130.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v131.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v130, (int8x16_t)v130, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v131, v131, 8uLL)));
  *(float32x2_t *)&v130.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v132.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v132, v132, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v128, v130);
  float32x4_t v162 = vaddq_f32(v125, (float32x4_t)v128);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float32x4_t v133 = *a3;
  __int32 v134 = a3->i32[2];
  v135.i32[0] = a2->i32[0];
  v135.i32[1] = HIDWORD(a3->i64[0]);
  v133.i32[2] = v134;
  float32x4_t v136 = v133;
  v136.i32[3] = 0;
  float32x4_t v137 = (float32x4_t)a4->var0.var0[2];
  btVector3 v138 = a4->var1;
  int8x16_t v139 = (int8x16_t)vmulq_f32(v133, v137);
  float32x4_t v140 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v141 = (float32x4_t)a4->var0.var0[1];
  int8x16_t v142 = (int8x16_t)vmulq_f32((float32x4_t)a4->var0.var0[0], v136);
  float32x4_t v143 = vmulq_f32(v136, v141);
  v139.i32[3] = 0;
  *(float32x2_t *)v143.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v142.i8, *(float32x2_t *)v143.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v142, v142, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v143, (int8x16_t)v143, 8uLL)));
  *(float32x2_t *)&v143.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v139.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v139, v139, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v143, (float32x4_t)v138);
  v135.i32[2] = v134;
  float32x4_t v144 = vmulq_f32(v140, v135);
  int8x16_t v145 = (int8x16_t)vmulq_f32(v141, v135);
  int8x16_t v146 = (int8x16_t)vmulq_f32(v137, v135);
  v146.i32[3] = 0;
  *(float32x2_t *)v144.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v144.f32, *(float32x2_t *)v145.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v144, (int8x16_t)v144, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v145, v145, 8uLL)));
  *(float32x2_t *)&v144.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v146.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v146, v146, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v138, v144);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
  float v147 = a3->f32[2];
  float32x4_t v148 = *a2;
  v148.i32[3] = 0;
  float32x4_t v149 = v148;
  v149.f32[1] = *v21;
  v149.f32[2] = v147;
  float32x4_t v150 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v151 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v152 = vmulq_f32((float32x4_t)a4->var0.var0[0], v149);
  int8x16_t v153 = (int8x16_t)vmulq_f32(v151, v149);
  float32x4_t v154 = (float32x4_t)a4->var0.var0[2];
  btVector3 v155 = a4->var1;
  int8x16_t v156 = (int8x16_t)vmulq_f32(v149, v154);
  v156.i32[3] = 0;
  *(float32x2_t *)v152.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v152.f32, *(float32x2_t *)v153.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v152, (int8x16_t)v152, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL)));
  *(float32x2_t *)&v152.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v156.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v156, v156, 8uLL)), 0);
  v148.i32[1] = HIDWORD(a2->i64[0]);
  float32x4_t v162 = vaddq_f32(v152, (float32x4_t)v155);
  v148.f32[2] = v147;
  float32x4_t v157 = vmulq_f32(v150, v148);
  int8x16_t v158 = (int8x16_t)vmulq_f32(v151, v148);
  int8x16_t v159 = (int8x16_t)vmulq_f32(v154, v148);
  v159.i32[3] = 0;
  *(float32x2_t *)v157.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v157.f32, *(float32x2_t *)v158.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v157, (int8x16_t)v157, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v158, v158, 8uLL)));
  *(float32x2_t *)&v157.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v159, v159, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32((float32x4_t)v155, v157);
  return (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v162, &v161, a5);
}

uint64_t btIDebugDraw::drawCapsule(btIDebugDraw *this, float32_t a2, float32_t a3, int a4, const btTransform *a5, const btVector3 *a6)
{
  float32x4_t v68 = 0uLL;
  v68.f32[a4] = -a3;
  float32x4_t v67 = 0uLL;
  v67.f32[a4] = a3;
  float32x4_t v11 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v63 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v64 = v11;
  float32x4_t v12 = vmulq_f32(v63, v68);
  int8x16_t v13 = (int8x16_t)vmulq_f32(v11, v68);
  int8x16_t v14 = (int8x16_t)vmulq_f32((float32x4_t)a5->var0.var0[2], v68);
  v14.i32[3] = 0;
  *(float32x2_t *)v12.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v13.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL)));
  *(float32x2_t *)&v12.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)), 0);
  float32x4_t v15 = vaddq_f32((float32x4_t)a5->var1, v12);
  btVector3 v65 = a5->var0.var0[2];
  float32x4_t v66 = v15;
  (*(void (**)(btIDebugDraw *, float32x4_t *, const btVector3 *, float32_t))(*(void *)this + 32))(this, &v63, a6, a2);
  float32x4_t v16 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v63 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v64 = v16;
  float32x4_t v17 = vmulq_f32(v63, v67);
  int8x16_t v18 = (int8x16_t)vmulq_f32(v16, v67);
  int8x16_t v19 = (int8x16_t)vmulq_f32((float32x4_t)a5->var0.var0[2], v67);
  v19.i32[3] = 0;
  *(float32x2_t *)v17.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v17.f32, *(float32x2_t *)v18.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)));
  *(float32x2_t *)&v17.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL)), 0);
  float32x4_t v20 = vaddq_f32((float32x4_t)a5->var1, v17);
  btVector3 v65 = a5->var0.var0[2];
  float32x4_t v66 = v20;
  (*(void (**)(btIDebugDraw *, float32x4_t *, const btVector3 *, float32_t))(*(void *)this + 32))(this, &v63, a6, a2);
  int v21 = (a4 + 1) % 3;
  v68.f32[v21] = a2;
  v67.f32[v21] = a2;
  float32x4_t v22 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v23 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v24 = vmulq_f32((float32x4_t)a5->var0.var0[0], v68);
  int8x16_t v25 = (int8x16_t)vmulq_f32(v68, v23);
  float32x4_t v26 = (float32x4_t)a5->var0.var0[2];
  btVector3 var1 = a5->var1;
  int8x16_t v28 = (int8x16_t)vmulq_f32(v68, v26);
  v28.i32[3] = 0;
  *(float32x2_t *)v24.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v24.f32, *(float32x2_t *)v25.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)));
  *(float32x2_t *)&v24.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32((float32x4_t)var1, v24);
  float32x4_t v29 = vmulq_f32(v22, v67);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v23, v67);
  int8x16_t v31 = (int8x16_t)vmulq_f32(v26, v67);
  v31.i32[3] = 0;
  *(float32x2_t *)v29.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v30.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)));
  *(float32x2_t *)&v29.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL)), 0);
  float32x4_t v61 = (float32x4_t)var1;
  float32x4_t v62 = vaddq_f32((float32x4_t)var1, v29);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v63, &v62, a6);
  v68.f32[v21] = -a2;
  v67.f32[v21] = -a2;
  float32x4_t v32 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v33 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v34 = vmulq_f32((float32x4_t)a5->var0.var0[0], v68);
  int8x16_t v35 = (int8x16_t)vmulq_f32(v68, v33);
  float32x4_t v36 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v37 = (int8x16_t)vmulq_f32(v68, v36);
  v37.i32[3] = 0;
  *(float32x2_t *)v34.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v34.f32, *(float32x2_t *)v35.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v34, (int8x16_t)v34, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)));
  *(float32x2_t *)&v34.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v34);
  float32x4_t v38 = vmulq_f32(v32, v67);
  int8x16_t v39 = (int8x16_t)vmulq_f32(v33, v67);
  int8x16_t v40 = (int8x16_t)vmulq_f32(v36, v67);
  v40.i32[3] = 0;
  *(float32x2_t *)v38.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v39.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL)));
  *(float32x2_t *)&v38.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v38);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v63, &v62, a6);
  v68.i32[v21] = 0;
  v67.i32[v21] = 0;
  int v41 = (a4 + 2) % 3;
  v68.f32[v41] = a2;
  v67.f32[v41] = a2;
  float32x4_t v42 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v43 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v44 = vmulq_f32((float32x4_t)a5->var0.var0[0], v68);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v68, v43);
  float32x4_t v46 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v47 = (int8x16_t)vmulq_f32(v68, v46);
  v47.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v44);
  float32x4_t v48 = vmulq_f32(v42, v67);
  int8x16_t v49 = (int8x16_t)vmulq_f32(v43, v67);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v46, v67);
  v50.i32[3] = 0;
  *(float32x2_t *)v48.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v48.f32, *(float32x2_t *)v49.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
  *(float32x2_t *)&v48.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v48);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v63, &v62, a6);
  v68.f32[v41] = -a2;
  v67.f32[v41] = -a2;
  float32x4_t v51 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v52 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v53 = vmulq_f32((float32x4_t)a5->var0.var0[0], v68);
  int8x16_t v54 = (int8x16_t)vmulq_f32(v68, v52);
  float32x4_t v55 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v56 = (int8x16_t)vmulq_f32(v68, v55);
  v56.i32[3] = 0;
  *(float32x2_t *)v53.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v54.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)));
  *(float32x2_t *)&v53.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v53);
  float32x4_t v57 = vmulq_f32(v51, v67);
  int8x16_t v58 = (int8x16_t)vmulq_f32(v52, v67);
  int8x16_t v59 = (int8x16_t)vmulq_f32(v55, v67);
  v59.i32[3] = 0;
  *(float32x2_t *)v57.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v57.f32, *(float32x2_t *)v58.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v57, (int8x16_t)v57, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)));
  *(float32x2_t *)&v57.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v57);
  return (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v63, &v62, a6);
}

uint64_t btIDebugDraw::drawCylinder(btIDebugDraw *this, float32_t a2, float32_t a3, int a4, const btTransform *a5, const btVector3 *a6)
{
  float32x4_t v73 = 0uLL;
  v73.f32[a4] = a3;
  int v11 = (a4 + 1) % 3;
  float32x4_t v72 = 0uLL;
  v72.f32[v11] = a2;
  float32x4_t v12 = vaddq_f32(v73, v72);
  float32x4_t v60 = v72;
  float32x4_t v13 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v14 = vmulq_f32((float32x4_t)a5->var0.var0[0], v12);
  int8x16_t v15 = (int8x16_t)vmulq_f32(v12, v13);
  float32x4_t v16 = (float32x4_t)a5->var0.var0[2];
  btVector3 var1 = a5->var1;
  int8x16_t v18 = (int8x16_t)vmulq_f32(v12, v16);
  v18.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v15.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)), 0);
  float32x4_t v62 = v73;
  float32x4_t v64 = vnegq_f32(v73);
  float32x4_t v66 = (float32x4_t)var1;
  float32x4_t v19 = vsubq_f32(v72, v73);
  float32x4_t v20 = vmulq_f32((float32x4_t)a5->var0.var0[0], v19);
  int8x16_t v21 = (int8x16_t)vmulq_f32(v13, v19);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, v19);
  v22.i32[3] = 0;
  *(float32x2_t *)v20.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v21.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL)));
  *(float32x2_t *)&v20.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), 0);
  float32x4_t v70 = vaddq_f32((float32x4_t)var1, v20);
  float32x4_t v71 = vaddq_f32((float32x4_t)var1, v14);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *))(*(void *)this + 16))(this, &v71, &v70);
  float32x4_t v23 = vsubq_f32(v62, v60);
  float32x4_t v25 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v24 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v26 = (int8x16_t)vmulq_f32(v24, v23);
  v23.i32[3] = 0;
  int8x16_t v27 = (int8x16_t)vmulq_f32((float32x4_t)a5->var0.var0[0], v23);
  float32x4_t v28 = vmulq_f32(v25, v23);
  v26.i32[3] = 0;
  *(float32x2_t *)v28.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v27.i8, *(float32x2_t *)v28.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL)));
  *(float32x2_t *)&v28.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)), 0);
  float32x4_t v29 = vaddq_f32(v66, v28);
  float32x4_t v30 = vsubq_f32(v64, v60);
  int8x16_t v31 = (int8x16_t)vmulq_f32(v24, v30);
  v30.i32[3] = 0;
  int8x16_t v32 = (int8x16_t)vmulq_f32((float32x4_t)a5->var0.var0[0], v30);
  float32x4_t v33 = vmulq_f32(v25, v30);
  v31.i32[3] = 0;
  *(float32x2_t *)v33.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v32.i8, *(float32x2_t *)v33.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL)));
  *(float32x2_t *)&v33.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL)), 0);
  float32x4_t v70 = vaddq_f32(v66, v33);
  float32x4_t v71 = v29;
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v71, &v70, a6);
  float32x4_t v71 = 0uLL;
  v71.i32[a4] = 1065353216;
  float32x4_t v70 = 0uLL;
  v70.i32[v11] = 1065353216;
  float32x4_t v65 = v73;
  float32x4_t v34 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v35 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v36 = vmulq_f32((float32x4_t)a5->var0.var0[0], v73);
  int8x16_t v37 = (int8x16_t)vmulq_f32(v73, v35);
  float32x4_t v38 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v39 = (int8x16_t)vmulq_f32(v73, v38);
  v39.i32[3] = 0;
  *(float32x2_t *)v36.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v37.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)));
  *(float32x2_t *)&v36.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL)), 0);
  float32x4_t v40 = vsubq_f32(v66, v36);
  v40.i32[3] = 0;
  float32x4_t v69 = v40;
  float32x4_t v63 = v71;
  int8x16_t v41 = (int8x16_t)vmulq_f32(v34, v71);
  int8x16_t v42 = (int8x16_t)vmulq_f32(v35, v71);
  int8x16_t v43 = (int8x16_t)vmulq_f32(v38, v71);
  v43.i32[3] = 0;
  *(float32x2_t *)v41.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v42.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL)));
  v41.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)), 0);
  float32x4_t v61 = v70;
  int8x16_t v44 = (int8x16_t)vmulq_f32(v34, v70);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v35, v70);
  int8x16_t v46 = (int8x16_t)vmulq_f32(v38, v70);
  v46.i32[3] = 0;
  *(float32x2_t *)v44.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.i8, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  v44.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL)), 0);
  int8x16_t v67 = v44;
  int8x16_t v68 = v41;
  (*(void (**)(btIDebugDraw *, float32x4_t *, int8x16_t *, int8x16_t *, const btVector3 *, void, float32_t, float32_t, double, float, float))(*(void *)this + 120))(this, &v69, &v68, &v67, a6, 0, a2, a2, 0.0, 6.2832, 10.0);
  float32x4_t v47 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v48 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v49 = vmulq_f32(v65, (float32x4_t)a5->var0.var0[0]);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v65, v48);
  float32x4_t v51 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v52 = (int8x16_t)vmulq_f32(v65, v51);
  v52.i32[3] = 0;
  *(float32x2_t *)v49.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v49.f32, *(float32x2_t *)v50.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)));
  *(float32x2_t *)&v49.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)), 0);
  float32x4_t v69 = vaddq_f32(v66, v49);
  int8x16_t v53 = (int8x16_t)vmulq_f32(v63, v47);
  int8x16_t v54 = (int8x16_t)vmulq_f32(v63, v48);
  int8x16_t v55 = (int8x16_t)vmulq_f32(v63, v51);
  v55.i32[3] = 0;
  *(float32x2_t *)v53.i8 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)), vpadd_f32(*(float32x2_t *)v53.i8, *(float32x2_t *)v54.i8));
  v53.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), 0);
  int8x16_t v56 = (int8x16_t)vmulq_f32(v61, v47);
  int8x16_t v57 = (int8x16_t)vmulq_f32(v61, v48);
  int8x16_t v58 = (int8x16_t)vmulq_f32(v61, v51);
  v58.i32[3] = 0;
  *(float32x2_t *)v56.i8 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)), vpadd_f32(*(float32x2_t *)v56.i8, *(float32x2_t *)v57.i8));
  v56.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)), 0);
  int8x16_t v67 = v56;
  int8x16_t v68 = v53;
  return (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, int8x16_t *, int8x16_t *, const btVector3 *, void, float32_t, float32_t, double, float, float))(*(void *)this + 120))(this, &v69, &v68, &v67, a6, 0, a2, a2, 0.0, 6.2832, 10.0);
}

uint64_t btIDebugDraw::drawCone(btIDebugDraw *this, float32_t a2, float a3, int a4, const btTransform *a5, const btVector3 *a6)
{
  float32x4_t v81 = 0uLL;
  v81.f32[a4] = a3 * 0.5;
  int v11 = (a4 + 1) % 3;
  float32x4_t v80 = 0uLL;
  v80.f32[v11] = a2;
  float32x4_t v79 = 0uLL;
  v79.f32[(a4 + 2) % 3] = a2;
  float32x4_t v12 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v13 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v14 = vmulq_f32((float32x4_t)a5->var0.var0[0], v81);
  int8x16_t v15 = (int8x16_t)vmulq_f32(v81, v13);
  float32x4_t v16 = (float32x4_t)a5->var0.var0[2];
  btVector3 var1 = a5->var1;
  int8x16_t v18 = (int8x16_t)vmulq_f32(v81, v16);
  v18.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v15.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32((float32x4_t)var1, v14);
  float32x4_t v71 = vnegq_f32(v81);
  float32x4_t v73 = (float32x4_t)var1;
  float32x4_t v67 = v81;
  float32x4_t v69 = v80;
  float32x4_t v19 = vsubq_f32(v80, v81);
  float32x4_t v20 = vmulq_f32(v12, v19);
  int8x16_t v21 = (int8x16_t)vmulq_f32(v13, v19);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, v19);
  v22.i32[3] = 0;
  *(float32x2_t *)v20.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v21.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL)));
  *(float32x2_t *)&v20.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32((float32x4_t)var1, v20);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *))(*(void *)this + 16))(this, &v78, &v77);
  float32x4_t v23 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v24 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v25 = vmulq_f32((float32x4_t)a5->var0.var0[0], v67);
  int8x16_t v26 = (int8x16_t)vmulq_f32(v67, v24);
  float32x4_t v27 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v28 = (int8x16_t)vmulq_f32(v67, v27);
  v28.i32[3] = 0;
  *(float32x2_t *)v25.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v26.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)));
  *(float32x2_t *)&v25.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32(v73, v25);
  float32x4_t v29 = vsubq_f32(v71, v69);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v27, v29);
  v29.i32[3] = 0;
  float32x4_t v31 = vmulq_f32(v23, v29);
  int8x16_t v32 = (int8x16_t)vmulq_f32(v24, v29);
  v30.i32[3] = 0;
  *(float32x2_t *)v31.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v32.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)));
  *(float32x2_t *)&v31.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v31);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v78, &v77, a6);
  float32x4_t v33 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v34 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v35 = vmulq_f32((float32x4_t)a5->var0.var0[0], v81);
  int8x16_t v36 = (int8x16_t)vmulq_f32(v81, v34);
  float32x4_t v37 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v38 = (int8x16_t)vmulq_f32(v81, v37);
  v38.i32[3] = 0;
  *(float32x2_t *)v35.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v35.f32, *(float32x2_t *)v36.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL)));
  *(float32x2_t *)&v35.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32(v73, v35);
  float32x4_t v72 = vnegq_f32(v81);
  float32x4_t v68 = v81;
  float32x4_t v70 = v79;
  float32x4_t v39 = vsubq_f32(v79, v81);
  float32x4_t v40 = vmulq_f32(v33, v39);
  int8x16_t v41 = (int8x16_t)vmulq_f32(v34, v39);
  int8x16_t v42 = (int8x16_t)vmulq_f32(v37, v39);
  v42.i32[3] = 0;
  *(float32x2_t *)v40.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)v41.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v40, (int8x16_t)v40, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL)));
  *(float32x2_t *)&v40.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v40);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v78, &v77, a6);
  float32x4_t v43 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v44 = vmulq_f32((float32x4_t)a5->var0.var0[0], v68);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v68, v43);
  float32x4_t v46 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v47 = (int8x16_t)vmulq_f32(v68, v46);
  v47.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL)), 0);
  float32x4_t v48 = vaddq_f32(v73, v44);
  float32x4_t v49 = vsubq_f32(v72, v70);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v46, v49);
  v49.i32[3] = 0;
  float32x4_t v51 = vmulq_f32((float32x4_t)a5->var0.var0[0], v49);
  int8x16_t v52 = (int8x16_t)vmulq_f32(v43, v49);
  v50.i32[3] = 0;
  *(float32x2_t *)v51.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v52.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)));
  *(float32x2_t *)&v51.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v51);
  float32x4_t v78 = v48;
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v78, &v77, a6);
  float32x4_t v78 = 0uLL;
  v78.i32[a4] = 1065353216;
  float32x4_t v77 = 0uLL;
  v77.i32[v11] = 1065353216;
  float32x4_t v53 = (float32x4_t)a5->var0.var0[0];
  float32x4_t v54 = (float32x4_t)a5->var0.var0[1];
  float32x4_t v55 = vmulq_f32((float32x4_t)a5->var0.var0[0], v81);
  int8x16_t v56 = (int8x16_t)vmulq_f32(v81, v54);
  float32x4_t v57 = (float32x4_t)a5->var0.var0[2];
  int8x16_t v58 = (int8x16_t)vmulq_f32(v81, v57);
  v58.i32[3] = 0;
  *(float32x2_t *)v55.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v55.f32, *(float32x2_t *)v56.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)));
  *(float32x2_t *)&v55.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)), 0);
  float32x4_t v59 = vsubq_f32(v73, v55);
  v59.i32[3] = 0;
  float32x4_t v76 = v59;
  int8x16_t v60 = (int8x16_t)vmulq_f32(v53, v78);
  int8x16_t v61 = (int8x16_t)vmulq_f32(v54, v78);
  int8x16_t v62 = (int8x16_t)vmulq_f32(v57, v78);
  v62.i32[3] = 0;
  *(float32x2_t *)v60.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v60.i8, *(float32x2_t *)v61.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)));
  v60.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v62.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL)), 0);
  int8x16_t v63 = (int8x16_t)vmulq_f32(v53, v77);
  int8x16_t v64 = (int8x16_t)vmulq_f32(v54, v77);
  int8x16_t v65 = (int8x16_t)vmulq_f32(v57, v77);
  v65.i32[3] = 0;
  *(float32x2_t *)v63.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v63.i8, *(float32x2_t *)v64.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL)));
  v63.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v65.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL)), 0);
  int8x16_t v74 = v63;
  int8x16_t v75 = v60;
  return (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, int8x16_t *, int8x16_t *, const btVector3 *, void, float32_t, float32_t, double, float, float))(*(void *)this + 120))(this, &v76, &v75, &v74, a6, 0, a2, a2, 0.0, 6.2832, 10.0);
}

uint64_t btIDebugDraw::drawPlane(btIDebugDraw *this, float32x4_t *a2, float a3, const btTransform *a4, const btVector3 *a5, float32x4_t a6)
{
  float32x4_t v9 = *a2;
  LODWORD(v10) = a2->i64[1];
  LODWORD(v11) = HIDWORD(a2->i64[0]);
  if (fabsf(v10) <= 0.70711)
  {
    float v16 = (float)(v11 * v11) + (float)(v9.f32[0] * v9.f32[0]);
    float v17 = 1.0 / sqrtf(v16);
    int8x16_t v18 = vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL);
    *(int32x2_t *)v18.i8 = vzip1_s32(*(int32x2_t *)v9.f32, *(int32x2_t *)v18.i8);
    int32x4_t v19 = (int32x4_t)v18;
    *(float *)&v19.i32[1] = -v11;
    *(float32x2_t *)v19.i8 = vmul_n_f32(*(float32x2_t *)v19.i8, v17);
    float32x4_t v15 = (float32x4_t)vrev64q_s32(v19).u64[0];
    *(float *)v18.i32 = -v10;
    *(float32x2_t *)a6.f32 = vmul_f32(*(float32x2_t *)v19.i8, *(float32x2_t *)v18.i8);
    a6.f32[2] = v16 * v17;
  }
  else
  {
    float v12 = (float)(v10 * v10) + (float)(v11 * v11);
    float v13 = 1.0 / sqrtf(v12);
    *(float *)&unsigned int v14 = v11 * v13;
    v15.i32[0] = 0;
    v15.f32[1] = -(float)(v10 * v13);
    v15.i64[1] = v14;
    a6.f32[0] = v12 * v13;
    a6.f32[1] = -(float)(v9.f32[0] * *(float *)&v14);
    a6.f32[2] = v9.f32[0] * v15.f32[1];
  }
  float32x4_t v20 = vmulq_n_f32(v9, a3);
  v20.i32[3] = 0;
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x42C80000u);
  float32x4_t v22 = vmulq_f32(v15, v21);
  v22.i32[3] = 0;
  float32x4_t v23 = vaddq_f32(v20, v22);
  float32x4_t v24 = vsubq_f32(v20, v22);
  float32x4_t v25 = (float32x4_t)a4->var0.var0[2];
  btVector3 var1 = a4->var1;
  int8x16_t v27 = (int8x16_t)vmulq_f32(v25, v24);
  v24.i32[3] = 0;
  float32x4_t v28 = vmulq_f32(a6, v21);
  v28.i32[3] = 0;
  float32x4_t v29 = vaddq_f32(v20, v28);
  float32x4_t v30 = vsubq_f32(v20, v28);
  float32x4_t v50 = v30;
  v30.i32[3] = 0;
  float32x4_t v48 = v29;
  float32x4_t v49 = v30;
  float32x4_t v31 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v32 = vmulq_f32((float32x4_t)a4->var0.var0[0], v23);
  int8x16_t v33 = (int8x16_t)vmulq_f32(v31, v23);
  int8x16_t v34 = (int8x16_t)vmulq_f32(v25, v23);
  v34.i32[3] = 0;
  *(float32x2_t *)v32.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v32.f32, *(float32x2_t *)v33.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v32, (int8x16_t)v32, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL)));
  *(float32x2_t *)&v32.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL)), 0);
  float32x4_t v35 = vmulq_f32((float32x4_t)a4->var0.var0[0], v24);
  int8x16_t v36 = (int8x16_t)vmulq_f32(v31, v24);
  v27.i32[3] = 0;
  *(float32x2_t *)v35.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v35.f32, *(float32x2_t *)v36.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL)));
  *(float32x2_t *)&v35.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL)), 0);
  float32x4_t v51 = vaddq_f32((float32x4_t)var1, v35);
  float32x4_t v52 = vaddq_f32((float32x4_t)var1, v32);
  (*(void (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v52, &v51, a5);
  float32x4_t v37 = (float32x4_t)a4->var0.var0[0];
  float32x4_t v38 = (float32x4_t)a4->var0.var0[1];
  float32x4_t v39 = vmulq_f32(v48, (float32x4_t)a4->var0.var0[0]);
  int8x16_t v40 = (int8x16_t)vmulq_f32(v48, v38);
  float32x4_t v41 = (float32x4_t)a4->var0.var0[2];
  btVector3 v42 = a4->var1;
  int8x16_t v43 = (int8x16_t)vmulq_f32(v48, v41);
  v43.i32[3] = 0;
  *(float32x2_t *)v39.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v39.f32, *(float32x2_t *)v40.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v39, (int8x16_t)v39, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)));
  *(float32x2_t *)&v39.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)), 0);
  float32x4_t v52 = vaddq_f32(v39, (float32x4_t)v42);
  float32x4_t v44 = vmulq_f32(v37, v49);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v38, v49);
  int8x16_t v46 = (int8x16_t)vmulq_f32(v41, v50);
  v46.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL)), 0);
  float32x4_t v51 = vaddq_f32((float32x4_t)v42, v44);
  return (*(uint64_t (**)(btIDebugDraw *, float32x4_t *, float32x4_t *, const btVector3 *))(*(void *)this + 16))(this, &v52, &v51, a5);
}

void btC3DRayResultCallback::btC3DRayResultCallback(btC3DRayResultCallback *this, const btVector3 *a2, const btVector3 *a3)
{
  *((_DWORD *)this + 2) = 1065353216;
  *((void *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = xmmword_20B5CD040;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(void *)this = &unk_26BF6B438;
  *((btVector3 *)this + 4) = *a2;
  *((btVector3 *)this + 5) = *a3;
  *((unsigned char *)this + 168) = 1;
  *((void *)this + 20) = 0;
  *(void *)((char *)this + 148) = 0;
  *((unsigned char *)this + 200) = 1;
  *((void *)this + 24) = 0;
  *(void *)((char *)this + 180) = 0;
  *((unsigned char *)this + 232) = 1;
  *((void *)this + 28) = 0;
  *(void *)((char *)this + 212) = 0;
  *((unsigned char *)this + 264) = 1;
  *((void *)this + 32) = 0;
  *(void *)((char *)this + 244) = 0;
  *((void *)this + 3) = -1;
  *((void *)this + 5) = 0;
}

float btC3DRayResultCallback::addSingleResult(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(float32x4_t **)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  float32x4_t v6 = *(float32x4_t *)(a2 + 16);
  if (!a3)
  {
    int8x16_t v7 = (int8x16_t)vmulq_f32(v5[1], v6);
    int8x16_t v8 = (int8x16_t)vmulq_f32(v6, v5[2]);
    int8x16_t v9 = (int8x16_t)vmulq_f32(v6, v5[3]);
    v9.i32[3] = 0;
    *(float32x2_t *)v6.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v8.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
    *(float32x2_t *)&v6.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)), 0);
  }
  *(float32x4_t *)(a1 + 112) = v6;
  *(float32x4_t *)(a1 + 128) = vaddq_f32(*(float32x4_t *)(a1 + 64), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(a1 + 80), *(float32x4_t *)(a1 + 64)), *(float *)(a2 + 32)));
  int v10 = *(_DWORD *)(a1 + 96);
  if (v10 == 1) {
    return 0.0;
  }
  if (!v10)
  {
    float result = *(float *)(a2 + 32);
    *(float *)(a1 + 8) = result;
    return result;
  }
  int v12 = *(_DWORD *)(a1 + 148);
  if (v12 == *(_DWORD *)(a1 + 152))
  {
    int v13 = v12 ? 2 * v12 : 1;
    if (v12 < v13)
    {
      if (v13)
      {
        uint64_t v14 = btAlignedAllocInternal(8 * v13, 16);
        int v12 = *(_DWORD *)(a1 + 148);
      }
      else
      {
        uint64_t v14 = 0;
      }
      if (v12 >= 1)
      {
        uint64_t v15 = 0;
        do
        {
          *(void *)(v14 + v15) = *(void *)(*(void *)(a1 + 160) + v15);
          v15 += 8;
        }
        while (8 * v12 != v15);
      }
      float v16 = *(void ***)(a1 + 160);
      if (v16 && *(unsigned char *)(a1 + 168))
      {
        btAlignedFreeInternal(v16);
        int v12 = *(_DWORD *)(a1 + 148);
      }
      *(unsigned char *)(a1 + 168) = 1;
      *(void *)(a1 + 160) = v14;
      *(_DWORD *)(a1 + 152) = v13;
    }
  }
  *(void *)(*(void *)(a1 + 160) + 8 * v12) = *(void *)a2;
  *(_DWORD *)(a1 + 148) = v12 + 1;
  int v17 = *(_DWORD *)(a1 + 212);
  if (v17 == *(_DWORD *)(a1 + 216))
  {
    int v18 = v17 ? 2 * v17 : 1;
    if (v17 < v18)
    {
      if (v18)
      {
        uint64_t v19 = btAlignedAllocInternal(16 * v18, 16);
        int v17 = *(_DWORD *)(a1 + 212);
      }
      else
      {
        uint64_t v19 = 0;
      }
      if (v17 >= 1)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 16 * v17;
        do
        {
          *(_OWORD *)(v19 + v20) = *(_OWORD *)(*(void *)(a1 + 224) + v20);
          v20 += 16;
        }
        while (v21 != v20);
      }
      float32x4_t v22 = *(void ***)(a1 + 224);
      if (v22 && *(unsigned char *)(a1 + 232)) {
        btAlignedFreeInternal(v22);
      }
      *(unsigned char *)(a1 + 232) = 1;
      *(void *)(a1 + 224) = v19;
      *(_DWORD *)(a1 + 216) = v18;
      int v17 = *(_DWORD *)(a1 + 212);
    }
  }
  *(_OWORD *)(*(void *)(a1 + 224) + 16 * v17) = *(_OWORD *)(a1 + 128);
  ++*(_DWORD *)(a1 + 212);
  int v23 = *(_DWORD *)(a1 + 180);
  if (v23 == *(_DWORD *)(a1 + 184))
  {
    int v24 = v23 ? 2 * v23 : 1;
    if (v23 < v24)
    {
      if (v24)
      {
        uint64_t v25 = btAlignedAllocInternal(16 * v24, 16);
        int v23 = *(_DWORD *)(a1 + 180);
      }
      else
      {
        uint64_t v25 = 0;
      }
      if (v23 >= 1)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 16 * v23;
        do
        {
          *(_OWORD *)(v25 + v26) = *(_OWORD *)(*(void *)(a1 + 192) + v26);
          v26 += 16;
        }
        while (v27 != v26);
      }
      float32x4_t v28 = *(void ***)(a1 + 192);
      if (v28 && *(unsigned char *)(a1 + 200)) {
        btAlignedFreeInternal(v28);
      }
      *(unsigned char *)(a1 + 200) = 1;
      *(void *)(a1 + 192) = v25;
      *(_DWORD *)(a1 + 184) = v24;
      int v23 = *(_DWORD *)(a1 + 180);
    }
  }
  *(_OWORD *)(*(void *)(a1 + 192) + 16 * v23) = *(_OWORD *)(a1 + 112);
  ++*(_DWORD *)(a1 + 180);
  int v29 = *(_DWORD *)(a1 + 244);
  if (v29 == *(_DWORD *)(a1 + 248))
  {
    int v30 = v29 ? 2 * v29 : 1;
    if (v29 < v30)
    {
      if (v30)
      {
        uint64_t v31 = btAlignedAllocInternal(4 * v30, 16);
        int v29 = *(_DWORD *)(a1 + 244);
      }
      else
      {
        uint64_t v31 = 0;
      }
      float32x4_t v32 = *(void ***)(a1 + 256);
      if (v29 < 1)
      {
        if (!v32)
        {
LABEL_68:
          *(unsigned char *)(a1 + 264) = 1;
          *(void *)(a1 + 256) = v31;
          *(_DWORD *)(a1 + 248) = v30;
          goto LABEL_69;
        }
      }
      else
      {
        uint64_t v33 = v29;
        int8x16_t v34 = (_DWORD *)v31;
        float32x4_t v35 = *(int **)(a1 + 256);
        do
        {
          int v36 = *v35++;
          *v34++ = v36;
          --v33;
        }
        while (v33);
      }
      if (*(unsigned char *)(a1 + 264))
      {
        btAlignedFreeInternal(v32);
        int v29 = *(_DWORD *)(a1 + 244);
      }
      *(void *)(a1 + 256) = 0;
      goto LABEL_68;
    }
  }
LABEL_69:
  *(_DWORD *)(*(void *)(a1 + 256) + 4 * v29) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 244) = v29 + 1;
  return 0.999;
}

void btC3DContactResultCallback::~btC3DContactResultCallback(btC3DContactResultCallback *this)
{
}

BOOL btC3DContactResultCallback::needsCollision(uint64_t a1, uint64_t a2)
{
  return (*(void *)(a1 + 40) & *(void *)(a2 + 8)) != 0 && (*(void *)(a2 + 16) & *(void *)(a1 + 32)) != 0;
}

float btC3DContactResultCallback::addSingleResult(uint64_t a1, const btVector3 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int8x16_t v7 = __contact(*(const btCollisionObject **)(a3 + 16), *(const btCollisionObject **)(a6 + 16), a2 + 2, a2 + 4, a2[5].var0.var0[0], 0.0);
  if (v7)
  {
    int8x16_t v8 = v7;
    int8x16_t v9 = *(void **)(a1 + 48);
    if (!v9)
    {
      int8x16_t v9 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:0];
      *(void *)(a1 + 48) = v9;
    }
    [v9 addObject:v8];
  }
  return 0.999;
}

void btC3DConvexResultCallback::~btC3DConvexResultCallback(btC3DConvexResultCallback *this)
{
}

uint64_t btCollisionWorld::ConvexResultCallback::needsCollision(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  BOOL v3 = (a1[3] & v2) != 0 && (*(void *)(a2 + 16) & a1[2]) != 0;
  return (a1[4] & v2) != 0 || v3;
}

float btC3DConvexResultCallback::addSingleResult(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(const btCollisionObject **)a2;
  *(void *)(a1 + 88) = *(void *)a2;
  float32x4_t v6 = *(float32x4_t *)(a2 + 16);
  if (!a3)
  {
    int8x16_t v7 = (int8x16_t)vmulq_f32(*((float32x4_t *)v5 + 1), v6);
    int8x16_t v8 = (int8x16_t)vmulq_f32(v6, *((float32x4_t *)v5 + 2));
    int8x16_t v9 = (int8x16_t)vmulq_f32(v6, *((float32x4_t *)v5 + 3));
    v9.i32[3] = 0;
    *(float32x2_t *)v6.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v8.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
    *(float32x2_t *)&v6.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)), 0);
  }
  *(float32x4_t *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 32);
  float v10 = *(float *)(a2 + 48);
  *(float *)(a1 + 8) = v10;
  int v11 = *(_DWORD *)(a1 + 80);
  if (v11)
  {
    if (v11 == 1)
    {
      return 0.0;
    }
    else
    {
      if (!*(void *)(a1 + 128))
      {
        *(void *)(a1 + 128) = [MEMORY[0x263EFF980] arrayWithCapacity:0];
        float v10 = *(float *)(a1 + 8);
      }
      int v12 = __contact(*(const btCollisionObject **)a2, 0, (const btVector3 *)(a1 + 112), (const btVector3 *)(a1 + 96), 0.0, v10);
      float v10 = 0.999;
      if (v12) {
        [*(id *)(a1 + 128) addObject:v12];
      }
    }
  }
  return v10;
}

void btGhostPairCallback::~btGhostPairCallback(btGhostPairCallback *this)
{
}

uint64_t btGhostPairCallback::addOverlappingPair(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = *a2;
  if (*(_DWORD *)(*a3 + 264) == 4) {
    uint64_t v6 = *a3;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v5) {
    BOOL v7 = *(_DWORD *)(*a2 + 264) == 4;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v5 + 56))(v5, a3, a2);
  }
  if (v6) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v6 + 56))(v6, a2, a3);
  }
  return 0;
}

uint64_t btGhostPairCallback::removeOverlappingPair(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = *a2;
  if (*(_DWORD *)(*a3 + 264) == 4) {
    uint64_t v8 = *a3;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v7) {
    BOOL v9 = *(_DWORD *)(*a2 + 264) == 4;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)v7 + 64))(v7, a3, a4, a2);
  }
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)v8 + 64))(v8, a2, a4, a3);
  }
  return 0;
}

uint64_t btAlignedObjectArray<btRigidBody *>::btAlignedObjectArray(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  uint64_t v3 = *(unsigned int *)(a2 + 4);
  if ((int)v3 < 1)
  {
    *(_DWORD *)(a1 + 4) = v3;
  }
  else
  {
    uint64_t v5 = 8 * v3;
    uint64_t v6 = btAlignedAllocInternal(8 * v3, 16);
    uint64_t v7 = v6;
    uint64_t v8 = *(unsigned int *)(a1 + 4);
    if ((int)v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v8;
      do
      {
        *(void *)(v6 + v9) = *(void *)(*(void *)(a1 + 16) + v9);
        v9 += 8;
      }
      while (v10 != v9);
    }
    int v11 = *(void ***)(a1 + 16);
    if (v11 && *(unsigned char *)(a1 + 24)) {
      btAlignedFreeInternal(v11);
    }
    *(unsigned char *)(a1 + 24) = 1;
    *(void *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 8) = v3;
    uint64_t v12 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 16) + v12) = 0;
      v12 += 8;
    }
    while (v5 != v12);
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)(a1 + 16);
    *(_DWORD *)(a1 + 4) = v3;
    do
    {
      *(void *)(v14 + v13) = *(void *)(*(void *)(a2 + 16) + v13);
      v13 += 8;
    }
    while (v5 != v13);
  }
  return a1;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2013()
{
  if (C3DWasLinkedBeforeMajorOSYear2013_onceToken != -1) {
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2013_onceToken, &__block_literal_global_68);
  }
  return 0;
}

BOOL __C3DWasLinkedBeforeMajorOSYear2013_block_invoke()
{
  return C3DPreferencesGetBool(12);
}

uint64_t SCNSetResourceBundle(uint64_t result)
{
  _SCNResourceBundle = result;
  return result;
}

BOOL SCNHasSpecialResourceBundle()
{
  return _SCNResourceBundle != 0;
}

uint64_t SCNGetResourceBundle()
{
  uint64_t result = _SCNResourceBundle;
  if (!_SCNResourceBundle) {
    return [MEMORY[0x263F086E0] mainBundle];
  }
  return result;
}

uint64_t SCNGetSceneKitBundle()
{
  id v0 = (void *)MEMORY[0x263F086E0];
  uint64_t v1 = objc_opt_class();

  return [v0 bundleForClass:v1];
}

id SCNSetExternalTextureSource(id result)
{
  if ((id)SCNGlobalTextureSource != result)
  {
    uint64_t v1 = result;

    uint64_t result = v1;
    SCNGlobalTextureSource = (uint64_t)result;
  }
  return result;
}

uint64_t SCNGetExternalTextureSource()
{
  return SCNGlobalTextureSource;
}

id C3DTimingFunctionFromCAMediaTimingFunction(id result)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v1 = result;
    [result getControlPointAtIndex:1 values:v2];
    [v1 getControlPointAtIndex:2 values:v3];
    return (id)C3DTimingFunctionCreateWithControlPoints(v2[0], v2[1], v3[0], v3[1]);
  }
  return result;
}

uint64_t CAMediaTimingFunctionFromC3DTimingFunction(uint64_t a1)
{
  ControlPoints = (_DWORD *)C3DTimingFunctionGetControlPoints(a1);
  LODWORD(v2) = *ControlPoints;
  LODWORD(v3) = ControlPoints[1];
  LODWORD(v4) = ControlPoints[2];
  LODWORD(v5) = ControlPoints[3];
  uint64_t v6 = (void *)MEMORY[0x263F15808];

  return [v6 functionWithControlPoints:v2 :v3 :v4 :v5];
}

uint64_t SCNInterpolationModeFromCACalculationMode(void *a1)
{
  if ([a1 isEqualToString:*MEMORY[0x263F15970]]) {
    return 0;
  }
  if ([a1 isEqualToString:*MEMORY[0x263F15968]]) {
    return 1;
  }
  if ([a1 isEqualToString:*MEMORY[0x263F15978]]) {
    return 0;
  }
  uint64_t v2 = 2;
  if (([a1 isEqualToString:*MEMORY[0x263F15958]] & 1) == 0)
  {
    if ([a1 isEqualToString:*MEMORY[0x263F15960]]) {
      return 2;
    }
    else {
      return 0;
    }
  }
  return v2;
}

double SCNGetFileTimestampAtURL(void *a1)
{
  uint64_t v1 = (void *)[a1 path];

  return SCNGetFileTimestampAtPath(v1);
}

double SCNGetFileTimestampAtPath(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  uint64_t v1 = [a1 stringByResolvingSymlinksInPath];
  uint64_t v5 = 0;
  uint64_t v2 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "attributesOfItemAtPath:error:", v1, &v5);
  double v3 = (void *)[v2 objectForKey:*MEMORY[0x263F08048]];
  if (!v3) {
    return 0.0;
  }
  [v3 timeIntervalSinceReferenceDate];
  return result;
}

uint64_t SCNCreateGLESContext(uint64_t a1)
{
  v32[1] = *MEMORY[0x263EF8340];
  Class v2 = NSClassFromString(&cfstr_Skglobalshared.isa);
  if (v2)
  {
    Class v3 = v2;
    double v4 = (void *)[(objc_class *)v2 globalGLSharedContext];
    if (!v4)
    {
      id v5 = objc_alloc(MEMORY[0x263F146E8]);
      uint64_t v31 = *MEMORY[0x263F14700];
      v32[0] = MEMORY[0x263EFFA88];
      uint64_t v6 = objc_msgSend(v5, "initWithAPI:properties:", 2, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v32, &v31, 1));
      if (v6)
      {
        uint64_t v7 = v6;
        [(objc_class *)v3 setGlobalGLSharedContext:v6];
        return v7;
      }
      uint64_t v20 = scn_default_log();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        SCNCreateGLESContext_cold_2(v20);
      }
      return 0;
    }
  }
  else
  {
    double v4 = (void *)SCNCreateGLESContext__SCNSharedGLContext;
    if (!SCNCreateGLESContext__SCNSharedGLContext)
    {
      uint64_t v29 = *MEMORY[0x263F14700];
      uint64_t v30 = MEMORY[0x263EFFA88];
      uint64_t v8 = [NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
      double v4 = (void *)[objc_alloc(MEMORY[0x263F146E8]) initWithAPI:2 properties:v8];
      SCNCreateGLESContext__SCNSharedGLContext = (uint64_t)v4;
    }
  }
  uint64_t v9 = [v4 sharegroup];
  uint64_t v10 = *MEMORY[0x263F14700];
  if (v9)
  {
    v28[0] = MEMORY[0x263EFFA88];
    uint64_t v11 = *MEMORY[0x263F146F8];
    v27[0] = v10;
    v27[1] = v11;
    v28[1] = [v4 sharegroup];
    uint64_t v12 = NSDictionary;
    uint64_t v13 = v28;
    uint64_t v14 = v27;
    uint64_t v15 = 2;
  }
  else
  {
    uint64_t v25 = *MEMORY[0x263F14700];
    uint64_t v26 = MEMORY[0x263EFFA88];
    uint64_t v12 = NSDictionary;
    uint64_t v13 = &v26;
    uint64_t v14 = &v25;
    uint64_t v15 = 1;
  }
  uint64_t v16 = [v12 dictionaryWithObjects:v13 forKeys:v14 count:v15];
  uint64_t v7 = [objc_alloc(MEMORY[0x263F146E8]) initWithAPI:a1 properties:v16];
  if (!v7)
  {
    int v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)float32x4_t v22 = 0;
      _os_log_impl(&dword_20B249000, v17, OS_LOG_TYPE_DEFAULT, "Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context", v22, 2u);
    }
    id v18 = objc_alloc(MEMORY[0x263F146E8]);
    uint64_t v23 = v10;
    uint64_t v24 = MEMORY[0x263EFFA88];
    uint64_t v7 = objc_msgSend(v18, "initWithAPI:properties:", a1, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", &v24, &v23, 1));
    if (!v7)
    {
      uint64_t v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        C3DRendererContextSetGLContext_cold_1(v19);
      }
      return 0;
    }
  }
  return v7;
}

void C3DRendererContextExecuteOnContext(uint64_t a1, uint64_t a2)
{
  id v4 = (id)[MEMORY[0x263F146E8] currentContext];
  [MEMORY[0x263F146E8] setCurrentContext:*(void *)(a1 + 160)];
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  [MEMORY[0x263F146E8] setCurrentContext:v4];
}

id C3DRendererContextRetainContext(uint64_t a1)
{
  return *(id *)(a1 + 160);
}

void C3DRendererContextReleaseContext(uint64_t a1)
{
}

const char *C3D::ResourceTypeDescription(unsigned int a1)
{
  if (a1 > 2) {
    return "Invalid - wrong value";
  }
  else {
    return off_264008320[(char)a1];
  }
}

std::string *C3D::description@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:nn180100]<0>(a2, "texture: {\n");
  C3D::appendValue<unsigned short>((uint64_t)a2, "width", (unsigned __int16 *)a1, &v16);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  C3D::appendValue<unsigned short>((uint64_t)a2, "height", (unsigned __int16 *)(a1 + 2), &v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  C3D::appendValue<unsigned short>((uint64_t)a2, "depth", (unsigned __int16 *)(a1 + 4), &v14);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  C3D::appendValue<unsigned short>((uint64_t)a2, "arrayLength", (unsigned __int16 *)(a1 + 6), &v13);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = (const std::string::value_type *)[(__CFString *)SCNMTLTextureTypeToString(*(unsigned __int8 *)(a1 + 8)) UTF8String];
  C3D::appendValue<char const*>((uint64_t)a2, "textureType", &v11, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = (const std::string::value_type *)[(__CFString *)SCNMTLStorageModeToString(*(unsigned __int8 *)(a1 + 9)) UTF8String];
  C3D::appendValue<char const*>((uint64_t)a2, "storageMode", &v11, &v10);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = (const std::string::value_type *)[(__CFString *)SCNTextureUsageToString(*(unsigned char *)(a1 + 10)) UTF8String];
  C3D::appendValue<char const*>((uint64_t)a2, "usage", &v11, &v9);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = (const std::string::value_type *)[(__CFString *)SCNMTLCPUCacheModeToString(*(unsigned __int8 *)(a1 + 11)) UTF8String];
  C3D::appendValue<char const*>((uint64_t)a2, "cpuCacheMode", &v11, &v8);
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = (const std::string::value_type *)[(__CFString *)SCNMTLPixelFormatToString(*(unsigned __int16 *)(a1 + 12)) UTF8String];
  C3D::appendValue<char const*>((uint64_t)a2, "pixelFormat", &v11, &v7);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  C3D::appendValue<unsigned char>((uint64_t)a2, "mipmapLevelCount", (unsigned __int8 *)(a1 + 14), &v6);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  C3D::appendValue<unsigned char>((uint64_t)a2, "sampleCount", (unsigned __int8 *)(a1 + 15), &v5);
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  return std::string::append(a2, "}");
}

void sub_20B3CC768(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void C3D::appendValue<unsigned short>(uint64_t a1@<X0>, const std::string::value_type *a2@<X1>, unsigned __int16 *a3@<X2>, std::string *a4@<X8>)
{
  std::string::append((std::string *)a1, "\t");
  std::string::append((std::string *)a1, a2);
  std::string::append((std::string *)a1, ": ");
  std::to_string(&v10, *a3);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v8 = &v10;
  }
  else {
    std::string v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v10.__r_.__value_.__l.__size_;
  }
  std::string::append((std::string *)a1, (const std::string::value_type *)v8, size);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  std::string::append((std::string *)a1, "\n");
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a4, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
  }
}

void sub_20B3CC874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void C3D::appendValue<char const*>(uint64_t a1@<X0>, const std::string::value_type *a2@<X1>, const std::string::value_type **a3@<X2>, std::string *a4@<X8>)
{
  std::string::append((std::string *)a1, "\t");
  std::string::append((std::string *)a1, a2);
  std::string::append((std::string *)a1, ": ");
  std::string::append((std::string *)a1, *a3);
  std::string::append((std::string *)a1, "\n");
  if (*(char *)(a1 + 23) < 0)
  {
    std::string v8 = *(const std::string::value_type **)a1;
    std::string::size_type v9 = *(void *)(a1 + 8);
    std::string::__init_copy_ctor_external(a4, v8, v9);
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
  }
}

void C3D::appendValue<unsigned char>(uint64_t a1@<X0>, const std::string::value_type *a2@<X1>, unsigned __int8 *a3@<X2>, std::string *a4@<X8>)
{
  std::string::append((std::string *)a1, "\t");
  std::string::append((std::string *)a1, a2);
  std::string::append((std::string *)a1, ": ");
  std::to_string(&v10, *a3);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v8 = &v10;
  }
  else {
    std::string v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v10.__r_.__value_.__l.__size_;
  }
  std::string::append((std::string *)a1, (const std::string::value_type *)v8, size);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  std::string::append((std::string *)a1, "\n");
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a4, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
  }
}

void sub_20B3CCA24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double C3D::PassIODescriptor::PassIODescriptor(uint64_t a1, char a2)
{
  *(unsigned char *)a1 = 1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 64) = 1;
  *(_WORD *)(a1 + 66) &= 0xFE00u;
  *(void *)&double result = 0x1000100000000;
  *(void *)(a1 + 16) = 0x1000100000000;
  *(unsigned char *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 25) = 2;
  *(unsigned char *)(a1 + 27) = 0;
  *(void *)(a1 + 28) = 0x10000;
  return result;
}

void C3D::PassIODescriptor::description(C3D::PassIODescriptor *this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  std::string::append(a2, "C3D::PassBufferParameter [");
  id v4 = (const std::string::value_type *)*((void *)this + 1);
  if (v4) {
    std::string::append(a2, v4);
  }
  std::string::append(a2, "] : ");
  unint64_t v5 = *(char *)this;
  if (v5 > 2) {
    std::string v6 = "Invalid - wrong value";
  }
  else {
    std::string v6 = off_264008320[v5];
  }
  std::string::append(a2, v6);
  std::string::append(a2, "\n");
  long long v9 = *((_OWORD *)this + 1);
  int v10 = *((_DWORD *)this + 8);
  C3D::description((uint64_t)&v9, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a2, (const std::string::value_type *)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_20B3CCB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  _Unwind_Resume(exception_object);
}

void *C3D::RefCountedResource::textureOrFinal(C3D::RefCountedResource *this, SCNMTLRenderContext *a2)
{
  if ((*((unsigned char *)this + 34) & 2) != 0) {
    return -[SCNMTLRenderContext _finalRenderTexture](a2);
  }
  else {
    return *(void **)this;
  }
}

uint64_t C3D::PassResource::inputAtIndex(C3D::PassResource *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 8) <= a2)
  {
    id v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::PassResource::inputAtIndex();
    }
  }
  return *(void *)(*(void *)this + 8 * a2);
}

uint64_t C3D::Pass::drawableInfo(C3D::Pass *this)
{
  if (!*((void *)this + 1))
  {
    Class v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3D::Pass::drawableInfo(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 88))(*((void *)this + 1));
}

uint64_t C3D::Pass::inputBufferParameterNamed(C3D::Pass *this, const char *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 72);
  if (!*((unsigned char *)this + 72)) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = (C3D::Pass *)((char *)this + 32);
  while (1)
  {
    uint64_t v6 = C3D::PassDescriptor::inputAtIndex(v5, v4);
    uint64_t v7 = *(const char **)(v6 + 8);
    if (v7)
    {
      if (!strcmp(v7, a2)) {
        break;
      }
    }
    unsigned __int8 v8 = v4 + 1;
    unsigned __int16 v4 = (v4 + 1);
    if (v2 <= v8) {
      return 0;
    }
  }
  return v6;
}

uint64_t C3D::Pass::outputBufferParameterNamed(C3D::Pass *this, const char *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 74);
  if (!*((unsigned char *)this + 74)) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = (C3D::Pass *)((char *)this + 32);
  while (1)
  {
    uint64_t v6 = C3D::PassDescriptor::outputAtIndex(v5, v4);
    uint64_t v7 = *(const char **)(v6 + 8);
    if (v7)
    {
      if (!strcmp(v7, a2)) {
        break;
      }
    }
    unsigned __int8 v8 = v4 + 1;
    unsigned __int16 v4 = (v4 + 1);
    if (v2 <= v8) {
      return 0;
    }
  }
  return v6;
}

void **C3D::Pass::inputTextureAtIndex(C3D::Pass *this, unsigned int a2)
{
  uint64_t RenderContext = (void *)C3DEngineContextGetRenderContext(*((void *)this + 2));
  double result = (void **)C3D::PassResource::inputAtIndex((C3D::Pass *)((char *)this + 80), a2);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = *result;
    uint64_t v8 = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)this + 32), a2);
    if (v7
      && (*(unsigned __int8 *)(v8 + 31) <= 1u ? (uint64_t v9 = 1) : (uint64_t v9 = *(unsigned __int8 *)(v8 + 31)),
          [v7 sampleCount] != v9))
    {
      if ((*((unsigned char *)v6 + 34) & 4) == 0) {
        return (void **)v6[3];
      }
    }
    else if ((*((unsigned char *)v6 + 34) & 2) == 0)
    {
      return (void **)*v6;
    }
    return (void **)-[SCNMTLRenderContext _finalRenderTexture](RenderContext);
  }
  return result;
}

void **C3D::Pass::inputTextureNamed(C3D::Pass *this, const char *a2)
{
  if (!*((_WORD *)this + 36)) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  while (1)
  {
    uint64_t v5 = *(const char **)(C3D::Pass::inputBufferParameterAtIndex(this, v4) + 8);
    if (v5)
    {
      if (!strcmp(v5, a2)) {
        break;
      }
    }
    if (*((unsigned __int16 *)this + 36) <= ++v4) {
      return 0;
    }
  }

  return C3D::Pass::inputTextureAtIndex(this, v4);
}

void *C3D::Pass::outputTextureNamed(C3D::Pass *this, const char *a2)
{
  if (!*((_WORD *)this + 37)) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  while (1)
  {
    uint64_t v5 = *(const char **)(C3D::Pass::outputBufferParameterAtIndex(this, v4) + 8);
    if (v5)
    {
      if (!strcmp(v5, a2)) {
        break;
      }
    }
    if (*((unsigned __int16 *)this + 37) <= ++v4) {
      return 0;
    }
  }

  return C3D::Pass::outputTextureAtIndex(this, v4);
}

const char *C3D::Pass::programHashCodeStoreName(C3D::Pass *this)
{
  return "default";
}

unint64_t C3D::Pass::programHashCodeStoreKey(C3D::Pass *this)
{
  uint64_t v1 = (const char *)(*(uint64_t (**)(C3D::Pass *))(*(void *)this + 72))(this);
  unsigned int v2 = strlen(v1);
  unint64_t v3 = 0xC6A4A7935BD1E995 * v2;
  if (v2 >= 8)
  {
    uint64_t v4 = v2 >> 3;
    uint64_t v5 = (unsigned __int8 *)&v1[8 * v4];
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *(void *)v1;
      v1 += 8;
      unint64_t v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v7) ^ ((0xC6A4A7935BD1E995 * v7) >> 47))) ^ v3);
      v6 -= 8;
    }
    while (v6);
    uint64_t v1 = (const char *)v5;
  }
  switch(v2 & 7)
  {
    case 1u:
      goto LABEL_12;
    case 2u:
      goto LABEL_11;
    case 3u:
      goto LABEL_10;
    case 4u:
      goto LABEL_9;
    case 5u:
      goto LABEL_8;
    case 6u:
      goto LABEL_7;
    case 7u:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 6) << 48;
LABEL_7:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 5) << 40;
LABEL_8:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 4) << 32;
LABEL_9:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 3) << 24;
LABEL_10:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 2) << 16;
LABEL_11:
      v3 ^= (unint64_t)*((unsigned __int8 *)v1 + 1) << 8;
LABEL_12:
      unint64_t v3 = 0xC6A4A7935BD1E995 * (v3 ^ *(unsigned __int8 *)v1);
      break;
    default:
      return (0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) >> 47);
  }
  return (0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) >> 47);
}

char *C3D::Pass::nameWithPrefixAndPointer(C3D::Pass *this, const char *__s, void *a3)
{
  size_t v6 = strlen(__s) + 20;
  uint64_t v7 = (char *)C3DScratchAllocatorAllocate(*(void **)(*((void *)this + 3) + 16), v6);
  snprintf(v7, v6, "%s%p", __s, a3);
  return v7;
}

const char *C3D::CachedFXPassName(void **this, const char **a2, __C3DFXPass *a3, void *a4)
{
  double result = (const char *)*this;
  if (!result)
  {
    double result = C3DFXPassGetCStringName((uint64_t)a2);
    if (result)
    {
      uint64_t v7 = result;
      size_t v8 = strlen(result) + 1;
      uint64_t Aligned = C3DScratchAllocatorAllocateAligned(a3, v8, 1, 0);
      *this = (void *)Aligned;
      if (!Aligned)
      {
        int v10 = scn_default_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          C3D::CachedFXPassName(v10, v11, v12, v13, v14, v15, v16, v17);
        }
      }
      memcpy(*this, v7, v8);
      return (const char *)*this;
    }
  }
  return result;
}

void **C3DPassGetInputTextureNamed(C3D::Pass *this, char *a2)
{
  if (!this)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DPassGetInputTextureNamed_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3D::Pass::inputTextureNamed(this, a2);
}

void *C3DPassGetOutputTextureNamed(C3D::Pass *this, char *a2)
{
  if (!this)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DPassGetInputTextureNamed_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return C3D::Pass::outputTextureNamed(this, a2);
}

C3D::RenderPass *C3D::GridPass::GridPass(C3D::GridPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  double result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)double result = &unk_26BF6E7E0;
  return result;
}

const char *C3D::GridPass::name(C3D::GridPass *this)
{
  return "GridPass";
}

const char *C3D::GridPass::programHashCodeStoreName(C3D::GridPass *this)
{
  return "GridPass";
}

double C3D::GridPass::setup(C3D::GridPass *this)
{
  C3D::Pass::setInputCount(this, 2u);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex((C3D::GridPass *)((char *)this + 32), 0);
  *(void *)(v2 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v6);
  *(_OWORD *)(v2 + 16) = v6;
  *(_DWORD *)(v2 + 32) = v7;
  *(_WORD *)(v2 + 66) = *(_WORD *)(v2 + 66) & 0xFF78 | 0x85;
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex((C3D::GridPass *)((char *)this + 32), 1u);
  *(void *)(v3 + 8) = "DEPTH";
  *(unsigned char *)(v3 + 64) = 2;
  C3D::Pass::parentDepthDesc(this, (uint64_t)&v6);
  *(_OWORD *)(v3 + 16) = v6;
  *(_DWORD *)(v3 + 32) = v7;
  *(_WORD *)(v3 + 66) = *(_WORD *)(v3 + 66) & 0xFFFC | 1;
  uint64_t v4 = C3D::PassDescriptor::outputAtIndex((C3D::GridPass *)((char *)this + 32), 0);
  *(void *)(v4 + 8) = "COLOR";
  *(unsigned char *)(v4 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v6);
  double result = *(double *)&v6;
  *(_OWORD *)(v4 + 16) = v6;
  *(_DWORD *)(v4 + 32) = v7;
  *(_WORD *)(v4 + 66) = *(_WORD *)(v4 + 66) & 0xFF7C | 0x81;
  *((unsigned char *)this + 119) = 1;
  return result;
}

uint64_t C3D::GridPass::compile(C3D::GridPass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::GridPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::GridPass::execute(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(C3D::DrawNodesPass **)(*(void *)(result + 24) + 112);
  if (v2)
  {
    uint64_t v4 = (uint64_t *)result;
    __n128 Viewport = C3DEngineContextGetViewport((__n128 *)*(void *)(result + 16));
    __n128 ViewBackgroundColor = C3DEngineContextGetViewBackgroundColor(v4[2]);
    BOOL v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)ViewBackgroundColor, 2), vaddq_f32((float32x4_t)ViewBackgroundColor, (float32x4_t)vdupq_lane_s32((int32x2_t)ViewBackgroundColor.n128_u64[0], 1))).f32[0] <= 1.5;
    float v7 = 1.0;
    if (!v6) {
      float v7 = 0.0;
    }
    float v52 = v7;
    uint64_t CullingContext = C3D::DrawNodesPass::getCullingContext(v2);
    unint64_t v9 = CullingContext + ((unint64_t)a2[8] << 6);
    long long v43 = *(_OWORD *)(v9 + 3488);
    float v10 = *(float *)(v9 + 3516);
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v4[2]);
    float v12 = -[SCNMTLRenderContext contentScaleFactor](RenderContext);
    char v13 = 2;
    if (!*(unsigned char *)(CullingContext + 4695)) {
      char v13 = 3;
    }
    __n128 v45 = Viewport;
    double v14 = v12;
    if (v10 == 0.0) {
      double v15 = v14 * 400.0;
    }
    else {
      double v15 = 1000.0 / *((float *)&v43 + 1) * v14;
    }
    float v16 = v15 / fmaxf(*(float *)((unint64_t)&v45 & 0xFFFFFFFFFFFFFFF3 | (4 * (v13 & 3))), 1.0);
    float v51 = v16;
    uint64_t v17 = (_OWORD *)(CullingContext + ((unint64_t)a2[8] << 6));
    v55.columns[1] = (simd_float4)v17[242];
    v55.columns[2] = (simd_float4)v17[243];
    v55.columns[3] = (simd_float4)v17[244];
    v47[0] = v17[241];
    v55.columns[0] = (simd_float4)v47[0];
    v47[1] = v55.columns[1];
    v47[2] = v55.columns[2];
    v47[3] = v55.columns[3];
    simd_float4x4 v56 = __invert_f4(v55);
    uint64_t v18 = 0;
    float32x4_t v19 = vmlaq_f32(vmulq_f32((float32x4_t)v56.columns[0], (float32x4_t)0), (float32x4_t)0, (float32x4_t)v56.columns[1]);
    __asm { FMOV            V4.4S, #-1.0 }
    float32x4_t v25 = vsubq_f32(vaddq_f32((float32x4_t)v56.columns[3], vmlaq_f32(v19, _Q4, (float32x4_t)v56.columns[2])), vaddq_f32((float32x4_t)v56.columns[3], vaddq_f32((float32x4_t)v56.columns[2], v19)));
    int8x16_t v26 = (int8x16_t)vmulq_f32(v25, v25);
    *(float32x2_t *)v26.i8 = vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
    v26.i32[0] = vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v26.i8, 1)).u32[0];
    float32x2_t v27 = vrsqrte_f32((float32x2_t)v26.u32[0]);
    float32x2_t v28 = vmul_f32(v27, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v27, v27)));
    v47[4] = vmulq_n_f32(v25, vmul_f32(v28, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v28, v28))).f32[0]);
    long long v29 = *(_OWORD *)(CullingContext + ((unint64_t)a2[8] << 6) + 2752);
    float32x4_t v30 = vmlaq_f32(vnegq_f32((float32x4_t)v56.columns[0]), _Q4, (float32x4_t)v56.columns[1]);
    float32x4_t v31 = vsubq_f32((float32x4_t)v56.columns[1], (float32x4_t)v56.columns[0]);
    float32x4_t v32 = vaddq_f32((float32x4_t)v56.columns[1], (float32x4_t)v56.columns[0]);
    v56.columns[0] = (simd_float4)vmlaq_f32((float32x4_t)v56.columns[0], _Q4, (float32x4_t)v56.columns[1]);
    v53[0] = vaddq_f32((float32x4_t)v56.columns[3], vmlaq_f32(v30, _Q4, (float32x4_t)v56.columns[2]));
    v53[1] = vaddq_f32((float32x4_t)v56.columns[3], vmlaq_f32((float32x4_t)v56.columns[0], _Q4, (float32x4_t)v56.columns[2]));
    v53[2] = vaddq_f32((float32x4_t)v56.columns[3], vmlaq_f32(v31, _Q4, (float32x4_t)v56.columns[2]));
    v53[3] = vaddq_f32((float32x4_t)v56.columns[3], vmlaq_f32(v32, _Q4, (float32x4_t)v56.columns[2]));
    v53[4] = vaddq_f32((float32x4_t)v56.columns[3], vaddq_f32((float32x4_t)v56.columns[2], v30));
    v53[5] = vaddq_f32((float32x4_t)v56.columns[3], vaddq_f32((float32x4_t)v56.columns[2], (float32x4_t)v56.columns[0]));
    void v53[6] = vaddq_f32((float32x4_t)v56.columns[3], vaddq_f32((float32x4_t)v56.columns[2], v31));
    v53[7] = vaddq_f32((float32x4_t)v56.columns[3], vaddq_f32((float32x4_t)v56.columns[2], v32));
    do
    {
      *(float32x4_t *)&v46[v18 * 16] = vdivq_f32((float32x4_t)v53[v18], (float32x4_t)vdupq_laneq_s32((int32x4_t)v53[v18], 3));
      ++v18;
    }
    while (v18 != 8);
    float v33 = 0.0;
    if (v10 != 0.0) {
      float v33 = 1.0;
    }
    float v50 = v33;
    if (v10 == 0.0) {
      float v34 = (float)(2.0 / v12) / *((float *)&v43 + 1);
    }
    else {
      float v34 = fabsf(*((float *)&v29 + 1));
    }
    float v48 = v34;
    char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(v4[2]);
    float v36 = -1.0;
    if ((CoordinatesSystemOptions & 8) == 0) {
      float v36 = 1.0;
    }
    float v49 = v36;
    uint64_t v37 = *(void *)a2;
    uint64_t v38 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v4[30] + 16) state];
    if (*(void *)(v37 + 3376) != v38)
    {
      *(void *)(v37 + 3376) = v38;
      [*(id *)(v37 + 3392) setRenderPipelineState:v38];
    }
    uint64_t v39 = *(void *)a2;
    if (!*(unsigned char *)(*(void *)a2 + 73))
    {
      if (*(void *)(v39 + 16))
      {
        *(void *)(v39 + 16) = 0;
        *(unsigned char *)(v39 + 41) = 1;
      }
    }
    uint64_t v40 = -[SCNMTLRenderContext resourceManager](RenderContext);
    [*(id *)(v39 + 3392) setDepthStencilState:-[SCNMTLResourceManager depthAndStencilStateWithReadWriteDepthDisabled](v40)];
    uint64_t v41 = *(void *)a2;
    btVector3 v42 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)v4, 1u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v41, v42, 0);
    SCNMTLRenderCommandEncoder::setVertexBytes(*(SCNMTLRenderCommandEncoder **)a2, v46, 0x80uLL, 0);
    SCNMTLRenderCommandEncoder::setFragmentBytes(*(SCNMTLRenderCommandEncoder **)a2, v47, 0x70uLL, 0);
    return SCNMTLRenderCommandEncoder::drawFullScreenQuad(*(SCNMTLRenderCommandEncoder **)a2);
  }
  return result;
}

void C3D::GridPassResource::~GridPassResource(C3D::GridPassResource *this)
{
  *(void *)this = &unk_26BF6D7E0;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6D7E0;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

void *_SCNAreaLightpolygonVerticesFromDescription(uint64_t a1)
{
  if (*(unsigned char *)a1 != 6) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v3 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:v2];
  if (v2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 8 * v2;
    do
    {
      objc_msgSend(v3, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 24) + v4))));
      v4 += 8;
    }
    while (v5 != v4);
  }
  return v3;
}

void _SCNLightUpdateC3DLightDescription(uint64_t a1, uint64_t a2, void *a3, float32x4_t a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  switch(a2)
  {
    case 0:
      long long v17 = 0uLL;
      v18.f32[0] = 0.5 * a4.f32[0];
      *(uint64_t *)((char *)v18.i64 + 4) = 0;
      v18.i32[3] = 0;
      goto LABEL_7;
    case 1:
      *((void *)&v17 + 1) = 0;
      *(void *)((char *)&v17 + 1) = 0;
      float32x2_t v5 = vmul_f32(*(float32x2_t *)a4.f32, (float32x2_t)0x3F0000003F000000);
      char v6 = 1;
      goto LABEL_5;
    case 2:
      *((void *)&v17 + 1) = 0;
      *(void *)((char *)&v17 + 1) = 0;
      float32x2_t v5 = vmul_f32(*(float32x2_t *)a4.f32, (float32x2_t)0x3F0000003F000000);
      char v6 = 2;
LABEL_5:
      LOBYTE(v17) = v6;
      float32x4_t v18 = (float32x4_t)(unint64_t)v5;
      goto LABEL_7;
    case 3:
      *((void *)&v17 + 1) = 0;
      *(void *)((char *)&v17 + 1) = 0;
      v7.i64[0] = 0x3F0000003F000000;
      v7.i64[1] = 0x3F0000003F000000;
      LOBYTE(v17) = 3;
      float32x4_t v18 = vmulq_f32(a4, v7);
LABEL_7:
      C3DLightSetAreaDescription(a1, (unsigned __int8 *)&v17);
      break;
    case 4:
      unint64_t v9 = [a3 count];
      if (v9 >= 0xFF) {
        uint64_t v10 = 255;
      }
      else {
        uint64_t v10 = v9;
      }
      double v11 = MEMORY[0x270FA5388](v9);
      char v13 = (char *)&v17 - v12;
      if (v10)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", i, v11), "CGPointValue");
          v16.f64[1] = v15;
          double v11 = COERCE_DOUBLE(vcvt_f32_f64(v16));
          *(double *)&v13[8 * i] = v11;
        }
      }
      *((void *)&v17 + 1) = 0;
      *(void *)((char *)&v17 + 1) = 0;
      *(__int32 *)((char *)v18.i32 + 1) = 0;
      v18.i32[1] = 0;
      LOBYTE(v17) = 4;
      v18.i8[0] = v10;
      v18.i64[1] = (uint64_t)v13;
      C3DLightSetAreaDescription(a1, (unsigned __int8 *)&v17);
      break;
    default:
      return;
  }
}

void OUTLINED_FUNCTION_2_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

float C3DMeshElementComputeACMR(uint64_t a1, size_t a2)
{
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)float32x4_t v7 = 0u;
  C3DMeshElementGetContent(a1, 0, (uint64_t)v7);
  float v3 = 0.0;
  if (*(void *)v7 && BYTE10(v8) != 4)
  {
    IndexCountWithTypeAndPrimitiveCFIndex Count = C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount(SBYTE10(v8), v7[2]);
    switch(BYTE11(v8))
    {
      case 4u:
        double v5 = VertexCache<unsigned int>::computeACMR(*(uint64_t *)v7, IndexCountWithTypeAndPrimitiveCount, a2);
        return *(float *)&v5;
      case 2u:
        double v5 = VertexCache<unsigned short>::computeACMR(*(uint64_t *)v7, IndexCountWithTypeAndPrimitiveCount, a2);
        return *(float *)&v5;
      case 1u:
        double v5 = VertexCache<unsigned char>::computeACMR(*(uint64_t *)v7, IndexCountWithTypeAndPrimitiveCount, a2);
        return *(float *)&v5;
    }
  }
  return v3;
}

double VertexCache<unsigned char>::computeACMR(uint64_t a1, unsigned int a2, size_t __len)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unsigned int v15 = __len;
  if (__len > 0x3F) {
    VertexCache<unsigned char>::computeACMR();
  }
  if (__len) {
    memset(&__b, 255, __len);
  }
  if (!a2) {
    return 0.0;
  }
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  int v8 = __b;
  do
  {
    int v9 = *(unsigned __int8 *)(a1 + v6);
    if (!v15) {
      goto LABEL_12;
    }
    if (v8 != v9)
    {
      uint64_t v10 = 1;
      do
      {
        unint64_t v11 = v10;
        if (v15 == v10) {
          break;
        }
        int v12 = v14[v10++ - 1];
      }
      while (v12 != v9);
      if (v11 >= v15)
      {
LABEL_12:
        memmove(v14, &__b, v15 - 1);
        unsigned __int8 __b = v9;
        ++v7;
        int v8 = v9;
      }
    }
    ++v6;
  }
  while (v6 != a2);
  *(float *)&double result = (float)v7 / (float)(a2 / 3);
  return result;
}

double VertexCache<unsigned short>::computeACMR(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v15 = a3;
  if (a3 > 0x3F) {
    VertexCache<unsigned char>::computeACMR();
  }
  if (a3) {
    memset(__b, 255, 2 * a3);
  }
  if (!a2) {
    return 0.0;
  }
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  int v8 = __b[0];
  do
  {
    int v9 = *(unsigned __int16 *)(a1 + 2 * v6);
    if (!v15) {
      goto LABEL_12;
    }
    if (v8 != v9)
    {
      uint64_t v10 = 1;
      do
      {
        unint64_t v11 = v10;
        if (v15 == v10) {
          break;
        }
        int v12 = (unsigned __int16)__b[v10++];
      }
      while (v12 != v9);
      if (v11 >= v15)
      {
LABEL_12:
        memmove(&v14, __b, 2 * (v15 - 1));
        __b[0] = v9;
        ++v7;
        int v8 = v9;
      }
    }
    ++v6;
  }
  while (v6 != a2);
  *(float *)&double result = (float)v7 / (float)(a2 / 3);
  return result;
}

double VertexCache<unsigned int>::computeACMR(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v15 = a3;
  if (a3 > 0x3F) {
    VertexCache<unsigned char>::computeACMR();
  }
  if (a3) {
    memset(__b, 255, 4 * a3);
  }
  if (!a2) {
    return 0.0;
  }
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  int v8 = __b[0];
  do
  {
    int v9 = *(_DWORD *)(a1 + 4 * v6);
    if (!v15) {
      goto LABEL_12;
    }
    if (v8 != v9)
    {
      uint64_t v10 = 1;
      do
      {
        unint64_t v11 = v10;
        if (v15 == v10) {
          break;
        }
        int v12 = __b[v10++];
      }
      while (v12 != v9);
      if (v11 >= v15)
      {
LABEL_12:
        memmove(&v14, __b, 4 * (v15 - 1));
        __b[0] = v9;
        ++v7;
        int v8 = v9;
      }
    }
    ++v6;
  }
  while (v6 != a2);
  *(float *)&double result = (float)v7 / (float)(a2 / 3);
  return result;
}

CFDataRef C3DDataCreateOptimizedIndices(const __CFData *a1, int a2, int a3)
{
  BytePtr = (unsigned int *)CFDataGetBytePtr(a1);
  switch(a3)
  {
    case 4:
      if (a2)
      {
        unsigned int v12 = 0;
        uint64_t v13 = (3 * a2);
        uint64_t v14 = BytePtr;
        do
        {
          unsigned int v16 = *v14++;
          unsigned int v15 = v16;
          if (v12 <= v16) {
            unsigned int v12 = v15;
          }
          --v13;
        }
        while (v13);
        int v17 = v12 + 1;
      }
      else
      {
        int v17 = 1;
      }
      return OptimizeVertexCache<unsigned int>::OptimizeIndices(BytePtr, a2, v17);
    case 2:
      if (a2)
      {
        LOWORD(v18) = 0;
        uint64_t v19 = (3 * a2);
        uint64_t v20 = BytePtr;
        do
        {
          unsigned int v22 = *(unsigned __int16 *)v20;
          uint64_t v20 = (unsigned int *)((char *)v20 + 2);
          unsigned int v21 = v22;
          unsigned int v18 = (unsigned __int16)v18;
          if ((unsigned __int16)v18 <= v22) {
            unsigned int v18 = v21;
          }
          --v19;
        }
        while (v19);
        int v23 = v18 + 1;
      }
      else
      {
        int v23 = 1;
      }
      return OptimizeVertexCache<unsigned short>::OptimizeIndices((unsigned __int16 *)BytePtr, a2, v23);
    case 1:
      if (a2)
      {
        LOBYTE(v6) = 0;
        uint64_t v7 = (3 * a2);
        int v8 = BytePtr;
        do
        {
          unsigned int v10 = *(unsigned __int8 *)v8;
          int v8 = (unsigned int *)((char *)v8 + 1);
          unsigned int v9 = v10;
          unsigned int v6 = v6;
          if (v6 <= v10) {
            unsigned int v6 = v9;
          }
          --v7;
        }
        while (v7);
        int v11 = v6 + 1;
      }
      else
      {
        int v11 = 1;
      }
      return OptimizeVertexCache<unsigned char>::OptimizeIndices((unsigned __int8 *)BytePtr, a2, v11);
    default:
      return 0;
  }
}

CFDataRef OptimizeVertexCache<unsigned char>::OptimizeIndices(unsigned __int8 *a1, int a2, int a3)
{
  size_t v6 = 3 * a2;
  uint64_t v7 = (UInt8 *)malloc_type_calloc(1uLL, v6, 0x52CCC585uLL);
  OptimizeVertexCache<unsigned char>::OptimizeVertexCache((uint64_t)v9);
  if (OptimizeVertexCache<unsigned char>::reorderIndices((uint64_t)v9, (uint64_t)v7, a1, a2, a3)) {
    return CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v6, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  }
  free(v7);
  return 0;
}

CFDataRef OptimizeVertexCache<unsigned short>::OptimizeIndices(unsigned __int16 *a1, int a2, int a3)
{
  size_t v6 = 3 * a2;
  uint64_t v7 = (UInt8 *)malloc_type_calloc(2uLL, v6, 0x52CCC585uLL);
  OptimizeVertexCache<unsigned char>::OptimizeVertexCache((uint64_t)v9);
  if (OptimizeVertexCache<unsigned short>::reorderIndices((uint64_t)v9, (uint64_t)v7, a1, a2, a3)) {
    return CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, 2 * v6, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  }
  free(v7);
  return 0;
}

CFDataRef OptimizeVertexCache<unsigned int>::OptimizeIndices(unsigned int *a1, int a2, int a3)
{
  size_t v6 = 3 * a2;
  uint64_t v7 = (UInt8 *)malloc_type_calloc(4uLL, v6, 0x52CCC585uLL);
  OptimizeVertexCache<unsigned char>::OptimizeVertexCache((uint64_t)v9);
  if (OptimizeVertexCache<unsigned int>::reorderIndices((uint64_t)v9, (uint64_t)v7, a1, a2, a3)) {
    return CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, 4 * v6, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  }
  free(v7);
  return 0;
}

void C3DMeshElementOptimizeIndices(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 88))
  {
    CFDataRef OptimizedIndices = C3DDataCreateOptimizedIndices(*(const __CFData **)(a1 + 96), *(_DWORD *)(a1 + 104), *(unsigned __int8 *)(a1 + 80));
    if (OptimizedIndices)
    {
      CFDataRef v3 = OptimizedIndices;
      C3DMeshElementSetPrimitives(a1, *(_DWORD *)(a1 + 104), OptimizedIndices, *(unsigned char *)(a1 + 80));
      CFRelease(v3);
    }
  }
}

_DWORD *C3DMeshSourceCreateWeldRemappingTable(uint64_t a1)
{
  uint64_t Content = C3DMeshSourceGetContent(a1);
  __int16 v3 = v2;
  uint64_t v5 = v4;
  size_t v6 = malloc_type_calloc(v4, 4uLL, 0x100004052888210uLL);
  float32x4_t v9 = 0uLL;
  long long v19 = 0u;
  long long v20 = 0u;
  int v21 = 1065353216;
  if (v5)
  {
    unsigned int v10 = 0;
    for (uint64_t i = 0; i != v5; ++i)
    {
      *(double *)v12.i64 = C3DConvertFloatingTypeToFloat4(v3, (float *)(Content + v10), v9, v7, v8);
      float32x4_t v17 = v12;
      float32x4_t v18 = v12;
      uint64_t v13 = _ZNSt3__112__hash_tableINS_17__hash_value_typeIDv3_fjEENS_22__unordered_map_hasherIS2_S3_NS_4hashIS2_EENS_8equal_toIS2_EELb1EEENS_21__unordered_map_equalIS2_S3_S8_S6_Lb1EEENS_9allocatorIS3_EEE4findIS2_EENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(&v19, &v18);
      if (v13)
      {
        __int32 v14 = v13[2].i32[0];
      }
      else
      {
        float32x4_t v18 = v17;
        unsigned int v22 = &v18;
        _ZNSt3__112__hash_tableINS_17__hash_value_typeIDv3_fjEENS_22__unordered_map_hasherIS2_S3_NS_4hashIS2_EENS_8equal_toIS2_EELb1EEENS_21__unordered_map_equalIS2_S3_S8_S6_Lb1EEENS_9allocatorIS3_EEE25__emplace_unique_key_argsIS2_JRKNS_21piecewise_construct_tENS_5tupleIJRKS2_EEENSJ_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEEbEERKT_DpOT0_((uint64_t)&v19, &v18, (uint64_t)&std::piecewise_construct, &v22)[2].i32[0] = i;
        __int32 v14 = i;
      }
      v6[i] = v14;
      v10 += HIBYTE(v3);
    }
    uint64_t v15 = *((void *)&v20 + 1);
  }
  else
  {
    uint64_t v15 = 0;
  }
  if (v15 == v5)
  {
    free(v6);
    size_t v6 = 0;
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)&v19);
  return v6;
}

uint64_t OptimizeVertexCache<unsigned char>::reorderIndices(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, int a5)
{
  uint64_t v91 = a1;
  uint64_t v94 = *MEMORY[0x263EF8340];
  size_t v8 = a5;
  float32x4_t v9 = (unsigned __int8 *)malloc_type_malloc(a5, 0x100004077774924uLL);
  bzero(v9, v8);
  if (a4 >= 1)
  {
    LODWORD(v10) = 3 * a4;
    if (3 * a4 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v10;
    }
    int v11 = a3;
    do
    {
      unsigned int v13 = *v11++;
      uint64_t v12 = v13;
      int v14 = v9[v13];
      if (v14 == 255)
      {
        free(v9);
        return 0;
      }
      v9[v12] = v14 + 1;
      --v10;
    }
    while (v10);
  }
  uint64_t v88 = a2;
  uint64_t v15 = (int *)malloc_type_malloc(4 * v8, 0x100004052888210uLL);
  unsigned int v16 = malloc_type_malloc(2 * v8, 0x1000040BDFB0063uLL);
  float32x4_t v17 = malloc_type_malloc(v8, 0x100004077774924uLL);
  int v18 = a4 + 7;
  if (a4 < -7) {
    int v18 = a4 + 14;
  }
  uint64_t v87 = (uint64_t)v18 >> 3;
  long long v19 = (unsigned __int8 *)malloc_type_malloc(v87, 0xECEB6150uLL);
  long long v20 = (unsigned __int16 *)malloc_type_malloc(2 * a4, 0x1000040BDFB0063uLL);
  uint64_t v86 = 12 * a4;
  int v21 = (char *)malloc_type_malloc(v86, 0xBD9110F1uLL);
  bzero(v19, v87);
  bzero(v20, 2 * a4);
  bzero(v21, v86);
  if (a5 >= 1)
  {
    int v22 = 0;
    uint64_t v23 = a5;
    uint64_t v24 = v15;
    float32x4_t v25 = v9;
    int8x16_t v26 = v17;
    do
    {
      *v24++ = v22;
      v22 += *v25;
      *v25++ = 0;
      *v26++ = -1;
      --v23;
    }
    while (v23);
  }
  uint64_t v27 = v91;
  if (a4 >= 1)
  {
    uint64_t v28 = 0;
    long long v29 = a3;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        uint64_t v31 = v29[i];
        *(_DWORD *)&v21[4 * v15[v31] + 4 * v9[v31]++] = v28;
      }
      ++v28;
      v29 += 3;
    }
    while (v28 != a4);
  }
  if (a5 >= 1)
  {
    uint64_t v32 = 0;
    do
    {
      uint64_t v33 = v9[v32];
      if (v9[v32])
      {
        unsigned int v34 = (char)v17[v32];
        if ((v34 & 0x80000000) != 0) {
          int v35 = 0;
        }
        else {
          int v35 = *(_DWORD *)(v27 + 4 * v34);
        }
        if (v33 <= 0x1F) {
          v35 += *(_DWORD *)(v27 + 4 * v33 + 128);
        }
      }
      else
      {
        LOWORD(v35) = 0;
      }
      v16[v32] = v35;
      if (v9[v32])
      {
        unint64_t v36 = 0;
        uint64_t v37 = &v21[4 * v15[v32]];
        do
          v20[*(int *)&v37[4 * v36++]] += v16[v32];
        while (v36 < v9[v32]);
      }
      ++v32;
    }
    while (v32 != a5);
  }
  if (a4 < 1)
  {
    unsigned int v40 = -1;
  }
  else
  {
    uint64_t v38 = 0;
    int v39 = -1;
    unsigned int v40 = -1;
    do
    {
      int v41 = v20[v38];
      if (v39 < v41) {
        unsigned int v40 = v38;
      }
      if (v39 <= v41) {
        int v39 = v20[v38];
      }
      ++v38;
    }
    while (a4 != v38);
  }
  uint64_t v90 = a4;
  long long v43 = (int *)malloc_type_malloc(4 * a4, 0x100004052888210uLL);
  *(void *)&long long v44 = -1;
  *((void *)&v44 + 1) = -1;
  *(_OWORD *)&v93[12] = v44;
  v92[4] = v44;
  *(_OWORD *)int8x16_t v93 = v44;
  v92[2] = v44;
  v92[3] = v44;
  v92[0] = v44;
  v92[1] = v44;
  uint64_t v45 = v91;
  if ((v40 & 0x80000000) != 0) {
    goto LABEL_92;
  }
  uint64_t v46 = 0;
  int v47 = 0;
  do
  {
    uint64_t v48 = 0;
    v19[(unint64_t)v40 >> 3] |= 1 << (v40 & 7);
    v43[v46] = v40;
    do
    {
      uint64_t v49 = a3[v48 + (int)(3 * v40)];
      LODWORD(j) = (char)v17[v49];
      if ((int)j < 0) {
        LODWORD(j) = v48 + 24;
      }
      for (uint64_t j = (int)j; j > v48; --j)
      {
        float v51 = (_DWORD *)v92 + j;
        uint64_t v52 = *(v51 - 1);
        _DWORD *v51 = v52;
        if ((v52 & 0x80000000) == 0)
        {
          int v53 = (char)v17[v52];
          if (v53 <= 25) {
            v17[v52] = v53 + 1;
          }
        }
      }
      *((_DWORD *)v92 + v48) = v49;
      v17[v49] = v48;
      int v54 = v9[v49];
      if (v9[v49])
      {
        uint64_t v55 = v15[v49];
        simd_float4x4 v56 = &v21[4 * v55];
        uint64_t v57 = v9[v49];
        while (*(_DWORD *)v56 != v40)
        {
          v56 += 4;
          if (!--v57) {
            goto LABEL_58;
          }
        }
        *(_DWORD *)simd_float4x4 v56 = *(_DWORD *)&v21[4 * v54 - 4 + 4 * (int)v55];
        LOBYTE(v54) = v9[v49];
      }
LABEL_58:
      v9[v49] = v54 - 1;
      ++v48;
    }
    while (v48 != 3);
    unint64_t v58 = 0;
    ++v46;
    do
    {
      uint64_t v59 = *((unsigned int *)v92 + v58);
      if ((v59 & 0x80000000) != 0) {
        break;
      }
      if (v58 <= 0x17)
      {
        int8x16_t v60 = &v9[v59];
        unsigned int v61 = v9[v59];
        if (v9[v59])
        {
          unsigned int v62 = (char)v17[v59];
          if ((v62 & 0x80000000) != 0) {
LABEL_67:
          }
            int v63 = 0;
          else {
            int v63 = *(_DWORD *)(v45 + 4 * v62);
          }
          if (v61 <= 0x1F) {
            v63 += *(_DWORD *)(v45 + 4 * v61 + 128);
          }
          unint64_t v64 = 0;
          int8x16_t v65 = &v16[v59];
          __int16 v66 = v63 - *v65;
          float32x4_t v67 = &v21[4 * v15[v59]];
          do
            v20[*(int *)&v67[4 * v64++]] += v66;
          while (v64 < *v60);
          goto LABEL_74;
        }
      }
      else
      {
        v17[v59] = -1;
        *((_DWORD *)v92 + v58) = -1;
        int8x16_t v60 = &v9[v59];
        unsigned int v61 = v9[v59];
        if (v9[v59]) {
          goto LABEL_67;
        }
      }
      LOWORD(v63) = 0;
      int8x16_t v65 = &v16[v59];
LABEL_74:
      *int8x16_t v65 = v63;
      ++v58;
    }
    while (v58 != 27);
    uint64_t v68 = 0;
    int v69 = -1;
    unsigned int v40 = -1;
    do
    {
      uint64_t v70 = *((unsigned int *)v92 + v68);
      if ((v70 & 0x80000000) != 0) {
        break;
      }
      uint64_t v71 = v9[v70];
      if (v9[v70])
      {
        float32x4_t v72 = &v21[4 * v15[v70]];
        do
        {
          uint64_t v74 = *(int *)v72;
          v72 += 4;
          unsigned int v73 = v74;
          int v75 = v20[v74];
          if (v69 < v75) {
            unsigned int v40 = v73;
          }
          if (v69 <= v75) {
            int v69 = v75;
          }
          --v71;
        }
        while (v71);
      }
      ++v68;
    }
    while (v68 != 24);
    if ((v40 & 0x80000000) != 0 && v47 < a4)
    {
      while (((v19[v47 >> 3] >> (v47 & 7)) & 1) != 0)
      {
        if (a4 == ++v47)
        {
          int v47 = a4;
          goto LABEL_91;
        }
      }
      unsigned int v40 = v47;
    }
LABEL_91:
    ;
  }
  while ((v40 & 0x80000000) == 0);
LABEL_92:
  BOOL v76 = a4 < 1;
  uint64_t v42 = v88;
  if (!v76)
  {
    uint64_t v77 = 0;
    int v78 = 0;
    do
    {
      uint64_t v79 = 0;
      int v80 = v78;
      uint64_t v81 = v88 + v78;
      int8x16_t v82 = &a3[3 * v43[v77]];
      do
      {
        *(unsigned char *)(v81 + v79) = v82[v79];
        ++v79;
      }
      while (v79 != 3);
      ++v77;
      int v78 = v80 + 3;
    }
    while (v77 != v90);
  }
  float32x4_t v83 = v21;
  int8x16_t v84 = v43;
  free(v83);
  free(v15);
  free(v16);
  free(v9);
  free(v17);
  free(v19);
  free(v20);
  free(v84);
  return v42;
}

uint64_t OptimizeVertexCache<unsigned char>::OptimizeVertexCache(uint64_t a1)
{
  for (unint64_t i = 0; i != 32; ++i)
  {
    float v3 = 0.75;
    if (i >= 3) {
      float v3 = powf((float)((float)((int)i - 3) * -0.034483) + 1.0, 1.5);
    }
    *(_DWORD *)(a1 + 4 * i) = (float)(v3 * 7281.0);
  }
  unint64_t v4 = 0;
  uint64x2_t v10 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
  do
  {
    uint64x2_t v5 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v4), (int8x16_t)xmmword_20B5CC140);
    unsigned __int8 v13 = vmovn_s64((int64x2_t)vcgtq_u64(v10, v5)).u8[0];
    uint64x2_t v14 = v5;
    v6.i32[0] = v4 | 1;
    v6.i32[1] = vadd_s32(vdup_lane_s32((int32x2_t)v4, 0), (int32x2_t)0x200000002).i32[1];
    float32x2_t v7 = vcvt_f32_s32(v6);
    float v11 = v7.f32[0];
    float v12 = powf(v7.f32[1], -0.5);
    float v8 = powf(v11, -0.5);
    if (v13) {
      *(_DWORD *)(a1 + 4 * v4 + 132) = (float)((float)(v8 + v8) * 7281.0);
    }
    if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v14)).i32[1]) {
      *(_DWORD *)(a1 + 4 * v4 + 136) = (float)((float)(v12 + v12) * 7281.0);
    }
    v4 += 2;
  }
  while (v4 != 32);
  return a1;
}

uint64_t OptimizeVertexCache<unsigned short>::reorderIndices(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4, int a5)
{
  uint64_t v91 = a1;
  uint64_t v94 = *MEMORY[0x263EF8340];
  size_t v8 = a5;
  float32x4_t v9 = (unsigned __int8 *)malloc_type_malloc(a5, 0x100004077774924uLL);
  bzero(v9, v8);
  if (a4 >= 1)
  {
    LODWORD(v10) = 3 * a4;
    if (3 * a4 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v10;
    }
    float v11 = a3;
    do
    {
      unsigned int v13 = *v11++;
      uint64_t v12 = v13;
      int v14 = v9[v13];
      if (v14 == 255)
      {
        free(v9);
        return 0;
      }
      v9[v12] = v14 + 1;
      --v10;
    }
    while (v10);
  }
  uint64_t v88 = a2;
  uint64_t v15 = (int *)malloc_type_malloc(4 * v8, 0x100004052888210uLL);
  unsigned int v16 = malloc_type_malloc(2 * v8, 0x1000040BDFB0063uLL);
  float32x4_t v17 = malloc_type_malloc(v8, 0x100004077774924uLL);
  int v18 = a4 + 7;
  if (a4 < -7) {
    int v18 = a4 + 14;
  }
  uint64_t v87 = (uint64_t)v18 >> 3;
  long long v19 = (unsigned __int8 *)malloc_type_malloc(v87, 0xECEB6150uLL);
  long long v20 = (unsigned __int16 *)malloc_type_malloc(2 * a4, 0x1000040BDFB0063uLL);
  uint64_t v86 = 12 * a4;
  int v21 = (char *)malloc_type_malloc(v86, 0xBD9110F1uLL);
  bzero(v19, v87);
  bzero(v20, 2 * a4);
  bzero(v21, v86);
  if (a5 >= 1)
  {
    int v22 = 0;
    uint64_t v23 = a5;
    uint64_t v24 = v15;
    float32x4_t v25 = v9;
    int8x16_t v26 = v17;
    do
    {
      *v24++ = v22;
      v22 += *v25;
      *v25++ = 0;
      *v26++ = -1;
      --v23;
    }
    while (v23);
  }
  uint64_t v27 = v91;
  if (a4 >= 1)
  {
    uint64_t v28 = 0;
    long long v29 = a3;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        uint64_t v31 = v29[i];
        *(_DWORD *)&v21[4 * v15[v31] + 4 * v9[v31]++] = v28;
      }
      ++v28;
      v29 += 3;
    }
    while (v28 != a4);
  }
  if (a5 >= 1)
  {
    uint64_t v32 = 0;
    do
    {
      uint64_t v33 = v9[v32];
      if (v9[v32])
      {
        unsigned int v34 = (char)v17[v32];
        if ((v34 & 0x80000000) != 0) {
          int v35 = 0;
        }
        else {
          int v35 = *(_DWORD *)(v27 + 4 * v34);
        }
        if (v33 <= 0x1F) {
          v35 += *(_DWORD *)(v27 + 4 * v33 + 128);
        }
      }
      else
      {
        LOWORD(v35) = 0;
      }
      v16[v32] = v35;
      if (v9[v32])
      {
        unint64_t v36 = 0;
        uint64_t v37 = &v21[4 * v15[v32]];
        do
          v20[*(int *)&v37[4 * v36++]] += v16[v32];
        while (v36 < v9[v32]);
      }
      ++v32;
    }
    while (v32 != a5);
  }
  if (a4 < 1)
  {
    unsigned int v40 = -1;
  }
  else
  {
    uint64_t v38 = 0;
    int v39 = -1;
    unsigned int v40 = -1;
    do
    {
      int v41 = v20[v38];
      if (v39 < v41) {
        unsigned int v40 = v38;
      }
      if (v39 <= v41) {
        int v39 = v20[v38];
      }
      ++v38;
    }
    while (a4 != v38);
  }
  uint64_t v90 = a4;
  long long v43 = (int *)malloc_type_malloc(4 * a4, 0x100004052888210uLL);
  *(void *)&long long v44 = -1;
  *((void *)&v44 + 1) = -1;
  *(_OWORD *)&v93[12] = v44;
  v92[4] = v44;
  *(_OWORD *)int8x16_t v93 = v44;
  v92[2] = v44;
  v92[3] = v44;
  v92[0] = v44;
  v92[1] = v44;
  uint64_t v45 = v91;
  if ((v40 & 0x80000000) != 0) {
    goto LABEL_92;
  }
  uint64_t v46 = 0;
  int v47 = 0;
  do
  {
    uint64_t v48 = 0;
    v19[(unint64_t)v40 >> 3] |= 1 << (v40 & 7);
    v43[v46] = v40;
    do
    {
      uint64_t v49 = a3[v48 + (int)(3 * v40)];
      LODWORD(j) = (char)v17[v49];
      if ((int)j < 0) {
        LODWORD(j) = v48 + 24;
      }
      for (uint64_t j = (int)j; j > v48; --j)
      {
        float v51 = (_DWORD *)v92 + j;
        uint64_t v52 = *(v51 - 1);
        _DWORD *v51 = v52;
        if ((v52 & 0x80000000) == 0)
        {
          int v53 = (char)v17[v52];
          if (v53 <= 25) {
            v17[v52] = v53 + 1;
          }
        }
      }
      *((_DWORD *)v92 + v48) = v49;
      v17[v49] = v48;
      int v54 = v9[v49];
      if (v9[v49])
      {
        uint64_t v55 = v15[v49];
        simd_float4x4 v56 = &v21[4 * v55];
        uint64_t v57 = v9[v49];
        while (*(_DWORD *)v56 != v40)
        {
          v56 += 4;
          if (!--v57) {
            goto LABEL_58;
          }
        }
        *(_DWORD *)simd_float4x4 v56 = *(_DWORD *)&v21[4 * v54 - 4 + 4 * (int)v55];
        LOBYTE(v54) = v9[v49];
      }
LABEL_58:
      v9[v49] = v54 - 1;
      ++v48;
    }
    while (v48 != 3);
    unint64_t v58 = 0;
    ++v46;
    do
    {
      uint64_t v59 = *((unsigned int *)v92 + v58);
      if ((v59 & 0x80000000) != 0) {
        break;
      }
      if (v58 <= 0x17)
      {
        int8x16_t v60 = &v9[v59];
        unsigned int v61 = v9[v59];
        if (v9[v59])
        {
          unsigned int v62 = (char)v17[v59];
          if ((v62 & 0x80000000) != 0) {
LABEL_67:
          }
            int v63 = 0;
          else {
            int v63 = *(_DWORD *)(v45 + 4 * v62);
          }
          if (v61 <= 0x1F) {
            v63 += *(_DWORD *)(v45 + 4 * v61 + 128);
          }
          unint64_t v64 = 0;
          int8x16_t v65 = &v16[v59];
          __int16 v66 = v63 - *v65;
          float32x4_t v67 = &v21[4 * v15[v59]];
          do
            v20[*(int *)&v67[4 * v64++]] += v66;
          while (v64 < *v60);
          goto LABEL_74;
        }
      }
      else
      {
        v17[v59] = -1;
        *((_DWORD *)v92 + v58) = -1;
        int8x16_t v60 = &v9[v59];
        unsigned int v61 = v9[v59];
        if (v9[v59]) {
          goto LABEL_67;
        }
      }
      LOWORD(v63) = 0;
      int8x16_t v65 = &v16[v59];
LABEL_74:
      *int8x16_t v65 = v63;
      ++v58;
    }
    while (v58 != 27);
    uint64_t v68 = 0;
    int v69 = -1;
    unsigned int v40 = -1;
    do
    {
      uint64_t v70 = *((unsigned int *)v92 + v68);
      if ((v70 & 0x80000000) != 0) {
        break;
      }
      uint64_t v71 = v9[v70];
      if (v9[v70])
      {
        float32x4_t v72 = &v21[4 * v15[v70]];
        do
        {
          uint64_t v74 = *(int *)v72;
          v72 += 4;
          unsigned int v73 = v74;
          int v75 = v20[v74];
          if (v69 < v75) {
            unsigned int v40 = v73;
          }
          if (v69 <= v75) {
            int v69 = v75;
          }
          --v71;
        }
        while (v71);
      }
      ++v68;
    }
    while (v68 != 24);
    if ((v40 & 0x80000000) != 0 && v47 < a4)
    {
      while (((v19[v47 >> 3] >> (v47 & 7)) & 1) != 0)
      {
        if (a4 == ++v47)
        {
          int v47 = a4;
          goto LABEL_91;
        }
      }
      unsigned int v40 = v47;
    }
LABEL_91:
    ;
  }
  while ((v40 & 0x80000000) == 0);
LABEL_92:
  BOOL v76 = a4 < 1;
  uint64_t v42 = v88;
  if (!v76)
  {
    uint64_t v77 = 0;
    int v78 = 0;
    do
    {
      uint64_t v79 = 0;
      int v80 = v78;
      uint64_t v81 = v88 + 2 * v78;
      int8x16_t v82 = &a3[3 * v43[v77]];
      do
      {
        *(_WORD *)(v81 + 2 * v79) = v82[v79];
        ++v79;
      }
      while (v79 != 3);
      ++v77;
      int v78 = v80 + 3;
    }
    while (v77 != v90);
  }
  float32x4_t v83 = v21;
  int8x16_t v84 = v43;
  free(v83);
  free(v15);
  free(v16);
  free(v9);
  free(v17);
  free(v19);
  free(v20);
  free(v84);
  return v42;
}

uint64_t OptimizeVertexCache<unsigned int>::reorderIndices(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, int a5)
{
  uint64_t v92 = a1;
  uint64_t v95 = *MEMORY[0x263EF8340];
  size_t v8 = a5;
  float32x4_t v9 = (unsigned __int8 *)malloc_type_malloc(a5, 0x100004077774924uLL);
  bzero(v9, v8);
  if (a4 >= 1)
  {
    LODWORD(v10) = 3 * a4;
    if (3 * a4 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v10;
    }
    float v11 = a3;
    do
    {
      unsigned int v13 = *v11++;
      uint64_t v12 = v13;
      int v14 = v9[v13];
      if (v14 == 255)
      {
        free(v9);
        return 0;
      }
      v9[v12] = v14 + 1;
      --v10;
    }
    while (v10);
  }
  uint64_t v89 = a2;
  uint64_t v15 = (int *)malloc_type_malloc(4 * v8, 0x100004052888210uLL);
  unsigned int v16 = malloc_type_malloc(2 * v8, 0x1000040BDFB0063uLL);
  float32x4_t v17 = malloc_type_malloc(v8, 0x100004077774924uLL);
  int v18 = a4 + 7;
  if (a4 < -7) {
    int v18 = a4 + 14;
  }
  uint64_t v88 = (uint64_t)v18 >> 3;
  long long v19 = (unsigned __int8 *)malloc_type_malloc(v88, 0xECEB6150uLL);
  long long v20 = (unsigned __int16 *)malloc_type_malloc(2 * a4, 0x1000040BDFB0063uLL);
  uint64_t v87 = 12 * a4;
  int v21 = (char *)malloc_type_malloc(v87, 0xBD9110F1uLL);
  bzero(v19, v88);
  bzero(v20, 2 * a4);
  bzero(v21, v87);
  if (a5 >= 1)
  {
    int v22 = 0;
    uint64_t v23 = a5;
    uint64_t v24 = v15;
    float32x4_t v25 = v9;
    int8x16_t v26 = v17;
    do
    {
      *v24++ = v22;
      v22 += *v25;
      *v25++ = 0;
      *v26++ = -1;
      --v23;
    }
    while (v23);
  }
  uint64_t v27 = v92;
  if (a4 >= 1)
  {
    uint64_t v28 = 0;
    long long v29 = a3;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        uint64_t v31 = (int)v29[i];
        *(_DWORD *)&v21[4 * v15[v31] + 4 * v9[v31]++] = v28;
      }
      ++v28;
      v29 += 3;
    }
    while (v28 != a4);
  }
  if (a5 >= 1)
  {
    uint64_t v32 = 0;
    do
    {
      uint64_t v33 = v9[v32];
      if (v9[v32])
      {
        unsigned int v34 = (char)v17[v32];
        if ((v34 & 0x80000000) != 0) {
          int v35 = 0;
        }
        else {
          int v35 = *(_DWORD *)(v27 + 4 * v34);
        }
        if (v33 <= 0x1F) {
          v35 += *(_DWORD *)(v27 + 4 * v33 + 128);
        }
      }
      else
      {
        LOWORD(v35) = 0;
      }
      v16[v32] = v35;
      if (v9[v32])
      {
        unint64_t v36 = 0;
        uint64_t v37 = &v21[4 * v15[v32]];
        do
          v20[*(int *)&v37[4 * v36++]] += v16[v32];
        while (v36 < v9[v32]);
      }
      ++v32;
    }
    while (v32 != a5);
  }
  if (a4 < 1)
  {
    unsigned int v40 = -1;
  }
  else
  {
    uint64_t v38 = 0;
    int v39 = -1;
    unsigned int v40 = -1;
    do
    {
      int v41 = v20[v38];
      if (v39 < v41) {
        unsigned int v40 = v38;
      }
      if (v39 <= v41) {
        int v39 = v20[v38];
      }
      ++v38;
    }
    while (a4 != v38);
  }
  uint64_t v91 = a4;
  long long v43 = (int *)malloc_type_malloc(4 * a4, 0x100004052888210uLL);
  *(void *)&long long v44 = -1;
  *((void *)&v44 + 1) = -1;
  *(_OWORD *)&v94[12] = v44;
  float32x4_t v93[4] = v44;
  *(_OWORD *)uint64_t v94 = v44;
  v93[2] = v44;
  v93[3] = v44;
  v93[0] = v44;
  v93[1] = v44;
  uint64_t v45 = v92;
  if ((v40 & 0x80000000) != 0) {
    goto LABEL_92;
  }
  uint64_t v46 = 0;
  int v47 = 0;
  do
  {
    uint64_t v48 = 0;
    v19[(unint64_t)v40 >> 3] |= 1 << (v40 & 7);
    v43[v46] = v40;
    do
    {
      unsigned int v49 = a3[v48 + (int)(3 * v40)];
      LODWORD(j) = (char)v17[v49];
      if ((int)j < 0) {
        LODWORD(j) = v48 + 24;
      }
      for (uint64_t j = (int)j; j > v48; --j)
      {
        float v51 = (_DWORD *)v93 + j;
        uint64_t v52 = *(v51 - 1);
        _DWORD *v51 = v52;
        if ((v52 & 0x80000000) == 0)
        {
          int v53 = (char)v17[v52];
          if (v53 <= 25) {
            v17[v52] = v53 + 1;
          }
        }
      }
      uint64_t v54 = (int)v49;
      *((_DWORD *)v93 + v48) = v49;
      v17[v49] = v48;
      uint64_t v55 = v9[v49];
      if (v55)
      {
        uint64_t v56 = v15[v54];
        uint64_t v57 = &v21[4 * v56];
        uint64_t v58 = v55;
        while (*(_DWORD *)v57 != v40)
        {
          v57 += 4;
          if (!--v58) {
            goto LABEL_58;
          }
        }
        *(_DWORD *)uint64_t v57 = *(_DWORD *)&v21[4 * (int)v55 - 4 + 4 * (int)v56];
        LOBYTE(v55) = v9[v54];
      }
LABEL_58:
      v9[v54] = v55 - 1;
      ++v48;
    }
    while (v48 != 3);
    unint64_t v59 = 0;
    ++v46;
    do
    {
      uint64_t v60 = *((unsigned int *)v93 + v59);
      if ((v60 & 0x80000000) != 0) {
        break;
      }
      if (v59 <= 0x17)
      {
        unsigned int v61 = &v9[v60];
        unsigned int v62 = v9[v60];
        if (v9[v60])
        {
          unsigned int v63 = (char)v17[v60];
          if ((v63 & 0x80000000) != 0) {
LABEL_67:
          }
            int v64 = 0;
          else {
            int v64 = *(_DWORD *)(v45 + 4 * v63);
          }
          if (v62 <= 0x1F) {
            v64 += *(_DWORD *)(v45 + 4 * v62 + 128);
          }
          unint64_t v65 = 0;
          __int16 v66 = &v16[v60];
          __int16 v67 = v64 - *v66;
          uint64_t v68 = &v21[4 * v15[v60]];
          do
            v20[*(int *)&v68[4 * v65++]] += v67;
          while (v65 < *v61);
          goto LABEL_74;
        }
      }
      else
      {
        v17[v60] = -1;
        *((_DWORD *)v93 + v59) = -1;
        unsigned int v61 = &v9[v60];
        unsigned int v62 = v9[v60];
        if (v9[v60]) {
          goto LABEL_67;
        }
      }
      LOWORD(v64) = 0;
      __int16 v66 = &v16[v60];
LABEL_74:
      *__int16 v66 = v64;
      ++v59;
    }
    while (v59 != 27);
    uint64_t v69 = 0;
    int v70 = -1;
    unsigned int v40 = -1;
    do
    {
      uint64_t v71 = *((unsigned int *)v93 + v69);
      if ((v71 & 0x80000000) != 0) {
        break;
      }
      uint64_t v72 = v9[v71];
      if (v9[v71])
      {
        unsigned int v73 = &v21[4 * v15[v71]];
        do
        {
          uint64_t v75 = *(int *)v73;
          v73 += 4;
          unsigned int v74 = v75;
          int v76 = v20[v75];
          if (v70 < v76) {
            unsigned int v40 = v74;
          }
          if (v70 <= v76) {
            int v70 = v76;
          }
          --v72;
        }
        while (v72);
      }
      ++v69;
    }
    while (v69 != 24);
    if ((v40 & 0x80000000) != 0 && v47 < a4)
    {
      while (((v19[v47 >> 3] >> (v47 & 7)) & 1) != 0)
      {
        if (a4 == ++v47)
        {
          int v47 = a4;
          goto LABEL_91;
        }
      }
      unsigned int v40 = v47;
    }
LABEL_91:
    ;
  }
  while ((v40 & 0x80000000) == 0);
LABEL_92:
  BOOL v77 = a4 < 1;
  uint64_t v42 = v89;
  if (!v77)
  {
    uint64_t v78 = 0;
    int v79 = 0;
    do
    {
      uint64_t v80 = 0;
      int v81 = v79;
      uint64_t v82 = v89 + 4 * v79;
      float32x4_t v83 = &a3[3 * v43[v78]];
      do
      {
        *(_DWORD *)(v82 + 4 * v80) = v83[v80];
        ++v80;
      }
      while (v80 != 3);
      ++v78;
      int v79 = v81 + 3;
    }
    while (v78 != v91);
  }
  int8x16_t v84 = v21;
  int8x16_t v85 = v43;
  free(v84);
  free(v15);
  free(v16);
  free(v9);
  free(v17);
  free(v19);
  free(v20);
  free(v85);
  return v42;
}

float32x4_t *_ZNSt3__112__hash_tableINS_17__hash_value_typeIDv3_fjEENS_22__unordered_map_hasherIS2_S3_NS_4hashIS2_EENS_8equal_toIS2_EELb1EEENS_21__unordered_map_equalIS2_S3_S8_S6_Lb1EEENS_9allocatorIS3_EEE4findIS2_EENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(void *a1, float32x4_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = a2->i32[0] ^ (2 * a2->i32[1]) ^ (4 * a2->i32[2]);
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2->i32[0] ^ (2 * a2->i32[1]) ^ (4 * a2->i32[2]);
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  int32x2_t v6 = *(float32x4_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (double result = *v6; result; double result = (float32x4_t *)result->i64[0])
  {
    unint64_t v8 = result->u64[1];
    if (v8 == v3)
    {
      uint32x4_t v9 = (uint32x4_t)vceqq_f32(result[1], *a2);
      v9.i32[3] = v9.i32[2];
      if ((vminvq_u32(v9) & 0x80000000) != 0) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

float32x4_t *_ZNSt3__112__hash_tableINS_17__hash_value_typeIDv3_fjEENS_22__unordered_map_hasherIS2_S3_NS_4hashIS2_EENS_8equal_toIS2_EELb1EEENS_21__unordered_map_equalIS2_S3_S8_S6_Lb1EEENS_9allocatorIS3_EEE25__emplace_unique_key_argsIS2_JRKNS_21piecewise_construct_tENS_5tupleIJRKS2_EEENSJ_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEEbEERKT_DpOT0_(uint64_t a1, float32x4_t *a2, uint64_t a3, float32x4_t **a4)
{
  unint64_t v7 = a2->i32[0] ^ (2 * a2->i32[1]) ^ (4 * a2->i32[2]);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = a2->i32[0] ^ (2 * a2->i32[1]) ^ (4 * a2->i32[2]);
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(float32x4_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (float32x4_t *)i->i64[0])
      {
        unint64_t v12 = i->u64[1];
        if (v12 == v7)
        {
          uint32x4_t v13 = (uint32x4_t)vceqq_f32(i[1], *a2);
          v13.i32[3] = v13.i32[2];
          if ((vminvq_u32(v13) & 0x80000000) != 0) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = (float32x4_t *)operator new(0x30uLL);
  i->i64[0] = 0;
  i->i64[1] = v7;
  i[1] = **a4;
  i[2].i32[0] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  int v21 = *(float32x4_t ***)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    i->i64[0] = (uint64_t)*v21;
LABEL_38:
    char *v21 = i;
    goto LABEL_39;
  }
  i->i64[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v4) = a1 + 16;
  if (i->i64[0])
  {
    unint64_t v22 = *(void *)(i->i64[0] + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    int v21 = (float32x4_t **)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

__n128 C3D::FillTexturePass::FillTexturePass(C3D::FillTexturePass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  unint64_t v5 = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)unint64_t v5 = &unk_26BF6D470;
  __n128 result = *(__n128 *)&a4->var0;
  *((_OWORD *)v5 + 15) = *(_OWORD *)&a4->var0;
  return result;
}

const char *C3D::FillTexturePass::name(C3D::FillTexturePass *this)
{
  return "FillTexturePass";
}

uint64_t C3D::FillTexturePass::setup(C3D::FillTexturePass *this)
{
  uint64_t v1 = this;
  C3D::Pass::setOutputCount(this, 1u);
  long long v4 = *((_OWORD *)v1 + 15);
  uint64_t v1 = (C3D::FillTexturePass *)((char *)v1 + 32);
  *(_OWORD *)(C3D::PassDescriptor::outputAtIndex(v1, 0) + 48) = v4;
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex(v1, 0);
  *(_WORD *)(v2 + 66) = *(_WORD *)(v2 + 66) & 0xFFFC | 2;
  uint64_t result = C3D::PassDescriptor::outputAtIndex(v1, 0);
  *(_WORD *)(result + 66) |= 0x40u;
  return result;
}

uint64_t C3DFramebufferRegistryGetEnableRecycling()
{
  return gC3DFBORegistryEnableRecycling;
}

CFStringRef _C3DFramebufferRegistryCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFramebufferRegistry>");
}

CFStringRef _C3DFramebufferRegistryCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFramebufferRegistry>");
}

CFTypeRef C3DFramebufferRegistryPrepareFramebufferWithDescription(uint64_t a1, float32x2_t *a2, uint64_t a3, CFIndex a4, int a5, void *key, uint64_t a7)
{
  if (!a1)
  {
    float v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (*(unsigned char *)(a1 + 80)) {
    goto LABEL_9;
  }
  CFNumberRef Value = (float32x2_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), key);
  if (Value)
  {
    ValueAtuint64_t Index = (uint64_t)Value;
    uint32x2_t v24 = (uint32x2_t)vceq_f32(*a2, Value[5]);
    if ((vpmin_u32(v24, v24).u32[0] & 0x80000000) != 0)
    {
      __int8 v25 = a2[10].i8[0];
      char v26 = Value[15].i8[0] ^ v25;
      if ((v26 & 7) == 0)
      {
        uint64_t v52 = v25 & 7;
        if (v52)
        {
          int v53 = Value + 6;
          uint64_t v54 = a2 + 1;
          while (1)
          {
            __int32 v56 = v54->i32[0];
            ++v54;
            int v55 = v56;
            __int32 v57 = v53->i32[0];
            ++v53;
            if (((v57 ^ v55) & 0x1700FFFF) != 0) {
              break;
            }
            if (!--v52) {
              goto LABEL_49;
            }
          }
        }
        else
        {
LABEL_49:
          if ((v26 & 0x10) == 0
            && ((Value[14].i32[0] ^ a2[9].i32[0]) & 0x1700FFFF) == 0
            && _fboHasSpecifiedOutputs(a1, (uint64_t)Value, a3, a4, a5)
            && (*(unsigned char *)(ValueAtIndex + 128) & 2) == 0)
          {
            goto LABEL_36;
          }
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 80))
  {
LABEL_9:
    uint64_t v60 = (const void *)(((32 * (a2[1].i8[3] & 1)) | a2[1].i8[1] | ((a2[9].i8[3] & 1) << 6)) | (((int)COERCE_FLOAT(*a2) & 0xFFFFF) << 10) | ((int)COERCE_FLOAT(HIDWORD(*(unint64_t *)a2)) << 30));
    CFArrayRef v27 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v60);
    if (v27)
    {
      CFArrayRef v28 = v27;
      uint64_t v59 = a7;
      CFIndex Count = CFArrayGetCount(v27);
      if (Count >= 1)
      {
        CFIndex v30 = Count;
        CFIndex v31 = 0;
        uint64_t v58 = key;
        do
        {
          ValueAtuint64_t Index = (uint64_t)CFArrayGetValueAtIndex(v28, v31);
          if (!CFDictionaryContainsValue(*(CFDictionaryRef *)(a1 + 72), (const void *)ValueAtIndex)
            && _fboHasSpecifiedOutputs(a1, ValueAtIndex, a3, a4, a5))
          {
            uint32x2_t v32 = (uint32x2_t)vceq_f32(*(float32x2_t *)(ValueAtIndex + 40), *a2);
            if ((vpmin_u32(v32, v32).u32[0] & 0x80000000) != 0)
            {
              char v33 = *(unsigned char *)(ValueAtIndex + 120);
              char v34 = a2[10].i8[0] ^ v33;
              if ((v34 & 7) == 0)
              {
                uint64_t v35 = v33 & 7;
                if (v35)
                {
                  unint64_t v36 = (int *)(ValueAtIndex + 48);
                  uint64_t v37 = a2 + 1;
                  while (1)
                  {
                    int v39 = *v36;
                    v36 += 2;
                    int v38 = v39;
                    __int32 v40 = v37->i32[0];
                    ++v37;
                    if (((v40 ^ v38) & 0x1700FFFF) != 0) {
                      break;
                    }
                    if (!--v35) {
                      goto LABEL_22;
                    }
                  }
                }
                else
                {
LABEL_22:
                  if ((v34 & 0x10) == 0
                    && ((a2[9].i32[0] ^ *(_DWORD *)(ValueAtIndex + 112)) & 0x1700FFFF) == 0
                    && (*(unsigned char *)(ValueAtIndex + 128) & 1) == 0)
                  {
                    unsigned __int8 v41 = 0;
                    while (1)
                    {
                      RenderTarget = C3DFramebufferGetRenderTarget(ValueAtIndex, (char)v41);
                      if (RenderTarget)
                      {
                        if (RenderTarget[19]) {
                          break;
                        }
                      }
                      unsigned int v43 = v41++;
                      if (v43 > 4)
                      {
                        key = v58;
                        a7 = v59;
                        if (ValueAtIndex) {
                          goto LABEL_36;
                        }
                        goto LABEL_32;
                      }
                    }
                  }
                }
              }
            }
          }
          ++v31;
        }
        while (v31 != v30);
        key = v58;
      }
      a7 = v59;
    }
LABEL_32:
    long long v44 = v60;
  }
  else
  {
    long long v44 = 0;
  }
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a7);
  *(unsigned char *)(a1 + 81) = 1;
  ValueAtuint64_t Index = C3DFramebufferCreate();
  long long v46 = *(_OWORD *)a2[2].f32;
  *(_OWORD *)(ValueAtIndex + 40) = *(_OWORD *)a2->f32;
  *(_OWORD *)(ValueAtIndex + 56) = v46;
  long long v48 = *(_OWORD *)a2[6].f32;
  long long v47 = *(_OWORD *)a2[8].f32;
  float32x2_t v49 = a2[10];
  *(_OWORD *)(ValueAtIndex + 72) = *(_OWORD *)a2[4].f32;
  *(float32x2_t *)(ValueAtIndex + 120) = v49;
  *(_OWORD *)(ValueAtIndex + 104) = v47;
  *(_OWORD *)(ValueAtIndex + 88) = v48;
  _addRenderTargetIfNeeded(a1, 1, 0, *(void *)&a2[1], ValueAtIndex, RendererContextGL, a3, a4, a5);
  _addRenderTargetIfNeeded(a1, 0, 4, *(void *)&a2[9], ValueAtIndex, RendererContextGL, a3, a4, a5);
  C3DRendererContextSetupFramebuffer(RendererContextGL, ValueAtIndex);
  CFArrayRef Mutable = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v44);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 24), v44, Mutable);
    CFRelease(Mutable);
  }
  CFArrayAppendValue((CFMutableArrayRef)Mutable, (const void *)ValueAtIndex);
  CFRelease((CFTypeRef)ValueAtIndex);
LABEL_36:
  context[0] = MEMORY[0x263EF8330];
  context[1] = 0x40000000;
  context[2] = __C3DFramebufferRegistryPrepareFramebufferWithDescription_block_invoke;
  context[3] = &__block_descriptor_tmp_4_2;
  context[4] = a1;
  C3DFramebufferApplyToRenderTargets(ValueAtIndex, context);
  if (key && !*(unsigned char *)(a1 + 80)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, (const void *)ValueAtIndex);
  }
  *(_DWORD *)(ValueAtIndex + 132) = *(_DWORD *)(a1 + 64);
  CFTypeRef result = *(CFTypeRef *)(a1 + 56);
  if (result != (CFTypeRef)ValueAtIndex)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 56) = 0;
    }
    CFTypeRef result = CFRetain((CFTypeRef)ValueAtIndex);
    *(void *)(a1 + 56) = result;
  }
  return result;
}

BOOL _fboHasSpecifiedOutputs(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  v25[3] = *MEMORY[0x263EF8340];
  memset(v25, 0, 24);
  if (*(unsigned char *)(a1 + 80) && CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 32)) < a4)
  {
    return 0;
  }
  else if (a4 < 1)
  {
    return 1;
  }
  else
  {
    BOOL v9 = 0;
    uint64_t v10 = 0;
    float v11 = (int *)(a3 + 16);
    unint64_t v12 = (int *)(a3 + 16);
    do
    {
      int v14 = *v12;
      v12 += 16;
      int v13 = v14;
      if (!a5 || v13 != 5)
      {
        uint64_t v15 = v13;
        int v16 = *((_DWORD *)v25 + v13);
        SlotForOutputBufferchar Type = C3DRenderBufferGetSlotForOutputBufferType(v13, v16);
        RenderTarget = C3DFramebufferGetRenderTarget(a2, SlotForOutputBufferType);
        if (!RenderTarget) {
          break;
        }
        *((_DWORD *)v25 + v15) = v16 + 1;
        Systeuint64_t m = C3DParticleSystemInstanceGetSystem((uint64_t)RenderTarget);
        if (System)
        {
          uint64_t v20 = (const void *)System;
          uint64_t v21 = (__CFString *)*((void *)v11 - 1);
          UniqueIdentifierWithuint64_t Name = _createUniqueIdentifierWithName(a1, v21);
          if (!v21 || UniqueIdentifierWithName != v20) {
            break;
          }
        }
      }
      BOOL v9 = ++v10 >= a4;
      float v11 = v12;
    }
    while (a4 != v10);
  }
  return v9;
}

void _addRenderTargetIfNeeded(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10 = a4;
  if (!(_BYTE)a4) {
    return;
  }
  if (a8 < 1)
  {
LABEL_6:
    uint64_t v17 = 0;
    if (a9) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v15 = (_DWORD *)(a7 + 16);
    uint64_t v16 = a8;
    while (*v15 != a2)
    {
      v15 += 16;
      if (!--v16) {
        goto LABEL_6;
      }
    }
    uint64_t v17 = (__CFString *)*((void *)v15 - 1);
    if (a9) {
      goto LABEL_17;
    }
  }
  if (!v17)
  {
    if (a4 - 46 < 0xFFFFFFFD || a8 < 1)
    {
LABEL_15:
      C3DFramebufferGetSize(a5);
LABEL_21:
      RenderTargetWithDescriptioint n = (float32x2_t *)C3DRendererContextCreateRenderTargetWithDescription(a6, a4, a5);
      if (!RenderTargetWithDescription)
      {
        uint32x2_t v24 = scn_default_log();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          _addRenderTargetIfNeeded_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
        }
      }
      uint32x2_t v32 = (const void *)C3DSceneSourcePerformConsistencyCheck(*(void *)&RenderTargetWithDescription[2]);
      CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v32);
      if (!Value)
      {
        CFNumberRef Value = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), v32, Value);
        CFRelease(Value);
      }
      CFArrayAppendValue((CFMutableArrayRef)Value, RenderTargetWithDescription);
      CFRelease(RenderTargetWithDescription);
      goto LABEL_27;
    }
    uint64_t v18 = (_DWORD *)(a7 + 16);
    while (*v18 != 5)
    {
      v18 += 16;
      if (!--a8) {
        goto LABEL_15;
      }
    }
    uint64_t v17 = (__CFString *)*((void *)v18 - 1);
  }
LABEL_17:
  double Size = C3DFramebufferGetSize(a5);
  if (!v17) {
    goto LABEL_21;
  }
  float32x2_t v20 = *(float32x2_t *)&Size;
  RenderTargetWithuint64_t Name = (float32x2_t *)C3DFramebufferRegistryGetRenderTargetWithName(a1, v17);
  if (!RenderTargetWithName) {
    goto LABEL_21;
  }
  RenderTargetWithDescriptioint n = RenderTargetWithName;
  if (((C3DRenderTargetGetDescription((uint64_t)RenderTargetWithName) ^ a4) & 0x1700FFFF) != 0) {
    goto LABEL_21;
  }
  uint32x2_t v23 = (uint32x2_t)vceq_f32(v20, RenderTargetWithDescription[5]);
  if ((vpmin_u32(v23, v23).u32[0] & 0x80000000) == 0) {
    goto LABEL_21;
  }
LABEL_27:
  C3DFramebufferAddRenderTarget(a5, RenderTargetWithDescription, a3);
  if (a3 == 4 && (a9 & 1) == 0 && (v10 - 46) >= 0xFFFFFFFD) {
    C3DFramebufferAddRenderTarget(a5, RenderTargetWithDescription, 5);
  }
}

uint64_t __C3DFramebufferRegistryPrepareFramebufferWithDescription_block_invoke(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 80) = *(_DWORD *)(*(void *)(result + 32) + 64);
  unsigned int v2 = *(_DWORD *)(a2 + 76);
  if (v2 <= 0x7FFFFFFD) {
    *(_DWORD *)(a2 + 76) = v2 + 1;
  }
  return result;
}

void C3DFramebufferRegistryTrackFBO(uint64_t a1, void *value, void *key)
{
  if (key) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, value);
  }
}

uint64_t C3DFramebufferRegistryFinalizeAndGetFramebuffer(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (!*(void *)(a1 + 56))
  {
    int v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryFinalizeAndGetFramebuffer_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  return *(void *)(a1 + 56);
}

void C3DFramebufferRegistryReplaceTextureWithNameByTexture(uint64_t a1, int a2, __CFString *a3)
{
  UniqueIdentifierWithuint64_t Name = _createUniqueIdentifierWithName(a1, a3);
  uint64_t v6 = *(void *)(a1 + 56);
  SlotForOutputBufferchar Type = C3DRenderBufferGetSlotForOutputBufferType(a2, 0);
  RenderTarget = C3DFramebufferGetRenderTarget(v6, SlotForOutputBufferType);
  if (!RenderTarget)
  {
    uint64_t v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
      _addRenderTargetIfNeeded_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), UniqueIdentifierWithName);
  if (Value) {
    BOOL v18 = Value == RenderTarget;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v19 = (uint64_t)Value;
    RenderTarget[19] = Value[19];
    Value[19] = 0;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), UniqueIdentifierWithName);
    C3DRenderTargetSetNameIndex(v19, 0);
  }
  C3DRenderTargetSetNameIndex((uint64_t)RenderTarget, (uint64_t)UniqueIdentifierWithName);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), UniqueIdentifierWithName, RenderTarget);
}

const void *_createUniqueIdentifierWithName(uint64_t a1, __CFString *a2)
{
  if (a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = @"(null)";
  }
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v3);
  if (!Value)
  {
    uint64_t v5 = *(__CFDictionary **)(a1 + 32);
    CFNumberRef Value = (const void *)(*(void *)(a1 + 40) + 1);
    *(void *)(a1 + 40) = Value;
    CFDictionarySetValue(v5, v3, Value);
  }
  return Value;
}

void C3DFramebufferRegistryRetainTextureWithName(uint64_t a1, int a2, __CFString *a3, int a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (!*(void *)(a1 + 56) && (uint64_t v16 = scn_default_log(), os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)))
  {
    C3DFramebufferRegistryFinalizeAndGetFramebuffer_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    if (a3) {
      goto LABEL_9;
    }
  }
  else if (a3)
  {
    goto LABEL_9;
  }
  uint32x2_t v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
    C3DFramebufferRegistryRetainTextureWithName_cold_3(v24, v25, v26, v27, v28, v29, v30, v31);
  }
LABEL_9:
  if (a4 <= 0)
  {
    uint32x2_t v32 = scn_default_log();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryRetainTextureWithName_cold_2(v32, v33, v34, v35, v36, v37, v38, v39);
    }
  }
  UniqueIdentifierWithuint64_t Name = _createUniqueIdentifierWithName(a1, a3);
  uint64_t v41 = *(void *)(a1 + 56);
  SlotForOutputBufferchar Type = C3DRenderBufferGetSlotForOutputBufferType(a2, 0);
  RenderTarget = C3DFramebufferGetRenderTarget(v41, SlotForOutputBufferType);
  if (!RenderTarget)
  {
    long long v44 = scn_default_log();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
      _addRenderTargetIfNeeded_cold_1(v44, v45, v46, v47, v48, v49, v50, v51);
    }
  }
  C3DRenderTargetSetNameIndex((uint64_t)RenderTarget, (uint64_t)UniqueIdentifierWithName);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), UniqueIdentifierWithName, RenderTarget);
  int v52 = 2147483646;
  if (a4 == 2147483646
    || (int v53 = RenderTarget[19], v53 == 2147483646)
    || (int v52 = 0x7FFFFFFF, a4 == 0x7FFFFFFF)
    || v53 == 0x7FFFFFFF)
  {
    RenderTarget[19] = v52;
  }
  else
  {
    RenderTarget[19] = v53 + a4;
  }
}

const void *C3DFramebufferRegistryGetRenderTargetWithName(uint64_t a1, __CFString *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  UniqueIdentifierWithuint64_t Name = _createUniqueIdentifierWithName(a1, a2);
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), UniqueIdentifierWithName);
}

const void *C3DFramebufferRegistryGetTextureWithName(uint64_t a1, __CFString *a2)
{
  CFTypeRef result = C3DFramebufferRegistryGetRenderTargetWithName(a1, a2);
  if (result)
  {
    return (const void *)C3DRenderTargetGetTexture((uint64_t)result);
  }
  return result;
}

void C3DFramebufferRegistryReleaseRenderTarget(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 76);
  if (v2 <= 0x7FFFFFFD)
  {
    unsigned int v3 = v2 - 1;
    *(_DWORD *)(a2 + 76) = v3;
    if (!v3) {
      _removeReference(a1, a2);
    }
  }
}

void _removeReference(uint64_t a1, uint64_t a2)
{
  Systeuint64_t m = (const void *)C3DParticleSystemInstanceGetSystem(a2);
  if (!System)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      _removeReference_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  C3DRenderTargetSetNameIndex(a2, 0);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), System);
}

void C3DFramebufferRegistryReleaseTextureWithName(uint64_t a1, __CFString *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  RenderTargetWithuint64_t Name = C3DFramebufferRegistryGetRenderTargetWithName(a1, a2);
  if (RenderTargetWithName)
  {
    unsigned int v13 = RenderTargetWithName[19];
    if (v13 <= 0x7FFFFFFD)
    {
      unsigned int v14 = v13 - 1;
      RenderTargetWithName[19] = v14;
      if (!v14) {
        _removeReference(a1, (uint64_t)RenderTargetWithName);
      }
    }
  }
}

void C3DFramebufferRegistryReleaseFramebuffer(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryReleaseFramebuffer_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  context[0] = MEMORY[0x263EF8330];
  context[1] = 0x40000000;
  context[2] = __C3DFramebufferRegistryReleaseFramebuffer_block_invoke;
  context[3] = &__block_descriptor_tmp_10_0;
  context[4] = a1;
  C3DFramebufferApplyToRenderTargets(a2, context);
}

void __C3DFramebufferRegistryReleaseFramebuffer_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 76);
  if ((v2 - 1) <= 0x7FFFFFFC) {
    *(_DWORD *)(a2 + 76) = --v2;
  }
  if (!v2)
  {
    if (*(void *)(a2 + 48)) {
      _removeReference(*(void *)(a1 + 32), a2);
    }
  }
}

void _releaseGlobalRenderTargets(int a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    unint64_t v6 = Count + 1;
    do
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v6 - 2);
      if (ValueAtIndex[19] == 2147483646)
      {
        ValueAtIndex[19] = 0;
        _removeReference(a3, (uint64_t)ValueAtIndex);
      }
      --v6;
    }
    while (v6 > 1);
  }
}

void C3DFramebufferRegistryFinalizeFrame(CFDictionaryRef *context)
{
  if (!context)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryApplyFunction(context[2], (CFDictionaryApplierFunction)_releaseGlobalRenderTargets, context);
}

void C3DFramebufferRegistryBumpTimestamp(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  ++*(_DWORD *)(a1 + 64);
  if (*(unsigned __int8 *)(a1 + 80) != gC3DFBORegistryEnableRecycling)
  {
    *(unsigned char *)(a1 + 80) = gC3DFBORegistryEnableRecycling;
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 72));
  }
}

void C3DFramebufferRegistryViewportDidResize(uint64_t a1, uint64_t a2)
{
  context[4] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  char v12 = 0;
  context[0] = C3DEngineContextGetRendererContextGL(a2);
  context[1] = 0;
  context[2] = *(unsigned int *)(a1 + 64);
  context[3] = &v12;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 24), (CFDictionaryApplierFunction)_purgeFBOs, context);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)_purgeRenderTargets, context);
}

void _purgeFBOs(int a1, CFArrayRef theArray, uint64_t a3)
{
  uint64_t v5 = *(void *)a3;
  uint64_t v6 = *(void *)(a3 + 8);
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v8 = Count + 1;
    while (1)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v8 - 2);
      if (v6) {
        break;
      }
      if ((ValueAtIndex[120] & 8) != 0) {
        goto LABEL_10;
      }
LABEL_12:
      if ((unint64_t)--v8 <= 1) {
        return;
      }
    }
    if (v6 == 1)
    {
      if ((*((_DWORD *)ValueAtIndex + 33) + 10) >= *(_DWORD *)(a3 + 16)) {
        goto LABEL_12;
      }
LABEL_10:
      **(unsigned char **)(a3 + 24) = 1;
    }
    else if (v6 != 2)
    {
      goto LABEL_12;
    }
    C3DRendererContextDeleteFramebuffer(v5, (uint64_t)ValueAtIndex, 0);
    CFArrayRemoveValueAtIndex(theArray, v8 - 2);
    goto LABEL_12;
  }
}

void _purgeRenderTargets(int a1, CFArrayRef theArray, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a3 + 16);
  uint64_t v6 = *(void *)a3;
  uint64_t v7 = *(void *)(a3 + 8);
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v9 = Count + 1;
    while (1)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v9 - 2);
      if (!v7) {
        break;
      }
      if (v7 == 1)
      {
        if (ValueAtIndex[18] || ValueAtIndex[19] || ValueAtIndex[20] + 10 >= v5) {
          goto LABEL_14;
        }
        goto LABEL_16;
      }
      if (v7 == 2) {
        goto LABEL_6;
      }
LABEL_14:
      if ((unint64_t)--v9 <= 1) {
        return;
      }
    }
    if (ValueAtIndex[18] || ValueAtIndex[19] || (*((unsigned char *)ValueAtIndex + 19) & 4) == 0) {
      goto LABEL_14;
    }
LABEL_16:
    **(unsigned char **)(a3 + 24) = 1;
LABEL_6:
    C3DRendererContextDeleteRenderTarget(v6, (uint64_t)ValueAtIndex);
    CFArrayRemoveValueAtIndex(theArray, v9 - 2);
    goto LABEL_14;
  }
}

uint64_t C3DFramebufferRegistryPurge(uint64_t a1, uint64_t a2)
{
  context[4] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unsigned __int8 v13 = 0;
  *(unsigned char *)(a1 + 81) = 0;
  context[0] = C3DEngineContextGetRendererContextGL(a2);
  context[1] = 1;
  context[2] = *(unsigned int *)(a1 + 64);
  context[3] = &v13;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 24), (CFDictionaryApplierFunction)_purgeFBOs, context);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)_purgeRenderTargets, context);
  return v13;
}

void C3DFramebufferRegistryCleanup(uint64_t a1, uint64_t a2)
{
  context[4] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferRegistryPrepareFramebufferWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  context[0] = C3DEngineContextGetRendererContextGL(a2);
  context[1] = 2;
  context[2] = 0;
  context[3] = 0;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 24), (CFDictionaryApplierFunction)_purgeFBOs, context);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)_purgeRenderTargets, context);
}

void C3D::BloomUpSamplePass::BloomUpSamplePass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *uint64_t v5 = &unk_26BF6D9E0;
  v5[15] = a4;
}

const char *C3D::BloomUpSamplePass::name(C3D::BloomUpSamplePass *this)
{
  return "BloomUpSamplePass";
}

double C3D::BloomUpSamplePass::setup(C3D::BloomUpSamplePass *this)
{
  C3D::Pass::setInputCount(this, 1u);
  C3D::Pass::setOutputCount(this, 2u);
  uint64_t v2 = (*(uint64_t (**)(C3D::BloomUpSamplePass *))(*(void *)this + 88))(this);
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex((C3D::BloomUpSamplePass *)((char *)this + 32), 0);
  *(void *)(v3 + 8) = "Bloom";
  *(_WORD *)(v3 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 15), 1.0);
  *(_WORD *)(v3 + 18) = (int)fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 15), 1.0);
  *(unsigned char *)(v3 + 30) = *(_DWORD *)(*((void *)this + 15) + 24);
  *(unsigned char *)(v3 + 26) = 3;
  *(_WORD *)(v3 + 28) = 115;
  uint64_t v4 = C3D::PassDescriptor::outputAtIndex((C3D::BloomUpSamplePass *)((char *)this + 32), 0);
  *(void *)(v4 + 8) = "Tmp";
  *(_WORD *)(v4 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 15), 1.0);
  *(_WORD *)(v4 + 18) = (int)fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 15), 1.0);
  *(unsigned char *)(v4 + 30) = *(_DWORD *)(*((void *)this + 15) + 24);
  *(unsigned char *)(v4 + 26) = 3;
  *(_WORD *)(v4 + 28) = 115;
  *(_WORD *)(v4 + 66) |= 8u;
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::BloomUpSamplePass *)((char *)this + 32), 1u);
  *(void *)(v5 + 8) = "Bloom";
  *(_WORD *)(v5 + 16) = (int)fmax(*(float *)(v2 + 8) * 0.5 / **((float **)this + 15), 1.0);
  double result = fmax(*(float *)(v2 + 12) * 0.5 / **((float **)this + 15), 1.0);
  *(_WORD *)(v5 + 18) = (int)result;
  *(_WORD *)(v5 + 28) = 115;
  *(unsigned char *)(v5 + 26) = 3;
  return result;
}

uint64_t C3D::BloomUpSamplePass::compile(C3D::BloomUpSamplePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = *(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128);
  uint64_t v4 = (*(uint64_t (**)(C3D::BloomUpSamplePass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(v3, v4);
  *((void *)this + 14) = result;
  if (!result) {
    operator new();
  }
  return result;
}

void C3D::BloomUpSamplePass::execute(C3D::Pass *a1, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  float v20 = *(float *)(*((void *)a1 + 15) + 28);
  uint64_t v3 = *a2;
  uint64_t v4 = C3D::Pass::outputTextureAtIndex(a1, 1u);
  uint64_t v21 = C3D::Pass::inputTextureAtIndex(a1, 0);
  uint64_t v22 = C3D::Pass::outputTextureAtIndex(a1, 0);
  uint64_t v5 = (MTLTexture *)objc_msgSend(v21, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), objc_msgSend(v4, "textureType"), *(int *)(*((void *)a1 + 15) + 24) - 1, 1, 0, 1);
  uint64_t v6 = *(int *)(*((void *)a1 + 15) + 24) - 2;
  uint64_t v7 = (MTLTexture *)objc_msgSend(v21, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), objc_msgSend(v4, "textureType"), v6, 1, 0, 1);
  uint64_t v8 = (MTLTexture *)objc_msgSend(v22, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), objc_msgSend(v4, "textureType"), v6, 1, 0, 1);
  uint64_t v9 = v8;
  uint64_t v19 = a1;
  int v10 = *(_DWORD *)(*((void *)a1 + 15) + 24);
  unsigned int v11 = v10 - 3;
  if (v10 >= 3)
  {
    uint64_t v12 = (v10 - 2) + 1;
    int v13 = 1;
    do
    {
      if (v3->_textures[0] != v5)
      {
        v3->_textures[0] = v5;
        v3->_texturesToBind[0] |= 1uLL;
      }
      if (v3->_textures[1] != v7)
      {
        v3->_textures[1] = v7;
        v3->_texturesToBind[0] |= 2uLL;
      }
      if (v3->_textures[2] != v9)
      {
        v3->_textures[2] = v9;
        v3->_texturesToBind[0] |= 4uLL;
      }
      if (v12 == 2)
      {
        float v14 = 1.0 / pow(v20, (double)(*(_DWORD *)(*((void *)v19 + 15) + 24) - 4));
        float v20 = v14;
      }
      SCNMTLComputeCommandEncoder::setBytes(v3, &v20, 4uLL, 0);
      uint64_t v15 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)v19 + 14) + 16);
      uint64_t v16 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v15);
      SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v9, v16);
      v13 ^= 1u;

      uint64_t v7 = (MTLTexture *)objc_msgSend(v21, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), objc_msgSend(v4, "textureType"), v11, 1, 0, 1);
      uint64_t v8 = (MTLTexture *)objc_msgSend((&v21)[v13 & 1], "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v4, "pixelFormat"), objc_msgSend(v4, "textureType"), v11, 1, 0, 1);
      --v12;
      --v11;
      uint64_t v5 = v9;
      uint64_t v9 = v8;
    }
    while (v12 > 1);
  }

  if (v3->_textures[0] != v5)
  {
    v3->_textures[0] = v5;
    v3->_texturesToBind[0] |= 1uLL;
  }
  if (v3->_textures[1] != v7)
  {
    v3->_textures[1] = v7;
    v3->_texturesToBind[0] |= 2uLL;
  }
  if ((void *)v3->_textures[2] != v4)
  {
    v3->_textures[2] = (MTLTexture *)v4;
    v3->_texturesToBind[0] |= 4uLL;
  }
  float v20 = 1.0;
  SCNMTLComputeCommandEncoder::setBytes(v3, &v20, 4uLL, 0);
  uint64_t v17 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)v19 + 14) + 16);
  uint64_t v18 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v17);
  SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v4, v18);
}

void C3D::BloomUpSamplePassResource::~BloomUpSamplePassResource(C3D::BloomUpSamplePassResource *this)
{
  *(void *)this = &unk_26BF6E510;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E510;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

float __spreadingVariationf(unsigned int *a1, float32x4_t *a2, int a3, float32x4_t a4, int8x16_t a5, double a6, int8x16_t a7, float32x4_t a8)
{
  float32x4_t v10 = *a2;
  unsigned int v11 = 214013 * *a1 + 2531011;
  float v12 = (float)HIWORD(v11);
  if (a3)
  {
    float cosval = (float)((float)(v12 * -0.000015259) * (float)(1.0 - a4.f32[0])) + 1.0;
    float v13 = sqrtf(1.0 - (float)(cosval * cosval));
  }
  else
  {
    float32x4_t v22 = *a2;
    __float2 v14 = __sincosf_stret((float)(v12 * 0.000015259) * a4.f32[0]);
    float32x4_t v10 = v22;
    float cosval = v14.__cosval;
    LODWORD(v13) = *(void *)&v14;
  }
  a5.i32[0] = v10.i32[2];
  a7.i32[0] = 1.0;
  a4.f32[0] = v10.f32[1] / (float)(fabsf(v10.f32[2]) + 1.0);
  a8.f32[0] = -(float)(v10.f32[0] * a4.f32[0]);
  a4.f32[0] = vmuls_lane_f32(a4.f32[0], *(float32x2_t *)v10.f32, 1);
  v15.i64[0] = 0x8000000080000000;
  v15.i64[1] = 0x8000000080000000;
  float v16 = *(float *)vbslq_s8(v15, a7, a5).i32;
  a8.f32[1] = 1.0 - a4.f32[0];
  a8.i32[2] = vmuls_lane_f32(-v16, *(float32x2_t *)v10.f32, 1);
  a4.f32[0] = v10.f32[2] + (float)(v16 * a4.f32[0]);
  a4.f32[1] = v16 * a8.f32[0];
  a4.f32[2] = -v10.f32[0];
  float32x4_t v21 = a4;
  float32x4_t v23 = a8;
  unsigned int v17 = 214013 * v11 + 2531011;
  *a1 = v17;
  float v18 = (float)((float)((float)HIWORD(v17) * 0.000015259) + (float)((float)HIWORD(v17) * 0.000015259)) * 3.14159265;
  __float2 v19 = __sincosf_stret(v18);
  float result = v13 * v19.__sinval;
  *a2 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*a2, cosval), v21, v13 * v19.__cosval), v23, v13 * v19.__sinval);
  return result;
}

__n128 __SetupIntegration(uint64_t a1, _OWORD *a2, float32x4_t *a3, int32x4_t *a4, __n128 *a5)
{
  if (*(void *)(a1 + 1056) && C3DParticleSystemGetAffectedByGravity(*(void *)(a1 + 1040)))
  {
    DWORD2(v16) = 0;
    *(void *)&long long v16 = 0;
    C3DPhysicsWorldGetWorldGravity(*(void **)(a1 + 1056), &v16);
    long long v10 = v16;
    HIDWORD(v10) = 0;
    *a2 = v10;
  }
  unsigned int v11 = (const float *)(a1 + 1028);
  float32x4_t v12 = vld1q_dup_f32(v11);
  *a3 = v12;
  *(float *)v13.i32 = -C3DParticleSystemGetDampingFactor(*(void *)(a1 + 1040));
  int32x4_t v14 = vdupq_lane_s32(v13, 0);
  v14.i32[3] = 0;
  *a4 = v14;
  __n128 result = C3DParticleSystemGetAcceleration((__n128 *)*(void *)(a1 + 1040));
  result.n128_u32[3] = 0;
  *a5 = result;
  return result;
}

__n128 C3DParticleEulerIntegration_C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  float32x4_t v24 = 0u;
  float32x4_t v25 = 0u;
  float32x4_t v22 = 0u;
  float32x4_t v23 = 0u;
  __SetupIntegration(a1, &v25, &v24, (int32x4_t *)&v23, (__n128 *)&v22);
  if (a2 >= a3)
  {
    float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v16.i64[0] = 0x80000000800000;
    v16.i64[1] = 0x80000000800000;
  }
  else
  {
    float v6 = *(float *)(a1 + 1028);
    float32x4_t v7 = v24;
    float32x4_t v8 = vmulq_f32(v24, v25);
    float32x4_t v9 = v22;
    float32x4_t v10 = v23;
    unsigned int v11 = (float *)(*(void *)(a1 + 304) + 4 * a2);
    float32x4_t v12 = (float32x4_t *)(*(void *)(a1 + 264) + 16 * a2);
    int32x2_t v13 = (float32x4_t *)(*(void *)(a1 + 256) + 16 * a2);
    unint64_t v14 = a3 - (unint64_t)a2;
    float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v16.i64[0] = 0x80000000800000;
    v16.i64[1] = 0x80000000800000;
    do
    {
      float v17 = *v11++;
      float32x4_t v18 = vmlaq_f32(*v13, v7, *v12);
      *v13++ = v18;
      float32x4_t v15 = vminq_f32(v15, v18);
      float32x4_t v16 = vmaxq_f32(v16, v18);
      float32x4_t *v12 = vaddq_f32(*v12, vmlaq_n_f32(v8, vmlaq_f32(v9, *v12, v10), v6 * v17));
      ++v12;
      --v14;
    }
    while (v14);
  }
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  __n128 result = (__n128)vmulq_f32(vaddq_f32(v15, v16), v19);
  float32x4_t v20 = vmulq_f32(vsubq_f32(v16, v15), v19);
  result.n128_u32[3] = 1.0;
  v20.i32[3] = 0;
  *(__n128 *)(a1 + 1088) = result;
  *(float32x4_t *)(a1 + 1104) = v20;
  return result;
}

__n128 C3DParticleEulerIntegration_NoMassVariation(uint64_t a1, unsigned int a2, unsigned int a3)
{
  float32x4_t v24 = 0u;
  float32x4_t v25 = 0u;
  float32x4_t v22 = 0u;
  float32x4_t v23 = 0u;
  __SetupIntegration(a1, &v25, &v24, (int32x4_t *)&v23, (__n128 *)&v22);
  uint64_t v6 = *(void *)(a1 + 256);
  uint64_t v7 = *(void *)(a1 + 264);
  *(float *)v8.i32 = C3DParticleSystemGetParticleMass(*(void *)(a1 + 1040));
  if (a2 >= a3)
  {
    float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v17.i64[0] = 0x80000000800000;
    v17.i64[1] = 0x80000000800000;
  }
  else
  {
    float32x4_t v9 = v24;
    float32x4_t v10 = vdivq_f32(v24, (float32x4_t)vdupq_lane_s32(v8, 0));
    float32x4_t v11 = v23;
    float32x4_t v12 = vmlaq_n_f32(v22, v25, *(float *)v8.i32);
    int32x2_t v13 = (float32x4_t *)(v7 + 16 * a2);
    unint64_t v14 = (float32x4_t *)(v6 + 16 * a2);
    unint64_t v15 = a3 - (unint64_t)a2;
    float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v17.i64[0] = 0x80000000800000;
    v17.i64[1] = 0x80000000800000;
    do
    {
      float32x4_t v18 = vmlaq_f32(*v14, v9, *v13);
      float32x4_t v16 = vminq_f32(v16, v18);
      float32x4_t v17 = vmaxq_f32(v17, v18);
      *int32x2_t v13 = vmlaq_f32(*v13, v10, vmlaq_f32(v12, *v13, v11));
      ++v13;
      *v14++ = v18;
      --v15;
    }
    while (v15);
  }
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  float32x4_t v20 = vmulq_f32(vaddq_f32(v16, v17), v19);
  __n128 result = (__n128)vmulq_f32(vsubq_f32(v17, v16), v19);
  v20.i32[3] = 1.0;
  result.n128_u32[3] = 0;
  *(float32x4_t *)(a1 + 1088) = v20;
  *(__n128 *)(a1 + 1104) = result;
  return result;
}

__n128 C3DParticleEulerIntegration_NoMassVariationNoDrag(uint64_t a1, unsigned int a2, unsigned int a3)
{
  float32x4_t v29 = 0u;
  float32x4_t v30 = 0u;
  float32x4_t v27 = 0u;
  __SetupIntegration(a1, &v30, &v29, &v28, (__n128 *)&v27);
  uint64_t v6 = *(void *)(a1 + 256);
  uint64_t v7 = *(void *)(a1 + 264);
  *(float *)v8.i32 = C3DParticleSystemGetParticleMass(*(void *)(a1 + 1040));
  float32x4_t v9 = v29;
  float32x4_t v10 = vmlaq_n_f32(v27, v30, *(float *)v8.i32);
  float32x4_t v11 = vmulq_f32(v10, v10);
  if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]) > 0.0)
  {
    if (a2 < a3)
    {
      float32x4_t v12 = vmulq_f32(vdivq_f32(v29, (float32x4_t)vdupq_lane_s32(v8, 0)), v10);
      int32x2_t v13 = (float32x4_t *)(v7 + 16 * a2);
      unint64_t v14 = (float32x4_t *)(v6 + 16 * a2);
      unint64_t v15 = a3 - (unint64_t)a2;
      float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      v17.i64[0] = 0x80000000800000;
      v17.i64[1] = 0x80000000800000;
      do
      {
        float32x4_t v18 = vmlaq_f32(*v14, v9, *v13);
        float32x4_t v16 = vminq_f32(v16, v18);
        float32x4_t v17 = vmaxq_f32(v17, v18);
        *int32x2_t v13 = vaddq_f32(v12, *v13);
        ++v13;
        *v14++ = v18;
        --v15;
      }
      while (v15);
      goto LABEL_11;
    }
LABEL_10:
    float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v17.i64[0] = 0x80000000800000;
    v17.i64[1] = 0x80000000800000;
    goto LABEL_11;
  }
  if (a2 >= a3) {
    goto LABEL_10;
  }
  float32x4_t v19 = (float32x4_t *)(v6 + 16 * a2);
  float32x4_t v20 = (float32x4_t *)(v7 + 16 * a2);
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
  v17.i64[0] = 0x80000000800000;
  v17.i64[1] = 0x80000000800000;
  unint64_t v21 = a3 - (unint64_t)a2;
  do
  {
    float32x4_t v22 = *v20++;
    float32x4_t v23 = vmlaq_f32(*v19, v9, v22);
    float32x4_t v16 = vminq_f32(v16, v23);
    float32x4_t v17 = vmaxq_f32(v17, v23);
    *v19++ = v23;
    --v21;
  }
  while (v21);
LABEL_11:
  v24.i64[0] = 0x3F0000003F000000;
  v24.i64[1] = 0x3F0000003F000000;
  float32x4_t v25 = vmulq_f32(vaddq_f32(v16, v17), v24);
  __n128 result = (__n128)vmulq_f32(vsubq_f32(v17, v16), v24);
  v25.i32[3] = 1.0;
  result.n128_u32[3] = 0;
  *(float32x4_t *)(a1 + 1088) = v25;
  *(__n128 *)(a1 + 1104) = result;
  return result;
}

double __SpawnSubSystem(uint64_t a1, const void *a2, __n128 a3, float32x4_t a4)
{
  uint32x4_t v6 = (uint32x4_t)vceqzq_f32(a4);
  v6.i32[3] = v6.i32[2];
  if ((vminvq_u32(v6) & 0x80000000) != 0)
  {
    float32x4_t v10 = (float32x4_t)xmmword_20B5CB520;
  }
  else
  {
    int32x4_t v7 = (int32x4_t)vmulq_f32(a4, a4);
    v7.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1))).u32[0];
    float32x2_t v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
    float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
    float32x4_t v10 = vmulq_n_f32(a4, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v9, v9))).f32[0]);
  }
  long long v16 = (__int128)v10;
  DWORD2(v20) = 0;
  *(void *)&long long v20 = 0;
  DWORD2(v19) = 0;
  *(void *)&long long v19 = 0;
  C3DVectorGenerateOrthogonalBasis((float32x4_t *)&v20, (int8x16_t *)&v19, v10);
  long long v11 = v19;
  long long v12 = v20;
  HIDWORD(v11) = 0;
  HIDWORD(v12) = 0;
  long long v13 = v16;
  HIDWORD(v13) = 0;
  v18[0] = v11;
  v18[1] = v12;
  long long v14 = (__int128)a3;
  HIDWORD(v14) = 1.0;
  v18[2] = v13;
  v18[3] = v14;
  return C3DParticleManagerAddSystem(a1, 0, a2, v18);
}

void C3DParticlePlaneCollider_C(uint64_t a1, int a2, unsigned int a3, float32x4_t *a4)
{
  LODWORD(v6) = a2;
  float v51 = *(float *)(a1 + 1028);
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a4);
  float Width = C3DParametricGeometryGetWidth(Geometry);
  float Height = C3DParametricGeometryGetHeight(Geometry);
  WorldMatrix = C3DNodeGetWorldMatrix(a4);
  simd_float4 v12 = (simd_float4)WorldMatrix[3];
  simd_float4 v14 = *(simd_float4 *)WorldMatrix;
  simd_float4 v13 = (simd_float4)WorldMatrix[1];
  v58.columns[2] = (simd_float4)WorldMatrix[2];
  v58.columns[3] = v12;
  v58.columns[0] = v14;
  v58.columns[1] = v13;
  if (*(unsigned char *)(a1 + 1136))
  {
    memset(&v57, 0, sizeof(v57));
    C3DMatrix4x4Invert(*(simd_float4x4 **)(a1 + 1144), &v57);
    C3DMatrix4x4Mult((uint64_t)&v58, (float32x4_t *)&v57, &v58);
  }
  simd_float4x4 v57 = v58;
  *(double *)v15.i64 = C3DVector3MultMatrix4x4((float32x4_t *)&v57, (float32x4_t)0);
  float32x4_t v53 = v15;
  simd_float4x4 v57 = v58;
  *(double *)v16.i64 = C3DVector3Rotate((float32x2_t *)&v57, (float32x4_t)xmmword_20B5CB520);
  float32x4_t v55 = v16;
  simd_float4x4 v57 = v58;
  *(double *)v17.i64 = C3DVector3Rotate((float32x2_t *)&v57, (float32x4_t)xmmword_20B5CB820);
  float32x4_t v52 = v17;
  simd_float4x4 v57 = v58;
  *(double *)v18.i64 = C3DVector3Rotate((float32x2_t *)&v57, (float32x4_t)xmmword_20B5CB7D0);
  BOOL v19 = a3 >= v6;
  int v20 = a3 - v6;
  float v21 = v51;
  if (v20 != 0 && v19)
  {
    float32x4_t v22 = v18;
    float v23 = Width * 0.5;
    float32x4_t v24 = v53;
    float32x4_t v25 = v55;
    float32x4_t v26 = vmulq_f32(v53, v55);
    float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)));
    v25.f32[3] = -v27.f32[0];
    v24.i32[3] = 0;
    float32x4_t v54 = v24;
    float32x4_t v56 = v25;
    float v28 = Height * 0.5;
    uint64_t v29 = *(void *)(a1 + 256);
    uint64_t v30 = *(void *)(a1 + 264);
    uint64_t v6 = v6;
    do
    {
      float32x4_t v31 = vmulq_n_f32(*(float32x4_t *)(v30 + 16 * v6), v21);
      float32x4_t v32 = vmulq_f32(v31, v31);
      float v33 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0];
      if (v33 > 0.0)
      {
        float v34 = sqrtf(v33);
        float32x4_t v35 = vmulq_n_f32(v31, 1.0 / v34);
        float32x4_t v36 = vmulq_f32(v56, v35);
        float v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
        if (v37 != 0.0)
        {
          float32x4_t v38 = vsubq_f32(*(float32x4_t *)(v29 + 16 * v6), v31);
          float32x4_t v39 = vmulq_f32(v56, v38);
          float v40 = (float)-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]- v27.f32[0])/ v37;
          BOOL v41 = v40 >= -0.00000011921 && v40 <= v34;
          if (v41)
          {
            float32x4_t v42 = vmlaq_n_f32(v38, v35, v40);
            float32x4_t v43 = vsubq_f32(v42, v54);
            float32x4_t v44 = vmulq_f32(v52, v43);
            BOOL v41 = fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0]) <= v23;
            float32x4_t v45 = vmulq_f32(v22, v43);
            float32x4_t v46 = vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1));
            float v47 = fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), v46).f32[0]);
            if (v41 && v47 <= v28)
            {
              float32x4_t v49 = v27;
              float32x4_t v50 = v22;
              __HandleCollision(a1, v6, v42, v56, *(double *)v46.i64);
              float32x4_t v27 = v49;
              float32x4_t v22 = v50;
              float v21 = v51;
            }
          }
        }
      }
      ++v6;
      --v20;
    }
    while (v20);
  }
}

void __HandleCollision(uint64_t a1, unsigned int a2, float32x4_t a3, float32x4_t a4, double a5)
{
  if (*(unsigned char *)(a1 + 1168))
  {
    *(_DWORD *)(*(void *)(a1 + 272) + 4 * a2) = 0;
  }
  else
  {
    float v7 = *(float *)(a1 + 1032);
    uint64_t v9 = *(void *)(a1 + 336);
    uint64_t v8 = *(void *)(a1 + 344);
    if (v8) {
      float32x4_t v10 = (_DWORD *)(v8 + 4 * a2);
    }
    else {
      float32x4_t v10 = (_DWORD *)(a1 + 1160);
    }
    LODWORD(a5) = *v10;
    long long v11 = (float *)(v9 + 4 * a2);
    if (!v9) {
      long long v11 = (float *)(a1 + 1164);
    }
    simd_float4 v12 = (float32x4_t *)(*(void *)(a1 + 264) + 16 * a2);
    float32x4_t v13 = vmulq_n_f32(*v12, *(float *)(a1 + 1028));
    float32x4_t v14 = vmulq_f32(v13, a4);
    v14.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u64[0];
    *(float *)&a5 = *(float *)&a5 * v14.f32[0];
    float32x4_t v15 = vmlaq_n_f32(vmulq_f32(vnegq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0)), a4), vmlsq_lane_f32(v13, a4, *(float32x2_t *)v14.f32, 0), *v11);
    float32x4_t v16 = vmlaq_f32(vaddq_f32(v15, a3), (float32x4_t)vdupq_n_s32(0x3A83126Fu), a4);
    uint64_t v17 = *(void *)(a1 + 256) + 16 * a2;
    v16.i32[3] = *(_DWORD *)(v17 + 12);
    *(float32x4_t *)uint64_t v17 = v16;
    float32x4_t v18 = vmulq_n_f32(v15, v7);
    v18.i32[3] = v12->i32[3];
    float32x4_t *v12 = v18;
  }
  BOOL v19 = *(const void **)(a1 + 1176);
  if (v19)
  {
    float32x4_t v25 = a3;
    float32x4_t v26 = a4;
    __SpawnSubSystem(*(void *)(a1 + 1064), v19, (__n128)a3, a4);
    a3 = v25;
    a4 = v26;
  }
  int v20 = *(unsigned int **)(a1 + 1184);
  if (v20)
  {
    *int v20 = a2;
    *(void *)(a1 + 1184) = v20 + 1;
    uint64_t v21 = *(void *)(a1 + 400);
    if (v21)
    {
      uint64_t v22 = v21 + 12 * a2;
      *(void *)uint64_t v22 = a3.i64[0];
      *(_DWORD *)(v22 + 8) = a3.i32[2];
    }
    uint64_t v23 = *(void *)(a1 + 408);
    if (v23)
    {
      uint64_t v24 = v23 + 12 * a2;
      *(void *)uint64_t v24 = a4.i64[0];
      *(_DWORD *)(v24 + 8) = a4.i32[2];
    }
  }
}

void C3DParticleFloorCollider_C(uint64_t a1, int a2, unsigned int a3, float32x4_t *a4)
{
  LODWORD(v6) = a2;
  float v32 = *(float *)(a1 + 1028);
  v34.n128_u32[2] = 0;
  v34.n128_u64[0] = 0;
  C3DSceneGetUpAxis(*(__n128 **)(a1 + 1048), &v34);
  float32x4_t v33 = 0uLL;
  C3DComputeMirrorPlane(a4, (float32x4_t *)&v34, (__n128 *)&v33);
  if (*(unsigned char *)(a1 + 1136))
  {
    uint64_t v8 = *(int32x4_t **)(a1 + 1144);
    int32x4_t v9 = v8[1];
    int32x4_t v10 = v8[2];
    int32x4_t v11 = v8[3];
    int32x4_t v12 = vzip1q_s32(*v8, v10);
    int32x4_t v13 = vzip2q_s32(*v8, v10);
    int32x4_t v14 = vzip1q_s32(v9, v11);
    int32x4_t v15 = vzip2q_s32(v9, v11);
    float32x4_t v33 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)vzip1q_s32(v12, v14), v33.f32[0]), (float32x4_t)vzip2q_s32(v12, v14), *(float32x2_t *)v33.f32, 1), (float32x4_t)vzip1q_s32(v13, v15), v33, 2), (float32x4_t)vzip2q_s32(v13, v15), v33, 3);
  }
  BOOL v16 = a3 >= v6;
  int v17 = a3 - v6;
  float v18 = v32;
  if (v17 != 0 && v16)
  {
    uint64_t v19 = *(void *)(a1 + 256);
    uint64_t v20 = *(void *)(a1 + 264);
    uint64_t v6 = v6;
    do
    {
      float32x4_t v21 = vmulq_n_f32(*(float32x4_t *)(v20 + 16 * v6), v18);
      float32x4_t v22 = vmulq_f32(v21, v21);
      float v23 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
      if (v23 > 0.0)
      {
        float v24 = sqrtf(v23);
        float32x4_t v25 = vmulq_n_f32(v21, 1.0 / v24);
        float32x4_t v26 = vmulq_f32(v25, v33);
        float v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
        if (v27 != 0.0)
        {
          float32x4_t v28 = vsubq_f32(*(float32x4_t *)(v19 + 16 * v6), v21);
          float32x4_t v29 = vmulq_f32(v28, v33);
          float v30 = (float)-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1)))).f32[0]/ v27;
          if (v30 >= -0.00000011921 && v30 <= v24)
          {
            __HandleCollision(a1, v6, vmlaq_n_f32(v28, v25, v30), v33, *(double *)v25.i64);
            float v18 = v32;
          }
        }
      }
      ++v6;
      --v17;
    }
    while (v17);
  }
}

BOOL __rayIntersectSphere(float *a1, float32x4_t a2, float32x4_t a3, float a4, float32x4_t a5, float a6)
{
  float32x4_t v7 = vsubq_f32(a2, a5);
  float32x4_t v8 = vmulq_f32(v7, v7);
  float v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0]- (float)(a6 * a6);
  if (v9 <= 0.0) {
    return 1;
  }
  float32x4_t v10 = vmulq_f32(v7, a3);
  float v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  if (v11 >= 0.0) {
    return 0;
  }
  float v12 = -(float)(v9 - (float)(v11 * v11));
  if (v12 < 0.0) {
    return 0;
  }
  float v15 = (float)-v11 - sqrtf(v12);
  *a1 = v15;
  if (v15 <= 0.0)
  {
    BOOL v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      __rayIntersectSphere_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  return *a1 < a4;
}

void C3DParticleSphereCollider_C(uint64_t a1, int a2, unsigned int a3, float32x4_t *a4)
{
  LODWORD(v6) = a2;
  float v53 = *(float *)(a1 + 1028);
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a4);
  float Radius = C3DParametricGeometryGetRadius(Geometry);
  WorldMatrix = C3DNodeGetWorldMatrix(a4);
  *(uint64_t *)((char *)v56.i64 + 4) = 0;
  v56.i32[0] = 0;
  C3DMatrix4x4GetScale(WorldMatrix, &v56);
  float32x4_t v11 = vabsq_f32(v56);
  float v49 = Radius * fmaxf(fmaxf(v11.f32[0], v11.f32[2]), v11.f32[1]);
  __n128 v55 = (__n128)WorldMatrix[3];
  C3DNodeGetWorldPosition(a4, &v55);
  float32x4_t v12 = (float32x4_t)v55;
  if (*(unsigned char *)(a1 + 1136))
  {
    int32x4_t v13 = *(simd_float4x4 **)(a1 + 1144);
    simd_float4x4 v57 = *v13;
    float32x4_t v44 = (float32x4_t)v57.columns[1];
    float32x4_t v45 = (float32x4_t)v57.columns[2];
    float32x4_t v47 = (float32x4_t)v13->columns[0];
    float32x4_t v51 = (float32x4_t)v55;
    simd_float4x4 v58 = __invert_f4(*v13);
    float32x4_t v12 = vaddq_f32((float32x4_t)v58.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v58.columns[1], *(float32x2_t *)v51.f32, 1), (float32x4_t)v58.columns[0], v51.f32[0]), (float32x4_t)v58.columns[2], v51, 2));
    v58.columns[1] = (simd_float4)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), (int8x16_t)v45, 0xCuLL), vnegq_f32(v44)), v45, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL));
    v58.columns[0] = (simd_float4)vmulq_f32(v47, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58.columns[1], (int32x4_t)v58.columns[1]), (int8x16_t)v58.columns[1], 0xCuLL));
    _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58.columns[0], 2), vaddq_f32((float32x4_t)v58.columns[0], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.columns[0].f32, 1))).f32[0] < 0.0;
    float v15 = 1.0;
    if (_NF) {
      float v15 = -1.0;
    }
    float32x4_t v16 = vmulq_f32(v47, v47);
    float32x4_t v17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1)));
    v17.f32[0] = sqrtf(v17.f32[0]);
    float32x4_t v18 = vmulq_f32(v44, v44);
    float32x4_t v19 = vmulq_f32(v45, v45);
    v17.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0]);
    v17.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0]);
    float32x4_t v20 = vmulq_n_f32(v17, v15);
    float v21 = v49 / fmaxf(fmaxf(v20.f32[0], v20.f32[2]), v20.f32[1]);
  }
  else
  {
    float v21 = v49;
  }
  v12.f32[3] = v21;
  _CF = a3 >= v6;
  int v23 = a3 - v6;
  if (v23 != 0 && _CF)
  {
    uint64_t v24 = *(void *)(a1 + 256);
    uint64_t v25 = *(void *)(a1 + 264);
    float v26 = v21;
    uint64_t v6 = v6;
    __asm { FMOV            V0.4S, #1.0 }
    int8x16_t v46 = _Q0;
    float32x4_t v52 = v12;
    do
    {
      float32x4_t v30 = vmulq_n_f32(*(float32x4_t *)(v25 + 16 * v6), v53);
      float32x4_t v31 = vmulq_f32(v30, v30);
      float v32 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0];
      if (v32 > 0.0)
      {
        float v33 = sqrtf(v32);
        float32x4_t v34 = vsubq_f32(*(float32x4_t *)(v24 + 16 * v6), v30);
        float v54 = 0.0;
        float32x4_t v48 = vmulq_n_f32(v30, 1.0 / v33);
        float32x4_t v50 = v34;
        if (__rayIntersectSphere(&v54, v34, v48, v33, v12, v26))
        {
          float32x4_t v35 = vmlaq_n_f32(v50, v48, v54);
          float32x4_t v36 = vsubq_f32(v35, v52);
          float32x4_t v37 = vmulq_f32(v36, v36);
          v37.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u64[0];
          float32x4_t v38 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0);
          float32x4_t v39 = vrsqrteq_f32(v38);
          float32x4_t v40 = vmulq_f32(v39, vrsqrtsq_f32(v38, vmulq_f32(v39, v39)));
          int32x4_t v41 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v37.f32[0] != 0.0)), 0x1FuLL));
          v41.i32[3] = 0;
          int8x16_t v42 = (int8x16_t)vmulq_f32(v40, vrsqrtsq_f32(v38, vmulq_f32(v40, v40)));
          float32x4_t v43 = vmulq_f32(v36, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v41), v42, v46));
          v43.i32[3] = 0;
          __HandleCollision(a1, v6, v35, v43, *(double *)v42.i64);
        }
        float32x4_t v12 = v52;
      }
      ++v6;
      --v23;
    }
    while (v23);
  }
}

BOOL __triangleContainsPointBarycentric(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  BOOL result = 0;
  float32x4_t v5 = vsubq_f32(a2, a1);
  float32x4_t v6 = vsubq_f32(a3, a1);
  float32x4_t v7 = vmulq_f32(v5, v5);
  float32x4_t v8 = vsubq_f32(a4, a1);
  LODWORD(v9) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u32[0];
  float32x4_t v10 = vmulq_f32(v5, v6);
  v10.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  float32x4_t v11 = vmulq_f32(v5, v8);
  LODWORD(v12) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
  float32x4_t v13 = vmulq_f32(v6, v6);
  LODWORD(v14) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
  float32x4_t v15 = vmulq_f32(v6, v8);
  float v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0];
  float v17 = -v10.f32[0];
  float v18 = 1.0 / vmlas_n_f32((float)-v10.f32[0] * v10.f32[0], v14, v9);
  float v19 = vmlas_n_f32((float)-v10.f32[0] * v16, v12, v14) * v18;
  if (v19 >= 0.0)
  {
    float v20 = vmlas_n_f32(v17 * v12, v16, v9) * v18;
    if (v20 >= 0.0) {
      return (float)(v19 + v20) < 1.0;
    }
  }
  return result;
}

void __ClassifyParticlesForBoundingBox(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, float32x4_t *a5)
{
  float32x4_t v26 = a5[1];
  float32x4_t v27 = *a5;
  float v9 = *(float *)(a1 + 1028);
  float ParticleVelocity = C3DParticleSystemGetParticleVelocity(*(void *)(a1 + 1040));
  ParticleVelocityVariatioint n = C3DParticleSystemGetParticleVelocityVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    int32x4_t v12 = (int32x4_t)vaddq_f32(v27, v26);
    double v13 = (float)(v9 * ParticleVelocity);
    *(float *)&double v13 = v13 + ParticleVelocityVariation * 0.5;
    float v14 = *(float *)v12.i32 + *(float *)&v13;
    float32x4_t v15 = (float32x4_t)vdupq_laneq_s32(v12, 2);
    float v16 = *(float *)&v12.i32[1] + *(float *)&v13;
    float32x4_t v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v13, 0);
    float32x4_t v19 = vsubq_f32(vsubq_f32(v27, v26), v17);
    uint64_t v18 = *(void *)(a1 + 256) + 16 * a2;
    v19.i32[3] = vaddq_f32(v15, v17).i32[3];
    float v20 = (char *)(a4 + a2);
    unint64_t v21 = a3 - (unint64_t)a2;
    do
    {
      float32x4_t v22 = *(float32x4_t *)v18;
      if (COERCE_FLOAT(*(_OWORD *)v18) <= v14 && COERCE_FLOAT(HIDWORD(*(void *)v18)) <= v16)
      {
        v22.i32[3] = *(void *)(v18 + 8);
        int16x4_t v25 = vmovn_s32(vcgtq_f32(v19, v22));
        v25.i16[3] = vmovn_s32(vcgtq_f32(v22, v19)).i16[3];
        char v24 = vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(v25, 0xFuLL))) & 1;
      }
      else
      {
        char v24 = 1;
      }
      *v20++ = v24;
      v18 += 16;
      --v21;
    }
    while (v21);
  }
}

void __CollideWithFace(uint64_t a1, unsigned int a2, unsigned int a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v10 = vsubq_f32(a6, a4);
  float32x4_t v11 = vsubq_f32(a5, a4);
  float32x4_t v12 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v10)), v11, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL));
  float32x4_t v14 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL);
  float32x4_t v13 = vmulq_f32(v14, a4);
  v14.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0];
  float32x4_t v15 = vmulq_f32(v12, v12);
  int32x2_t v16 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v15)).u64[0];
  *(float *)v16.i32 = sqrtf(*(float *)v16.i32);
  if (*(float *)v16.i32 > 0.0) {
    float32x4_t v14 = vdivq_f32(v14, (float32x4_t)vdupq_lane_s32(v16, 0));
  }
  unsigned int v17 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v18 = *(void *)(a1 + 256);
    uint64_t v19 = *(void *)(a1 + 264);
    uint64_t v20 = a2;
    float v21 = *(float *)(a1 + 1028);
    float32x4_t v37 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
    float v31 = v21;
    float32x4_t v32 = v14;
    do
    {
      if (!*(unsigned char *)(a8 + v20))
      {
        float32x4_t v22 = vmulq_n_f32(*(float32x4_t *)(v19 + 16 * v20), v21);
        float32x4_t v23 = vmulq_f32(v14, v22);
        float v24 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0];
        if (v24 != 0.0)
        {
          float32x4_t v25 = vsubq_f32(*(float32x4_t *)(v18 + 16 * v20), v22);
          float32x4_t v26 = vmulq_f32(v14, v25);
          float v27 = (float)-vaddq_f32(v37, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)))).f32[0]/ v24;
          if (v27 >= 0.0 && v27 <= 1.0)
          {
            float32x4_t v36 = vmlaq_n_f32(v25, v22, v27);
            BOOL v29 = __triangleContainsPointBarycentric(a4, a5, a6, v36);
            float v21 = v31;
            float32x4_t v14 = v32;
            if (v29)
            {
              __HandleCollision(a1, v20, v36, v32, v30);
              float v21 = v31;
              float32x4_t v14 = v32;
            }
          }
        }
      }
      ++v20;
      --v17;
    }
    while (v17);
  }
}

void C3DParticleMeshCollider_C(uint64_t a1, unsigned int a2, unsigned int a3, float32x4_t *a4)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a4);
  if (Geometry)
  {
    uint64_t Mesh = C3DGeometryGetMesh(Geometry);
    if (Mesh)
    {
      uint64_t v8 = Mesh;
      PositionSource = C3DMeshGetPositionSource(Mesh, 1);
      if (PositionSource)
      {
        uint64_t v10 = (uint64_t)PositionSource;
        float32x4_t v52 = 0u;
        int32x4_t v53 = 0u;
        C3DNodeGetLocalBoundingBox((uint64_t)a4, &v52);
        if (*(unsigned char *)(a1 + 1136) && *(void *)(a1 + 1144))
        {
          WorldMatrix = C3DNodeGetWorldMatrix(a4);
          float32x4_t v48 = WorldMatrix[1];
          float32x4_t v50 = *WorldMatrix;
          float32x4_t v44 = WorldMatrix[3];
          float32x4_t v46 = WorldMatrix[2];
          simd_float4x4 v63 = __invert_f4(*(simd_float4x4 *)*(void *)(a1 + 1144));
          unint64_t v12 = 0;
          float32x4_t v54 = v50;
          float32x4_t v55 = v48;
          float32x4_t v56 = v46;
          float32x4_t v57 = v44;
          float32x4_t v58 = 0u;
          float32x4_t v59 = 0u;
          float32x4_t v60 = 0u;
          float32x4_t v61 = 0u;
          do
          {
            *(float32x4_t *)((char *)&v58 + v12) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v63.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v54 + v12))), (float32x4_t)v63.columns[1], *(float32x2_t *)&v54.f32[v12 / 4], 1), (float32x4_t)v63.columns[2], *(float32x4_t *)((char *)&v54 + v12), 2), (float32x4_t)v63.columns[3], *(float32x4_t *)((char *)&v54 + v12), 3);
            v12 += 16;
          }
          while (v12 != 64);
          float32x4_t v13 = v58;
          float32x4_t v14 = v59;
          float32x4_t v15 = v60;
          float32x4_t v16 = v61;
        }
        else
        {
          unsigned int v17 = C3DNodeGetWorldMatrix(a4);
          float32x4_t v13 = *v17;
          float32x4_t v14 = v17[1];
          float32x4_t v15 = v17[2];
          float32x4_t v16 = v17[3];
        }
        float32x4_t v45 = v16;
        float32x4_t v47 = v15;
        float32x4_t v18 = vaddq_f32(v16, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v14, *(float32x2_t *)v52.f32, 1), v13, v52.f32[0]), v15, v52, 2));
        v18.i32[3] = 1.0;
        float32x4_t v19 = (float32x4_t)v53;
        v19.i32[1] = v53.i32[0];
        v19.i32[2] = v53.i32[0];
        float32x4_t v49 = v14;
        float32x4_t v51 = v13;
        float32x4_t v54 = v18;
        float32x4_t v55 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v13, v19)), vabsq_f32(vmulq_f32(v14, (float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v53.i8, 1), v53)))), vabsq_f32(vmulq_f32(v15, (float32x4_t)vzip2q_s32(vtrn1q_s32(v53, v53), v53))));
        uint64_t v20 = *(void *)(a1 + 384);
        __ClassifyParticlesForBoundingBox(a1, a2, a3, v20, &v54);
        float32x4_t v41 = *(float32x4_t *)(a1 + 1088);
        float32x4_t v37 = *(float32x4_t *)(a1 + 1104);
        ElementsCFIndex Count = C3DMeshGetElementsCount(v8);
        if ((uint64_t)ElementsCount >= 1)
        {
          CFIndex v21 = 0;
          float32x4_t v22 = vaddq_f32(v41, v37);
          float32x4_t v42 = vsubq_f32(v41, v37);
          float32x4_t v43 = v22;
          do
          {
            uint64_t v23 = v8;
            ElementAtuint64_t Index = C3DMeshGetElementAtIndex(v8, v21, 1);
            int Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
            if (C3DMeshElementTypeDefinesSurface(Type))
            {
              C3DMeshElementGetDoubleSided((uint64_t)ElementAtIndex);
              if (!Type)
              {
                PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
                if (PrimitiveCount >= 1)
                {
                  uint64_t v27 = PrimitiveCount;
                  for (uint64_t i = 0; i != v27; ++i)
                  {
                    for (uint64_t j = 0; j != 3; ++j)
                    {
                      uint64_t Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, j, 0);
                      *(double *)v31.i64 = C3DMeshSourceGetValueAtIndexAsVector3(v10, Index);
                      float32x4_t v32 = vaddq_f32(v45, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v49, *(float32x2_t *)v31.f32, 1), v51, v31.f32[0]), v47, v31, 2));
                      v32.i32[3] = 0;
                      *(&v58 + j) = v32;
                    }
                    float32x4_t v33 = vminq_f32(vminq_f32(v58, v59), v60);
                    float32x4_t v34 = vmaxq_f32(vmaxq_f32(v58, v59), v60);
                    v34.i32[3] = v43.i32[0];
                    float32x4_t v35 = v42;
                    v35.i32[3] = v33.i32[0];
                    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vcgtq_f32(v35, v34)), 0xFuLL))) & 1) == 0)
                    {
                      int16x4_t v36 = vmovn_s32(vcgtq_f32(v33, v43));
                      if ((v36.i8[2] & 1) == 0 && (v36.i8[4] & 1) == 0) {
                        __CollideWithFace(a1, a2, a3, v58, v59, v60, 0, v20);
                      }
                    }
                  }
                }
              }
            }
            ++v21;
            uint64_t v8 = v23;
          }
          while ((const __CFArray *)v21 != ElementsCount);
        }
      }
    }
  }
}

void C3DParticleGenericCollider(uint64_t a1, unsigned int a2, unsigned int a3, float32x4_t *a4)
{
  uint64_t Geometry = (const void *)C3DNodeGetGeometry((uint64_t)a4);
  if (!Geometry) {
    return;
  }
  uint64_t v9 = (uint64_t)Geometry;
  CFTypeID v10 = CFGetTypeID(Geometry);
  if (v10 == C3DFloorGetTypeID())
  {
    C3DParticleFloorCollider_C(a1, a2, a3, a4);
    return;
  }
  if (v10 != C3DParametricGeometryGetTypeID())
  {
LABEL_13:
    C3DParticleMeshCollider_C(a1, a2, a3, a4);
    return;
  }
  int Type = C3DParametricGeometryGetType(v9);
  if (Type != 3)
  {
    if (!Type)
    {
      C3DParticlePlaneCollider_C(a1, a2, a3, a4);
      return;
    }
    goto LABEL_13;
  }

  C3DParticleSphereCollider_C(a1, a2, a3, a4);
}

uint64_t C3DParticleContextSetup(uint64_t a1, uint64_t a2, const void *a3, double a4, float a5)
{
  bzero((void *)a1, 0x4C0uLL);
  memcpy((void *)a1, a3, 0x400uLL);
  *(_DWORD *)(a1 + 1024) = *(_DWORD *)(a2 + 1104);
  *(float *)(a1 + 1028) = a5;
  *(float *)(a1 + 1032) = 1.0 / a5;
  float v10 = a4;
  *(float *)(a1 + 1036) = v10;
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)(a1 + 1040) = *(void *)(a2 + 48);
  *(void *)(a1 + 1072) = v11;
  long long v12 = *(_OWORD *)(a2 + 1152);
  *(_OWORD *)(a1 + 1104) = *(_OWORD *)(a2 + 1168);
  *(_OWORD *)(a1 + 1088) = v12;
  uint64_t v13 = *(void *)(a2 + 48);
  *(void *)(a1 + 1064) = *(void *)(a2 + 56);
  *(void *)(a1 + 1048) = *(void *)(a2 + 64);
  int IsLocal = C3DParticleSystemGetIsLocal(v13);
  *(unsigned char *)(a1 + 1136) = IsLocal;
  if (IsLocal)
  {
    uint64_t v15 = *(void *)(a2 + 16);
    if (v15)
    {
      if (*(_DWORD *)(a2 + 24) == 1)
      {
        *(void *)(a1 + 1144) = v15 + 32;
        *(void *)(a1 + 1152) = v15 + 96;
      }
    }
  }
  if ((C3DParticleSystemGetAffectedByPhysicsFields(*(void *)(a1 + 1040)) & 1) != 0
    || C3DParticleSystemGetAffectedByGravity(*(void *)(a1 + 1040)))
  {
    *(void *)(a1 + 1056) = C3DSceneGetPhysicsWorld(*(id **)(a1 + 1048), 1);
  }
  *(float *)(a1 + 1160) = C3DParticleSystemGetParticleBounce(*(void *)(a2 + 48));
  *(float *)(a1 + 1164) = C3DParticleSystemGetParticleFriction(*(void *)(a2 + 48));
  *(unsigned char *)(a1 + 1168) = C3DParticleSystemGetParticleDiesOnCollision(*(void *)(a2 + 48));
  *(void *)(a1 + 1176) = C3DParticleSystemGetSystemSpawnedOnCollision(*(void *)(a2 + 48));
  *(void *)(a1 + 1192) = C3DParticleManagerGetUpdateQueue();
  uint64_t result = C3DParticleManagerGetUpdateQueue();
  *(void *)(a1 + 1200) = result;
  return result;
}

void C3DParticleGenericColliderWithBlock(void *a1, unsigned int a2, unsigned int a3, float32x4_t *a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  CFArrayRef theArray = 0;
  EventBlocCFIndex k = C3DParticleSystemGetEventBlock(a1[130], 2u, &theArray);
  uint64_t v9 = a1[49];
  a1[148] = v9;
  C3DParticleGenericCollider((uint64_t)a1, a2, a3, a4);
  uint64_t v10 = a1[148] - v9;
  if (v10)
  {
    uint64_t v11 = v10 >> 2;
    memset(v14, 0, 256);
    C3DParticleSystemInstanceFillUserData(a1[130], (uint64_t)a1, theArray, (uint64_t)v14, (uint64_t)v13, 0);
    (*(void (**)(uint64_t, unsigned char *, unsigned char *, uint64_t, uint64_t))(EventBlock + 16))(EventBlock, v14, v13, v9, v11);
  }
}

void C3DParticleSpawnSubSystem(void *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = a1[32];
  uint64_t v7 = a1[33];
  uint64_t SystemSpawnedOnLiving = C3DParticleSystemGetSystemSpawnedOnLiving(a1[130]);
  if (SystemSpawnedOnLiving) {
    BOOL v9 = a3 > a2;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    uint64_t v10 = (const void *)SystemSpawnedOnLiving;
    uint64_t v11 = (__n128 *)(v6 + 16 * a2);
    unsigned int v12 = a3 - a2;
    uint64_t v13 = (float32x4_t *)(v7 + 16 * a2);
    do
    {
      __n128 v14 = *v11++;
      __n128 v15 = v14;
      float32x4_t v16 = *v13++;
      __SpawnSubSystem(a1[133], v10, v15, v16);
      --v12;
    }
    while (v12);
  }
}

void C3DParticleModifier_Frame(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 368);
  uint64_t v5 = *(void *)(a1 + 376);
  float v7 = *(float *)(a1 + 1028);
  if (v5)
  {
    if (a2 < a3)
    {
      uint64_t v8 = (float *)(v5 + 4 * a2);
      BOOL v9 = (float *)(v6 + 4 * a2);
      unint64_t v10 = a3 - (unint64_t)a2;
      do
      {
        float v11 = *v8++;
        *BOOL v9 = *v9 + (float)(v11 * v7);
        ++v9;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    float ImageSequenceFrameRate = C3DParticleSystemGetImageSequenceFrameRate(*(void *)(a1 + 1040));
    if (a2 < a3)
    {
      uint64_t v13 = (float *)(v6 + 4 * a2);
      unint64_t v14 = a3 - (unint64_t)a2;
      do
      {
        *uint64_t v13 = *v13 + (float)(ImageSequenceFrameRate * v7);
        ++v13;
        --v14;
      }
      while (v14);
    }
  }
}

void C3DParticleInitPositionAndVelocity(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 256);
  uint64_t v7 = *(void *)(a1 + 264);
  EmitterShape = (const void *)C3DParticleSystemGetEmitterShape(*(void *)(a1 + 1040));
  BirthLocatioint n = C3DParticleSystemGetBirthLocation(*(void *)(a1 + 1040));
  BirthDirectioint n = C3DParticleSystemGetBirthDirection(*(void *)(a1 + 1040));
  float ParticleAngle = C3DParticleSystemGetParticleAngle(*(void *)(a1 + 1040));
  ParticleAngleVariatioint n = C3DParticleSystemGetParticleAngleVariation(*(void *)(a1 + 1040));
  float ParticleVelocity = C3DParticleSystemGetParticleVelocity(*(void *)(a1 + 1040));
  ParticleVelocityVariatioint n = C3DParticleSystemGetParticleVelocityVariation(*(void *)(a1 + 1040));
  float ParticleAngularVelocity = C3DParticleSystemGetParticleAngularVelocity(*(void *)(a1 + 1040));
  ParticleAngularVelocityVariatioint n = C3DParticleSystemGetParticleAngularVelocityVariation(*(void *)(a1 + 1040));
  EmittingDirectioint n = C3DParticleSystemGetEmittingDirection((__n128 *)*(void *)(a1 + 1040));
  float v16 = C3DParticleSystemGetSpreadingAngle(*(void *)(a1 + 1040)) / 180.0 * 3.14159265;
  float v92 = v16;
  float v86 = cosf(v16);
  float32x4_t v19 = *(float32x4_t **)(a1 + 1144);
  float32x4_t v90 = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  int8x16_t v85 = _Q0;
  if (!v19)
  {
    int v48 = 0;
    float32x4_t v27 = 0uLL;
    float32x4_t v28 = 0uLL;
    float32x4_t v25 = 0uLL;
    float32x4_t v26 = 0uLL;
    float32x4_t v49 = 0uLL;
    float32x4_t v93 = 0u;
    float32x4_t v94 = 0u;
    float32x4_t v95 = 0u;
    goto LABEL_5;
  }
  float32x4_t v26 = *v19;
  float32x4_t v25 = v19[1];
  float32x4_t v28 = v19[2];
  float32x4_t v27 = v19[3];
  BOOL v29 = *(float32x4_t **)(a1 + 1152);
  float32x4_t v30 = v29[1];
  int8x16_t v31 = (int8x16_t)vmulq_f32(v26, v26);
  int32x2_t v32 = (int32x2_t)vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
  float32x4_t v33 = v29[2];
  float32x4_t v17 = v29[3];
  float32x4_t v34 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32((float32x2_t)v32, (float32x2_t)vdup_lane_s32(v32, 1)), 0);
  float32x4_t v35 = vrsqrteq_f32(v34);
  float32x4_t v36 = vmulq_f32(v35, vrsqrtsq_f32(v34, vmulq_f32(v35, v35)));
  float32x4_t v37 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v34), _Q0, (int8x16_t)vmulq_f32(v36, vrsqrtsq_f32(v34, vmulq_f32(v36, v36))));
  int8x16_t v38 = (int8x16_t)vmulq_f32(v25, v25);
  *(float32x2_t *)v38.i8 = vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
  float32x4_t v95 = vmulq_f32(*v19, v37);
  float32x4_t v39 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1)), 0);
  float32x4_t v40 = vrsqrteq_f32(v39);
  float32x4_t v41 = vmulq_f32(v40, vrsqrtsq_f32(v39, vmulq_f32(v40, v40)));
  float32x4_t v42 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v39), _Q0, (int8x16_t)vmulq_f32(v41, vrsqrtsq_f32(v39, vmulq_f32(v41, v41))));
  int8x16_t v43 = (int8x16_t)vmulq_f32(v28, v28);
  *(float32x2_t *)v43.i8 = vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
  float32x4_t v94 = vmulq_f32(v25, v42);
  float32x4_t v44 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1)), 0);
  float32x4_t v45 = vrsqrteq_f32(v44);
  float32x4_t v46 = vmulq_f32(v45, vrsqrtsq_f32(v44, vmulq_f32(v45, v45)));
  float32x4_t v93 = vmulq_f32(v28, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v44), _Q0, (int8x16_t)vmulq_f32(v46, vrsqrtsq_f32(v44, vmulq_f32(v46, v46)))));
  float32x4_t v47 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  float32x4_t v18 = (float32x4_t)vorrq_s8(vorrq_s8((int8x16_t)vcgtq_f32(vabdq_f32(v25, v30), v47), (int8x16_t)vcgtq_f32(vabdq_f32(*v19, *v29), v47)), vorrq_s8((int8x16_t)vcgtq_f32(vabdq_f32(v28, v33), v47), (int8x16_t)vcgtq_f32(vabdq_f32(v27, v17), v47)));
  if ((vmaxvq_u32((uint32x4_t)v18) & 0x80000000) == 0)
  {
    int v48 = 0;
    float32x4_t v49 = 0uLL;
LABEL_5:
    float32x4_t v88 = v49;
    float32x4_t v89 = v49;
    float32x4_t v87 = v49;
    goto LABEL_7;
  }
  float v50 = 1.0 / (float)(a3 - a2);
  float32x4_t v87 = vmulq_n_f32(vsubq_f32(v26, *v29), v50);
  float32x4_t v88 = vmulq_n_f32(vsubq_f32(v25, v30), v50);
  int v48 = 1;
  float32x4_t v18 = vmulq_n_f32(vsubq_f32(v27, v17), v50);
  float32x4_t v89 = vmulq_n_f32(vsubq_f32(v28, v33), v50);
  float32x4_t v90 = v18;
  float32x4_t v27 = v29[3];
  float32x4_t v28 = v29[2];
  float32x4_t v25 = v29[1];
  float32x4_t v26 = *v29;
LABEL_7:
  float32x4_t v111 = 0uLL;
  unsigned int v51 = a3 - a2;
  if (a3 > a2)
  {
    *(double *)v52.i64 = ParticleAngularVelocity / 180.0 * 3.14159265;
    *(double *)v17.i64 = ParticleAngularVelocityVariation / 180.0 * 3.14159265;
    float v53 = ParticleAngle / 180.0 * 3.14159265;
    float v54 = ParticleAngleVariation / 180.0 * 3.14159265;
    float v55 = *(double *)v52.i64;
    float v56 = *(double *)v17.i64;
    __n128 v57 = EmittingDirection;
    v57.n128_u32[3] = 0;
    float32x4_t v98 = (float32x4_t)v57;
    unsigned int v58 = ~a2 + a3;
    if (v58 <= 1) {
      unsigned int v58 = 1;
    }
    float v59 = (float)v58;
    v18.i32[0] = *(_DWORD *)(a1 + 1028);
    float32x4_t v60 = (unsigned int *)(a1 + 1120);
    unsigned int v61 = a2;
    uint64_t v62 = (float32x4_t *)(v6 + 16 * a2);
    simd_float4x4 v63 = (float32x4_t *)(v7 + 16 * v61);
    float32x4_t v64 = (float32x4_t)vdupq_n_s32(0x37800080u);
    float32x4_t v84 = v64;
    float v65 = v18.f32[0] / v59;
    while (1)
    {
      if (EmitterShape)
      {
        v110.i32[2] = 0;
        v110.i64[0] = 0;
        v109.i32[2] = 0;
        v109.i64[0] = 0;
        float32x4_t v105 = v28;
        float32x4_t v107 = v27;
        float32x4_t v103 = v25;
        float32x4_t v99 = v18;
        float32x4_t v101 = v26;
        if (BirthDirection == 1)
        {
          C3DGeometryGeneratePoints(EmitterShape, 1, v60, &v110, &v109, BirthLocation);
          float32x4_t v18 = v99;
          float32x4_t v26 = v101;
          float32x4_t v25 = v103;
          float32x4_t v28 = v105;
          float32x4_t v27 = v107;
          float32x4_t v66 = v109;
          v66.i32[3] = 0;
          float32x4_t v111 = v66;
        }
        else
        {
          C3DGeometryGeneratePoints(EmitterShape, 1, v60, &v110, 0, BirthLocation);
          float32x4_t v18 = v99;
          float32x4_t v26 = v101;
          float32x4_t v25 = v103;
          float32x4_t v28 = v105;
          float32x4_t v27 = v107;
        }
        float32x4_t v67 = v110;
        v67.i32[3] = 1.0;
      }
      else
      {
        float32x4_t v66 = v98;
        float32x4_t v111 = v98;
        float32x4_t v67 = (float32x4_t)xmmword_20B5CB530;
      }
      if (BirthDirection != 2) {
        break;
      }
      int v76 = 214013 * *v60 + 2531011;
      v77.i32[0] = v76;
      v77.i32[1] = 214013 * v76 + 2531011;
      v77.i64[1] = (214013 * v77.i32[1] + 2531011);
      v78.i64[0] = 0xBF000000BF000000;
      v78.i64[1] = 0xBF000000BF000000;
      float32x4_t v79 = vaddq_f32(vmulq_f32(vcvtq_f32_u32(vshrq_n_u32(v77, 0x10uLL)), v84), v78);
      int8x16_t v80 = (int8x16_t)vmulq_f32(v79, v79);
      *(float32x2_t *)v80.i8 = vadd_f32(*(float32x2_t *)v80.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v80, v80, 8uLL));
      float32x4_t v81 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v80.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v80.i8, 1)), 0);
      unsigned int *v60 = 214013 * (214013 * v76 + 2531011) + 2531011;
      float32x4_t v82 = vrsqrteq_f32(v81);
      float32x4_t v83 = vmulq_f32(v82, vrsqrtsq_f32(v81, vmulq_f32(v82, v82)));
      float32x4_t v17 = (float32x4_t)v85;
      float32x4_t v64 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v81), v85, (int8x16_t)vmulq_f32(v83, vrsqrtsq_f32(v81, vmulq_f32(v83, v83))));
      float32x4_t v111 = vmulq_f32(v79, v64);
      if (v19)
      {
LABEL_24:
        if (v48)
        {
          float32x4_t v26 = vaddq_f32(v87, v26);
          float32x4_t v25 = vaddq_f32(v88, v25);
          float32x4_t v28 = vaddq_f32(v89, v28);
          float32x4_t v27 = vaddq_f32(v90, v27);
        }
        float32x4_t v68 = vaddq_f32(v27, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v25, *(float32x2_t *)v67.f32, 1), v26, v67.f32[0]), v28, v67, 2));
        v68.i32[3] = v67.i32[3];
        float32x4_t v64 = v111;
        float32x4_t v17 = v93;
        float32x4_t v69 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v94, *(float32x2_t *)v111.f32, 1), v95, v111.f32[0]), v93, v111, 2);
        v69.i32[3] = v111.i32[3];
        float32x4_t v111 = v69;
        float32x4_t v67 = v68;
      }
LABEL_27:
      float v70 = v53;
      if (v54 != 0.0)
      {
        unsigned int v71 = 214013 * *v60 + 2531011;
        unsigned int *v60 = v71;
        float v70 = v53 + (float)((float)((float)((float)HIWORD(v71) * 0.000015259) + -0.5) * v54);
      }
      v64.f32[0] = ParticleVelocity;
      if (ParticleVelocityVariation != 0.0)
      {
        unsigned int v72 = 214013 * *v60 + 2531011;
        unsigned int *v60 = v72;
        v64.f32[0] = ParticleVelocity
                   + (float)((float)((float)((float)HIWORD(v72) * 0.000015259) + -0.5) * ParticleVelocityVariation);
      }
      float32x4_t v52 = v111;
      v17.f32[0] = v55;
      if (v56 != 0.0)
      {
        unsigned int v73 = 214013 * *v60 + 2531011;
        unsigned int *v60 = v73;
        v17.f32[0] = v55 + (float)((float)((float)((float)HIWORD(v73) * 0.000015259) + -0.5) * v56);
      }
      v67.f32[3] = v70;
      float32x4_t v74 = vmulq_n_f32(v52, v64.f32[0]);
      v74.i32[3] = v17.i32[0];
      float32x4_t v111 = v74;
      float32x4_t v75 = vmlaq_n_f32(v67, v74, v18.f32[0]);
      v18.f32[0] = v18.f32[0] - v65;
      *v62++ = v75;
      *v63++ = v74;
      if (!--v51) {
        return;
      }
    }
    if (BirthDirection != 1)
    {
      if (BirthDirection) {
        goto LABEL_23;
      }
      float32x4_t v66 = v98;
      float32x4_t v111 = v98;
    }
    if (v92 > 0.0)
    {
      v66.f32[0] = v86;
      float32x4_t v106 = v28;
      float32x4_t v108 = v27;
      float32x4_t v104 = v25;
      float32x4_t v100 = v18;
      float32x4_t v102 = v26;
      float32x4_t v91 = v67;
      __spreadingVariationf(v60, &v111, 1, v66, (int8x16_t)v64, *(double *)v52.i64, (int8x16_t)v17, v18);
      float32x4_t v67 = v91;
      float32x4_t v18 = v100;
      float32x4_t v26 = v102;
      float32x4_t v25 = v104;
      float32x4_t v28 = v106;
      float32x4_t v27 = v108;
    }
LABEL_23:
    if (v19) {
      goto LABEL_24;
    }
    goto LABEL_27;
  }
}

float C3DParticleInitLife(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 272);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitLife_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float result = C3DParticleSystemGetParticleLifeSpan(*(void *)(a1 + 1040));
  unsigned int v16 = ~a2 + a3;
  if (v16 <= 1) {
    unsigned int v16 = 1;
  }
  if (a2 < a3)
  {
    float v17 = *(float *)(a1 + 1028) / (float)v16;
    float32x4_t v18 = (float *)(v6 + 4 * a2);
    unint64_t v19 = a3 - (unint64_t)a2;
    do
    {
      *v18++ = result;
      float result = result - v17;
      --v19;
    }
    while (v19);
  }
  return result;
}

void C3DParticleInitLifeWithVariation(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 272);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitLife_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = *(void *)(a1 + 280);
  if (!v15)
  {
    unsigned int v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitLifeWithVariation_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  ParticleLifeSpaint n = C3DParticleSystemGetParticleLifeSpan(*(void *)(a1 + 1040));
  ParticleLifeSpanVariatioint n = C3DParticleSystemGetParticleLifeSpanVariation(*(void *)(a1 + 1040));
  unsigned int v26 = ~a2 + a3;
  if (v26 <= 1) {
    unsigned int v26 = 1;
  }
  if (a2 < a3)
  {
    float v27 = *(float *)(a1 + 1028);
    float v28 = v27 / (float)v26;
    float v29 = ParticleLifeSpan - v27;
    float32x4_t v30 = (float *)(v6 + 4 * a2);
    int8x16_t v31 = (float *)(v15 + 4 * a2);
    unint64_t v32 = a3 - (unint64_t)a2;
    do
    {
      float v33 = v29;
      if (ParticleLifeSpanVariation != 0.0)
      {
        unsigned int v34 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v34;
        float v33 = v29 + (float)((float)((float)((float)HIWORD(v34) * 0.000015259) + -0.5) * ParticleLifeSpanVariation);
      }
      *v30++ = v33;
      *v31++ = 1.0 / v33;
      float v29 = v28 + v29;
      --v32;
    }
    while (v32);
  }
}

void C3DParticleInitBirthTime(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 288);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitBirthTime_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  unsigned int v15 = ~a2 + a3;
  if (v15 <= 1) {
    unsigned int v15 = 1;
  }
  if (a2 < a3)
  {
    float v16 = *(float *)(a1 + 1028);
    float v17 = v16 / (float)v15;
    float v18 = *(float *)(a1 + 1036) - v16;
    uint64_t v19 = (float *)(v6 + 4 * a2);
    unint64_t v20 = a3 - (unint64_t)a2;
    do
    {
      *v19++ = v18;
      float v18 = v17 + v18;
      --v20;
    }
    while (v20);
  }
}

void C3DParticleInitMass(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 304);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitMass_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ParticleMass = C3DParticleSystemGetParticleMass(*(void *)(a1 + 1040));
  ParticleMassVariatioint n = C3DParticleSystemGetParticleMassVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleMass;
      if (ParticleMassVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleMass + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleMassVariation);
      }
      if (v19 == 0.0) {
        float v21 = 1.0;
      }
      else {
        float v21 = 1.0 / v19;
      }
      *v17++ = v21;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitSize(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 312);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitSize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ParticleSize = C3DParticleSystemGetParticleSize(*(void *)(a1 + 1040));
  ParticleSizeVariatioint n = C3DParticleSystemGetParticleSizeVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleSize;
      if (ParticleSizeVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleSize + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleSizeVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitIntensity(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 416);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitSize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  Particlefloat Intensity = C3DParticleSystemGetParticleIntensity(*(void *)(a1 + 1040));
  ParticleIntensityVariatioint n = C3DParticleSystemGetParticleIntensityVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleIntensity;
      if (ParticleIntensityVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleIntensity
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleIntensityVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitBounce(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 344);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitBounce_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ParticleBounce = C3DParticleSystemGetParticleBounce(*(void *)(a1 + 1040));
  ParticleBounceVariatioint n = C3DParticleSystemGetParticleBounceVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleBounce;
      if (ParticleBounceVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleBounce
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleBounceVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitFriction(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 336);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitFriction_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  ParticleFrictioint n = C3DParticleSystemGetParticleFriction(*(void *)(a1 + 1040));
  ParticleFrictionVariatioint n = C3DParticleSystemGetParticleFrictionVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleFriction;
      if (ParticleFrictionVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleFriction
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleFrictionVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitCharge(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 352);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitCharge_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ParticleCharge = C3DParticleSystemGetParticleCharge(*(void *)(a1 + 1040));
  ParticleChargeVariatioint n = C3DParticleSystemGetParticleChargeVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    float v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ParticleCharge;
      if (ParticleChargeVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ParticleCharge
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ParticleChargeVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitColor(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 320);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitColor_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  ParticleColor = (uint64_t *)C3DParticleSystemGetParticleColor(*(void *)(a1 + 1040));
  unint64_t v16 = C3DColor4RGB2HSB(*ParticleColor, ParticleColor[1]);
  float v18 = v17;
  ParticleColorVariatioint n = C3DParticleSystemGetParticleColorVariation((__n128 *)*(void *)(a1 + 1040));
  BOOL v19 = a3 >= a2;
  unsigned int v20 = a3 - a2;
  if (v20 != 0 && v19)
  {
    float v21 = (unint64_t *)(v6 + 16 * a2);
    do
    {
      float v22 = *(float *)&v16;
      if (ParticleColorVariation.n128_f32[0] != 0.0)
      {
        unsigned int v23 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v23;
        float v22 = *(float *)&v16
            + (float)((float)((float)((float)HIWORD(v23) * 0.000015259) + -0.5) * ParticleColorVariation.n128_f32[0]);
      }
      float v24 = *((float *)&v16 + 1);
      if (ParticleColorVariation.n128_f32[1] != 0.0)
      {
        unsigned int v25 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v25;
        float v24 = *((float *)&v16 + 1)
            + (float)((float)((float)((float)HIWORD(v25) * 0.000015259) + -0.5) * ParticleColorVariation.n128_f32[1]);
      }
      if (v24 >= 0.0) {
        float v26 = v24;
      }
      else {
        float v26 = 0.0;
      }
      if (v24 <= 1.0) {
        float v27 = v26;
      }
      else {
        float v27 = 1.0;
      }
      float v28 = v18;
      if (ParticleColorVariation.n128_f32[2] != 0.0)
      {
        unsigned int v29 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v29;
        float v28 = v18
            + (float)((float)((float)((float)HIWORD(v29) * 0.000015259) + -0.5) * ParticleColorVariation.n128_f32[2]);
      }
      if (v28 >= 0.0) {
        float v30 = v28;
      }
      else {
        float v30 = 0.0;
      }
      if (v28 <= 1.0) {
        float v31 = v30;
      }
      else {
        float v31 = 1.0;
      }
      if (ParticleColorVariation.n128_f32[3] != 0.0) {
        *(_DWORD *)(a1 + 1120) = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
      }
      unint64_t *v21 = C3DColor4HSB2RGB(COERCE_UNSIGNED_INT(v22 - floorf(v22)) | ((unint64_t)LODWORD(v27) << 32), SLODWORD(v31));
      v21[1] = v32;
      v21 += 2;
      --v20;
    }
    while (v20);
  }
}

void C3DParticleInitRotationAxis(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 360);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitRotationAxis_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  OrientationDirectioint n = C3DParticleSystemGetOrientationDirection((__n128 *)*(void *)(a1 + 1040));
  uint32x4_t v17 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)OrientationDirection));
  v17.i32[3] = v17.i32[2];
  if ((vmaxvq_u32(v17) & 0x80000000) != 0)
  {
    if (a2 < a3)
    {
      float32x4_t v32 = vmulq_f32((float32x4_t)OrientationDirection, (float32x4_t)OrientationDirection);
      v32.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).u64[0];
      int32x4_t v33 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v32.f32[0] != 0.0)), 0x1FuLL));
      v33.i32[3] = 0;
      float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0);
      float32x4_t v35 = vrsqrteq_f32(v34);
      float32x4_t v36 = vmulq_f32(v35, vrsqrtsq_f32(v34, vmulq_f32(v35, v35)));
      int8x16_t v37 = (int8x16_t)vmulq_f32(v36, vrsqrtsq_f32(v34, vmulq_f32(v36, v36)));
      __asm { FMOV            V3.4S, #1.0 }
      float32x4_t v39 = vmulq_f32((float32x4_t)OrientationDirection, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v33), v37, _Q3));
      float32x4_t v40 = (_DWORD *)(v6 + 12 * a2 + 8);
      unint64_t v41 = a3 - (unint64_t)a2;
      do
      {
        *((void *)v40 - 1) = v39.i64[0];
        *float32x4_t v40 = v39.i32[2];
        v40 += 3;
        --v41;
      }
      while (v41);
    }
  }
  else if (a2 < a3)
  {
    unsigned __int32 v18 = *(_DWORD *)(a1 + 1120);
    BOOL v19 = (_DWORD *)(v6 + 12 * a2 + 8);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x37800080u);
    unint64_t v21 = a3 - (unint64_t)a2;
    __asm { FMOV            V4.4S, #1.0 }
    do
    {
      v16.i32[0] = 214013 * v18 + 2531011;
      v16.i32[1] = 214013 * v16.i32[0] + 2531011;
      unsigned __int32 v18 = 214013 * v16.i32[1] + 2531011;
      *(float32x2_t *)v16.f32 = vadd_f32(vmul_f32(vcvt_f32_u32(vshr_n_u32(*(uint32x2_t *)v16.f32, 0x10uLL)), v20), (float32x2_t)0xBF000000BF000000);
      v16.f32[2] = (float)((float)HIWORD(v18) * 0.000015259) + -0.5;
      float32x4_t v27 = vmulq_f32(v16, v16);
      v27.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u64[0];
      float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0);
      float32x4_t v29 = vrsqrteq_f32(v28);
      float32x4_t v30 = vmulq_f32(v29, vrsqrtsq_f32(v28, vmulq_f32(v29, v29)));
      int32x4_t v31 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v27.f32[0] != 0.0)), 0x1FuLL));
      v31.i32[3] = 0;
      float32x4_t v16 = vmulq_f32(v16, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v31), (int8x16_t)vmulq_f32(v30, vrsqrtsq_f32(v28, vmulq_f32(v30, v30))), _Q4));
      *((void *)v19 - 1) = v16.i64[0];
      *BOOL v19 = v16.i32[2];
      v19 += 3;
      --v21;
    }
    while (v21);
    *(_DWORD *)(a1 + 1120) = v18;
  }
}

void C3DParticleInitFrame(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 368);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitFrame_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ImageSequenceInitialFrame = C3DParticleSystemGetImageSequenceInitialFrame(*(void *)(a1 + 1040));
  ImageSequenceInitialFrameVariatioint n = C3DParticleSystemGetImageSequenceInitialFrameVariation(*(void *)(a1 + 1040));
  if (C3DParticleSystemGetImageSequenceFrameRate(*(void *)(a1 + 1040)) == 0.0
    && C3DParticleSystemGetImageSequenceFrameRateVariation(*(void *)(a1 + 1040)) == 0.0)
  {
    if (a2 < a3)
    {
      unint64_t v21 = (float *)(v6 + 4 * a2);
      unint64_t v22 = a3 - (unint64_t)a2;
      do
      {
        float v23 = ImageSequenceInitialFrame;
        if (ImageSequenceInitialFrameVariation != 0.0)
        {
          unsigned int v24 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
          *(_DWORD *)(a1 + 1120) = v24;
          float v23 = ImageSequenceInitialFrame
              + (float)((float)((float)((float)HIWORD(v24) * 0.000015259) + -0.5) * ImageSequenceInitialFrameVariation);
        }
        *v21++ = (float)(int)v23;
        --v22;
      }
      while (v22);
    }
  }
  else if (a2 < a3)
  {
    uint32x4_t v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ImageSequenceInitialFrame;
      if (ImageSequenceInitialFrameVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ImageSequenceInitialFrame
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ImageSequenceInitialFrameVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleInitFrameRate(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 376);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DParticleInitFrame_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float ImageSequenceFrameRate = C3DParticleSystemGetImageSequenceFrameRate(*(void *)(a1 + 1040));
  ImageSequenceFrameRateVariatioint n = C3DParticleSystemGetImageSequenceFrameRateVariation(*(void *)(a1 + 1040));
  if (a2 < a3)
  {
    uint32x4_t v17 = (float *)(v6 + 4 * a2);
    unint64_t v18 = a3 - (unint64_t)a2;
    do
    {
      float v19 = ImageSequenceFrameRate;
      if (ImageSequenceFrameRateVariation != 0.0)
      {
        unsigned int v20 = 214013 * *(_DWORD *)(a1 + 1120) + 2531011;
        *(_DWORD *)(a1 + 1120) = v20;
        float v19 = ImageSequenceFrameRate
            + (float)((float)((float)((float)HIWORD(v20) * 0.000015259) + -0.5) * ImageSequenceFrameRateVariation);
      }
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
}

void C3DParticleAnimatePropertyWithLife(void *a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4)
{
  uint64_t v7 = a1[35];
  uint64_t v8 = a4[1];
  int v9 = *((unsigned __int16 *)a4 + 1);
  uint64_t v10 = *((unsigned __int16 *)a4 + 2);
  uint64_t v11 = *((unsigned __int16 *)a4 + 3);
  uint64_t v12 = a1[*a4];
  uint64_t v29 = a1[34];
  if (v12)
  {
    uint64_t v13 = (float32x4_t *)(v12 + v11);
    unsigned int v28 = *((unsigned __int16 *)a4 + 2);
  }
  else
  {
    ConstantDataPtrForSemantiCC_SHA256_CTX c = C3DParticleSystemGetConstantDataPtrForSemantic(a1[130], *((unsigned __int16 *)a4 + 4));
    if (!ConstantDataPtrForSemantic) {
      return;
    }
    uint64_t v13 = (float32x4_t *)ConstantDataPtrForSemantic;
    unsigned int v28 = 0;
  }
  unsigned int v15 = (__n128 *)v13;
  if (v8 != 255) {
    unsigned int v15 = (__n128 *)(a1[v8] + v11);
  }
  ParticleLifeSpaint n = C3DParticleSystemGetParticleLifeSpan(a1[130]);
  v18.i32[0] = 1.0;
  float v19 = 1.0 / ParticleLifeSpan;
  if (v9 == 1)
  {
    unsigned int v20 = a3 - a2;
    if (a3 > a2)
    {
      unint64_t v21 = (float *)(v29 + 4 * a2);
      unint64_t v22 = (float *)(v7 + 4 * a2);
      do
      {
        if (v7) {
          float v19 = *v22;
        }
        float v23 = *v21++;
        __evaluateAnimationFloat(v13->f32, (float *)v15, (uint64_t)a4, 1.0 - (float)(v23 * v19));
        unsigned int v15 = (__n128 *)((char *)v15 + v10);
        uint64_t v13 = (float32x4_t *)((char *)v13 + v28);
        ++v22;
        --v20;
      }
      while (v20);
    }
  }
  else if (v9 == 3 && v10 == 16)
  {
    unsigned int v24 = a3 - a2;
    if (a3 > a2)
    {
      unsigned int v25 = (float *)(v29 + 4 * a2);
      float v26 = (float *)(v7 + 4 * a2);
      do
      {
        if (v7) {
          float v19 = *v26;
        }
        float v27 = *v25++;
        __evaluateAnimationFloat3(v13, v15, (uint64_t)a4, 1.0 - (float)(v27 * v19), v18, v17);
        uint64_t v13 = (float32x4_t *)((char *)v13 + v28);
        ++v15;
        ++v26;
        --v24;
      }
      while (v24);
    }
  }
}

float *__evaluateAnimationFloat(float *result, float *a2, uint64_t a3, float a4)
{
  float v5 = *result;
  float v11 = *result;
  uint64_t v6 = *(void *)(a3 + 56);
  if (v6)
  {
    float v7 = fminf(fmaxf(a4, 0.0), 1.0) * *(float *)(a3 + 52);
    float v8 = *(float *)(v6 + 4 * v7);
    if (*(unsigned char *)(a3 + 49)) {
      float v8 = (float)((float)(v7 - (float)v7) * *(float *)(v6 + 4 * (v7 + 1)))
    }
         + (float)((float)(1.0 - (float)(v7 - (float)v7)) * v8);
    float v9 = v5 * v8;
    float v10 = v5 + v8;
    if (!*(unsigned char *)(a3 + 50)) {
      float v10 = v9;
    }
  }
  else if (*(unsigned char *)(a3 + 50))
  {
    float result = (float *)C3DAnimationEvaluate(*(void *)(a3 + 16));
    float v10 = v11;
  }
  else
  {
    float result = (float *)C3DAnimationEvaluate(*(void *)(a3 + 16));
    float v10 = 0.0 * v5;
  }
  *a2 = v10;
  return result;
}

float32x4_t __evaluateAnimationFloat3(float32x4_t *a1, __n128 *a2, uint64_t a3, float a4, int8x16_t a5, int8x16_t a6)
{
  uint64_t v7 = *(void *)(a3 + 56);
  if (v7)
  {
    a5.i32[1] = 0;
    *(float *)a6.i32 = fminf(fmaxf(a4, 0.0), 1.0) * *(float *)(a3 + 52);
    float32x4_t v8 = *(float32x4_t *)(v7 + 16 * *(float *)a6.i32);
    if (*(unsigned char *)(a3 + 49))
    {
      a6 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v7 + 16 * (*(float *)a6.i32 + 1)), *(float *)a6.i32 - (float)*(float *)a6.i32), v8, 1.0 - (float)(*(float *)a6.i32 - (float)*(float *)a6.i32));
      float32x4_t v8 = (float32x4_t)a6;
    }
    a5.i32[0] = 0;
    a6.i8[0] = *(unsigned char *)(a3 + 50);
    float32x4_t result = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(a6, a5), 0), (int8x16_t)vmulq_f32(*a1, v8), (int8x16_t)vaddq_f32(*a1, v8));
  }
  else if (*(unsigned char *)(a3 + 50))
  {
    __n128 v13 = *(__n128 *)a1;
    C3DAnimationEvaluate(*(void *)(a3 + 16));
    float32x4_t result = (float32x4_t)v13;
  }
  else
  {
    v12.i32[2] = 0;
    v12.i64[0] = 0;
    float32x4_t v11 = *a1;
    C3DAnimationEvaluate(*(void *)(a3 + 16));
    float32x4_t v10 = v12;
    v10.i32[3] = 0;
    float32x4_t result = vmulq_f32(v11, v10);
  }
  result.i32[3] = a2->n128_i32[3];
  *a2 = (__n128)result;
  return result;
}

void C3DParticleAnimatePropertyWithDistance(uint64_t a1, unsigned int a2, unsigned int a3, float *a4, float32x4_t a5, double a6, int8x16_t a7)
{
  uint64_t v11 = *(void *)(a1 + 256);
  uint64_t v12 = *((unsigned __int8 *)a4 + 1);
  uint64_t v13 = *((unsigned __int16 *)a4 + 2);
  uint64_t v14 = *((unsigned __int16 *)a4 + 3);
  uint64_t v15 = *(void *)(a1 + 8 * *(unsigned __int8 *)a4);
  if (v15)
  {
    float32x4_t v16 = (float32x4_t *)(v15 + v14);
    uint64_t v17 = *((unsigned __int16 *)a4 + 2);
  }
  else
  {
    float32x4_t v30 = a5;
    uint64_t v18 = *(void *)(a1 + 256);
    ConstantDataPtrForSemantiCC_SHA256_CTX c = C3DParticleSystemGetConstantDataPtrForSemantic(*(void *)(a1 + 1040), *((unsigned __int16 *)a4 + 4));
    a5 = v30;
    if (!ConstantDataPtrForSemantic) {
      return;
    }
    uint64_t v11 = v18;
    float32x4_t v16 = (float32x4_t *)ConstantDataPtrForSemantic;
    uint64_t v17 = 0;
  }
  unsigned int v20 = (__n128 *)v16;
  if (v12 != 255) {
    unsigned int v20 = (__n128 *)(*(void *)(a1 + 8 * v12) + v14);
  }
  BOOL v21 = a3 >= a2;
  unsigned int v22 = a3 - a2;
  if (v22 != 0 && v21)
  {
    float v23 = a4[18];
    float v24 = a4[17] * a4[17];
    unsigned int v25 = (float32x4_t *)(v11 + 16 * a2);
    float32x4_t v31 = a5;
    do
    {
      float32x4_t v26 = *v25++;
      float32x4_t v27 = vsubq_f32(v26, a5);
      float32x4_t v28 = vmulq_f32(v27, v27);
      int8x16_t v29 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1)));
      __evaluateAnimationGeneric(v16, v20, (uint64_t)a4, vmlas_n_f32(v23, v24, *(float *)v29.i32), v29, a7);
      a5 = v31;
      unsigned int v20 = (__n128 *)((char *)v20 + v13);
      float32x4_t v16 = (float32x4_t *)((char *)v16 + v17);
      --v22;
    }
    while (v22);
  }
}

void __evaluateAnimationGeneric(float32x4_t *a1, __n128 *a2, uint64_t a3, float a4, int8x16_t a5, int8x16_t a6)
{
  int v7 = *(unsigned __int16 *)(a3 + 2);
  switch(v7)
  {
    case 4:
      uint64_t v8 = *(void *)(a3 + 56);
      if (v8)
      {
        a5.i32[1] = 0;
        *(float *)a6.i32 = fminf(fmaxf(a4, 0.0), 1.0) * *(float *)(a3 + 52);
        float32x4_t v9 = *(float32x4_t *)(v8 + 16 * *(float *)a6.i32);
        if (*(unsigned char *)(a3 + 49))
        {
          a6 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v8 + 16 * (*(float *)a6.i32 + 1)), *(float *)a6.i32 - (float)*(float *)a6.i32), v9, 1.0 - (float)(*(float *)a6.i32 - (float)*(float *)a6.i32));
          float32x4_t v9 = (float32x4_t)a6;
        }
        a5.i32[0] = 0;
        a6.i8[0] = *(unsigned char *)(a3 + 50);
        float32x4_t v10 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(a6, a5), 0), (int8x16_t)vmulq_f32(*a1, v9), (int8x16_t)vaddq_f32(*a1, v9));
      }
      else if (*(unsigned char *)(a3 + 50))
      {
        float32x4_t v14 = *a1;
        C3DAnimationEvaluate(*(void *)(a3 + 16));
        float32x4_t v10 = v14;
        v10.i32[3] = 0;
      }
      else
      {
        v13.i32[2] = 0;
        v13.i64[0] = 0;
        float32x4_t v12 = *a1;
        C3DAnimationEvaluate(*(void *)(a3 + 16));
        float32x4_t v11 = v13;
        v11.i32[3] = 0;
        float32x4_t v10 = vmulq_f32(v12, v11);
      }
      *a2 = (__n128)v10;
      break;
    case 3:
      __evaluateAnimationFloat3(a1, a2, a3, a4, a5, a6);
      break;
    case 1:
      __evaluateAnimationFloat(a1->f32, (float *)a2, a3, a4);
      break;
  }
}

void C3DParticleAnimatePropertyWithOtherProperty(uint64_t a1, unsigned int a2, unsigned int a3, float *a4, double a5, int8x16_t a6, int8x16_t a7)
{
  uint64_t v11 = *((unsigned __int8 *)a4 + 1);
  uint64_t v12 = *((unsigned __int16 *)a4 + 2);
  uint64_t v13 = *((unsigned __int16 *)a4 + 3);
  uint64_t v14 = *(void *)(a1 + 8 * *(unsigned __int8 *)a4);
  if (v14)
  {
    uint64_t v15 = (float32x4_t *)(v14 + v13);
    unsigned int v16 = *((unsigned __int16 *)a4 + 2);
  }
  else
  {
    ConstantDataPtrForSemantiCC_SHA256_CTX c = C3DParticleSystemGetConstantDataPtrForSemantic(*(void *)(a1 + 1040), *((unsigned __int16 *)a4 + 4));
    if (!ConstantDataPtrForSemantic) {
      return;
    }
    uint64_t v15 = (float32x4_t *)ConstantDataPtrForSemantic;
    unsigned int v16 = 0;
  }
  uint64_t v18 = (__n128 *)v15;
  if (v11 != 255) {
    uint64_t v18 = (__n128 *)(*(void *)(a1 + 8 * v11) + v13);
  }
  int v19 = *((unsigned __int16 *)a4 + 14);
  uint64_t v20 = *((unsigned __int16 *)a4 + 15);
  BOOL v21 = (float32x4_t *)(*(void *)(a1 + 8 * *((unsigned __int8 *)a4 + 26))
                      + *((unsigned __int16 *)a4 + 16)
                      + v20 * a2);
  float v22 = a4[17];
  float v23 = a4[18];
  switch(v19)
  {
    case 1:
      _CF = a3 >= a2;
      unsigned int v33 = a3 - a2;
      if (v33 != 0 && _CF)
      {
        uint64_t v34 = v16;
        do
        {
          __evaluateAnimationGeneric(v15, v18, (uint64_t)a4, v23 + (float)(v22 * v21->f32[0]), a6, a7);
          uint64_t v18 = (__n128 *)((char *)v18 + v12);
          uint64_t v15 = (float32x4_t *)((char *)v15 + v34);
          BOOL v21 = (float32x4_t *)((char *)v21 + v20);
          --v33;
        }
        while (v33);
      }
      break;
    case 3:
      if (v20 == 16)
      {
        _CF = a3 >= a2;
        unsigned int v35 = a3 - a2;
        if (v35 != 0 && _CF)
        {
          uint64_t v36 = v16;
          do
          {
            float32x4_t v37 = *v21++;
            float32x4_t v38 = vmulq_f32(v37, v37);
            float32x4_t v39 = vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1));
            __evaluateAnimationGeneric(v15, v18, (uint64_t)a4, v23 + (float)(v22 * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), v39).f32[0])), (int8x16_t)v39, a7);
            uint64_t v18 = (__n128 *)((char *)v18 + v12);
            uint64_t v15 = (float32x4_t *)((char *)v15 + v36);
            --v35;
          }
          while (v35);
        }
      }
      break;
    case 4:
      _CF = a3 >= a2;
      unsigned int v25 = a3 - a2;
      if (v25 != 0 && _CF)
      {
        uint64_t v26 = v16;
        __asm { FMOV            V0.4S, #0.25 }
        float32x4_t v40 = _Q0;
        do
        {
          int8x16_t v31 = (int8x16_t)vmulq_f32(*v21, v40);
          int8x16_t v32 = vextq_s8(v31, v31, 8uLL);
          __evaluateAnimationGeneric(v15, v18, (uint64_t)a4, v23 + (float)(v22 * vaddv_f32(vadd_f32(*(float32x2_t *)v31.i8, *(float32x2_t *)v32.i8))), v32, a7);
          uint64_t v18 = (__n128 *)((char *)v18 + v12);
          uint64_t v15 = (float32x4_t *)((char *)v15 + v26);
          BOOL v21 = (float32x4_t *)((char *)v21 + v20);
          --v25;
        }
        while (v25);
      }
      break;
  }
}

BOOL __lightNeedsClustering(uint64_t a1)
{
  if (C3DLightTypeSupportsShadow(a1)) {
    int CastsShadow = C3DLightGetCastsShadow(a1);
  }
  else {
    int CastsShadow = 0;
  }
  if (C3DLightHasValidIES(a1) || ((C3DLightHasValidGobo(a1) | CastsShadow) & 1) != 0) {
    return 0;
  }
  int Type = C3DLightGetType(a1);
  if (Type != 2 && Type != 3)
  {
    if (Type == 4) {
      return C3DLightGetProbeType(a1) != 0;
    }
    return 0;
  }
  return C3DLightGetAttenuationEndDistance(a1) > 0.0;
}

uint64_t __isLightGlobal(uint64_t a1)
{
  int Type = C3DLightGetType(a1);
  if ((Type & 0xFFFFFFFB) == 0) {
    return 0;
  }
  int v3 = Type - 1;
  uint64_t result = 1;
  switch(v3)
  {
    case 0:
    case 5:
      return result;
    case 1:
    case 2:
      if (C3DLightGetAttenuationEndDistance(a1) <= 0.0) {
        goto LABEL_9;
      }
      goto LABEL_4;
    default:
LABEL_4:
      if (C3DLightTypeSupportsShadow(a1)) {
        int CastsShadow = C3DLightGetCastsShadow(a1);
      }
      else {
        int CastsShadow = 0;
      }
      if (C3DLightHasValidIES(a1)) {
LABEL_9:
      }
        uint64_t result = 1;
      else {
        uint64_t result = C3DLightHasValidGobo(a1) | CastsShadow;
      }
      break;
  }
  return result;
}

uint64_t __appendGlobalLight(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = (uint64_t)C3DNodeGetLight(a1);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t result = __isLightGlobal(result);
    if (result)
    {
      uint64_t v7 = *(unsigned int *)(a3 + 568);
      if (v7 <= 7)
      {
        *(_DWORD *)(a3 + 4 * v7 + 504) = a2;
        uint64_t result = C3DLightGetProgramHashCode(v6);
        *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 568))++ + 536) = result;
      }
    }
  }
  return result;
}

void *__C3DLightingSystemGetGlobalLightHashCodeForCaching_block_invoke(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = (void *)result[6];
  if (*(void *)v1 == v2[67]
    && *(void *)(v1 + 8) == v2[68]
    && *(void *)(v1 + 16) == v2[69]
    && *(void *)(v1 + 24) == v2[70])
  {
    char v8 = 0;
  }
  else
  {
    uint64_t v6 = v2 + 67;
    long long v7 = v6[1];
    *(_OWORD *)uint64_t v1 = *v6;
    *(_OWORD *)(v1 + 16) = v7;
    char v8 = 1;
  }
  *(unsigned char *)(*(void *)(result[4] + 8) + 24) = v8;
  return result;
}

void *_mm_realloc(void *a1, size_t a2, size_t a3, size_t alignment)
{
  memptr = 0;
  malloc_type_posix_memalign(&memptr, alignment, a3, 0x128F7C20uLL);
  if (a2) {
    memcpy(memptr, a1, a2);
  }
  free(a1);
  return memptr;
}

void __reserveData(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= 8)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __reserveData_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  else if (a2 == 4)
  {
    C3DLightProbesSystemSetProbesCount(*(void *)(a1 + 24), a3 + 1);
  }
  uint64_t v14 = a1 + 4 * a2;
  unsigned int v17 = *(_DWORD *)(v14 + 96);
  unsigned int v16 = (_DWORD *)(v14 + 96);
  unsigned int v15 = v17;
  if (v17 <= a3)
  {
    if (v15) {
      size_t v18 = 2 * v15;
    }
    else {
      size_t v18 = 8;
    }
    int v19 = (void **)(a1 + 8 * a2);
    BOOL v21 = v19 + 17;
    uint64_t v20 = v19[17];
    float v22 = v19 + 25;
    if (v20)
    {
      float32x4_t *v21 = malloc_type_realloc(v20, 8 * v18, 0x2004093837F09uLL);
      v19[33] = malloc_type_realloc(v19[33], 8 * v18, 0x100004000313F17uLL);
      *float v22 = malloc_type_realloc(*v22, 8 * v18, 0x2004093837F09uLL);
      v19[41] = malloc_type_realloc(v19[41], v18, 0x100004077774924uLL);
      v19[49] = malloc_type_realloc(v19[49], v18, 0x100004077774924uLL);
      switch(a2)
      {
        case 2u:
          *(void *)(a1 + 456) = _mm_realloc(*(void **)(a1 + 456), 16 * *v16, 16 * v18, 0x10uLL);
          break;
        case 3u:
          *(void *)(a1 + 472) = _mm_realloc(*(void **)(a1 + 472), 48 * *v16, 48 * v18, 0x10uLL);
          break;
        case 5u:
          *(void *)(a1 + 480) = _mm_realloc(*(void **)(a1 + 480), 80 * *v16, 80 * v18, 0x10uLL);
          break;
        case 6u:
          *(void *)(a1 + 464) = _mm_realloc(*(void **)(a1 + 464), 16 * *v16, 16 * v18, 0x10uLL);
          break;
        default:
          break;
      }
    }
    else
    {
      float32x4_t *v21 = malloc_type_calloc(8uLL, v18, 0xBAAE0A04uLL);
      v19[33] = malloc_type_calloc(8 * v18, 1uLL, 0xC11025D1uLL);
      *float v22 = malloc_type_calloc(8uLL, v18, 0x64B0EBBDuLL);
      v19[41] = malloc_type_calloc(1uLL, v18, 0x445D957EuLL);
      v19[49] = malloc_type_calloc(1uLL, v18, 0xDFE8E096uLL);
      switch(a2)
      {
        case 2u:
          float v23 = (void **)(a1 + 456);
          goto LABEL_21;
        case 3u:
          float v23 = (void **)(a1 + 472);
          size_t v24 = 48 * v18;
          unsigned int v25 = -288221644;
          goto LABEL_22;
        case 5u:
          float v23 = (void **)(a1 + 480);
          size_t v24 = 80 * v18;
          unsigned int v25 = 1112007933;
          goto LABEL_22;
        case 6u:
          float v23 = (void **)(a1 + 464);
LABEL_21:
          size_t v24 = 16 * v18;
          unsigned int v25 = 1159420904;
LABEL_22:
          malloc_type_posix_memalign(v23, 0x10uLL, v24, v25 | 0x100004000000000);
          break;
        default:
          break;
      }
    }
    _DWORD *v16 = v18;
  }
}

void C3DLightingSystemAddToLightsWithTechnique(uint64_t a1, void *value)
{
  int v3 = (__CFSet **)(a1 + 116496);
  CFArrayRef Mutable = *(__CFSet **)(a1 + 116496);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 1, MEMORY[0x263EFFFA0]);
    *int v3 = Mutable;
  }

  CFSetAddValue(Mutable, value);
}

void C3DLightingSystemRemoveFromLightsWithTechnique(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(__CFSet **)(a1 + 116496);
  if (v2) {
    CFSetRemoveValue(v2, a2);
  }
}

void __updateWorldData(uint64_t *a1, int a2, unsigned int a3, float32x4_t *a4, __n128 *a5)
{
  WorldMatrix = C3DNodeGetWorldMatrix(a4);
  float AttenuationEndDistance = C3DLightGetAttenuationEndDistance((uint64_t)a5);
  uint64_t v11 = &a1[a2];
  *(void *)(v11[33] + 8 * a3) = C3DLightGetCategoryBitMask((uint64_t)a5);
  if (C3DLightIsBlack((uint64_t)a5) || C3DLightGetBaked((uint64_t)a5)) {
    *(void *)(v11[33] + 8 * a3) = 0;
  }
  switch(a2)
  {
    case 2:
      uint64_t v12 = a1[57];
      float32x4_t v13 = WorldMatrix[3];
      v13.f32[3] = AttenuationEndDistance;
      goto LABEL_21;
    case 3:
      float v14 = C3DLightGetSpotOuterAngle((uint64_t)a5) / 180.0 * 3.14159265 * 0.5;
      if (AttenuationEndDistance <= 0.0) {
        float v15 = INFINITY;
      }
      else {
        float v15 = AttenuationEndDistance;
      }
      uint64_t v16 = a1[59] + 48 * a3;
      float32x4_t v58 = WorldMatrix[2];
      float32x4_t v60 = WorldMatrix[3];
      float v17 = tanf(v14);
      int32x4_t v18 = (int32x4_t)vmulq_f32(v58, v58);
      v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
      float32x2_t v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
      float32x2_t v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
      float32x4_t v21 = vmulq_n_f32(vnegq_f32(v58), vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
      *(float *)&unsigned int v22 = (float)(v17 * v17) + 1.0;
      float32x2_t v23 = vrsqrte_f32((float32x2_t)v22);
      float32x2_t v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v22, vmul_f32(v23, v23)));
      *(float32x4_t *)uint64_t v16 = v60;
      *(float32x4_t *)(v16 + 16) = v21;
      *(float *)(v16 + 32) = v15;
      *(float *)(v16 + 36) = v15 * v17;
      *(_DWORD *)(v16 + 40) = vmul_f32(v24, vrsqrts_f32((float32x2_t)v22, vmul_f32(v24, v24))).u32[0];
      *(float *)(v16 + 44) = v17;
      break;
    case 4:
      if (C3DLightGetProbeType((uint64_t)a5))
      {
        unsigned int v25 = scn_default_log();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          __updateWorldData_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
        }
      }
      C3DLightProbesSystemSetProbeData(a1[3], a3, a4, (uint64_t)a5);
      break;
    case 5:
      if (C3DLightGetProbeType((uint64_t)a5) != 1)
      {
        unsigned int v33 = scn_default_log();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
          __updateWorldData_cold_2(v33, v34, v35, v36, v37, v38, v39, v40);
        }
      }
      __n128 ProbeExtents = C3DLightGetProbeExtents(a5);
      v42.i64[0] = 0x3F0000003F000000;
      v42.i64[1] = 0x3F0000003F000000;
      float32x4_t v43 = vmulq_f32((float32x4_t)ProbeExtents, v42);
      float32x4_t v45 = *WorldMatrix;
      float32x4_t v44 = WorldMatrix[1];
      float32x4_t v46 = WorldMatrix[2];
      float32x4_t v48 = vaddq_f32(WorldMatrix[3], vmlaq_f32(vmlaq_f32(vmulq_f32(v44, (float32x4_t)0), (float32x4_t)0, *WorldMatrix), (float32x4_t)0, v46));
      float v47 = 1.0;
      v48.i32[3] = 1.0;
      int32x4_t v49 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), vnegq_f32(v44)), v46, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL));
      float32x4_t v50 = vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v49, v49), (int8x16_t)v49, 0xCuLL));
      uint64_t v51 = a1[60] + 80 * a3;
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0] < 0.0)float v47 = -1.0; {
      float32x4_t v52 = vmulq_f32(v45, v45);
      }
      float32x4_t v53 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1)));
      float32x4_t v54 = vmulq_f32(v44, v44);
      v53.f32[0] = sqrtf(v53.f32[0]);
      float32x4_t v55 = vmulq_f32(v46, v46);
      v53.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), vaddq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1))).f32[0]);
      v53.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).f32[0]);
      float32x4_t v56 = vmulq_n_f32(v53, v47);
      float32x4_t v57 = vmulq_f32(v43, v56);
      v57.i32[3] = 0;
      *(float32x4_t *)uint64_t v51 = v48;
      *(float32x4_t *)(v51 + 16) = vdivq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0));
      *(float32x4_t *)(v51 + 32) = vdivq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1));
      *(float32x4_t *)(v51 + 48) = vdivq_f32(v46, (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2));
      *(float32x4_t *)(v51 + 64) = v57;
      break;
    case 6:
      float32x4_t v13 = WorldMatrix[3];
      v13.i32[3] = 1120403456;
      uint64_t v12 = a1[58];
LABEL_21:
      *(float32x4_t *)(v12 + 16 * a3) = v13;
      break;
    default:
      return;
  }
}

void _C3DLightingSystemCFFinalize(uint64_t a1)
{
  uint64_t v2 = a1 + 116488;
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFRelease(*(CFTypeRef *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 496));
  CFRelease(*(CFTypeRef *)(a1 + 488));
  if (*(void *)v2)
  {
    CFRelease(*(CFTypeRef *)v2);
    *(void *)uint64_t v2 = 0;
  }
  int v3 = *(const void **)(v2 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(v2 + 8) = 0;
  }
  uint64_t v4 = a1 + 392;
  uint64_t v5 = -64;
  do
  {
    free(*(void **)(v4 + v5 - 192));
    free(*(void **)(v4 + v5 - 128));
    free(*(void **)(v4 + v5 - 64));
    free(*(void **)(v4 + v5));
    free(*(void **)(v4 + v5 + 64));
    v5 += 8;
  }
  while (v5);
  free(*(void **)(a1 + 456));
  free(*(void **)(a1 + 464));
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 480));
  uint64_t v6 = 0;
  uint64_t v7 = a1 + 117008;
  do
  {
    for (uint64_t i = 0; i != 1536; i += 384)
    {
      uint64_t v9 = *(const void **)(v7 + i);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(v7 + i) = 0;
      }
    }
    ++v6;
    v7 += 1568;
  }
  while (v6 != 8);
}

CFStringRef _C3DLightingSystemCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DLightingSystem %p>", a1);
}

CFStringRef _C3DLightingSystemCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DLightingSystem %p>", a1);
}

uint64_t __lightOptimizedType(uint64_t a1)
{
  int Type = C3DLightGetType(a1);
  float AttenuationEndDistance = C3DLightGetAttenuationEndDistance(a1);
  BOOL v5 = (LODWORD(AttenuationEndDistance) & 0x7FFFFFFF) == 0 || LODWORD(AttenuationEndDistance) == 2139095040;
  unsigned __int8 v6 = 0;
  switch(Type)
  {
    case 0:
      return v6;
    case 1:
      unsigned __int8 v6 = 1;
      break;
    case 2:
      if (v5) {
        unsigned __int8 v6 = 1;
      }
      else {
        unsigned __int8 v6 = 2;
      }
      break;
    case 3:
      unsigned __int8 v6 = 3;
      break;
    case 4:
      Probeint Type = C3DLightGetProbeType(a1);
      if (ProbeType)
      {
        if (ProbeType != 1) {
          goto LABEL_16;
        }
        unsigned __int8 v6 = 5;
      }
      else
      {
        unsigned __int8 v6 = 4;
      }
      break;
    case 5:
      if (v5) {
        unsigned __int8 v6 = 1;
      }
      else {
        unsigned __int8 v6 = 6;
      }
      break;
    case 6:
      unsigned __int8 v6 = 7;
      break;
    default:
LABEL_16:
      uint64_t v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        __lightOptimizedType_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      }
      unsigned __int8 v6 = 8;
      break;
  }
  return v6;
}

void C3DLightingSystemAdd(uint64_t a1, float32x4_t *a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef Light = C3DNodeGetLight((uint64_t)a2);
  if (Light)
  {
    uint64_t v13 = (__n128 *)Light;
    if ((C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)a2) & 1) == 0)
    {
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2))
      {
        uint64_t v14 = scn_default_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          C3DLightingSystemAdd_cold_2(v14, v15, v16);
        }
      }
      else
      {
        unsigned int v26 = __lightOptimizedType((uint64_t)v13);
        uint64_t v27 = a1 + 4 * v26;
        uint64_t v28 = *(unsigned int *)(v27 + 64);
        *(_DWORD *)(v27 + 64) = v28 + 1;
        __reserveData(a1, v26, v28);
        uint64_t v29 = a1 + 8 * v26;
        *(void *)(*(void *)(v29 + 136) + 8 * v28) = a2;
        *(void *)(*(void *)(v29 + 200) + 8 * v28) = v13;
        C3DLightSetRadianceProbeIndex((uint64_t)v13, v28 + 1);
        __updateWorldData((uint64_t *)a1, v26, v28, a2, v13);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, (const void *)(((int)v28 + 1) & 0xFFFFFFF | (v26 << 28)));
        if (__isLightGlobal((uint64_t)v13))
        {
          *(_DWORD *)(a1 + 568) = 0;
          *(_OWORD *)(a1 + 504) = 0u;
          *(_OWORD *)(a1 + 520) = 0u;
          CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)__appendGlobalLight, (void *)a1);
        }
        else if (!*(_DWORD *)(a1 + 572))
        {
          uint64_t v30 = *(void *)(a1 + 116424);
          if (v30) {
            C3DEnginePipelineInvalidateAllProgramHashCode(v30);
          }
        }
        _recomputeLocalLightsCount(a1);
        if (C3DLightGetTechnique((uint64_t)v13)) {
          C3DLightingSystemAddToLightsWithTechnique(a1, v13);
        }
      }
    }
  }
  else
  {
    float v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      __C3DLightDidChange_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    unsigned int v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v31 = 0;
      _os_log_impl(&dword_20B249000, v25, OS_LOG_TYPE_DEFAULT, "Warning: Should not register a node without light to the light system", v31, 2u);
    }
  }
}

uint64_t _recomputeLocalLightsCount(uint64_t result)
{
  uint64_t v1 = result;
  *(_DWORD *)(result + 572) = 0;
  for (uint64_t i = 2; i != 7; ++i)
  {
    uint64_t v3 = *(unsigned int *)(v1 + 4 * i + 64);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t result = *(void *)(*(void *)(v1 + 8 * i + 200) + v4);
        if (result)
        {
          uint64_t result = __lightNeedsClustering(result);
          if (result) {
            ++*(_DWORD *)(v1 + 572);
          }
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  return result;
}

void C3DLightingSystemRemove(uint64_t a1, const void *a2)
{
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (Value)
  {
    uint64_t v5 = Value;
    CFDictionaryRef Light = C3DNodeGetLight((uint64_t)a2);
    uint64_t v7 = (v5 & 0xFFFFFFF) - 1;
    uint64_t v8 = v5 >> 28;
    uint64_t v9 = a1 + 4 * v8;
    uint64_t v10 = (*(_DWORD *)(v9 + 64) - 1);
    *(_DWORD *)(v9 + 64) = v10;
    if (v7 < v10)
    {
      uint64_t v11 = (void *)(a1 + 8 * v8);
      uint64_t v12 = v11[17];
      uint64_t v13 = *(float32x4_t **)(v12 + 8 * v10);
      uint64_t v14 = *(void *)(v11[25] + 8 * v10);
      *(void *)(v12 + 8 * v7) = v13;
      *(void *)(v11[25] + 8 * v7) = v14;
      *(unsigned char *)(v11[41] + v7) = *(unsigned char *)(v11[41] + v10);
      *(unsigned char *)(v11[49] + v7) = *(unsigned char *)(v11[49] + v10);
      switch((int)v8)
      {
        case 2:
          uint64_t v15 = *(void *)(a1 + 456);
          goto LABEL_9;
        case 3:
          uint64_t v16 = *(void *)(a1 + 472);
          float v17 = (long long *)(v16 + 48 * v10);
          long long v18 = *v17;
          long long v19 = v17[2];
          uint64_t v20 = (_OWORD *)(v16 + 48 * v7);
          v20[1] = v17[1];
          v20[2] = v19;
          *uint64_t v20 = v18;
          break;
        case 4:
          C3DLightProbesSystemSetProbeData(*(void *)(a1 + 24), v7, v13, v14);
          break;
        case 5:
          uint64_t v21 = *(void *)(a1 + 480);
          uint64_t v22 = (_OWORD *)(v21 + 80 * v7);
          uint64_t v23 = (_OWORD *)(v21 + 80 * v10);
          *uint64_t v22 = *v23;
          long long v24 = v23[1];
          long long v25 = v23[2];
          long long v26 = v23[4];
          v22[3] = v23[3];
          v22[4] = v26;
          v22[1] = v24;
          v22[2] = v25;
          C3DLightSetRadianceProbeIndex(v14, (__int16)v5);
          break;
        case 6:
          uint64_t v15 = *(void *)(a1 + 464);
LABEL_9:
          *(_OWORD *)(v15 + 16 * v7) = *(_OWORD *)(v15 + 16 * v10);
          break;
        default:
          break;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v13, v5);
    }
    if (v8 == 4) {
      C3DLightProbesSystemSetProbesCount(*(void *)(a1 + 24), v10);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
    if (Light && __isLightGlobal((uint64_t)Light))
    {
      *(_DWORD *)(a1 + 568) = 0;
      *(_OWORD *)(a1 + 504) = 0u;
      *(_OWORD *)(a1 + 520) = 0u;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)__appendGlobalLight, (void *)a1);
    }
    _recomputeLocalLightsCount(a1);
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 496), a2);
    if (C3DLightGetTechnique((uint64_t)Light))
    {
      uint64_t v27 = *(__CFSet **)(a1 + 116496);
      if (v27)
      {
        CFSetRemoveValue(v27, Light);
      }
    }
  }
}

void C3DLightingSystemLightDidUpdate(uint64_t a1, const void *a2)
{
  if (__isLightGlobal((uint64_t)a2)) {
    goto LABEL_2;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 568);
  if (v4)
  {
    if (*(const void **)(*(void *)(a1 + (((unint64_t)*(unsigned int *)(a1 + 504) >> 25) & 0x78) + 200)
                        + 8 * ((*(_DWORD *)(a1 + 504) & 0xFFFFFFFu) - 1)) == a2)
      goto LABEL_2;
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v5;
      if (v4 - 1 == v5) {
        break;
      }
      uint64_t v7 = *(const void **)(*(void *)(a1
                                      + (((unint64_t)*(unsigned int *)(a1 + 508 + 4 * v5) >> 25) & 0x78)
                                      + 200)
                          + 8 * ((*(_DWORD *)(a1 + 508 + 4 * v5) & 0xFFFFFFFu) - 1));
      ++v5;
    }
    while (v7 != a2);
    if (v6 + 1 < v4)
    {
LABEL_2:
      *(_DWORD *)(a1 + 568) = 0;
      *(_OWORD *)(a1 + 504) = 0u;
      *(_OWORD *)(a1 + 520) = 0u;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)__appendGlobalLight, (void *)a1);
    }
  }
  uint64_t v8 = *(__CFSet **)(a1 + 488);

  CFSetAddValue(v8, a2);
}

uint64_t __LightsHaveChanged(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 0;
  do
  {
    uint64_t v4 = a1 + 4 * v2;
    uint64_t v5 = *(unsigned int *)(v4 + 64);
    uint64_t v14 = (unsigned int *)(v4 + 64);
    if (*(_DWORD *)(v4 + 64))
    {
      uint64_t v6 = 0;
      uint64_t v7 = a1 + 8 * v2;
      uint64_t v8 = (void *)(v7 + 200);
      uint64_t v9 = (void *)(v7 + 136);
      do
      {
        uint64_t v10 = *(__n128 **)(*v8 + 8 * v6);
        if (CFSetContainsValue(*(CFSetRef *)(a1 + 488), v10))
        {
          uint64_t v11 = *(float32x4_t **)(*v9 + 8 * v6);
          int v12 = __lightOptimizedType((uint64_t)v10);
          if (v2 == v12)
          {
            __updateWorldData((uint64_t *)a1, v2, v6, v11, v10);
          }
          else
          {
            C3DLightingSystemRemove(a1, v11);
            C3DLightingSystemAdd(a1, v11);
            uint64_t v5 = *v14;
            --v6;
          }
          v3 |= v12 == 0;
          C3DNodeUpdateCullingSystemMembership((uint64_t)v11);
        }
        ++v6;
      }
      while (v6 < v5);
    }
    ++v2;
  }
  while (v2 != 8);
  _recomputeLocalLightsCount(a1);
  return v3 & 1;
}

void __ComputeInfiniteLightSet(uint64_t a1)
{
  v16[1] = *MEMORY[0x263EF8340];
  v16[0] = 0;
  unsigned int v2 = *(_DWORD *)(a1 + 68);
  if (v2 >= 8) {
    uint64_t v3 = 8;
  }
  else {
    uint64_t v3 = v2;
  }
  if (v3)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 272) + 8 * v4);
      if (v7 == -1) {
        *((unsigned char *)v16 + v5++) = __runtimeIndex(a1, 1u, v4);
      }
      else {
        v6 |= v7;
      }
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    uint64_t v6 = 0;
    unsigned int v5 = 0;
  }
  *(void *)(a1 + 592) = v6;
  int v8 = *(_DWORD *)(a1 + 76) + *(_DWORD *)(a1 + 72);
  int v9 = -*(_DWORD *)(a1 + 88);
  if (v3) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v8 == v9;
  }
  if (v10 && (uint64_t v11 = (uint64_t *)(a1 + 116416), __ShouldForceLighting(*(void *)(a1 + 116416))))
  {
    DefaultLightuint64_t Node = C3DEngineContextGetDefaultLightNode(*v11);
    CFDictionaryRef Light = C3DNodeGetLight((uint64_t)DefaultLightNode);
    PointOfView = C3DEngineContextGetPointOfView(*v11);
    C3DEngineContextSynchronizeDefaultLight(*v11, PointOfView);
    *(_DWORD *)(a1 + 5732) = C3DLightGetProgramHashCode((uint64_t)Light);
    *(void *)(a1 + 4704) = Light;
    *(void *)(a1 + 2656) = DefaultLightNode;
    _ComputeRuntimeDataForIndex(a1, 0xFFu, 0);
    LOBYTE(v16[0]) = -1;
    *(void *)(a1 + 576) = v16[0];
    unsigned int v5 = 1;
  }
  else
  {
    *(void *)(a1 + 576) = v16[0];
  }
  *(_DWORD *)(a1 + 584) = v5;
  BOOL v15 = v8 == v9 && !*(void *)(a1 + 592) || v5 == 8;
  *(unsigned char *)(a1 + 588) = v15;
}

uint64_t __runtimeIndex(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = a1 + 8 * a2;
  unsigned __int8 v4 = *(unsigned char *)(*(void *)(v3 + 328) + a3);
  if (!v4)
  {
    int v6 = *(_DWORD *)(a1 + 608);
    if (v6 == 256)
    {
      if ((__runtimeIndex_done & 1) == 0)
      {
        __runtimeIndex_done = 1;
        uint64_t v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          __runtimeIndex_cold_1(v7);
        }
      }
      return 0;
    }
    else
    {
      unsigned __int8 v9 = a2;
      unsigned __int8 v4 = v6 + 1;
      *(_DWORD *)(a1 + 608) = v6 + 1;
      uint64_t v10 = a1 + 8 * a2;
      uint64_t v11 = *(void *)(*(void *)(v10 + 200) + 8 * a3);
      uint64_t v12 = *(void *)(*(void *)(v10 + 136) + 8 * a3);
      uint64_t v13 = a1 + 608 + 8 * v4;
      *(void *)(v13 + 2056) = v11;
      *(void *)(v13 + 8) = v12;
      *(unsigned char *)(*(void *)(v3 + 328) + a3) = v4;
      *(_DWORD *)(a1 + 608 + 4 * v4 + 4104) = C3DLightGetProgramHashCode(v11);
      _ComputeRuntimeDataForIndex(a1, v4, a3 & 0xFFFFFFF | (v9 << 28));
    }
  }
  return v4;
}

void _ComputeRuntimeDataForIndex(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned __int8 v4 = (float32x4_t *)(a1 + 116336);
  uint64_t v6 = a1 + 608 + 432 * a2;
  uint64_t v7 = v6 + 5136;
  uint64_t v8 = a1 + 608 + 8 * a2;
  unsigned __int8 v9 = *(float32x4_t **)(v8 + 8);
  uint64_t v10 = *(float **)(v8 + 2056);
  uint64_t v11 = (_DWORD *)(v6 + 5248);
  *(_DWORD *)(v6 + 5248) = 0;
  key = v9;
  WorldMatrix = C3DNodeGetWorldMatrix(v9);
  memset(&v134, 0, sizeof(v134));
  C3DMatrix4x4Mult((uint64_t)WorldMatrix, v4, &v134);
  int Type = C3DLightGetType((uint64_t)v10);
  int HasValidGobo = C3DLightHasValidGobo((uint64_t)v10);
  int UsesDeferredShadows = C3DLightGetUsesDeferredShadows((uint64_t)v10);
  int CastsShadow = C3DLightGetCastsShadow((uint64_t)v10);
  int v16 = C3DLightGetUsesModulatedMode((uint64_t)v10) & (HasValidGobo | UsesDeferredShadows ^ 1);
  if ((v16 & 1) == 0)
  {
    C3DLightGetColorModulatedByIntensity((uint64_t)v10, v17, v18, v19, v20, v21, v22, v23);
    *(void *)uint64_t v7 = v24;
    *(void *)(v7 + 8) = v25;
    *v11 |= 0x40u;
  }
  if (Type > 6)
  {
LABEL_9:
    if (Type < 2) {
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  if (((1 << Type) & 0x6C) == 0)
  {
    if (Type != 1) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  simd_float4 v26 = v134.columns[3];
  *v11 |= 1u;
  uint64_t v27 = (simd_float4 *)(a1 + 432 * a2);
  v26.i32[3] = v27[360].i32[3];
  v27[360] = v26;
  *(float *)(v7 + 28) = C3DLightGetAttenuationEndDistance((uint64_t)v10);
  if (((1 << Type) & 0x68) != 0)
  {
LABEL_8:
    int32x4_t v28 = (int32x4_t)vmulq_f32((float32x4_t)v134.columns[2], (float32x4_t)v134.columns[2]);
    v28.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v28, 2), vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v28.i8, 1))).u32[0];
    float32x2_t v29 = vrsqrte_f32((float32x2_t)v28.u32[0]);
    float32x2_t v30 = vmul_f32(v29, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(v29, v29)));
    float32x4_t v31 = vmulq_n_f32((float32x4_t)v134.columns[2], vmul_f32(v30, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(v30, v30))).f32[0]);
    *v11 |= 2u;
    uint64_t v32 = a1 + 432 * a2;
    *(_DWORD *)(v32 + 5784) = v31.i32[2];
    *(void *)(v32 + 5776) = v31.i64[0];
    goto LABEL_9;
  }
LABEL_10:
  *(float *)&long long v33 = C3DLightComputeDistanceAttenuations(v10, 0, v4[4].f32[0]);
  *(_OWORD *)(a1 + 432 * a2 + 5824) = v33;
  if (Type == 3) {
    char v34 = v16;
  }
  else {
    char v34 = 1;
  }
  if (v34)
  {
    if (Type == 5)
    {
      *(float *)&unsigned int v35 = 1.0 / (C3DLightGetIESSpotAngle((uint64_t)v10) / 180.0 * 3.14159265);
      uint64_t v36 = a1 + 432 * a2;
      *(_DWORD *)(v36 + 5848) = 0;
      *(void *)(v36 + 5840) = v35;
    }
  }
  else
  {
    C3DLightComputeSpotAttenuations((uint64_t)v10);
    *(_OWORD *)(a1 + 432 * a2 + 5840) = v37;
  }
LABEL_17:
  int v38 = C3DLightTypeSupportsShadow((uint64_t)v10);
  if (((CastsShadow ^ 1 | UsesDeferredShadows) & 1) == 0 && v38)
  {
    *v11 |= 0x10u;
    uint64_t v39 = *(void *)(a1 + 8 * (a3 >> 28) + 392);
    int v40 = *(unsigned __int8 *)(v39 + (a3 & 0xFFFFFFF));
    unsigned int v41 = a2;
    if (*(unsigned char *)(v39 + (a3 & 0xFFFFFFF)))
    {
      char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(v4[5].i64[0]);
      simd_float4x4 v140 = __invert_f4(*(simd_float4x4 *)v4->f32);
      __n128 v114 = (__n128)v140.columns[1];
      __n128 v116 = (__n128)v140.columns[0];
      __n128 v111 = (__n128)v140.columns[3];
      __n128 v112 = (__n128)v140.columns[2];
      if (!C3DLightSupportsShadowCascades((uint64_t)v10))
      {
        uint64_t v51 = 1;
LABEL_31:
        float32x4_t v83 = (__n128 *)(a1 + 1568 * (v40 - 1) + 116944);
        float32x4_t v84 = (_OWORD *)(a1 + 432 * a2 + 5920);
        do
        {
          *(double *)&long long v85 = _computeShadowMatrix(CoordinatesSystemOptions, v83[-7], v83[-6], v83[-5], v83[-4], v83[-3], v83[-2], v83[-1], *v83, v43, v44, v45, v46, v47, v48, v49, v116, v114, v112,
                              v111);
          *(v84 - 3) = v85;
          *(v84 - 2) = v86;
          *(v84 - 1) = v87;
          _OWORD *v84 = v88;
          v83 += 24;
          v84 += 4;
          --v51;
        }
        while (v51);
        goto LABEL_33;
      }
      ShadowCascadeCFIndex Count = C3DLightGetShadowCascadeCount((uint64_t)v10);
      if (ShadowCascadeCount)
      {
        uint64_t v51 = ShadowCascadeCount;
        goto LABEL_31;
      }
    }
LABEL_33:
    CFNumberRef Value = (__CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), key);
    if (Value)
    {
      *(void *)(a1 + 432 * v41 + 6144) = C3DEngineContextGetTextureWithName(v4[5].i64[0], Value);
    }
    else if ((_ComputeRuntimeData_done & 1) == 0)
    {
      _ComputeRuntimeData_done = 1;
      float32x4_t v90 = scn_default_log();
      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
        _ComputeRuntimeDataForIndex_cold_1((uint64_t *)(a1 + 40), v90);
      }
    }
    float32x4_t v91 = (void *)(a1 + 432 * v41);
    v91[769] = C3DTextureSamplerDepthCompare();
    uint64_t ShadowColor = C3DLightGetShadowColor((uint64_t)v10);
    v91[767] = v93;
    v91[766] = ShadowColor;
    if (C3DLightGetEffectiveShadowSampleCount((uint64_t)v10) >= 2)
    {
      *v11 |= 0x20u;
      RealShadowMapdouble Size = C3DLightGetRealShadowMapSize((uint64_t)v10);
      Shadowfloat Radius = C3DLightGetShadowRadius((uint64_t)v10);
      float v95 = *(float *)&RealShadowMapSize.i32[1];
      if (*(float *)RealShadowMapSize.i32 > *(float *)&RealShadowMapSize.i32[1]) {
        float v95 = *(float *)RealShadowMapSize.i32;
      }
      if (v95 < 1.0) {
        float v95 = 1.0;
      }
      *(float *)(a1 + 432 * v41 + 5860) = ShadowRadius / v95;
    }
    return;
  }
  if (HasValidGobo)
  {
    uint64_t Gobo = C3DLightGetGobo((uint64_t)v10, 0);
    uint64_t v133 = 0;
    TextureForuint64_t EffectSlot = C3DEngineContextGetTextureForEffectSlot((uint64_t *)v4[5].i64[0], Gobo, &v133);
    uint64_t v54 = a1 + 432 * a2;
    *(void *)(v54 + 6144) = TextureForEffectSlot;
    *(void *)(v54 + 6152) = v133;
    C3DEffectSlotSetTextureFromImageProxy(Gobo, TextureForEffectSlot);
    *v11 |= 0x10u;
    memset(&v132, 0, sizeof(v132));
    C3DMatrix4x4Invert(&v134, &v132);
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    C3DLightGetProjectionInfo((uint64_t)v10, (uint64_t)&v118);
    char v55 = C3DEngineContextGetCoordinatesSystemOptions(v4[5].i64[0]);
    Matrix = C3DProjectionInfosGetMatrix((char *)&v118, 0, v55);
    uint64_t v57 = 0;
    float32x4_t v58 = *(float32x4_t *)Matrix;
    float32x4_t v59 = *((float32x4_t *)Matrix + 1);
    float32x4_t v60 = *((float32x4_t *)Matrix + 2);
    float32x4_t v61 = *((float32x4_t *)Matrix + 3);
    simd_float4x4 v135 = v132;
    long long v136 = 0u;
    long long v137 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    do
    {
      *(long long *)((char *)&v136 + v57 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v58, COERCE_FLOAT(*(_OWORD *)&v135.columns[v57])), v59, *(float32x2_t *)v135.columns[v57].f32, 1), v60, (float32x4_t)v135.columns[v57], 2), v61, (float32x4_t)v135.columns[v57], 3);
      ++v57;
    }
    while (v57 != 4);
    uint64_t v62 = (long long *)(a1 + 432 * a2);
    simd_float4x4 v63 = v62 + 367;
    long long v64 = v137;
    long long v65 = v138;
    long long v66 = v139;
    v62[367] = v136;
    float32x4_t v67 = v62 + 368;
    v62[368] = v64;
    float32x4_t v68 = v62 + 369;
    v62[369] = v65;
    float32x4_t v69 = v62 + 370;
    v62[370] = v66;
    if (C3DKeyframeControllerHasInterpolationModesPerKey(Gobo))
    {
      ImageTransforuint64_t m = (float32x4_t *)C3DEffectSlotGetImageTransform(Gobo);
      uint64_t v71 = 0;
      float32x4_t v72 = *ImageTransform;
      float32x4_t v73 = ImageTransform[1];
      float32x4_t v74 = ImageTransform[2];
      float32x4_t v75 = ImageTransform[3];
      long long v76 = *v67;
      long long v77 = *v68;
      long long v78 = *v69;
      long long v136 = *v63;
      long long v137 = v76;
      long long v138 = v77;
      long long v139 = v78;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      do
      {
        *(long long *)((char *)&v118 + v71) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(long long *)((char *)&v136 + v71))), v73, *(float32x2_t *)((char *)&v136 + v71), 1), v74, *(float32x4_t *)((char *)&v136 + v71), 2), v75, *(float32x4_t *)((char *)&v136 + v71), 3);
        v71 += 16;
      }
      while (v71 != 64);
      long long v79 = v118;
      long long v80 = v119;
      long long v81 = v120;
      long long v82 = v121;
    }
    else
    {
      long long v79 = *v63;
      long long v80 = *v67;
      long long v81 = *v68;
      long long v82 = *v69;
    }
    uint64_t v96 = 0;
    float32x4_t v97 = *(float32x4_t *)MEMORY[0x263EF89A8];
    float32x4_t v98 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
    float32x4_t v99 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
    v97.i32[0] = 0.5;
    v98.i32[1] = -0.5;
    v99.i32[2] = 1.0;
    v100.i64[0] = 0x3F0000003F000000;
    v100.i64[1] = *(void *)(MEMORY[0x263EF89A8] + 56);
    long long v136 = v79;
    long long v137 = v80;
    long long v138 = v81;
    long long v139 = v82;
    long long v118 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    do
    {
      *(long long *)((char *)&v118 + v96) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v97, COERCE_FLOAT(*(long long *)((char *)&v136 + v96))), v98, *(float32x2_t *)((char *)&v136 + v96), 1), v99, *(float32x4_t *)((char *)&v136 + v96), 2), v100, *(float32x4_t *)((char *)&v136 + v96), 3);
      v96 += 16;
    }
    while (v96 != 64);
    long long v101 = v119;
    long long v102 = v120;
    long long v103 = v121;
    *simd_float4x4 v63 = v118;
    *float32x4_t v67 = v101;
    *float32x4_t v68 = v102;
    long long *v69 = v103;
    float Intensity = C3DEffectSlotGetIntensity(Gobo);
    __asm { FMOV            V1.4S, #1.0 }
    *((float *)&_Q1 + 3) = Intensity;
    *(_OWORD *)(a1 + 432 * a2 + 6128) = _Q1;
  }
}

uint64_t __appendShadowTechnique(uint64_t a1, void *key, const void *a3, uint64_t a4, uint64_t a5, int a6)
{
  ShadowTechniqueForuint64_t Node = C3DLightingSystemGetShadowTechniqueForNode(a1, a3, key);
  if (!ShadowTechniqueForNode)
  {
    ShadowTechniqueForuint64_t Node = (const void *)C3DFXTechniqueCreateSpotShadow((uint64_t)a3);
    C3DLightingSystemSetShadowTechniqueForNode(a1, a3, key, ShadowTechniqueForNode);
    CFRelease(ShadowTechniqueForNode);
  }
  if (C3DLightShouldAdjustsShadowProjection((uint64_t)key))
  {
    int EnableSampleDistributed = C3DLightGetEnableSampleDistributed((uint64_t)key);
    C3DFXContextSetEnableSampleDistributedRange(a4, a5, EnableSampleDistributed);
  }
  uint64_t result = C3DFXTechniqueMarkAsUsed((uint64_t)ShadowTechniqueForNode, a6);
  if (result)
  {
    BOOL v15 = (const void *)C3DFXShadowMapTargetNameWithNode((uint64_t)a3);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a3, v15);
    return C3DFXContextAppendTechnique(a4, a5, (uint64_t)ShadowTechniqueForNode);
  }
  return result;
}

const void *C3DLightingSystemGetShadowTechniqueForNode(uint64_t a1, const void *a2, void *key)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 116488);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v3, key);
  if (!Value) {
    return 0;
  }

  return CFDictionaryGetValue(Value, a2);
}

void C3DLightingSystemSetShadowTechniqueForNode(uint64_t a1, const void *a2, void *key, const void *a4)
{
  uint64_t v7 = (CFMutableDictionaryRef *)(a1 + 116488);
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 116488);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, 0, MEMORY[0x263EFFF90]);
    *uint64_t v7 = Mutable;
  }
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    CFDictionaryRef Value = CFDictionaryCreateMutable(0, 1, 0, MEMORY[0x263EFFF90]);
    CFDictionarySetValue(*v7, key, Value);
    CFRelease(Value);
  }

  CFDictionarySetValue((CFMutableDictionaryRef)Value, a2, a4);
}

uint64_t C3DLightingSystemAppendForwardShadowingTechniques(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Scene = C3DEngineContextGetScene(a3);
  uint64_t result = C3DSceneGetFrameStamp(Scene);
  int v8 = result;
  if (*(_DWORD *)(a1 + 116504) != result) {
    *(_DWORD *)(a1 + 116504) = result;
  }
  uint64_t v9 = *(unsigned int *)(a1 + 68);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 8 * v9;
    do
    {
      uint64_t v12 = *(void **)(*(void *)(a1 + 208) + v10);
      uint64_t result = C3DLightGetCastsShadow((uint64_t)v12);
      if (result)
      {
        uint64_t result = C3DLightGetUsesDeferredShadows((uint64_t)v12);
        if ((result & 1) == 0) {
          uint64_t result = __appendShadowTechnique(a1, v12, *(const void **)(*(void *)(a1 + 144) + v10), a2, a3, v8);
        }
      }
      v10 += 8;
    }
    while (v11 != v10);
  }
  uint64_t v13 = *(unsigned int *)(a1 + 76);
  if (v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 8 * v13;
    do
    {
      int v16 = *(void **)(*(void *)(a1 + 224) + v14);
      uint64_t result = C3DLightGetCastsShadow((uint64_t)v16);
      if (result)
      {
        uint64_t result = C3DLightGetUsesDeferredShadows((uint64_t)v16);
        if ((result & 1) == 0) {
          uint64_t result = __appendShadowTechnique(a1, v16, *(const void **)(*(void *)(a1 + 160) + v14), a2, a3, v8);
        }
      }
      v14 += 8;
    }
    while (v15 != v14);
  }
  return result;
}

uint64_t __C3DLightingSystemGetLightingContext_block_invoke(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(result + 32) + 8);
  long long v5 = *(_OWORD *)(*(void *)(result + 40) + 536);
  *(_OWORD *)(v4 + 44) = *(_OWORD *)(*(void *)(result + 40) + 552);
  *(_OWORD *)(v4 + 28) = v5;
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_WORD *)(*(void *)(*(void *)(result + 32) + 8)
                                                                            + 24) & 0x807F | (a2 << 7);
  if (a2)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    uint64_t v9 = 8 * a2;
    do
    {
      uint64_t result = C3DLightGetCategoryBitMask(*(void *)(a4 + v8));
      *(void *)(*(void *)(*(void *)(v7 + 32) + 8) + v8 + 64) = result;
      v8 += 8;
    }
    while (v9 != v8);
  }
  return result;
}

unint64_t C3DLightingSystemQuery(uint64_t a1, float32x4_t *a2, uint64_t a3, void *a4)
{
  v52[1] = *MEMORY[0x263EF8340];
  uint64_t v7 = a1 + 116432;
  v52[0] = *(void *)(a1 + 576);
  unint64_t v8 = *(unsigned int *)(a1 + 584);
  float32x4_t v47 = a2[1];
  float32x4_t v49 = *a2;
  if ((*(void *)(a1 + 592) & a3) != 0)
  {
    unint64_t v9 = *(unsigned int *)(a1 + 68);
    if (v8 <= 7 && v9 != 0)
    {
      uint64_t v11 = 0;
      while (1)
      {
        uint64_t v12 = *(void *)(*(void *)(a1 + 272) + 8 * v11);
        if (v12 != -1)
        {
          if (!*(unsigned char *)v7) {
            goto LABEL_11;
          }
          if ((C3DLightGetBaked(*(void *)(*(void *)(a1 + 208) + 8 * v11)) & 1) == 0) {
            break;
          }
        }
LABEL_13:
        if (v8 <= 7 && ++v11 < v9) {
          continue;
        }
        goto LABEL_15;
      }
      uint64_t v12 = *(void *)(*(void *)(a1 + 272) + 8 * v11);
LABEL_11:
      if ((v12 & a3) != 0) {
        *((unsigned char *)v52 + v8++) = __runtimeIndex(a1, 1u, v11);
      }
      goto LABEL_13;
    }
  }
LABEL_15:
  unint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v8 <= 7 && v13 != 0)
  {
    unint64_t v15 = 0;
    float32x4_t v44 = vnegq_f32(v47);
    do
    {
      if ((*(void *)(*(void *)(a1 + 280) + 8 * v15) & a3) != 0
        && (!*(unsigned char *)v7 || (C3DLightGetBaked(*(void *)(*(void *)(a1 + 216) + 8 * v15)) & 1) == 0))
      {
        float32x4_t v16 = *(float32x4_t *)(*(void *)(a1 + 456) + 16 * v15);
        float32x4_t v17 = vsubq_f32(v16, v49);
        float32x4_t v18 = vsubq_f32(v17, vmaxnmq_f32(vminnmq_f32(v17, v47), v44));
        float32x4_t v19 = vmulq_f32(v18, v18);
        if (vmovn_s32(vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v16, v16), 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))))).u8[0])
        {
          float32x4_t v42 = *(float32x4_t *)(*(void *)(a1 + 456) + 16 * v15);
          *((unsigned char *)v52 + v8) = __runtimeIndex(a1, 2u, v15);
          if (*(unsigned char *)(v7 + 52))
          {
            long long v51 = xmmword_20B5CD380;
            C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(v7 + 8), 0, (float *)&v51, 0, v42, *a2);
          }
          ++v8;
        }
      }
      if (v8 > 7) {
        break;
      }
      ++v15;
    }
    while (v15 < v13);
  }
  if (v8 <= 7)
  {
    unint64_t v20 = *(unsigned int *)(a1 + 88);
    if (v20)
    {
      unint64_t v21 = 0;
      float32x4_t v45 = vnegq_f32(v47);
      do
      {
        if ((*(void *)(*(void *)(a1 + 312) + 8 * v21) & a3) != 0
          && (!*(unsigned char *)v7 || (C3DLightGetBaked(*(void *)(*(void *)(a1 + 248) + 8 * v21)) & 1) == 0))
        {
          float32x4_t v22 = *(float32x4_t *)(*(void *)(a1 + 464) + 16 * v21);
          float32x4_t v23 = vsubq_f32(v22, v49);
          float32x4_t v24 = vsubq_f32(v23, vmaxnmq_f32(vminnmq_f32(v23, v47), v45));
          float32x4_t v25 = vmulq_f32(v24, v24);
          if (vmovn_s32(vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))))).u8[0])
          {
            float32x4_t v43 = *(float32x4_t *)(*(void *)(a1 + 464) + 16 * v21);
            *((unsigned char *)v52 + v8) = __runtimeIndex(a1, 6u, v21);
            if (*(unsigned char *)(v7 + 52))
            {
              long long v51 = xmmword_20B5CD380;
              C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(v7 + 8), 0, (float *)&v51, 0, v43, *a2);
            }
            ++v8;
          }
        }
        if (v8 > 7) {
          break;
        }
        ++v21;
      }
      while (v21 < v20);
    }
  }
  if (v8 <= 7)
  {
    unint64_t v26 = *(unsigned int *)(a1 + 76);
    if (v26)
    {
      uint64_t v27 = 0;
      unint64_t v28 = 0;
      float32x4_t v29 = vmulq_f32(v47, v47);
      float v30 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]);
      float32x4_t v31 = v49;
      v31.f32[3] = v30;
      float v48 = v30;
      float32x4_t v50 = v31;
      do
      {
        if ((*(void *)(*(void *)(a1 + 288) + 8 * v28) & a3) != 0)
        {
          if (!*(unsigned char *)v7
            || (Baked = C3DLightGetBaked(*(void *)(*(void *)(a1 + 224) + 8 * v28)), float v30 = v48, (Baked & 1) == 0))
          {
            long long v33 = (float32x4_t *)(*(void *)(a1 + 472) + v27);
            float32x4_t v34 = vsubq_f32(v50, *v33);
            float32x4_t v35 = vmulq_f32(v34, v34);
            if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0] <= (float)((float)(v30 + v33[2].f32[0]) * (float)(v30 + v33[2].f32[0])))
            {
              float32x4_t v36 = v33[1];
              float32x4_t v37 = vmulq_f32(v34, v36);
              v37.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u64[0];
              float32x4_t v38 = vmlsq_lane_f32(v34, v36, *(float32x2_t *)v37.f32, 0);
              float32x4_t v39 = vmulq_f32(v38, v38);
              if ((float)(v33[2].f32[2]
                         * (float)(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0])- (float)(v33[2].f32[3] * v37.f32[0]))) < v30)
              {
                float32x4_t v46 = *v33;
                *((unsigned char *)v52 + v8) = __runtimeIndex(a1, 3u, v28);
                if (*(unsigned char *)(v7 + 52))
                {
                  long long v51 = xmmword_20B5CD380;
                  C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(v7 + 8), 0, (float *)&v51, 0, v46, *a2);
                }
                ++v8;
                float v30 = v48;
              }
            }
          }
        }
        if (v8 > 7) {
          break;
        }
        ++v28;
        v27 += 48;
      }
      while (v28 < v26);
    }
  }
  ++*(_DWORD *)(a1 + 4 * v8 + 116448);
  *a4 = v52[0];
  return v8;
}

uint64_t C3DLightingSystemGetLightingSetProgramHashCodes(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v6 = 0;
  *(void *)&void v12[5] = *MEMORY[0x263EF8340];
  *a3 = 0u;
  a3[1] = 0u;
  do
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + v6);
    if (!*(unsigned char *)(a2 + v6)) {
      break;
    }
    if (v7 != 255 && *(_DWORD *)(a1 + 608) < v7)
    {
      unint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        C3DLightingSystemGetLightingSetProgramHashCodes_cold_1(v11, v12, v9);
      }
    }
    *((_DWORD *)a3 + v6++) = *(_DWORD *)(a1 + 4 * v7 + 4712);
  }
  while (v6 != 8);
  return v6;
}

void C3DLightingSystemGetLightingSetDesc(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = *(unsigned __int8 *)(a2 + v7);
    if (!*(unsigned char *)(a2 + v7)) {
      break;
    }
    if (v8 == 255 || *(_DWORD *)(a1 + 608) >= v8)
    {
      a3[v7 + 1] = *(void *)(a1 + 608 + 8 * v8 + 2056);
      uint64_t v10 = a1 + 608 + 432 * v8 + 5136;
    }
    else
    {
      if ((C3DLightingSystemGetLightingSetDesc_done & 1) == 0)
      {
        C3DLightingSystemGetLightingSetDesc_done = 1;
        uint64_t v11 = scn_default_log();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          C3DLightingSystemGetLightingSetDesc_cold_1(&v13, v14, v11);
        }
      }
      uint64_t v10 = 0;
      a3[v7 + 1] = 0;
    }
    a3[v7++ + 9] = v10;
    ++v6;
    if (v7 == 8)
    {
      *a3 = 8;
      return;
    }
  }
  *a3 = v7;
  if (v7 <= 7)
  {
    do
    {
      uint64_t v12 = &a3[v6];
      v12[1] = 0;
      v12[9] = 0;
      ++v6;
    }
    while (v6 != 8);
  }
}

uint64_t C3DLightingSystemCheckLightingSetTextureUsage(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 8; ++i)
  {
    unsigned int v5 = *(unsigned __int8 *)(a2 + i);
    if (!*(unsigned char *)(a2 + i)) {
      break;
    }
    if (v5 == 255 || *(_DWORD *)(a1 + 608) >= v5)
    {
      if ((*(unsigned char *)(a1 + 432 * *(unsigned __int8 *)(a2 + i) + 5856) & 0x10) != 0) {
        return 1;
      }
    }
    else if ((C3DLightingSystemCheckLightingSetTextureUsage_done & 1) == 0)
    {
      C3DLightingSystemCheckLightingSetTextureUsage_done = 1;
      unint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        C3DLightingSystemGetLightingSetDesc_cold_1(&v9, v10, v7);
      }
    }
  }
  return 0;
}

void __C3DLightingSystemEndQueries_block_invoke(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (long long *)(a1 + 32);
    uint8_t v9 = (long long *)(a1 + 48);
    uint64_t v10 = a2;
    do
    {
      uint64_t v11 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v11 + 344) + v7)) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = v9;
      }
      C3DAuthoringEnvironmentAppendDebugBoundingSphere(*(void *)(v11 + 116440), *(void *)(a5 + 16 * v7), *(void *)(a5 + 16 * v7 + 8), 0, v12);
      ++v7;
    }
    while (v10 != v7);
  }
}

void __C3DLightingSystemEndQueries_block_invoke_2(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (long long *)(a1 + 32);
    uint8_t v9 = (long long *)(a1 + 48);
    uint64_t v10 = a2;
    do
    {
      long long v11 = *(_OWORD *)(a5 + 16 * v7);
      HIDWORD(v11) = sqrtf(*((float *)&v11 + 3));
      uint64_t v12 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v12 + 376) + v7)) {
        uint8_t v13 = v8;
      }
      else {
        uint8_t v13 = v9;
      }
      C3DAuthoringEnvironmentAppendDebugBoundingSphere(*(void *)(v12 + 116440), *(void *)(a5 + 16 * v7++), *((uint64_t *)&v11 + 1), 0, v13);
    }
    while (v10 != v7);
  }
}

void __C3DLightingSystemEndQueries_block_invoke_3(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (float *)(a1 + 32);
    uint64_t v8 = (float *)(a1 + 48);
    uint8_t v9 = (_DWORD *)(a5 + 32);
    uint64_t v10 = a2;
    do
    {
      long long v11 = *((_OWORD *)v9 - 2);
      long long v12 = *((_OWORD *)v9 - 1);
      float v13 = *(float *)v9;
      float v14 = *((float *)v9 + 1);
      v9 += 12;
      long long v17 = v12;
      long long v18 = v11;
      uint64_t v15 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v15 + 352) + v6)) {
        float32x4_t v16 = v7;
      }
      else {
        float32x4_t v16 = v8;
      }
      C3DAuthoringEnvironmentAppendDebugCone(*(uint64_t **)(v15 + 116440), (uint64_t)&v18, (uint64_t)&v17, 0, v16, 0, v13, v14);
      ++v6;
    }
    while (v10 != v6);
  }
}

void C3DLightingSystemEndProcessing(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 76);
  if (v3) {
    __C3DLightingSystemEndProcessing_block_invoke(a1, v3, a3, *(uint64_t **)(a1 + 224));
  }
}

void __C3DLightingSystemEndProcessing_block_invoke(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t Gobo = C3DLightGetGobo(*a4, 0);
      if (Gobo)
      {
        uint64_t v7 = Gobo;
        if (C3DEffectSlotGetImageProxy(Gobo)) {
          C3DEffectSlotSetTextureFromImageProxy(v7, 0);
        }
      }
      ++a4;
      --v5;
    }
    while (v5);
  }
}

uint64_t C3DLightingSystemGetLightProbesSystem(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemGetIrradianceProbesCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void C3DLightingSystemInvalidateShadowTechniqueForLight(uint64_t a1, const void *a2)
{
  unsigned int v2 = *(__CFDictionary **)(a1 + 116488);
  if (v2) {
    CFDictionaryRemoveValue(v2, a2);
  }
}

void C3DLightingSystemNextFrame(uint64_t a1)
{
  uint64_t v2 = 0;
  *(_DWORD *)(a1 + 116760) = 0;
  do
  {
    bzero(*(void **)(a1 + 8 * v2 + 400), *(unsigned int *)(a1 + 4 * v2 + 68));
    ++v2;
  }
  while (v2 != 7);

  __CommitLightsUpdate(a1);
}

double _computeShadowMatrix(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __n128 a17, __n128 a18, __n128 a19, __n128 a20)
{
  unint64_t v20 = 0;
  float v21 = -0.5;
  if ((a1 & 2) == 0) {
    float v21 = 0.5;
  }
  if (a1) {
    float v22 = 1.0;
  }
  else {
    float v22 = 0.5;
  }
  if (a1) {
    float v23 = 0.0;
  }
  else {
    float v23 = 0.5;
  }
  float32x4_t v24 = *(float32x4_t *)MEMORY[0x263EF89A8];
  float32x4_t v25 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  v24.i32[0] = 0.5;
  float32x4_t v26 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  v25.f32[1] = v21;
  v26.f32[2] = v22;
  v27.i64[0] = 0x3F0000003F000000;
  v27.f32[2] = v23;
  v27.i32[3] = *(_DWORD *)(MEMORY[0x263EF89A8] + 60);
  __n128 v39 = a6;
  __n128 v40 = a7;
  __n128 v41 = a8;
  __n128 v42 = a9;
  float32x4_t v43 = 0u;
  float32x4_t v44 = 0u;
  float32x4_t v45 = 0u;
  float32x4_t v46 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v43 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)((char *)&v39 + v20))), v25, (float32x2_t)v39.n128_u64[v20 / 8], 1), v26, *(float32x4_t *)((char *)&v39 + v20), 2), v27, *(float32x4_t *)((char *)&v39 + v20), 3);
    v20 += 16;
  }
  while (v20 != 64);
  unint64_t v28 = 0;
  float32x4_t v29 = v43;
  float32x4_t v30 = v44;
  float32x4_t v31 = v45;
  float32x4_t v32 = v46;
  __n128 v39 = a2;
  __n128 v40 = a3;
  __n128 v41 = a4;
  __n128 v42 = a5;
  float32x4_t v43 = 0u;
  float32x4_t v44 = 0u;
  float32x4_t v45 = 0u;
  float32x4_t v46 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v43 + v28) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v29, COERCE_FLOAT(*(_OWORD *)((char *)&v39 + v28))), v30, (float32x2_t)v39.n128_u64[v28 / 8], 1), v31, *(float32x4_t *)((char *)&v39 + v28), 2), v32, *(float32x4_t *)((char *)&v39 + v28), 3);
    v28 += 16;
  }
  while (v28 != 64);
  unint64_t v33 = 0;
  float32x4_t v34 = v43;
  float32x4_t v35 = v44;
  float32x4_t v36 = v45;
  float32x4_t v37 = v46;
  __n128 v39 = a17;
  __n128 v40 = a18;
  __n128 v41 = a19;
  __n128 v42 = a20;
  float32x4_t v43 = 0u;
  float32x4_t v44 = 0u;
  float32x4_t v45 = 0u;
  float32x4_t v46 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v43 + v33) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(_OWORD *)((char *)&v39 + v33))), v35, (float32x2_t)v39.n128_u64[v33 / 8], 1), v36, *(float32x4_t *)((char *)&v39 + v33), 2), v37, *(float32x4_t *)((char *)&v39 + v33), 3);
    v33 += 16;
  }
  while (v33 != 64);
  return *(double *)v43.i64;
}

void __computeSplitPositions(uint64_t a1, unsigned int a2, float a3, float a4, float a5)
{
  uint64_t v6 = a2 + 1;
  if (a2 == -1)
  {
    LODWORD(v6) = 0;
LABEL_6:
    uint64_t v16 = v6;
    do
    {
      *(_DWORD *)(a1 + 4 * v16) = *(_DWORD *)(a1 + 4 * (v16 - 1));
      ++v16;
    }
    while (v16 != 5);
    return;
  }
  uint64_t v9 = 0;
  float v10 = a4 - a3;
  float v11 = (float)a2;
  float v12 = a4 / a3;
  do
  {
    float v13 = (float)v9 / v11;
    float v14 = a3 + (float)(v10 * v13);
    float v15 = powf(v12, v13);
    *(float *)(a1 + 4 * v9++) = (float)(v15 * a3) + (float)(a5 * (float)(v14 - (float)(v15 * a3)));
  }
  while (v6 != v9);
  if (v6 <= 4) {
    goto LABEL_6;
  }
}

double _computeOrthographicProjectionFromShadowBoundingBox(char a1, __n128 a2, __n128 a3)
{
  double v3 = (float)-a3.n128_f32[2];
  if (a2.n128_f32[2] < a3.n128_f32[2]) {
    double v4 = (float)-a2.n128_f32[2];
  }
  else {
    double v4 = v3 + 1.0;
  }
  double v5 = v3 - v4;
  float64x2_t v10 = vcvtq_f64_f32((float32x2_t)a2.n128_u64[0]);
  float64x2_t v6 = vcvtq_f64_f32((float32x2_t)a3.n128_u64[0]);
  float64x2_t v7 = vsubq_f64(v6, v10);
  a3.n128_u32[0] = 0;
  a3.n128_u64[1] = 0;
  *(float32x2_t *)&v10.f64[0] = vcvt_f32_f64(vdivq_f64(vnegq_f64(vaddq_f64(v10, v6)), v7));
  if (a1)
  {
    *(float *)&unsigned int v13 = 1.0 / v5;
    *(void *)&long long v12 = 0;
    *((void *)&v12 + 1) = v13;
  }
  else
  {
    *(float *)&unsigned int v11 = 2.0 / v5;
    *(void *)&long long v12 = 0;
    *((void *)&v12 + 1) = v11;
    double v3 = v4 + v3;
  }
  float v8 = 2.0 / v7.f64[0];
  long long v14 = LODWORD(v8);
  float v9 = 2.0 / v7.f64[1];
  a3.n128_f32[1] = v9;
  *(float *)&unsigned int v15 = v3 / v5;
  *(void *)&v10.f64[1] = __PAIR64__(1.0, v15);
  if ((a1 & 8) != 0)
  {
    uint64_t v16 = 0;
    v18[0] = LODWORD(v8);
    v18[1] = a3;
    v18[2] = v12;
    v18[3] = v10;
    memset(v19, 0, sizeof(v19));
    do
    {
      v19[v16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(v18[v16])), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)&v18[v16], 1), (float32x4_t)xmmword_20B5CB810, (float32x4_t)v18[v16], 2), (float32x4_t)xmmword_20B5CBCA0, (float32x4_t)v18[v16], 3);
      ++v16;
    }
    while (v16 != 4);
    *(void *)&long long v14 = *(void *)&v19[0];
  }
  return *(double *)&v14;
}

void __computeStableCascade(uint64_t a1, uint64_t a2, char a3, float32x4_t a4, float32x4_t a5)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  scn_plane_intersect_3_planes(*(void *)(a1 + 336), *(void *)(a1 + 344), *(void *)(a1 + 288), *(void *)(a1 + 296), *(void *)(a1 + 272), *(void *)(a1 + 280), &v64);
  scn_plane_intersect_3_planes(*(void *)(a1 + 336), *(void *)(a1 + 344), *(void *)(a1 + 256), *(void *)(a1 + 264), *(void *)(a1 + 288), *(void *)(a1 + 296), &v65);
  scn_plane_intersect_3_planes(*(void *)(a1 + 336), *(void *)(a1 + 344), *(void *)(a1 + 272), *(void *)(a1 + 280), *(void *)(a1 + 304), *(void *)(a1 + 312), &v66);
  scn_plane_intersect_3_planes(*(void *)(a1 + 336), *(void *)(a1 + 344), *(void *)(a1 + 304), *(void *)(a1 + 312), *(void *)(a1 + 256), *(void *)(a1 + 264), &v67);
  scn_plane_intersect_3_planes(*(void *)(a1 + 320), *(void *)(a1 + 328), *(void *)(a1 + 288), *(void *)(a1 + 296), *(void *)(a1 + 272), *(void *)(a1 + 280), &v68);
  scn_plane_intersect_3_planes(*(void *)(a1 + 320), *(void *)(a1 + 328), *(void *)(a1 + 256), *(void *)(a1 + 264), *(void *)(a1 + 288), *(void *)(a1 + 296), &v69);
  scn_plane_intersect_3_planes(*(void *)(a1 + 320), *(void *)(a1 + 328), *(void *)(a1 + 272), *(void *)(a1 + 280), *(void *)(a1 + 304), *(void *)(a1 + 312), &v70);
  scn_plane_intersect_3_planes(*(void *)(a1 + 320), *(void *)(a1 + 328), *(void *)(a1 + 304), *(void *)(a1 + 312), *(void *)(a1 + 256), *(void *)(a1 + 264), &v71);
  uint64_t v8 = 0;
  v9.columns[0] = 0uLL;
  do
  {
    v9.columns[0] = (simd_float4)vaddq_f32((float32x4_t)v9.columns[0], *(float32x4_t *)((char *)&v64 + v8));
    v8 += 16;
  }
  while (v8 != 128);
  uint64_t v10 = 0;
  v9.columns[1].i64[0] = 0x3E0000003E000000;
  v9.columns[1].i64[1] = 0x3E0000003E000000;
  v9.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v9.columns[0], (float32x4_t)v9.columns[1]);
  v9.columns[0].i32[0] = 0;
  do
  {
    v9.columns[1] = (simd_float4)vsubq_f32(*(float32x4_t *)((char *)&v64 + v10), (float32x4_t)v9.columns[3]);
    v9.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v9.columns[1], (float32x4_t)v9.columns[1]);
    v9.columns[0].f32[0] = fmaxf(v9.columns[0].f32[0], sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9.columns[1], 2), vaddq_f32((float32x4_t)v9.columns[1], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.columns[1].f32, 1))).f32[0]));
    v10 += 16;
  }
  while (v10 != 128);
  float v11 = ceilf(v9.columns[0].f32[0] * 16.0);
  v9.columns[0] = v9.columns[3];
  v9.columns[0].f32[3] = v11 * 0.0625;
  int32x4_t v54 = (int32x4_t)v9.columns[0];
  *(simd_float4 *)(a1 + 224) = v9.columns[0];
  v9.columns[3].i32[3] = *(_DWORD *)(a1 + 60);
  *(simd_float4 *)(a1 + 48) = v9.columns[3];
  v9.columns[0] = *(simd_float4 *)a1;
  v9.columns[1] = *(simd_float4 *)(a1 + 16);
  v9.columns[2] = *(simd_float4 *)(a1 + 32);
  simd_float4x4 v77 = __invert_f4(v9);
  uint64_t v13 = 0;
  float32x4_t v14 = *(float32x4_t *)(a1 + 32);
  float32x4_t v15 = *(float32x4_t *)(a1 + 48);
  int32x4_t v16 = (int32x4_t)vmulq_f32(v14, v14);
  v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2), vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.i8, 1))).u32[0];
  float32x2_t v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
  float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
  float32x4_t v19 = vmulq_n_f32(v14, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]);
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v25 = _Q4;
  float32x4_t v28 = vdivq_f32(_Q4, v19);
  _Q4.f32[0] = -(float)(v11 * 0.0625);
  float32x4_t v26 = _Q4;
  v26.f32[1] = _Q4.f32[0];
  simd_float4 v57 = v77.columns[1];
  simd_float4 v58 = v77.columns[0];
  *(simd_float4x4 *)(a1 + 64) = v77;
  v26.f32[2] = v11 * 0.0625;
  v25.f32[0] = v11 * 0.0625;
  simd_float4 v55 = v77.columns[3];
  simd_float4 v56 = v77.columns[2];
  float32x4_t v27 = v25;
  v27.f32[1] = _Q4.f32[0];
  v27.f32[2] = v11 * 0.0625;
  float32x4_t v72 = v26;
  float32x4_t v73 = v27;
  v25.f32[1] = v11 * 0.0625;
  v25.f32[2] = v11 * 0.0625;
  _Q4.f32[1] = v11 * 0.0625;
  _Q4.f32[2] = v11 * 0.0625;
  float32x4_t v74 = v25;
  float32x4_t v75 = _Q4;
  v28.i32[3] = 1259902592;
  float32x4_t v29 = vsubq_f32(a4, a5);
  float32x4_t v30 = vaddq_f32(a4, a5);
  float v31 = 0.0;
  do
  {
    float32x4_t v32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a1, COERCE_FLOAT(*(_OWORD *)((char *)&v72 + v13 * 4))), *(float32x4_t *)(a1 + 16), *(float32x2_t *)&v72.f32[v13], 1), v14, *(float32x4_t *)((char *)&v72 + v13 * 4), 2), v15, *(float32x4_t *)((char *)&v72 + v13 * 4), 3);
    v32.i32[3] = 1.0;
    float32x4_t v33 = vmulq_f32(v28, vsubq_f32(v29, v32));
    v33.i32[3] = 0;
    float32x4_t v34 = vmulq_f32(v28, vsubq_f32(v30, v32));
    v34.i32[3] = 0;
    float32x4_t v35 = vminnmq_f32(v33, v34);
    float32x4_t v36 = vmaxnmq_f32(v33, v34);
    float v37 = v35.f32[2];
    if (v35.f32[0] >= v35.f32[2]) {
      float v37 = v35.f32[0];
    }
    if (v37 < v35.f32[1]) {
      float v37 = v35.f32[1];
    }
    float v38 = v36.f32[2];
    if (v36.f32[0] <= v36.f32[2]) {
      float v38 = v36.f32[0];
    }
    v36.i32[0] = v36.i32[1];
    if (v38 <= v36.f32[1]) {
      v36.f32[0] = v38;
    }
    if (v36.f32[0] >= v37)
    {
      if (v37 > 0.0 && v37 < 10000000.0 || v36.f32[0] > 0.0 && (float v37 = v36.f32[0], v36.f32[0] < 10000000.0)) {
        float v31 = fmaxf(v31, v37);
      }
    }
    v13 += 4;
  }
  while (v13 != 16);
  *(float *)v12.i32 = -(float)(v11 * 0.0625);
  __n128 v39 = (__n128)vdupq_laneq_s32(v54, 3);
  v39.n128_u32[1] = v54.u32[3];
  v39.n128_f32[2] = (float)(v11 * 0.0625) + v31;
  float32x4_t v60 = (float32x4_t)v39;
  __n128 v62 = (__n128)vdupq_lane_s32(v12, 0);
  *(double *)v40.i64 = _computeOrthographicProjectionFromShadowBoundingBox(a3, v62, v39);
  uint64_t v44 = 0;
  *(float32x4_t *)(a1 + 128) = v40;
  *(float32x4_t *)(a1 + 144) = v41;
  *(float32x4_t *)(a1 + 160) = v42;
  *(float32x4_t *)(a1 + 176) = v43;
  v45.i64[0] = 0x3F0000003F000000;
  v45.i64[1] = 0x3F0000003F000000;
  float32x4_t v46 = vmulq_f32(vaddq_f32((float32x4_t)v62, v60), v45);
  float32x4_t v47 = vmulq_f32(vsubq_f32(v60, (float32x4_t)v62), v45);
  v46.i32[3] = 1.0;
  v47.i32[3] = 0;
  *(float32x4_t *)(a1 + 352) = v46;
  *(float32x4_t *)(a1 + 368) = v47;
  v63[0] = v58;
  v63[1] = v57;
  v63[2] = v56;
  v63[3] = v55;
  float32x4_t v72 = 0u;
  float32x4_t v73 = 0u;
  float32x4_t v74 = 0u;
  float32x4_t v75 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v72 + v44 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, COERCE_FLOAT(v63[v44])), v41, *(float32x2_t *)&v63[v44], 1), v42, (float32x4_t)v63[v44], 2), v43, (float32x4_t)v63[v44], 3);
    ++v44;
  }
  while (v44 != 4);
  float32x2_t v48 = vadd_f32(*(float32x2_t *)v75.f32, (float32x2_t)*(_OWORD *)&vmlaq_f32(vmlaq_f32(vmulq_f32(v72, (float32x4_t)0), (float32x4_t)0, v73), (float32x4_t)0, v74));
  float v49 = *(float *)C3DLightGetRealShadowMapSize(a2).i32;
  *(float32x2_t *)v50.f32 = vmul_n_f32(v48, 0.5 * v49);
  float32x2_t v51 = vmul_n_f32(vsub_f32((float32x2_t)*(_OWORD *)&vrndaq_f32(v50), *(float32x2_t *)v50.f32), 2.0 / v49);
  int8x16_t v52 = *(int8x16_t *)(a1 + 176);
  *(float32x2_t *)&long long v53 = vadd_f32(*(float32x2_t *)v52.i8, v51);
  *((void *)&v53 + 1) = vextq_s8(v52, v52, 8uLL).u64[0];
  *(_OWORD *)(a1 + 176) = v53;
}

void C3DLightingSystemComputeShadowMatrices(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, simd_float4 *a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v253 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    float32x4_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemComputeShadowMatrices_cold_6(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  __CommitLightsUpdate(a1);
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!Value)
  {
    float32x4_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      C3DLightingSystemComputeShadowMatrices_cold_1(v34, v35, v36);
    }
    return;
  }
  uint64_t v23 = Value >> 28;
  uint64_t v24 = (Value & 0xFFFFFFF) - 1;
  uint64_t v25 = *(void *)(*(void *)(a1 + 8 * v23 + 200) + 8 * v24);
  if ((C3DLightGetCastsShadow(v25) & 1) == 0)
  {
    float v37 = scn_default_log();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemComputeShadowMatrices_cold_5(v37, v38, v39, v40, v41, v42, v43, v44);
    }
    return;
  }
  float32x4_t v26 = (float32x4_t *)(a1 + 116640);
  __n128 v224 = *(__n128 *)(a1 + 116704);
  __n128 v225 = *(__n128 *)(a1 + 116688);
  __n128 v222 = *(__n128 *)(a1 + 116736);
  __n128 v223 = *(__n128 *)(a1 + 116720);
  if (C3DLightSupportsShadowCascades(v25)) {
    ShadowCascadeCFIndex Count = C3DLightGetShadowCascadeCount(v25);
  }
  else {
    ShadowCascadeCFIndex Count = 1;
  }
  uint64_t v45 = *(void *)(a1 + 8 * v23 + 392);
  unsigned int v46 = *(unsigned __int8 *)(v45 + v24);
  if (*(unsigned char *)(v45 + v24))
  {
    uint64_t v207 = v25;
    if (v46 >= 9)
    {
      float32x4_t v47 = scn_default_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
        C3DLightingSystemComputeShadowMatrices_cold_4(v47, v27, v28, v29, v30, v31, v32, v33);
      }
    }
    uint64_t v48 = a1 + 1568 * (v46 - 1) + 116768;
    unsigned int v49 = ShadowCascadeCount;
    goto LABEL_18;
  }
  int v88 = *(_DWORD *)(a1 + 116760);
  if (v88 == 8)
  {
    if ((C3DLightingSystemComputeShadowMatrices_done & 1) == 0)
    {
      C3DLightingSystemComputeShadowMatrices_done = 1;
      float32x4_t v89 = scn_default_log();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
        C3DLightingSystemComputeShadowMatrices_cold_2(v89);
      }
    }
    return;
  }
  char v193 = *(_DWORD *)(a1 + 116760);
  int v90 = v88 + 1;
  *(_DWORD *)(a1 + 116760) = v90;
  *(unsigned char *)(v45 + v24) = v90;
  int v91 = v90 - 1;
  uint64_t v92 = v25;
  uint64_t v48 = a1 + 1568 * v91 + 116768;
  int Type = C3DLightGetType(v92);
  uint64_t v207 = v92;
  if (!C3DLightShouldAdjustsShadowProjection(v92))
  {
    long long v243 = 0u;
    long long v244 = 0u;
    long long v241 = 0u;
    long long v242 = 0u;
    long long v239 = 0u;
    long long v240 = 0u;
    long long v237 = 0u;
    long long v238 = 0u;
    float32x4_t v235 = 0u;
    float32x4_t v236 = 0u;
    long long v233 = 0u;
    long long v234 = 0u;
    long long v231 = 0u;
    long long v232 = 0u;
    C3DLightGetProjectionInfo(v92, (uint64_t)&v231);
    RealShadowMapdouble Size = (float32x2_t)C3DLightGetRealShadowMapSize(v92);
    if (Type != 2)
    {
      if ((a8 & 8) != 0)
      {
        _Q1.i64[0] = 0;
      }
      else
      {
        RealShadowMapdouble Size = vadd_f32(RealShadowMapSize, (float32x2_t)0xC0000000C0000000);
        __asm { FMOV            V1.2S, #1.0 }
      }
      *(float32x2_t *)&_Q1.u32[2] = RealShadowMapSize;
      unsigned int v49 = ShadowCascadeCount;
      float32x4_t v245 = _Q1;
      Matrix = C3DProjectionInfosGetMatrix((char *)&v231, (uint64_t)&v245, a8);
      long long v175 = *((_OWORD *)Matrix + 3);
      long long v177 = *(_OWORD *)Matrix;
      long long v176 = *((_OWORD *)Matrix + 1);
      *(_OWORD *)(v48 + 160) = *((_OWORD *)Matrix + 2);
      *(_OWORD *)(v48 + 176) = v175;
      *(_OWORD *)(v48 + 128) = v177;
      *(_OWORD *)(v48 + 144) = v176;
      goto LABEL_84;
    }
    double ZNear = C3DLightGetZNear(v92);
    double ZFar = C3DLightGetZFar(v92);
    if (ZFar <= ZNear) {
      double ZFar = ZNear + 1.0;
    }
    double v217 = ZFar;
    double v149 = __tanpi(0.25);
    if (v149 == 0.0) {
      double v152 = 1.0;
    }
    else {
      double v152 = 1.0 / v149;
    }
    float v153 = v152;
    long long v154 = LODWORD(v153);
    LODWORD(v155) = 0;
    *((void *)&v155 + 1) = 0;
    *((float *)&v155 + 1) = v153;
    if (a8)
    {
      v170.f64[0] = v217;
      v170.f64[1] = ZNear * v217;
      *(float32x2_t *)v151.i8 = vcvt_f32_f64(vdivq_f64(v170, (float64x2_t)vdupq_lane_s64(COERCE__INT64(ZNear - v217), 0)));
      long long v171 = xmmword_20B5CC220;
      DWORD2(v171) = v151.i32[0];
      *(void *)&long long v172 = 0;
      *((void *)&v172 + 1) = v151.u32[1];
      *(_OWORD *)(a1 + 1568 * v91 + 116896) = LODWORD(v153);
      *(_OWORD *)(a1 + 1568 * v91 + 116912) = v155;
      *(_OWORD *)(a1 + 1568 * v91 + 116928) = v171;
      *(_OWORD *)(a1 + 1568 * v91 + 116944) = v172;
      if ((a8 & 8) != 0)
      {
        uint64_t v183 = 0;
        long long v249 = LODWORD(v153);
        long long v250 = v155;
        long long v251 = v171;
        long long v252 = v172;
        float32x4_t v245 = 0uLL;
        simd_float4 v246 = 0uLL;
        simd_float4 v247 = 0uLL;
        simd_float4 v248 = 0uLL;
        unsigned int v49 = ShadowCascadeCount;
        do
        {
          *(float32x4_t *)((char *)&v245 + v183) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_20B5CB820, COERCE_FLOAT(*(long long *)((char *)&v249 + v183))), (float32x4_t)xmmword_20B5CB7D0, *(float32x2_t *)((char *)&v249 + v183), 1), (float32x4_t)xmmword_20B5CB810, *(float32x4_t *)((char *)&v249 + v183), 2), (float32x4_t)xmmword_20B5CBCA0, *(float32x4_t *)((char *)&v249 + v183), 3);
          v183 += 16;
        }
        while (v183 != 64);
        simd_float4 v184 = v246;
        simd_float4 v185 = v247;
        int8x16_t v212 = (int8x16_t)v248;
        simd_float4 v186 = v248;
        int8x16_t v219 = (int8x16_t)v247;
        *(float32x4_t *)(v48 + 128) = v245;
        *(simd_float4 *)(v48 + 144) = v184;
        *(simd_float4 *)(v48 + 160) = v185;
        *(simd_float4 *)(v48 + 176) = v186;
        float ShadowBias = C3DLightGetShadowBias(v92);
        int8x16_t v173 = vextq_s8(v219, v219, 8uLL);
        *(int32x2_t *)v173.i8 = vzip1_s32(*(int32x2_t *)v173.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v212, v212, 8uLL));
        float v160 = -0.001;
        goto LABEL_83;
      }
      int8x16_t v218 = v151;
      float ShadowBias = C3DLightGetShadowBias(v92);
    }
    else
    {
      v156.f64[0] = ZNear + v217;
      v156.f64[1] = (ZNear + ZNear) * v217;
      *(float32x2_t *)v150.i8 = vcvt_f32_f64(vdivq_f64(v156, (float64x2_t)vdupq_lane_s64(COERCE__INT64(ZNear - v217), 0)));
      long long v157 = xmmword_20B5CC220;
      DWORD2(v157) = v150.i32[0];
      *(void *)&long long v158 = 0;
      int8x16_t v218 = v150;
      *((void *)&v158 + 1) = v150.u32[1];
      *(_OWORD *)(a1 + 1568 * v91 + 116896) = v154;
      *(_OWORD *)(a1 + 1568 * v91 + 116912) = v155;
      *(_OWORD *)(a1 + 1568 * v91 + 116928) = v157;
      *(_OWORD *)(a1 + 1568 * v91 + 116944) = v158;
      float ShadowBias = C3DLightGetShadowBias(v92);
      if ((a8 & 8) != 0)
      {
        float v160 = -0.001;
        unsigned int v49 = ShadowCascadeCount;
LABEL_74:
        int8x16_t v173 = v218;
LABEL_83:
        *(float *)v173.i32 = -*(float *)v173.i32;
        *(float *)&v173.i32[2] = v160 * ShadowBias;
        *(int8x16_t *)(v48 + 192) = v173;
LABEL_84:
        WorldMatrix = C3DNodeGetWorldMatrix(a2);
        float32x4_t v188 = WorldMatrix[3];
        float32x4_t v190 = *WorldMatrix;
        float32x4_t v189 = WorldMatrix[1];
        *(float32x4_t *)(v48 + 32) = WorldMatrix[2];
        *(float32x4_t *)(v48 + 48) = v188;
        *(float32x4_t *)uint64_t v48 = v190;
        *(float32x4_t *)(v48 + 16) = v189;
        *(simd_float4x4 *)(v48 + 64) = __invert_f4(*(simd_float4x4 *)v48);
LABEL_18:
        *(double *)v254.columns[0].i64 = _computeShadowMatrix(a8, *(__n128 *)(v48 + 64), *(__n128 *)(v48 + 80), *(__n128 *)(v48 + 96), *(__n128 *)(v48 + 112), *(__n128 *)(v48 + 128), *(__n128 *)(v48 + 144), *(__n128 *)(v48 + 160), *(__n128 *)(v48 + 176), v27, v28, v29, v30, v31, v32, v33, v225, v224, v223,
                                           v222);
        simd_float4 v203 = v254.columns[1];
        simd_float4 v205 = v254.columns[0];
        simd_float4 v199 = v254.columns[3];
        simd_float4 v201 = v254.columns[2];
        simd_float4x4 v255 = __invert_f4(v254);
        simd_float4 v213 = v255.columns[1];
        simd_float4 v221 = v255.columns[0];
        simd_float4 v208 = v255.columns[3];
        simd_float4 v210 = v255.columns[2];
        if (v49)
        {
          uint64_t v57 = 0;
          __asm { FMOV            V0.4S, #1.0 }
          long long v197 = _Q0;
          do
          {
            if (a3)
            {
              simd_float4x4 v63 = (long long *)(v48 + 384 * v57);
              float32x4_t v64 = (_OWORD *)(a3 + (v57 << 6));
              long long v65 = *v63;
              long long v66 = v63[1];
              long long v67 = v63[3];
              v64[2] = v63[2];
              v64[3] = v67;
              *float32x4_t v64 = v65;
              v64[1] = v66;
            }
            if (a4)
            {
              float32x4_t v68 = (_OWORD *)(a4 + (v57 << 6));
              float32x4_t v69 = (_OWORD *)(v48 + 384 * v57);
              long long v70 = v69[8];
              long long v71 = v69[9];
              long long v72 = v69[11];
              v68[2] = v69[10];
              v68[3] = v72;
              *float32x4_t v68 = v70;
              v68[1] = v71;
            }
            if (v57)
            {
              float32x4_t v73 = (__n128 *)(v48 + 384 * v57);
              *(double *)v74.i64 = _computeShadowMatrix(a8, v73[4], v73[5], v73[6], v73[7], v73[8], v73[9], v73[10], v73[11], v50, v51, v52, v53, v54, v55, v56, v225, v224, v223,
                                     v222);
              unint64_t v78 = 0;
              float32x4_t v245 = (float32x4_t)v221;
              simd_float4 v246 = v213;
              simd_float4 v247 = v210;
              simd_float4 v248 = v208;
              long long v231 = 0u;
              long long v232 = 0u;
              long long v233 = 0u;
              long long v234 = 0u;
              do
              {
                *(long long *)((char *)&v231 + v78) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v74, COERCE_FLOAT(*(_OWORD *)((char *)&v245 + v78))), v75, *(float32x2_t *)&v245.f32[v78 / 4], 1), v76, *(float32x4_t *)((char *)&v245 + v78), 2), v77, *(float32x4_t *)((char *)&v245 + v78), 3);
                v78 += 16;
              }
              while (v78 != 64);
              long long v79 = v231;
              long long v80 = v234;
              DWORD1(v79) = DWORD1(v232);
              DWORD2(v79) = DWORD2(v233);
              uint64_t v81 = v48 + 384 * v57;
              *(_OWORD *)(v81 + 192) = v79;
              *(_OWORD *)(v81 + 208) = v80;
              uint64_t v82 = a7;
              if (a5)
              {
                float32x4_t v83 = (float32x4_t *)&a5[4 * v57];
                *float32x4_t v83 = v74;
                v83[1] = v75;
                v83[2] = v76;
                v83[3] = v77;
              }
            }
            else
            {
              if (C3DLightGetType(v207) != 2)
              {
                *(_OWORD *)(v48 + 192) = v197;
                *(_OWORD *)(v48 + 208) = 0u;
              }
              uint64_t v82 = a7;
              if (a5)
              {
                *a5 = v205;
                a5[1] = v203;
                a5[2] = v201;
                a5[3] = v199;
              }
            }
            if (a6)
            {
              long long v84 = *(_OWORD *)(v48 + 384 * v57 + 192);
              uint64_t v85 = a6 + 16 * v57;
              HIDWORD(v84) = *(_DWORD *)(v85 + 12);
              *(_OWORD *)uint64_t v85 = v84;
            }
            if (v82)
            {
              long long v86 = *(_OWORD *)(v48 + 384 * v57 + 208);
              uint64_t v87 = v82 + 16 * v57;
              HIDWORD(v86) = *(_DWORD *)(v87 + 12);
              *(_OWORD *)uint64_t v87 = v86;
            }
            ++v57;
          }
          while (v57 != v49);
        }
        return;
      }
    }
    unsigned int v49 = ShadowCascadeCount;
    float v160 = 0.001;
    goto LABEL_74;
  }
  if (Type == 1)
  {
    uint64_t v93 = C3DGetScene(a2);
    CullingSysteuint64_t m = C3DSceneGetCullingSystem(v93);
    uint64_t v230 = 0;
    long long v228 = 0u;
    long long v229 = 0u;
    C3DCullingSystemQueryMake(0, (uint64_t)&v228);
    *(void *)&long long v229 = 0x100000020;
    *(void *)&long long v228 = C3DLightGetCategoryBitMask(v92);
    C3DCullingSystemGetSceneBoundingBox(CullingSystem, (uint64_t)&v228);
    float32x4_t v211 = v95;
    float32x4_t v216 = v94;
    uint64_t v96 = C3DNodeGetWorldMatrix(a2);
    v256.columns[1] = (simd_float4)v96[1];
    simd_float4 v97 = (simd_float4)v96[2];
    float32x4_t v245 = *v96;
    simd_float4 v246 = v256.columns[1];
    v256.columns[3] = *(simd_float4 *)(MEMORY[0x263EF89A8] + 48);
    simd_float4 v247 = v97;
    simd_float4 v248 = v256.columns[3];
    v256.columns[0] = (simd_float4)v245;
    v256.columns[2] = v247;
    simd_float4x4 v257 = __invert_f4(v256);
    float32x4_t v209 = (float32x4_t)v257.columns[0];
    float32x4_t v204 = (float32x4_t)v257.columns[2];
    float32x4_t v206 = (float32x4_t)v257.columns[1];
    float32x4_t v202 = (float32x4_t)v257.columns[3];
    float v98 = *(float *)(a1 + 116672);
    float v99 = fminf(*(float *)(a1 + 116676), C3DMeshElementGetPointSize(v92));
    AutomaticallyAdjustsShadowProjectioint n = C3DLightGetAutomaticallyAdjustsShadowProjection(v92);
    char v200 = AutomaticallyAdjustsShadowProjection;
    if (AutomaticallyAdjustsShadowProjection)
    {
      float32x4_t v101 = vmulq_f32(v211, v211);
      v101.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 2), vaddq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1))).f32[0]);
      float32x4_t v102 = vsubq_f32(v216, *(float32x4_t *)(a1 + 116656));
      float32x4_t v103 = vmulq_f32(v102, v102);
      v103.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v103, 2), vaddq_f32(v103, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v103.f32, 1))).f32[0]);
      float v98 = fmaxf(v98, v103.f32[0] - v101.f32[0]);
      float v99 = fminf(v99, v101.f32[0] + v103.f32[0]);
    }
    float ShadowCascadeSplittingFactor = C3DLightGetShadowCascadeSplittingFactor(v92);
    __computeSplitPositions(a1 + 1568 * v91 + 118304, ShadowCascadeCount, v98, v99, ShadowCascadeSplittingFactor);
    if (!ShadowCascadeCount)
    {
      LOBYTE(v120) = 0;
LABEL_78:
      unsigned int v49 = ShadowCascadeCount;
      if (ShadowCascadeCount > v120)
      {
        *(double *)&long long v178 = _computeOrthographicProjectionFromShadowBoundingBox(a8, (__n128)vdupq_n_s32(0x47C34F80u), (__n128)vdupq_n_s32(0x47C35000u));
        v179 = (_OWORD *)(v48 + 384 * v120);
        v179[8] = v178;
        v179[9] = v180;
        v179[10] = v181;
        v179[11] = v182;
      }
      goto LABEL_18;
    }
    int32x4_t v105 = (int32x4_t)vmulq_f32(*v26, *v26);
    v105.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v105, 2), vadd_f32(*(float32x2_t *)v105.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v105.i8, 1))).u32[0];
    float32x2_t v106 = vrsqrte_f32((float32x2_t)v105.u32[0]);
    float32x2_t v107 = vmul_f32(v106, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v106, v106)));
    float32x4_t v196 = vmulq_n_f32(*v26, vmul_f32(v107, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v107, v107))).f32[0]);
    float32x4_t v198 = *(float32x4_t *)(a1 + 116656);
    float32x4_t v195 = vnegq_f32(v196);
    float32x4_t v108 = (long long *)(a1 + 116512);
    float32x4_t v110 = v211;
    float32x4_t v109 = v216;
    float32x4_t v112 = v204;
    float32x4_t v111 = v206;
    float32x4_t v113 = v209;
    float32x4_t v114 = v202;
    float32x4_t v115 = vaddq_f32(v202, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v206, *(float32x2_t *)v216.f32, 1), v209, v216.f32[0]), v204, v216, 2));
    v115.i32[3] = 1.0;
    float32x4_t v116 = v211;
    v116.i32[1] = v211.i32[0];
    v116.i32[2] = v211.i32[0];
    float32x4_t v117 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v116, v209)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v211.f32, 1), (int32x4_t)v211), v206))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v110, (int32x4_t)v110), (int32x4_t)v211), v204)));
    v117.i32[2] = fminf(v117.f32[2], 10000.0);
    float32x4_t v191 = vaddq_f32(v115, v117);
    float32x4_t v192 = vsubq_f32(v115, v117);
    uint64_t v118 = ShadowCascadeCount;
    uint64_t v119 = a1 + 1568 * (v193 + 1);
    uint64_t v120 = 0;
    long long v121 = (float *)(v119 + 116740);
    while (1)
    {
      unsigned int v122 = v120;
      uint64_t v123 = v48 + 384 * v120;
      simd_float4 v124 = v246;
      *(float32x4_t *)uint64_t v123 = v245;
      *(simd_float4 *)(v123 + 16) = v124;
      simd_float4 v125 = v248;
      *(simd_float4 *)(v123 + 32) = v247;
      *(simd_float4 *)(v123 + 48) = v125;
      *(float32x4_t *)(v123 + 64) = v113;
      *(float32x4_t *)(v123 + 80) = v111;
      *(float32x4_t *)(v123 + 96) = v112;
      *(float32x4_t *)(v123 + 112) = v114;
      long long v127 = v108[1];
      long long v249 = *v108;
      long long v126 = v249;
      long long v250 = v127;
      long long v128 = v108[3];
      float32x4_t v129 = vmulq_f32(vmlaq_n_f32(v198, v195, *(v121 - 1)), v195);
      float32x4_t v130 = v195;
      v130.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 2), vaddq_f32(v129, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.f32, 1))).f32[0];
      float32x4_t v131 = vmulq_f32(v196, vmlaq_n_f32(v198, v195, *v121));
      long long v251 = v108[2];
      long long v252 = v128;
      v129.f32[0] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v131, 2), vaddq_f32(v131, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v131.f32, 1))).f32[0];
      float32x4_t v132 = v196;
      v132.i32[3] = v129.i32[0];
      *(_OWORD *)(v123 + 288) = v251;
      *(_OWORD *)(v123 + 304) = v128;
      *(_OWORD *)(v123 + 256) = v126;
      *(_OWORD *)(v123 + 272) = v127;
      *(float32x4_t *)(v123 + 320) = v132;
      *(float32x4_t *)(v123 + 336) = v130;
      if (v200)
      {
        uint64_t v194 = v120;
        uint64_t v120 = *(void *)(v48 + 384 * v120 + 240);
        long long v231 = v249;
        long long v232 = v250;
        long long v233 = v251;
        long long v234 = v252;
        float32x4_t v235 = v132;
        float32x4_t v236 = v130;
        C3DConvexPolyhedronSetFrustum(v120, (uint64_t *)&v231);
        if (!C3DConvexPolyhedronClipAABB(v120, v216, v211)) {
          goto LABEL_55;
        }
        float32x4_t v133 = C3DConvexPolyhedronComputeBoxInSpace(v120, v209, v206, v204, v202);
        float32x4_t v135 = vsubq_f32(v133, v134);
        float32x4_t v136 = vaddq_f32(v133, v134);
        v135.i32[2] = v192.i32[2];
        v136.i32[2] = v191.i32[2];
        v137.i64[0] = 0x3F0000003F000000;
        v137.i64[1] = 0x3F0000003F000000;
        C3DConvexPolyhedronSetAABB(v120, vmulq_f32(vaddq_f32(v135, v136), v137), vmulq_f32(vsubq_f32(v136, v135), v137));
        C3DConvexPolyhedronTransform(v120, &v245);
        if (!C3DConvexPolyhedronClipAABB(v120, v216, v211))
        {
LABEL_55:
          float32x4_t v113 = v209;
          float32x4_t v112 = v204;
          float32x4_t v111 = v206;
          float32x4_t v114 = v202;
          uint64_t v120 = v194;
          goto LABEL_56;
        }
        float32x4_t v138 = C3DConvexPolyhedronComputeBoxInSpace(v120, v209, v206, v204, v202);
        float32x4_t v140 = vmulq_f32(vaddq_f32(v139, (float32x4_t)vdupq_n_s32(0x3C23D70Au)), (float32x4_t)vdupq_n_s32(0x3F800054u));
        v140.i32[3] = v139.i32[3];
        uint64_t v141 = v48 + 384 * v122;
        *(float32x4_t *)(v141 + 352) = v138;
        *(float32x4_t *)(v141 + 368) = v140;
        *(double *)&long long v142 = _computeOrthographicProjectionFromShadowBoundingBox(a8, (__n128)vsubq_f32(v138, v140), (__n128)vaddq_f32(v138, v140));
        *(_OWORD *)(v141 + 128) = v142;
        *(_OWORD *)(v141 + 144) = v143;
        *(_OWORD *)(v141 + 160) = v144;
        *(_OWORD *)(v141 + 176) = v145;
        LODWORD(v120) = v194;
      }
      else
      {
        __computeStableCascade(v123, v207, a8, v109, v110);
      }
      uint64_t v120 = (v120 + 1);
      float32x4_t v113 = v209;
      float32x4_t v112 = v204;
      float32x4_t v111 = v206;
      float32x4_t v114 = v202;
LABEL_56:
      ++v121;
      --v118;
      float32x4_t v110 = v211;
      float32x4_t v109 = v216;
      if (!v118) {
        goto LABEL_78;
      }
    }
  }
  float32x4_t v161 = scn_default_log();
  if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
    C3DLightingSystemComputeShadowMatrices_cold_3(v161, v162, v163, v164, v165, v166, v167, v168);
  }
}

uint64_t C3DLightingSystemGetActiveNonAmbientLightCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 608);
}

uint64_t C3DLightingSystemApplyActiveNonAmbientLights(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 608))
  {
    uint64_t v3 = result;
    unint64_t v4 = 0;
    uint64_t v5 = result + 624;
    uint64_t v6 = result + 6176;
    do
    {
      unint64_t v7 = v4 + 1;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a2 + 16))(a2, *(void *)(v5 + 8 * v4), v6);
      v6 += 432;
      unint64_t v4 = v7;
    }
    while (v7 < *(unsigned int *)(v3 + 608));
  }
  return result;
}

uint64_t __lightsWithTechniqueEnumerator(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
}

void C3DLightingSystemSetShadowMapNameForNode(uint64_t a1, const void *a2, const void *a3)
{
}

const void *C3DLightingSystemGetShadowMapNameForNode(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
}

const void *C3DLightingSystemGetActiveShadowCasterIndex(uint64_t a1, const void *a2)
{
  uint64_t result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (result) {
    return (const void *)*(unsigned __int8 *)((result & 0xFFFFFFF)
  }
                                            + *(void *)(a1 + 8 * (result >> 28) + 392)
                                            - 1);
  return result;
}

uint64_t C3DLightingSystemGetActiveShadowCasterData(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 9)
    {
      unint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        C3DLightingSystemGetActiveShadowCasterData_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
  }
  else
  {
    int32x2_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DLightingSystemGetActiveShadowCasterData_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return a1 + 1568 * a2 + 115200;
}

BOOL _isValidCustomPropertyType(void *a1)
{
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  return (objc_opt_isKindOfClass() & 1) != 0
      && strcmp((const char *)[a1 objCType], "{CGRect={CGPoint=dd}{CGSize=dd}}") == 0;
}

C3D::DrawBackgroundPass *C3D::DrawBackgroundPass::DrawBackgroundPass(C3D::DrawBackgroundPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  unint64_t v4 = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)unint64_t v4 = &unk_26BF6DB30;
  bzero((char *)v4 + 240, 0x13A8uLL);
  return this;
}

const char *C3D::DrawBackgroundPass::name(C3D::DrawBackgroundPass *this)
{
  return "DrawBackgroundPass";
}

uint64_t C3D::DrawBackgroundPass::setup(C3D::DrawBackgroundPass *this)
{
  uint64_t v2 = (char *)this + 4868;
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  *((void *)this + 658) = C3DSceneGetBackgroundEffectSlot(Scene, 0);
  C3D::Pass::setOutputCount(this, 1u);
  *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::DrawBackgroundPass *)((char *)this + 32), 0) + 8) = "BACKGROUND";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v14);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::DrawBackgroundPass *)((char *)this + 32), 0);
  *(_OWORD *)(v5 + 16) = v14;
  *(_DWORD *)(v5 + 32) = v15;
  uint64_t v6 = *((void *)this + 658);
  if (!v6 || C3DEffectSlotGetColorIfApplicable(v6))
  {
    uint64_t v7 = C3D::PassDescriptor::outputAtIndex((C3D::DrawBackgroundPass *)((char *)this + 32), 0);
    *(_WORD *)(v7 + 66) = *(_WORD *)(v7 + 66) & 0xFFFC | 2;
  }
  *((void *)this + 30) = EnginePipeline;
  v2[66] = 0;
  *((void *)this + 622) = *((void *)this + 2);
  v2[64] = 1;
  *((void *)this + 621) = Scene;
  uint64_t v8 = *((unsigned __int16 *)this + 19);
  char *v2 = v8;
  v2[3] = 0;
  if (v8) {
    bzero((char *)this + 5152, 16 * v8);
  }
  v2[4] = 0;
  *((void *)this + 612) = 0;
  *((void *)this + 613) = this;
  *((void *)this + 657) = 0;
  v2[65] = 0;
  v2[380] = 0;
  float v2[2] = *((_DWORD *)this + 11);
  v2[68] = 0;
  *((void *)this + 614) = C3DSceneGetRootNode(Scene);
  v2[60] = 1;
  uint64_t v9 = C3D::PassDescriptor::outputAtIndex((C3D::DrawBackgroundPass *)((char *)this + 32), 0);
  if (*((unsigned char *)this + 121))
  {
    long long v10 = *((_OWORD *)this + 8);
  }
  else
  {
    v11.i32[0] = *(unsigned __int16 *)(v9 + 16);
    v11.i32[1] = *(unsigned __int16 *)(v9 + 18);
    float32x2_t v12 = vcvt_f32_u32(v11);
    *(void *)&long long v10 = 0;
    *((float32x2_t *)&v10 + 1) = v12;
  }
  *((_OWORD *)this + 305) = v10;
  v2[61] = 0;
  C3DCullingContextSetupMatricesToIdentity((uint64_t)this + 240);
  uint64_t result = C3DEngineContextGetAuthoringEnvironment(*((void *)this + 2), 0);
  *((void *)this + 620) = result;
  *((_WORD *)v2 + 31) = 0;
  return result;
}

void C3D::DrawBackgroundPass::execute(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  uint64_t v3 = (const void *)(v1 + 240);
  bzero(v5, 0x1410uLL);
  v5[24] = *(unsigned char *)(v2 + 4868);
  __int16 v6 = *(_WORD *)(v2 + 117);
  memcpy(v7, v3, sizeof(v7));
  uint64_t v4 = *(void *)(v2 + 5264);
  if (v4) {
    C3DEngineContextRenderBackgroundMap(*(void *)(v2 + 16), v4, (uint64_t)v5);
  }
}

void sub_20B3EFBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _rendererCallback(float32x4_t *a1, uint64_t a2, void *a3, uint64_t a4)
{
  memset(v25, 0, sizeof(v25));
  uint64_t v7 = (void *)[a3 rendererDelegate];
  uint64_t UserInfo = C3DEngineContextGetUserInfo((uint64_t)a1);
  uint64_t v9 = (void *)[MEMORY[0x263EFF9A0] dictionaryWithCapacity:6];
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t Matrix4x4 = C3DEngineContextGetMatrix4x4((uint64_t)a1, 0);
  C3DMatrix4x4ToSCNMatrix4(Matrix4x4, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kProjectionTransform");
  uint64_t v11 = C3DEngineContextGetMatrix4x4((uint64_t)a1, 2);
  C3DMatrix4x4ToSCNMatrix4(v11, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kModelTransform");
  uint64_t v12 = C3DEngineContextGetMatrix4x4((uint64_t)a1, 1);
  C3DMatrix4x4ToSCNMatrix4(v12, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kViewTransform");
  C3DEngineContextComputeNormalMatrix(a1, v25);
  C3DMatrix4x4ToSCNMatrix4((uint64_t)v25, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kNormalTransform");
  uint64_t v13 = C3DEngineContextGetMatrix4x4((uint64_t)a1, 2);
  long long v14 = (float32x4_t *)C3DEngineContextGetMatrix4x4((uint64_t)a1, 1);
  C3DMatrix4x4Mult(v13, v14, v25);
  C3DMatrix4x4ToSCNMatrix4((uint64_t)v25, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kModelViewTransform");
  int v15 = (float32x4_t *)C3DEngineContextGetMatrix4x4((uint64_t)a1, 0);
  C3DMatrix4x4Mult((uint64_t)v25, v15, v25);
  C3DMatrix4x4ToSCNMatrix4((uint64_t)v25, &v21);
  long long v17 = v21;
  long long v18 = v22;
  long long v19 = v23;
  long long v20 = v24;
  objc_msgSend(v9, "setValue:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNMatrix4:", &v17), @"kModelViewProjectionTransform");
  if (a4) {
    [v9 setValue:C3DFXPassGetName(a4) forKey:@"kRenderPassName"];
  }
  return [v7 renderNode:a3 renderer:UserInfo arguments:v9];
}

void sub_20B3F2F18(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F3158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

void sub_20B3F3374(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F3570(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F5374(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F5468(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F557C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F56C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B3F5800(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t SCNNodeRemoveDeadParticleInstance(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = +[SCNNode nodeWithNodeRef:result];
    return [(SCNNode *)v3 _removeDeadParticleSystem:a2];
  }
  return result;
}

void sub_20B3F851C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _findClone(void *a1, void *a2, void *a3)
{
  if (a1 == a2) {
    return (uint64_t)a3;
  }
  unint64_t v6 = objc_msgSend((id)objc_msgSend(a3, "childNodes"), "count");
  unint64_t v7 = objc_msgSend((id)objc_msgSend(a2, "childNodes"), "count");
  if (v7 >= v6)
  {
    if (v6)
    {
      unint64_t v10 = v7;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      while (1)
      {
        uint64_t v13 = objc_msgSend((id)objc_msgSend(a2, "childNodes"), "objectAtIndex:", v11);
        if ([v13 isGizmo])
        {
          do
          {
            if (++v11 >= v10) {
              break;
            }
            uint64_t v13 = objc_msgSend((id)objc_msgSend(a2, "childNodes"), "objectAtIndex:", v11);
          }
          while (([v13 isGizmo] & 1) != 0);
        }
        if ([v13 isGizmo]) {
          break;
        }
        uint64_t result = _findClone(a1, v13, objc_msgSend((id)objc_msgSend(a3, "childNodes"), "objectAtIndex:", v12));
        if (!result && ++v12 < v6 && ++v11 < v10) {
          continue;
        }
        return result;
      }
    }
  }
  else
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      _findClone_cold_1();
    }
  }
  return 0;
}

void OUTLINED_FUNCTION_9_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

void sub_20B3FADDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_20B3FD610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

uint64_t C3DSceneGetPhysicsWorld(id *a1, uint64_t a2)
{
  ObjCWrapper = C3DEntityGetObjCWrapper(a1);

  return [ObjCWrapper _physicsWorldCreateIfNeeded:a2];
}

__n128 C3DPhysicsWorldGetWorldGravity(void *a1, _OWORD *a2)
{
  [a1 gravity];
  DWORD1(v5) = v3;
  DWORD2(v5) = v4;
  *a2 = v5;
  result.n128_u64[0] = v5;
  result.n128_u32[2] = DWORD2(v5);
  return result;
}

uint64_t C3DSceneRegisterNodePhysicsField(id *a1, id *a2)
{
  ObjCWrapper = C3DEntityGetObjCWrapper(a1);
  int v4 = C3DEntityGetObjCWrapper(a2);
  uint64_t result = [v4 physicsField];
  if (result)
  {
    unint64_t v6 = (void *)[ObjCWrapper physicsWorld];
    uint64_t v7 = [v4 physicsField];
    return [v6 _addFieldToWorld:v7];
  }
  return result;
}

uint64_t C3DSceneUnregisterNodePhysicsField(id *a1, id *a2)
{
  ObjCWrapper = C3DEntityGetObjCWrapper(a1);
  int v4 = C3DEntityGetObjCWrapper(a2);
  uint64_t result = [v4 physicsField];
  if (result)
  {
    unint64_t v6 = (void *)[ObjCWrapper physicsWorld];
    uint64_t v7 = [v4 physicsField];
    return [v6 _removeFieldFromWorld:v7];
  }
  return result;
}

uint64_t __inferRenderingAPIFromGLContext(void *a1)
{
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 1;
  }
  if ([a1 API] == 3) {
    return 2;
  }
  return 1;
}

void deleteGLFramebufferInfo(uint64_t *a1, uint64_t a2)
{
  if (*a1)
  {
    C3DRendererContextDeleteFramebuffer(a2, *a1, 1);
    CFRelease((CFTypeRef)*a1);
    *a1 = 0;
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    C3DRendererContextDeleteFramebuffer(a2, v4, 1);
    CFRelease((CFTypeRef)a1[1]);
    a1[1] = 0;
  }
}

BOOL createGLFramebufferInfo(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      createGLFramebufferInfo_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a1[1])
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      createGLFramebufferInfo_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  float32x2_t v24 = vcvt_f32_f64(*((float64x2_t *)a1 + 1));
  int32x2_t v25 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vceq_f32(v24, 0), 0), (int8x8_t)__PAIR64__(v24.u32[1], 1.0), (int8x8_t)v24);
  int8x8_t v26 = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_f32((float32x2_t)vdup_lane_s32(v25, 1), 0), 0), (int8x8_t)__PAIR64__(1.0, v25.u32[0]), (int8x8_t)v25);
  double v43 = *(double *)&v26;
  if (*(float *)v26.i32 <= 0.0 || *(float *)&v26.i32[1] <= 0.0)
  {
    uint64_t v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      createGLFramebufferInfo_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
    }
  }
  uint64_t v35 = C3DFramebufferCreate();
  *a1 = v35;
  C3DFramebufferSetSize(v35, v43);
  *(void *)(*a1 + 136) = a4;
  uint64_t v36 = C3DRenderTargetDescriptionMake(1u, a4 == 0);
  C3DFramebufferAddRenderTargetDescription(*a1, 0, v36);
  if (a2 <= 1)
  {
    uint64_t v37 = C3DRenderTargetDescriptionMake(0x29u, 0);
    C3DFramebufferAddRenderTargetDescription(*a1, 4, v37);
  }
  BOOL result = C3DRendererContextSetupFramebuffer(a3, *a1);
  if (a2 >= 2 && result)
  {
    uint64_t v39 = C3DFramebufferCreate();
    a1[1] = v39;
    unsigned __int8 v40 = a2;
    C3DFramebufferSetSampleCount(v39, a2);
    C3DFramebufferSetSize(a1[1], v43);
    uint64_t v41 = C3DRenderTargetDescriptionMake(1u, 0);
    uint64_t v42 = C3DRenderTargetDescriptionMake(0x29u, 0);
    C3DFramebufferAddRenderTargetDescription(a1[1], 0, v41 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v40 << 8));
    C3DFramebufferAddRenderTargetDescription(a1[1], 4, v42 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v40 << 8));
    return C3DRendererContextSetupFramebuffer(a3, a1[1]);
  }
  return result;
}

void _SCNGetEffectiveLegacyFieldOfView(double *a1, double *a2, double a3, double a4, long double a5)
{
  double v7 = a3;
  if (a4 == 0.0 && a3 == 0.0) {
    double v9 = 60.0;
  }
  else {
    double v9 = a4;
  }
  if (a3 != 0.0 && v9 != 0.0)
  {
    double v11 = tan(a3 / 180.0 * 3.14159265);
    if (v11 / tan(v9 / 180.0 * 3.14159265) <= a5) {
      double v7 = 0.0;
    }
    else {
      double v9 = 0.0;
    }
  }
  *a1 = v7;
  *a2 = v9;
}

double _SCNConvertFieldOfViewFromVerticalToHorizontal(double a1, double a2)
{
  double v3 = __tanpi(a1 / 360.0);
  double v4 = atan(v3 * a2);
  if (v4 < 0.0) {
    double v4 = 3.14159265 - v4;
  }
  return v4 * 114.591559;
}

double _SCNConvertFieldOfViewFromHorizontalToVertical(double a1, double a2)
{
  double v3 = __tanpi(a1 / 360.0);
  double v4 = atan(v3 / a2);
  if (v4 < 0.0) {
    double v4 = 3.14159265 - v4;
  }
  return v4 * 114.591559;
}

uint64_t _mainPassCustomPostProcessUsesExtraRenderTargetEngineContextCallback(uint64_t a1, _DWORD *a2)
{
  uint64_t result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    uint64_t v4 = result;
    if ((*(_WORD *)(result + 292) & 0x200) != 0)
    {
      uint64_t v5 = 0;
    }
    else
    {
      if ((*(_WORD *)(result + 296) & 0x200) == 0) {
        return 0;
      }
      uint64_t v5 = 0;
      uint64_t result = *(void *)(result + 344);
    }
    uint64_t result = [(id)result _customMainPassPostProcessUsesExtraRenderTargetForRenderer:v4 pixelFormat:&v5];
    *a2 = v5;
  }
  return result;
}

uint64_t _useSpecificMainPassClearColorEngineContextCallback(uint64_t a1, uint64_t a2)
{
  uint64_t UserInfo = C3DEngineContextGetUserInfo(a1);
  if (!UserInfo) {
    return 0;
  }
  uint64_t v4 = UserInfo;
  if ((*(_WORD *)(UserInfo + 292) & 0x200) == 0)
  {
    if ((*(_WORD *)(UserInfo + 296) & 0x200) == 0) {
      return 0;
    }
    uint64_t UserInfo = *(void *)(UserInfo + 344);
  }

  return [(id)UserInfo _usesSpecificMainPassClearColorForRenderer:v4 clearColor:a2];
}

void sub_20B400B70(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *_readSubdivCacheEngineContextCallback(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    return (void *)[result _readSubdivCacheForHash:a2];
  }
  return result;
}

void *_writeSubdivCacheEngineContextCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (void *)C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    return (void *)[result _writeSubdivCacheForHash:a2 dataProvider:a3];
  }
  return result;
}

uint64_t _encodeMainPassCustomPostProcessEngineContextCallback(uint64_t a1, uint64_t a2)
{
  uint64_t result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    uint64_t v4 = result;
    double v5 = *(double *)(result + 160);
    if (v5 == 0.0) {
      double v5 = *(double *)(result + 144);
    }
    if ((*(_WORD *)(result + 292) & 0x200) != 0) {
      uint64_t result = [(id)result _encodeCustomMainPassPostProcessForRenderer:result atTime:a2 helper:v5];
    }
    if ((*(_WORD *)(v4 + 296) & 0x200) != 0)
    {
      unint64_t v6 = *(void **)(v4 + 344);
      return [v6 _encodeCustomMainPassPostProcessForRenderer:v6 atTime:a2 helper:v5];
    }
  }
  return result;
}

uint64_t _renderOverlayEngineContextCallback(uint64_t a1)
{
  uint64_t result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    double v3 = (void *)result;
    double SceneTime = C3DEngineContextGetSceneTime(a1);
    return [v3 _drawOverlaySceneAtTime:SceneTime];
  }
  return result;
}

void sub_20B401F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL SCNKitSplitKVCPath(void *a1, void *a2, uint64_t *a3)
{
  uint64_t v6 = [a1 rangeOfString:@"."];
  uint64_t v8 = v7;
  if (v7 == 1)
  {
    uint64_t v9 = v6;
    *a2 = objc_msgSend(a1, "substringWithRange:", 0, v6);
    uint64_t v10 = objc_msgSend(a1, "substringWithRange:", v9 + 1, objc_msgSend(a1, "length") + ~v9);
  }
  else
  {
    uint64_t v10 = 0;
    *a2 = a1;
  }
  *a3 = v10;
  return v8 == 1;
}

const void *SCNGetCachedImageProxyOrCreateIfNeededForSource(void *a1, uint64_t a2)
{
  Shareduint64_t Instance = C3DResourceCacheGetSharedInstance();
  IfNeededForSource = (const void *)C3DResourceCacheCopyResourceOrCreateIfNeededForSource(SharedInstance, a1, 1, a2);
  uint64_t v6 = IfNeededForSource;
  if (IfNeededForSource) {
    CFAutorelease(IfNeededForSource);
  }
  return v6;
}

uint64_t C3DColor4ToRGBCFColor(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x263F1C550], "scn_colorWithC3DColor:", a1);
}

uint64_t SCNLightTypeToC3DLightType(void *a1)
{
  if ([a1 isEqualToString:@"ambient"]) {
    return 0;
  }
  if ([a1 isEqualToString:@"directional"]) {
    return 1;
  }
  if ([a1 isEqualToString:@"omni"]) {
    return 2;
  }
  if ([a1 isEqualToString:@"spot"]) {
    return 3;
  }
  if ([a1 isEqualToString:@"probe"]) {
    return 4;
  }
  if ([a1 isEqualToString:@"ies"]) {
    return 5;
  }
  if ([a1 isEqualToString:@"area"]) {
    return 6;
  }
  double v3 = scn_default_log();
  uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  if (result)
  {
    SCNLightTypeToC3DLightType_cold_1();
    return 0;
  }
  return result;
}

SCNLightType SCNLightTypeFromC3DLightType(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = &SCNLightTypeAmbient;
      goto LABEL_10;
    case 1:
      uint64_t v1 = &SCNLightTypeDirectional;
      goto LABEL_10;
    case 2:
      uint64_t v1 = &SCNLightTypeOmni;
      goto LABEL_10;
    case 3:
      uint64_t v1 = &SCNLightTypeSpot;
      goto LABEL_10;
    case 4:
      uint64_t v1 = &SCNLightTypeProbe;
      goto LABEL_10;
    case 5:
      uint64_t v1 = &SCNLightTypeIES;
      goto LABEL_10;
    case 6:
      uint64_t v1 = &SCNLightTypeArea;
LABEL_10:
      SCNLightType result = *v1;
      break;
    default:
      SCNLightType result = 0;
      break;
  }
  return result;
}

uint64_t SCNEncodeColor(void *a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  double v5 = (CGColor *)[(id)scn_NSColorFromCGColorIfApplicable(cf) CGColor];
  if (v5) {
    *(double *)&long long v6 = C3DCGColorGetLinearExtendedSRGBComponents(v5);
  }
  else {
    long long v6 = xmmword_20B5CB530;
  }
  long long v8 = v6;
  return [a1 encodeBytes:&v8 length:16 forKey:a3];
}

uint64_t SCNDecodeColor(void *a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v2 = (float32x4_t *)[a1 decodeBytesForKey:a2 returnedLength:&v8];
  float32x4_t v3 = 0uLL;
  if (v8 == 16) {
    float32x4_t v3 = *v2;
  }
  CGColorRef ExtendedLinearSRGBWithComponents = C3DCGColorCreateExtendedLinearSRGBWithComponents(v3);
  if (!ExtendedLinearSRGBWithComponents) {
    return 0;
  }
  CGColorRef v5 = ExtendedLinearSRGBWithComponents;
  uint64_t v6 = [MEMORY[0x263F1C550] colorWithCGColor:ExtendedLinearSRGBWithComponents];
  CFRelease(v5);
  return v6;
}

uint64_t SCNEncodeVector3(void *a1, uint64_t a2, float a3, float a4, float a5)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  *(float *)uint64_t v6 = a3;
  *(float *)&v6[1] = a4;
  *(float *)&_OWORD v6[2] = a5;
  return [a1 encodeBytes:v6 length:12 forKey:a2];
}

uint64_t SCNEncodeVector4(void *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  *(float *)uint64_t v7 = a3;
  *(float *)&v7[1] = a4;
  *(float *)&v7[2] = a5;
  *(float *)&v7[3] = a6;
  return [a1 encodeBytes:v7 length:16 forKey:a2];
}

uint64_t SCNEncodeSCNMatrix4(void *a1, const char *a2, uint64_t a3)
{
  return [a1 encodeBytes:a3 length:64 forKey:a2];
}

float SCNDecodeVector3(void *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v2 = [a1 decodeBytesForKey:a2 returnedLength:&v4];
  float result = 0.0;
  if (v4 == 12) {
    return *(float *)v2;
  }
  return result;
}

float SCNDecodeVector4(void *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v2 = [a1 decodeBytesForKey:a2 returnedLength:&v4];
  float result = 0.0;
  if (v4 == 16) {
    return *(float *)v2;
  }
  return result;
}

_OWORD *SCNDecodeSCNMatrix4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v8 = 0;
  float result = (_OWORD *)[a1 decodeBytesForKey:a2 returnedLength:&v8];
  if (v8 == 64)
  {
    long long v5 = result[1];
    *a3 = *result;
    a3[1] = v5;
    long long v6 = result[2];
    long long v7 = result[3];
  }
  else
  {
    *a3 = *(_OWORD *)&SCNMatrix4Identity.m11;
    a3[1] = *(_OWORD *)&SCNMatrix4Identity.m21;
    long long v6 = *(_OWORD *)&SCNMatrix4Identity.m31;
    long long v7 = *(_OWORD *)&SCNMatrix4Identity.m41;
  }
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

uint64_t _SCNArrayFromCGPathApply(void *a1, unsigned int *a2)
{
  uint64_t v4 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  int v5 = *a2;
  objc_msgSend(v4, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithInt:", *a2), @"type");
  long long v6 = (double *)*((void *)a2 + 1);
  long long v7 = (void *)[MEMORY[0x263EFF980] array];
  switch(v5)
  {
    case 0:
    case 1:
      uint64_t v8 = (void *)MEMORY[0x263F08D40];
      double v9 = *v6;
      double v10 = v6[1];
      goto LABEL_5;
    case 2:
      objc_msgSend(v7, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "SCN_valueWithCGPoint:", *v6, v6[1]));
      uint64_t v8 = (void *)MEMORY[0x263F08D40];
      double v9 = v6[2];
      double v10 = v6[3];
      goto LABEL_5;
    case 3:
      objc_msgSend(v7, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "SCN_valueWithCGPoint:", *v6, v6[1]));
      objc_msgSend(v7, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "SCN_valueWithCGPoint:", v6[2], v6[3]));
      uint64_t v8 = (void *)MEMORY[0x263F08D40];
      double v9 = v6[4];
      double v10 = v6[5];
LABEL_5:
      objc_msgSend(v7, "addObject:", objc_msgSend(v8, "SCN_valueWithCGPoint:", v9, v10));
      break;
    case 4:
      break;
    default:
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v13 = 0;
        _os_log_impl(&dword_20B249000, v12, OS_LOG_TYPE_DEFAULT, "Warning: CGPath archiving: unknown path element type", v13, 2u);
      }
      break;
  }
  [v4 setValue:v7 forKey:@"points"];
  return [a1 addObject:v4];
}

CGPath *_SCNCGPathCreateFromArray(void *a1)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  CFDictionaryRef Mutable = CGPathCreateMutable();
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v3 = [a1 countByEnumeratingWithState:&v32 objects:v36 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v33;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v33 != v5) {
          objc_enumerationMutation(a1);
        }
        long long v7 = *(void **)(*((void *)&v32 + 1) + 8 * i);
        int v8 = objc_msgSend((id)objc_msgSend(v7, "objectForKey:", @"type"), "intValue");
        double v9 = (void *)[v7 objectForKey:@"points"];
        double v10 = v9;
        switch(v8)
        {
          case 0:
            objc_msgSend((id)objc_msgSend(v9, "objectAtIndex:", 0), "SCN_CGPointValue");
            CGPathMoveToPoint(Mutable, 0, v11, v12);
            break;
          case 1:
            objc_msgSend((id)objc_msgSend(v9, "objectAtIndex:", 0), "SCN_CGPointValue");
            CGPathAddLineToPoint(Mutable, 0, v13, v14);
            break;
          case 2:
            objc_msgSend((id)objc_msgSend(v9, "objectAtIndex:", 0), "SCN_CGPointValue");
            CGFloat v16 = v15;
            CGFloat v18 = v17;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 1), "SCN_CGPointValue");
            CGPathAddQuadCurveToPoint(Mutable, 0, v16, v18, v19, v20);
            break;
          case 3:
            objc_msgSend((id)objc_msgSend(v9, "objectAtIndex:", 0), "SCN_CGPointValue");
            CGFloat v22 = v21;
            CGFloat v24 = v23;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 1), "SCN_CGPointValue");
            CGFloat v26 = v25;
            CGFloat v28 = v27;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 2), "SCN_CGPointValue");
            CGPathAddCurveToPoint(Mutable, 0, v22, v24, v26, v28, v29, v30);
            break;
          case 4:
            CGPathCloseSubpath(Mutable);
            break;
          default:
            continue;
        }
      }
      uint64_t v4 = [a1 countByEnumeratingWithState:&v32 objects:v36 count:16];
    }
    while (v4);
  }
  return Mutable;
}

uint64_t SCNEncodeCGPathForKey(uint64_t a1, const CGPath *a2, uint64_t a3)
{
  return _SCNEncodeCGPathForKey(a1, a2, 0, a3);
}

uint64_t _SCNEncodeCGPathForKey(uint64_t result, const CGPath *a2, _DWORD *a3, uint64_t a4)
{
  v11[2] = *MEMORY[0x263EF8340];
  if (a2)
  {
    long long v7 = (void *)result;
    int v8 = (void *)[MEMORY[0x263EFF980] array];
    CGPathApply(a2, v8, (CGPathApplierFunction)_SCNArrayFromCGPathApply);
    if (a3)
    {
      v10[1] = @"flatness";
      v11[0] = v8;
      v10[0] = @"path";
      LODWORD(v9) = *a3;
      v11[1] = [NSNumber numberWithFloat:v9];
      return objc_msgSend(v7, "encodeObject:forKey:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v11, v10, 2), a4);
    }
    else
    {
      return [v7 encodeObject:v8 forKey:a4];
    }
  }
  return result;
}

uint64_t SCNEncodeBezierPathForKey(uint64_t a1, void *a2, uint64_t a3)
{
  [a2 flatness];
  *(float *)&double v6 = v6;
  int v8 = LODWORD(v6);
  return _SCNEncodeCGPathForKey(a1, (const CGPath *)[a2 CGPath], &v8, a3);
}

CGPath *SCNDecodeCGPathForKey(void *a1, uint64_t a2)
{
  float result = _SCNDecodeCGPathForKey(a1, a2, 0);
  if (result)
  {
    return (CGPath *)CFAutorelease(result);
  }
  return result;
}

CGPath *_SCNDecodeCGPathForKey(void *a1, uint64_t a2, _DWORD *a3)
{
  double v6 = (void *)MEMORY[0x263EFFA08];
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  double v10 = objc_msgSend(a1, "decodeObjectOfClasses:forKey:", objc_msgSend(v6, "setWithObjects:", v7, v8, v9, objc_opt_class(), 0), a2);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (a3)
      {
        objc_msgSend((id)objc_msgSend(v10, "valueForKey:", @"flatness"), "floatValue");
        *a3 = v11;
      }
      double v10 = (void *)[v10 valueForKey:@"path"];
    }
    else
    {
      double v10 = 0;
    }
  }

  return _SCNCGPathCreateFromArray(v10);
}

void *SCNDecodeBezierPathForKey(void *a1, uint64_t a2)
{
  float v6 = -1.0;
  uint64_t v2 = _SCNDecodeCGPathForKey(a1, a2, &v6);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = (void *)[MEMORY[0x263F1C478] bezierPathWithCGPath:v2];
  CFRelease(v3);
  if (v6 >= 0.0) {
    [v4 setFlatness:v6];
  }
  return v4;
}

uint64_t SCNEncodeEntity(void *a1, void *a2)
{
  uint64_t result = C3DEntityGetID(objc_msgSend(a2, "__CFObject"));
  if (result)
  {
    return [a1 encodeObject:result forKey:@"entityID"];
  }
  return result;
}

CFTypeRef SCNDecodeEntity(void *a1, void *a2)
{
  CFTypeRef result = (CFTypeRef)[a1 decodeObjectOfClass:objc_opt_class() forKey:@"entityID"];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = objc_msgSend(a2, "__CFObject");
    return C3DEntitySetID(v5, v4);
  }
  return result;
}

uint64_t SCNEncodeMTLTextureAsDataForKey(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = SCNCreateDataWithMTLTexture(a2);
  if (result) {
    return [a1 encodeObject:result forKey:a3];
  }
  return result;
}

uint64_t SCNEncodeUnsafeObjectForKey(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = [MEMORY[0x263F08910] archivedDataWithRootObject:a2 requiringSecureCoding:1 error:0];
  if (result) {
    return [a1 encodeObject:result forKey:a3];
  }
  return result;
}

uint64_t SCNDecodeUnsecureColor(void *a1, uint64_t a2)
{
  v7[2] = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)MEMORY[0x263EFFA08];
  v7[0] = objc_opt_class();
  v7[1] = objc_opt_class();
  uint64_t v5 = objc_msgSend(a1, "decodeObjectOfClasses:forKey:", objc_msgSend(v4, "setWithArray:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v7, 2)), a2);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      return objc_msgSend(MEMORY[0x263F08928], "unarchivedObjectOfClasses:fromData:error:", objc_msgSend(MEMORY[0x263EFFA08], "setWithObject:", objc_opt_class()), v5, 0);
    }
    else {
      return 0;
    }
  }
  return v5;
}

uint64_t SCNDecodeUnsafeObjectForKey(void *a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a3) {
    uint64_t v6 = [a3 setByAddingObject:objc_opt_class()];
  }
  else {
    uint64_t v6 = [MEMORY[0x263EFFA08] setWithObject:objc_opt_class()];
  }
  uint64_t v7 = [a1 decodeObjectOfClasses:v6 forKey:a2];
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([a1 requiresSecureCoding])
      {
        uint64_t v8 = (void *)[objc_alloc(MEMORY[0x263F08928]) initForReadingFromData:v7 error:0];
        if (!v3)
        {
          if (SCNUserInfoClasses_onceToken != -1) {
            dispatch_once(&SCNUserInfoClasses_onceToken, &__block_literal_global_110);
          }
          uint64_t v3 = (void *)SCNUserInfoClasses_set;
        }
        uint64_t v7 = objc_msgSend(v8, "scn_decodeObjectOfClasses:forKey:", v3, *MEMORY[0x263F081D0]);
        [v8 finishDecoding];
      }
      else
      {
        uint64_t v9 = [MEMORY[0x263F08928] unarchiveObjectWithData:v7];
        if ([v3 count])
        {
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          uint64_t v10 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
          if (!v10) {
            return 0;
          }
          uint64_t v11 = *(void *)v15;
LABEL_15:
          uint64_t v12 = 0;
          while (1)
          {
            if (*(void *)v15 != v11) {
              objc_enumerationMutation(v3);
            }
            if (objc_opt_isKindOfClass()) {
              break;
            }
            if (v10 == ++v12)
            {
              uint64_t v10 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
              uint64_t v7 = 0;
              if (v10) {
                goto LABEL_15;
              }
              return v7;
            }
          }
        }
        return v9;
      }
    }
  }
  return v7;
}

void sub_20B407EE8(_Unwind_Exception *a1)
{
}

void sub_20B407EF0()
{
}

uint64_t SCNUserInfoClasses()
{
  if (SCNUserInfoClasses_onceToken != -1) {
    dispatch_once(&SCNUserInfoClasses_onceToken, &__block_literal_global_110);
  }
  return SCNUserInfoClasses_set;
}

void SCNEncodeC3DAnimationForKey(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (void *)C3DCopyPropertyList(a2, 0, 0, 0);
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == C3DSimpleAnimationGetTypeID())
  {
    uint64_t v8 = @"basic";
  }
  else
  {
    CFTypeID v9 = CFGetTypeID(a2);
    if (v9 == C3DKeyframedAnimationGetTypeID())
    {
      uint64_t v8 = @"keyframe";
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(a2);
      if (v10 == C3DAnimationGroupGetTypeID())
      {
        uint64_t v8 = @"group";
      }
      else
      {
        uint64_t v11 = scn_default_log();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          SCNEncodeC3DAnimationForKey_cold_1();
        }
        uint64_t v8 = 0;
      }
    }
  }
  uint64_t v12 = (void *)[MEMORY[0x263EFF9A0] dictionaryWithCapacity:4];
  [v12 setValue:v6 forKey:@"animation"];
  [v12 setValue:v8 forKey:@"class"];
  [a1 encodeObject:v12 forKey:a3];
}

uint64_t SCNDecodeC3DAnimationForKey(void *a1, uint64_t a2)
{
  if (SCNPlistClasses_onceToken != -1) {
    dispatch_once(&SCNPlistClasses_onceToken, &__block_literal_global_74);
  }
  uint64_t v4 = [a1 decodeObjectOfClasses:SCNPlistClasses_set forKey:a2];
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (void *)v4;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return (uint64_t)v5;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFTypeID v9 = (void *)[v5 valueForKey:@"class"];
    if ([v9 isEqualToString:@"basic"])
    {
      CFTypeID v10 = (void *)C3DSimpleAnimationCreate();
    }
    else if ([v9 isEqualToString:@"keyframe"])
    {
      CFTypeID v10 = (void *)C3DKeyframedAnimationCreate();
    }
    else
    {
      if (![v9 isEqualToString:@"group"]) {
        goto LABEL_20;
      }
      CFTypeID v10 = (void *)C3DAnimationGroupCreate();
    }
    uint64_t v6 = v10;
    if (v10)
    {
      id v11 = v10;
      if (C3DInitWithPropertyList(v6, [v5 valueForKey:@"animation"], 0, 0)) {
        return (uint64_t)v6;
      }
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        SCNDecodeC3DAnimationForKey_cold_2();
      }
      return 0;
    }
LABEL_20:
    CGFloat v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      SCNDecodeC3DAnimationForKey_cold_1();
    }
    return 0;
  }
  CFTypeID v7 = (void *)[MEMORY[0x263EFFA08] setWithObject:objc_opt_class()];

  return SCNDecodeUnsafeObjectForKey(a1, a2, v7);
}

uint64_t SCNPlistClasses()
{
  if (SCNPlistClasses_onceToken != -1) {
    dispatch_once(&SCNPlistClasses_onceToken, &__block_literal_global_74);
  }
  return SCNPlistClasses_set;
}

void *SCNEncodeAnimations(void *a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)[a2 animationKeys];
  uint64_t v37 = a1;
  if (v4)
  {
    uint64_t v5 = v4;
    if ([v4 count])
    {
      uint64_t v42 = objc_msgSend(MEMORY[0x263EFF9A0], "dictionaryWithCapacity:", objc_msgSend(v5, "count"));
      uint64_t v6 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v5, "count"));
      double v43 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v5, "count"));
      long long v50 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      uint64_t v7 = [v5 countByEnumeratingWithState:&v50 objects:v59 count:16];
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)v51;
        unsigned __int8 v40 = v5;
        uint64_t v41 = v2;
        uint64_t v38 = *(void *)v51;
        uint64_t v39 = v6;
        do
        {
          uint64_t v10 = 0;
          uint64_t v44 = v8;
          do
          {
            if (*(void *)v51 != v9) {
              objc_enumerationMutation(v5);
            }
            uint64_t v11 = *(void *)(*((void *)&v50 + 1) + 8 * v10);
            uint64_t v12 = (void *)[v2 animationPlayerForKey:v11];
            CGFloat v13 = (void *)[v12 animation];
            long long v14 = (__n128 *)[v13 animationRef];
            if (v14
              || ([v12 prepareWithTarget:v2 implicitDuration:0.0],
                  (long long v14 = (__n128 *)[v13 animationRef]) != 0))
            {
              if ((C3DAnimationGetIsImplicit((uint64_t)v14) & 1) == 0)
              {
                [v6 addObject:v12];
                [v43 addObject:v11];
                CFArrayRef KeyPath = (const __CFArray *)C3DAnimationGetKeyPath((uint64_t)v14);
                CFArrayRef v16 = C3DCreatePathFromComponents(KeyPath);
                CFTypeID v17 = CFGetTypeID(v14);
                uint64_t TypeID = C3DAnimationClusterGetTypeID();
                if (v17 == TypeID) {
                  long long v14 = C3DAnimationGroupCreateWithAnimationCluster((uint64_t)v14);
                }
                uint64_t v19 = (void *)C3DCopyPropertyList(v14, 0, 0, 0);
                CFTypeID v20 = CFGetTypeID(v14);
                CFTypeID v45 = v17;
                if (v20 == C3DSimpleAnimationGetTypeID())
                {
                  char v21 = 0;
                  CGFloat v22 = @"basic";
                }
                else
                {
                  CFTypeID v23 = CFGetTypeID(v14);
                  if (v23 == C3DKeyframedAnimationGetTypeID())
                  {
                    char v21 = 0;
                    CGFloat v22 = @"keyframe";
                  }
                  else
                  {
                    CFTypeID v25 = CFGetTypeID(v14);
                    if (v25 == C3DAnimationGroupGetTypeID())
                    {
                      char v21 = 0;
                      CGFloat v22 = @"group";
                    }
                    else
                    {
                      CGFloat v26 = scn_default_log();
                      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 138412290;
                        simd_float4 v58 = v13;
                        _os_log_error_impl(&dword_20B249000, v26, OS_LOG_TYPE_ERROR, "Error: SCNEncodeAnimations unknown animation type: %@", buf, 0xCu);
                      }
                      CGFloat v22 = 0;
                      char v21 = 1;
                    }
                  }
                }
                double v27 = (void *)[MEMORY[0x263EFF9A0] dictionaryWithCapacity:4];
                [v27 setValue:v19 forKey:@"animation"];
                if (v16) {
                  [v27 setValue:v16 forKey:@"keyPath"];
                }
                if ((v21 & 1) == 0) {
                  [v27 setValue:v22 forKey:@"class"];
                }
                if ([v13 usesSceneTimeBase]) {
                  [v27 setValue:MEMORY[0x263EFFA88] forKey:@"usesSceneTimeBase"];
                }
                [v42 setObject:v27 forKey:v11];

                uint64_t v8 = v44;
                BOOL v28 = v45 == TypeID;
                uint64_t v5 = v40;
                uint64_t v2 = v41;
                uint64_t v9 = v38;
                uint64_t v6 = v39;
                if (v28 && v14) {
                  CFRelease(v14);
                }
              }
            }
            else
            {
              CGFloat v24 = scn_default_log();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                simd_float4 v58 = v13;
                _os_log_error_impl(&dword_20B249000, v24, OS_LOG_TYPE_ERROR, "Error: SCNEncodeAnimations failed to encode animation: %@", buf, 0xCu);
              }
            }
            ++v10;
          }
          while (v8 != v10);
          uint64_t v8 = [v5 countByEnumeratingWithState:&v50 objects:v59 count:16];
        }
        while (v8);
      }
      if ([v43 count])
      {
        if (v6) {
          [v37 encodeObject:v6 forKey:@"animation-players"];
        }
        [v37 encodeObject:v42 forKey:@"animations"];
        [v37 encodeObject:v43 forKey:@"animation-keys"];
      }
    }
  }
  uint64_t result = (void *)[v2 _scnBindings];
  if (result)
  {
    CGFloat v30 = result;
    uint64_t v31 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(result, "count"));
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    uint64_t v32 = [v30 countByEnumeratingWithState:&v46 objects:v56 count:16];
    if (v32)
    {
      uint64_t v33 = v32;
      uint64_t v34 = *(void *)v47;
      do
      {
        for (uint64_t i = 0; i != v33; ++i)
        {
          if (*(void *)v47 != v34) {
            objc_enumerationMutation(v30);
          }
          uint64_t v36 = (void *)[v30 valueForKey:*(void *)(*((void *)&v46 + 1) + 8 * i)];
          if ([v36 sourceObject])
          {
            v54[0] = @"sourceObject";
            v55[0] = [v36 sourceObject];
            v54[1] = @"keyPathSrc";
            v55[1] = [v36 keyPathSrc];
            v54[2] = @"keyPathDst";
            v55[2] = [v36 keyPathDst];
            objc_msgSend(v31, "addObject:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v55, v54, 3));
          }
        }
        uint64_t v33 = [v30 countByEnumeratingWithState:&v46 objects:v56 count:16];
      }
      while (v33);
    }
    return (void *)[v37 encodeObject:v31 forKey:@"bindings"];
  }
  return result;
}

void *SCNDecodeAnimations(void *a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v3 = [MEMORY[0x263EFFA08] setWithObject:objc_opt_class()];
  if (SCNPlistClasses_onceToken != -1) {
    dispatch_once(&SCNPlistClasses_onceToken, &__block_literal_global_74);
  }
  CGFloat v29 = a1;
  uint64_t v31 = objc_msgSend(a1, "scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:", v3, SCNPlistClasses_set, @"animations");
  if (v31)
  {
    uint64_t v4 = objc_msgSend(a1, "scn_decodeArrayOfObjectsOfClass:forKey:", objc_opt_class(), @"animation-keys");
    uint64_t v5 = objc_msgSend(a1, "scn_decodeArrayOfObjectsOfClass:forKey:", objc_opt_class(), @"animation-players");
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    if (!v4) {
      uint64_t v4 = (void *)[v31 allKeys];
    }
    uint64_t v6 = [v4 countByEnumeratingWithState:&v37 objects:v44 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = 0;
      uint64_t v9 = *(void *)v38;
      obuint64_t j = v4;
      do
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          if (*(void *)v38 != v9) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(void *)(*((void *)&v37 + 1) + 8 * i);
          if (v5) {
            uint64_t v12 = (void *)[v5 objectAtIndex:v8++];
          }
          else {
            uint64_t v12 = 0;
          }
          CGFloat v13 = (void *)[v31 objectForKey:v11];
          long long v14 = (void *)[v13 valueForKey:@"class"];
          if ([v14 isEqualToString:@"basic"])
          {
            uint64_t v15 = C3DSimpleAnimationCreate();
            goto LABEL_18;
          }
          if ([v14 isEqualToString:@"keyframe"])
          {
            uint64_t v15 = C3DKeyframedAnimationCreate();
LABEL_18:
            CFArrayRef v16 = (const void *)v15;
            int v17 = 0;
            if (v15) {
              goto LABEL_19;
            }
            goto LABEL_29;
          }
          if ([v14 isEqualToString:@"group"])
          {
            int v17 = 1;
            CFArrayRef v16 = (const void *)C3DAnimationGroupCreate();
            if (v16)
            {
LABEL_19:
              if (C3DInitWithPropertyList(v16, [v13 valueForKey:@"animation"], 0, 0))
              {
                if (v17)
                {
                  CGFloat v18 = C3DAnimationClusterCreateWithAnimationGroup((uint64_t)v16);
                  if (v18)
                  {
                    uint64_t v19 = v18;
                    CFRelease(v16);
                    CFArrayRef v16 = v19;
                  }
                }
                C3DAnimationSetIsSceneTimeBased((uint64_t)v16, objc_msgSend((id)objc_msgSend(v13, "valueForKey:", @"usesSceneTimeBase"), "BOOLValue"));
                uint64_t v20 = [v13 valueForKey:@"keyPath"];
                char v21 = +[SCNAnimation animationWithC3DAnimation:v16];
                [(SCNAnimation *)v21 setKeyPath:v20];
                if (v12)
                {
                  [v12 _setAnimation:v21];
                  [a2 addAnimationPlayer:v12 forKey:v11];
                }
                else
                {
                  [a2 addAnimation:v21 forKey:v11];
                }
              }
              else
              {
                CGFloat v22 = scn_default_log();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138412290;
                  double v43 = v13;
                  _os_log_error_impl(&dword_20B249000, v22, OS_LOG_TYPE_ERROR, "Error: failed to deserialize animation %@", buf, 0xCu);
                }
              }
              CFRelease(v16);
              continue;
            }
          }
LABEL_29:
          CFTypeID v23 = scn_default_log();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            double v43 = v13;
            _os_log_error_impl(&dword_20B249000, v23, OS_LOG_TYPE_ERROR, "Error: can't deserialize animation %@", buf, 0xCu);
          }
        }
        uint64_t v7 = [obj countByEnumeratingWithState:&v37 objects:v44 count:16];
      }
      while (v7);
    }
  }
  if (SCNUserInfoClassesWithoutCollections_onceToken != -1) {
    dispatch_once(&SCNUserInfoClassesWithoutCollections_onceToken, &__block_literal_global_96);
  }
  uint64_t result = objc_msgSend(v29, "scn_decodeArrayOfObjectsOfClasses:forKey:", SCNUserInfoClassesWithoutCollections_set, @"bindings");
  if (result)
  {
    CFTypeID v25 = result;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    uint64_t result = (void *)[result countByEnumeratingWithState:&v33 objects:v41 count:16];
    if (result)
    {
      CGFloat v26 = result;
      uint64_t v27 = *(void *)v34;
      do
      {
        BOOL v28 = 0;
        do
        {
          if (*(void *)v34 != v27) {
            objc_enumerationMutation(v25);
          }
          objc_msgSend(a2, "bindAnimatablePath:toObject:withKeyPath:options:", objc_msgSend(*(id *)(*((void *)&v33 + 1) + 8 * (void)v28), "objectForKeyedSubscript:", @"keyPathDst"), objc_msgSend(*(id *)(*((void *)&v33 + 1) + 8 * (void)v28), "objectForKeyedSubscript:", @"sourceObject"), objc_msgSend(*(id *)(*((void *)&v33 + 1) + 8 * (void)v28), "objectForKeyedSubscript:", @"keyPathSrc"), 0);
          BOOL v28 = (char *)v28 + 1;
        }
        while (v26 != v28);
        uint64_t result = (void *)[v25 countByEnumeratingWithState:&v33 objects:v41 count:16];
        CGFloat v26 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t SCNFindImageNamedInAppBundle(void *a1)
{
  uint64_t v2 = (void *)[a1 path];
  uint64_t v3 = [v2 rangeOfString:@".app/Contents/"];
  if (!v4 || (uint64_t v5 = (void *)[v2 substringFromIndex:v3 + v4]) == 0)
  {
    uint64_t v5 = (void *)[a1 path];
    if (!v5) {
      return 0;
    }
  }
  uint64_t v6 = (void *)[v5 pathComponents];
  uint64_t v7 = [v6 count];
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  char v21 = a1;
  uint64_t v9 = (void *)SCNGetResourceBundle();
  uint64_t v10 = objc_msgSend((id)objc_msgSend(v5, "lastPathComponent"), "stringByDeletingPathExtension");
  uint64_t v11 = [v5 pathExtension];
  uint64_t v12 = v8 - 1;
  if (v8 == 1)
  {
LABEL_12:
    id v19 = (id)objc_msgSend(MEMORY[0x263F1C6B0], "imageNamed:", objc_msgSend(v21, "lastPathComponent"));
  }
  else
  {
    uint64_t v13 = v11;
    unint64_t v14 = 0;
    while (1)
    {
      unint64_t v15 = [v6 count] - 1;
      CFArrayRef v16 = &stru_26BF72F58;
      if (v15 > v14)
      {
        CFArrayRef v16 = &stru_26BF72F58;
        unint64_t v17 = v14;
        do
          CFArrayRef v16 = (__CFString *)-[__CFString stringByAppendingPathComponent:](v16, "stringByAppendingPathComponent:", [v6 objectAtIndex:v17++]);
        while (v15 != v17);
      }
      uint64_t v18 = [v9 pathForResource:v10 ofType:v13 inDirectory:v16];
      if (v18) {
        break;
      }
      if (++v14 == v12) {
        goto LABEL_12;
      }
    }
    id v19 = (id)[objc_alloc(MEMORY[0x263F1C6B0]) initWithContentsOfFile:v18];
  }

  return [v19 CGImage];
}

uint64_t SCNResolveImageContents(void *a1, void *a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v4 = 0;
  }
  else
  {
    objc_opt_class();
    uint64_t v5 = 0;
    uint64_t v4 = a1;
    a1 = 0;
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return v5;
    }
  }
  if (objc_msgSend((id)objc_msgSend(a1, "scheme"), "isEqualToString:", @"imageNamed"))
  {
    uint64_t v6 = [a1 absoluteString];
  }
  else
  {
    if (v4) {
      goto LABEL_9;
    }
    if (![a1 isFileURL] || objc_msgSend(a1, "query")) {
      goto LABEL_21;
    }
    uint64_t v6 = [a1 path];
  }
  uint64_t v4 = (void *)v6;
  if (!v6)
  {
LABEL_21:
    uint64_t v4 = 0;
    if (!a1) {
      return (uint64_t)v4;
    }
    char v12 = 0;
    goto LABEL_23;
  }
LABEL_9:
  if ([v4 hasPrefix:@"imageNamed://"])
  {
    uint64_t v7 = [v4 substringFromIndex:13];
    uint64_t v8 = [MEMORY[0x263F1C6B0] imageNamed:v7];
    if (v8) {
      return v8;
    }
    else {
      return v7;
    }
  }
  uint64_t v9 = [v4 rangeOfString:@".app/Contents/"];
  if (v10)
  {
    uint64_t v11 = (void *)[v4 substringFromIndex:v9 + v10];
    if (v11)
    {
      uint64_t v5 = objc_msgSend((id)SCNGetResourceBundle(), "URLForResource:withExtension:", objc_msgSend(v11, "stringByDeletingPathExtension"), objc_msgSend(v11, "pathExtension"));
      if (v5) {
        return v5;
      }
    }
  }
  uint64_t v5 = objc_msgSend((id)SCNGetResourceBundle(), "URLForResource:withExtension:", objc_msgSend(v4, "stringByDeletingPathExtension"), objc_msgSend(v4, "pathExtension"));
  if (v5) {
    return v5;
  }
  if (!a1)
  {
    unint64_t v14 = (void *)[NSURL fileURLWithPath:v4];
    char v13 = 0;
    char v12 = 1;
    goto LABEL_29;
  }
  char v12 = 1;
LABEL_23:
  if (![a1 isFileURL] || objc_msgSend(a1, "query")) {
    return (uint64_t)a1;
  }
  char v13 = 1;
  unint64_t v14 = a1;
LABEL_29:
  uint64_t v5 = objc_msgSend((id)SCNGetResourceBundle(), "URLForResource:withExtension:", objc_msgSend(v14, "lastPathComponent"), objc_msgSend(v14, "pathExtension"));
  if (v5) {
    return v5;
  }
  uint64_t v5 = (uint64_t)v14;
  if ([v14 checkResourceIsReachableAndReturnError:0]) {
    return v5;
  }
  char v15 = v12 ^ 1;
  if (!a2) {
    char v15 = 1;
  }
  if (v15)
  {
    uint64_t v5 = (uint64_t)a1;
    if (v13) {
      return v5;
    }
  }
  else
  {
    CFArrayRef v16 = (void *)[a2 URLByAppendingPathComponent:v4];
    unint64_t v17 = (void *)[v16 URLByStandardizingPath];
    if (v17 != v16)
    {
      uint64_t v5 = (uint64_t)v17;
      if ([v17 checkResourceIsReachableAndReturnError:0]) {
        return v5;
      }
    }
    uint64_t v5 = (uint64_t)v16;
    if ([v16 checkResourceIsReachableAndReturnError:0]) {
      return v5;
    }
    uint64_t v18 = objc_msgSend(a2, "URLByAppendingPathComponent:", objc_msgSend(v4, "lastPathComponent"));
    id v19 = (void *)[v18 URLByStandardizingPath];
    if (v19 != v18)
    {
      uint64_t v5 = (uint64_t)v19;
      if ([v19 checkResourceIsReachableAndReturnError:0]) {
        return v5;
      }
    }
    int v20 = [v18 checkResourceIsReachableAndReturnError:0];
    uint64_t v5 = (uint64_t)(v20 ? v18 : a1);
    if ((v13 | v20)) {
      return v5;
    }
  }
  if (!C3DWasLinkedBeforeMajorOSYear2016()) {
    return (uint64_t)v4;
  }
  char v21 = NSURL;

  return [v21 fileURLWithPath:v4];
}

id _SCNDecodeImageContents(id result)
{
  if (result)
  {
    uint64_t v1 = result;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (objc_msgSend((id)objc_msgSend(v1, "valueForKey:", @"type"), "isEqualToString:", @"MDLSkyCubeTexture"))
      {
        id v2 = objc_alloc(MEMORY[0x263F13660]);
        uint64_t v3 = [v1 objectForKeyedSubscript:@"name"];
        uint64_t v4 = objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"channelEncoding"), "integerValue");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"dimensions.x"), "floatValue");
        unsigned int v25 = v5;
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"dimensions.x"), "floatValue");
        double v7 = COERCE_DOUBLE(vcvt_s32_f32((float32x2_t)__PAIR64__(v6, v25)));
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"turbidity"), "floatValue");
        int v9 = v8;
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"sunElevation"), "floatValue");
        int v11 = v10;
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"upperAtmosphereScattering"), "floatValue");
        int v13 = v12;
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"groundAlbedo"), "floatValue");
        LODWORD(v15) = v14;
        LODWORD(v16) = v9;
        LODWORD(v17) = v11;
        LODWORD(v18) = v13;
        id v19 = (void *)[v2 initWithName:v3 channelEncoding:v4 textureDimensions:v7 turbidity:v16 sunElevation:v17 upperAtmosphereScattering:v18 groundAlbedo:v15];
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"horizonElevation"), "floatValue");
        objc_msgSend(v19, "setHorizonElevation:");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"gamma"), "floatValue");
        objc_msgSend(v19, "setGamma:");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"exposure"), "floatValue");
        objc_msgSend(v19, "setExposure:");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"brightness"), "floatValue");
        objc_msgSend(v19, "setBrightness:");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"contrast"), "floatValue");
        objc_msgSend(v19, "setContrast:");
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"saturation"), "floatValue");
        objc_msgSend(v19, "setSaturation:");
        uint64_t v20 = [v1 objectForKeyedSubscript:@"groundColor"];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          char v21 = (void *)[MEMORY[0x263F08928] unarchivedObjectOfClass:objc_opt_class() fromData:v20 error:0];
          if (v21) {
            objc_msgSend(v19, "setGroundColor:", objc_msgSend(v21, "CGColor"));
          }
        }
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"highDynamicRangeCompression.x"), "floatValue");
        unsigned int v26 = v22;
        objc_msgSend((id)objc_msgSend(v1, "objectForKeyedSubscript:", @"highDynamicRangeCompression.y"), "floatValue");
        objc_msgSend(v19, "setHighDynamicRangeCompression:", COERCE_DOUBLE(__PAIR64__(v23, v26)));
        if ((C3DWasLinkedBeforeMajorOSYear2018() & 1) == 0) {
          [v19 updateTexture];
        }
        return v19;
      }
      else
      {
        uint64_t result = (id)[v1 valueForKey:@"data"];
        if (!result)
        {
          uint64_t result = (id)[v1 valueForKey:@"path"];
          if (!result)
          {
            return (id)[v1 valueForKey:@"URL"];
          }
        }
      }
    }
    else
    {
      CGFloat v24 = scn_default_log();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        _SCNDecodeImageContents_cold_1(v24);
      }
      return 0;
    }
  }
  return result;
}

id SCNDecodeImageContents(void *a1, uint64_t a2)
{
  uint64_t v4 = [MEMORY[0x263EFFA08] setWithObject:objc_opt_class()];
  unsigned int v5 = (void *)MEMORY[0x263EFFA08];
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  int v9 = objc_msgSend(a1, "scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:forKey:", v4, objc_msgSend(v5, "setWithObjects:", v6, v7, v8, objc_opt_class(), 0), a2);

  return _SCNDecodeImageContents(v9);
}

uint64_t SCNEncodeC3DImage(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = _SCNEncodedC3DImage(a1, a3);

  return [a1 encodeObject:v5 forKey:a2];
}

void *_SCNEncodedC3DImage(void *a1, uint64_t a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    int v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "options"), "objectForKeyedSubscript:", @"SCNSceneExportEmbedImages"), "BOOLValue");
  }
  else {
    int v4 = 0;
  }
  URL = (void *)C3DImageGetURL(a2);
  uint64_t v6 = (uint64_t)URL;
  if (URL) {
    BOOL v7 = objc_msgSend((id)objc_msgSend(URL, "query"), "length") == 0;
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t v8 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  int v9 = v8;
  if (v7 && !v4)
  {
    int v10 = @"URL";
    uint64_t v11 = v6;
LABEL_12:
    [v8 setObject:v11 forKey:v10];
    return v9;
  }
  uint64_t Data = C3DImageGetData(a2);
  if (Data
    || (CGImageRef v14 = C3DImageCopyCGImage(a2)) != 0
    && (double v15 = v14,
        uint64_t Data = (uint64_t)UIImagePNGRepresentation((UIImage *)[MEMORY[0x263F1C6B0] imageWithCGImage:v14]),
        CGImageRelease(v15),
        Data))
  {
    int v10 = @"data";
    uint64_t v8 = v9;
    uint64_t v11 = Data;
    goto LABEL_12;
  }
  return v9;
}

void *SCNEncodeNamedObject(void *a1, const char *a2)
{
  if (a2) {
    return (void *)[a1 encodeObject:a2 forKey:@"name"];
  }
  return a1;
}

uint64_t __SCNPlistClasses_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x263EFFA08]);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t result = objc_msgSend(v0, "initWithObjects:", v1, v2, v3, v4, v5, v6, v7, objc_opt_class(), 0);
  SCNPlistClasses_set = result;
  return result;
}

uint64_t __SCNUserInfoClassesWithoutCollections_block_invoke()
{
  id v30 = objc_alloc(MEMORY[0x263EFFA08]);
  uint64_t v29 = objc_opt_class();
  uint64_t v28 = objc_opt_class();
  uint64_t v27 = objc_opt_class();
  uint64_t v26 = objc_opt_class();
  uint64_t v25 = objc_opt_class();
  uint64_t v24 = objc_opt_class();
  uint64_t v23 = objc_opt_class();
  uint64_t v22 = objc_opt_class();
  uint64_t v21 = objc_opt_class();
  uint64_t v20 = objc_opt_class();
  uint64_t v19 = objc_opt_class();
  uint64_t v18 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v0 = (uint64_t)__SKSceneClass();
  if (!v0) {
    uint64_t v0 = objc_opt_class();
  }
  uint64_t v14 = v0;
  uint64_t v1 = (uint64_t)__SKTextureClass();
  if (!v1) {
    uint64_t v1 = objc_opt_class();
  }
  uint64_t v13 = v1;
  uint64_t v2 = (uint64_t)__GLKTextureInfoClass();
  if (!v2) {
    uint64_t v2 = objc_opt_class();
  }
  uint64_t v3 = (uint64_t)__AVPlayerClass();
  if (!v3) {
    uint64_t v3 = objc_opt_class();
  }
  uint64_t v4 = (uint64_t)__AVCaptureDeviceClass();
  if (!v4) {
    uint64_t v4 = objc_opt_class();
  }
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t result = objc_msgSend(v30, "initWithObjects:", v29, v28, v27, v26, v25, v24, v23, v22, v21, v20, v19, v18, v17, v16, v15, v14, v13,
             v2,
             v3,
             v4,
             v5,
             v6,
             v7,
             v8,
             v9,
             v10,
             v11,
             objc_opt_class(),
             0);
  SCNUserInfoClassesWithoutCollections_set = result;
  return result;
}

id __SCNUserInfoClasses_block_invoke()
{
  float v2[2] = *MEMORY[0x263EF8340];
  if (SCNUserInfoClassesWithoutCollections_onceToken != -1) {
    dispatch_once(&SCNUserInfoClassesWithoutCollections_onceToken, &__block_literal_global_96);
  }
  uint64_t v0 = (void *)SCNUserInfoClassesWithoutCollections_set;
  v2[0] = objc_opt_class();
  v2[1] = objc_opt_class();
  id result = (id)objc_msgSend(v0, "setByAddingObjectsFromArray:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v2, 2));
  SCNUserInfoClasses_set = (uint64_t)result;
  return result;
}

void SCNEncodeImageContents(void *a1, uint64_t a2, void *a3)
{
  v36[18] = *MEMORY[0x263EF8340];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    int v6 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "options"), "objectForKeyedSubscript:", @"SCNSceneExportEmbedImages"), "BOOLValue") ^ 1;
  }
  else {
    int v6 = 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && v6)
  {
    uint64_t v7 = (void *)[MEMORY[0x263EFF9A0] dictionary];
    uint64_t v8 = v7;
    uint64_t v9 = @"path";
LABEL_7:
    [v7 setObject:a3 forKey:v9];
    [a1 encodeObject:v8 forKey:a2];
    return;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & v6) == 1 && !objc_msgSend((id)objc_msgSend(a3, "query"), "length"))
  {
    uint64_t v7 = (void *)[MEMORY[0x263EFF9A0] dictionary];
    uint64_t v8 = v7;
    uint64_t v9 = @"URL";
    goto LABEL_7;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if ([a3 groundColor])
    {
      uint64_t v10 = objc_msgSend(MEMORY[0x263F1C550], "colorWithCGColor:", objc_msgSend(a3, "groundColor"));
      uint64_t v11 = [MEMORY[0x263F08910] archivedDataWithRootObject:v10 requiringSecureCoding:1 error:0];
    }
    else
    {
      uint64_t v11 = 0;
    }
    v36[0] = @"MDLSkyCubeTexture";
    v35[0] = @"type";
    v35[1] = @"name";
    uint64_t v14 = [a3 name];
    if (v14) {
      uint64_t v15 = (__CFString *)v14;
    }
    else {
      uint64_t v15 = &stru_26BF72F58;
    }
    v36[1] = v15;
    v35[2] = @"turbidity";
    uint64_t v16 = NSNumber;
    [a3 turbidity];
    v36[2] = objc_msgSend(v16, "numberWithFloat:");
    v35[3] = @"sunElevation";
    uint64_t v17 = NSNumber;
    [a3 sunElevation];
    v36[3] = objc_msgSend(v17, "numberWithFloat:");
    v35[4] = @"upperAtmosphereScattering";
    uint64_t v18 = NSNumber;
    [a3 upperAtmosphereScattering];
    v36[4] = objc_msgSend(v18, "numberWithFloat:");
    v35[5] = @"groundAlbedo";
    uint64_t v19 = NSNumber;
    [a3 groundAlbedo];
    v36[5] = objc_msgSend(v19, "numberWithFloat:");
    v35[6] = @"horizonElevation";
    uint64_t v20 = NSNumber;
    [a3 horizonElevation];
    v36[6] = objc_msgSend(v20, "numberWithFloat:");
    _DWORD v35[7] = @"gamma";
    uint64_t v21 = NSNumber;
    [a3 gamma];
    void v36[7] = objc_msgSend(v21, "numberWithFloat:");
    v35[8] = @"exposure";
    uint64_t v22 = NSNumber;
    [a3 exposure];
    v36[8] = objc_msgSend(v22, "numberWithFloat:");
    v35[9] = @"brightness";
    uint64_t v23 = NSNumber;
    [a3 brightness];
    v36[9] = objc_msgSend(v23, "numberWithFloat:");
    v35[10] = @"contrast";
    uint64_t v24 = NSNumber;
    [a3 contrast];
    v36[10] = objc_msgSend(v24, "numberWithFloat:");
    v35[11] = @"saturation";
    uint64_t v25 = NSNumber;
    [a3 saturation];
    v36[11] = objc_msgSend(v25, "numberWithFloat:");
    v35[12] = @"channelEncoding";
    v36[12] = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(a3, "channelEncoding"));
    v35[13] = @"dimensions.x";
    uint64_t v26 = NSNumber;
    [a3 dimensions];
    v36[13] = [v26 numberWithInt:v27];
    v35[14] = @"dimensions.y";
    uint64_t v28 = NSNumber;
    [a3 dimensions];
    v36[14] = [v28 numberWithInt:v29];
    v35[15] = @"highDynamicRangeCompression.x";
    id v30 = NSNumber;
    [a3 highDynamicRangeCompression];
    v36[15] = objc_msgSend(v30, "numberWithFloat:");
    v35[16] = @"highDynamicRangeCompression.y";
    uint64_t v31 = NSNumber;
    [a3 highDynamicRangeCompression];
    LODWORD(v32) = HIDWORD(v32);
    uint64_t v33 = [v31 numberWithFloat:v32];
    v35[17] = @"groundColor";
    if (v11) {
      long long v34 = (__CFString *)v11;
    }
    else {
      long long v34 = &stru_26BF72F58;
    }
    v36[16] = v33;
    v36[17] = v34;
    objc_msgSend(a1, "encodeObject:forKey:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v36, v35, 18), a2);
  }
  else
  {
    int v12 = +[SCNMaterialProperty copyC3DImageFromImage:a3];
    if (v12)
    {
      uint64_t v13 = v12;
      objc_msgSend(a1, "encodeObject:forKey:", _SCNEncodedC3DImage(a1, (uint64_t)v12), a2);
      CFRelease(v13);
    }
  }
}

uint64_t SCNEncodeImageArray(void *a1, uint64_t a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  int v6 = (void *)[MEMORY[0x263EFF980] array];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v7 = [a3 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v15;
    do
    {
      uint64_t v10 = 0;
      do
      {
        if (*(void *)v15 != v9) {
          objc_enumerationMutation(a3);
        }
        uint64_t v11 = +[SCNMaterialProperty copyC3DImageFromImage:*(void *)(*((void *)&v14 + 1) + 8 * v10)];
        if (v11)
        {
          int v12 = v11;
          objc_msgSend(v6, "addObject:", _SCNEncodedC3DImage(a1, (uint64_t)v11));
          CFRelease(v12);
        }
        ++v10;
      }
      while (v8 != v10);
      uint64_t v8 = [a3 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v8);
  }
  return [a1 encodeObject:v6 forKey:a2];
}

void *SCNDecodeImageArray(void *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (SCNPlistClasses_onceToken != -1) {
    dispatch_once(&SCNPlistClasses_onceToken, &__block_literal_global_74);
  }
  uint64_t v4 = [a1 decodeObjectOfClasses:SCNPlistClasses_set forKey:a2];
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (void *)v4;
  int v6 = (void *)[MEMORY[0x263EFF980] array];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v14 != v9) {
          objc_enumerationMutation(v5);
        }
        id v11 = _SCNDecodeImageContents(*(id *)(*((void *)&v13 + 1) + 8 * i));
        if (v11) {
          [v6 addObject:v11];
        }
      }
      uint64_t v8 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v8);
  }
  return v6;
}

uint64_t C3DOrderedDictionaryGetValue(void *a1, const char *a2)
{
  return [a1 valueForKey:a2];
}

uint64_t C3DOrderedDictionarySetValue(void *a1, const char *a2, uint64_t a3)
{
  return [a1 setValue:a3 forKey:a2];
}

uint64_t C3DOrderedDictionaryRemoveValue(void *a1, const char *a2)
{
  return [a1 removeObjectForKey:a2];
}

uint64_t C3DOrderedDictionaryApplyFunction(void *a1, const char *a2, uint64_t a3)
{
  return [a1 applyFunction:a2 withContext:a3];
}

SCNOrderedDictionary *C3DOrderedDictionaryCreate()
{
  return objc_alloc_init(SCNOrderedDictionary);
}

uint64_t _CAToC3DFillMode(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    if ([(id)result isEqualToString:*MEMORY[0x263F15AB8]])
    {
      return 0;
    }
    else if ([v1 isEqualToString:*MEMORY[0x263F15AB0]])
    {
      return 1;
    }
    else if ([v1 isEqualToString:*MEMORY[0x263F15AA0]])
    {
      return 2;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

uint64_t _C3DToCAFillMode(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = (uint64_t *)MEMORY[0x263F15AB8];
      goto LABEL_9;
    case 1:
      uint64_t v1 = (uint64_t *)MEMORY[0x263F15AB0];
      goto LABEL_9;
    case 2:
      uint64_t v1 = (uint64_t *)MEMORY[0x263F15AA0];
      goto LABEL_9;
    case 3:
      uint64_t v1 = (uint64_t *)MEMORY[0x263F15AA8];
LABEL_9:
      uint64_t result = *v1;
      break;
    default:
      uint64_t v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        _C3DToCAFillMode_cold_1();
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

void *_CAToC3DAnimationEvents(void *a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = (void *)[a1 count];
  if (result)
  {
    uint64_t v3 = (void *)[a1 sortedArrayUsingComparator:&__block_literal_global_75];
    uint64_t v4 = (void *)C3DAnimationEventsCreateWithEventCount([v3 count]);
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)v12;
      do
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v3);
          }
          uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * i);
          [v9 time];
          C3DAnimationEventsAddEvent(v4, (void *)[v9 eventBlock], v10);
        }
        uint64_t v6 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v6);
    }
    return v4;
  }
  return result;
}

void *_C3DToCAAnimationEvents(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t Count = C3DAnimationEventsGetCount(a1);
  uint64_t v3 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:Count];
  if (Count >= 1)
  {
    for (uint64_t i = 0; i != Count; ++i)
    {
      EventTimeAtuint64_t Index = C3DAnimationEventsGetEventTimeAtIndex(a1, i);
      objc_msgSend(v3, "addObject:", +[SCNAnimationEvent animationEventWithKeyTime:block:](SCNAnimationEvent, "animationEventWithKeyTime:block:", C3DAnimationEventsGetEventBlockAtIndex(a1, i), EventTimeAtIndex));
    }
  }
  return v3;
}

__n128 *CAAnimationToC3DAnimation(void *a1, void *a2)
{
  uint64_t v2 = (__n128 *)_CAAnimationToC3DAnimation(a1, a2);
  if (v2)
  {
    uint64_t TypeID = C3DAnimationGroupGetTypeID();
    if (TypeID == CFGetTypeID(v2))
    {
      uint64_t v4 = C3DAnimationClusterCreateWithAnimationGroup((uint64_t)v2);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = v4;
        uint64_t v2 = v5;
      }
    }
    if ((C3DAnimationGetIsSceneTimeBased((uint64_t)v2) & 1) == 0)
    {
      double PauseTime = C3DAnimationNodeGetPauseTime((uint64_t)v2);
      if (PauseTime != 0.0)
      {
        double v8 = PauseTime;
        C3DTransactionGetAtomicTime();
        C3DAnimationNodeSetPauseTime((uint64_t)v2, v8 - v9);
      }
    }
  }
  return v2;
}

uint64_t SCNAnimationGetTargetedBaseType(void *a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if ([a1 fromValue])
    {
      uint64_t v2 = [a1 fromValue];
    }
    else if ([a1 toValue])
    {
      uint64_t v2 = [a1 toValue];
    }
    else
    {
      uint64_t v2 = [a1 byValue];
    }
    uint64_t v3 = (void *)v2;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      goto LABEL_13;
    }
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      double v9 = a1;
      uint64_t v5 = "Warning: unable to infer the type of a basic animation: %@";
      goto LABEL_18;
    }
    return 0;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  if (!objc_msgSend((id)objc_msgSend(a1, "values"), "count")
    || (uint64_t v3 = objc_msgSend((id)objc_msgSend(a1, "values"), "objectAtIndexedSubscript:", 0),
        objc_opt_class(),
        (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      double v9 = a1;
      uint64_t v5 = "Warning: unable to infer the type of a keyframed animation: %@";
LABEL_18:
      _os_log_impl(&dword_20B249000, v4, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, 0xCu);
    }
    return 0;
  }
LABEL_13:
  uint64_t v6 = (const char *)[v3 objCType];

  return SCNObjCEncodedTypeToC3DBaseType(v6);
}

CAMediaTimingFunction *SCNKitGetImplicitAnimationTimingFunction()
{
  uint64_t result = +[SCNTransaction animationTimingFunction];
  if (!result)
  {
    uint64_t v1 = (void *)MEMORY[0x263F15808];
    uint64_t v2 = *MEMORY[0x263F15EA0];
    return (CAMediaTimingFunction *)[v1 functionWithName:v2];
  }
  return result;
}

SCNAnimationPlayer *SCNConvertC3DAnimationDictionaryFunc(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = +[SCNAnimationPlayer animationPlayerWithAnimationPlayerRef:a2];
  if (result)
  {
    return (SCNAnimationPlayer *)[a3 setValue:result forKey:a1];
  }
  return result;
}

_WORD *CABasicAnimationToC3DAnimation(void *a1, int a2, int a3)
{
  if (a3 == 2)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      CABasicAnimationToC3DAnimation_cold_1();
    }
    return 0;
  }
  int v5 = a2;
  if (!a2)
  {
    if ([a1 toValue])
    {
      uint64_t v7 = (void *)[a1 toValue];
LABEL_11:
      int v5 = SCNObjCEncodedTypeToC3DBaseType((const char *)[v7 objCType]);
      goto LABEL_12;
    }
    if ([a1 fromValue])
    {
      uint64_t v7 = (void *)[a1 fromValue];
      goto LABEL_11;
    }
    if ([a1 byValue])
    {
      uint64_t v7 = (void *)[a1 byValue];
      goto LABEL_11;
    }
    int v5 = 0;
  }
LABEL_12:
  uint64_t v8 = C3DValueCreate(v5, 1);
  if (!v8) {
    return 0;
  }
  double v9 = (const void *)v8;
  Bytes = (__C3DImage **)C3DValueGetBytes(v8);
  long long v11 = (_WORD *)C3DSimpleAnimationCreate();
  C3DAnimationSetupWithCAPropertyAnimation(v11, a1);
  if ([a1 toValue]
    && __SCNAnimationTargetCopyValueToAddress((void *)[a1 toValue], v5, a3, Bytes))
  {
    C3DSimpleAnimationSetEndValue((uint64_t)v11, (uint64_t)v9);
  }
  if ([a1 fromValue]
    && __SCNAnimationTargetCopyValueToAddress((void *)[a1 fromValue], v5, a3, Bytes))
  {
    C3DSimpleAnimationSetStartValue((uint64_t)v11, (uint64_t)v9);
  }
  if ([a1 byValue]
    && __SCNAnimationTargetCopyValueToAddress((void *)[a1 byValue], v5, a3, Bytes))
  {
    C3DSimpleAnimationSetByValue((uint64_t)v11, (uint64_t)v9);
  }
  CFRelease(v9);

  return v11;
}

void C3DAnimationSetupWithCAPropertyAnimation(_WORD *a1, void *a2)
{
  C3DAnimationSetupWithCAAnimation(a1, a2);
  CFStringRef v4 = C3DCreatePathComponentsFromString((const __CFString *)[a2 keyPath]);
  C3DAnimationSetKeyPath((uint64_t)a1, v4);
  if (v4) {
    CFRelease(v4);
  }
  C3DAnimationSetAdditive((uint64_t)a1, [a2 isAdditive]);
  int v5 = [a2 isCumulative];

  C3DAnimationSetCumulative((uint64_t)a1, v5);
}

uint64_t __SCNAnimationTargetCopyValueToAddress(void *a1, int a2, int a3, __C3DImage **a4)
{
  if (a2 == 5)
  {
    if (a3 == 2)
    {
      int v5 = +[SCNMaterialProperty copyC3DImageFromImage:a1];
      uint64_t result = 0;
      if (a4)
      {
        if (v5)
        {
          *a4 = v5;
          uint64_t v7 = v5;
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return SCNWriteValueToTypedBytes(a1, (uint64_t)a4, a2);
  }
  return result;
}

_WORD *CAKeyframeAnimationToC3DAnimation(void *a1, unsigned int a2, char a3)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v6 = [a1 c3dAnimation];
    if (v6)
    {
      uint64_t v7 = v6;
      SCNAnimationSetupDelegateWithCAAnimation(v6, a1);
      return (_WORD *)v7;
    }
  }
  if (!a2)
  {
    if (objc_msgSend((id)objc_msgSend(a1, "values"), "count")) {
      a2 = SCNObjCEncodedTypeToC3DBaseType((const char *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "values"), "objectAtIndexedSubscript:", 0), "objCType"));
    }
    else {
      a2 = 0;
    }
  }
  unint64_t v8 = C3DSizeOfBaseType(a2);
  if (v8 >= 0x41)
  {
    int v9 = v8;
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      CAKeyframeAnimationToC3DAnimation_cold_1(v9, v10);
    }
    return 0;
  }
  if ([a1 path])
  {
    NSLog(&cfstr_Cakeyframeanim.isa);
    return 0;
  }
  unsigned int v12 = objc_msgSend((id)objc_msgSend(a1, "values"), "count");
  if (!v12)
  {
    uint64_t v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      CAKeyframeAnimationToC3DAnimation_cold_2();
    }
    return 0;
  }
  unsigned int v48 = v12;
  long long v49 = (_WORD *)C3DKeyframedAnimationCreate();
  C3DAnimationSetupWithCAPropertyAnimation(v49, a1);
  long long v13 = (void *)[a1 keyTimes];
  uint64_t v57 = (void *)[a1 values];
  long long v14 = (void *)[a1 timingFunctions];
  long long v15 = (void *)[a1 calculationMode];
  uint64_t v16 = (void *)[a1 tensionValues];
  long long v17 = (void *)[a1 continuityValues];
  uint64_t v18 = (void *)[a1 biasValues];
  unint64_t v56 = [v13 count];
  unint64_t v19 = [v14 count];
  long long v52 = v16;
  unint64_t v55 = [v16 count];
  long long v51 = v17;
  unint64_t v54 = [v17 count];
  long long v50 = v18;
  unint64_t v53 = [v18 count];
  [a1 duration];
  double v21 = v20;
  uint64_t v47 = *MEMORY[0x263F15958];
  if (objc_msgSend(v15, "isEqualToString:")) {
    int v22 = 1;
  }
  else {
    int v22 = [v15 isEqualToString:*MEMORY[0x263F15960]];
  }
  uint64_t v24 = (const void *)C3DKeyframeControllerCreateWithCapacity(v48, a2, a3, 0, v19 != 0, v22, v22);
  memset(__src, 0, sizeof(__src));
  float v25 = (float)v48;
  unint64_t v26 = 0;
  double v27 = 0.0;
  if (v22)
  {
    while (v13)
    {
      if (v56 > v26)
      {
        objc_msgSend((id)objc_msgSend(v13, "objectAtIndex:", v26), "doubleValue");
LABEL_26:
        double v27 = v21 * v28;
      }
      if (v19 <= v26) {
        unsigned int v29 = 0;
      }
      else {
        unsigned int v29 = (void *)[v14 objectAtIndex:v26];
      }
      float v30 = 0.0;
      float v31 = 0.0;
      if (v55 > v26)
      {
        objc_msgSend((id)objc_msgSend(v52, "objectAtIndex:", v26), "floatValue");
        float v31 = v32;
      }
      if (v54 > v26)
      {
        objc_msgSend((id)objc_msgSend(v51, "objectAtIndex:", v26), "floatValue");
        float v30 = v33;
      }
      float v34 = 0.0;
      if (v53 > v26)
      {
        objc_msgSend((id)objc_msgSend(v50, "objectAtIndex:", v26), "floatValue");
        float v34 = v35;
      }
      SCNWriteValueToTypedBytes((void *)[v57 objectAtIndex:v26], (uint64_t)__src, a2);
      float v36 = v27;
      double v27 = v36;
      char v37 = SCNInterpolationModeFromCACalculationMode(v15);
      id v38 = C3DTimingFunctionFromCAMediaTimingFunction(v29);
      C3DKeyframeControllerSetKeyframeAtIndex((uint64_t)v24, v26++, __src, v37, (uint64_t)v38, 0, 0, v27, v31, v30, v34);
      if (v48 == v26) {
        goto LABEL_47;
      }
    }
    double v28 = (float)((float)v26 / v25);
    goto LABEL_26;
  }
  do
  {
    if (v13)
    {
      if (v56 <= v26) {
        goto LABEL_43;
      }
      objc_msgSend((id)objc_msgSend(v13, "objectAtIndex:", v26), "doubleValue");
    }
    else
    {
      double v39 = (float)((float)v26 / v25);
    }
    double v27 = v21 * v39;
LABEL_43:
    if (v19 <= v26) {
      long long v40 = 0;
    }
    else {
      long long v40 = (void *)[v14 objectAtIndex:v26];
    }
    SCNWriteValueToTypedBytes((void *)[v57 objectAtIndex:v26], (uint64_t)__src, a2);
    float v41 = v27;
    double v27 = v41;
    char v42 = SCNInterpolationModeFromCACalculationMode(v15);
    id v43 = C3DTimingFunctionFromCAMediaTimingFunction(v40);
    C3DKeyframeControllerSetKeyframeAtIndex((uint64_t)v24, v26++, __src, v42, (uint64_t)v43, 0, 0, v27, 0.0, 0.0, 0.0);
  }
  while (v48 != v26);
LABEL_47:
  uint64_t v44 = [a1 calculationMode];
  if (v44 == *MEMORY[0x263F15968])
  {
    uint64_t v45 = (uint64_t)v24;
    unsigned int v46 = 1;
    goto LABEL_54;
  }
  if (v44 == *MEMORY[0x263F15978])
  {
    C3DKeyframeControllerSetCalculationMode((uint64_t)v24, 1);
  }
  else
  {
    if (v44 == v47) {
      goto LABEL_52;
    }
    if (v44 == *MEMORY[0x263F15960])
    {
      C3DKeyframeControllerSetCalculationMode((uint64_t)v24, 1);
LABEL_52:
      uint64_t v45 = (uint64_t)v24;
      unsigned int v46 = 2;
LABEL_54:
      C3DKeyframeControllerSetDefaultInterpolationMode(v45, v46);
    }
  }
  C3DKeyframedAnimationSetController((uint64_t)v49, v24);
  CFRelease(v24);
  return v49;
}

uint64_t SCNAnimationSetupDelegateWithCAAnimation(uint64_t a1, void *a2)
{
  AnimationCallbacks = (void *)C3DAnimationGetAnimationCallbacks(a1);
  [a2 delegate];
  uint64_t result = objc_opt_respondsToSelector();
  if (result) {
    void *AnimationCallbacks = SCNAnimationDidStart;
  }
  AnimationCallbacks[1] = SCNAnimationDidStop;
  return result;
}

_WORD *_CAAnimationToC3DAnimation(void *a1, void *a2)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      uint64_t v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        _CAAnimationToC3DAnimation_cold_2();
      }
      return 0;
    }
    CFArrayRef v5 = (const __CFArray *)objc_msgSend(a2, "copyAnimationChannelForKeyPath:animation:", objc_msgSend(a1, "keyPath"), a1);
    if (v5
      && (uint64_t v6 = C3DCFTypeCopyModelInfoAtSplittedPath((float32x4_t *)objc_msgSend(a2, "__CFObject"), v5, 0, 1)) != 0
      && (uint64_t v7 = (const void *)v6, C3DModelTargetGetTargetAddress(v6)))
    {
      Baseint Type = C3DModelTargetGetBaseType((uint64_t)v7);
      TypeSemantiCC_SHA256_CTX c = C3DModelTargetGetTypeSemantic((uint64_t)v7);
      CFRelease(v7);
    }
    else
    {
      Baseint Type = 0;
      TypeSemantiCC_SHA256_CTX c = 0;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      unsigned int v12 = CABasicAnimationToC3DAnimation(a1, BaseType, TypeSemantic);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        long long v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          _CAAnimationToC3DAnimation_cold_1();
        }
        long long v11 = 0;
        goto LABEL_24;
      }
      unsigned int v12 = CAKeyframeAnimationToC3DAnimation(a1, BaseType, TypeSemantic);
    }
    long long v11 = v12;
    if (v5 && v12) {
      C3DAnimationSetKeyPath((uint64_t)v12, v5);
    }
LABEL_24:

    return v11;
  }

  return CAAnimationGroupToC3DAnimation(a1, (uint64_t)a2);
}

id C3DAnimationToCAAnimation(const void *a1)
{
  id v1 = _C3DAnimationToCAAnimation(a1);
  [v1 beginTime];
  if (v2 != 0.0 && ([v1 usesSceneTimeBase] & 1) == 0)
  {
    double v3 = CACurrentMediaTime();
    [v1 beginTime];
    [v1 setBeginTime:v3 + v4];
  }
  return v1;
}

id _C3DAnimationToCAAnimation(const void *a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == C3DKeyframedAnimationGetTypeID())
    {
      if (C3DKeyframedAnimationGetController((uint64_t)a1))
      {
        double v3 = objc_alloc_init(SCN_CAKeyframeAnimation);
        [(SCN_CAKeyframeAnimation *)v3 setC3dAnimation:a1];
        double v4 = v3;
LABEL_8:
        id v5 = v4;
LABEL_36:
        [v5 setDuration:C3DAnimationGetDuration((uint64_t)a1)];
        return v5;
      }
    }
    else
    {
      if (v2 == C3DAnimationGroupGetTypeID())
      {
        double v4 = (SCN_CAKeyframeAnimation *)SCNAnimationGroupToCAAnimationGroup((uint64_t)a1);
        goto LABEL_8;
      }
      if (v2 == C3DSimpleAnimationGetTypeID())
      {
        id v5 = (id)[MEMORY[0x263F15760] animation];
        uint64_t started = C3DSimpleAnimationCopyStartValue((uint64_t)a1);
        if (started)
        {
          uint64_t v7 = (const void *)started;
          Bytes = (float32x2_t *)C3DValueGetBytes(started);
          int Type = C3DValueGetType((uint64_t)v7);
          uint64_t v14 = SCNNSValueFromTypedBytes(Bytes, Type, v10, v11, v12, v13);
          if (v14)
          {
            [v5 setFromValue:v14];
          }
          else
          {
            uint64_t v18 = scn_default_log();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_20B249000, v18, OS_LOG_TYPE_DEFAULT, "Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue", buf, 2u);
            }
          }
          CFRelease(v7);
        }
        uint64_t v19 = C3DSimpleAnimationCopyEndValue((uint64_t)a1);
        if (v19)
        {
          double v20 = (const void *)v19;
          double v21 = (float32x2_t *)C3DValueGetBytes(v19);
          int v22 = C3DValueGetType((uint64_t)v20);
          uint64_t v27 = SCNNSValueFromTypedBytes(v21, v22, v23, v24, v25, v26);
          if (v27)
          {
            [v5 setToValue:v27];
          }
          else
          {
            double v28 = scn_default_log();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)float v41 = 0;
              _os_log_impl(&dword_20B249000, v28, OS_LOG_TYPE_DEFAULT, "Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue", v41, 2u);
            }
          }
          CFRelease(v20);
        }
        uint64_t v29 = C3DSimpleAnimationCopyByValue((uint64_t)a1);
        if (v29)
        {
          float v30 = (const void *)v29;
          float v31 = (float32x2_t *)C3DValueGetBytes(v29);
          int v32 = C3DValueGetType((uint64_t)v30);
          uint64_t v37 = SCNNSValueFromTypedBytes(v31, v32, v33, v34, v35, v36);
          if (v37)
          {
            [v5 setByValue:v37];
          }
          else
          {
            id v38 = scn_default_log();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long v40 = 0;
              _os_log_impl(&dword_20B249000, v38, OS_LOG_TYPE_DEFAULT, "Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue", v40, 2u);
            }
          }
          CFRelease(v30);
        }
        CAPropertyAnimationSetupWithSCNAnimation(v5, (uint64_t)a1);
        goto LABEL_36;
      }
      if (v2 == C3DAnimationClusterGetTypeID())
      {
        long long v15 = C3DAnimationGroupCreateWithAnimationCluster((uint64_t)a1);
        id v5 = SCNAnimationGroupToCAAnimationGroup((uint64_t)v15);
        if (v15) {
          CFRelease(v15);
        }
        goto LABEL_36;
      }
      CFStringRef v16 = CFCopyTypeIDDescription(v2);
      long long v17 = scn_default_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        _C3DAnimationToCAAnimation_cold_1();
      }
      CFRelease(v16);
    }
    id v5 = 0;
    goto LABEL_36;
  }
  return 0;
}

__CFString *SCNCreateAnimationChannelWithObjectAndPath(void *a1, __CFString *a2)
{
  if (![(__CFString *)a2 length]) {
    return 0;
  }
  double v4 = (float32x4_t *)objc_msgSend(a1, "__CFObject");
  id v5 = (__CFString *)C3DCreatePathComponentsFromString(a2);
  uint64_t v6 = C3DCFTypeCopyModelInfoAtSplittedPath(v4, (const __CFArray *)v5, 0, 0);
  uint64_t v7 = (const void *)v6;
  if (v6 && C3DModelTargetGetTargetAddress(v6))
  {
    unint64_t v8 = v5;
LABEL_14:
    CFRelease(v7);
    return v8;
  }
  uint64_t v9 = SCNCopyValueFromObjCProperty(a1, a2);
  if (v9)
  {
    double v10 = (__int16 *)v9;
    double v11 = (const void *)objc_msgSend(a1, "__CFObject");
    if (CFTypeIsC3DEntity(v11)
      && (C3DEntitySetValueForKey((uint64_t)v11, a2, v10), C3DEntityGetValueForKey((uint64_t)v11, a2)))
    {
      unint64_t v8 = (__CFString *)(id)objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", -[__CFString count](v5, "count") + 1);
      [(__CFString *)v8 addObject:@"customProperty"];
      [(__CFString *)v8 addObjectsFromArray:v5];
    }
    else
    {
      unint64_t v8 = 0;
    }
    CFRelease(v10);
  }
  else
  {
    unint64_t v8 = 0;
  }
  CFRelease(v5);
  if (v7) {
    goto LABEL_14;
  }
  return v8;
}

uint64_t SCNAddAnimation(void *a1, void *a2, void *a3)
{
  if (!a3 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a1)
    {
LABEL_4:
      uint64_t result = [a1 animationPlayerRef];
      if (result)
      {
        long long v15 = (uint64_t *)result;
        CFStringRef v16 = (float32x4_t *)objc_msgSend(a2, "__CFObject");
        if (v16)
        {
          long long v17 = v16;
          if ((CFTypeIsC3DEntity(v16) & 1) == 0)
          {
            uint64_t v18 = scn_default_log();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
              SCNAddAnimation_cold_2(v18, v19, v20, v21, v22, v23, v24, v25);
            }
          }
          C3DEntityAddAnimationForKey(v17, v15, a3);
        }
        return 1;
      }
      return result;
    }
  }
  else if (a1)
  {
    goto LABEL_4;
  }
  double v26 = scn_default_log();
  uint64_t result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
  if (result)
  {
    SCNAddAnimation_cold_1();
    return 0;
  }
  return result;
}

void SCNRemoveAnimation(void *a1, void *a2)
{
  double v3 = objc_msgSend(a1, "__CFObject");
  if (v3)
  {
    double v4 = v3;
    if ((CFTypeIsC3DEntity(v3) & 1) == 0)
    {
      id v5 = scn_default_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
        SCNRemoveAnimation_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    C3DEntityRemoveAnimationForKey(v4, a2, 0);
  }
}

void SCNFadeAndRemoveAnimation(void *a1, void *a2, double a3)
{
  id v5 = objc_msgSend(a1, "__CFObject");
  if (v5)
  {
    uint64_t v6 = v5;
    if ((CFTypeIsC3DEntity(v5) & 1) == 0)
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        SCNFadeAndRemoveAnimation_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      }
    }
    C3DEntityFadeAndRemoveAnimationForKey(v6, a2, a3);
  }
}

void SCNRemoveAllAnimations(void *a1)
{
  id v1 = objc_msgSend(a1, "__CFObject");
  if (v1)
  {
    CFTypeID v2 = v1;
    if ((CFTypeIsC3DEntity(v1) & 1) == 0)
    {
      double v3 = scn_default_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
        SCNRemoveAllAnimations_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
      }
    }
    C3DEntityRemoveAllAnimations(v2);
  }
}

void SCNFadeAndRemoveAllAnimations(void *a1, double a2)
{
  double v3 = objc_msgSend(a1, "__CFObject");
  if (v3)
  {
    uint64_t v4 = v3;
    if ((CFTypeIsC3DEntity(v3) & 1) == 0)
    {
      uint64_t v5 = scn_default_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
        SCNFadeAndRemoveAllAnimations_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    C3DEntityFadeAndRemoveAllAnimations(v4, a2);
  }
}

void sub_20B40FBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20B4101C4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t SCNAnimationDidStart(uint64_t a1)
{
  Animatioint n = (id *)C3DAnimationNodeGetAnimation(a1);
  ObjCWrapper = C3DEntityGetObjCWrapper(Animation);
  uint64_t v4 = (void *)[ObjCWrapper userAnimation];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = [v4 delegate];
  if (objc_opt_respondsToSelector())
  {
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 3221225472;
    void v10[2] = __SCNAnimationDidStart_block_invoke;
    v10[3] = &unk_264005FA0;
    void v10[4] = v5;
    void v10[5] = v4;
    dispatch_async(MEMORY[0x263EF83A0], v10);
  }
  uint64_t result = [ObjCWrapper animationDidStart];
  if (result)
  {
    uint64_t v7 = result;
    Owner = (id *)C3DAnimationNodeGetOwner(a1);
    uint64_t v9 = C3DEntityGetObjCWrapper(Owner);
    return (*(uint64_t (**)(uint64_t, id *, id *))(v7 + 16))(v7, ObjCWrapper, v9);
  }
  return result;
}

uint64_t SCNAnimationDidStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1;
  uint64_t v43 = *MEMORY[0x263EF8340];
  Animatioint n = (id *)C3DAnimationNodeGetAnimation(a1);
  uint64_t v8 = C3DEntityGetObjCWrapper(Animation);
  id v9 = (id)[v8 userAnimation];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v10 = [v9 delegate];
  }
  else {
    uint64_t v10 = 0;
  }
  if (!C3DAnimationGetRemoveOnCompletion((uint64_t)Animation)) {
    goto LABEL_29;
  }
  Owner = (id *)C3DAnimationNodeGetOwner(v6);
  ObjCWrapper = C3DEntityGetObjCWrapper(Owner);
  if (C3DAnimationGetCommitWhenDone((uint64_t)Animation))
  {
    uint64_t TypeID = C3DAnimationClusterGetTypeID();
    if (TypeID == CFGetTypeID(Animation))
    {
      uint64_t v34 = v10;
      uint64_t v35 = a4;
      unsigned int v33 = a2;
      uint64_t v14 = C3DAnimationClusterCopyKeyPaths((uint64_t)Animation);
      +[SCNTransaction begin];
      +[SCNTransaction setDisableActions:1];
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      uint64_t v15 = [(__CFArray *)v14 countByEnumeratingWithState:&v38 objects:v42 count:16];
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)v39;
        do
        {
          uint64_t v18 = 0;
          do
          {
            if (*(void *)v39 != v17) {
              objc_enumerationMutation(v14);
            }
            objc_msgSend(ObjCWrapper, "setValue:forKeyPath:", objc_msgSend((id)objc_msgSend(ObjCWrapper, "presentationInstance"), "valueForKeyPath:", *(void *)(*((void *)&v38 + 1) + 8 * v18)), *(void *)(*((void *)&v38 + 1) + 8 * v18));
            ++v18;
          }
          while (v16 != v18);
          uint64_t v16 = [(__CFArray *)v14 countByEnumeratingWithState:&v38 objects:v42 count:16];
        }
        while (v16);
      }
      +[SCNTransaction commit];

      a2 = v33;
LABEL_24:
      uint64_t v10 = v34;
      a4 = v35;
      goto LABEL_25;
    }
    uint64_t KeyPath = C3DAnimationGetKeyPath((uint64_t)Animation);
    if (KeyPath)
    {
      CFArrayRef v20 = (const __CFArray *)KeyPath;
      uint64_t v34 = v10;
      uint64_t v35 = a4;
      if (ObjCWrapper)
      {
        uint64_t v21 = a2;
        uint64_t v22 = ObjCWrapper;
      }
      else
      {
        if (v6)
        {
          while (1)
          {
            uint64_t Parent = C3DAnimationNodeGetParent(v6);
            uint64_t v6 = Parent;
            if (!Parent) {
              break;
            }
            uint64_t v24 = (id *)C3DAnimationNodeGetOwner(Parent);
            uint64_t v25 = C3DEntityGetObjCWrapper(v24);
            if (v25)
            {
              uint64_t v22 = v25;
              uint64_t v21 = a2;
              goto LABEL_23;
            }
          }
        }
        uint64_t v21 = a2;
        uint64_t v22 = 0;
      }
LABEL_23:
      +[SCNTransaction begin];
      +[SCNTransaction setDisableActions:1];
      CFArrayRef v26 = C3DCreatePathFromComponents(v20);
      objc_msgSend(v22, "setValue:forKeyPath:", objc_msgSend((id)objc_msgSend(v22, "presentationInstance"), "valueForKeyPath:", v26), v26);

      +[SCNTransaction commit];
      a2 = v21;
      goto LABEL_24;
    }
  }
LABEL_25:
  if (a2
    && (!C3DIsRunningInEditor() || C3DAnimationGetIsImplicit((uint64_t)Animation)))
  {
    uint64_t v27 = objc_msgSend(ObjCWrapper, "__removeAnimation:forKey:", v8, a4);
    goto LABEL_30;
  }
LABEL_29:
  uint64_t v27 = 0;
LABEL_30:
  if (objc_opt_respondsToSelector())
  {
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __SCNAnimationDidStop_block_invoke;
    block[3] = &unk_264008AF0;
    block[4] = v10;
    block[5] = v9;
    char v37 = a2;
    dispatch_async(MEMORY[0x263EF83A0], block);
  }
  uint64_t v28 = [v8 animationDidStop];
  if (v28)
  {
    uint64_t v29 = v28;
    float v30 = (id *)C3DAnimationNodeGetOwner(v6);
    float v31 = C3DEntityGetObjCWrapper(v30);
    (*(void (**)(uint64_t, id *, id *, uint64_t))(v29 + 16))(v29, v8, v31, a2);
  }

  return v27;
}

void _optimizeKeyframes(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == C3DAnimationGroupGetTypeID())
  {
    Animationuint64_t Count = C3DAnimationGroupGetAnimationCount((uint64_t)a1);
    if (AnimationCount >= 1)
    {
      CFIndex v4 = 0;
      uint64_t v5 = AnimationCount;
      do
      {
        AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex((uint64_t)a1, v4);
        _optimizeKeyframes(AnimationAtIndex);
        ++v4;
      }
      while (v5 != v4);
    }
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == C3DKeyframedAnimationGetTypeID())
    {
      uint64_t Controller = C3DKeyframedAnimationGetController((uint64_t)a1);
      char v9 = 0;
      C3DKeyframeControllerRemoveUselessKeys(Controller, &v9);
    }
  }
}

uint64_t C3DAnimationSetupWithCAAnimation(_WORD *a1, void *a2)
{
  [a2 duration];
  double v5 = v4;
  int v6 = [a2 autoreverses];
  float v7 = v5;
  C3DAnimationSetDuration((uint64_t)a1, v7);
  [a2 repeatCount];
  float v9 = v8;
  [a2 repeatDuration];
  if (v9 == 0.0)
  {
    float v11 = v10;
    if (v11 != 0.0 && v5 != 0.0)
    {
      double v12 = v11;
      [a2 duration];
      float v14 = v12 / v13;
      if (v6) {
        float v9 = v14 * 0.5;
      }
      else {
        float v9 = v14;
      }
    }
  }
  C3DAnimationSetRepeatCount((uint64_t)a1, v9);
  C3DAnimationSetAutoreverses((uint64_t)a1, v6);
  [a2 beginTime];
  C3DAnimationNodeSetPauseTime((uint64_t)a1, v15);
  [a2 timeOffset];
  C3DAnimationSetTimeOffset((uint64_t)a1, v16);
  [a2 speed];
  C3DAnimationSetSpeed((uint64_t)a1, v17);
  C3DAnimationSetRemoveOnCompletion((uint64_t)a1, [a2 isRemovedOnCompletion]);
  [a2 fadeInDuration];
  *(float *)&double v18 = v18;
  C3DAnimationSetFadeInDuration((uint64_t)a1, *(float *)&v18);
  [a2 fadeOutDuration];
  *(float *)&double v19 = v19;
  C3DAnimationSetFadeOutDuration((uint64_t)a1, *(float *)&v19);
  C3DAnimationSetCommitWhenDone(a1, [a2 commitsOnCompletion]);
  C3DAnimationSetIsSceneTimeBased((uint64_t)a1, [a2 usesSceneTimeBase]);
  char v20 = _CAToC3DFillMode([a2 fillMode]);
  C3DAnimationSetFillModeMask((uint64_t)a1, v20);
  uint64_t v21 = _CAToC3DAnimationEvents((void *)[a2 animationEvents]);
  C3DAnimationSetAnimationEvents((uint64_t)a1, v21);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [a2 mass];
    float v23 = v22;
    [a2 stiffness];
    float v25 = v24;
    [a2 damping];
    float v27 = v26;
    [a2 initialVelocity];
    float v29 = v28;
    Spring = (const void *)C3DTimingFunctionCreateSpring(v23, v25, v27, v29);
    C3DAnimationSetTimingFunction((uint64_t)a1, Spring);
    CFRelease(Spring);
  }
  else
  {
    float v31 = (void *)[a2 timingFunction];
    if (v31)
    {
      id v32 = C3DTimingFunctionFromCAMediaTimingFunction(v31);
      C3DAnimationSetTimingFunction((uint64_t)a1, v32);
    }
  }

  return SCNAnimationSetupDelegateWithCAAnimation((uint64_t)a1, a2);
}

uint64_t CAPropertyAnimationSetupWithSCNAnimation(void *a1, uint64_t a2)
{
  [a1 setAdditive:C3DAnimationGetAdditive(a2)];
  [a1 setCumulative:C3DAnimationGetCumulative(a2)];

  return CAAnimationSetupWithSCNAnimation(a1, a2);
}

uint64_t CAAnimationSetupWithSCNAnimation(void *a1, uint64_t a2)
{
  [a1 setDuration:C3DAnimationGetDuration(a2)];
  *(float *)&double v4 = C3DAnimationGetRepeatCount(a2);
  [a1 setRepeatCount:v4];
  [a1 setAutoreverses:C3DAnimationGetAutoreverses(a2)];
  [a1 setBeginTime:C3DAnimationNodeGetPauseTime(a2)];
  [a1 setTimeOffset:C3DAnimationGetTimeOffset(a2)];
  *(float *)&double v5 = C3DAnimationGetSpeed(a2);
  [a1 setSpeed:v5];
  [a1 setFadeInDuration:C3DAnimationGetFadeInDuration(a2)];
  [a1 setFadeOutDuration:C3DAnimationGetFadeOutDuration(a2)];
  [a1 setRemovedOnCompletion:C3DAnimationGetRemoveOnCompletion(a2)];
  [a1 setCommitsOnCompletion:C3DAnimationGetCommitWhenDone(a2)];
  [a1 setUsesSceneTimeBase:C3DAnimationGetIsSceneTimeBased(a2)];
  FillModeMasCFIndex k = C3DAnimationGetFillModeMask(a2);
  [a1 setFillMode:_C3DToCAFillMode(FillModeMask)];
  uint64_t AnimationEvents = C3DAnimationGetAnimationEvents(a2);
  [a1 setAnimationEvents:_C3DToCAAnimationEvents(AnimationEvents)];
  uint64_t result = C3DAnimationGetTimingFunction(a2);
  if (result)
  {
    uint64_t v9 = CAMediaTimingFunctionFromC3DTimingFunction(result);
    return [a1 setTimingFunction:v9];
  }
  return result;
}

_WORD *CAAnimationGroupToC3DAnimation(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  double v4 = (_WORD *)C3DAnimationGroupCreate();
  C3DAnimationSetupWithCAAnimation(v4, a1);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  double v5 = (void *)[a1 animations];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v17 objects:v25 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v18;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(v5);
        }
        double v10 = *(void **)(*((void *)&v17 + 1) + 8 * v9);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          float v11 = (void *)CAAnimationGroupToC3DAnimation(v10, a2);
          C3DAnimationGroupAddAnimation((uint64_t)v4, v11);
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v12 = objc_msgSend((id)objc_msgSend(v10, "keyPath"), "copy");
            if (v12)
            {
              double v13 = (void *)v12;
              float v14 = (void *)_CAAnimationToC3DAnimation(v10, a2);
              if (v14) {
                C3DAnimationGroupAddAnimation((uint64_t)v4, v14);
              }
            }
            else
            {
              double v15 = scn_default_log();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412546;
                double v22 = v10;
                __int16 v23 = 2112;
                double v24 = v4;
                _os_log_error_impl(&dword_20B249000, v15, OS_LOG_TYPE_ERROR, "Error: sub-animation %@ of %@ has no keyPath - ignoring", buf, 0x16u);
              }
            }
          }
        }
        ++v9;
      }
      while (v7 != v9);
      uint64_t v7 = [v5 countByEnumeratingWithState:&v17 objects:v25 count:16];
    }
    while (v7);
  }
  return v4;
}

id SCNAnimationGroupToCAAnimationGroup(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F15750]);
  CAAnimationSetupWithSCNAnimation(v2, a1);
  CFArrayRef Animations = (const __CFArray *)C3DAnimationGroupGetAnimations(a1);
  if (Animations)
  {
    CFIndex Count = CFArrayGetCount(Animations);
    double v5 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:Count];
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex(a1, i);
        uint64_t v8 = (void *)_C3DAnimationToCAAnimation();
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t KeyPath = (void *)C3DAnimationGetKeyPath((uint64_t)AnimationAtIndex);
          if (KeyPath)
          {
            objc_msgSend(v8, "setKeyPath:", objc_msgSend(KeyPath, "componentsJoinedByString:", @"."));
          }
          else
          {
            double v10 = scn_default_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v12 = 0;
              _os_log_impl(&dword_20B249000, v10, OS_LOG_TYPE_DEFAULT, "Warning: SCNAnimationGroupToCAAnimationGroup - no target path", v12, 2u);
            }
          }
        }
        [v5 addObject:v8];
      }
    }
  }
  else
  {
    double v5 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:0];
  }
  [v2 setAnimations:v5];
  return v2;
}

uint64_t __SCNAnimationDidStart_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) animationDidStart:*(void *)(a1 + 40)];
}

uint64_t __SCNAnimationDidStop_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) animationDidStop:*(void *)(a1 + 40) finished:*(unsigned __int8 *)(a1 + 48)];
}

void sub_20B4140A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B414154(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B4141B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B415350()
{
}

void sub_20B4154E8(_Unwind_Exception *a1)
{
}

void sub_20B416B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double C3DAnimationManagerApplyActions(uint64_t a1, double result)
{
  context[2] = *MEMORY[0x263EF8340];
  double v14 = result;
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 120);
  if (v2)
  {
    context[0] = a1;
    context[1] = &v14;
    *(unsigned char *)(a1 + 89) = 1;
    *(_DWORD *)(a1 + 160) = 0;
    CFDictionaryRef Copy = CFDictionaryCreateCopy(0, v2);
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)_applyActions, context);
    if (Copy) {
      CFRelease(Copy);
    }
    *(unsigned char *)(a1 + 89) = 0;
    CFArrayRef v5 = *(const __CFArray **)(a1 + 128);
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        CFIndex v7 = Count;
        for (CFIndex i = 0; i != v7; ++i)
        {
          ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 128), i);
          CFTypeID v10 = CFGetTypeID(ValueAtIndex);
          if (v10 == CFArrayGetTypeID())
          {
            float v11 = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
            uint64_t v12 = (void *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 1);
            double v13 = (void *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 2);
            _C3DAnimationManagerRemoveActionWithKey(a1, v11, v12, v13);
          }
          else
          {
            C3DAnimationManagerRemoveActionsForObject(a1, ValueAtIndex);
          }
        }
      }
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 128));
    }
    uint64_t result = v14;
    *(double *)(a1 + 152) = v14;
  }
  return result;
}

void _applyActions(id *a1, CFArrayRef theArray, uint64_t *a3)
{
  uint64_t v5 = *a3;
  double v6 = *(double *)a3[1];
  CFIndex Count = CFArrayGetCount(theArray);
  if (C3DIsRunningInEditor())
  {
    if (v6 == 0.0)
    {
      SCNActionRestoreState((uint64_t)a1);
      SCNActionReleaseCachedState((uint64_t)a1);
      SCNActionsReset(theArray);
    }
    else
    {
      SCNActionSaveStateIfNeeded((uint64_t)a1);
      if (v6 < *(double *)(v5 + 152))
      {
        SCNActionRestoreState((uint64_t)a1);
        SCNActionsReset(theArray);
        if (Count < 1) {
          return;
        }
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(theArray, i);
          SCNActionApply(ValueAtIndex, a1, 0.0);
        }
      }
    }
  }
  if (Count >= 1)
  {
    for (CFIndex j = 0; j < Count; ++j)
    {
      float v11 = (void *)CFArrayGetValueAtIndex(theArray, j);
      if (!SCNActionIsPaused(v11))
      {
        if (SCNActionApply(v11, a1, v6))
        {
          CFRetain(a1);
          CFRetain(v11);
          SCNActionWasRemovedFromTargetAtTime(v11, a1, v6);
          CFArrayRemoveValueAtIndex(theArray, j--);
          --Count;
          SCNActionDidFinish(v11, a1);
          CFRelease(v11);
          CFRelease(a1);
        }
        else
        {
          ++*(_DWORD *)(v5 + 160);
        }
      }
    }
  }
}

void _C3DAnimationManagerRemoveActionWithKey(uint64_t a1, const void *a2, void *a3, void *a4)
{
  v21[3] = *(const void **)MEMORY[0x263EF8340];
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 120);
  if (v5)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v5, a2);
    if (Value)
    {
      CFArrayRef v10 = Value;
      CFIndex Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        CFIndex v12 = Count;
        CFIndex v13 = 0;
        while (1)
        {
          ValueAtuint64_t Index = (void *)CFArrayGetValueAtIndex(v10, v13);
          int HasKey = SCNActionHasKey(ValueAtIndex, a3);
          BOOL v16 = !a4 || ValueAtIndex == a4;
          BOOL v17 = v16;
          if (HasKey && v17) {
            break;
          }
          if (v12 == ++v13) {
            return;
          }
        }
        if (*(unsigned char *)(a1 + 89))
        {
          CFDictionaryRef Mutable = *(__CFArray **)(a1 + 128);
          if (!Mutable)
          {
            CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
            *(void *)(a1 + 128) = Mutable;
          }
          v21[0] = a2;
          v21[1] = a3;
          v21[2] = ValueAtIndex;
          CFArrayRef v19 = CFArrayCreate(0, v21, 3, MEMORY[0x263EFFF70]);
          CFArrayAppendValue(Mutable, v19);
        }
        else
        {
          CFArrayRemoveValueAtIndex(v10, v13);
          if (v12 == 1)
          {
            long long v20 = *(__CFDictionary **)(a1 + 120);
            CFDictionaryRemoveValue(v20, a2);
          }
        }
      }
    }
  }
}

void C3DAnimationManagerRemoveActionsForObject(uint64_t a1, void *key)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 120);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 89))
    {
      CFDictionaryRef Mutable = *(__CFArray **)(a1 + 128);
      if (!Mutable)
      {
        CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
        *(void *)(a1 + 128) = Mutable;
      }
      CFArrayAppendValue(Mutable, key);
    }
    else if (CFDictionaryGetValue(v3, key))
    {
      double v6 = *(__CFDictionary **)(a1 + 120);
      CFDictionaryRemoveValue(v6, key);
    }
  }
}

void C3DAnimationManagerAddAction(uint64_t a1, void *key, const void *a3)
{
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 120);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    *(void *)(a1 + 120) = Mutable;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    CFArrayRef Value = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 120), key, Value);
    CFRelease(Value);
  }

  CFArrayAppendValue((CFMutableArrayRef)Value, a3);
}

void C3DAnimationManagerRemoveActionWithKey(uint64_t a1, const void *a2, void *a3)
{
}

CFTypeRef C3DCommonProfileShaderAssignAttributesAndUniformsIndexes(CFTypeRef cf)
{
  if (C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_onceToken != -1) {
    dispatch_once(&C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_onceToken, &__block_literal_global_77);
  }
  _C3DFXGLSLProgramSetUniformDictionary(cf, (CFTypeRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol);
  CFDictionaryRef v2 = (const void *)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol;

  return _C3DFXGLSLProgramSetAttributesDictionary(cf, v2);
}

void __C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  id v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_skinningWeights", (const void *)0xD);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_skinningJoints", (const void *)0xE);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_position", 0);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_normal", (const void *)1);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_vertexColor", (const void *)2);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_TexTangent", (const void *)3);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_diffuseTexcoord", (const void *)4);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_ambientTexcoord", (const void *)5);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_specularTexcoord", (const void *)6);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_emissionTexcoord", (const void *)7);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_filterTexcoord", (const void *)8);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_transparentTexcoord", (const void *)9);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_normalTexcoord", (const void *)0xA);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_attributeIndexToSymbol, @"a_lightmapTexcoord", (const void *)0xC);
  C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, 0);
  C3DShaderFeedStandardUniformsToIndex((void *)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_cameraPosition", (const void *)0x11);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_nodeOpacity", (const void *)9);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_skinningJointMatrices", (const void *)0xBA);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_materialShininess", (const void *)0x93);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_ambientColor", (const void *)0x98);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_ambientIntensity", (const void *)0x99);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_ambientTexture", (const void *)0x9A);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_ambientTextureMatrix", (const void *)0x9B);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_diffuseColor", (const void *)0x94);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_diffuseIntensity", (const void *)0x95);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_diffuseTexture", (const void *)0x96);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_diffuseTextureMatrix", (const void *)0x97);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_specularColor", (const void *)0x9C);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_specularIntensity", (const void *)0x9D);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_specularTexture", (const void *)0x9E);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_specularTextureMatrix", (const void *)0x9F);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_emissionColor", (const void *)0xA0);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_emissionIntensity", (const void *)0xA1);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_emissionTexture", (const void *)0xA2);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_emissionTextureMatrix", (const void *)0xA3);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_multiplyColor", (const void *)0xA4);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_multiplyIntensity", (const void *)0xA5);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_multiplyTexture", (const void *)0xA6);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_multiplyTextureMatrix", (const void *)0xA7);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_transparency", (const void *)0xA8);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_transparentColor", (const void *)0xA9);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_transparentIntensity", (const void *)0xAA);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_transparentTexture", (const void *)0xAB);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_transparentTextureMatrix", (const void *)0xAC);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_normalTexture", (const void *)0xAD);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_normalIntensity", (const void *)0xAE);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_normalTextureMatrix", (const void *)0xAF);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_shininessTexture", (const void *)0xB0);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_shininessTextureMatrix", (const void *)0xB1);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_lightmapTexture", (const void *)0xB2);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_reflectiveColor", (const void *)0xB3);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_reflectiveIntensity", (const void *)0xB4);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_reflectiveTexture", (const void *)0xB5);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_reflectiveTextureMatrix", (const void *)0xB6);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_fresnel", (const void *)0xB7);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_ambientLightColor", (const void *)0xB8);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_shCoefficients", (const void *)0xB9);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_fogColor", (const void *)0xBE);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_fogParameters", (const void *)0xBF);
  uint64_t v2 = 0;
  for (uint64_t i = 33; i != 161; i += 16)
  {
    CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"u_light%d_attenuation", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v4, (const void *)(i - 10));
    CFRelease(v4);
    CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"u_light%d_spotAttenuation", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v5, (const void *)(i - 9));
    CFRelease(v5);
    CFStringRef v6 = CFStringCreateWithFormat(0, 0, @"u_light%d_color", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v6, (const void *)(i - 15));
    CFRelease(v6);
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"u_light%d_position", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v7, (const void *)(i - 14));
    CFRelease(v7);
    CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"u_light%d_direction", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v8, (const void *)(i - 13));
    CFRelease(v8);
    CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"u_light%d_up", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v9, (const void *)(i - 12));
    CFRelease(v9);
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"u_light%d_right", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v10, (const void *)(i - 11));
    CFRelease(v10);
    CFStringRef v11 = CFStringCreateWithFormat(0, 0, @"u_light%d_gobo", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v11, (const void *)(i - 8));
    CFRelease(v11);
    CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"u_light%d_goboMatrix", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v12, (const void *)(i - 7));
    CFRelease(v12);
    CFStringRef v13 = CFStringCreateWithFormat(0, 0, @"u_light%d_goboIntensity", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v13, (const void *)(i - 6));
    CFRelease(v13);
    CFStringRef v14 = CFStringCreateWithFormat(0, 0, @"u_light%d_iesMatrix", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v14, (const void *)(i - 4));
    CFRelease(v14);
    CFStringRef v15 = CFStringCreateWithFormat(0, 0, @"u_light%d_iesTex", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v15, (const void *)(i - 5));
    CFRelease(v15);
    CFStringRef v16 = CFStringCreateWithFormat(0, 0, @"u_light%d_shadow", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v16, (const void *)(i - 3));
    CFRelease(v16);
    CFStringRef v17 = CFStringCreateWithFormat(0, 0, @"u_light%d_shadowMatrix", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v17, (const void *)(i - 2));
    CFRelease(v17);
    CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"u_light%d_shadowRadius", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v18, (const void *)(i - 1));
    CFRelease(v18);
    CFStringRef v19 = CFStringCreateWithFormat(0, 0, @"u_light%d_shadowColor", v2);
    CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, v19, (const void *)i);
    CFRelease(v19);
    uint64_t v2 = (v2 + 1);
  }
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_zRange", (const void *)0xBB);
  CFDictionarySetValue((CFMutableDictionaryRef)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol, @"u_orientationPreserved", (const void *)0xBC);
  long long v20 = (__CFDictionary *)C3DCommonProfileShaderAssignAttributesAndUniformsIndexes_uniformIndexToSymbol;

  CFDictionarySetValue(v20, @"u_shadowKernel", (const void *)0xBD);
}

C3D::RenderProbePass *C3D::RenderProbePass::RenderProbePass(C3D::RenderProbePass *this, RenderGraph *a2, C3D::Pass *a3, __C3DNode *a4, int a5, MTLPixelFormat a6)
{
  v12[0] = 0;
  v12[1] = a4;
  memset(&v12[2], 0, 24);
  long long v13 = xmmword_20B5CBBE0;
  char v14 = 1;
  __int16 v15 = 64;
  int v16 = 0x1000000;
  __int16 v17 = 0;
  char v18 = 2;
  CFStringRef v9 = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, (const Parameters *)v12);
  *(void *)CFStringRef v9 = &unk_26BF6D5E0;
  if (!C3DNodeGetLight(*((void *)v9 + 31)))
  {
    CFStringRef v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3D::RenderProbePass::RenderProbePass(v10);
    }
  }
  *((_DWORD *)this + 1340) = a5;
  *((void *)this + 671) = a6;
  return this;
}

void C3D::RenderProbePass::setup(C3D::RenderProbePass *this)
{
  C3D::Pass::setOutputCount(this, 2u);
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::RenderProbePass *)((char *)this + 32), 0);
  *(unsigned char *)(v2 + 64) = 1;
  *(void *)(v2 + 8) = "PROBE";
  __int16 v3 = *(_WORD *)(v2 + 66);
  *(_WORD *)(v2 + 66) = v3 & 0xFFEF;
  __int16 v4 = *((_WORD *)this + 2680);
  uint64_t v5 = *((void *)this + 671);
  *(_WORD *)(v2 + 16) = v4;
  *(_WORD *)(v2 + 18) = v4;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 24) = 517;
  *(_WORD *)(v2 + 28) = v5;
  *(_DWORD *)(v2 + 32) = 0;
  *(_WORD *)(v2 + 30) = 5;
  *(_WORD *)(v2 + 66) = v3 & 0xFFEC | 2;
  uint64_t v6 = C3D::PassDescriptor::outputAtIndex((C3D::RenderProbePass *)((char *)this + 32), 1u);
  *(unsigned char *)(v6 + 64) = 2;
  *(void *)(v6 + 8) = "DEPTH";
  __int16 v7 = *(_WORD *)(v6 + 66) | 0x18;
  *(_WORD *)(v6 + 66) = v7;
  __int16 v8 = *((_WORD *)this + 2680);
  *(_WORD *)(v6 + 16) = v8;
  *(_WORD *)(v6 + 18) = v8;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 24) = 517;
  *(_WORD *)(v6 + 28) = 252;
  *(_WORD *)(v6 + 30) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_WORD *)(v6 + 66) = v7 & 0xFFFC | 2;

  C3D::DrawNodesPass::setup(this);
}

const char *C3D::RenderProbePass::name(C3D::RenderProbePass *this)
{
  return "RenderProbePass";
}

const char *C3D::RenderProbePass::programHashCodeStoreName(C3D::RenderProbePass *this)
{
  return "RenderProbePass";
}

void sub_20B418EE8(_Unwind_Exception *a1)
{
  vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation(v1 - 256);
  _Unwind_Resume(a1);
}

void sub_20B419028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_20B419288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  vmesh::StaticAdjacencyInformation<Pair>::~StaticAdjacencyInformation((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_20B419BF4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B419C64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B419D94(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B419DF4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B41A800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_20B41B408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_20B41BFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

uint64_t __UpdateLight(const void *a1, const void *a2, void *a3)
{
  return [a3 updateLightNode:a2 withSourceNode:a1];
}

uint64_t __UpdateCamera(const void *a1, const void *a2, void *a3)
{
  return [a3 updateCameraNode:a2 withSourceNode:a1];
}

uint64_t __UpdateParticles(const void *a1, const void *a2, void *a3)
{
  return [a3 updateParticlesNode:a2 withSourceNode:a1];
}

uint64_t __UpdateFields(const void *a1, const void *a2, void *a3)
{
  return [a3 updateFieldNode:a2 withSourceNode:a1];
}

uint64_t C3DAuthoringEnvironment2Create(uint64_t a1)
{
  uint64_t v1 = +[SCNScene sceneWithSceneRef:a1];
  uint64_t v2 = [SCNAuthoringEnvironment2 alloc];

  return (uint64_t)[(SCNAuthoringEnvironment2 *)v2 initWithScene:v1];
}

uint64_t C3DAuthoringEnvironment2NodeAddedToScene(void *a1, id *a2)
{
  ObjCWrapper = C3DEntityGetObjCWrapper(a2);

  return [a1 addedNode:ObjCWrapper];
}

id *C3DAuthoringEnvironment2NodeRemovedFromScene(void *a1, id *a2)
{
  uint64_t result = C3DEntityGetObjCWrapper(a2);
  if (result)
  {
    return (id *)[a1 removedNode:result];
  }
  return result;
}

uint64_t C3DAuthoringEnvironment2Update(void *a1, const char *a2)
{
  return [a1 updateWithRenderer:a2];
}

void *C3DEAGLWrapperContextRetain(void *a1)
{
  id v2 = a1;
  return a1;
}

uint64_t C3DFXTechniqueCreateAuthoring()
{
  CFAllocatorRef v0 = (const void *)C3DDictionaryNamed(@"C3DFXAuthoring.plist");

  return C3DFXTechniqueCreateWithDescription(v0, 0);
}

id SCNCreateFuntionConstants(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _WORD *a6, uint64_t a7)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t CommonProfile = (float *)C3DMaterialGetCommonProfile(a7);
  if (a3) {
    BOOL v14 = C3DMeshContainsSourcesWithSemantic(a3, 1);
  }
  else {
    BOOL v14 = 0;
  }
  uint64_t v51 = a2;
  long long v52 = a1;
  uint64_t v50 = a4;
  if (a6)
  {
    unsigned int v15 = (unsigned __int16)*a6;
    BOOL v53 = (v15 & 1) == 0;
    int v16 = (v15 >> 1) & 1;
  }
  else
  {
    BOOL v53 = 0;
    int v16 = 1;
  }
  int v49 = v16;
  int LightingModel = C3DEffectCommonProfileGetLightingModel((uint64_t)CommonProfile);
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  if (a3) {
    BOOL v18 = C3DMeshContainsSourcesWithSemantic(a3, 2);
  }
  else {
    BOOL v18 = 0;
  }
  LOBYTE(v63) = v18;
  BYTE1(v63) = 1;
  BYTE2(v63) = v14;
  ElementsCFIndex Count = C3DMeshGetElementsCount(a3);
  if ((uint64_t)ElementsCount >= 1)
  {
    CFArrayRef v20 = ElementsCount;
    char v21 = 0;
    for (CFIndex i = 0; (const __CFArray *)i != v20; ++i)
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex(a3, i, 1);
      v21 |= C3DMeshElementGetType((uint64_t)ElementAtIndex) == 3;
    }
    BYTE11(v75) = v21;
  }
  uint64_t v24 = 0;
  uint64_t v62 = 0;
  do
  {
    if (C3DEffectCommonProfileIsUsingMappingChannel((uint64_t)CommonProfile, v24))
    {
      if (a3 && C3DMeshGetSourceWithSemanticAtIndex(a3, 3, v24, 1))
      {
        *((unsigned char *)&v62 + v24) = 1;
      }
      else
      {
        float v25 = scn_default_log();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          int v61 = v24;
          _os_log_impl(&dword_20B249000, v25, OS_LOG_TYPE_DEFAULT, "Warning: MappingChannel %d needed but not available", buf, 8u);
        }
      }
    }
    ++v24;
  }
  while (v24 != 8);
  *(void *)((char *)&v63 + 4) = v62;
  BYTE12(v63) = v63;
  *(_WORD *)((char *)&v63 + 13) = 257;
  HIBYTE(v63) = 1;
  BOOL v59 = 0;
  *(_DWORD *)long long buf = 0;
  *((void *)&v78 + 1) = -1;
  if (C3DEffectCommonProfileIsUsingSelfIllumination((uint64_t)CommonProfile))
  {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 9, (BOOL *)&v64 + 3, (BOOL *)&v64 + 10, (BOOL *)&v67 + 15, &v66, (int *)&v71 + 3, (_DWORD *)&v69 + 2, (int *)&v74);
    BYTE8(v75) = BYTE3(v64);
  }
  else
  {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 0, (BOOL *)&v64 + 3, (BOOL *)&v64 + 10, (BOOL *)&v67 + 15, &v66, (int *)&v71 + 3, (_DWORD *)&v69 + 2, (int *)&v74);
  }
  if (C3DEffectCommonProfileIsUsingAmbientOcclusion((uint64_t)CommonProfile))
  {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 8, (BOOL *)&v64, (BOOL *)&v64 + 11, (BOOL *)&v68, (_DWORD *)&v66 + 1, (int *)&v72, (_DWORD *)&v69 + 3, (int *)&v74 + 1);
    BYTE9(v75) = v64;
  }
  else if ((C3DEffectCommonProfileGetEnableLockAmbientWithDiffuse((uint64_t)CommonProfile) & 1) == 0 && v49)
  {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 1, (BOOL *)&v64, (BOOL *)&v64 + 11, (BOOL *)&v68, (_DWORD *)&v66 + 1, (int *)&v72, (_DWORD *)&v69 + 3, (int *)&v74 + 1);
  }
  SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 2, (BOOL *)&v64 + 1, (BOOL *)&v64 + 7, (BOOL *)&v67 + 12, (_DWORD *)&v65 + 1, (int *)&v71, (_DWORD *)&v68 + 3, (int *)&v73 + 1);
  if ((LightingModel & 0xFFFFFFFE) == 2) {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 3, (BOOL *)&v64 + 2, (BOOL *)&v64 + 13, (BOOL *)&v68 + 2, (_DWORD *)&v66 + 3, (int *)&v72 + 2, (_DWORD *)&v70 + 1, (int *)&v74 + 3);
  }
  SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 4, (BOOL *)&v64 + 5, (BOOL *)&v64 + 14, (BOOL *)&v68 + 3, &v67, (int *)buf, buf, (int *)buf);
  SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 5, (BOOL *)&v64 + 6, (BOOL *)&v64 + 9, (BOOL *)&v67 + 14, (_DWORD *)&v65 + 3, (int *)&v71 + 2, (_DWORD *)&v69 + 1, (int *)&v73 + 3);
  SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 6, (BOOL *)&v64 + 4, (BOOL *)&v64 + 12, (BOOL *)&v68 + 1, (_DWORD *)&v66 + 2, (int *)&v72 + 1, &v70, (int *)&v74 + 2);
  SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 7, &v59, (BOOL *)&v64 + 8, (BOOL *)&v67 + 13, (_DWORD *)&v65 + 2, (int *)&v71 + 1, &v69, (int *)&v73 + 2);
  if (LightingModel == 5)
  {
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 11, &v59, (BOOL *)&v65, (BOOL *)&v68 + 4, (_DWORD *)&v67 + 1, (int *)&v72 + 3, (_DWORD *)&v70 + 2, (int *)&v75);
    SCNStandardConstants::_setPropertyFlags((uint64_t)&v63, (uint64_t)CommonProfile, 10, &v59, (BOOL *)&v65 + 1, (BOOL *)&v68 + 5, (_DWORD *)&v67 + 2, (int *)&v73, (_DWORD *)&v70 + 3, (int *)&v75 + 1);
  }
  BYTE3(v63) = BYTE8(v64);
  int v58 = 0;
  unsigned __int8 v57 = 0;
  char v56 = 1;
  char v26 = BYTE7(v64);
  if (BYTE7(v64))
  {
    uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 2, 0);
    C3DEffectSlotGetTextureInfo(EffectSlot, &v58, &v57, &v56);
    if (v56) {
      BOOL v28 = v57 == 0;
    }
    else {
      BOOL v28 = 1;
    }
    char v26 = !v28;
  }
  BYTE12(v75) = v26;
  if (BYTE14(v64))
  {
    int v55 = 0;
    uint64_t v29 = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 4, 0);
    C3DEffectSlotGetTextureInfo(v29, &v55, &v59, &v59);
    if (v55 == 4) {
      HIWORD(v64) = 256;
    }
  }
  Ischar DoubleSided = C3DMaterialIsDoubleSided(a7);
  BOOL v31 = v53;
  if ((LightingModel & 0xFFFFFFFB) == 0) {
    BOOL v31 = 0;
  }
  BYTE9(v76) = IsDoubleSided;
  LODWORD(v76) = LightingModel;
  char v32 = v31 && v14;
  if (LightingModel == 5) {
    char v32 = 1;
  }
  BYTE4(v76) = v32;
  if (a6 && LightingModel == 5)
  {
    BYTE10(v76) = (*a6 & 0x70) != 0;
    LOBYTE(v33) = 1;
    uint64_t v35 = v51;
    uint64_t v34 = v52;
    uint64_t v36 = v50;
  }
  else
  {
    BYTE10(v76) = 0;
    if (LightingModel == 5)
    {
      uint64_t v35 = v51;
      uint64_t v34 = v52;
      uint64_t v36 = v50;
      LOBYTE(v33) = 1;
    }
    else
    {
      uint64_t v35 = v51;
      uint64_t v34 = v52;
      uint64_t v36 = v50;
      LOBYTE(v33) = LightingModel == 5;
      if (a6) {
        int v33 = ((unsigned __int16)*a6 >> 1) & 1;
      }
    }
  }
  BYTE5(v76) = v33;
  if (a5 < 1)
  {
    BOOL v40 = 0;
  }
  else if ((*(unsigned char *)(v36 + 1) & 0x10) != 0)
  {
    BOOL v40 = 1;
  }
  else
  {
    uint64_t v37 = 1;
    do
    {
      uint64_t v38 = v37;
      if (a5 == v37) {
        break;
      }
      int v39 = *(_DWORD *)(v36 + 4 * v37++);
    }
    while ((v39 & 0x1000) == 0);
    BOOL v40 = v38 < a5;
  }
  BYTE6(v76) = v40;
  BYTE7(v76) = C3DEffectCommonProfileIsPerPixelLit((uint64_t)CommonProfile) ^ 1;
  int v41 = C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18) != 1.0;
  BYTE7(v68) = v41;
  char v42 = BYTE5(v64);
  if (BYTE5(v64))
  {
    char v42 = C3DEffectCommonProfileGetFloatProperty(CommonProfile, 20) != 0.0;
    int v41 = BYTE7(v68);
  }
  BYTE6(v68) = v42;
  if (v41) {
    LOBYTE(v41) = C3DEffectCommonProfileGetTransparencyMode((uint64_t)CommonProfile) == 1;
  }
  BYTE8(v68) = v41;
  BYTE13(v75) = (BYTE9(v64) | v57) != 0;
  uint64_t v43 = 4;
  if (a5 < 4) {
    uint64_t v43 = a5;
  }
  switch(v43)
  {
    case 1:
      goto LABEL_73;
    case 2:
      goto LABEL_72;
    case 3:
      goto LABEL_71;
    case 4:
      DWORD2(v77) = *(_DWORD *)(v36 + 12);
LABEL_71:
      DWORD1(v77) = *(_DWORD *)(v36 + 8);
LABEL_72:
      LODWORD(v77) = *(_DWORD *)(v36 + 4);
LABEL_73:
      HIDWORD(v76) = *(_DWORD *)v36;
      break;
    default:
      break;
  }
  BYTE12(v77) = C3DNodeGetOpacity((uint64_t)v34) < 1.0;
  int IsDynamicBatchingEnabled = C3DGeometryIsDynamicBatchingEnabled(v35);
  BOOL v45 = 0;
  if (IsDynamicBatchingEnabled && !BYTE12(v77)) {
    BOOL v45 = BYTE10(v76) == 0;
  }
  BYTE14(v75) = v45;
  v47 = v34 && (uint64_t v46 = C3DGetScene(v34)) != 0 && C3DSceneGetFogEndDistance(v46) > 0.0;
  BYTE13(v77) = v47;
  return objc_alloc_init(MEMORY[0x263F128B0]);
}

void SCNStandardConstants::_setPropertyFlags(uint64_t a1, uint64_t a2, int a3, BOOL *a4, BOOL *a5, BOOL *a6, _DWORD *a7, int *a8, _DWORD *a9, int *a10)
{
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(a2, a3, 0);
  if (!EffectSlot) {
    return;
  }
  uint64_t v18 = EffectSlot;
  *a4 = C3DEffectSlotIsValid(EffectSlot);
  *a5 = C3DEffectSlotHasImageOrTexture(v18);
  *a6 = C3DEffectSlotGetIntensity(v18) != 1.0;
  if (C3DEffectSlotGetTextureComponents(v18) == 15)
  {
    int v19 = 0;
LABEL_7:
    *a7 = v19;
    goto LABEL_8;
  }
  unint64_t v20 = (((unint64_t)*(unsigned __int16 *)(v18 + 48) >> 11) & 0xF) - 1;
  if v20 <= 7 && ((0x8Bu >> v20))
  {
    int v19 = dword_20B5EE1C0[v20];
    goto LABEL_7;
  }
LABEL_8:
  if (a3 != 4 && *a5)
  {
    *a9 = C3DEffectSlotGetUVSet(v18);
    if (C3DKeyframeControllerHasInterpolationModesPerKey(v18))
    {
      int v21 = *(_DWORD *)(a1 + 244) + 1;
      *(_DWORD *)(a1 + 244) = v21;
      *a10 = v21;
      int v22 = *(_DWORD *)(a1 + 240) + 1;
      *(_DWORD *)(a1 + 240) = v22;
    }
    else
    {
      uint64_t v23 = a1 + *a9;
      int v26 = *(unsigned __int8 *)(v23 + 248);
      uint64_t v24 = (unsigned char *)(v23 + 248);
      LOBYTE(v25) = v26;
      if (v26 == 255)
      {
        int v25 = *(_DWORD *)(a1 + 240) + 1;
        *(_DWORD *)(a1 + 240) = v25;
        unsigned char *v24 = v25;
      }
      int v22 = v25;
    }
    *a8 = v22;
    if (v22 >= 8)
    {
      float v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        SCNStandardConstants::_setPropertyFlags(v27);
      }
    }
  }
}

void __DestroyControllers(uint64_t a1)
{
  if (*(int *)(a1 + 888) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 56;
    do
    {
      free(*(void **)(*(void *)(a1 + 880) + v3));
      ++v2;
      v3 += 80;
    }
    while (v2 < *(int *)(a1 + 888));
  }
  free(*(void **)(a1 + 880));
  *(void *)(a1 + 880) = 0;
}

BOOL C3DParticleSystemGetAndClearMeshDidChange(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 856);
  if (*(unsigned char *)(a1 + 856)) {
    *(unsigned char *)(a1 + 856) = 0;
  }
  return v1 != 0;
}

void __C3DParticleSystemControllersDidChange(uint64_t a1)
{
  __DestroyControllers(a1);
  *(void *)(a1 + 888) = -1;
  uint64_t v2 = *(const void **)(a1 + 920);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 920) = 0;
  }
}

uint64_t C3DParticleSystemCreate()
{
  if (C3DParticleSystemGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParticleSystemGetTypeID_onceToken, &__block_literal_global_78);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DParticleSystemGetTypeID_typeID, 0x3C0uLL);
  C3DColor4Make((float *)(Instance + 256), 1.0, 1.0, 1.0, 1.0);
  *(_DWORD *)(Instance + 372) = 1065353216;
  *(void *)(Instance + 108) = 1065353216;
  *(unsigned char *)(Instance + 101) = 1;
  *(_DWORD *)(Instance + 204) = 1065353216;
  *(_DWORD *)(Instance + 288) = 1065353216;
  *(_DWORD *)(Instance + 296) = 1065353216;
  *(_DWORD *)(Instance + 212) = 1060320051;
  *(_DWORD *)(Instance + 228) = 0;
  *(_DWORD *)(Instance + 220) = 1065353216;
  *(_DWORD *)(Instance + 304) = 65537;
  *(_DWORD *)(Instance + 384) = 1065353216;
  *(_DWORD *)(Instance + 396) = 1077936128;
  *(_OWORD *)(Instance + 128) = xmmword_20B5CB7D0;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 160) = 0u;
  __C3DParticleSystemControllersDidChange(Instance);
  *(_DWORD *)(Instance + 872) = -1;
  *(_WORD *)(Instance + 857) = 257;
  *(void *)(Instance + 904) = 0;
  return Instance;
}

CFIndex __AddModifierForStage(uint64_t a1, _DWORD *a2, CFArrayRef theArray, int a4)
{
  CFIndex result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    CFIndex v9 = result;
    for (CFIndex i = 0; i != v9; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, i);
      CFIndex result = C3DParticleModifierGetStage((uint64_t)ValueAtIndex);
      if (result == a4)
      {
        unsigned int v12 = (*a2)++;
        *(void *)(a1 + 24 * v12 + 16) = ValueAtIndex;
      }
    }
  }
  return result;
}

void __C3DParticleSystemUpdateInternal(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  uint64_t v27 = *MEMORY[0x263EF8340];
  *(_DWORD *)(v1 + 872) = 0;
  unsigned int v25 = 0;
  bzero(__src, 0x3000uLL);
  if (C3DParticleSystemGetRenderingMode(v2) - 4 >= 0xFFFFFFFE)
  {
    uint64_t v6 = (void *)(v2 + 864);
    free(*(void **)(v2 + 864));
LABEL_32:
    unsigned int v23 = 0;
    *uint64_t v6 = 0;
    goto LABEL_33;
  }
  CFArrayRef v3 = *(const __CFArray **)(v2 + 896);
  if (v3) {
    __AddModifierForStage((uint64_t)__src, &v25, v3, 0);
  }
  if (C3DParticleSystemGetParticleMassVariation(v2) == 0.0)
  {
    float DampingFactor = C3DParticleSystemGetDampingFactor(v2);
    unsigned int v8 = v25;
    unsigned int v5 = ++v25;
    CFIndex v9 = (__n128 (**)(uint64_t, unsigned int, unsigned int))&__src[3 * v8];
    if (DampingFactor == 0.0) {
      CFStringRef v10 = C3DParticleEulerIntegration_NoMassVariationNoDrag;
    }
    else {
      CFStringRef v10 = C3DParticleEulerIntegration_NoMassVariation;
    }
    *CFIndex v9 = v10;
  }
  else
  {
    unsigned int v4 = v25;
    unsigned int v5 = ++v25;
    __src[3 * v4] = C3DParticleEulerIntegration_C;
  }
  if (C3DParticleSystemGetAffectedByPhysicsFields(v2))
  {
    uint64_t v11 = 3 * v5++;
    unsigned int v25 = v5;
    __src[v11] = C3DParticleModifier_PhysicsField;
  }
  if (C3DParticleSystemHasTextureAnimation(v2))
  {
    unsigned int v25 = v5 + 1;
    __src[3 * v5] = C3DParticleModifier_Frame;
  }
  CFArrayRef v12 = *(const __CFArray **)(v2 + 896);
  if (v12)
  {
    __AddModifierForStage((uint64_t)__src, &v25, v12, 1);
    __AddModifierForStage((uint64_t)__src, &v25, *(CFArrayRef *)(v2 + 896), 2);
  }
  if (C3DParticleSystemGetEventBlock(v2, 2u, 0)) {
    long long v13 = C3DParticleGenericColliderWithBlock;
  }
  else {
    long long v13 = C3DParticleGenericCollider;
  }
  CFArrayRef v14 = *(const __CFArray **)(v2 + 360);
  if (v14)
  {
    CFIndex Count = CFArrayGetCount(v14);
    unsigned int v16 = v25;
    if (Count >= 1)
    {
      CFIndex v17 = Count;
      for (CFIndex i = 0; i != v17; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 360), i);
        unint64_t v20 = &__src[3 * v16 + 3 * i];
        *unint64_t v20 = v13;
        v20[1] = ValueAtIndex;
      }
      v16 += i;
    }
    unsigned int v25 = v16;
  }
  CFArrayRef v21 = *(const __CFArray **)(v2 + 896);
  if (v21) {
    __AddModifierForStage((uint64_t)__src, &v25, v21, 3);
  }
  uint64_t SystemSpawnedOnLiving = C3DParticleSystemGetSystemSpawnedOnLiving(v2);
  unsigned int v23 = v25;
  if (SystemSpawnedOnLiving)
  {
    __src[3 * v25] = C3DParticleSpawnSubSystem;
    ++v23;
  }
  uint64_t v6 = (void *)(v2 + 864);
  free(*(void **)(v2 + 864));
  if (!v23) {
    goto LABEL_32;
  }
  uint64_t v24 = malloc_type_malloc(24 * v23, 0xA0040114AFA65uLL);
  *uint64_t v6 = v24;
  memcpy(v24, __src, 24 * v23);
LABEL_33:
  *(_DWORD *)(v2 + 872) = v23;
}

uint64_t C3DParticleSystemGetRenderingMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 91);
}

float C3DParticleSystemGetParticleMassVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 376);
}

float C3DParticleSystemGetDampingFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 380);
}

uint64_t C3DParticleSystemGetAffectedByPhysicsFields(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 97);
}

BOOL C3DParticleSystemHasTextureAnimation(uint64_t a1)
{
  return C3DParticleSystemGetImageSequenceColumnCount(a1) > 1
      || C3DParticleSystemGetImageSequenceRowCount(a1) > 1;
}

uint64_t C3DParticleSystemGetEventBlock(uint64_t a1, unsigned int a2, void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (a3) {
    *a3 = *(void *)(a1 + 8 * a2 + 952);
  }
  return *(void *)(a1 + 8 * a2 + 928);
}

uint64_t C3DParticleSystemGetSystemSpawnedOnLiving(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 344);
}

uint64_t C3DParticleSystemGetParticleColor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 256;
}

__n128 C3DParticleSystemSetParticleColor(__n128 *a1, __n128 *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DCGColorGetComponentsInColorSpace_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  __n128 result = *a2;
  a1[16] = *a2;
  return result;
}

uint64_t C3DParticleSystemGetParticleColorController(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(__int16 *)(a1 + 892) == -1) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 880) + 80 * *(__int16 *)(a1 + 892) + 16);
  }
}

uint64_t C3DParticleSystemGetParticleOpacityController(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(__int16 *)(a1 + 894) == -1) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 880) + 80 * *(__int16 *)(a1 + 894) + 16);
  }
}

uint64_t C3DParticleSystemGetParticleTexture(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 240);
}

CFTypeRef C3DParticleSystemSetParticleTexture(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 240);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 240) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 240) = result;
    *(unsigned char *)(a1 + 858) = 1;
  }
  return result;
}

void C3DParticleSystemSetColliderNodes(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 360);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 360) = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    *(void *)(a1 + 360) = v13;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

void C3DParticleSystemSetEventBlock(uint64_t a1, unsigned int a2, void *aBlock, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  uint64_t v16 = a2;
  uint64_t v17 = a1 + 8 * a2;
  CFTypeRef v18 = *(CFTypeRef *)(v17 + 952);
  if (v18 != cf)
  {
    uint64_t v19 = (void *)(v17 + 952);
    if (v18)
    {
      CFRelease(v18);
      *uint64_t v19 = 0;
    }
    if (cf) {
      CFTypeRef v20 = CFRetain(cf);
    }
    else {
      CFTypeRef v20 = 0;
    }
    *uint64_t v19 = v20;
  }
  uint64_t v21 = a1 + 8 * v16;
  int v22 = *(const void **)(v21 + 928);
  if (v22 != aBlock)
  {
    unsigned int v23 = (void **)(v21 + 928);
    if (v22) {
      _Block_release(v22);
    }
    NSObject *v23 = _Block_copy(aBlock);
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

void C3DParticleSystemSetProperyControllers(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 400);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 400) = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    *(void *)(a1 + 400) = v13;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

void C3DParticleSystemSetParticleColorVariation(uint64_t a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      C3DParticleSystemGetRenderingMode_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  *(__n128 *)(a1 + 272) = a2;
  __C3DParticleSystemControllersDidChange(a1);
  *(_DWORD *)(a1 + 872) = -1;
  *(_WORD *)(a1 + 857) = 257;
  *(void *)(a1 + 904) = 0;
}

__n128 C3DParticleSystemGetOrientationDirection(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1[9];
}

void C3DParticleSystemSetOrientationDirection(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      C3DParticleSystemGetRenderingMode_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  a1[9] = a2;
}

float C3DParticleSystemGetLightEmissionRadiusFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 392);
}

void C3DParticleSystemSetLightEmissionRadiusFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 392) = a2;
}

__n128 C3DParticleSystemGetAcceleration(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1[10];
}

void C3DParticleSystemSetAcceleration(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      C3DParticleSystemGetRenderingMode_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  a1[10] = a2;
}

uint64_t C3DParticleSystemGetAffectedByGravity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 96);
}

void C3DParticleSystemSetAffectedByGravity(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 96) != a2)
  {
    *(unsigned char *)(a1 + 96) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

void C3DParticleSystemSetAffectedByPhysicsFields(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 97) != a2)
  {
    *(unsigned char *)(a1 + 97) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetBirthDirection(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 89);
}

void C3DParticleSystemSetBirthDirection(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 89) = a2;
}

uint64_t C3DParticleSystemGetBirthLocation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 88);
}

void C3DParticleSystemSetBirthLocation(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 88) = a2;
}

float C3DParticleSystemGetBirthRate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 64);
}

void C3DParticleSystemSetBirthRate(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 64) = a2;
}

float C3DParticleSystemGetBirthRateVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 68);
}

void C3DParticleSystemSetBirthRateVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 68) = a2;
}

uint64_t C3DParticleSystemGetBlackPassEnabled(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 105);
}

void C3DParticleSystemSetBlackPassEnabled(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 105) != a2)
  {
    *(unsigned char *)(a1 + 105) = a2;
    *(unsigned char *)(a1 + 858) = 1;
  }
}

uint64_t C3DParticleSystemGetBlendMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 90);
}

void C3DParticleSystemSetBlendMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 90) != a2)
  {
    *(unsigned char *)(a1 + 90) = a2;
    *(unsigned char *)(a1 + 858) = 1;
  }
}

uint64_t C3DParticleSystemGetColliderNodes(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 360);
}

void C3DParticleSystemSetDampingFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 380) = a2;
}

float C3DParticleSystemGetEmissionDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 108);
}

void C3DParticleSystemSetEmissionDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 108) = a2;
}

float C3DParticleSystemGetEmissionDurationVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 112);
}

void C3DParticleSystemSetEmissionDurationVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 112) = a2;
}

uint64_t C3DParticleSystemGetEmitterShape(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 80);
}

CFTypeRef C3DParticleSystemSetEmitterShape(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 80);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 80) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 80) = result;
  }
  return result;
}

__n128 C3DParticleSystemGetEmittingDirection(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1[8];
}

void C3DParticleSystemSetEmittingDirection(__n128 *a1, __n128 a2)
{
  if (!a1)
  {
    __n128 v12 = a2;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    a2 = v12;
    if (v4)
    {
      C3DParticleSystemGetRenderingMode_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      a2 = v12;
    }
  }
  a1[8] = a2;
}

float C3DParticleSystemGetFixedTimeStep(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 388);
}

void C3DParticleSystemSetFixedTimeStep(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 388) = a2;
}

float C3DParticleSystemGetFresnelExponent(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 396);
}

void C3DParticleSystemSetFresnelExponent(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 396) = a2;
}

float C3DParticleSystemGetIdleDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 116);
}

void C3DParticleSystemSetIdleDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 116) = a2;
}

float C3DParticleSystemGetIdleDurationVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 120);
}

void C3DParticleSystemSetIdleDurationVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 120) = a2;
}

uint64_t C3DParticleSystemGetImageSequenceAnimationMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 94);
}

void C3DParticleSystemSetImageSequenceAnimationMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 94) != a2)
  {
    *(unsigned char *)(a1 + 94) = a2;
    *(unsigned char *)(a1 + 858) = 1;
  }
}

uint64_t C3DParticleSystemGetImageSequenceColumnCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int16 *)(a1 + 304);
}

void C3DParticleSystemSetImageSequenceColumnCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int16 *)(a1 + 304) != a2)
  {
    HasTextureAnimatioint n = C3DParticleSystemHasTextureAnimation(a1);
    *(_WORD *)(a1 + 304) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
    if (HasTextureAnimation != C3DParticleSystemHasTextureAnimation(a1))
    {
      *(unsigned char *)(a1 + 858) = 1;
      *(unsigned char *)(a1 + 856) = 1;
    }
  }
}

float C3DParticleSystemGetImageSequenceFrameRate(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 316);
}

void C3DParticleSystemSetImageSequenceFrameRate(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 316) != a2)
  {
    *(float *)(a1 + 316) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetImageSequenceFrameRateVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 320);
}

void C3DParticleSystemSetImageSequenceFrameRateVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 320) != a2)
  {
    *(float *)(a1 + 320) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetImageSequenceInitialFrame(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 308);
}

void C3DParticleSystemSetImageSequenceInitialFrame(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 308) != a2)
  {
    *(float *)(a1 + 308) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetImageSequenceInitialFrameVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 312);
}

void C3DParticleSystemSetImageSequenceInitialFrameVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 312) != a2)
  {
    *(float *)(a1 + 312) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetImageSequenceRowCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int16 *)(a1 + 306);
}

void C3DParticleSystemSetImageSequenceRowCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int16 *)(a1 + 306) != a2)
  {
    HasTextureAnimatioint n = C3DParticleSystemHasTextureAnimation(a1);
    *(_WORD *)(a1 + 306) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
    if (HasTextureAnimation != C3DParticleSystemHasTextureAnimation(a1))
    {
      *(unsigned char *)(a1 + 858) = 1;
      *(unsigned char *)(a1 + 856) = 1;
    }
  }
}

uint64_t C3DParticleSystemGetIsLocal(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 95);
}

void C3DParticleSystemSetIsLocal(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 95) != a2)
  {
    *(unsigned char *)(a1 + 95) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetLightingEnabled(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 99);
}

void C3DParticleSystemSetLightingEnabled(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 99) != a2)
  {
    *(unsigned char *)(a1 + 99) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 904) = 0;
    *(unsigned char *)(a1 + 858) = 1;
    *(_WORD *)(a1 + 856) = 257;
  }
}

uint64_t C3DParticleSystemGetLoops(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 101);
}

void C3DParticleSystemSetLoops(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 101) != a2)
  {
    *(unsigned char *)(a1 + 101) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetOrientationMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 92);
}

void C3DParticleSystemSetOrientationMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 92) != a2)
  {
    *(unsigned char *)(a1 + 92) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleAngle(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 180);
}

void C3DParticleSystemSetParticleAngle(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 180) != a2)
  {
    *(float *)(a1 + 180) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleAngleVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 184);
}

void C3DParticleSystemSetParticleAngleVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 184) != a2)
  {
    *(float *)(a1 + 184) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleAngularVelocity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 196);
}

void C3DParticleSystemSetParticleAngularVelocity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 196) != a2)
  {
    *(float *)(a1 + 196) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleAngularVelocityVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 200);
}

void C3DParticleSystemSetParticleAngularVelocityVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 200) != a2)
  {
    *(float *)(a1 + 200) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleBounce(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 212);
}

void C3DParticleSystemSetParticleBounce(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 212) != a2)
  {
    *(float *)(a1 + 212) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleBounceVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 216);
}

void C3DParticleSystemSetParticleBounceVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 216) != a2)
  {
    *(float *)(a1 + 216) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleCharge(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 228);
}

void C3DParticleSystemSetParticleCharge(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 228) != a2)
  {
    *(float *)(a1 + 228) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleChargeVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 232);
}

void C3DParticleSystemSetParticleChargeVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 232) != a2)
  {
    *(float *)(a1 + 232) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

__n128 C3DParticleSystemGetParticleColorVariation(__n128 *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1[17];
}

uint64_t C3DParticleSystemGetParticleDiesOnCollision(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 104);
}

void C3DParticleSystemSetParticleDiesOnCollision(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 104) = a2;
}

float C3DParticleSystemGetParticleFriction(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 220);
}

void C3DParticleSystemSetParticleFriction(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 220) != a2)
  {
    *(float *)(a1 + 220) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleFrictionVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 224);
}

void C3DParticleSystemSetParticleFrictionVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 224) != a2)
  {
    *(float *)(a1 + 224) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleLifeSpan(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 204);
}

void C3DParticleSystemSetParticleLifeSpan(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 204) != a2)
  {
    *(float *)(a1 + 204) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleLifeSpanVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 208);
}

void C3DParticleSystemSetParticleLifeSpanVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 208) != a2)
  {
    *(float *)(a1 + 208) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleMass(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 372);
}

void C3DParticleSystemSetParticleMass(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 372) != a2)
  {
    *(float *)(a1 + 372) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

void C3DParticleSystemSetParticleMassVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 376) != a2)
  {
    *(float *)(a1 + 376) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleSize(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 288);
}

void C3DParticleSystemSetParticleSize(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 288) != a2)
  {
    *(float *)(a1 + 288) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleSizeVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 292);
}

void C3DParticleSystemSetParticleSizeVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 292) != a2)
  {
    *(float *)(a1 + 292) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleVelocity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 188);
}

void C3DParticleSystemSetParticleVelocity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 188) != a2)
  {
    *(float *)(a1 + 188) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetParticleVelocityVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 192);
}

void C3DParticleSystemSetParticleVelocityVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 192) != a2)
  {
    *(float *)(a1 + 192) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetPhysicsCollisionsEnabled(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 98);
}

void C3DParticleSystemSetPhysicsCollisionsEnabled(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 98) = a2;
}

void C3DParticleSystemSetRenderingMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 91) != a2)
  {
    *(unsigned char *)(a1 + 91) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetSeed(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 368);
}

void C3DParticleSystemSetSeed(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 368) = a2;
}

uint64_t C3DParticleSystemGetSoftParticlesEnabled(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 103);
}

void C3DParticleSystemSetSoftParticlesEnabled(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 103) != a2)
  {
    *(unsigned char *)(a1 + 103) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

uint64_t C3DParticleSystemGetSortingMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 93);
}

void C3DParticleSystemSetSortingMode(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 93) != a2)
  {
    *(unsigned char *)(a1 + 93) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(_WORD *)(a1 + 857) = 257;
    *(void *)(a1 + 904) = 0;
  }
}

float C3DParticleSystemGetSpeedFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 384);
}

void C3DParticleSystemSetSpeedFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 384) = a2;
}

float C3DParticleSystemGetSpreadingAngle(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 176);
}

void C3DParticleSystemSetSpreadingAngle(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 176) = a2;
}

float C3DParticleSystemGetStretchFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 248);
}

void C3DParticleSystemSetStretchFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 248) != a2)
  {
    *(float *)(a1 + 248) = a2;
    *(unsigned char *)(a1 + 858) = 1;
    *(unsigned char *)(a1 + 856) = 1;
  }
}

uint64_t C3DParticleSystemGetSystemSpawnedOnCollision(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 328);
}

CFTypeRef C3DParticleSystemSetSystemSpawnedOnCollision(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 328);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 328) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 328) = result;
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 912) = 0;
  }
  return result;
}

uint64_t C3DParticleSystemGetSystemSpawnedOnDying(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 336);
}

CFTypeRef C3DParticleSystemSetSystemSpawnedOnDying(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 336);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 336) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 336) = result;
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 912) = 0;
  }
  return result;
}

CFTypeRef C3DParticleSystemSetSystemSpawnedOnLiving(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 344);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 344) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 344) = result;
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 912) = 0;
  }
  return result;
}

float C3DParticleSystemGetWarmupDuration(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 72);
}

void C3DParticleSystemSetWarmupDuration(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 72) = a2;
}

uint64_t C3DParticleSystemGetWritesToDepthBuffer(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 106);
}

void C3DParticleSystemSetWritesToDepthBuffer(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 106) = a2;
}

float C3DParticleSystemGetParticleIntensity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 296);
}

void C3DParticleSystemSetParticleIntensity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 296) != a2)
  {
    *(float *)(a1 + 296) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(unsigned char *)(a1 + 858) = 1;
    *(void *)(a1 + 904) = 0;
    *(_WORD *)(a1 + 856) = 257;
  }
}

float C3DParticleSystemGetParticleIntensityVariation(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 300);
}

void C3DParticleSystemSetParticleIntensityVariation(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DParticleSystemGetRenderingMode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 300) != a2)
  {
    *(float *)(a1 + 300) = a2;
    __C3DParticleSystemControllersDidChange(a1);
    *(_DWORD *)(a1 + 872) = -1;
    *(unsigned char *)(a1 + 858) = 1;
    *(void *)(a1 + 904) = 0;
    *(_WORD *)(a1 + 856) = 257;
  }
}

uint64_t C3DParticleSystemGetControllers(uint64_t a1, _DWORD *a2)
{
  int v4 = *(_DWORD *)(a1 + 888);
  if (v4 == -1)
  {
    *(_DWORD *)(a1 + 888) = 0;
    CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 400);
    if (v5)
    {
      size_t v6 = 80 * CFDictionaryGetCount(v5);
      uint64_t v7 = malloc_type_malloc(v6, 0x1030040D754E354uLL);
      *(void *)(a1 + 880) = v7;
      bzero(v7, v6);
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 400), (CFDictionaryApplierFunction)__appendController, (void *)a1);
      int v4 = *(_DWORD *)(a1 + 888);
    }
    else
    {
      int v4 = 0;
    }
  }
  *a2 = v4;
  return *(void *)(a1 + 880);
}

void __appendController(const void *a1, CFDictionaryRef theDict, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 880);
  int v7 = *(_DWORD *)(a3 + 888);
  *(_DWORD *)(a3 + 888) = v7 + 1;
  uint64_t v8 = v6 + 80 * v7;
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"ControllerAnimation");
  *(void *)(v8 + 16) = Value;
  *(unsigned char *)(v8 + 48) = 1;
  uint64_t v10 = (unsigned char *)(v8 + 48);
  *(unsigned char *)(v8 + 24) = 0;
  uint64_t v11 = (unsigned char *)(v8 + 24);
  __n128 v12 = CFDictionaryGetValue(theDict, @"ControllerVariableMode");
  if (v12)
  {
    CFTypeRef v13 = v12;
    if (CFEqual(v12, @"ControllerVariableOverLife"))
    {
      unsigned char *v11 = 0;
    }
    else if (CFEqual(v13, @"ControllerVariableOverDistance"))
    {
      unsigned char *v11 = 1;
    }
    else if (CFEqual(v13, @"ControllerVariableOverOtherProperty"))
    {
      uint64_t v34 = CFDictionaryGetValue(theDict, @"ControllerVariableOverOtherProperty");
      unint64_t PropertyIndexAndStride = (unint64_t)C3DParticleSystemGetPropertyIndexAndStride(a3, v34);
      if ((PropertyIndexAndStride & 0xFFFF00000000) != 0)
      {
        unsigned char *v11 = 2;
        uint64_t v37 = v6 + 80 * v7;
        *(void *)(v37 + 26) = PropertyIndexAndStride;
        *(_WORD *)(v37 + 34) = v36;
      }
      else
      {
        long long v63 = scn_default_log();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          __appendController_cold_3((uint64_t)v34, v63, v56, v57, v58, v59, v60, v61);
        }
      }
    }
    else
    {
      uint64_t v62 = scn_default_log();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        __appendController_cold_2((uint64_t)v13, v62, v50, v51, v52, v53, v54, v55);
      }
    }
  }
  uint64_t v14 = v6 + 80 * v7;
  *(void *)(v14 + 40) = CFDictionaryGetValue(theDict, @"ControllerVariableOrigin");
  CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ControllerVariableScale");
  uint64_t v16 = (_DWORD *)(v14 + 68);
  if (v15) {
    CFNumberGetValue(v15, kCFNumberFloatType, v16);
  }
  else {
    _DWORD *v16 = 1065353216;
  }
  CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ControllerVariableBias");
  CFTypeRef v18 = (_DWORD *)(v6 + 80 * v7 + 72);
  if (v17) {
    CFNumberGetValue(v17, kCFNumberFloatType, v18);
  }
  else {
    _DWORD *v18 = 0;
  }
  unint64_t v19 = (unint64_t)C3DParticleSystemGetPropertyIndexAndStride(a3, a1);
  __int16 v21 = v20;
  if (CFEqual(a1, @"Color") && !*v11)
  {
    *(_WORD *)(a3 + 892) = *(_WORD *)(a3 + 888) - 1;
LABEL_23:
    *uint64_t v10 = 0;
    goto LABEL_24;
  }
  if (CFEqual(a1, @"Opacity") && !*v11)
  {
    *(_WORD *)(a3 + 894) = *(_WORD *)(a3 + 888) - 1;
    goto LABEL_23;
  }
  if ((v19 & 0xFFFF00000000) != 0)
  {
    *(void *)uint64_t v8 = v19;
    *(_WORD *)(v8 + 8) = v21;
  }
  else
  {
    int v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      __appendController_cold_1((uint64_t)a1, v22, v23, v24, v25, v26, v27, v28);
    }
    --*(_DWORD *)(a3 + 888);
  }
LABEL_24:
  if (*v10)
  {
    if (Value)
    {
      CFTypeID v29 = CFGetTypeID(Value);
      if (v29 == C3DKeyframedAnimationGetTypeID())
      {
        uint64_t Controller = C3DKeyframedAnimationGetController((uint64_t)Value);
        KeyCFIndex Count = C3DKeyframeControllerGetKeyCount(Controller);
        Valueint Type = C3DKeyframeControllerGetValueType(Controller);
        int DefaultInterpolationMode = C3DKeyframeControllerGetDefaultInterpolationMode(Controller);
        if (DefaultInterpolationMode)
        {
          if (DefaultInterpolationMode == 2) {
            KeyCount *= 8;
          }
        }
        else
        {
          KeyCount *= 2;
        }
        uint64_t v38 = v6 + 80 * v7;
        *(unsigned char *)(v38 + 49) = DefaultInterpolationMode != 1;
        *(unsigned char *)(v38 + 50) = C3DAnimationGetAdditive(*(void *)(v8 + 16));
        if (KeyCount <= 0xFF)
        {
          int v39 = KeyCount <= 2 ? 2 : KeyCount;
          uint64_t v40 = v6 + 80 * v7;
          *(_DWORD *)(v40 + 64) = v39;
          int v41 = (float *)(v40 + 64);
          *(v41 - 3) = (float)(v39 - 1);
          if (WORD2(v19))
          {
            char v42 = malloc_type_malloc(WORD2(v19) + WORD2(v19) * v39, 0x2A9BEDFBuLL);
            uint64_t v43 = v6 + 80 * v7;
            *(void *)(v43 + 56) = v42;
            uint64_t v44 = (void *)(v43 + 56);
            bzero(v42, WORD2(v19) + WORD2(v19) * *(_DWORD *)v41);
            if (*(_DWORD *)v41)
            {
              unsigned int v45 = 0;
              unint64_t v46 = 0;
              float v47 = 1.0 / (float)(*(_DWORD *)v41 - 1);
              float v48 = 0.0;
              do
              {
                C3DAnimationEvaluate((uint64_t)Value);
                if (ValueType == 9)
                {
                  uint64_t v49 = *v44 + v45;
                  *(void *)uint64_t v49 = 0;
                  *(_DWORD *)(v49 + 8) = 0;
                }
                float v48 = v47 + v48;
                ++v46;
                v45 += WORD2(v19);
              }
              while (v46 < *(unsigned int *)v41);
            }
            else
            {
              LODWORD(v46) = 0;
            }
            memcpy((void *)(*v44 + v46 * WORD2(v19)), (const void *)(*v44 + (v46 - 1) * WORD2(v19)), WORD2(v19));
          }
        }
      }
    }
  }
}

void C3DParticleSystemProcessAffectors(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v8 = *(_DWORD *)(a1 + 872);
  if (v8 == -1)
  {
    __C3DParticleSystemUpdateInternal(a1);
    int v8 = *(_DWORD *)(a1 + 872);
  }
  if (v8 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(a1 + 864) + v9;
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12)
      {
        uint64_t KeyPath = C3DAnimationGetKeyPath(v12);
        CFArrayRef OverrideMaterial = (const __CFArray *)C3DGeometryGetOverrideMaterial(*(void *)(*(void *)(a1 + 864) + v9 + 16));
        memset(v16, 0, sizeof(v16));
        C3DParticleSystemInstanceFillUserData(a1, a2, OverrideMaterial, (uint64_t)v16, (uint64_t)v15, 0);
        (*(void (**)(uint64_t, _OWORD *, unsigned char *, void, void, float))(KeyPath + 16))(KeyPath, v16, v15, a3, a4, *(float *)(a2 + 1028));
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))v11)(a2, a3, a4, *(void *)(v11 + 8));
      }
      ++v10;
      v9 += 24;
    }
    while (v10 < *(int *)(a1 + 872));
  }
}

void *C3DParticleSystemGetSimulateLifeCallback(uint64_t a1)
{
  CFTypeRef result = *(void **)(a1 + 912);
  if (!result)
  {
    if (C3DParticleSystemGetEventBlock(a1, 1u, 0))
    {
      CFTypeRef result = C3DParticleSystemInstanceSimulateLifeWithBlock;
    }
    else if (*(void *)(a1 + 336))
    {
      CFTypeRef result = C3DParticleSystemInstanceSimulateLifeAndSpawnWhenDying;
    }
    else
    {
      CFTypeRef result = C3DParticleSystemInstanceSimulateLife;
    }
    *(void *)(a1 + 912) = result;
  }
  return result;
}

uint64_t (*C3DParticleSystemGetEmissionCallback(uint64_t a1))()
{
  uint64_t v1 = *(uint64_t (**)())(a1 + 904);
  if (!v1)
  {
    int v2 = *(unsigned __int8 *)(a1 + 91);
    uint64_t v1 = (uint64_t (*)())C3DParticleEmitStandard;
    if (v2 == 3) {
      uint64_t v1 = C3DParticleEmitBeam;
    }
    if (v2 == 2) {
      uint64_t v1 = (uint64_t (*)())C3DParticleEmitTrail;
    }
    *(void *)(a1 + 904) = v1;
  }
  return v1;
}

const UInt8 *C3DParticleSystemGetColorRamp(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      -[SCNNode replaceObjectInParticleSystemsAtIndex:withObject:](v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(void *)(a1 + 920)) {
    return *(const UInt8 **)(a1 + 920);
  }
  ParticleColoruint64_t Controller = C3DParticleSystemGetParticleColorController(a1);
  ParticleOpacityuint64_t Controller = C3DParticleSystemGetParticleOpacityController(a1);
  CFTypeRef result = (const UInt8 *)C3DMalloc(0x400uLL);
  if (result)
  {
    CFTypeRef v13 = result;
    uint64_t v14 = 0;
    float v15 = 0.0;
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v32 = _Q0;
    do
    {
      if (ParticleColorController) {
        C3DAnimationEvaluate(ParticleColorController);
      }
      if (ParticleOpacityController) {
        C3DAnimationEvaluate(ParticleOpacityController);
      }
      float v15 = v15 + 0.0039216;
      float64x2_t v21 = vmaxnmq_f64(vcvtq_f64_f32((float32x2_t)0x3F8000003F800000), (float64x2_t)0);
      float32x2_t v22 = vcvt_f32_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v21, v32), (int8x16_t)v32, (int8x16_t)v21));
      double v23 = fmax(1.0, 0.0);
      if (v23 > 1.0) {
        double v23 = 1.0;
      }
      float v24 = v23;
      uint64_t v25 = (UInt8 *)&v13[v14];
      *uint64_t v25 = (int)((float)(1.0 * v22.f32[0]) * 255.0);
      v25[1] = (int)(vmuls_lane_f32(1.0, v22, 1) * 255.0);
      v25[2] = (int)((float)(1.0 * v24) * 255.0);
      v25[3] = (int)(1.0 * 255.0);
      v14 += 4;
    }
    while (v14 != 1024);
    CFDataRef v26 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v13, 1024, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
    uint64_t v27 = C3DImageCreateWithRawData(v26, 0x20u, 4, 0.00781250196);
    if (v27)
    {
      uint64_t v28 = (const void *)v27;
      uint64_t v29 = C3DFXSamplerCreate();
      *(void *)(a1 + 920) = v29;
      C3DFXSamplerSetImage(v29, v28);
      CFRelease(v28);
      uint64_t v30 = *(void *)(a1 + 920);
      BOOL v31 = (const void *)C3DTextureSamplerBilinearNoAnisotropy();
      C3DFXSamplerSetTextureSampler(v30, v31);
    }
    return *(const UInt8 **)(a1 + 920);
  }
  return result;
}

void __addPrimaryData(uint64_t a1, __CFDictionary *a2, int a3, const void *a4, __int16 a5, int a6, uint64_t a7, __int16 a8, char a9, char a10)
{
  uint64_t v10 = *(unsigned int *)(a1 + 384);
  if (v10 > 0x1F)
  {
    if ((__addPrimaryData_done & 1) == 0)
    {
      __addPrimaryData_done = 1;
      float64x2_t v21 = scn_default_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        __addPrimaryData_cold_1(v21);
      }
    }
  }
  else
  {
    __int16 v12 = a6;
    __int16 v15 = a3;
    *(_DWORD *)(a1 + 384) = v10 + 1;
    char v17 = -1;
    if (a3 != 1 && a10)
    {
      *(_DWORD *)(a1 + 384) = v10 + 2;
      *(_DWORD *)(a1 + 4 * (v10 + 1)) = a6;
      char v17 = v10 + 1;
    }
    if (a9) {
      int v18 = a6;
    }
    else {
      int v18 = 0;
    }
    if (!a9) {
      a7 = 0;
    }
    *(_DWORD *)(a1 + 4 * v10) = v18;
    *(void *)(a1 + 8 * v10 + 128) = a7;
    __int16 v20 = malloc_type_malloc(0xAuLL, 0x100004080B1215BuLL);
    *__int16 v20 = v10;
    v20[1] = v17;
    *((_WORD *)v20 + 1) = a5;
    *((_WORD *)v20 + 2) = v12;
    *((_WORD *)v20 + 3) = a8;
    *((_WORD *)v20 + 4) = v15;
    CFDictionarySetValue(a2, a4, v20);
  }
}

void __addSecondaryData(uint64_t a1, __CFDictionary *a2, const void *a3, __int16 a4, int a5, uint64_t a6, __int16 a7)
{
  unsigned int v7 = *(_DWORD *)(a1 + 384);
  if (v7 > 0x1F)
  {
    if ((__addSecondaryData_done & 1) == 0)
    {
      __addSecondaryData_done = 1;
      __int16 v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        __addPrimaryData_cold_1(v15);
      }
    }
  }
  else
  {
    __int16 v9 = a5;
    unsigned int v13 = v7 - 1;
    *(_DWORD *)(a1 + 4 * v13) = a5;
    *(void *)(a1 + 8 * v13 + 128) = a6;
    uint64_t v14 = malloc_type_malloc(0xAuLL, 0x100004080B1215BuLL);
    *uint64_t v14 = v13;
    v14[1] = -1;
    *((_WORD *)v14 + 1) = a4;
    *((_WORD *)v14 + 2) = v9;
    *((_WORD *)v14 + 3) = a7;
    CFDictionarySetValue(a2, a3, v14);
  }
}

BOOL __semanticHasVariation(__n128 *a1, int a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 1:
      return result;
    case 6:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleMassVariation((uint64_t)a1);
      goto LABEL_9;
    case 7:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleSizeVariation((uint64_t)a1);
      goto LABEL_9;
    case 8:
      return vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)C3DParticleSystemGetParticleColorVariation(a1)))) >> 31;
    case 10:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleFrictionVariation((uint64_t)a1);
      goto LABEL_9;
    case 11:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleBounceVariation((uint64_t)a1);
      goto LABEL_9;
    case 12:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleChargeVariation((uint64_t)a1);
      goto LABEL_9;
    case 20:
      ParticleMassVariatioint n = C3DParticleSystemGetParticleIntensityVariation((uint64_t)a1);
LABEL_9:
      BOOL result = ParticleMassVariation > 0.0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

CFDictionaryRef __semanticIsUsedByController(uint64_t a1, unsigned int a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 400);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, *(&s_semanticsDesc + 3 * a2));
    if (result)
    {
      if ((a2 & 0xFFFFFFFE) == 8)
      {
        CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"ControllerVariableMode");
        if (result) {
          return (const __CFDictionary *)(CFEqual(result, @"ControllerVariableOverLife") == 0);
        }
      }
      else
      {
        return (const __CFDictionary *)1;
      }
    }
  }
  return result;
}

BOOL __semanticIsUsedByEventBlock(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = 0;
  uint64_t v4 = (CFTypeRef *)(&s_semanticsDesc + 3 * a2);
  BOOL v5 = 1;
  while (1)
  {
    CFArrayRef theArray = 0;
    if (C3DParticleSystemGetEventBlock(a1, v3, &theArray))
    {
      if (theArray)
      {
        CFIndex Count = CFArrayGetCount(theArray);
        if (Count >= 1) {
          break;
        }
      }
    }
LABEL_8:
    BOOL v5 = v3++ < 2;
    if (v3 == 3) {
      return 0;
    }
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  while (1)
  {
    ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v8);
    if (CFEqual(ValueAtIndex, *v4)) {
      return v5;
    }
    if (v7 == ++v8) {
      goto LABEL_8;
    }
  }
}

void __addSemanticData(__n128 *a1, __CFDictionary *a2, unsigned int a3, char a4)
{
  HasVariatioint n = __semanticHasVariation(a1, a3);
  unsigned int v9 = __semanticIsUsedByController((uint64_t)a1, a3);
  IsUsedByEventBlocCFIndex k = __semanticIsUsedByEventBlock((uint64_t)a1, a3);
  if ((a4 & 1) != 0 || HasVariation || v9) {
    __addPrimaryData((uint64_t)&a1[26], a2, a3, *(&s_semanticsDesc + 3 * a3), *((unsigned __int8 *)&s_semanticsDesc + 24 * a3 + 8), *((unsigned __int8 *)&s_semanticsDesc + 24 * a3 + 9), (uint64_t)*(&s_semanticsDesc + 3 * a3 + 2), 0, a4 | IsUsedByEventBlock | HasVariation, v9);
  }
}

uint64_t C3DParticleSystemGetParticleLayout(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 857)) {
    return a1 + 416;
  }
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  __releaseProperties(a1);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0);
  __addSemanticData((__n128 *)a1, Mutable, 0, 1);
  __addSecondaryData(a1 + 416, Mutable, @"Angle", 1, 16, (uint64_t)C3DParticleInitPositionAndVelocity, 12);
  __addSemanticData((__n128 *)a1, Mutable, 1u, 1);
  __addSecondaryData(a1 + 416, Mutable, @"AngularVelocity", 1, 16, (uint64_t)C3DParticleInitDummy, 12);
  if (C3DParticleSystemGetParticleLifeSpanVariation(a1) <= 0.0)
  {
    __addSemanticData((__n128 *)a1, Mutable, 2u, 1);
  }
  else
  {
    __addPrimaryData(a1 + 416, Mutable, 2, @"Life", 1, 4, (uint64_t)C3DParticleInitLifeWithVariation, 0, 1, 0);
    __addPrimaryData(a1 + 416, Mutable, 3, @"InvLifeSpan", 1, 4, (uint64_t)C3DParticleInitDummy, 0, 1, 0);
  }
  __addSemanticData((__n128 *)a1, Mutable, 7u, 0);
  __addSemanticData((__n128 *)a1, Mutable, 0x14u, 0);
  __addSemanticData((__n128 *)a1, Mutable, 0xBu, 0);
  __addSemanticData((__n128 *)a1, Mutable, 0xAu, 0);
  __addSemanticData((__n128 *)a1, Mutable, 0xCu, 0);
  char v4 = C3DParticleSystemGetOrientationMode(a1) == 2;
  __addSemanticData((__n128 *)a1, Mutable, 0xDu, v4);
  if (__semanticIsUsedByController(a1, 9u))
  {
    int v5 = vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)C3DParticleSystemGetParticleColorVariation((__n128 *)a1))));
    IsUsedByEventBlocCFIndex k = __semanticIsUsedByEventBlock(a1, 8u);
    char v7 = v5 < 0 || IsUsedByEventBlock;
    char v8 = __semanticIsUsedByController(a1, 8u);
    __addPrimaryData(a1 + 416, Mutable, 8, @"Color", 4, 16, (uint64_t)C3DParticleInitColor, 0, v7, v8);
    __addSecondaryData(a1 + 416, Mutable, @"Opacity", 1, 16, (uint64_t)C3DParticleInitColor, 12);
  }
  else
  {
    __addSemanticData((__n128 *)a1, Mutable, 8u, 0);
  }
  __addSemanticData((__n128 *)a1, Mutable, 6u, 0);
  HasTextureAnimatioint n = C3DParticleSystemHasTextureAnimation(a1);
  __addSemanticData((__n128 *)a1, Mutable, 0xEu, HasTextureAnimation);
  __addSemanticData((__n128 *)a1, Mutable, 0xFu, 0);
  uint64_t v10 = C3DParticleSystemGetColliderNodes(a1) != 0;
  int v11 = *(unsigned __int8 *)(a1 + 91);
  if (v11 == 3 || v11 == 2) {
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 93))
  {
    if (*(unsigned __int8 *)(a1 + 93) - 3 > 1)
    {
      uint64_t v10 = 4;
      goto LABEL_16;
    }
LABEL_15:
    __addSemanticData((__n128 *)a1, Mutable, 4u, 1);
LABEL_16:
    __addSemanticData((__n128 *)a1, Mutable, 5u, 1);
  }
  EventBlocCFIndex k = C3DParticleSystemGetEventBlock(a1, 2u, 0);
  if (EventBlock | C3DParticleSystemGetEventBlock(a1, 1u, 0)) {
    __addSemanticData((__n128 *)a1, Mutable, 0x11u, 1);
  }
  CFArrayRef theArray = 0;
  if (C3DParticleSystemGetEventBlock(a1, 2u, &theArray))
  {
    if (theArray)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        CFIndex v14 = Count;
        CFIndex v15 = 0;
        while (1)
        {
          ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v15);
          if (CFEqual(ValueAtIndex, @"ContactPoint")) {
            break;
          }
          if (CFEqual(ValueAtIndex, @"ContactNormal"))
          {
            unsigned int v17 = 19;
            goto LABEL_27;
          }
LABEL_28:
          if (v14 == ++v15) {
            goto LABEL_29;
          }
        }
        unsigned int v17 = 18;
LABEL_27:
        __addSemanticData((__n128 *)a1, Mutable, v17, 1);
        goto LABEL_28;
      }
    }
  }
LABEL_29:
  if (v10) {
    __addPrimaryData(a1 + 416, Mutable, 16, @"TempData", 0, v10, 0, 0, 1, 0);
  }
  *(void *)(a1 + 408) = CFDictionaryCreateCopy(v2, Mutable);
  CFRelease(Mutable);
  uint64_t v18 = 0;
  unint64_t v19 = (unsigned char *)(a1 + 804);
  do
  {
    CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 408), *(__CFString **)((char *)&s_semanticsDesc + v18));
    if (Value)
    {
      *unint64_t v19 = *Value;
      int v21 = Value[1];
      if (v21 == 255) {
        LOBYTE(v21) = *Value;
      }
    }
    else
    {
      LOBYTE(v21) = -1;
      *unint64_t v19 = -1;
    }
    v19[21] = v21;
    ++v19;
    v18 += 24;
  }
  while (v18 != 504);
  *(unsigned char *)(a1 + 857) = 0;
  return a1 + 416;
}

void __releaseProperties(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 408);
  if (v2)
  {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)__freeProperty, 0);
    unint64_t v3 = *(const void **)(a1 + 408);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 408) = 0;
    }
  }
}

unint64_t C3DParticleSystemGetMaterial(__n128 *a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6)
{
  char v9 = a3;
  if (a1[53].n128_u8[10] || a1[53].n128_u8[11] != a3 || a1[53].n128_u8[12] != a5)
  {
    a1[53].n128_u8[12] = a5;
    a1[53].n128_u8[10] = 0;
    a1[53].n128_u8[11] = a3;
    if (!a1[53].n128_u64[0])
    {
      uint64_t v12 = C3DMaterialCreate();
      a1[53].n128_u64[0] = v12;
      C3DMaterialSetDoubleSided(v12, 1);
      C3DMaterialSetEnableReadFromDepthBuffer(a1[53].n128_i64[0], 1);
      uint64_t v13 = a1[53].n128_i64[0];
      int WritesToDepthBuffer = C3DParticleSystemGetWritesToDepthBuffer((uint64_t)a1);
      C3DMaterialSetEnableWriteInDepthBuffer(v13, WritesToDepthBuffer);
    }
    CFIndex v15 = C3DParticleManagerComputeTechniqueForSystem(a2, a1, v9, a4, a5, a6);
    C3DMaterialSetTechnique(a1[53].n128_i64[0], v15);
  }
  return a1[53].n128_u64[0];
}

const void *C3DParticleSystemGetPropertyIndexAndStride(uint64_t a1, const void *a2)
{
  C3DParticleSystemGetParticleLayout(a1);
  CFDictionaryRef result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 408), a2);
  if (result) {
    return *(const void **)result;
  }
  return result;
}

void C3DParticleSystemAddModifier(uint64_t a1, void *value)
{
  CFDictionaryRef Mutable = *(__CFArray **)(a1 + 896);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
    *(void *)(a1 + 896) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
  *(_DWORD *)(a1 + 872) = -1;
  *(void *)(a1 + 912) = 0;
}

void C3DParticleSystemRemoveModifier(uint64_t a1, int a2)
{
  CFArrayRef v3 = *(const __CFArray **)(a1 + 896);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      do
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 896), v7);
        if (C3DParticleModifierGetStage((uint64_t)ValueAtIndex) == a2)
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 896), v7);
          --v6;
        }
        else
        {
          ++v7;
        }
      }
      while (v7 < v6);
    }
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 912) = 0;
  }
}

void C3DParticleSystemRemoveAllModifiers(uint64_t a1)
{
  CFDictionaryRef v2 = *(__CFArray **)(a1 + 896);
  if (v2)
  {
    CFArrayRemoveAllValues(v2);
    *(_DWORD *)(a1 + 872) = -1;
    *(void *)(a1 + 912) = 0;
  }
}

uint64_t C3DParticleSystemHasFogSupport(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 859);
}

uint64_t C3DParticleSystemHasCubeMapTexture(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 240);
  if (result) {
    return C3DImageIsCubeMap(result);
  }
  return result;
}

uint64_t C3DParticleSystemGetConstantDataPtrForSemantic(uint64_t a1, uint64_t a2)
{
  switch((int)a2)
  {
    case 6:
      uint64_t result = a1 + 372;
      break;
    case 7:
      uint64_t result = a1 + 288;
      break;
    case 8:
      uint64_t result = a1 + 256;
      break;
    case 9:
      uint64_t result = a1 + 268;
      break;
    case 10:
      uint64_t result = a1 + 220;
      break;
    case 11:
      uint64_t result = a1 + 212;
      break;
    case 12:
      uint64_t result = a1 + 228;
      break;
    case 14:
      uint64_t result = a1 + 308;
      break;
    case 15:
      uint64_t result = a1 + 316;
      break;
    case 20:
      uint64_t result = a1 + 296;
      break;
    default:
      char v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        C3DParticleSystemGetConstantDataPtrForSemantic_cold_1(a2, v4, v5, v6, v7, v8, v9, v10);
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

void _C3DParticleSystemCFFinalize(uint64_t a1)
{
  CFDictionaryRef v2 = *(const void **)(a1 + 240);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 240) = 0;
  }
  CFArrayRef v3 = *(const void **)(a1 + 352);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 352) = 0;
  }
  char v4 = *(const void **)(a1 + 920);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 920) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 848);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 848) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 80);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 360);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 360) = 0;
  }
  uint64_t v8 = *(const void **)(a1 + 328);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 328) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 336);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 336) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 344);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 344) = 0;
  }
  __releaseProperties(a1);
  for (uint64_t i = 0; i != 24; i += 8)
  {
    uint64_t v12 = a1 + i;
    uint64_t v13 = *(const void **)(a1 + i + 928);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(v12 + 928) = 0;
    }
    CFIndex v14 = *(const void **)(v12 + 952);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(v12 + 952) = 0;
    }
  }
  CFIndex v15 = *(const void **)(a1 + 896);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 896) = 0;
  }
  free(*(void **)(a1 + 864));
  *(void *)(a1 + 864) = 0;
  __DestroyControllers(a1);
  uint64_t v16 = *(const void **)(a1 + 400);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 400) = 0;
  }
}

CFStringRef _C3DParticleSystemCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleSystemRef>");
}

CFStringRef _C3DParticleSystemCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleSystemRef>");
}

void _C3DParticleSystemSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 248) == __dst)
  {
    float v7 = *__src;
    C3DParticleSystemSetStretchFactor(a1, v7);
  }
  else
  {
    uint64_t v6 = (void *)(a1 + 256);
    memcpy(__dst, __src, __n);
    if (v6 != __dst)
    {
      __C3DParticleSystemControllersDidChange(a1);
      *(_DWORD *)(a1 + 872) = -1;
      *(_WORD *)(a1 + 857) = 257;
      *(void *)(a1 + 904) = 0;
    }
  }
}

void __freeProperty(int a1, void *a2)
{
}

__CFString *C3DLibraryGetStringForType(uint64_t a1)
{
  if (C3DGeometryGetTypeID() == a1 || C3DParametricGeometryGetTypeID() == a1 || C3DFloorGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DGeometryTypeKey;
    return *v2;
  }
  if (C3DMeshGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DMeshTypeKey;
    return *v2;
  }
  if (C3DAnimationGroupGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DAnimationGroupTypeKey;
    return *v2;
  }
  if (C3DMaterialGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DMaterialTypeKey;
    return *v2;
  }
  if (C3DImageGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DImageTypeKey;
    return *v2;
  }
  if (C3DMeshElementGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DMeshElementTypeKey;
    return *v2;
  }
  if (C3DNodeGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DNodeTypeKey;
    return *v2;
  }
  if (C3DCameraGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DCameraTypeKey;
    return *v2;
  }
  if (C3DLightGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DLightTypeKey;
    return *v2;
  }
  if (C3DSkinGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DSkinTypeKey;
    return *v2;
  }
  if (C3DMeshSourceGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DMeshSourceTypeKey;
    return *v2;
  }
  if (C3DGenericSourceGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DGenericSourceTypeKey;
    return *v2;
  }
  if (C3DMorphGetTypeID() == a1)
  {
    CFDictionaryRef v2 = kC3DMorphTypeKey;
    return *v2;
  }
  if (C3DSceneGetTypeID() == a1) {
    return @"scene";
  }
  if (C3DKeyframedAnimationGetTypeID() == a1) {
    return @"keyframedAnimations";
  }
  return 0;
}

uint64_t C3DLibraryGetTypeForString(const __CFString *a1)
{
  if (CFStringCompare(a1, @"mesh", 0))
  {
    if (CFStringCompare(a1, @"geometry", 0))
    {
      if (CFStringCompare(a1, @"animation", 0))
      {
        if (CFStringCompare(a1, @"material", 0))
        {
          if (CFStringCompare(a1, @"image", 0))
          {
            if (CFStringCompare(a1, @"geometryElement", 0))
            {
              if (CFStringCompare(a1, @"node", 0))
              {
                if (CFStringCompare(a1, @"camera", 0))
                {
                  if (CFStringCompare(a1, @"light", 0))
                  {
                    if (CFStringCompare(a1, @"skin", 0))
                    {
                      if (CFStringCompare(a1, @"morph", 0))
                      {
                        if (CFStringCompare(a1, @"geometrySource", 0))
                        {
                          if (CFStringCompare(a1, @"genericSource", 0))
                          {
                            return 0;
                          }
                          else
                          {
                            return C3DGenericSourceGetTypeID();
                          }
                        }
                        else
                        {
                          return C3DMeshSourceGetTypeID();
                        }
                      }
                      else
                      {
                        return C3DMorphGetTypeID();
                      }
                    }
                    else
                    {
                      return C3DSkinGetTypeID();
                    }
                  }
                  else
                  {
                    return C3DLightGetTypeID();
                  }
                }
                else
                {
                  return C3DCameraGetTypeID();
                }
              }
              else
              {
                return C3DNodeGetTypeID();
              }
            }
            else
            {
              return C3DMeshElementGetTypeID();
            }
          }
          else
          {
            return C3DImageGetTypeID();
          }
        }
        else
        {
          return C3DMaterialGetTypeID();
        }
      }
      else
      {
        return C3DAnimationGroupGetTypeID();
      }
    }
    else
    {
      return C3DMeshGetTypeID();
    }
  }
  else
  {
    return C3DGeometryGetTypeID();
  }
}

void _C3DLibrarySubStorageCFFinalize(void *a1)
{
  CFDictionaryRef v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  CFArrayRef v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  char v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
}

CFStringRef _C3DLibrarySubStorageCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLibrarySubStorage>");
}

CFStringRef _C3DLibrarySubStorageCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLibrarySubStorage>");
}

uint64_t __C3DLibrarySubStorageGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DLibrarySubStorageGetTypeID_typeuint64_t ID = result;
  return result;
}

__CFString *C3DLibraryCreateEntryIdentifier(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"%d", a1);
  StringForint Type = C3DLibraryGetStringForType(a2);
  if (StringForType)
  {
    CFStringAppend(Mutable, StringForType);
    CFStringAppend(Mutable, @"/");
    CFStringAppend(Mutable, v5);
    CFRelease(v5);
  }
  else
  {
    CFRelease(v5);
    CFRelease(Mutable);
    float v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      C3DLibraryCreateEntryIdentifier_cold_1(v7);
    }
    return 0;
  }
  return Mutable;
}

uint64_t C3DLibraryGetRemappedID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !*(void *)(a1 + 48)) {
    return 0;
  }
  int v4 = a3;
  int v5 = a2;
  EntryIdentifier = C3DLibraryCreateEntryIdentifier(a2, a3);
  if (!EntryIdentifier)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      C3DLibraryGetRemappedID_cold_1(v5, v4, v10);
    }
    return 0;
  }
  float v7 = EntryIdentifier;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), EntryIdentifier);
  if (Value)
  {
    int valuePtr = 0;
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    uint64_t v9 = valuePtr;
  }
  else
  {
    int v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      C3DLibraryGetRemappedID_cold_2((uint64_t)v7, v11, v12, v13, v14, v15, v16, v17);
    }
    uint64_t v9 = 0;
  }
  CFRelease(v7);
  return v9;
}

double __C3DLibraryGetTypeID_block_invoke()
{
  C3DLibraryGetTypeID_typeuint64_t ID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DLibraryContextClassSerializable;
  unk_26B466E08 = kC3DC3DLibraryContextClassSerializable;
  unk_26B466E18 = *(_OWORD *)&off_26BF71330;
  return result;
}

uint64_t C3DLibraryCreate()
{
  if (C3DLibraryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DLibraryGetTypeID_onceToken, &__block_literal_global_11_0);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DLibraryGetTypeID_typeID, 0x30uLL);
  if (Instance) {
    *(void *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  }
  return Instance;
}

void *C3DLibraryGetSubStorage(uint64_t a1, void *key)
{
  if (!a1)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DSceneFinalizeDeserialization_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef v12 = *(const __CFDictionary **)(a1 + 16);
  CFNumberRef Value = CFDictionaryGetValue(v12, key);
  if (!Value)
  {
    if (C3DLibrarySubStorageGetTypeID_onceToken != -1) {
      dispatch_once(&C3DLibrarySubStorageGetTypeID_onceToken, &__block_literal_global_79);
    }
    CFNumberRef Value = (void *)C3DTypeCreateInstance_(C3DLibrarySubStorageGetTypeID_typeID, 0x28uLL);
    if (Value)
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      uint64_t v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
      Value[2] = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
      Value[3] = CFDictionaryCreateMutable(v14, 0, MEMORY[0x263EFFF88], 0);
      Value[4] = CFDictionaryCreateMutable(v14, 0, 0, v15);
      Value[5] = 1;
      Value[6] = key;
    }
    CFDictionaryAddValue(v12, key, Value);
    CFRelease(Value);
  }
  return Value;
}

char *C3DLibraryAddEntry(uint64_t a1, const void *a2)
{
  int v4 = _C3DLibraryAddEntry(a1, a2);
  uint64_t ID = (void *)C3DEntityGetID((uint64_t)a2);
  if (ID) {
    C3DLibraryTrackID(a1, ID, v4, a2);
  }
  return v4;
}

char *_C3DLibraryAddEntry(uint64_t a1, CFTypeRef cf)
{
  int v4 = (void *)CFGetTypeID(cf);
  SubStorage = C3DLibraryGetSubStorage(a1, v4);
  if (CFDictionaryGetValue((CFDictionaryRef)SubStorage[3], cf)) {
    return (char *)CFDictionaryGetValue((CFDictionaryRef)SubStorage[3], cf);
  }
  uint64_t v6 = (char *)SubStorage[5];
  SubStorage[5] = v6 + 1;
  CFDictionaryAddValue((CFMutableDictionaryRef)SubStorage[2], v6, cf);
  CFDictionaryAddValue((CFMutableDictionaryRef)SubStorage[3], cf, v6);
  return v6;
}

void C3DLibraryTrackID(uint64_t a1, void *key, const void *a3, const void *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DSceneFinalizeDeserialization_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DLibraryTrackID_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 40);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    *(void *)(a1 + 40) = Mutable;
  }
  if (!CFDictionaryGetValue(Mutable, key))
  {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), key, a4);
    if (CFTypeIsC3DEntity(a4)) {
      C3DEntitySetID((uint64_t)a4, key);
    }
    uint64_t v25 = (void *)CFGetTypeID(a4);
    SubStorage = (__CFDictionary *)C3DLibraryGetSubStorage(a1, v25);
    if (SubStorage) {
      SubStorage = (__CFDictionary *)*((void *)SubStorage + 4);
    }
    CFDictionaryAddValue(SubStorage, a3, key);
  }
}

CFDictionaryRef *C3DLibraryGetEntryID(uint64_t a1, CFTypeRef cf)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 16);
  int v4 = (const void *)CFGetTypeID(cf);
  double result = (CFDictionaryRef *)CFDictionaryGetValue(v3, v4);
  if (result) {
    return (CFDictionaryRef *)CFDictionaryGetValue(result[3], cf);
  }
  return result;
}

void *C3DLibraryGetEntry(uint64_t a1, void *key, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DSceneFinalizeDeserialization_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  double result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (result)
  {
    uint64_t v15 = (uint64_t)result;
    if (!result[2])
    {
      uint64_t v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        C3DLibraryGetEntry_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    return CFDictionaryGetValue(*(CFDictionaryRef *)(v15 + 16), a3);
  }
  return result;
}

const void **C3DLibraryCopyEntriesWithKind(uint64_t a1, void *key, CFIndex *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DSceneFinalizeDeserialization_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFNumberRef Value = (CFDictionaryRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value && (CFDictionaryRef v15 = Value[2]) != 0)
  {
    CFIndex Count = CFDictionaryGetCount(Value[2]);
    uint64_t v17 = (const void **)C3DMalloc(8 * Count);
    CFDictionaryGetKeysAndValues(v15, 0, v17);
  }
  else
  {
    CFIndex Count = 0;
    uint64_t v17 = 0;
  }
  *a3 = Count;
  return v17;
}

const void **C3DLibraryCopyIDsWithKind(uint64_t a1, void *a2, CFIndex *a3)
{
  SubStorage = C3DLibraryGetSubStorage(a1, a2);
  if (SubStorage && (CFDictionaryRef v5 = (const __CFDictionary *)SubStorage[4]) != 0)
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)SubStorage[4]);
    *a3 = Count;
    uint64_t v7 = (const void **)C3DMalloc(8 * Count);
    CFDictionaryGetKeysAndValues(v5, 0, v7);
  }
  else
  {
    uint64_t v7 = 0;
    *a3 = 0;
  }
  return v7;
}

CFDictionaryRef C3DLibraryGetEntryWithUniqueID(uint64_t a1, void *key)
{
  if (!a1 && (int v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DLibraryGetEntryWithUniqueID_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DLibraryGetEntryWithUniqueID_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 32);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

CFDictionaryRef C3DLibraryGetEntryWithDocumentID(uint64_t a1, void *key)
{
  if (!a1 && (int v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DSceneFinalizeDeserialization_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DLibraryGetEntryWithDocumentID_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 40);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

void *C3DLibraryGetMemoryUsageForKind(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  CFDictionaryRef result = C3DLibraryGetSubStorage(a1, a2);
  if (result)
  {
    context[0] = &v7;
    context[1] = a2;
    context[2] = a1;
    CFDictionaryRef v5 = (const __CFDictionary *)result[2];
    CFIndex Count = CFDictionaryGetCount(v5);
    CFTypeRef cf = CFSetCreateMutable(0, Count, 0);
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)_getMemoryUsage, context);
    CFRelease(cf);
    return (void *)v7;
  }
  return result;
}

void _getMemoryUsage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void context[3] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(unint64_t **)a3;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v7 = *(void *)(a3 + 16);
  if (C3DImageGetTypeID() == v5)
  {
    double Size = C3DImageGetSize(a2);
    if (C3DImageHasTextureRawData(a2))
    {
      CFDataRef Data = (const __CFData *)C3DImageGetData(a2);
      if (!Data) {
        return;
      }
      CFIndex v9 = *v6 + CFDataGetLength(Data);
      goto LABEL_23;
    }
    __int16 v28 = 0;
    uint64_t TypeID = (void *)C3DMaterialGetTypeID();
    SubStorage = C3DLibraryGetSubStorage(v7, TypeID);
    if (SubStorage)
    {
      context[0] = (char *)&v28 + 1;
      context[1] = &v28;
      context[2] = a2;
      CFDictionaryApplyFunction((CFDictionaryRef)SubStorage[2], (CFDictionaryApplierFunction)_fillImageSamplerMask, context);
      if (HIBYTE(v28))
      {
        int v26 = C3DMakePowerOfTwo((int)*(float *)&Size);
        *v6 += (int)(4 * v26 * C3DMakePowerOfTwo((int)*((float *)&Size + 1)));
      }
      if ((_BYTE)v28)
      {
        CFIndex v9 = (unint64_t)vmlas_n_f32((float)*v6, 4.0, vmul_lane_f32(*(float32x2_t *)&Size, *(float32x2_t *)&Size, 1).f32[0]);
LABEL_23:
        *uint64_t v6 = v9;
      }
    }
  }
  else if (C3DGeometryGetTypeID() == v5)
  {
    uint64_t Mesh = (const void *)C3DGeometryGetMesh(a2);
    uint64_t v11 = *(__CFSet **)(a3 + 24);
    if (!CFSetContainsValue(v11, Mesh))
    {
      CFSetAddValue(v11, Mesh);
      CFArrayRef v12 = C3DMeshCopyAllSources((uint64_t)Mesh, 1);
      if (v12)
      {
        CFArrayRef v13 = v12;
        CFIndex Count = CFArrayGetCount(v12);
        if (Count >= 1)
        {
          CFIndex v15 = Count;
          for (CFIndex i = 0; i != v15; ++i)
          {
            ValueAtuint64_t Index = CFArrayGetValueAtIndex(v13, i);
            uint64_t Accessor = C3DMeshSourceGetAccessor(ValueAtIndex);
            *v6 += C3DSourceAccessorGetLength(Accessor);
          }
        }
        CFRelease(v13);
      }
      ElementsCFIndex Count = C3DMeshGetElementsCount((uint64_t)Mesh);
      if ((uint64_t)ElementsCount >= 1)
      {
        CFArrayRef v20 = ElementsCount;
        for (CFIndex j = 0; (const __CFArray *)j != v20; ++j)
        {
          ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)Mesh, j, 1);
          LODWORD(context[0]) = 0;
          CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, context);
          if (Indexes) {
            *v6 += CFDataGetLength(Indexes);
          }
        }
      }
    }
  }
}

void C3DLibraryApplyEntriesWithType(uint64_t a1, const void *a2, void *a3)
{
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  if (Value)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)Value + 2);
    if (v5)
    {
      CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)__applyBlock, a3);
    }
  }
}

uint64_t __applyBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

CFMutableArrayRef C3DLibraryCopyKinds(uint64_t a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DSceneFinalizeDeserialization_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRef v10 = *(const __CFDictionary **)(a1 + 16);
  if (!v10) {
    return 0;
  }
  CFIndex Count = CFDictionaryGetCount(v10);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x263EFFF70]);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)_getKinds, Mutable);
  return Mutable;
}

void _getKinds(int a1, uint64_t a2, __CFArray *a3)
{
  int valuePtr = a1;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFArrayAppendValue(a3, v4);
  CFRelease(v4);
}

void *C3DLibraryFillWithContentOfScene(uint64_t a1, const void *a2, uint64_t a3)
{
  return C3DFillLibraryForSerialization(a2, a1, a3);
}

void _C3DLibraryCFFinalize(void *a1)
{
  CFDictionaryRef v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[6];
  if (v3)
  {
    CFRelease(v3);
    a1[6] = 0;
  }
  CFNumberRef v4 = (const void *)a1[7];
  if (v4)
  {
    CFRelease(v4);
    a1[7] = 0;
  }
  uint64_t v5 = (const void *)a1[3];
  if (v5)
  {
    CFRelease(v5);
    a1[3] = 0;
  }
  uint64_t v6 = (const void *)a1[4];
  if (v6)
  {
    CFRelease(v6);
    a1[4] = 0;
  }
  uint64_t v7 = (const void *)a1[5];
  if (v7)
  {
    CFRelease(v7);
    a1[5] = 0;
  }
}

CFStringRef _C3DLibraryCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLibrary>");
}

CFStringRef _C3DLibraryCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DLibrary>");
}

BOOL _C3DLibraryInitWithPropertyList(void *a1, CFDictionaryRef theDict, const __CFDictionary *a3, uint64_t a4)
{
  uint64_t v7 = a1;
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (!theDict)
    {
LABEL_4:
      uint64_t v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
  }
  else if (!theDict)
  {
    goto LABEL_4;
  }
  CFNumberRef Value = CFDictionaryGetValue(theDict, @"libraryStorage");
  uint64_t v25 = (const void *)v7[3];
  if (v25 != Value)
  {
    if (v25)
    {
      CFRelease(v25);
      void v7[3] = 0;
    }
    if (Value) {
      CFTypeRef v26 = CFRetain(Value);
    }
    else {
      CFTypeRef v26 = 0;
    }
    void v7[3] = v26;
  }
  uint64_t v27 = (const void *)v7[6];
  if (v27)
  {
    CFRelease(v27);
    v7[6] = 0;
  }
  CFAllocatorRef v28 = CFGetAllocator(v7);
  v7[6] = CFDictionaryCreateMutable(v28, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v29 = (const void *)v7[7];
  if (v29)
  {
    CFRelease(v29);
    v7[7] = 0;
  }
  CFAllocatorRef v30 = CFGetAllocator(v7);
  v7[7] = CFDictionaryCreateMutable(v30, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)Value);
  float64x2_t v32 = (const void **)C3DMalloc(8 * Count);
  CFDictionaryGetKeysAndValues((CFDictionaryRef)Value, v32, 0);
  qsort(v32, Count, 8uLL, (int (__cdecl *)(const void *, const void *))__LibraryDeserializationCompareStrings);
  if (Count < 1)
  {
    BOOL v33 = 1;
    if (v32) {
      goto LABEL_76;
    }
    return v33;
  }
  BOOL v33 = 0;
  uint64_t v34 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  long long v75 = Value;
  long long v76 = v32;
  CFIndex v74 = Count;
  while (1)
  {
    CFStringRef v35 = (const __CFString *)v32[v34];
    uint64_t TypeForString = C3DLibraryGetTypeForString(v35);
    if (TypeForString) {
      break;
    }
LABEL_70:
    BOOL v33 = ++v34 >= Count;
    if (v34 == Count) {
      goto LABEL_75;
    }
  }
  uint64_t v37 = TypeForString;
  uint64_t v77 = v34;
  uint64_t v73 = (uint64_t)v35;
  CFDictionaryRef v38 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)Value, v35);
  uint64_t TypeID = C3DImageGetTypeID();
  CFIndex v39 = CFDictionaryGetCount(v38);
  uint64_t v40 = (const void **)C3DMalloc(8 * v39);
  int v41 = (const void **)C3DMalloc(8 * v39);
  CFDictionaryRef v42 = v38;
  CFIndex v43 = v39;
  CFDictionaryGetKeysAndValues(v42, v41, v40);
  if (v39 < 1)
  {
    unsigned int v45 = v40;
    if (v40) {
LABEL_67:
    }
      free(v45);
    CFNumberRef Value = v75;
    float64x2_t v32 = v76;
    CFIndex Count = v74;
    uint64_t v34 = v77;
    if (v41) {
      free(v41);
    }
    goto LABEL_70;
  }
  BOOL v72 = v33;
  uint64_t v44 = 0;
  unsigned int v45 = v40;
  CFIndex v79 = v43;
  while (1)
  {
    CFDictionaryRef v46 = (const __CFDictionary *)v45[v44];
    IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)v41[v44]);
    if (C3DImageGetTypeID() == v37)
    {
      CFURLRef v47 = (const __CFURL *)CFDictionaryGetValue(a3, @"kEnclosingFolderURL");
      if (v47)
      {
        CFURLRef v48 = v47;
        CFStringRef v49 = (const __CFString *)CFDictionaryGetValue(v46, @"imageRelativePath");
        if (v49)
        {
          CFURLRef v50 = CFURLCreateCopyAppendingPathComponent(allocator, v48, v49, 0);
          if (v50)
          {
            uint64_t v51 = v50;
            Shareduint64_t Instance = C3DResourceCacheGetSharedInstance();
            Resource = C3DResourceCacheGetResource(SharedInstance, v51);
            if (Resource)
            {
              __AddEntry((uint64_t)v7, v37, IntValue, 0, Resource);
LABEL_63:
              CFRelease(v51);
              goto LABEL_64;
            }
            CFRelease(v51);
          }
        }
      }
    }
    if (C3DGeometryGetTypeID() == v37)
    {
      Empty = (void *)C3DGeometryCreate();
      goto LABEL_53;
    }
    if (C3DMeshGetTypeID() == v37)
    {
      Empty = (void *)C3DMeshCreate();
      goto LABEL_53;
    }
    if (C3DMaterialGetTypeID() == v37)
    {
      Empty = (void *)C3DMaterialCreate();
      goto LABEL_53;
    }
    if (C3DImageGetTypeID() == v37)
    {
      Empty = (void *)C3DImageCreate();
      goto LABEL_53;
    }
    if (C3DNodeGetTypeID() == v37)
    {
      Empty = (void *)C3DNodeCreate();
      goto LABEL_53;
    }
    if (C3DCameraGetTypeID() == v37)
    {
      Empty = (void *)C3DCameraCreate();
      goto LABEL_53;
    }
    if (C3DLightGetTypeID() == v37)
    {
      Empty = (void *)C3DLightCreate();
      goto LABEL_53;
    }
    if (C3DAnimationGroupGetTypeID() == v37)
    {
      Empty = (void *)C3DAnimationGroupCreate();
      goto LABEL_53;
    }
    if (C3DSkinGetTypeID() == v37)
    {
      Empty = (void *)C3DSkinCreate();
      goto LABEL_53;
    }
    if (C3DMeshSourceGetTypeID() == v37)
    {
      Empty = (void *)_C3DMeshSourceCreate();
      goto LABEL_53;
    }
    if (C3DMorphGetTypeID() == v37)
    {
      Empty = (void *)C3DMorphCreate();
      goto LABEL_53;
    }
    if (C3DGenericSourceGetTypeID() == v37) {
      break;
    }
LABEL_64:
    if (v43 == ++v44) {
      goto LABEL_67;
    }
  }
  Empty = (void *)C3DGenericSourceCreateEmpty();
LABEL_53:
  uint64_t v51 = Empty;
  if (!Empty) {
    goto LABEL_64;
  }
  if (C3DInitWithPropertyList(Empty, (uint64_t)v46, (uint64_t)a3, a4))
  {
    if (TypeID == v37)
    {
      uint64_t v55 = v45;
      uint64_t v56 = v7;
      CFDictionaryRef v57 = a3;
      uint64_t v58 = a4;
      uint64_t URL = C3DImageGetURL((uint64_t)v51);
      if (URL)
      {
        uint64_t v60 = (void *)URL;
        uint64_t v61 = C3DResourceCacheGetSharedInstance();
        uint64_t v62 = (void *)C3DResourceCacheGetResource(v61, v60);
        if (v62 != v51)
        {
          long long v63 = v62;
          if (v62)
          {
            CFRelease(v51);
            uint64_t v51 = (void *)CFRetain(v63);
          }
        }
      }
      a4 = v58;
      a3 = v57;
      uint64_t v7 = v56;
      unsigned int v45 = v55;
      CFIndex v43 = v79;
    }
    __AddEntry((uint64_t)v7, v37, IntValue, v46, v51);
    if (C3DAnimationGroupGetTypeID() == v37) {
      _fillLibraryWithAnimationGroup((uint64_t)v7, v51);
    }
    goto LABEL_63;
  }
  free(v45);
  free(v41);
  CFRelease(v51);
  long long v64 = scn_default_log();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
    _C3DLibraryInitWithPropertyList_cold_1(v73, v64, v65, v66, v67, v68, v69, v70);
  }
  float64x2_t v32 = v76;
  BOOL v33 = v72;
LABEL_75:
  if (v32) {
LABEL_76:
  }
    free(v32);
  return v33;
}

__CFDictionary *_C3DLibraryCopyPropertyList(CFDictionaryRef *cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!cf)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  CFAllocatorRef v15 = CFGetAllocator(cf);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v15, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable)
  {
    CFAllocatorRef v17 = CFGetAllocator(cf);
    uint64_t v18 = CFDictionaryCreateMutable(v17, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    CFIndex Count = CFDictionaryGetCount(cf[2]);
    uint64_t v20 = (const void **)C3DMalloc(8 * Count);
    uint64_t v21 = (const void **)C3DMalloc(8 * Count);
    float64x2_t v32 = v20;
    CFDictionaryGetKeysAndValues(cf[2], v21, v20);
    if (Count >= 1)
    {
      uint64_t v22 = (uint64_t *)v21;
      do
      {
        uint64_t v23 = (const void *)*v22;
        if (!C3DTypeConformsToProtocol(*v22, 0))
        {
          uint64_t v27 = scn_default_log();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            int v34 = (int)v23;
            _os_log_error_impl(&dword_20B249000, v27, OS_LOG_TYPE_ERROR, "Error: type %d is not serializable\n", buf, 8u);
          }
          goto LABEL_18;
        }
        CFMutableDictionaryRef v24 = _copySerializedSubStorage(cf, v23, a3, a4, 0);
        StringForint Type = C3DLibraryGetStringForType((uint64_t)v23);
        if (StringForType) {
          BOOL v26 = v24 == 0;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26)
        {
          if (!v24) {
            goto LABEL_18;
          }
        }
        else
        {
          CFDictionarySetValue(v18, StringForType, v24);
        }
        CFRelease(v24);
LABEL_18:
        ++v22;
        --Count;
      }
      while (Count);
    }
    uint64_t TypeID = (const void *)C3DMaterialGetTypeID();
    CFMutableDictionaryRef v29 = _copySerializedSubStorage(cf, TypeID, a3, a4, (uint64_t (*)(const void *, CFDictionaryRef *, uint64_t, uint64_t))C3DMaterialCopyEffectPropertyList);
    if (v29)
    {
      CFMutableDictionaryRef v30 = v29;
      CFDictionarySetValue(v18, @"effect", v29);
      CFRelease(v30);
    }
    CFDictionarySetValue(Mutable, @"libraryStorage", v18);
    CFRelease(v18);
    if (v32) {
      free(v32);
    }
    if (v21) {
      free(v21);
    }
  }
  return Mutable;
}

uint64_t _C3DLibraryFinalizeDeserialization(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void context[3] = *MEMORY[0x263EF8340];
  if (a1 != a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DLibraryFinalizeDeserialization_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!*(void *)(a1 + 16))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      _C3DLibraryFinalizeDeserialization_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
  uint64_t v23 = (const void **)C3DMalloc(8 * Count);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v23, 0);
  qsort(v23, Count, 8uLL, (int (__cdecl *)(const void *, const void *))__LibraryDeserializationCompare);
  uint64_t v24 = 1;
  if (Count >= 1)
  {
    uint64_t v25 = v23;
    char v26 = 1;
    do
    {
      uint64_t v27 = *v25++;
      CFNumberRef Value = (CFDictionaryRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v27);
      char v34 = 1;
      context[0] = a1;
      context[1] = a4;
      context[2] = &v34;
      CFDictionaryApplyFunction(Value[2], (CFDictionaryApplierFunction)__finalizeDeserialization, context);
      v26 &= v34 != 0;
      --Count;
    }
    while (Count);
    if (v26)
    {
      uint64_t v24 = 1;
    }
    else
    {
      CFMutableDictionaryRef v29 = scn_default_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        _C3DLibraryFinalizeDeserialization_cold_1(v29);
      }
      uint64_t v24 = 0;
    }
  }
  CFMutableDictionaryRef v30 = *(const void **)(a1 + 56);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 56) = 0;
  }
  BOOL v31 = *(const void **)(a1 + 48);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 48) = 0;
  }
  if (v23) {
    free(v23);
  }
  float64x2_t v32 = *(const void **)(a1 + 24);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(a1 + 24) = 0;
  }
  return v24;
}

uint64_t __LibraryDeserializationCompareStrings(const __CFString **a1, const __CFString **a2)
{
  CFStringRef v2 = *a2;
  uint64_t TypeForString = C3DLibraryGetTypeForString(*a1);
  int v4 = __LibraryDeserializationOrder(TypeForString);
  uint64_t v5 = C3DLibraryGetTypeForString(v2);
  return v4 - __LibraryDeserializationOrder(v5);
}

uint64_t __LibraryDeserializationOrder(uint64_t a1)
{
  if (C3DAnimationGroupGetTypeID() == a1) {
    return 1;
  }
  if (C3DImageGetTypeID() == a1) {
    return 2;
  }
  if (C3DMaterialGetTypeID() == a1) {
    return 4;
  }
  if (C3DMeshSourceGetTypeID() == a1) {
    return 5;
  }
  if (C3DGenericSourceGetTypeID() == a1) {
    return 6;
  }
  if (C3DMeshGetTypeID() == a1) {
    return 7;
  }
  if (C3DMeshElementGetTypeID() == a1) {
    return 8;
  }
  if (C3DGeometryGetTypeID() == a1 || C3DParametricGeometryGetTypeID() == a1 || C3DFloorGetTypeID() == a1) {
    return 9;
  }
  if (C3DSkinGetTypeID() == a1) {
    return 10;
  }
  if (C3DMorphGetTypeID() == a1) {
    return 11;
  }
  if (C3DCameraGetTypeID() == a1) {
    return 12;
  }
  if (C3DLightGetTypeID() == a1) {
    return 13;
  }
  if (C3DNodeGetTypeID() == a1) {
    return 14;
  }
  return 0;
}

void __AddEntry(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5)
{
  int valuePtr = C3DLibraryAddEntry(a1, a5);
  if (C3DTypeConformsToProtocol(a2, 0))
  {
    CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberLongType, &valuePtr);
    EntryIdentifier = C3DLibraryCreateEntryIdentifier(a3, a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), EntryIdentifier, v10);
    if (a4) {
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 56), a5, a4);
    }
    if (v10) {
      CFRelease(v10);
    }
    if (EntryIdentifier) {
      CFRelease(EntryIdentifier);
    }
    uint64_t ID = (__CFString *)C3DEntityGetID((uint64_t)a5);
    if (ID)
    {
      uint64_t v13 = ID;
      CFRetain(ID);
    }
    else
    {
      uint64_t v14 = valuePtr;
      CFTypeID v15 = CFGetTypeID(a5);
      uint64_t v13 = C3DLibraryCreateEntryIdentifier((uint64_t)v14, v15);
    }
    C3DLibraryTrackID(a1, v13, valuePtr, a5);
    CFRelease(v13);
  }
}

void _fillLibraryWithAnimationGroup(uint64_t a1, const void *a2)
{
  AnimationCFIndex Count = C3DAnimationGroupGetAnimationCount((uint64_t)a2);
  if (!C3DLibraryGetEntryID(a1, a2)) {
    _addAndTrackEntity(a1, a2);
  }
  if (AnimationCount >= 1)
  {
    for (CFIndex i = 0; i != AnimationCount; ++i)
    {
      AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex((uint64_t)a2, i);
      if (C3DAnimationIsGroup(AnimationAtIndex)) {
        _fillLibraryWithAnimationGroup(a1, AnimationAtIndex);
      }
      else {
        _addAndTrackEntity(a1, AnimationAtIndex);
      }
    }
  }
}

void _addAndTrackEntity(uint64_t a1, const void *a2)
{
  int v4 = C3DLibraryAddEntry(a1, a2);
  uint64_t ID = (__CFString *)C3DEntityGetID((uint64_t)a2);
  if (ID)
  {
    EntryIdentifier = ID;
    CFRetain(ID);
    C3DLibraryTrackID(a1, EntryIdentifier, v4, a2);
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(a2);
    EntryIdentifier = C3DLibraryCreateEntryIdentifier((uint64_t)v4, v7);
    C3DLibraryTrackID(a1, EntryIdentifier, v4, a2);
    if (!EntryIdentifier) {
      return;
    }
  }

  CFRelease(EntryIdentifier);
}

CFMutableDictionaryRef _copySerializedSubStorage(CFDictionaryRef *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(const void *, CFDictionaryRef *, uint64_t, uint64_t))
{
  CFNumberRef Value = CFDictionaryGetValue(a1[2], a2);
  if (!Value) {
    return 0;
  }
  CFNumberRef v10 = Value;
  CFAllocatorRef v11 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFMutableDictionaryRef v13 = Mutable;
  CFDictionaryRef v14 = (const __CFDictionary *)*((void *)v10 + 2);
  if (v14)
  {
    theDict = Mutable;
    CFIndex Count = CFDictionaryGetCount(v14);
    uint64_t v16 = (const void **)C3DMalloc(8 * Count);
    uint64_t v17 = (const void **)C3DMalloc(8 * Count);
    CFDictionaryGetKeysAndValues(v14, v17, v16);
    char v26 = v16;
    uint64_t v27 = v17;
    if (Count >= 1)
    {
      while (1)
      {
        uint64_t v18 = *v17;
        CFAllocatorRef v19 = CFGetAllocator(a1);
        CFStringRef v20 = CFStringCreateWithFormat(v19, 0, @"%d", v18, v26);
        uint64_t v21 = *v16;
        uint64_t v22 = (const void *)(a5 ? a5(v21, a1, a3, a4) : C3DCopyPropertyList(v21, (uint64_t)a1, a3, a4));
        uint64_t v23 = v22;
        if (v22 && v20 != 0) {
          break;
        }
        if (v20) {
          goto LABEL_17;
        }
        if (v22) {
          goto LABEL_14;
        }
LABEL_15:
        ++v16;
        ++v17;
        if (!--Count) {
          goto LABEL_21;
        }
      }
      CFDictionarySetValue(theDict, v20, v22);
LABEL_17:
      CFRelease(v20);
      if (!v23) {
        goto LABEL_15;
      }
LABEL_14:
      CFRelease(v23);
      goto LABEL_15;
    }
    if (v16) {
LABEL_21:
    }
      free(v26);
    CFMutableDictionaryRef v13 = theDict;
    if (v27) {
      free(v27);
    }
  }
  return v13;
}

uint64_t __LibraryDeserializationCompare(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = __LibraryDeserializationOrder(*a1);
  return v3 - __LibraryDeserializationOrder(v2);
}

void __finalizeDeserialization(int a1, void *key, uint64_t a3)
{
  CFDictionaryRef v5 = *(const __CFDictionary **)(*(void *)a3 + 56);
  if (!v5)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __finalizeDeserialization_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)a3;
  CFNumberRef Value = CFDictionaryGetValue(v5, key);
  int v16 = C3DFinalizeDeserialization(key, v14, (uint64_t)Value, *(void *)(a3 + 8));
  if (!v16)
  {
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      __finalizeDeserialization_cold_1((uint64_t)key, v17, v18, v19, v20, v21, v22, v23);
    }
    uint64_t v24 = *(CFErrorRef **)(a3 + 8);
    if (v24 && !*v24) {
      CFErrorRef *v24 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
  }
  **(unsigned char **)(a3 + 16) &= v16 != 0;
}

void _fillImageSamplerMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned char **)a3;
  int v4 = *(unsigned char **)(a3 + 8);
  if (!**(unsigned char **)a3 || !*v4)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t CommonProfile = C3DMaterialGetCommonProfile(a2);
    unsigned __int8 v7 = 0;
    do
    {
      uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, (char)v7, 0);
      if (EffectSlot)
      {
        uint64_t v9 = EffectSlot;
        if (C3DEffectSlotGetImage(EffectSlot) == v5)
        {
          if (C3DEffectSlotGetTextureSampler(v9))
          {
            if (C3DRendererContextTextureSamplerImpliesPow2TextureSize()) {
              *int v3 = 1;
            }
            else {
              *int v4 = 1;
            }
          }
          else
          {
            uint64_t v11 = scn_default_log();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v12 = 0;
              _os_log_impl(&dword_20B249000, v11, OS_LOG_TYPE_DEFAULT, "Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler", v12, 2u);
            }
          }
        }
      }
      unsigned int v10 = v7++;
    }
    while (v10 < 0x15);
  }
}

uint64_t C3DFloorGetBoundingBoxWithExtent(uint64_t a1, float32x4_t *a2, __n128 *a3, double a4)
{
  uint64_t v8 = (__n128 *)C3DGetScene((void *)a1);
  if (v8)
  {
    v16.i32[2] = 0;
    v16.i64[0] = 0;
    __n128 UpAxis = C3DSceneGetUpAxis(v8, (__n128 *)&v16);
    int8x16_t v10 = v16;
  }
  else
  {
    int8x16_t v10 = (int8x16_t)xmmword_20B5CB7D0;
  }
  UpAxis.n128_f32[0] = a4;
  UpAxis.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vceqz_f32(*(float32x2_t *)(a1 + 236)), (int8x8_t)vdup_lane_s32((int32x2_t)UpAxis.n128_u64[0], 0), *(int8x8_t *)(a1 + 236));
  if (*(float *)&v10.i32[1] == 0.0)
  {
    if (*(float *)&v10.i32[2] == 0.0)
    {
      v14.i32[0] = 0;
      v14.i32[3] = 0;
      v14.f32[1] = -UpAxis.n128_f32[0];
      v14.f32[2] = -UpAxis.n128_f32[1];
      *a2 = v14;
      v10.i32[0] = 925353388;
      __n128 UpAxis = (__n128)vextq_s8(vextq_s8(v10, v10, 4uLL), (int8x16_t)UpAxis, 0xCuLL);
    }
    else
    {
      *(float *)&unint64_t v13 = -UpAxis.n128_f32[0];
      *((float *)&v13 + 1) = -UpAxis.n128_f32[1];
      *a2 = (float32x4_t)v13;
      UpAxis.n128_u32[2] = 925353388;
    }
  }
  else
  {
    float32x4_t v11 = vnegq_f32((float32x4_t)vzip1q_s32((int32x4_t)UpAxis, (int32x4_t)UpAxis));
    v11.i32[1] = 0;
    *a2 = v11;
    int8x16_t v12 = (int8x16_t)vdupq_n_s32(0x3727C5ACu);
    __n128 UpAxis = (__n128)vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)v12, (int32x4_t)UpAxis), v12, 4uLL);
  }
  *a3 = UpAxis;
  return 1;
}

uint64_t C3DFloorCreate()
{
  if (C3DFloorGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFloorGetTypeID_onceToken, &__block_literal_global_80);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFloorGetTypeID_typeID, 0xF0uLL);
  C3DGeometryInit(Instance);
  *(_DWORD *)(Instance + 228) = 1056964608;
  *(void *)(Instance + 248) = -1;
  uint64_t Plane = (const void *)C3DMeshCreatePlane(0, 10, 10, 0, 2.0, -2.0, 0.0);
  CopyWithInterleavedSources = (uint64_t *)C3DMeshCreateCopyWithInterleavedSources((uint64_t)Plane);
  if (Plane) {
    CFRelease(Plane);
  }
  C3DGeometrySetMesh(Instance, CopyWithInterleavedSources);
  CFRelease(CopyWithInterleavedSources);
  int v3 = (void *)C3DMaterialCreate();
  C3DMaterialSetDoubleSided((uint64_t)v3, 1);
  uint64_t CommonProfile = C3DMaterialGetCommonProfile((uint64_t)v3);
  C3DEffectCommonProfileSetPerPixelLit(CommonProfile, 1);
  C3DEffectCommonProfileSetEnableLockAmbientWithDiffuse(CommonProfile, 1);
  uint64_t v5 = (const void *)C3DTextureSamplerCreateWithOptions(2, 2, 2, 2, 2, 2);
  int v6 = 0;
  do
  {
    C3DMaterialSetTextureSampler((uint64_t)v3, (char)v6, v5);
    unsigned int v7 = v6++;
  }
  while (v7 < 0xF);
  CFRelease(v5);
  C3DGeometryAppendMaterial(Instance, v3);
  CFRelease(v3);
  C3DFloorSetReflectivity(Instance, 0.25);
  return Instance;
}

float C3DFloorGetReflectivity(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 216);
}

void __notifyMaterialDidChangeAndInvalidatePasses(void *a1)
{
  _C3DGeometryShadingDidUpdate(a1);
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  uint64_t v3 = (const void *)C3DGetScene(a1);

  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", v3, 0, 1u);
}

void C3DFloorSetReflectivity(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 216);
  if (a2 != 0.0 && v12 == 0.0)
  {
    *(float *)(a1 + 216) = a2;
LABEL_9:
    __notifyMaterialDidChangeAndInvalidatePasses((void *)a1);
    return;
  }
  *(float *)(a1 + 216) = a2;
  if (a2 == 0.0 && v12 != 0.0) {
    goto LABEL_9;
  }
}

float C3DFloorGetReflectionFalloffStart(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 220);
}

void C3DFloorSetReflectionFalloffStart(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 220);
  if (a2 != 0.0 && v12 == 0.0)
  {
    *(float *)(a1 + 220) = a2;
LABEL_9:
    __notifyMaterialDidChangeAndInvalidatePasses((void *)a1);
    return;
  }
  *(float *)(a1 + 220) = a2;
  if (a2 == 0.0 && v12 != 0.0) {
    goto LABEL_9;
  }
}

float C3DFloorGetReflectionFalloffEnd(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 224);
}

void C3DFloorSetReflectionFalloffEnd(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = *(float *)(a1 + 224);
  if (a2 != 0.0 && v12 == 0.0)
  {
    *(float *)(a1 + 224) = a2;
LABEL_9:
    __notifyMaterialDidChangeAndInvalidatePasses((void *)a1);
    return;
  }
  *(float *)(a1 + 224) = a2;
  if (a2 == 0.0 && v12 != 0.0) {
    goto LABEL_9;
  }
}

float C3DFloorGetReflectionResolutionScaleFactor(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 228);
}

void C3DFloorSetReflectionResolutionScaleFactor(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 != 0.0 && *(float *)(a1 + 228) != a2)
  {
    *(float *)(a1 + 228) = a2;
    __notifyMaterialDidChangeAndInvalidatePasses((void *)a1);
  }
}

uint64_t C3DFloorGetReflectionSampleCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 232);
}

void C3DFloorSetReflectionSampleCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFloorGetReflectivity_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(_DWORD *)(a1 + 232) != a2)
  {
    *(_DWORD *)(a1 + 232) = a2;
    __notifyMaterialDidChangeAndInvalidatePasses((void *)a1);
  }
}

float C3DFloorGetWidth(uint64_t a1)
{
  return *(float *)(a1 + 236);
}

uint64_t C3DFloorSetWidth(uint64_t result, float a2)
{
  *(float *)(result + 236) = a2;
  return result;
}

float C3DFloorGetLength(uint64_t a1)
{
  return *(float *)(a1 + 240);
}

uint64_t C3DFloorSetLength(uint64_t result, float a2)
{
  *(float *)(result + 240) = a2;
  return result;
}

uint64_t C3DFloorGetReflectionCategoryBitMask(uint64_t a1)
{
  return *(void *)(a1 + 248);
}

uint64_t C3DFloorSetReflectionCategoryBitMask(uint64_t result, uint64_t a2)
{
  *(void *)(result + 248) = a2;
  return result;
}

CFStringRef _C3DFloorCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFloor>");
}

CFStringRef _C3DFloorCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFloor>");
}

uint64_t _C3DFloorInitWithPropertyList(_DWORD *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  uint64_t v16 = _C3DGeometryInitWithPropertyList(a1, a2, a3, a4);
  if (v16)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"reflectivity");
    if (Value)
    {
      int valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
      a1[54] = valuePtr;
    }
    CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(a2, @"reflectionFalloffStart");
    if (v18)
    {
      int v23 = 0;
      CFNumberGetValue(v18, kCFNumberFloatType, &v23);
      a1[55] = v23;
    }
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"reflectionFalloffEnd");
    if (v19)
    {
      int v22 = 0;
      CFNumberGetValue(v19, kCFNumberFloatType, &v22);
      a1[56] = v22;
    }
  }
  else
  {
    uint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      _C3DFloorInitWithPropertyList_cold_1(v20);
    }
  }
  return v16;
}

__CFDictionary *_C3DFloorCopyPropertyList(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = _C3DGeometryCopyPropertyList((uint64_t)a1, a2, a3);
  if (v14)
  {
    int valuePtr = a1[54];
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryAddValue(v14, @"reflectivity", v15);
    CFRelease(v15);
    int v20 = a1[55];
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberFloatType, &v20);
    CFDictionaryAddValue(v14, @"reflectionFalloffStart", v16);
    CFRelease(v16);
    int v19 = a1[56];
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberFloatType, &v19);
    CFDictionaryAddValue(v14, @"reflectionFalloffEnd", v17);
    CFRelease(v17);
  }
  return v14;
}

__CFArray *_C3DFloorCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 216;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v5, @"name", @"reflectivity");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 220;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v9, @"name", @"reflectionFalloffStart");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 224;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v13, @"name", @"reflectionFalloffEnd");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  CFNumberRef v17 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 228;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v17, @"name", @"resolutionScaleFactor");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 232;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v21, @"name", @"sampleCount");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  uint64_t v25 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 2;
  uint64_t v39 = a1 + 248;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v25, @"name", @"reflectionBitMask");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 236;
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v29, @"name", @"width");
  CFDictionarySetValue(v29, @"type", v30);
  CFDictionarySetValue(v29, @"address", v32);
  CFDictionarySetValue(v29, @"semantic", v31);
  CFArrayAppendValue(Mutable, v29);
  CFRelease(v31);
  CFRelease(v29);
  CFRelease(v32);
  CFRelease(v30);
  BOOL v33 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 240;
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v33, @"name", @"length");
  CFDictionarySetValue(v33, @"type", v34);
  CFDictionarySetValue(v33, @"address", v36);
  CFDictionarySetValue(v33, @"semantic", v35);
  CFArrayAppendValue(Mutable, v33);
  CFRelease(v35);
  CFRelease(v33);
  CFRelease(v36);
  CFRelease(v34);
  uint64_t v37 = _C3DGeometryCopyInstanceVariables(a1);
  v42.length = CFArrayGetCount(v37);
  v42.locatioint n = 0;
  CFArrayAppendArray(Mutable, v37, v42);
  CFRelease(v37);
  return Mutable;
}

uint64_t _C3DFloorGetBoundingBox(uint64_t a1, uint64_t a2, float32x4_t *a3, __n128 *a4)
{
  return 1;
}

const void *_C3DFloorGetBoundingSphere(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef result = (const void *)C3DGeometryGetMesh(a1);
  if (result)
  {
    return (const void *)C3DGetBoundingSphere(result, a2, a3);
  }
  return result;
}

uint64_t _C3DFloorSearchByID(uint64_t a1, const void *a2)
{
  uint64_t ID = (const void *)C3DEntityGetID(a1);
  if (C3DEqual(ID, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void _C3DFloorSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 216) == __dst)
  {
    C3DFloorSetReflectivity(a1, *__src);
  }
  else if ((void *)(a1 + 224) == __dst)
  {
    C3DFloorSetReflectionFalloffEnd(a1, *__src);
  }
  else
  {
    memcpy(__dst, __src, __n);
  }
}

SCNMaterialAttachment *SCNTextureContentWithGLInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  CFNumberRef v12 = objc_alloc_init(SCNMaterialAttachment);
  [(SCNMaterialAttachment *)v12 setOptions:a4];
  [(SCNMaterialAttachment *)v12 setGlID:a2];
  [(SCNMaterialAttachment *)v12 setTarget:a3];
  [(SCNMaterialAttachment *)v12 setContext:a1];
  -[SCNMaterialAttachment setSize:](v12, "setSize:", a5, a6);
  return v12;
}

Class __SKSceneClass()
{
  return NSClassFromString(&cfstr_Skscene.isa);
}

Class __SKTextureClass()
{
  return NSClassFromString(&cfstr_Sktexture.isa);
}

Class __GLKTextureInfoClass()
{
  return NSClassFromString(&cfstr_Glktextureinfo.isa);
}

Class __AVPlayerClass()
{
  return NSClassFromString(&cfstr_Avplayer.isa);
}

Class __AVCaptureDeviceClass()
{
  return NSClassFromString(&cfstr_Avcapturedevic.isa);
}

void sub_20B434A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef _C3DProgramHashCodeStoreCFCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v3, 0, @"<C3DProgramHashCodeStore %p>", a1);
}

CFStringRef _C3DProgramHashCodeStoreCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DProgramHashCodeStore %p>", a1);
}

void C3DProgramHashCodeStoreInvalidateRendererElementSpan(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = HIDWORD(a2);
  if (HIDWORD(a2))
  {
    int v4 = 0;
    __int16 v5 = WORD1(a2);
    int v6 = (unsigned __int16)a2;
    do
    {
      unsigned int v7 = C3DRendererElementFlattenedIndexForSpanHandle(v6, (unsigned __int16)(v4 + v5));
      if (*(_DWORD *)(a1 + 44) != -15)
      {
        unint64_t v8 = 0;
        uint64_t v9 = v7;
        do
        {
          if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v8))
          {
            uint64_t v10 = *(void *)(a1 + 24);
            if (C3DArrayGetCount(*(void *)(v10 + 8 * v8)) > v9)
            {
              ValuePtrAtuint64_t Index = (void **)C3DArrayGetValuePtrAtIndex(*(void *)(v10 + 8 * v8), v9);
              if (*ValuePtrAtIndex)
              {
                CFNumberRef v12 = (uint64_t *)ValuePtrAtIndex;
                C3DIndexStoreRemoveIndexForKey(*(void *)(a1 + 48), *ValuePtrAtIndex);
                C3DProgramHashCodeRelease(*v12);
                uint64_t *v12 = 0;
              }
            }
          }
          ++v8;
        }
        while (v8 < (*(_DWORD *)(a1 + 44) + 15));
      }
      ++v4;
    }
    while (v4 != v2);
  }
}

void C3DProgramHashCodeStoreRegisterProgramForRendererElement(uint64_t a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t a5)
{
}

void C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_grow(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  CFAllocatorRef v3 = *(CFTypeRef **)(a1 + 8);
  int v4 = *(__int16 **)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 28);
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v5 != -15)
  {
    unsigned int v7 = v3;
    unint64_t v8 = v2;
    uint64_t v9 = v4;
    do
    {
      __int16 v10 = *v9++;
      if (v10)
      {
        C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::insert(a1, *v8, v7);
        if (*v7) {
          CFRelease(*v7);
        }
      }
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  free(v3);
  free(v2);

  free(v4);
}

void sub_20B4367C4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ____createCopy_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (id)[a3 copy];
  [*(id *)(a1 + 32) _shadableSetValue:v5 forUndefinedKey:a2];
}

uint64_t C3DFXGLSLProgramObjectGetTypeID()
{
  if (C3DFXGLSLProgramObjectGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXGLSLProgramObjectGetTypeID_onceToken, &__block_literal_global_83);
  }
  return C3DFXGLSLProgramObjectGetTypeID_typeID;
}

void _C3DFXGLSLProgramObjectCFFinalize(void *a1)
{
  unint64_t v2 = (void *)a1[9];
  if (v2) {
    free(v2);
  }
  CFAllocatorRef v3 = (void *)a1[10];
  if (v3) {
    free(v3);
  }
  int v4 = (void *)a1[12];
  if (v4) {
    free(v4);
  }
  id v5 = (const void *)a1[15];
  if (v5)
  {
    CFRelease(v5);
    a1[15] = 0;
  }
  uint64_t v6 = (const void *)a1[13];
  if (v6)
  {
    CFRelease(v6);
    a1[13] = 0;
  }
  unsigned int v7 = (const void *)a1[14];
  if (v7)
  {
    CFRelease(v7);
    a1[14] = 0;
  }
}

CFStringRef _C3DFXGLSLProgramObjectCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXGLSLProgramObject %p>", a1);
}

CFStringRef _C3DFXGLSLProgramObjectCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXGLSLProgramObject %p>", a1);
}

uint64_t __C3DFXGLSLProgramObjectGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXGLSLProgramObjectGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DFXGLSLProgramObjectCreateWithProgramID(uint64_t a1)
{
  if (C3DFXGLSLProgramObjectGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXGLSLProgramObjectGetTypeID_onceToken, &__block_literal_global_83);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFXGLSLProgramObjectGetTypeID_typeID, 0x70uLL);
  uint64_t v3 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 64) = 1;
    *(void *)(Instance + 96) = 0;
    *(void *)(Instance + 72) = 0;
    *(void *)(Instance + 80) = 0;
    C3DVRAMResourceSetID(Instance, a1);
  }
  return v3;
}

uint64_t C3DFXGLSLProgramObjectAttachWithProgram(uint64_t result)
{
  return result;
}

uint64_t C3DFXGLSLProgramObjectDetachOfProgram(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 64) - 1);
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 64) = v1;
  return v1;
}

uint64_t C3DFXGLSLProgramObjectGetProgramID(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DVRAMResourceGetID(a1);
}

void *C3DFXGLSLProgramObjectSetUniformsLocations(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  *(void *)(a1 + 88) = a3;
  CFNumberRef v14 = malloc_type_realloc(*(void **)(a1 + 72), 8 * a3, 0x100004000313F17uLL);
  *(void *)(a1 + 72) = v14;
  memcpy(v14, a2, 8 * a3);
  uint64_t result = malloc_type_realloc(*(void **)(a1 + 80), 8 * a3, 0x80040B8603338uLL);
  *(void *)(a1 + 80) = result;
  if (a3 >= 1)
  {
    uint64_t v16 = 0;
    do
      *(void *)(*(void *)(a1 + 80) + 8 * v16++) = -1;
    while (a3 != v16);
  }
  return result;
}

uint64_t C3DFXGLSLProgramObjectGetUniformLocation(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 88) > a2 && (uint64_t v12 = *(void *)(a1 + 72)) != 0) {
    return *(void *)(v12 + 8 * a2);
  }
  else {
    return -1;
  }
}

uint64_t C3DFXGLSLProgramObjectGetUniformIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 88);
  if (v12 < 1) {
    return -1;
  }
  uint64_t result = 0;
  while (*(void *)(*(void *)(a1 + 72) + 8 * result) != a2)
  {
    if (v12 == ++result) {
      return -1;
    }
  }
  return result;
}

uint64_t C3DFXGLSLProgramObjectGetUniformLocationOfSymbolNamed(uint64_t a1, void *key)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), key) - 1;
}

void C3DFXGLSLProgramObjectApplyFunctionForAttributes(uint64_t a1, CFDictionaryApplierFunction applier, void *context)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 112), applier, context);
}

void C3DFXGLSLProgramObjectApplyFunctionForUniforms(uint64_t a1, CFDictionaryApplierFunction applier, void *context)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 104), applier, context);
}

void C3DFXGLSLProgramObjectSetUniformValueAtIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererElementStateDrawRendererElement_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2 < 0) {
      return;
    }
  }
  else if (a2 < 0)
  {
    return;
  }
  if (*(void *)(a1 + 88) > a2) {
    *(void *)(*(void *)(a1 + 80) + 8 * a2) = a3;
  }
}

uint64_t C3DFXGLSLProgramObjectGetUniformValueAtIndex(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererElementStateDrawRendererElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2 < 0) {
      return 0;
    }
  }
  else if (a2 < 0)
  {
    return 0;
  }
  if (*(void *)(a1 + 88) > a2) {
    return *(void *)(*(void *)(a1 + 80) + 8 * a2);
  }
  return 0;
}

BOOL SCNVector3EqualToVector3(SCNVector3 a, SCNVector3 b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

BOOL SCNVector4EqualToVector4(SCNVector4 a, SCNVector4 b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}

__n128 C3DMatrix4x4ToSCNMatrix4(uint64_t a1, _OWORD *a2)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  return result;
}

__n128 C3DMatrix4x4FromSCNMatrix4(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return result;
}

SCNMatrix4 *__cdecl SCNMatrix4Invert(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *m)
{
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  simd_float4 v3 = *(simd_float4 *)&m->m21;
  v8.columns[0] = *(simd_float4 *)&m->m11;
  v8.columns[1] = v3;
  simd_float4 v4 = *(simd_float4 *)&m->m41;
  v8.columns[2] = *(simd_float4 *)&m->m31;
  v8.columns[3] = v4;
  __n128 result = (SCNMatrix4 *)C3DMatrix4x4Invert(&v8, &v8);
  simd_float4 v6 = v8.columns[1];
  *(simd_float4 *)&retstr->m11 = v8.columns[0];
  *(simd_float4 *)&retstr->m21 = v6;
  simd_float4 v7 = v8.columns[3];
  *(simd_float4 *)&retstr->m31 = v8.columns[2];
  *(simd_float4 *)&retstr->m41 = v7;
  return result;
}

SCNMatrix4 *__cdecl SCNMatrix4Scale(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *m, float sx, float sy, float sz)
{
  long long v7 = *(_OWORD *)&m->m21;
  float32x4_t v17 = *(float32x4_t *)&m->m11;
  long long v18 = v7;
  long long v8 = *(_OWORD *)&m->m41;
  long long v19 = *(_OWORD *)&m->m31;
  long long v20 = v8;
  long long v16 = *(_OWORD *)&sx;
  C3DMatrix4x4Scale(&v17, (float32x2_t *)&v16);
  long long v12 = v18;
  *(float32x4_t *)&m->m11 = v17;
  *(_OWORD *)&m->m21 = v12;
  long long v13 = v20;
  *(_OWORD *)&m->m31 = v19;
  *(_OWORD *)&m->m41 = v13;
  long long v14 = *(_OWORD *)&m->m21;
  *(_OWORD *)&retstr->m11 = *(_OWORD *)&m->m11;
  *(_OWORD *)&retstr->m21 = v14;
  long long v15 = *(_OWORD *)&m->m41;
  *(_OWORD *)&retstr->m31 = *(_OWORD *)&m->m31;
  *(_OWORD *)&retstr->m41 = v15;
  return result;
}

BOOL SCNMatrix4EqualToMatrix4(SCNMatrix4 *a, SCNMatrix4 *b)
{
  return memcmp(a, b, 0x40uLL) == 0;
}

SCNMatrix4 *__cdecl SCNMatrix4Rotate(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *m, float angle, float x, float y, float z)
{
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  memset(v22, 0, sizeof(v22));
  float32x4_t v17 = *(float32x4_t *)&x;
  C3DMatrix4x4MakeAxisAngleRotation(v22, &v17, (float)-angle);
  long long v10 = *(_OWORD *)&m->m21;
  long long v18 = *(_OWORD *)&m->m11;
  long long v19 = v10;
  long long v11 = *(_OWORD *)&m->m41;
  long long v20 = *(_OWORD *)&m->m31;
  long long v21 = v11;
  if (C3DWasLinkedBeforeMajorOSYear2019())
  {
    long long v12 = (float32x4_t *)&v18;
    long long v13 = v22;
  }
  else
  {
    long long v12 = v22;
    long long v13 = (float32x4_t *)&v18;
  }
  C3DMatrix4x4Mult((uint64_t)v12, v13, &v18);
  long long v15 = v19;
  *(_OWORD *)&retstr->m11 = v18;
  *(_OWORD *)&retstr->m21 = v15;
  long long v16 = v21;
  *(_OWORD *)&retstr->m31 = v20;
  *(_OWORD *)&retstr->m41 = v16;
  return result;
}

GLKMatrix4 *__cdecl SCNMatrix4ToGLKMatrix4(GLKMatrix4 *__return_ptr retstr, GLKMatrix4 *mat)
{
  long long v2 = *(_OWORD *)&mat->m[4];
  *(_OWORD *)&retstr->m00 = *(_OWORD *)&mat->m00;
  *(_OWORD *)&retstr->m[4] = v2;
  long long v3 = *(_OWORD *)&mat->m[12];
  *(_OWORD *)&retstr->m[8] = *(_OWORD *)&mat->m[8];
  *(_OWORD *)&retstr->m[12] = v3;
  return mat;
}

SCNMatrix4 *__cdecl SCNMatrix4FromGLKMatrix4(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *mat)
{
  long long v2 = *(_OWORD *)&mat->m21;
  *(_OWORD *)&retstr->m11 = *(_OWORD *)&mat->m11;
  *(_OWORD *)&retstr->m21 = v2;
  long long v3 = *(_OWORD *)&mat->m41;
  *(_OWORD *)&retstr->m31 = *(_OWORD *)&mat->m31;
  *(_OWORD *)&retstr->m41 = v3;
  return mat;
}

uint64_t CreateRadialSpanSide(uint64_t a1, double a2, __n128 a3)
{
  float v4 = (1.0 - a2) * 6.28318531;
  a3.n128_u32[0] = 0;
  a3.n128_f32[1] = v4;
  memset(v7, 0, sizeof(v7));
  a3.n128_u32[2] = 1078530011;
  __n128 v6 = a3;
  C3DMatrix4x4MakeEulerRotation(v7, &v6);
  return C3DMeshCopyWithTransform(a1, v7);
}

void generateRingProfile(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  BOOL v11 = a5 < 0.0;
  float v12 = -1.0;
  if (!v11) {
    float v12 = 1.0;
  }
  if (a2 == 3)
  {
    float v18 = (1.0 - a8 + (float)((float)(a4 * a8) / a3)) * 0.5;
    double v19 = v18;
    __double2 v20 = __sincos_stret(a9 * 6.28318531);
    float v21 = v19 * v20.__cosval + 0.5;
    *a1 = v21;
    float v17 = v19 * v20.__sinval + 0.5;
    uint64_t v22 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      *a1 = 0.0;
      a1[1] = v12;
      float v17 = 0.0;
    }
    else
    {
      if (a2) {
        return;
      }
      float v13 = (float)(a4 * a8) + (1.0 - a8) * a3;
      double v14 = (float)(v12 * v13);
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * v14;
      *a1 = v16;
      a1[1] = a5;
      float v17 = v15.__cosval * v13;
    }
    uint64_t v22 = 2;
  }
  a1[v22] = v17;
}

void generateSphereProfile(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  double v11 = 1.0 - a8;
  if (a2 == 3)
  {
    *a1 = a9;
    uint64_t v18 = 1;
  }
  else
  {
    float v12 = (a5 + -0.5) * a8 + (a4 + -0.5) * v11;
    if (a2 == 1)
    {
      __double2 v19 = __sincos_stret(v12 * 3.14159265);
      __double2 v20 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v21 = v20.__sinval * v19.__cosval;
      float sinval = v19.__sinval;
      *a1 = v21;
      a1[1] = sinval;
      double v11 = v20.__cosval * v19.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v13 = a3;
      __double2 v14 = __sincos_stret(v12 * 3.14159265);
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * (v14.__cosval * v13);
      float v17 = v14.__sinval * v13;
      *a1 = v16;
      a1[1] = v17;
      double v11 = v15.__cosval * (v14.__cosval * v13);
    }
    uint64_t v18 = 2;
  }
  float v23 = v11;
  a1[v18] = v23;
}

void generateCylinderProfile(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  BOOL v12 = a4 <= 0.0;
  double v13 = 3.14159265;
  if (v12) {
    double v13 = 0.0;
  }
  if (a2 == 3)
  {
    if (a4 <= 0.0)
    {
      *a1 = 1.0 - a9;
      a1[1] = a8;
    }
    else
    {
      *a1 = a9;
      a1[1] = 1.0 - a8;
    }
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v19 = __sincos_stret(v13 + a9 * 6.28318531);
      float sinval = v19.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      float cosval = v19.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v14 = a3;
      __double2 v15 = __sincos_stret(v13 + a9 * 6.28318531);
      float v16 = v15.__sinval * v14;
      float v17 = (a8 + -0.5) * a4;
      *a1 = v16;
      a1[1] = v17;
      float cosval = v15.__cosval * v14;
    }
    a1[2] = cosval;
  }
}

void generateConeProfile(uint64_t a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  if (a2 == 3)
  {
    *(float *)a1 = a9;
    float cosval = 1.0 - a8;
    uint64_t v17 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v18 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float sinval = v18.__sinval;
      *(float *)a1 = sinval;
      *(_DWORD *)(a1 + 4) = 0;
      float cosval = v18.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v11 = a8;
      double v12 = (float)(a3 * a8) + (1.0 - a8) * a4;
      __double2 v13 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v14 = v12 * v13.__sinval;
      float v15 = (v11 + -0.5) * a5;
      *(float *)a1 = v14;
      *(float *)(a1 + 4) = v15;
      float cosval = v12 * v13.__cosval;
    }
    uint64_t v17 = 2;
  }
  *(float *)(a1 + 4 * v17) = cosval;
}

void generateTorusProfile(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  if (a2 == 3)
  {
    *a1 = a9;
    float v19 = 1.0 - a8;
    uint64_t v20 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v21 = __sincos_stret((a8 + -0.5) * 6.28318531);
      __double2 v22 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v23 = v21.__cosval * v22.__sinval;
      float sinval = v21.__sinval;
      *a1 = v23;
      a1[1] = sinval;
      double v18 = v21.__cosval * v22.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v11 = a3;
      double v12 = a4;
      __double2 v13 = __sincos_stret((a8 + -0.5) * 6.28318531);
      double v14 = v11 + v12 * v13.__cosval;
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * v14;
      float v17 = v13.__sinval * v12;
      *a1 = v16;
      a1[1] = v17;
      double v18 = v15.__cosval * v14;
    }
    float v19 = v18;
    uint64_t v20 = 2;
  }
  a1[v20] = v19;
}

void generateCapsuleProfile(float *a1, int a2, int a3, float a4, float a5, double a6, double a7, double a8, float a9, float a10)
{
  if (a2 == 3)
  {
    *a1 = a10;
    double v22 = (float)(a4 / a5);
    double v23 = 1.0 - v22;
    double v24 = 1.0 - a9;
    double v25 = (float)((float)(a4 / a5) * a9) + (1.0 - v22) * v24;
    uint64_t v26 = 1;
    double v27 = v24 * v22;
    double v28 = v24 + a9 * v23;
    if (!a3) {
      double v27 = v28;
    }
    if (a3 == 1) {
      double v27 = v25;
    }
    else {
      uint64_t v26 = 1;
    }
    goto LABEL_24;
  }
  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    if (a3 == 2)
    {
      double v30 = a4;
      __double2 v31 = __sincos_stret(a9 * 1.57079633);
      __double2 v32 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      float v33 = v31.__cosval * v30 * v32.__sinval;
      float v34 = a5 * 0.5 + v30 * v31.__sinval - v30;
      *a1 = v33;
      a1[1] = v34;
      double v27 = v31.__cosval * v30 * v32.__cosval;
    }
    else
    {
      if (a3 == 1)
      {
        double v17 = a4;
        __double2 v35 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        double cosval = v35.__cosval;
        float v20 = v35.__sinval * v17;
        double v21 = (a9 + -0.5) * (float)(a5 + (float)(a4 * -2.0));
      }
      else
      {
        if (a3) {
          return;
        }
        double v15 = a4;
        __double2 v16 = __sincos_stret((a9 + -1.0) * 1.57079633);
        double v17 = v16.__cosval * v15;
        __double2 v19 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        double cosval = v19.__cosval;
        float v20 = v19.__sinval * (v16.__cosval * v15);
        double v21 = a5 * -0.5 + v15 * v16.__sinval + v15;
      }
      float v36 = v21;
      *a1 = v20;
      a1[1] = v36;
      double v27 = cosval * v17;
    }
    goto LABEL_23;
  }
  if (a3 == 2)
  {
    double v29 = a9;
  }
  else
  {
    if (a3 == 1)
    {
      __double2 v41 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      double v27 = v41.__cosval;
      float sinval = v41.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      goto LABEL_23;
    }
    if (a3) {
      return;
    }
    double v29 = a9 + -1.0;
  }
  __double2 v37 = __sincos_stret(v29 * 1.57079633);
  __double2 v38 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
  float v39 = v37.__cosval * v38.__sinval;
  float v40 = v37.__sinval;
  *a1 = v39;
  a1[1] = v40;
  double v27 = v37.__cosval * v38.__cosval;
LABEL_23:
  uint64_t v26 = 2;
LABEL_24:
  float v43 = v27;
  a1[v26] = v43;
}

void generateChamferCornerProfile(uint64_t a1, int a2, float a3, float32x4_t a4, float a5, float a6, float a7, float a8, float a9)
{
  _S21 = a3;
  float32x2_t v12 = vcvt_f32_s32((int32x2_t)(*(void *)&vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32((int)a7), (int8x8_t)0x200000001)) | 0x100000001));
  if (((int)a7 & 4) != 0) {
    int v13 = 1;
  }
  else {
    int v13 = -1;
  }
  float v14 = (float)v13;
  if (a9 != 0.0)
  {
    if (a8 != 0.0)
    {
      float v29 = _S21 / 1.41421356;
      float v30 = _S21 / 1.73205081;
      float v31 = v29 * v12.f32[0];
      float v32 = v29 * v14;
      float32x2_t v33 = vmul_n_f32(v12, v30);
      float v34 = vmuls_lane_f32(v29, v12, 1);
      double v35 = 1.0 - a8;
      double v36 = 1.0 - a9;
      v37.i32[0] = 0;
      v37.f32[1] = v34;
      float32x4_t v38 = (float32x4_t)vcvtq_f64_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v37, a8)), (float64x2_t)0, v35)));
      *(float32x2_t *)v38.f32 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v33, a8)), (float64x2_t)COERCE_UNSIGNED_INT64(v31), v35)), a9)), (float64x2_t)v38, v36));
      float v39 = (float)(v32 * a8) + v35 * (float)(v14 * _S21);
      float v40 = (float)((float)(v30 * v14) * a8) + v35 * v32;
      float32_t v41 = (float)(v40 * a9) + v36 * v39;
      v38.f32[2] = v41;
      int32x4_t v42 = (int32x4_t)vmulq_f32(v38, v38);
      v42.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v42, 2), vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v42.i8, 1))).u32[0];
      float32x2_t v43 = vrsqrte_f32((float32x2_t)v42.u32[0]);
      float32x2_t v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v43, v43)));
      _Q0 = vmulq_n_f32(v38, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v44, v44))).f32[0]);
      if (!a2)
      {
        a4.f32[1] = a5;
        *(float32x2_t *)a4.f32 = vmla_n_f32(*(float32x2_t *)a4.f32, *(float32x2_t *)_Q0.f32, _S21);
        __asm { FMLA            S3, S21, V0.S[2] }
        a4.i32[2] = _S3;
        _Q0 = a4;
      }
      *(void *)a1 = _Q0.i64[0];
      float v51 = _Q0.f32[2];
      goto LABEL_20;
    }
    if (a2 != 1)
    {
      if (a2) {
        return;
      }
      double v20 = a4.f32[0];
      double v21 = (float)(_S21 * v12.f32[0]);
      float v56 = a6;
      float v57 = _S21;
      __double2 v22 = __sincos_stret(a9 * 0.785398163);
      double cosval = v22.__cosval;
      float v23 = v20 + v21 * v22.__sinval;
      *(float *)a1 = v23;
      *(float *)(a1 + 4) = a5;
      goto LABEL_12;
    }
    double v52 = v12.f32[0];
    __double2 v53 = __sincos_stret(a9 * 0.785398163);
    double v26 = v53.__cosval;
    float v54 = v53.__sinval * v52;
    *(float *)a1 = v54;
    *(_DWORD *)(a1 + 4) = 0;
LABEL_18:
    double v24 = v26 * v14;
    goto LABEL_19;
  }
  if (a2 == 1)
  {
    *(_DWORD *)a1 = 0;
    double v25 = v12.f32[1];
    __double2 v27 = __sincos_stret(a8 * 0.785398163);
    double v26 = v27.__cosval;
    float v28 = v27.__sinval * v25;
    *(float *)(a1 + 4) = v28;
    goto LABEL_18;
  }
  if (a2) {
    return;
  }
  *(_DWORD *)a1 = a4.i32[0];
  double v15 = a5;
  double v16 = vmuls_lane_f32(_S21, v12, 1);
  float v56 = a6;
  float v57 = _S21;
  __double2 v18 = __sincos_stret(a8 * 0.785398163);
  double cosval = v18.__cosval;
  float v19 = v15 + v16 * v18.__sinval;
  *(float *)(a1 + 4) = v19;
LABEL_12:
  double v24 = v56 + (float)(v14 * v57) * cosval;
LABEL_19:
  float v51 = v24;
LABEL_20:
  *(float *)(a1 + 8) = v51;
}

void generateChamferQuadProfile(uint64_t a1, int a2, int a3, int a4, float32x4_t a5, float32_t a6, float32_t a7, double a8, float a9, float a10, float a11)
{
  if (a9 >= 4.0)
  {
    if (a9 == 4.0)
    {
      __n128 v20 = (__n128)xmmword_20B5EE3D0;
      long long v21 = xmmword_20B5EE3E0;
    }
    else
    {
      __n128 v20 = (__n128)xmmword_20B5EE3E0;
      long long v21 = xmmword_20B5EE3D0;
    }
    __n128 v63 = (__n128)v21;
  }
  else
  {
    double v17 = a9;
    float v18 = v17 * 1.57079633;
    v20.n128_u32[0] = 0;
    v20.n128_u64[1] = 0;
    LODWORD(v19) = 0;
    *((float *)&v19 + 1) = v18;
    __n128 v63 = (__n128)v19;
    *(float *)&double v17 = v17 * -1.57079633;
    v20.n128_u32[1] = LODWORD(v17);
  }
  a5.f32[1] = a6;
  a5.f32[2] = a7;
  *(float32x2_t *)&v22.__float sinval = C3DVector3EulerRotate(a5, v20);
  float v24 = fabsf(*(float *)&v22.__sinval);
  float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(float32x2_t *)v25.f32 = vabs_f32((float32x2_t)vext_s8(*(int8x8_t *)&v22.__sinval, *(int8x8_t *)v25.f32, 4uLL));
  if (a2 == 3)
  {
    float v29 = *(float *)&a8 / v24;
    if (a4)
    {
      if (a4 != 2)
      {
        if (a4 != 1) {
          goto LABEL_41;
        }
        float v30 = v29 * a11;
LABEL_40:
        *(float *)a1 = v30;
LABEL_41:
        float v39 = 1.0 - a10;
        float v40 = *(float *)&a8 / v25.f32[0];
        if (a3)
        {
          if (a3 != 1)
          {
            float v42 = v39 * v40;
            goto LABEL_47;
          }
          double v41 = v39 + (1.0 - v40) * (1.0 - v39);
        }
        else
        {
          double v41 = (1.0 - v40) * v39 + (1.0 - v39) * v40;
        }
        float v42 = v41;
LABEL_47:
        *(float *)(a1 + 4) = v42;
        return;
      }
      double v38 = a11;
      double v36 = 1.0 - a11;
      double v37 = 1.0 - v29;
    }
    else
    {
      double v36 = 1.0 - a11;
      double v37 = v29;
      double v38 = (1.0 - v37) * a11;
    }
    float v30 = v38 + v36 * v37;
    goto LABEL_40;
  }
  float v26 = v24 * 0.5;
  *(float32x2_t *)&long long v23 = vmul_f32(*(float32x2_t *)v25.f32, (float32x2_t)0x3F0000003F000000);
  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    HIDWORD(v22.__cosval) = v65;
    float v27 = v25.f32[0] + (float)(*(float *)&a8 * -2.0);
    if (a4 != 2)
    {
      if (a4 != 1)
      {
        if (!a4)
        {
          HIDWORD(v22.__cosval) = v65;
          *(float *)&v22.__float sinval = (a11 + -0.5) * (float)(v24 + (float)(*(float *)&a8 * -2.0));
          *(_DWORD *)a1 = LODWORD(v22.__sinval);
          if (a3 != 2)
          {
            if (a3 != 1)
            {
              if (!a3)
              {
                float v28 = (a10 + -0.5) * v27;
                *(float *)(a1 + 4) = v28;
                *(_DWORD *)(a1 + 8) = DWORD1(v23);
              }
              goto LABEL_71;
            }
            double v54 = (float)(*(float *)&a8 - *(float *)&v23);
            float v62 = *((float *)&v23 + 1);
            __double2 v55 = __sincos_stret(a10 * 0.785398163 + -0.785398163);
            *(float *)&v22.__float sinval = v54 + *(float *)&a8 * v55.__sinval;
            double cosval = (float)(v62 - *(float *)&a8) + *(float *)&a8 * v55.__cosval;
            goto LABEL_70;
          }
          float32x2_t v53 = vsub_f32(*(float32x2_t *)&v23, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0));
          __double2 v22 = __sincos_stret(a10 * 0.785398163);
          *(float32x2_t *)&v22.__float sinval = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(v53), (float64x2_t)v22, *(float *)&a8));
          goto LABEL_65;
        }
        goto LABEL_71;
      }
      if (a3 != 2)
      {
        if (a3 != 1)
        {
          if (a3) {
            goto LABEL_71;
          }
          double v31 = (float)(*(float *)&a8 - v26);
          double v32 = *(float *)&a8;
          double v33 = a11 * 0.785398163 + -0.785398163;
LABEL_36:
          long long v61 = v23;
          __double2 v34 = __sincos_stret(v33);
          *(float *)&v22.__float sinval = v31 + v32 * v34.__sinval;
          float v35 = (a10 + -0.5) * v27;
          *(_DWORD *)a1 = LODWORD(v22.__sinval);
          *(float *)(a1 + 4) = v35;
          HIDWORD(v22.__cosval) = HIDWORD(v61);
          *(float *)&v22.__float sinval = (float)(*((float *)&v61 + 1) - *(float *)&a8) + v32 * v34.__cosval;
LABEL_57:
          *(_DWORD *)(a1 + 8) = LODWORD(v22.__sinval);
          goto LABEL_71;
        }
        goto LABEL_62;
      }
      goto LABEL_61;
    }
    if (a3 != 2)
    {
      if (a3 != 1)
      {
        if (a3) {
          goto LABEL_71;
        }
        double v31 = (float)(v26 - *(float *)&a8);
        double v32 = *(float *)&a8;
        double v33 = a11 * 0.785398163;
        goto LABEL_36;
      }
      goto LABEL_59;
    }
LABEL_58:
    float v45 = *(float *)&a8;
    v25.f32[0] = v26 - *(float *)&a8;
    float v46 = *(float *)&v23 - *(float *)&a8;
    float v47 = *((float *)&v23 + 1) - *(float *)&a8;
    float v48 = 7.0;
    uint64_t v49 = a1;
    int v50 = a2;
    float v51 = a10;
LABEL_60:
    float v52 = a11;
LABEL_63:
    generateChamferCornerProfile(v49, v50, v45, v25, v46, v47, v48, v51, v52);
    goto LABEL_71;
  }
  if (a4 == 2)
  {
    if (a3 == 2) {
      goto LABEL_58;
    }
    if (a3 == 1)
    {
LABEL_59:
      float v45 = *(float *)&a8;
      v25.f32[0] = v26 - *(float *)&a8;
      float v46 = *(float *)&a8 - *(float *)&v23;
      float v47 = *((float *)&v23 + 1) - *(float *)&a8;
      float v51 = 1.0 - a10;
      float v48 = 5.0;
      uint64_t v49 = a1;
      int v50 = a2;
      goto LABEL_60;
    }
    if (a3) {
      goto LABEL_71;
    }
    double v43 = a11 * 0.785398163;
LABEL_56:
    __double2 v44 = __sincos_stret(v43);
    *(float *)&v22.__float sinval = v44.__sinval;
    *(_DWORD *)a1 = LODWORD(v22.__sinval);
    *(_DWORD *)(a1 + 4) = 0;
    *(float *)&v22.__float sinval = v44.__cosval;
    goto LABEL_57;
  }
  if (a4 == 1)
  {
    if (a3 == 2)
    {
LABEL_61:
      float v45 = *(float *)&a8;
      v25.f32[0] = *(float *)&a8 - v26;
      float v46 = *(float *)&v23 - *(float *)&a8;
      float v47 = *((float *)&v23 + 1) - *(float *)&a8;
      float v52 = 1.0 - a11;
      float v48 = 6.0;
      uint64_t v49 = a1;
      int v50 = a2;
      float v51 = a10;
      goto LABEL_63;
    }
    if (a3 == 1)
    {
LABEL_62:
      float v45 = *(float *)&a8;
      v25.f32[0] = *(float *)&a8 - v26;
      float v46 = *(float *)&a8 - *(float *)&v23;
      float v47 = *((float *)&v23 + 1) - *(float *)&a8;
      float v51 = 1.0 - a10;
      float v52 = 1.0 - a11;
      float v48 = 4.0;
      uint64_t v49 = a1;
      int v50 = a2;
      goto LABEL_63;
    }
    if (a3) {
      goto LABEL_71;
    }
    double v43 = a11 * 0.785398163 + -0.785398163;
    goto LABEL_56;
  }
  if (a4) {
    goto LABEL_71;
  }
  *(_DWORD *)a1 = 0;
  switch(a3)
  {
    case 2:
      double v57 = a10 * 0.785398163;
LABEL_69:
      __double2 v58 = __sincos_stret(v57);
      double cosval = v58.__cosval;
      *(float *)&v22.__float sinval = v58.__sinval;
LABEL_70:
      float v59 = cosval;
      *(_DWORD *)(a1 + 4) = LODWORD(v22.__sinval);
      *(float *)(a1 + 8) = v59;
      break;
    case 1:
      double v57 = a10 * 0.785398163 + -0.785398163;
      goto LABEL_69;
    case 0:
      v22.__float sinval = 0.0078125;
LABEL_65:
      *(double *)(a1 + 4) = v22.__sinval;
      break;
  }
LABEL_71:
  v22.__float sinval = *(double *)a1;
  LODWORD(v22.__cosval) = *(_DWORD *)(a1 + 8);
  *(float32x2_t *)a1 = C3DVector3EulerRotate((float32x4_t)v22, v63);
  *(_DWORD *)(a1 + 8) = v60;
}

void generatePyramidProfile(uint64_t a1, int a2, float32x4_t a3, float32_t a4, float32_t a5, float a6, double a7, float a8, float a9)
{
  double v13 = a6;
  float v14 = a6 * -1.57079633;
  LODWORD(v15) = 0;
  *((float *)&v15 + 1) = v14;
  a3.f32[1] = a4;
  a3.f32[2] = a5;
  *(float32x2_t *)v16.f32 = C3DVector3EulerRotate(a3, (__n128)v15);
  float v17 = fabsf(v16.f32[1]);
  float v18 = fabsf(v16.f32[2]);
  if (a2)
  {
    if (a2 == 1)
    {
      *(_DWORD *)a1 = 0;
      v16.f32[0] = v18 * 0.5;
      float v22 = sqrtf((float)(v16.f32[1] * v16.f32[1]) + (float)(v16.f32[0] * v16.f32[0]));
      float v20 = v16.f32[0] / v22;
      float v21 = v17 / v22;
      *(float *)(a1 + 4) = v16.f32[0] / v22;
      *(float *)(a1 + 8) = v21;
      v16.i32[0] = 0;
    }
    else
    {
      if (a2 == 3)
      {
        *(float *)a1 = a9;
        *(float *)(a1 + 4) = 1.0 - a8;
        return;
      }
      v16.i32[0] = *(_DWORD *)a1;
      float v20 = *(float *)(a1 + 4);
      float v21 = *(float *)(a1 + 8);
    }
  }
  else
  {
    double v19 = 1.0 - a8;
    v16.f32[0] = (a9 + -0.5) * (v19 * fabsf(v16.f32[0]));
    float v20 = v17 * a8;
    *(_DWORD *)a1 = v16.i32[0];
    *(float *)(a1 + 4) = v17 * a8;
    float v21 = v19 * (v18 * 0.5);
    *(float *)(a1 + 8) = v21;
  }
  float v23 = v13 * 1.57079633;
  LODWORD(v24) = 0;
  *((float *)&v24 + 1) = v23;
  v16.f32[1] = v20;
  v16.f32[2] = v21;
  *(float32x2_t *)a1 = C3DVector3EulerRotate(v16, (__n128)v24);
  *(_DWORD *)(a1 + 8) = v25;
}

uint64_t C3DMeshCreateFromProfile(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), unsigned int a2, int *a3, int a4, int a5, int a6, int *a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  uint64_t v132 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a2))
  {
    unint64_t v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  values[0] = (void *)__CreateSourceFromProfileGenerator(a1, 0, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[1] = (void *)__CreateSourceFromProfileGenerator(a1, 1, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[2] = (void *)__CreateSourceFromProfileGenerator(a1, 3, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  CFTypeRef cf = 0;
  if (!C3DMeshElementTypeDefinesTopology(a2))
  {
    double v32 = scn_default_log();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v32, v33, v34, v35, v36, v37, v38, v39);
    }
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t v123 = (a4 - 1);
  uint64_t v41 = 0;
  if (a4 >= 1)
  {
    float v42 = a3;
    uint64_t v43 = a4;
    do
    {
      uint64_t v44 = *v42++;
      v41 += v44 + 1;
      --v43;
    }
    while (v43);
  }
  CFDataRef v45 = Mutable;
  if (a8 < 1)
  {
    int v51 = 0;
    char v52 = 2;
    goto LABEL_118;
  }
  uint64_t v46 = 0;
  uint64_t v47 = a8;
  float v48 = a7;
  uint64_t v103 = a8;
  do
  {
    uint64_t v49 = *v48++;
    v46 += v49 + 1;
    --v47;
  }
  while (v47);
  int v121 = a5;
  int v110 = v41;
  if (v46 * v41 >= 0x10000)
  {
    uint64_t v73 = 0;
    int v51 = 0;
    int v105 = 0;
    char v52 = 4;
    while (1)
    {
      int v74 = a7[v73];
      if (v74 < 1) {
        goto LABEL_117;
      }
      uint64_t v75 = 0;
      int v114 = v41 * v105;
      int v116 = v41 + v41 * v105;
      uint64_t v107 = v73;
      do
      {
        if (a4 < 1) {
          goto LABEL_116;
        }
        uint64_t v76 = 0;
        int v77 = 0;
        uint64_t v109 = v75;
        uint64_t v118 = v75 | v73;
        do
        {
          int v78 = a3[v76];
          int v120 = v77;
          if (v78 >= 1)
          {
            int v79 = 0;
            if (a6) {
              BOOL v80 = v76 == v123;
            }
            else {
              BOOL v80 = 0;
            }
            int v81 = v80;
            int v82 = v116 + v77;
            int v83 = v114 + v77;
            do
            {
              *(_DWORD *)float32x4_t v130 = v83 + v79;
              *(_DWORD *)&v130[4] = v82 + v79 + 1;
              int v84 = v79 + 1;
              *(_DWORD *)&v130[8] = v83 + v79 + 1;
              v131[0] = v83 + v79;
              v131[1] = v82 + v79;
              v131[2] = *(_DWORD *)&v130[4];
              if (!a5 || v79 | v76)
              {
                if (v84 == v78) {
                  int v87 = v81;
                }
                else {
                  int v87 = 0;
                }
                if (v87 == 1)
                {
                  switch(a2)
                  {
                    case 3u:
                      *(_DWORD *)long long v127 = v83 + v79;
                      *(_DWORD *)&v127[4] = v82 + v79 + 1;
                      goto LABEL_105;
                    case 2u:
                      *(_DWORD *)long long v127 = v83 + v79;
                      *(_DWORD *)&v127[4] = v82 + v79;
                      int v128 = v82 + v79;
                      int v129 = v82 + v79 + 1;
LABEL_101:
                      float32x4_t v89 = v127;
                      int v90 = v45;
                      CFIndex v91 = 16;
LABEL_106:
                      CFDataAppendBytes(v90, v89, v91);
                      CFMutableDictionaryRef Mutable = v45;
                      v51 += 2;
                      break;
                    case 0u:
                      long long v86 = v45;
                      uint64_t v85 = (UInt8 *)v131;
                      goto LABEL_92;
                  }
                }
                else
                {
                  switch(a2)
                  {
                    case 3u:
LABEL_98:
                      *(_DWORD *)long long v127 = v83 + v79;
                      *(_DWORD *)&v127[4] = v83 + v79 + 1;
LABEL_105:
                      float32x4_t v89 = v127;
                      int v90 = v45;
                      CFIndex v91 = 8;
                      goto LABEL_106;
                    case 2u:
                      *(_DWORD *)long long v127 = v83 + v79;
                      *(_DWORD *)&v127[4] = v82 + v79;
                      int v128 = v82 + v79;
                      int v129 = v82 + v79 + 1;
                      uint64_t v92 = Mutable;
                      CFDataAppendBytes(Mutable, v127, 16);
                      if (v118)
                      {
                        v51 += 2;
                      }
                      else
                      {
                        *(_DWORD *)long long v127 = *(_DWORD *)v130;
                        *(_DWORD *)&v127[4] = *(_DWORD *)&v130[8];
                        CFDataAppendBytes(v92, v127, 8);
                        v51 += 3;
                      }
                      a5 = v121;
                      if (v76 != v123 || v79 != a3[v76] - 1)
                      {
                        CFMutableDictionaryRef Mutable = v45;
                        break;
                      }
                      *(void *)long long v127 = *(void *)&v130[4];
                      uint64_t v85 = v127;
                      long long v86 = v45;
                      CFIndex v88 = 8;
                      goto LABEL_93;
                    case 0u:
                      float32x4_t v89 = v130;
                      int v90 = v45;
                      CFIndex v91 = 24;
                      goto LABEL_106;
                  }
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
                    goto LABEL_98;
                  case 2u:
                    *(_DWORD *)long long v127 = v83 + v79;
                    *(_DWORD *)&v127[4] = v82 + v79 + 1;
                    int v128 = v83 + v79;
                    int v129 = v83 + v79 + 1;
                    goto LABEL_101;
                  case 0u:
                    uint64_t v85 = v130;
                    long long v86 = v45;
LABEL_92:
                    CFIndex v88 = 12;
LABEL_93:
                    CFDataAppendBytes(v86, v85, v88);
                    CFMutableDictionaryRef Mutable = v45;
                    ++v51;
                    break;
                }
              }
              int v78 = a3[v76];
              ++v79;
            }
            while (v84 < v78);
          }
          int v77 = v120 + v78 + 1;
          ++v76;
        }
        while (v76 != a4);
        LODWORD(v41) = v110;
        uint64_t v73 = v107;
        uint64_t v75 = v109;
        int v74 = a7[v107];
        char v52 = 4;
LABEL_116:
        ++v75;
        v116 += v41;
        v114 += v41;
      }
      while (v75 < v74);
LABEL_117:
      v105 += v74 + 1;
      if (++v73 == v103) {
        goto LABEL_118;
      }
    }
  }
  uint64_t v50 = 0;
  int v51 = 0;
  __int16 v106 = 0;
  char v52 = 2;
  do
  {
    int v53 = a7[v50];
    if (v53 < 1) {
      goto LABEL_62;
    }
    int v54 = 0;
    uint64_t v104 = v50;
    do
    {
      int v55 = v54 + 1;
      if (a4 < 1) {
        goto LABEL_61;
      }
      uint64_t v56 = 0;
      int v57 = 0;
      BOOL v58 = v50 == 0;
      int v108 = v54 + 1;
      __int16 v113 = (v106 + v55) * v41;
      __int16 v115 = (v106 + v54) * v41;
      if ((_WORD)v54) {
        BOOL v58 = 0;
      }
      BOOL v117 = v58;
      do
      {
        int v59 = a3[v56];
        int v119 = v57;
        if (v59 >= 1)
        {
          int v60 = 0;
          int v61 = 0;
          __int16 v62 = v57 + v115;
          __int16 v63 = v57 + v113;
          do
          {
            *(_WORD *)float32x4_t v130 = v61 + v62;
            int v64 = v61 + 1;
            *(_WORD *)&v130[2] = v61 + 1 + v63;
            *(_WORD *)&v130[4] = v61 + 1 + v62;
            *(_WORD *)&v130[6] = v61 + v62;
            *(_WORD *)&v130[8] = v61 + v63;
            *(_WORD *)&v130[10] = *(_WORD *)&v130[2];
            int v65 = (__int16)(v61 + 1);
            if (v56 || (_WORD)v61 || !a5)
            {
              if (v56 == v123 && a6 && v59 == v65)
              {
                switch(a2)
                {
                  case 3u:
                    *(_WORD *)long long v127 = v61 + v62;
                    *(_WORD *)&v127[2] = v61 + 1 + v63;
                    goto LABEL_48;
                  case 2u:
                    *(_WORD *)long long v127 = v61 + v62;
                    *(_WORD *)&v127[2] = v61 + v63;
                    *(_WORD *)&v127[4] = v61 + v63;
                    *(_WORD *)&v127[6] = v61 + 1 + v63;
LABEL_46:
                    uint64_t v69 = v127;
                    uint64_t v70 = v45;
                    CFIndex v71 = 8;
LABEL_49:
                    CFDataAppendBytes(v70, v69, v71);
                    CFMutableDictionaryRef Mutable = v45;
                    v51 += 2;
                    break;
                  case 0u:
                    uint64_t v67 = v45;
                    uint64_t v66 = &v130[6];
                    goto LABEL_37;
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
LABEL_43:
                    *(_WORD *)long long v127 = v61 + v62;
                    *(_WORD *)&v127[2] = v61 + 1 + v62;
LABEL_48:
                    uint64_t v69 = v127;
                    uint64_t v70 = v45;
                    CFIndex v71 = 4;
                    goto LABEL_49;
                  case 2u:
                    *(_WORD *)long long v127 = v61 + v62;
                    *(_WORD *)&v127[2] = v61 + v63;
                    *(_WORD *)&v127[4] = v61 + v63;
                    *(_WORD *)&v127[6] = v61 + 1 + v63;
                    BOOL v72 = Mutable;
                    CFDataAppendBytes(Mutable, v127, 8);
                    if (v117)
                    {
                      *(_WORD *)long long v127 = *(_WORD *)v130;
                      *(_WORD *)&v127[2] = *(_WORD *)&v130[4];
                      CFDataAppendBytes(v72, v127, 4);
                      v51 += 3;
                    }
                    else
                    {
                      v51 += 2;
                    }
                    a5 = v121;
                    if (v56 != v123 || a3[v56] - 1 != v60)
                    {
                      CFMutableDictionaryRef Mutable = v45;
                      break;
                    }
                    *(_DWORD *)long long v127 = *(_DWORD *)&v130[2];
                    uint64_t v66 = v127;
                    uint64_t v67 = v45;
                    CFIndex v68 = 4;
                    goto LABEL_38;
                  case 0u:
                    uint64_t v69 = v130;
                    uint64_t v70 = v45;
                    CFIndex v71 = 12;
                    goto LABEL_49;
                }
              }
            }
            else
            {
              switch(a2)
              {
                case 3u:
                  goto LABEL_43;
                case 2u:
                  *(_WORD *)long long v127 = v61 + v62;
                  *(_WORD *)&v127[2] = v61 + 1 + v63;
                  *(_WORD *)&v127[4] = v61 + v62;
                  *(_WORD *)&v127[6] = v61 + 1 + v62;
                  goto LABEL_46;
                case 0u:
                  uint64_t v66 = v130;
                  uint64_t v67 = v45;
LABEL_37:
                  CFIndex v68 = 6;
LABEL_38:
                  CFDataAppendBytes(v67, v66, v68);
                  CFMutableDictionaryRef Mutable = v45;
                  ++v51;
                  break;
              }
            }
            int v59 = a3[v56];
            int v60 = v65;
            int v61 = v64;
          }
          while (v59 > (__int16)v64);
        }
        int v57 = v119 + v59 + 1;
        ++v56;
      }
      while (v56 != a4);
      LOWORD(v41) = v110;
      uint64_t v50 = v104;
      int v53 = a7[v104];
      char v52 = 2;
      int v55 = v108;
LABEL_61:
      int v54 = v55;
    }
    while (v53 > (__int16)v55);
LABEL_62:
    v106 += v53 + 1;
    ++v50;
  }
  while (v50 != v103);
LABEL_118:
  uint64_t v93 = (const void *)C3DMeshElementCreate();
  C3DMeshElementSetDoubleSided((uint64_t)v93, 0);
  CFDataRef Copy = CFDataCreateCopy(allocator, v45);
  C3DMeshElementInit((uint64_t)v93, a2, v51, Copy, v52);
  CFRelease(Copy);
  CFRelease(v45);
  CFTypeRef cf = v93;
  v130[2] = 0;
  *(_WORD *)float32x4_t v130 = 0;
  float32x4_t v95 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  CFArrayRef v96 = CFArrayCreate(allocator, (const void **)values, 3, MEMORY[0x263EFFF70]);
  CFArrayRef v97 = CFArrayCreate(allocator, &cf, 1, v95);
  uint64_t v98 = C3DMeshCreateWithMeshSourcesAndMeshElements(v96, v97, (uint64_t)v130);
  CFRelease(v96);
  CFRelease(v97);
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  for (uint64_t i = 0; i != 3; ++i)
  {
    float32x4_t v100 = values[i];
    if (v100)
    {
      CFRelease(v100);
      values[i] = 0;
    }
  }
  return v98;
}

uint64_t __CreateSourceFromProfileGenerator(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), uint64_t a2, int *a3, int a4, int *a5, int a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v23 = a4;
  int v24 = a4;
  if (a4 >= 1)
  {
    uint64_t v25 = a4;
    uint64_t v26 = a3;
    int v24 = a4;
    do
    {
      int v27 = *v26++;
      v24 += v27;
      --v25;
    }
    while (v25);
  }
  uint64_t v48 = a6;
  int v28 = a6;
  if (a6 >= 1)
  {
    uint64_t v29 = a6;
    uint64_t v30 = a5;
    int v28 = a6;
    do
    {
      int v31 = *v30++;
      v28 += v31;
      --v29;
    }
    while (v29);
  }
  if (a2 == 3) {
    uint64_t v32 = 2;
  }
  else {
    uint64_t v32 = 3;
  }
  int v46 = v28 * v24;
  uint64_t v47 = v32;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 4 * v28 * v24 * (int)v32);
  if (a6 >= 1)
  {
    uint64_t v34 = 0;
    do
    {
      int v35 = a5[v34];
      if ((v35 & 0x80000000) == 0)
      {
        int v36 = 0;
        do
        {
          if (a4 >= 1)
          {
            uint64_t v37 = 0;
            int v50 = v36;
            float v38 = (float)v36 * a12;
            do
            {
              int v39 = a3[v37];
              if ((v39 & 0x80000000) == 0)
              {
                int v40 = -1;
                do
                {
                  a1(bytes, a2, v37, v34, a7, a8, a9, a10, a11, (float)((float)++v40 / (float)v39) + 0.0, (float)(v38 / (float)a5[v34]) + 0.0);
                  CFDataAppendBytes(Mutable, bytes, (4 * v47));
                  int v39 = a3[v37];
                }
                while (v40 < v39);
              }
              ++v37;
            }
            while (v37 != v23);
            int v35 = a5[v34];
            int v36 = v50;
          }
        }
        while (v36++ < v35);
      }
      ++v34;
    }
    while (v34 != v48);
  }
  CFDataRef Copy = CFDataCreateCopy(allocator, Mutable);
  uint64_t v43 = C3DMeshSourceCreate(Copy, a2, v46, v47, 1);
  CFRelease(Mutable);
  CFRelease(Copy);
  return v43;
}

uint64_t C3DMeshCreateRing(unsigned int a1, int a2, float a3, float a4, float a5, double a6)
{
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    float32x2_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  int v22 = a2;
  int v23 = 1;
  float v20 = a6;
  return C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateRingProfile, a1, &v23, 1, 0, a4 == 0.0, &v22, 1, a3, a4, a5, 0.0, 0.0, v20);
}

uint64_t C3DMeshCreateSphere(unsigned int a1, uint64_t a2, int a3, double a4, double a5)
{
  values[3] = *(void **)MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    long long v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  if (a4 <= 0.0) {
    return 0;
  }
  if (a3 == 1) {
    return C3DMeshCreateGeosphere(a1, a2, a4);
  }
  int v36 = a2;
  if (a5 == 1.0)
  {
    float v21 = 0.5;
    if (a3 != 2) {
      float v21 = 0.0;
    }
    float v20 = a4;
    return C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateSphereProfile, a1, &v36, 1, a3 != 2, 1, &v36, 1, v20, v21, 1.0, 0.0, 0.0, 1.0);
  }
  float v23 = a4;
  float v24 = 0.0;
  if (a3 == 2)
  {
    float v24 = 0.5;
    double v26 = 0.25;
  }
  else
  {
    double v26 = 0.5;
  }
  float v25 = a5;
  values[0] = (void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateSphereProfile, a1, &v36, 1, a3 != 2, 1, &v36, 1, v23, v24, 1.0, 0.0, 0.0, v25);
  Ring = (const void *)C3DMeshCreateRing(a1, a2, v23, 0.0, 0.0, v26);
  memset(v35, 0, sizeof(v35));
  long long v34 = xmmword_20B5EE3F0;
  C3DMatrix4x4MakeEulerRotation(v35, &v34);
  int v28 = (void *)C3DMeshCopyWithTransform((uint64_t)Ring, v35);
  values[1] = v28;
  if (Ring) {
    CFRelease(Ring);
  }
  float v30 = (1.0 - a5) * 6.28318531;
  LODWORD(v29) = 0;
  *((float *)&v29 + 1) = v30;
  DWORD2(v29) = 1078530011;
  long long v34 = v29;
  C3DMatrix4x4MakeEulerRotation(v35, &v34);
  values[2] = (void *)C3DMeshCopyWithTransform((uint64_t)v28, v35);
  CFArrayRef v31 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)values, 3, MEMORY[0x263EFFF70]);
  uint64_t v19 = C3DMeshCreateByMergingMeshes(v31);
  CFRelease(v31);
  for (uint64_t i = 0; i != 3; ++i)
  {
    uint64_t v33 = values[i];
    if (v33)
    {
      CFRelease(v33);
      values[i] = 0;
    }
  }
  return v19;
}

uint64_t C3DMeshCreateCylinder(unsigned int a1, int a2, uint64_t a3, double a4, double a5, double a6)
{
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  if (a4 <= 0.0) {
    return 0;
  }
  int v49 = a2;
  int v50 = a3;
  float v20 = (const void **)malloc_type_calloc(5uLL, 8uLL, 0x2004093837F09uLL);
  if (a5 <= 0.0)
  {
    unsigned int v23 = 0;
  }
  else
  {
    float v21 = a5;
    float v22 = a6;
    unsigned int v23 = 1;
    float v24 = a4;
    *float v20 = (const void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateCylinderProfile, a1, &v50, 1, 0, 0, &v49, 1, v24, v21, 0.0, 0.0, 0.0, v22);
  }
  float v26 = a5 * 0.5;
  float v27 = a4;
  unsigned int v28 = v23 + 1;
  v20[v23] = (const void *)C3DMeshCreateRing(a1, a2, v27, 0.0, v26, a6);
  if (a5 > 0.0)
  {
    float v29 = a5 * -0.5;
    float v30 = a4;
    Ring = (const void *)C3DMeshCreateRing(a1, a2, v30, 0.0, v29, a6);
    LODWORD(v32) = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    __n128 v45 = 0u;
    long long v46 = 0u;
    float v33 = a6 * 6.28318531;
    *((float *)&v32 + 1) = v33;
    long long v44 = v32;
    C3DMatrix4x4MakeEulerRotation((float32x4_t *)&v45, &v44);
    uint64_t v34 = v23 | 2;
    v20[v28] = (const void *)C3DMeshCopyWithTransform((uint64_t)Ring, (float32x4_t *)&v45);
    if (Ring) {
      CFRelease(Ring);
    }
    if (a6 >= 1.0)
    {
      unsigned int v28 = v23 | 2;
    }
    else
    {
      uint64_t Plane = (const void *)C3DMeshCreatePlane(a1, 1, a3, 0, a4, a5, 0.0);
      long long v47 = 0u;
      long long v48 = 0u;
      __n128 v45 = 0u;
      long long v46 = 0u;
      long long v44 = xmmword_20B5EE400;
      C3DMatrix4x4MakeEulerRotation((float32x4_t *)&v45, &v44);
      *(float *)&unsigned int v36 = a4 * -0.5;
      v37.n128_u64[0] = 0;
      v37.n128_u64[1] = v36;
      C3DMatrix4x4SetTranslation(&v45, v37);
      uint64_t v38 = C3DMeshCopyWithTransform((uint64_t)Plane, (float32x4_t *)&v45);
      v20[v34] = (const void *)v38;
      if (Plane)
      {
        CFRelease(Plane);
        uint64_t v38 = (uint64_t)v20[v34];
      }
      unsigned int v28 = v23 | 4;
      v20[v23 + 3] = (const void *)CreateRadialSpanSide(v38, a6, v39);
    }
  }
  CFArrayRef v40 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v20, v28, MEMORY[0x263EFFF70]);
  uint64_t v25 = C3DMeshCreateByMergingMeshes(v40);
  CFRelease(v40);
  uint64_t v41 = 0;
  do
  {
    float v42 = v20[v41];
    if (v42)
    {
      CFRelease(v42);
      v20[v41] = 0;
    }
    ++v41;
  }
  while (v28 != v41);
  free(v20);
  return v25;
}

uint64_t C3DMeshCreateCone(unsigned int a1, int a2, int a3, double a4, double a5, double a6)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t v20 = 0;
  if (a4 >= 0.0 && a5 >= 0.0)
  {
    uint64_t v20 = 0;
    BOOL v21 = a5 == 0.0 && a4 == 0.0;
    if (!v21 && a6 > 0.0)
    {
      int v39 = a2;
      int v40 = a3;
      BOOL v22 = a4 <= 0.0;
      float v23 = a4;
      if (v22)
      {
        uint64_t Ring = 0;
      }
      else
      {
        float v24 = a6 * 0.5;
        uint64_t Ring = C3DMeshCreateRing(a1, a2, v23, 0.0, v24, 1.0);
      }
      if (a5 <= 0.0)
      {
        uint64_t v28 = 0;
      }
      else
      {
        float v26 = a6 * -0.5;
        float v27 = a5;
        uint64_t v28 = C3DMeshCreateRing(a1, a2, v27, 0.0, v26, 1.0);
      }
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      float v29 = a6;
      float v30 = a5;
      values = (void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateConeProfile, a1, &v40, 1, v28 == 0, Ring == 0, &v39, 1, v23, v30, v29, 0.0, 0.0, 1.0);
      if (Ring && v28)
      {
        uint64_t v42 = Ring;
        uint64_t v31 = 3;
        CFIndex v32 = 2;
      }
      else
      {
        CFIndex v32 = 1;
        uint64_t v33 = Ring | v28;
        if (Ring) {
          uint64_t v28 = Ring;
        }
        if (!v33) {
          goto LABEL_25;
        }
        uint64_t v31 = 2;
      }
      *(&values + v32) = (void *)v28;
      CFIndex v32 = v31;
LABEL_25:
      CFArrayRef v34 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)&values, v32, MEMORY[0x263EFFF70]);
      uint64_t v20 = C3DMeshCreateByMergingMeshes(v34);
      CFRelease(v34);
      uint64_t v35 = 0;
      uint64_t v36 = 8 * v32;
      do
      {
        __n128 v37 = *(void **)((char *)&values + v35);
        if (v37)
        {
          CFRelease(v37);
          *(void **)((char *)&values + v35) = 0;
        }
        v35 += 8;
      }
      while (v36 != v35);
    }
  }
  return v20;
}

uint64_t C3DMeshCreateTube(unsigned int a1, int a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  uint64_t v22 = 0;
  if (a4 <= a5 && a4 >= 0.0 && a5 > 0.0)
  {
    float v23 = (const void **)malloc_type_calloc(6uLL, 8uLL, 0x2004093837F09uLL);
    if (a6 <= 0.0)
    {
      uint64_t v29 = 0;
      float v24 = a5;
      float v27 = a4;
    }
    else
    {
      v46.n128_u32[0] = a2;
      LODWORD(v45) = a3;
      float v24 = a5;
      float v25 = a6;
      float v26 = a7;
      const void *v23 = (const void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateCylinderProfile, a1, (int *)&v45, 1, 0, 0, (int *)&v46, 1, v24, v25, 0.0, 0.0, 0.0, v26);
      float v27 = a4;
      float v28 = a7;
      v23[1] = (const void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateCylinderProfile, a1, (int *)&v45, 1, 0, 0, (int *)&v46, 1, -v27, -v25, 0.0, 0.0, 0.0, v28);
      uint64_t v29 = 2;
    }
    float v30 = a6 * 0.5;
    CFIndex v31 = v29 | 1;
    v23[v29] = (const void *)C3DMeshCreateRing(a1, a2, v24, v27, v30, a7);
    if (a6 > 0.0)
    {
      float v32 = a6 * -0.5;
      uint64_t Ring = (const void *)C3DMeshCreateRing(a1, a2, v24, v27, v32, a7);
      LODWORD(v34) = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      __n128 v46 = 0u;
      long long v47 = 0u;
      float v35 = a7 * 6.28318531;
      *((float *)&v34 + 1) = v35;
      long long v45 = v34;
      C3DMatrix4x4MakeEulerRotation((float32x4_t *)&v46, &v45);
      v23[v31] = (const void *)C3DMeshCopyWithTransform((uint64_t)Ring, (float32x4_t *)&v46);
      if (Ring) {
        CFRelease(Ring);
      }
      if (a7 >= 1.0)
      {
        CFIndex v31 = v29 + 2;
      }
      else
      {
        uint64_t Plane = (const void *)C3DMeshCreatePlane(a1, 1, a3, 0, a5 - a4, a6, 0.0);
        long long v48 = 0u;
        long long v49 = 0u;
        __n128 v46 = 0u;
        long long v47 = 0u;
        long long v45 = xmmword_20B5EE400;
        C3DMatrix4x4MakeEulerRotation((float32x4_t *)&v46, &v45);
        *(float *)&unsigned int v37 = (a4 + a5) * -0.5;
        v38.n128_u64[0] = 0;
        v38.n128_u64[1] = v37;
        C3DMatrix4x4SetTranslation(&v46, v38);
        uint64_t v39 = C3DMeshCopyWithTransform((uint64_t)Plane, (float32x4_t *)&v46);
        v23[v29 + 2] = (const void *)v39;
        CFIndex v31 = v29 | 4;
        v23[v29 + 3] = (const void *)CreateRadialSpanSide(v39, a7, v40);
        CFRelease(Plane);
      }
    }
    CFArrayRef v41 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v23, v31, MEMORY[0x263EFFF70]);
    uint64_t v22 = C3DMeshCreateByMergingMeshes(v41);
    CFRelease(v41);
    uint64_t v42 = 0;
    do
    {
      uint64_t v43 = v23[v42];
      if (v43)
      {
        CFRelease(v43);
        v23[v42] = 0;
      }
      ++v42;
    }
    while (v31 != v42);
    free(v23);
  }
  return v22;
}

uint64_t C3DMeshCreateCapsule(unsigned int a1, int a2, int a3, int a4, double a5, double a6)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t result = 0;
  if (a5 > 0.0 && a6 > 0.0)
  {
    double v21 = a6 * 0.5;
    if (a6 * 0.5 > a5) {
      double v21 = a5;
    }
    v25[0] = a4;
    v25[1] = a3;
    v25[2] = a4;
    int v24 = a2;
    float v22 = v21;
    float v23 = a6;
    return C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateCapsuleProfile, a1, v25, 3, 1, 1, &v24, 1, v22, v23, 0.0, 0.0, 0.0, 1.0);
  }
  return result;
}

uint64_t C3DMeshCreateTorus(unsigned int a1, int a2, int a3, double a4, double a5, double a6)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t v20 = 0;
  if (a4 > 0.0 && a5 > 0.0)
  {
    int v35 = a2;
    int v36 = a3;
    if (a6 == 1.0)
    {
      float v21 = a4;
      float v22 = a5;
      return C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateTorusProfile, a1, &v36, 1, 0, 0, &v35, 1, v21, v22, 0.0, 0.0, 0.0, 1.0);
    }
    else
    {
      float v23 = a4;
      float v24 = a5;
      float v25 = a6;
      values = (void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateTorusProfile, a1, &v36, 1, 0, 0, &v35, 1, v23, v24, 0.0, 0.0, 0.0, v25);
      uint64_t Ring = C3DMeshCreateRing(a1, a3, v24, 0.0, 0.0, 1.0);
      memset(v34, 0, sizeof(v34));
      long long v33 = xmmword_20B5EE410;
      C3DMatrix4x4MakeEulerRotation(v34, &v33);
      v27.n128_u64[0] = 0;
      v27.n128_u32[3] = 0;
      v27.n128_f32[2] = -v23;
      C3DMatrix4x4SetTranslation((__n128 *)v34, v27);
      uint64_t v38 = C3DMeshCopyWithTransform(Ring, v34);
      uint64_t RadialSpanSide = CreateRadialSpanSide(v38, a6, v28);
      CFArrayRef v29 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)&values, 3, MEMORY[0x263EFFF70]);
      uint64_t v20 = C3DMeshCreateByMergingMeshes(v29);
      CFRelease(v29);
      for (uint64_t i = 0; i != 24; i += 8)
      {
        CFIndex v31 = *(void **)((char *)&values + i);
        if (v31)
        {
          CFRelease(v31);
          *(void **)((char *)&values + i) = 0;
        }
      }
    }
  }
  return v20;
}

uint64_t C3DMeshCreateChamferBox(unsigned int a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6, double a7, double a8, double a9, double a10)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
    }
  }
  uint64_t v27 = 0;
  if (a7 >= 0.0 && a8 >= 0.0 && a9 >= 0.0 && a10 >= 0.0)
  {
    uint64_t v28 = 0;
    double v29 = a7 * 0.5;
    if (a7 * 0.5 >= a8 * 0.5) {
      double v29 = a8 * 0.5;
    }
    double v30 = a9 * 0.5;
    if (v29 < a9 * 0.5) {
      double v30 = v29;
    }
    if (v30 > a10) {
      double v30 = a10;
    }
    if (a5 >= 0) {
      unint64_t v31 = a5;
    }
    else {
      unint64_t v31 = a5 + 1;
    }
    unint64_t v32 = v31 >> 1;
    if ((unint64_t)(a5 + 1) < 3) {
      LODWORD(v32) = 1;
    }
    v70[1] = v32;
    v70[2] = v32;
    v69[1] = v32;
    v69[2] = v32;
    if (v30 == 0.0) {
      int v33 = 1;
    }
    else {
      int v33 = 3;
    }
    *(_OWORD *)values = 0u;
    long long v66 = 0u;
    v70[0] = a3;
    float v34 = a7;
    float v35 = a8;
    float v36 = a9;
    float v37 = v30;
    do
    {
      if ((v28 & 0x7FFFFFFD) != 0) {
        int v38 = a4;
      }
      else {
        int v38 = a2;
      }
      v69[0] = v38;
      values[v28] = (void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateChamferQuadProfile, a1, v70, v33, 0, 0, v69, v33, v34, v35, v36, v37, (float)(int)v28, 1.0);
      ++v28;
    }
    while (v28 != 4);
    v70[0] = a4;
    v69[0] = a2;
    uint64_t v67 = C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateChamferQuadProfile, a1, v70, v33, 0, 0, v69, v33, v34, v35, v36, v37, 4.0, 1.0);
    uint64_t v68 = C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generateChamferQuadProfile, a1, v70, v33, 0, 0, v69, v33, v34, v35, v36, v37, 5.0, 1.0);
    CFArrayRef v39 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)values, 6, MEMORY[0x263EFFF70]);
    uint64_t v27 = C3DMeshCreateByMergingMeshes(v39);
    CFRelease(v39);
    if (a6)
    {
      uint64_t v61 = v27;
      CFArrayRef theArray = (const __CFArray *)C3DMeshGetMeshElements(v27, 0);
      uint64_t v40 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 6, MEMORY[0x263EFFF70]);
      uint64_t v42 = CFArrayCreateMutable(0, 6, v40);
      uint64_t v43 = 0;
      unint64_t v44 = 0;
      int v45 = 0;
      char v46 = 4;
      uint64_t v47 = 1;
      do
      {
        int v48 = 1 << ((a6 >> (4 * v44)) & 0xF);
        if ((v48 & v45) != 0)
        {
          ++v43;
        }
        else
        {
          int v62 = v45;
          CFArrayRemoveAllValues(Mutable);
          ValueAtuint64_t Index = CFArrayGetValueAtIndex(theArray, v44);
          CFArrayAppendValue(Mutable, ValueAtIndex);
          if (v44 <= 4)
          {
            char v50 = v46;
            CFIndex v51 = v47;
            do
            {
              if (((a6 >> (4 * v44)) & 0xF) == ((a6 >> v50) & 0xF))
              {
                uint64_t v52 = CFArrayGetValueAtIndex(theArray, v51);
                CFArrayAppendValue(Mutable, v52);
              }
              ++v51;
              v50 += 4;
            }
            while (v51 != 6);
          }
          if (CFArrayGetCount(Mutable) < 2)
          {
            int v54 = CFArrayGetValueAtIndex(Mutable, 0);
            CFTypeRef v53 = CFRetain(v54);
          }
          else
          {
            CFTypeRef v53 = (CFTypeRef)C3DMeshElementCreateByMergingElements(Mutable);
          }
          int v55 = v53;
          if (v43 >= 1)
          {
            do
            {
              EmptyElement = (const void *)C3DMeshElementGetEmptyElement();
              CFArrayAppendValue(v42, EmptyElement);
              --v43;
            }
            while (v43);
          }
          if (!v55)
          {
            CFRelease(v42);
            CFRelease(Mutable);
            uint64_t v27 = v61;
            goto LABEL_48;
          }
          int v45 = v62 | v48;
          CFArrayAppendValue(v42, v55);
          CFRelease(v55);
          uint64_t v43 = 0;
        }
        ++v47;
        v46 += 4;
      }
      while (v44++ < 5);
      CFRelease(Mutable);
      uint64_t v27 = v61;
      if (v42)
      {
        C3DMeshSetMeshElements(v61, v42);
        CFRelease(v42);
      }
    }
LABEL_48:
    for (uint64_t i = 0; i != 6; ++i)
    {
      int v59 = values[i];
      if (v59)
      {
        CFRelease(v59);
        values[i] = 0;
      }
    }
  }
  return v27;
}

uint64_t C3DMeshCreatePyramid(unsigned int a1, uint64_t a2, __int32 a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (!C3DMeshElementTypeDefinesTopology(a1))
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshCreateFromProfile_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  uint64_t v22 = 0;
  *(_OWORD *)values = 0u;
  long long v36 = 0u;
  float v24 = a6;
  do
  {
    v34[0].i32[0] = a3;
    if (v22) {
      int v26 = a4;
    }
    else {
      int v26 = a2;
    }
    LODWORD(v33) = v26;
    float v23 = a5;
    float v25 = a7;
    values[v22] = (void *)C3DMeshCreateFromProfile((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))generatePyramidProfile, a1, (int *)v34, 1, 0, 1, (int *)&v33, 1, v23, v24, v25, (float)(int)v22, 0.0, 1.0);
    ++v22;
  }
  while (v22 != 4);
  uint64_t Plane = (const void *)C3DMeshCreatePlane(a1, a2, a4, 0, a5, a7, 0.0);
  memset(v34, 0, sizeof(v34));
  long long v33 = xmmword_20B5EE3D0;
  C3DMatrix4x4MakeEulerRotation(v34, &v33);
  uint64_t v37 = C3DMeshCopyWithTransform((uint64_t)Plane, v34);
  if (Plane) {
    CFRelease(Plane);
  }
  CFArrayRef v28 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)values, 5, MEMORY[0x263EFFF70]);
  uint64_t v29 = C3DMeshCreateByMergingMeshes(v28);
  CFRelease(v28);
  for (uint64_t i = 0; i != 5; ++i)
  {
    unint64_t v31 = values[i];
    if (v31)
    {
      CFRelease(v31);
      values[i] = 0;
    }
  }
  return v29;
}

void sub_20B43E5CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B43E898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void *_commonAncessor_0(void *a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v2 = [a1 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  float v4 = 0;
  uint64_t v5 = *(void *)v11;
  do
  {
    for (uint64_t i = 0; i != v3; ++i)
    {
      if (*(void *)v11 != v5) {
        objc_enumerationMutation(a1);
      }
      long long v7 = *(void **)(*((void *)&v10 + 1) + 8 * i);
      if (v4)
      {
        while (!v7)
        {
LABEL_11:
          float v4 = (void *)[v4 parentNode];
          if (!v4) {
            return v4;
          }
        }
        long long v8 = v7;
        while (v8 != v4)
        {
          long long v8 = (void *)[v8 parentNode];
          if (!v8) {
            goto LABEL_11;
          }
        }
      }
      else
      {
        float v4 = *(void **)(*((void *)&v10 + 1) + 8 * i);
      }
    }
    uint64_t v3 = [a1 countByEnumeratingWithState:&v10 objects:v14 count:16];
  }
  while (v3);
  return v4;
}

void C3DSubdivInitializeIfNeeded(void)
{
  if (C3DSubdivInitializeIfNeeded(void)::onceToken != -1) {
    dispatch_once(&C3DSubdivInitializeIfNeeded(void)::onceToken, &__block_literal_global_85);
  }
}

void *___Z27C3DSubdivInitializeIfNeededv_block_invoke()
{
  OpenSubdiv::v3_1_1::Far::SetErrorCallback(_C3DSubdivErrorCallbackFunc);

  return OpenSubdiv::v3_1_1::Far::SetWarningCallback(_C3DSubdivWarningCallbackFunc, v0);
}

void _C3DSubdivErrorCallbackFunc()
{
  CFAllocatorRef v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    _C3DSubdivErrorCallbackFunc();
  }
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_2();
  OUTLINED_FUNCTION_1_4(&dword_20B249000, v0, v1, "Error (OpenSubdiv): %s", v2, v3, v4, v5, v6);
}

void _C3DSubdivWarningCallbackFunc(const char *a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  uint64_t v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    float v4 = a1;
    _os_log_impl(&dword_20B249000, v2, OS_LOG_TYPE_DEFAULT, "Warning (OpenSubdiv): %s", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t C3DSubdivSourceSemanticCanBePrimvar(int a1, uint64_t a2, unsigned int a3)
{
  if (a1 == 4) {
    unsigned int v3 = a3;
  }
  else {
    unsigned int v3 = 0;
  }
  if (a2) {
    unsigned int v3 = 0;
  }
  if ((a1 & 0xFE) == 2) {
    unsigned int v3 = 1;
  }
  if (a1) {
    return v3;
  }
  else {
    return a2 == 0;
  }
}

uint64_t C3DGeometryOsdGetPrimvarDataTypeHash(__C3DGeometry *a1)
{
  uint64_t result = C3DGeometryInitSubdivTopologyInfoIfNeeded(a1);
  if (result)
  {
    var7 = a1->var10.var7;
    v27[0] = MEMORY[0x263EF8330];
    v27[1] = 0x40000000;
    CFArrayRef v28 = __C3DGeometryOsdGetPrimvarDataTypeHash_block_invoke;
    uint64_t v29 = &__block_descriptor_tmp_2_2;
    double v30 = var7;
    uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a1);
    uint64_t v5 = Mesh;
    uint64_t v6 = var7[10];
    uint64_t v7 = var7[11];
    if (v6 != v7)
    {
      char v8 = -1;
      do
      {
        if (*(_DWORD *)(v6 + 12) == 3)
        {
          if (v8 == -1)
          {
            char v8 = *(unsigned char *)(v6 + 8);
          }
          else if (*(unsigned __int8 *)(v6 + 8) != v8)
          {
            int v26 = 1;
            goto LABEL_11;
          }
        }
        v6 += 16;
      }
      while (v6 != v7);
    }
    int v26 = 0;
LABEL_11:
    SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 2, 0, 0);
    int v10 = v26 & 0xFFFFFFF9 | (2 * (v28((uint64_t)v27, (uint64_t)SourceWithSemanticAtIndex) & 3));
    long long v11 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 0, 0);
    int v12 = v10 & 0xFFFFFFE7 | (8 * (v28((uint64_t)v27, (uint64_t)v11) & 3));
    long long v13 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 1, 0);
    int v14 = v12 & 0xFFFFFF9F | (32 * (v28((uint64_t)v27, (uint64_t)v13) & 3));
    uint64_t v15 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 2, 0);
    int v16 = v14 & 0xFFFFFE7F | ((v28((uint64_t)v27, (uint64_t)v15) & 3) << 7);
    uint64_t v17 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 3, 0);
    char v18 = v28((uint64_t)v27, (uint64_t)v17);
    uint64_t v19 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 4, 0);
    char v20 = v28((uint64_t)v27, (uint64_t)v19);
    uint64_t v21 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 5, 0);
    int v22 = (v28((uint64_t)v27, (uint64_t)v21) & 3) << 13;
    float v23 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 6, 0);
    int v24 = (v28((uint64_t)v27, (uint64_t)v23) & 3) << 15;
    float v25 = C3DMeshGetSourceWithSemanticAtIndex(v5, 3, 7, 0);
    return v16 & 0xFFFFE1FF | ((v18 & 3) << 9) & 0xE7FF | ((v20 & 3) << 11) | v22 | v24 | ((v28((uint64_t)v27, (uint64_t)v25) & 3) << 17);
  }
  return result;
}

BOOL C3DGeometryInitSubdivTopologyInfoIfNeeded(__C3DGeometry *a1)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  if (a1->var10.var7) {
    return 1;
  }
  uint64_t Mesh = C3DGeometryGetMesh((uint64_t)a1);
  if (C3DMeshGetSourcesCountForSemantic(Mesh, 0) == 1)
  {
    unsigned int v3 = malloc_type_calloc(1uLL, 0xD8uLL, 0x10F004000FC2A7CuLL);
    a1->var10.var7 = v3;
    SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 0, 0, 0);
    uint64_t Content = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
    uint64_t v7 = v6;
    std::vector<int>::size_type v8 = v6;
    uint64_t v112 = v6;
    uint64_t v113 = Mesh;
    if (C3DMeshUsesSameChannelForAllSources(Mesh, 0))
    {
      if (a1->var10.var2.var0)
      {
        if (C3DGeometryGetEffectiveDataKindForRendering(a1))
        {
          *unsigned int v3 = 2;
          uint64_t v118 = 0;
          uint64_t v119 = 0;
          BOOL v117 = (uint64_t *)&v118;
          if (v7)
          {
            uint64_t v12 = 0;
            do
            {
              *(double *)v13.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(Content + BYTE5(v7) * v12), v9, v10, v11);
              float32x4_t v120 = v13;
              int v121 = v119;
              int v14 = _ZNSt3__16__treeINS_12__value_typeIDv3_fjEENS_19__map_value_compareIS2_S3_30__C3DSubdivWelderKeyComparatorLb1EEENS_9allocatorIS3_EEE25__emplace_unique_key_argsIS2_JNS_4pairIS2_jEEEEENSB_INS_15__tree_iteratorIS3_PNS_11__tree_nodeIS3_PvEElEEbEERKT_DpOT0_(&v117, &v120, (uint64_t)&v120);
              v120.i8[0] = v15 ^ 1;
              int v16 = *((_DWORD *)v14 + 12);
              char v18 = (char *)*((void *)v3 + 2);
              unint64_t v17 = *((void *)v3 + 3);
              if ((unint64_t)v18 >= v17)
              {
                uint64_t v21 = (char *)*((void *)v3 + 1);
                uint64_t v22 = (v18 - v21) >> 2;
                unint64_t v23 = v22 + 1;
                if ((unint64_t)(v22 + 1) >> 62) {
                  goto LABEL_157;
                }
                uint64_t v24 = v17 - (void)v21;
                if (v24 >> 1 > v23) {
                  unint64_t v23 = v24 >> 1;
                }
                if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v25 = v23;
                }
                if (v25)
                {
                  int v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 24), v25);
                  uint64_t v21 = (char *)*((void *)v3 + 1);
                  char v18 = (char *)*((void *)v3 + 2);
                }
                else
                {
                  int v26 = 0;
                }
                uint64_t v27 = &v26[4 * v22];
                *(_DWORD *)uint64_t v27 = v16;
                uint64_t v19 = v27 + 4;
                if (v18 == v21)
                {
                  uint64_t v20 = v112;
                }
                else
                {
                  uint64_t v20 = v112;
                  do
                  {
                    int v28 = *((_DWORD *)v18 - 1);
                    v18 -= 4;
                    *((_DWORD *)v27 - 1) = v28;
                    v27 -= 4;
                  }
                  while (v18 != v21);
                }
                *((void *)v3 + 1) = v27;
                *((void *)v3 + 2) = v19;
                *((void *)v3 + 3) = &v26[4 * v25];
                if (v21) {
                  operator delete(v21);
                }
              }
              else
              {
                *(_DWORD *)char v18 = v16;
                uint64_t v19 = v18 + 4;
                uint64_t v20 = v112;
              }
              *((void *)v3 + 2) = v19;
              std::vector<BOOL>::push_back((uint64_t)(v3 + 56), &v120);
              if (v120.i8[0])
              {
                *unsigned int v3 = 3;
              }
              else
              {
                double v30 = (char *)*((void *)v3 + 5);
                unint64_t v29 = *((void *)v3 + 6);
                if ((unint64_t)v30 >= v29)
                {
                  unint64_t v32 = (char *)*((void *)v3 + 4);
                  uint64_t v33 = (v30 - v32) >> 2;
                  unint64_t v34 = v33 + 1;
                  if ((unint64_t)(v33 + 1) >> 62) {
                    goto LABEL_157;
                  }
                  uint64_t v35 = v29 - (void)v32;
                  if (v35 >> 1 > v34) {
                    unint64_t v34 = v35 >> 1;
                  }
                  if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v36 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v36 = v34;
                  }
                  if (v36)
                  {
                    uint64_t v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 48), v36);
                    unint64_t v32 = (char *)*((void *)v3 + 4);
                    double v30 = (char *)*((void *)v3 + 5);
                  }
                  else
                  {
                    uint64_t v37 = 0;
                  }
                  uint64_t v38 = &v37[4 * v33];
                  *(_DWORD *)uint64_t v38 = v12;
                  unint64_t v31 = v38 + 4;
                  while (v30 != v32)
                  {
                    int v39 = *((_DWORD *)v30 - 1);
                    v30 -= 4;
                    *((_DWORD *)v38 - 1) = v39;
                    v38 -= 4;
                  }
                  *((void *)v3 + 4) = v38;
                  *((void *)v3 + 5) = v31;
                  *((void *)v3 + 6) = &v37[4 * v36];
                  if (v32) {
                    operator delete(v32);
                  }
                }
                else
                {
                  *(_DWORD *)double v30 = v12;
                  unint64_t v31 = v30 + 4;
                }
                *((void *)v3 + 5) = v31;
              }
              ++v12;
            }
            while (v12 != v20);
            uint64_t v40 = v118;
            uint64_t Mesh = v113;
          }
          else
          {
            uint64_t v40 = 0;
          }
          std::vector<int>::size_type v8 = (uint64_t)(*((void *)v3 + 5) - *((void *)v3 + 4)) >> 2;
          std::__tree<char>::destroy((uint64_t)&v117, v40);
          goto LABEL_126;
        }
        if ((C3DGeometryInitSubdivTopologyInfoIfNeeded(__C3DGeometry *)::done & 1) == 0)
        {
          C3DGeometryInitSubdivTopologyInfoIfNeeded(__C3DGeometry *)::done = 1;
          uint64_t v68 = scn_default_log();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
            C3DGeometryInitSubdivTopologyInfoIfNeeded();
          }
        }
      }
      *unsigned int v3 = 1;
      uint64_t v69 = (void **)(v3 + 32);
      uint64_t v70 = (void **)(v3 + 8);
      std::vector<unsigned int>::reserve((std::vector<int> *)(v3 + 8), v8);
      std::vector<unsigned int>::reserve((std::vector<int> *)(v3 + 32), v8);
      if (v7)
      {
        int v71 = 0;
        do
        {
          uint64_t v73 = (char *)*((void *)v3 + 2);
          unint64_t v72 = *((void *)v3 + 3);
          if ((unint64_t)v73 >= v72)
          {
            uint64_t v75 = (char *)*v70;
            uint64_t v76 = (v73 - (unsigned char *)*v70) >> 2;
            unint64_t v77 = v76 + 1;
            if ((unint64_t)(v76 + 1) >> 62) {
              goto LABEL_157;
            }
            uint64_t v78 = v72 - (void)v75;
            if (v78 >> 1 > v77) {
              unint64_t v77 = v78 >> 1;
            }
            if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v79 = v77;
            }
            if (v79)
            {
              BOOL v80 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 24), v79);
              uint64_t v75 = (char *)*((void *)v3 + 1);
              uint64_t v73 = (char *)*((void *)v3 + 2);
            }
            else
            {
              BOOL v80 = 0;
            }
            int v81 = &v80[4 * v76];
            *(_DWORD *)int v81 = v71;
            int v74 = v81 + 4;
            while (v73 != v75)
            {
              int v82 = *((_DWORD *)v73 - 1);
              v73 -= 4;
              *((_DWORD *)v81 - 1) = v82;
              v81 -= 4;
            }
            *((void *)v3 + 1) = v81;
            *((void *)v3 + 2) = v74;
            *((void *)v3 + 3) = &v80[4 * v79];
            if (v75) {
              operator delete(v75);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v73 = v71;
            int v74 = v73 + 4;
          }
          *((void *)v3 + 2) = v74;
          int v84 = (char *)*((void *)v3 + 5);
          unint64_t v83 = *((void *)v3 + 6);
          if ((unint64_t)v84 >= v83)
          {
            long long v86 = (char *)*v69;
            uint64_t v87 = (v84 - (unsigned char *)*v69) >> 2;
            unint64_t v88 = v87 + 1;
            if ((unint64_t)(v87 + 1) >> 62) {
              goto LABEL_157;
            }
            uint64_t v89 = v83 - (void)v86;
            if (v89 >> 1 > v88) {
              unint64_t v88 = v89 >> 1;
            }
            if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v90 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v90 = v88;
            }
            if (v90)
            {
              CFIndex v91 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 48), v90);
              long long v86 = (char *)*((void *)v3 + 4);
              int v84 = (char *)*((void *)v3 + 5);
            }
            else
            {
              CFIndex v91 = 0;
            }
            uint64_t v92 = &v91[4 * v87];
            *(_DWORD *)uint64_t v92 = v71;
            uint64_t v85 = v92 + 4;
            while (v84 != v86)
            {
              int v93 = *((_DWORD *)v84 - 1);
              v84 -= 4;
              *((_DWORD *)v92 - 1) = v93;
              v92 -= 4;
            }
            *((void *)v3 + 4) = v92;
            *((void *)v3 + 5) = v85;
            *((void *)v3 + 6) = &v91[4 * v90];
            if (v86) {
              operator delete(v86);
            }
          }
          else
          {
            *(_DWORD *)int v84 = v71;
            uint64_t v85 = v84 + 4;
          }
          *((void *)v3 + 5) = v85;
          ++v71;
        }
        while (v71 != v7);
LABEL_123:
        LODWORD(v8) = v112;
        uint64_t Mesh = v113;
      }
    }
    else
    {
      *unsigned int v3 = 0;
      uint64_t v43 = (void **)(v3 + 32);
      unint64_t v44 = (void **)(v3 + 8);
      std::vector<unsigned int>::reserve((std::vector<int> *)(v3 + 8), v8);
      std::vector<unsigned int>::reserve((std::vector<int> *)(v3 + 32), v8);
      if (v7)
      {
        int v45 = 0;
        do
        {
          uint64_t v47 = (char *)*((void *)v3 + 2);
          unint64_t v46 = *((void *)v3 + 3);
          if ((unint64_t)v47 >= v46)
          {
            long long v49 = (char *)*v44;
            uint64_t v50 = (v47 - (unsigned char *)*v44) >> 2;
            unint64_t v51 = v50 + 1;
            if ((unint64_t)(v50 + 1) >> 62) {
              goto LABEL_157;
            }
            uint64_t v52 = v46 - (void)v49;
            if (v52 >> 1 > v51) {
              unint64_t v51 = v52 >> 1;
            }
            if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v53 = v51;
            }
            if (v53)
            {
              int v54 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 24), v53);
              long long v49 = (char *)*((void *)v3 + 1);
              uint64_t v47 = (char *)*((void *)v3 + 2);
            }
            else
            {
              int v54 = 0;
            }
            int v55 = &v54[4 * v50];
            *(_DWORD *)int v55 = v45;
            int v48 = v55 + 4;
            while (v47 != v49)
            {
              int v56 = *((_DWORD *)v47 - 1);
              v47 -= 4;
              *((_DWORD *)v55 - 1) = v56;
              v55 -= 4;
            }
            *((void *)v3 + 1) = v55;
            *((void *)v3 + 2) = v48;
            *((void *)v3 + 3) = &v54[4 * v53];
            if (v49) {
              operator delete(v49);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v47 = v45;
            int v48 = v47 + 4;
          }
          *((void *)v3 + 2) = v48;
          BOOL v58 = (char *)*((void *)v3 + 5);
          unint64_t v57 = *((void *)v3 + 6);
          if ((unint64_t)v58 >= v57)
          {
            int v60 = (char *)*v43;
            uint64_t v61 = (v58 - (unsigned char *)*v43) >> 2;
            unint64_t v62 = v61 + 1;
            if ((unint64_t)(v61 + 1) >> 62) {
LABEL_157:
            }
              abort();
            uint64_t v63 = v57 - (void)v60;
            if (v63 >> 1 > v62) {
              unint64_t v62 = v63 >> 1;
            }
            if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v64 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v64 = v62;
            }
            if (v64)
            {
              int v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v3 + 48), v64);
              int v60 = (char *)*((void *)v3 + 4);
              BOOL v58 = (char *)*((void *)v3 + 5);
            }
            else
            {
              int v65 = 0;
            }
            long long v66 = &v65[4 * v61];
            *(_DWORD *)long long v66 = v45;
            int v59 = v66 + 4;
            while (v58 != v60)
            {
              int v67 = *((_DWORD *)v58 - 1);
              v58 -= 4;
              *((_DWORD *)v66 - 1) = v67;
              v66 -= 4;
            }
            *((void *)v3 + 4) = v66;
            *((void *)v3 + 5) = v59;
            *((void *)v3 + 6) = &v65[4 * v64];
            if (v60) {
              operator delete(v60);
            }
          }
          else
          {
            *(_DWORD *)BOOL v58 = v45;
            int v59 = v58 + 4;
          }
          *((void *)v3 + 5) = v59;
          ++v45;
        }
        while (v45 != v7);
        goto LABEL_123;
      }
    }
LABEL_126:
    v116[0] = MEMORY[0x263EF8330];
    v116[1] = 0x40000000;
    v116[2] = ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke;
    v116[3] = &__block_descriptor_tmp_4_3;
    v116[4] = v3;
    C3DMeshApplySources(Mesh, 0, (uint64_t)v116);
    *((_DWORD *)v3 + 26) = v8;
    ElementsCFIndex Count = C3DMeshGetElementsCount(Mesh);
    if ((uint64_t)ElementsCount < 1)
    {
      int v96 = 0;
    }
    else
    {
      CFIndex v95 = 0;
      int v96 = 0;
      do
      {
        ElementAtuint64_t Index = C3DMeshGetElementAtIndex(Mesh, v95, 0);
        char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
        if (C3DMeshElementTypeDefinesSurface(Type)) {
          v96 += C3DMeshElementGetPrimitiveCountByEvaluatingPrimitiveRanges((uint64_t)ElementAtIndex);
        }
        ++v95;
      }
      while (ElementsCount != (const __CFArray *)v95);
    }
    *((_DWORD *)v3 + 27) = v96;
    float v99 = malloc_type_malloc(4 * v96, 0x100004052888210uLL);
    *((_DWORD *)v3 + 52) = 0;
    v3[212] = 1;
    v120.i32[0] = 0;
    if ((uint64_t)ElementsCount < 1)
    {
      __int32 v103 = 0;
    }
    else
    {
      for (CFIndex i = 0; (const __CFArray *)i != ElementsCount; ++i)
      {
        float32x4_t v101 = C3DMeshGetElementAtIndex(v113, i, 0);
        char v102 = C3DMeshElementGetType((uint64_t)v101);
        if (C3DMeshElementTypeDefinesSurface(v102))
        {
          v115[0] = MEMORY[0x263EF8330];
          v115[1] = 0x40000000;
          v115[2] = ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke_2;
          v115[3] = &__block_descriptor_tmp_6_3;
          v115[4] = v101;
          v115[5] = v99;
          v115[6] = &v120;
          v115[7] = v3;
          C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges((uint64_t)v101, (uint64_t)v115);
        }
      }
      __int32 v103 = v120.i32[0];
      uint64_t Mesh = v113;
    }
    if (v103 != *((_DWORD *)v3 + 27)) {
      C3DGeometryInitSubdivTopologyInfoIfNeeded();
    }
    *((void *)v3 + 14) = v99;
    if ((v7 - 1) >= 0x7FFFFFFF) {
      uint64_t v104 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v104 = (v7 - 1);
    }
    int v105 = malloc_type_malloc(4 * *((unsigned int *)v3 + 52), 0x100004052888210uLL);
    uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 0, 0);
    LODWORD(v117) = 0;
    if ((uint64_t)ElementsCount < 1)
    {
      int v111 = 0;
    }
    else
    {
      uint64_t v107 = ChannelForSourceWithSemanticAtIndex;
      for (CFIndex j = 0; (const __CFArray *)j != ElementsCount; ++j)
      {
        uint64_t v109 = C3DMeshGetElementAtIndex(v113, j, 0);
        char v110 = C3DMeshElementGetType((uint64_t)v109);
        if (C3DMeshElementTypeDefinesSurface(v110))
        {
          v114[0] = MEMORY[0x263EF8330];
          v114[1] = 0x40000000;
          v114[2] = ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke_3;
          v114[3] = &__block_descriptor_tmp_9_2;
          v114[4] = v109;
          v114[5] = v107;
          v114[6] = v104;
          v114[7] = v3;
          v114[8] = v105;
          v114[9] = &v117;
          C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges((uint64_t)v109, (uint64_t)v114);
        }
      }
      int v111 = (int)v117;
    }
    if (v111 != *((_DWORD *)v3 + 52)) {
      C3DGeometryInitSubdivTopologyInfoIfNeeded();
    }
    *((void *)v3 + 15) = v105;
    return 1;
  }
  CFArrayRef v41 = scn_default_log();
  BOOL result = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3DGeometryInitSubdivTopologyInfoIfNeeded();
    return 0;
  }
  return result;
}

uint64_t __C3DGeometryOsdGetPrimvarDataTypeHash_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 80);
  uint64_t v4 = *(void *)(v2 + 88);
  while (v3 != v4)
  {
    if (*(void *)v3 == a2) {
      return *(unsigned int *)(v3 + 12);
    }
    v3 += 16;
  }
  uint64_t v5 = scn_default_log();
  uint64_t result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __C3DGeometryOsdGetPrimvarDataTypeHash_block_invoke_cold_1();
    return 0;
  }
  return result;
}

uint64_t C3DGeometryOsdGetColorDataType(unsigned int a1)
{
  return (a1 >> 1) & 3;
}

uint64_t C3DGeometryOsdGetTextureCoordinatesDataType(unsigned int a1, uint64_t a2)
{
  switch((int)a2)
  {
    case 0:
      uint64_t result = (a1 >> 3) & 3;
      break;
    case 1:
      uint64_t result = (a1 >> 5) & 3;
      break;
    case 2:
      uint64_t result = (a1 >> 7) & 3;
      break;
    case 3:
      uint64_t result = (a1 >> 9) & 3;
      break;
    case 4:
      uint64_t result = (a1 >> 11) & 3;
      break;
    case 5:
      uint64_t result = (a1 >> 13) & 3;
      break;
    case 6:
      uint64_t result = (a1 >> 15) & 3;
      break;
    case 7:
      uint64_t result = (a1 >> 17) & 3;
      break;
    default:
      uint64_t v4 = scn_default_log();
      uint64_t result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if (result)
      {
        C3DGeometryOsdGetTextureCoordinatesDataType(a2, v4, v5, v6, v7, v8, v9, v10);
        uint64_t result = 0;
      }
      break;
  }
  return result;
}

BOOL C3DGeometryOsdGetColorIsVarying(char a1)
{
  return (a1 & 6) == 4;
}

uint64_t C3DGeometryOsdGetVaryingTextureCoordinatesCount(unsigned int a1)
{
  int v1 = (a1 & 0x18) == 16;
  if ((a1 & 0x18) == 0x10) {
    int v2 = 2;
  }
  else {
    int v2 = 1;
  }
  if ((a1 & 0x60) == 0x40) {
    int v1 = v2;
  }
  int32x4_t v3 = (int32x4_t)vandq_s8((int8x16_t)vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(a1), (int8x16_t)xmmword_20B5EE440), (int32x4_t)xmmword_20B5EE450), (int8x16_t)xmmword_20B5CBD00);
  v3.i32[0] = vaddvq_s32(v3) & 0xF;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v3.i8);
  v4.i16[0] = vaddlv_u8(v4);
  __int32 v5 = v4.i32[0];
  if ((a1 & 0x18000) == 0x10000) {
    __int32 v5 = v4.i32[0] + 1;
  }
  if ((a1 & 0x60000) == 0x40000) {
    ++v1;
  }
  return (v5 + v1);
}

BOOL C3DGeometryOsdGetColorIsFaceVarying(int a1)
{
  return (~a1 & 6) == 0;
}

uint64_t C3DGeometryOsdGetFaceVaryingTextureCoordinatesCount(unsigned int a1)
{
  int v1 = (~a1 & 0x18) == 0;
  if ((~a1 & 0x18) != 0) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  if ((~a1 & 0x60) == 0) {
    int v1 = v2;
  }
  int32x4_t v3 = (int32x4_t)vandq_s8((int8x16_t)vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(a1), (int8x16_t)xmmword_20B5EE440), (int32x4_t)xmmword_20B5EE440), (int8x16_t)xmmword_20B5CBD00);
  v3.i32[0] = vaddvq_s32(v3) & 0xF;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v3.i8);
  v4.i16[0] = vaddlv_u8(v4);
  __int32 v5 = v4.i32[0];
  if ((~a1 & 0x18000) == 0) {
    __int32 v5 = v4.i32[0] + 1;
  }
  if ((~a1 & 0x60000) == 0) {
    ++v1;
  }
  return (v5 + v1);
}

uint64_t C3DGeometryOsdGetHasMultipleFaceVaryingChannels(char a1)
{
  return a1 & 1;
}

void _Z68C3DSubdivCPUPrimvarDataCopyCrossNormalizedDataAtIndexToBufferAtIndexIDv2_fEvRNSt3__16vectorI16C3DSubdivCPUDataIT_ENS1_9allocatorIS5_EEEES9_iPfi()
{
  CFAllocatorRef v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    _Z68C3DSubdivCPUPrimvarDataCopyCrossNormalizedDataAtIndexToBufferAtIndexIDv2_fEvRNSt3__16vectorI16C3DSubdivCPUDataIT_ENS1_9allocatorIS5_EEEES9_iPfi_cold_1();
  }
}

void std::vector<BOOL>::push_back(uint64_t a1, unsigned char *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0) {
      abort();
    }
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4 + 1;
  uint64_t v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1 << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

void ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5)
{
  if (a3)
  {
    if ((a3 & 0xFE) != 2) {
      return;
    }
    unint64_t v7 = *(void **)(a1 + 32);
    unsigned int v8 = *(unsigned __int8 *)v7;
    if (v8 >= 2)
    {
      if (v8 == 2)
      {
        int v9 = 2;
        goto LABEL_11;
      }
      if (v8 != 3)
      {
        int v9 = 0;
        goto LABEL_11;
      }
    }
    int v9 = 3;
  }
  else
  {
    if (a4) {
      return;
    }
    unint64_t v7 = *(void **)(a1 + 32);
    int v9 = 1;
  }
LABEL_11:
  unint64_t v10 = v7[12];
  unint64_t v11 = v7[11];
  if (v11 >= v10)
  {
    uint64_t v13 = v7[10];
    uint64_t v14 = (uint64_t)(v11 - v13) >> 4;
    unint64_t v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 60) {
      abort();
    }
    uint64_t v16 = v10 - v13;
    if (v16 >> 3 > v15) {
      unint64_t v15 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17) {
      char v18 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(v7 + 12), v17);
    }
    else {
      char v18 = 0;
    }
    uint64_t v19 = &v18[16 * v14];
    uint64_t v20 = &v18[16 * v17];
    *(void *)uint64_t v19 = a2;
    v19[8] = a5;
    *(_WORD *)(v19 + 9) = 0;
    v19[11] = 0;
    *((_DWORD *)v19 + 3) = v9;
    uint64_t v12 = v19 + 16;
    uint64_t v22 = (char *)v7[10];
    uint64_t v21 = (char *)v7[11];
    if (v21 != v22)
    {
      do
      {
        *((_OWORD *)v19 - 1) = *((_OWORD *)v21 - 1);
        v19 -= 16;
        v21 -= 16;
      }
      while (v21 != v22);
      uint64_t v21 = (char *)v7[10];
    }
    v7[10] = v19;
    v7[11] = v12;
    v7[12] = v20;
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *(void *)unint64_t v11 = a2;
    *(unsigned char *)(v11 + 8) = a5;
    *(_WORD *)(v11 + 9) = 0;
    *(unsigned char *)(v11 + 11) = 0;
    uint64_t v12 = (char *)(v11 + 16);
    *(_DWORD *)(v11 + 12) = v9;
  }
  v7[11] = v12;
}

uint64_t ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke_2(uint64_t *a1, unsigned int a2)
{
  uint64_t result = C3DMeshElementGetVertexCountForPrimitiveAtIndex(a1[4], a2);
  uint64_t v4 = a1[5];
  uint64_t v5 = (_DWORD *)a1[6];
  uint64_t v6 = *v5;
  *uint64_t v5 = v6 + 1;
  *(_DWORD *)(v4 + 4 * v6) = result;
  uint64_t v7 = a1[7];
  *(_DWORD *)(v7 + 208) += result;
  if (result != 4) {
    *(unsigned char *)(v7 + 212) = 0;
  }
  return result;
}

uint64_t ___Z41C3DGeometryInitSubdivTopologyInfoIfNeededP13__C3DGeometry_block_invoke_3(uint64_t *a1, unsigned int a2)
{
  uint64_t v3 = a2;
  uint64_t result = C3DMeshElementGetVertexCountForPrimitiveAtIndex(a1[4], a2);
  if (result >= 1)
  {
    uint64_t v5 = result;
    for (uint64_t i = 0; i != v5; ++i)
    {
      uint64_t result = C3DMeshElementGetIndex(a1[4], v3, i, a1[5]);
      uint64_t v7 = a1[6];
      uint64_t v8 = a1[7];
      if (result < v7) {
        uint64_t v7 = result;
      }
      if (*(unsigned char *)v8 == 3) {
        LODWORD(v7) = *(_DWORD *)(*(void *)(v8 + 8) + 4 * v7);
      }
      uint64_t v9 = a1[8];
      unint64_t v10 = (_DWORD *)a1[9];
      uint64_t v11 = *v10;
      *unint64_t v10 = v11 + 1;
      *(_DWORD *)(v9 + 4 * v11) = v7;
    }
  }
  return result;
}

void C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[5];
  if (!v3)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(int *)(v3 + 128) <= 0 && *(int *)(v3 + 152) <= 0)
  {
    uint64_t v12 = a1[2];
    if (v12 && a1[1])
    {
      uint64_t v55 = a1[1];
      ElementsCFIndex Count = C3DMeshGetElementsCount(a2);
      if ((uint64_t)ElementsCount < 1)
      {
        BOOL v62 = 0;
      }
      else
      {
        CFIndex v14 = 0;
        BOOL v62 = 1;
        do
        {
          ElementAtint Index = C3DMeshGetElementAtIndex(a2, v14, 0);
          char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
          if (C3DMeshElementTypeDefinesSurface(Type) && C3DMeshElementGetPrimitiveRange((uint64_t)ElementAtIndex) != -1) {
            break;
          }
          BOOL v62 = ++v14 < (uint64_t)ElementsCount;
        }
        while (ElementsCount != (const __CFArray *)v14);
      }
      uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(v12);
      uint64_t v17 = v55;
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount(v55);
      int v60 = malloc_type_malloc(4 * PrimitiveCount, 0x100004052888210uLL);
      BOOL v58 = (char *)malloc_type_malloc(8 * PrimitiveCount, 0x100004052888210uLL);
      if (C3DMeshElementGetIndicesChannelCount(v55) != 1)
      {
        uint64_t v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v19, v20, v21, v22, v23, v24, v25, v26);
        }
      }
      if (PrimitiveCount < 1)
      {
        LODWORD(v28) = 0;
      }
      else
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        uint64_t v54 = PrimitiveCount;
        do
        {
          int Index = C3DMeshElementGetIndex(v17, v27, 0, 0);
          int v30 = C3DMeshElementGetIndex(v17, v27, 1, 0);
          if (!v62) {
            goto LABEL_27;
          }
          uint64_t v74 = 0;
          uint64_t v75 = &v74;
          uint64_t v76 = 0x2000000000;
          char v77 = 0;
          unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a2, 0, 0);
          if ((uint64_t)ElementsCount >= 1)
          {
            CFIndex v32 = 0;
            uint64_t v33 = ChannelForSourceWithSemanticAtIndex;
            do
            {
              unint64_t v34 = C3DMeshGetElementAtIndex(a2, v32, 0);
              char v35 = C3DMeshElementGetType((uint64_t)v34);
              if (C3DMeshElementTypeDefinesSurface(v35))
              {
                uint64_t v73 = 0;
                long long v71 = 0u;
                __n128 v72 = 0u;
                long long v70 = 0u;
                C3DMeshElementGetContent((uint64_t)v34, v33, (uint64_t)&v70);
                v68[0] = v70;
                v68[1] = v71;
                v68[2] = v72;
                uint64_t v69 = v73;
                v65[0] = MEMORY[0x263EF8330];
                v65[1] = 0x40000000;
                _OWORD v65[2] = ___Z50C3DGeometrySubdivTopologyInfoInitCreasesAndCornersPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke;
                v65[3] = &unk_2640092C0;
                int v66 = Index;
                int v67 = v30;
                uint8_t v65[4] = &v74;
                C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges((uint64_t)v68, (uint64_t)v65, v72);
              }
              ++v32;
            }
            while (ElementsCount != (const __CFArray *)v32);
          }
          int v36 = *((unsigned __int8 *)v75 + 24);
          _Block_object_dispose(&v74, 8);
          PrimitiveCFIndex Count = v54;
          uint64_t v17 = v55;
          if (v36)
          {
LABEL_27:
            if (*(unsigned char *)v3 == 3)
            {
              uint64_t v37 = *(void *)(v3 + 8);
              int Index = *(_DWORD *)(v37 + 4 * Index);
              int v30 = *(_DWORD *)(v37 + 4 * v30);
            }
            uint64_t v38 = &v58[8 * v28];
            *(_DWORD *)uint64_t v38 = Index;
            *((_DWORD *)v38 + 1) = v30;
            v60[v28++] = *(_DWORD *)C3DSourceAccessorGetValuePtrAtIndex(Accessor, v27);
          }
          ++v27;
        }
        while (v27 != PrimitiveCount);
      }
      *(_DWORD *)(v3 + 128) = v28;
      *(void *)(v3 + 136) = v58;
      *(void *)(v3 + 144) = v60;
    }
    SourceWithSemanticAtint Index = C3DMeshGetSourceWithSemanticAtIndex(a2, 7, 0, 0);
    if (SourceWithSemanticAtIndex)
    {
      uint64_t v40 = (void *)C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
      size_t v41 = *(void *)(v3 + 40) - *(void *)(v3 + 32);
      uint64_t v42 = malloc_type_malloc(v41, 0x100004052888210uLL);
      size_t v57 = v41;
      uint64_t v43 = malloc_type_malloc(v41, 0x100004052888210uLL);
      uint64_t v44 = C3DMeshGetChannelForSourceWithSemanticAtIndex(a2, 7, 0);
      CFArrayRef v59 = C3DMeshGetElementsCount(a2);
      if ((uint64_t)v59 >= 1)
      {
        CFIndex v45 = 0;
        do
        {
          CFIndex v61 = v45;
          unint64_t v46 = C3DMeshGetElementAtIndex(a2, v45, 0);
          char v47 = C3DMeshElementGetType((uint64_t)v46);
          if (C3DMeshElementTypeDefinesSurface(v47))
          {
            uint64_t v63 = C3DMeshElementGetPrimitiveCount((uint64_t)v46);
            if (v63 >= 1)
            {
              for (uint64_t i = 0; i != v63; ++i)
              {
                VertexCountForPrimitiveAtint Index = C3DMeshElementGetVertexCountForPrimitiveAtIndex((uint64_t)v46, i);
                if (VertexCountForPrimitiveAtIndex >= 1)
                {
                  uint64_t v50 = VertexCountForPrimitiveAtIndex;
                  for (uint64_t j = 0; j != v50; ++j)
                  {
                    int v52 = C3DMeshElementGetIndex((uint64_t)v46, i, j, v44);
                    int v53 = v52;
                    if (*(unsigned char *)v3 == 3) {
                      int v53 = *(_DWORD *)(*(void *)(v3 + 8) + 4 * v52);
                    }
                    v42[v53] = *(_DWORD *)C3DSourceAccessorGetValuePtrAtIndex(v40, v52);
                    v43[v53] = v53;
                  }
                }
              }
            }
          }
          CFIndex v45 = v61 + 1;
        }
        while ((const __CFArray *)(v61 + 1) != v59);
      }
      *(_DWORD *)(v3 + 152) = v57 >> 2;
      *(void *)(v3 + 160) = v43;
      *(void *)(v3 + 168) = v42;
    }
  }
}

uint64_t ___Z50C3DGeometrySubdivTopologyInfoInitCreasesAndCornersPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = 0;
    int v5 = *(_DWORD *)(result + 40);
    do
    {
      int v6 = *(_DWORD *)(a3 + 4 * v4);
      if (a4 - 1 == v4) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v4 + 1;
      }
      int v8 = *(_DWORD *)(a3 + 4 * v7);
      if (v5 == v6 && *(_DWORD *)(result + 44) == v8 || v5 == v8 && *(_DWORD *)(result + 44) == v6) {
        *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      }
      ++v4;
    }
    while (a4 != v4);
  }
  return result;
}

void C3DSubdivCreateRefiner(uint64_t a1)
{
  if (!*(void *)(a1 + 40))
  {
    int v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  OpenSubdiv::v3_1_1::Far::TopologyRefinerFactory<OpenSubdiv::v3_1_1::Far::TopologyDescriptor>::Create();
}

void OpenSubdiv::v3_1_1::Far::TopologyRefinerFactory<OpenSubdiv::v3_1_1::Far::TopologyDescriptor>::Create()
{
}

void C3DSubdivInitCPUPrimvarContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)((char *)&v39[1] + 4) = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 40);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  v37[0] = MEMORY[0x263EF8330];
  v37[1] = 0x40000000;
  v37[2] = ___Z30C3DSubdivInitCPUPrimvarContextP26C3DSubdivCPUPrimvarContextPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke;
  v37[3] = &__block_descriptor_tmp_15_0;
  v37[4] = a2;
  void v37[5] = a1;
  C3DMeshApplySources(a3, 0, (uint64_t)v37);
  unint64_t v15 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
  unsigned int v16 = (v15 >> 5);
  if ((v15 >> 5))
  {
    if (!*(_DWORD *)(v6 + 196))
    {
      uint64_t v17 = (char *)malloc_type_malloc((v15 >> 1) & 0xFF0, 0x105004037B82EA9uLL);
      uint64_t v18 = 0;
      do
      {
        uint64_t v19 = *(unsigned int *)(v6 + 208);
        *(_DWORD *)&v17[v18] = v19;
        *(void *)&v17[v18 + 8] = malloc_type_malloc(4 * v19, 0x100004052888210uLL);
        v18 += 16;
      }
      while (16 * v16 != v18);
      *(_DWORD *)(v6 + 196) = v16;
      *(void *)(v6 + 200) = v17;
    }
    uint64_t v20 = 0;
    if (v16 <= 1) {
      uint64_t v21 = 1;
    }
    else {
      uint64_t v21 = v16;
    }
    uint64_t v32 = v21;
    uint64_t v33 = a1;
    do
    {
      uint64_t v22 = *(void *)(a1 + 48) + 32 * v20;
      uint64_t v24 = *(void *)(v22 + 8);
      uint64_t v23 = *(void *)(v22 + 16);
      int v36 = 0;
      ElementsCFIndex Count = C3DMeshGetElementsCount(a3);
      if ((uint64_t)ElementsCount >= 1)
      {
        CFArrayRef v26 = ElementsCount;
        CFIndex v27 = 0;
        uint64_t v28 = (v23 - v24) >> 3;
        do
        {
          ElementAtint Index = C3DMeshGetElementAtIndex(a3, v27, 0);
          char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
          if (C3DMeshElementTypeDefinesSurface(Type))
          {
            v34[0] = MEMORY[0x263EF8330];
            v34[1] = 0x40000000;
            void v34[2] = ___Z30C3DSubdivInitCPUPrimvarContextP26C3DSubdivCPUPrimvarContextPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_2;
            v34[3] = &__block_descriptor_tmp_16_1;
            float32x4_t v34[4] = ElementAtIndex;
            v34[5] = v28;
            v34[6] = v22;
            v34[7] = v6;
            char v35 = v20;
            v34[8] = &v36;
            C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges((uint64_t)ElementAtIndex, (uint64_t)v34);
          }
          ++v27;
        }
        while (v26 != (const __CFArray *)v27);
      }
      if (v36 != *(_DWORD *)(v6 + 208))
      {
        unint64_t v31 = scn_default_log();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
          C3DSubdivInitCPUPrimvarContext(v38, v39, v31);
        }
      }
      ++v20;
      a1 = v33;
    }
    while (v20 != v32);
  }
  else
  {
    *(_DWORD *)(v6 + 196) = 0;
    *(void *)(v6 + 200) = 0;
  }
}

void ___Z30C3DSubdivInitCPUPrimvarContextP26C3DSubdivCPUPrimvarContextPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a3)
  {
    if ((a3 & 0xFFFFFFFE) == 2) {
      goto LABEL_5;
    }
    if (a3 != 4) {
      return;
    }
  }
  if (a4) {
    return;
  }
LABEL_5:
  C3DMeshSourceGetContent(a2);
  if (!v11 || !C3DBaseTypeIsFloatingValue(v10)) {
    return;
  }
  if (a3)
  {
    if ((a3 & 0xFFFFFFFE) == 2 || a3 == 4 && !a4) {
      goto LABEL_15;
    }
  }
  else if (!a4)
  {
    goto LABEL_24;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    ___Z30C3DSubdivInitCPUPrimvarContextP26C3DSubdivCPUPrimvarContextPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_cold_1();
    if (!a3) {
      goto LABEL_24;
    }
LABEL_15:
    uint64_t v13 = *(void *)(a1 + 40);
    unint64_t v15 = *(unsigned __int8 **)(v13 + 48);
    unsigned int v16 = *(unsigned __int8 **)(v13 + 56);
    uint64_t v14 = (uint64_t *)(v13 + 48);
    while (v15 != v16)
    {
      if (*v15 == a5)
      {
        uint64_t v18 = (void **)(v15 + 8);
        goto LABEL_25;
      }
      v15 += 32;
    }
    *(_OWORD *)std::string __p = 0u;
    long long v33 = 0u;
    std::vector<C3DSubdivCPUFVarPrimvarInfo>::push_back[abi:nn180100](v14, (char *)__p);
    if (__p[1])
    {
      *(void **)&long long v33 = __p[1];
      operator delete(__p[1]);
    }
    uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 56);
    *(unsigned char *)(v17 - 32) = a5;
    uint64_t v18 = (void **)(v17 - 24);
    goto LABEL_25;
  }
  if (a3) {
    goto LABEL_15;
  }
LABEL_24:
  uint64_t v18 = *(void ***)(a1 + 40);
LABEL_25:
  unint64_t v19 = (unint64_t)v18[2];
  uint64_t v20 = (uint64_t *)v18[1];
  if ((unint64_t)v20 >= v19)
  {
    uint64_t v22 = ((char *)v20 - (unsigned char *)*v18) >> 3;
    if ((unint64_t)(v22 + 1) >> 61) {
      abort();
    }
    uint64_t v23 = v19 - (void)*v18;
    uint64_t v24 = v23 >> 2;
    if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
      uint64_t v24 = v22 + 1;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25) {
      CFArrayRef v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)(v18 + 2), v25);
    }
    else {
      CFArrayRef v26 = 0;
    }
    CFIndex v27 = (uint64_t *)&v26[8 * v22];
    uint64_t v28 = &v26[8 * v25];
    *CFIndex v27 = a2;
    uint64_t v21 = v27 + 1;
    int v30 = (char *)*v18;
    unint64_t v29 = (char *)v18[1];
    if (v29 != *v18)
    {
      do
      {
        uint64_t v31 = *((void *)v29 - 1);
        v29 -= 8;
        *--CFIndex v27 = v31;
      }
      while (v29 != v30);
      unint64_t v29 = (char *)*v18;
    }
    char *v18 = v27;
    v18[1] = v21;
    v18[2] = v28;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *uint64_t v20 = a2;
    uint64_t v21 = v20 + 1;
  }
  v18[1] = v21;
}

uint64_t C3DSubdivSourceGetPrimvarDataType(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a3)
  {
    if (a3 & 0xFFFFFFFE) == 2 || a3 == 4 && !a4 && (a5)
    {
LABEL_9:
      if (a5) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
  }
  else if (!a4)
  {
    goto LABEL_9;
  }
  uint64_t v9 = scn_default_log();
  if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
    goto LABEL_9;
  }
  C3DSubdivSourceGetPrimvarDataType();
  if (a5)
  {
LABEL_10:
    if (a3) {
      return 3;
    }
    else {
      return 1;
    }
  }
LABEL_14:
  uint64_t v11 = *(void *)(a1 + 40);
  if (!v11)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  for (uint64_t i = *(void *)(v11 + 80); i != *(void *)(v11 + 88); i += 16)
  {
    if (*(void *)i == a2) {
      return *(unsigned int *)(i + 12);
    }
  }
  uint64_t v21 = scn_default_log();
  uint64_t result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __C3DGeometryOsdGetPrimvarDataTypeHash_block_invoke_cold_1();
    return 0;
  }
  return result;
}

uint64_t std::vector<C3DSubdivCPUFVarPrimvarInfo>::push_back[abi:nn180100](uint64_t *a1, char *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 5;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59) {
      abort();
    }
    uint64_t v11 = v5 - *a1;
    if (v11 >> 4 > v10) {
      unint64_t v10 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    uint8_t v16[4] = result;
    uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(result, v12);
    uint64_t v14 = &v13[32 * v9];
    v16[0] = v13;
    v16[1] = v14;
    __n128 v16[3] = &v13[32 * v15];
    *uint64_t v14 = *a2;
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = 0;
    *((void *)v14 + 1) = 0;
    *(_OWORD *)(v14 + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v14 + 3) = *((void *)a2 + 3);
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    void v16[2] = v14 + 32;
    std::vector<C3DSubdivCPUFVarPrimvarInfo>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = a1[1];
    uint64_t result = std::__split_buffer<C3DSubdivCPUFVarPrimvarInfo>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *(unsigned char *)unint64_t v7 = *a2;
    *(void *)(v7 + 16) = 0;
    *(void *)(v7 + 24) = 0;
    *(void *)(v7 + 8) = 0;
    *(_OWORD *)(v7 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(v7 + 24) = *((void *)a2 + 3);
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v8 = v7 + 32;
  }
  a1[1] = v8;
  return result;
}

uint64_t ___Z30C3DSubdivInitCPUPrimvarContextP26C3DSubdivCPUPrimvarContextPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_2(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a2;
  uint64_t result = C3DMeshElementGetVertexCountForPrimitiveAtIndex(*(void *)(a1 + 32), a2);
  if (result >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    unint64_t v7 = *(void *)(a1 + 40);
    do
    {
      if (v7)
      {
        for (unint64_t i = 0; i < v7; ++i)
        {
          uint64_t Count = C3DMeshSourceGetCount(*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 8 * i));
          if (Count >= 0x80000000) {
            uint64_t v10 = 0x80000000;
          }
          else {
            uint64_t v10 = Count;
          }
          uint64_t v11 = v10 - 1;
          uint64_t result = C3DMeshElementGetIndex(*(void *)(a1 + 32), v3, v6, **(unsigned __int8 **)(a1 + 48));
          if (result >= v11) {
            int v12 = v11;
          }
          else {
            int v12 = result;
          }
          uint64_t v13 = *(_DWORD **)(a1 + 64);
          *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 200) + 16 * *(unsigned __int8 *)(a1 + 72) + 8)
                    + 4 * *v13) = v12;
          unint64_t v7 = *(void *)(a1 + 40);
        }
      }
      else
      {
        uint64_t v13 = *(_DWORD **)(a1 + 64);
      }
      ++*v13;
      ++v6;
    }
    while (v6 != v5);
  }
  return result;
}

void C3DSubdivFeedCPUPrimvar(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(uint64_t **)a1;
  unint64_t v7 = *(uint64_t **)(a1 + 8);
  if (*(uint64_t **)a1 != v7)
  {
    do
    {
      uint64_t v8 = *v6++;
      __C3DSubdivFeedCPUPrimvar(a2, a3, v8, 0, (uint64_t *)(a1 + 72), 0);
    }
    while (v6 != v7);
  }
  uint64_t v9 = *(uint64_t **)(a1 + 24);
  uint64_t v10 = *(uint64_t **)(a1 + 32);
  while (v9 != v10)
  {
    uint64_t v11 = *v9++;
    __C3DSubdivFeedCPUPrimvar(a2, a3, v11, 0, (uint64_t *)(a1 + 144), 1);
  }
  unint64_t v12 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
  unint64_t v13 = (v12 >> 5);
  std::vector<C3DSubdivCPUPrimvarDataGroup>::resize((uint64_t *)(a1 + 216), v13);
  if ((v12 & 0x1FE0) != 0)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)(a1 + 48) + 32 * v14;
      uint64_t v16 = *(uint64_t **)(v15 + 8);
      uint64_t v17 = *(uint64_t **)(v15 + 16);
      if (v16 != v17)
      {
        uint64_t v18 = (uint64_t *)(*(void *)(a1 + 216) + 72 * v14);
        do
        {
          uint64_t v19 = *v16++;
          __C3DSubdivFeedCPUPrimvar(a2, a3, v19, v14, v18, 2);
        }
        while (v16 != v17);
      }
      ++v14;
    }
    while (v14 != v13);
  }
}

void __C3DSubdivFeedCPUPrimvar(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t *a5, int a6)
{
  uint64_t v11 = *(void *)(a1 + 40);
  if (!v11)
  {
    unint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  C3DMeshSourceGetContent(a3);
  uint64_t v21 = HIBYTE(v20);
  if (BYTE4(v20) - 23 >= 2) {
    int v22 = HIBYTE(v20);
  }
  else {
    int v22 = 4;
  }
  switch(v22)
  {
    case 4:
      _ZN23C3DSubdivCPUPrimvarDataIDv3_fEC2EPK15__C3DMeshSourceP29C3DGeometrySubdivTopologyInfoPN10OpenSubdiv6v3_1_13Far15TopologyRefinerEh37C3DSubdivPrimvarDataInterpolationMode((uint64_t)v30, a3, v11, a2, a4, a6);
      _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE9push_backB8nn180100ERKS3_(a5 + 6, (uint64_t)v30);
      goto LABEL_13;
    case 3:
      _ZN23C3DSubdivCPUPrimvarDataIDv3_fEC2EPK15__C3DMeshSourceP29C3DGeometrySubdivTopologyInfoPN10OpenSubdiv6v3_1_13Far15TopologyRefinerEh37C3DSubdivPrimvarDataInterpolationMode((uint64_t)v30, a3, v11, a2, a4, a6);
      _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE9push_backB8nn180100ERKS3_(a5 + 3, (uint64_t)v30);
      goto LABEL_13;
    case 2:
      _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2EPK15__C3DMeshSourceP29C3DGeometrySubdivTopologyInfoPN10OpenSubdiv6v3_1_13Far15TopologyRefinerEh37C3DSubdivPrimvarDataInterpolationMode((uint64_t)v30, a3, v11, a2, a4, a6);
      _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE9push_backB8nn180100ERKS3_(a5, (uint64_t)v30);
LABEL_13:
      if (__p)
      {
        unint64_t v34 = __p;
        operator delete(__p);
      }
      if (v31)
      {
        uint64_t v32 = v31;
        operator delete(v31);
      }
      if (v30[0])
      {
        v30[1] = v30[0];
        operator delete(v30[0]);
      }
      return;
  }
  uint64_t v23 = scn_default_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
    __C3DSubdivFeedCPUPrimvar(v21, v23, v24, v25, v26, v27, v28, v29);
  }
}

void std::vector<C3DSubdivCPUPrimvarDataGroup>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = 0x8E38E38E38E38E39 * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<C3DSubdivCPUPrimvarDataGroup>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 72 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 9;
      std::allocator<C3DSubdivCPUPrimvarDataGroup>::destroy[abi:nn180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void C3DSubdivInterpolateCPUPrimvar(uint64_t a1, double a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, int **a7)
{
  __C3DSubdivInterpolateCPUPrimvar((void *)(a1 + 72), a6, a7, a2, a3, a4);
  __C3DSubdivInterpolateCPUPrimvar((void *)(a1 + 144), a6, a7, v10, v11, v12);
  int v16 = *(_DWORD *)(a1 + 48);
  if (((*(_DWORD *)(a1 + 56) - v16) >> 5))
  {
    uint64_t v17 = 0;
    uint64_t v18 = 72 * ((*(_DWORD *)(a1 + 56) - v16) >> 5);
    do
    {
      __C3DSubdivInterpolateCPUPrimvar((void *)(*(void *)(a1 + 216) + v17), a6, a7, v13, v14, v15);
      v17 += 72;
    }
    while (v18 != v17);
  }
}

void __C3DSubdivInterpolateCPUPrimvar(void *a1, uint64_t a2, int **a3, double a4, float32x4_t a5, float32x4_t a6)
{
  if ((*(unsigned char *)(a2 + 8) & 0x3C) != 0)
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = a1[1] - *a1;
      if (v10)
      {
        uint64_t v11 = 0;
        unint64_t v12 = v10 / 112;
        if (v12 <= 1) {
          uint64_t v13 = 1;
        }
        else {
          uint64_t v13 = v12;
        }
        do
        {
          _ZN23C3DSubdivCPUPrimvarDataIDv2_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(*a1 + v11, v9 + 1, a3, a2, a4, *(double *)a5.i64);
          v11 += 112;
          --v13;
        }
        while (v13);
      }
      uint64_t v14 = a1[4] - a1[3];
      if (v14)
      {
        uint64_t v15 = 0;
        unint64_t v16 = v14 / 112;
        if (v16 <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = v16;
        }
        do
        {
          _ZN23C3DSubdivCPUPrimvarDataIDv3_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(a1[3] + v15, v9 + 1, a3, a2, a4, *(double *)a5.i64, a6);
          v15 += 112;
          --v17;
        }
        while (v17);
      }
      uint64_t v18 = a1[7] - a1[6];
      if (v18)
      {
        uint64_t v19 = 0;
        unint64_t v20 = v18 / 112;
        if (v20 <= 1) {
          uint64_t v21 = 1;
        }
        else {
          uint64_t v21 = v20;
        }
        do
        {
          _ZN23C3DSubdivCPUPrimvarDataIDv4_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(a1[6] + v19, v9 + 1, a3, a2, a4, a5);
          v19 += 112;
          --v21;
        }
        while (v21);
      }
      ++v9;
    }
    while (v9 < (((unint64_t)*(unsigned __int8 *)(a2 + 8) >> 2) & 0xF));
  }
}

void C3DSubdivInitGPUPrimvarDescriptor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v124 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 40);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DGeometrySubdivTopologyInfoInitCreasesAndCorners(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 56) = 0;
  v119[0] = MEMORY[0x263EF8330];
  v119[1] = 0x40000000;
  v119[2] = ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke;
  v119[3] = &__block_descriptor_tmp_18_1;
  v119[4] = a2;
  v119[5] = a1;
  uint64_t v109 = a3;
  C3DMeshApplySources(a3, 0, (uint64_t)v119);
  uint64_t v101 = *(void *)(a1 + 8);
  uint64_t v102 = *(void *)(a1 + 16);
  uint64_t v99 = *(void *)(a1 + 64);
  uint64_t v100 = *(void *)(a1 + 72);
  std::vector<float>::reserve((void **)(a1 + 32), (*(_DWORD *)(v6 + 208) * *(_DWORD *)a1));
  int v108 = (void **)(a1 + 88);
  std::vector<float>::reserve((void **)(a1 + 88), (*(_DWORD *)(v6 + 208) * *(_DWORD *)(a1 + 56)));
  uint64_t v15 = *(void *)(a1 + 112);
  uint64_t v16 = *(void *)(a1 + 120);
  while (v15 != v16)
  {
    std::vector<float>::reserve((void **)(v15 + 40), (*(_DWORD *)(v6 + 208) * *(_DWORD *)(v15 + 8)));
    v15 += 64;
  }
  uint64_t v104 = v6;
  if (*(_DWORD *)(v6 + 104))
  {
    uint64_t v17 = 0;
    uint64_t v18 = (void *)(a1 + 48);
    uint64_t v19 = (void *)(a1 + 104);
    if ((unint64_t)((v102 - v101) >> 4) <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = (v102 - v101) >> 4;
    }
    if ((unint64_t)((v100 - v99) >> 4) <= 1) {
      uint64_t v21 = 1;
    }
    else {
      uint64_t v21 = (v100 - v99) >> 4;
    }
    uint64_t v105 = v21;
    uint64_t v106 = v20;
    uint64_t v107 = (void **)(a1 + 32);
    do
    {
      uint64_t v103 = v17;
      int v110 = *(_DWORD *)(*(void *)(v6 + 32) + 4 * v17);
      if (v102 != v101)
      {
        uint64_t v22 = 0;
        do
        {
          uint64_t v23 = *(void *)(a1 + 8) + 16 * v22;
          unsigned int v24 = *(_DWORD *)(v23 + 4);
          uint64_t Content = C3DMeshSourceGetContent(*(void *)(v23 + 8));
          __int16 v30 = WORD2(v29);
          unint64_t v31 = HIBYTE(v29);
          if (HIBYTE(v29) >= 5)
          {
            uint64_t v32 = scn_default_log();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              int v121 = "srcContent.componentCount <= 4";
              __int16 v122 = 1024;
              int v123 = v31;
              _os_log_fault_impl(&dword_20B249000, v32, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)", buf, 0x12u);
            }
          }
          *(double *)v33.i64 = C3DConvertFloatingTypeToFloat4(v30, (float *)(Content + HIBYTE(v30) * v110), v26, v27, v28);
          if (v24)
          {
            unsigned __int8 v34 = 0;
            v35.i32[0] = 0;
            v35.i32[1] = v31;
            int32x4_t v36 = vzip1q_s32((int32x4_t)(unint64_t)v35, vdupq_lane_s32(v35, 1));
            v37.i64[0] = v31 | 0x100000000;
            v37.i64[1] = 0x300000002;
            unsigned __int16 v38 = vmovn_s32(vceqq_s32(v36, v37)).u16[0];
            *(int16x4_t *)v36.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v36, (uint32x4_t)v37));
            v36.i16[0] = v38;
            int8x16_t v39 = (int8x16_t)xmmword_20B5CB530;
            v39.i32[0] = v33.i32[0];
            v33.i32[0] = 0;
            int8x16_t v40 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v36.i8), v33, v39);
            size_t v41 = *(char **)(a1 + 40);
            int8x16_t v111 = v40;
            do
            {
              int8x16_t v115 = v40;
              int v42 = *(_DWORD *)((unint64_t)&v115 & 0xFFFFFFFFFFFFFFF3 | (4 * (v34 & 3)));
              if ((unint64_t)v41 >= *v18)
              {
                uint64_t v44 = (char *)*v107;
                uint64_t v45 = (v41 - (unsigned char *)*v107) >> 2;
                unint64_t v46 = v45 + 1;
                if ((unint64_t)(v45 + 1) >> 62) {
LABEL_88:
                }
                  abort();
                uint64_t v47 = *v18 - (void)v44;
                if (v47 >> 1 > v46) {
                  unint64_t v46 = v47 >> 1;
                }
                if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v48 = v46;
                }
                if (v48)
                {
                  long long v49 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 48, v48);
                  uint64_t v44 = *(char **)(a1 + 32);
                  size_t v41 = *(char **)(a1 + 40);
                }
                else
                {
                  long long v49 = 0;
                }
                uint64_t v50 = &v49[4 * v45];
                *(_DWORD *)uint64_t v50 = v42;
                uint64_t v43 = v50 + 4;
                while (v41 != v44)
                {
                  int v51 = *((_DWORD *)v41 - 1);
                  v41 -= 4;
                  *((_DWORD *)v50 - 1) = v51;
                  v50 -= 4;
                }
                *(void *)(a1 + 32) = v50;
                *(void *)(a1 + 40) = v43;
                *(void *)(a1 + 48) = &v49[4 * v48];
                if (v44) {
                  operator delete(v44);
                }
                int8x16_t v40 = v111;
              }
              else
              {
                *(_DWORD *)size_t v41 = v42;
                uint64_t v43 = v41 + 4;
              }
              *(void *)(a1 + 40) = v43;
              ++v34;
              size_t v41 = v43;
            }
            while (v24 > v34);
          }
          ++v22;
        }
        while (v22 != v106);
      }
      if (v100 != v99)
      {
        uint64_t v52 = 0;
        do
        {
          uint64_t v53 = *(void *)(a1 + 64) + 16 * v52;
          unsigned int v54 = *(_DWORD *)(v53 + 4);
          uint64_t v55 = C3DMeshSourceGetContent(*(void *)(v53 + 8));
          __int16 v60 = WORD2(v59);
          unint64_t v61 = HIBYTE(v59);
          if (HIBYTE(v59) >= 5)
          {
            BOOL v62 = scn_default_log();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              int v121 = "srcContent.componentCount <= 4";
              __int16 v122 = 1024;
              int v123 = v61;
              _os_log_fault_impl(&dword_20B249000, v62, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)", buf, 0x12u);
            }
          }
          *(double *)v63.i64 = C3DConvertFloatingTypeToFloat4(v60, (float *)(v55 + HIBYTE(v60) * v110), v56, v57, v58);
          if (v54)
          {
            unsigned __int8 v64 = 0;
            v65.i32[0] = 0;
            v65.i32[1] = v61;
            int32x4_t v66 = vzip1q_s32((int32x4_t)(unint64_t)v65, vdupq_lane_s32(v65, 1));
            v67.i64[0] = v61 | 0x100000000;
            v67.i64[1] = 0x300000002;
            unsigned __int16 v68 = vmovn_s32(vceqq_s32(v66, v67)).u16[0];
            *(int16x4_t *)v66.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v66, (uint32x4_t)v67));
            v66.i16[0] = v68;
            int8x16_t v69 = (int8x16_t)xmmword_20B5CB530;
            v69.i32[0] = v63.i32[0];
            v63.i32[0] = 0;
            int8x16_t v70 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v66.i8), v63, v69);
            long long v71 = *(char **)(a1 + 96);
            int8x16_t v112 = v70;
            do
            {
              int8x16_t v114 = v70;
              int v72 = *(_DWORD *)((unint64_t)&v114 & 0xFFFFFFFFFFFFFFF3 | (4 * (v64 & 3)));
              if ((unint64_t)v71 >= *v19)
              {
                uint64_t v74 = (char *)*v108;
                uint64_t v75 = (v71 - (unsigned char *)*v108) >> 2;
                unint64_t v76 = v75 + 1;
                if ((unint64_t)(v75 + 1) >> 62) {
                  goto LABEL_88;
                }
                uint64_t v77 = *v19 - (void)v74;
                if (v77 >> 1 > v76) {
                  unint64_t v76 = v77 >> 1;
                }
                if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v78 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v78 = v76;
                }
                if (v78)
                {
                  unint64_t v79 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v78);
                  uint64_t v74 = *(char **)(a1 + 88);
                  long long v71 = *(char **)(a1 + 96);
                }
                else
                {
                  unint64_t v79 = 0;
                }
                BOOL v80 = &v79[4 * v75];
                *(_DWORD *)BOOL v80 = v72;
                uint64_t v73 = v80 + 4;
                while (v71 != v74)
                {
                  int v81 = *((_DWORD *)v71 - 1);
                  v71 -= 4;
                  *((_DWORD *)v80 - 1) = v81;
                  v80 -= 4;
                }
                *(void *)(a1 + 88) = v80;
                *(void *)(a1 + 96) = v73;
                *(void *)(a1 + 104) = &v79[4 * v78];
                if (v74) {
                  operator delete(v74);
                }
                int8x16_t v70 = v112;
              }
              else
              {
                *(_DWORD *)long long v71 = v72;
                uint64_t v73 = v71 + 4;
              }
              *(void *)(a1 + 96) = v73;
              ++v64;
              long long v71 = v73;
            }
            while (v54 > v64);
          }
          ++v52;
        }
        while (v52 != v105);
      }
      uint64_t v6 = v104;
      uint64_t v17 = v103 + 1;
    }
    while (v103 + 1 < (unint64_t)*(unsigned int *)(v104 + 104));
  }
  unint64_t v82 = *(void *)(a1 + 120) - *(void *)(a1 + 112);
  unsigned int v83 = (v82 >> 6);
  if ((v82 >> 6))
  {
    if (!*(_DWORD *)(v6 + 196))
    {
      int v84 = (char *)malloc_type_malloc((v82 >> 2) & 0xFF0, 0x105004037B82EA9uLL);
      uint64_t v85 = 0;
      do
      {
        uint64_t v86 = *(unsigned int *)(v6 + 208);
        *(_DWORD *)&v84[v85] = v86;
        *(void *)&v84[v85 + 8] = malloc_type_malloc(4 * v86, 0x100004052888210uLL);
        v85 += 16;
      }
      while (16 * v83 != v85);
      *(_DWORD *)(v6 + 196) = v83;
      *(void *)(v6 + 200) = v84;
    }
    uint64_t v87 = 0;
    if (v83 <= 1) {
      uint64_t v88 = 1;
    }
    else {
      uint64_t v88 = v83;
    }
    uint64_t v113 = v88;
    do
    {
      uint64_t v89 = *(void *)(a1 + 112) + (v87 << 6);
      uint64_t v91 = *(void *)(v89 + 16);
      uint64_t v90 = *(void *)(v89 + 24);
      int v118 = 0;
      Elementsuint64_t Count = C3DMeshGetElementsCount(v109);
      if ((uint64_t)ElementsCount >= 1)
      {
        CFArrayRef v93 = ElementsCount;
        CFIndex v94 = 0;
        uint64_t v95 = (v90 - v91) >> 4;
        do
        {
          ElementAtint Index = C3DMeshGetElementAtIndex(v109, v94, 0);
          char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
          if (C3DMeshElementTypeDefinesSurface(Type))
          {
            v116[0] = MEMORY[0x263EF8330];
            v116[1] = 0x40000000;
            v116[2] = ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_19;
            v116[3] = &__block_descriptor_tmp_20_4;
            v116[4] = ElementAtIndex;
            void v116[5] = v95;
            v116[6] = v89;
            v116[7] = v104;
            char v117 = v87;
            v116[8] = &v118;
            C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges((uint64_t)ElementAtIndex, (uint64_t)v116);
          }
          ++v94;
        }
        while (v93 != (const __CFArray *)v94);
      }
      if (v118 != *(_DWORD *)(v104 + 208))
      {
        uint64_t v98 = scn_default_log();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
          C3DSubdivInitGPUPrimvarDescriptor(buf, &v121, v98);
        }
      }
      ++v87;
    }
    while (v87 != v113);
  }
  else
  {
    *(_DWORD *)(v6 + 196) = 0;
    *(void *)(v6 + 200) = 0;
  }
}

void ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a3)
  {
    if ((a3 & 0xFFFFFFFE) != 2) {
      return;
    }
  }
  else if (a4)
  {
    return;
  }
  C3DMeshSourceGetContent(a2);
  if (v11 && C3DBaseTypeIsFloatingValue(v10))
  {
    if (a3)
    {
      if (a3 == 3)
      {
        int v12 = 2;
      }
      else if (a3 == 2)
      {
        int v12 = 4;
      }
      else
      {
        uint64_t v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_cold_2(a3, v13);
        }
        int v12 = 0;
      }
    }
    else
    {
      int v12 = 3;
    }
    switch(C3DSubdivSourceGetPrimvarDataType(*(void *)(a1 + 32), a2, a3, a4, 0))
    {
      case 1u:
        uint64_t v14 = *(void *)(a1 + 40);
        goto LABEL_25;
      case 2u:
        uint64_t v14 = *(void *)(a1 + 40) + 56;
        goto LABEL_25;
      case 3u:
        uint64_t v15 = *(void *)(a1 + 40);
        uint64_t v17 = *(unsigned __int8 **)(v15 + 112);
        uint64_t v18 = *(unsigned __int8 **)(v15 + 120);
        uint64_t v16 = (uint64_t *)(v15 + 112);
        break;
      default:
        ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_cold_1((uint8_t *)v34);
    }
    while (1)
    {
      if (v17 == v18)
      {
        memset(v34, 0, sizeof(v34));
        std::vector<C3DSubdivGPUFVarPrimvarData>::push_back[abi:nn180100](v16, (uint64_t)v34);
        C3DSubdivGPUFVarPrimvarData::~C3DSubdivGPUFVarPrimvarData((C3DSubdivGPUFVarPrimvarData *)v34);
        uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 120);
        *(_DWORD *)(v19 - 56) = 0;
        uint64_t v14 = v19 - 56;
        *(unsigned char *)(v14 - 8) = a5;
        goto LABEL_25;
      }
      if (*v17 == a5) {
        break;
      }
      v17 += 64;
    }
    uint64_t v14 = (uint64_t)(v17 + 8);
LABEL_25:
    int v20 = *(_DWORD *)v14;
    unint64_t v21 = *(void *)(v14 + 16);
    unint64_t v22 = *(void *)(v14 + 24);
    if (v21 >= v22)
    {
      uint64_t v24 = *(void *)(v14 + 8);
      uint64_t v25 = (uint64_t)(v21 - v24) >> 4;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 60) {
        abort();
      }
      uint64_t v27 = v22 - v24;
      if (v27 >> 3 > v26) {
        unint64_t v26 = v27 >> 3;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28) {
        unint64_t v29 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v14 + 24, v28);
      }
      else {
        unint64_t v29 = 0;
      }
      __int16 v30 = &v29[16 * v25];
      unint64_t v31 = &v29[16 * v28];
      *(_DWORD *)__int16 v30 = v20;
      *((_DWORD *)v30 + 1) = v12;
      *((void *)v30 + 1) = a2;
      uint64_t v23 = v30 + 16;
      int8x16_t v33 = *(char **)(v14 + 8);
      uint64_t v32 = *(char **)(v14 + 16);
      if (v32 != v33)
      {
        do
        {
          *((_OWORD *)v30 - 1) = *((_OWORD *)v32 - 1);
          v30 -= 16;
          v32 -= 16;
        }
        while (v32 != v33);
        uint64_t v32 = *(char **)(v14 + 8);
      }
      *(void *)(v14 + 8) = v30;
      *(void *)(v14 + 16) = v23;
      *(void *)(v14 + 24) = v31;
      if (v32) {
        operator delete(v32);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v21 = v20;
      *(_DWORD *)(v21 + 4) = v12;
      uint64_t v23 = (char *)(v21 + 16);
      *(void *)(v21 + 8) = a2;
    }
    *(void *)(v14 + 16) = v23;
    *(_DWORD *)v14 += v12;
  }
}

uint64_t std::vector<C3DSubdivGPUFVarPrimvarData>::push_back[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  if (v3 >= a1[2])
  {
    uint64_t result = std::vector<C3DSubdivGPUFVarPrimvarData>::__push_back_slow_path<C3DSubdivGPUFVarPrimvarData>(a1, a2);
  }
  else
  {
    *(unsigned char *)unint64_t v3 = *(unsigned char *)a2;
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
    *(void *)(v3 + 24) = 0;
    *(void *)(v3 + 32) = 0;
    *(void *)(v3 + 16) = 0;
    *(_OWORD *)(v3 + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(v3 + 32) = *(void *)(a2 + 32);
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(v3 + 40) = 0;
    *(void *)(v3 + 48) = 0;
    *(void *)(v3 + 56) = 0;
    *(_OWORD *)(v3 + 40) = *(_OWORD *)(a2 + 40);
    *(void *)(v3 + 56) = *(void *)(a2 + 56);
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    uint64_t result = v3 + 64;
  }
  a1[1] = result;
  return result;
}

void C3DSubdivGPUFVarPrimvarData::~C3DSubdivGPUFVarPrimvarData(C3DSubdivGPUFVarPrimvarData *this)
{
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

void ___Z33C3DSubdivInitGPUPrimvarDescriptorP29C3DSubdivGPUPrimvarDescriptorPK26C3DGeometrySubdivisionInfoP9__C3DMesh_block_invoke_19(uint64_t a1, unsigned int a2)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v42 = a2;
  VertexCountForPrimitiveAtuint64_t Index = C3DMeshElementGetVertexCountForPrimitiveAtIndex(*(void *)(a1 + 32), a2);
  if (VertexCountForPrimitiveAtIndex >= 1)
  {
    uint64_t v43 = 0;
    unint64_t v3 = *(void *)(a1 + 40);
    do
    {
      if (v3)
      {
        for (unint64_t i = 0; i < v3; ++i)
        {
          uint64_t Count = C3DMeshSourceGetCount(*(void *)(*(void *)(*(void *)(a1 + 48) + 16) + 16 * i + 8));
          uint64_t v6 = 0x80000000;
          if (Count < 0x80000000) {
            uint64_t v6 = Count;
          }
          uint64_t v7 = v6 - 1;
          uint64_t Index = C3DMeshElementGetIndex(*(void *)(a1 + 32), v42, v43, **(unsigned __int8 **)(a1 + 48));
          *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 200) + 16 * *(unsigned __int8 *)(a1 + 72) + 8)
                    + 4 * **(unsigned int **)(a1 + 64)) = **(_DWORD **)(a1 + 64);
          if (Index >= v7) {
            int v9 = v7;
          }
          else {
            int v9 = Index;
          }
          uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 16) + 16 * i;
          unsigned int v11 = *(_DWORD *)(v10 + 4);
          uint64_t Content = C3DMeshSourceGetContent(*(void *)(v10 + 8));
          __int16 v17 = WORD2(v16);
          unint64_t v18 = HIBYTE(v16);
          if (HIBYTE(v16) >= 5)
          {
            uint64_t v19 = scn_default_log();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              uint64_t v47 = "srcContent.componentCount <= 4";
              __int16 v48 = 1024;
              int v49 = v18;
              _os_log_fault_impl(&dword_20B249000, v19, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)", buf, 0x12u);
            }
          }
          *(double *)v20.i64 = C3DConvertFloatingTypeToFloat4(v17, (float *)(Content + HIBYTE(v17) * v9), v13, v14, v15);
          if (v11)
          {
            unsigned __int8 v21 = 0;
            v22.i32[0] = 0;
            v22.i32[1] = v18;
            v23.i64[0] = v18 | 0x100000000;
            int32x4_t v24 = vzip1q_s32((int32x4_t)(unint64_t)v22, vdupq_lane_s32(v22, 1));
            v23.i64[1] = 0x300000002;
            unsigned __int16 v25 = vmovn_s32(vceqq_s32(v24, v23)).u16[0];
            *(int16x4_t *)v24.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v24, (uint32x4_t)v23));
            v24.i16[0] = v25;
            int8x16_t v26 = (int8x16_t)xmmword_20B5CB530;
            v26.i32[0] = v20.i32[0];
            v20.i32[0] = 0;
            int8x16_t v27 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v24.i8), v20, v26);
            int8x16_t v44 = v27;
            do
            {
              unint64_t v28 = *(void **)(a1 + 48);
              int8x16_t v45 = v27;
              int v29 = *(_DWORD *)((unint64_t)&v45 & 0xFFFFFFFFFFFFFFF3 | (4 * (v21 & 3)));
              __int16 v30 = (char *)v28[6];
              unint64_t v31 = v28[7];
              if ((unint64_t)v30 >= v31)
              {
                int8x16_t v33 = (char *)v28[5];
                uint64_t v34 = (v30 - v33) >> 2;
                unint64_t v35 = v34 + 1;
                if ((unint64_t)(v34 + 1) >> 62) {
                  abort();
                }
                uint64_t v36 = v31 - (void)v33;
                if (v36 >> 1 > v35) {
                  unint64_t v35 = v36 >> 1;
                }
                if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v37 = v35;
                }
                if (v37)
                {
                  unsigned __int16 v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v28 + 7), v37);
                  int8x16_t v33 = (char *)v28[5];
                  __int16 v30 = (char *)v28[6];
                }
                else
                {
                  unsigned __int16 v38 = 0;
                }
                int8x16_t v39 = &v38[4 * v34];
                *(_DWORD *)int8x16_t v39 = v29;
                uint64_t v32 = v39 + 4;
                while (v30 != v33)
                {
                  int v40 = *((_DWORD *)v30 - 1);
                  v30 -= 4;
                  *((_DWORD *)v39 - 1) = v40;
                  v39 -= 4;
                }
                v28[5] = v39;
                _OWORD v28[6] = v32;
                v28[7] = &v38[4 * v37];
                if (v33) {
                  operator delete(v33);
                }
                int8x16_t v27 = v44;
              }
              else
              {
                *(_DWORD *)__int16 v30 = v29;
                uint64_t v32 = v30 + 4;
              }
              _OWORD v28[6] = v32;
              ++v21;
            }
            while (v11 > v21);
          }
          unint64_t v3 = *(void *)(a1 + 40);
        }
      }
      ++**(_DWORD **)(a1 + 64);
      ++v43;
    }
    while (v43 != VertexCountForPrimitiveAtIndex);
  }
}

void C3DSubdivComputeElementToFaceRangeTable(OpenSubdiv::v3_1_1::Far::TopologyRefiner *a1, __C3DMesh *a2)
{
  v20[4] = *MEMORY[0x263EF8340];
  std::string __p = 0;
  uint64_t v19 = 0;
  v20[0] = 0;
  Elementsuint64_t Count = C3DMeshGetElementsCount((uint64_t)a2);
  if (ElementsCount)
  {
    CFIndex v4 = 0;
    int v5 = 0;
    do
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)a2, v4, 0);
      char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
      if (C3DMeshElementTypeDefinesSurface(Type))
      {
        v5 += C3DMeshElementGetPrimitiveCountByEvaluatingPrimitiveRanges((uint64_t)ElementAtIndex);
        uint64_t v8 = v19;
        if ((unint64_t)v19 >= v20[0])
        {
          uint64_t v10 = __p;
          uint64_t v11 = (v19 - __p) >> 2;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 62) {
            abort();
          }
          uint64_t v13 = v20[0] - (void)__p;
          if ((uint64_t)(v20[0] - (void)__p) >> 1 > v12) {
            unint64_t v12 = v13 >> 1;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            float v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v20, v14);
            uint64_t v10 = __p;
            uint64_t v8 = v19;
          }
          else
          {
            float v15 = 0;
          }
          unint64_t v16 = &v15[4 * v11];
          *(_DWORD *)unint64_t v16 = v5;
          int v9 = v16 + 4;
          while (v8 != v10)
          {
            int v17 = *((_DWORD *)v8 - 1);
            v8 -= 4;
            *((_DWORD *)v16 - 1) = v17;
            v16 -= 4;
          }
          std::string __p = v16;
          v20[0] = &v15[4 * v14];
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v19 = v5;
          int v9 = v19 + 4;
        }
        uint64_t v19 = v9;
      }
      ++v4;
    }
    while (v4 != ElementsCount);
  }
  operator new();
}

uint64_t C3DSubdivComputeElementToPatchRangeTable(OpenSubdiv::v3_1_1::Far::TopologyRefiner *a1, const OpenSubdiv::v3_1_1::Far::PatchTable *a2, __C3DMesh *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  int v40 = &v39;
  uint64_t v41 = 0x2000000000;
  int v42 = 0;
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  unsigned __int16 v38 = 0;
  Elementsuint64_t Count = C3DMeshGetElementsCount((uint64_t)a3);
  if ((ElementsCount & 0xFE) == 0) {
    goto LABEL_35;
  }
  CFIndex v6 = 0;
  unsigned __int16 v25 = a2;
  uint64_t v7 = ElementsCount;
  do
  {
    ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)a3, v6, 0);
    unsigned int Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
    if (!C3DMeshElementTypeDefinesSurface(Type)) {
      goto LABEL_28;
    }
    if (Type >= 2)
    {
      if (Type == 4)
      {
        unsigned __int8 ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex((uint64_t)a3, 0, 0);
        uint64_t v30 = 0;
        __n128 v28 = 0u;
        __n128 v29 = 0u;
        __n128 v27 = 0u;
        C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v27);
        v34[0] = v27;
        v34[1] = v28;
        void v34[2] = v29;
        uint64_t v35 = v30;
        v33[0] = MEMORY[0x263EF8330];
        v33[1] = 0x40000000;
        v33[2] = ___Z40C3DSubdivComputeElementToPatchRangeTablePN10OpenSubdiv6v3_1_13Far15TopologyRefinerEPKNS1_10PatchTableEP9__C3DMesh_block_invoke;
        v33[3] = &unk_264009368;
        v33[4] = &v39;
        C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges((uint64_t)v34, (uint64_t)v33, v29);
        goto LABEL_11;
      }
      if (Type != 5)
      {
        unint64_t v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          C3DSubdivComputeElementToPatchRangeTable(&buf, v32, v12);
        }
        goto LABEL_11;
      }
    }
    int PrimitiveCountByEvaluatingPrimitiveRanges = C3DMeshElementGetPrimitiveCountByEvaluatingPrimitiveRanges((uint64_t)ElementAtIndex);
    *((_DWORD *)v40 + 6) += 3 * PrimitiveCountByEvaluatingPrimitiveRanges;
LABEL_11:
    uint64_t v13 = v40;
    unint64_t v14 = v37;
    if (v37 >= v38)
    {
      unint64_t v16 = v36;
      uint64_t v17 = (v37 - v36) >> 2;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 62) {
        abort();
      }
      uint64_t v19 = v38 - v36;
      if ((v38 - v36) >> 1 > v18) {
        unint64_t v18 = v19 >> 1;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        unsigned __int8 v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v38, v20);
        unint64_t v16 = v36;
        unint64_t v14 = v37;
      }
      else
      {
        unsigned __int8 v21 = 0;
      }
      int32x2_t v22 = &v21[4 * v17];
      *(_DWORD *)int32x2_t v22 = *((_DWORD *)v13 + 6);
      float v15 = v22 + 4;
      while (v14 != v16)
      {
        int v23 = *((_DWORD *)v14 - 1);
        v14 -= 4;
        *((_DWORD *)v22 - 1) = v23;
        v22 -= 4;
      }
      uint64_t v36 = v22;
      unint64_t v37 = v15;
      unsigned __int16 v38 = &v21[4 * v20];
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v37 = *((_DWORD *)v40 + 6);
      float v15 = v14 + 4;
    }
    unint64_t v37 = v15;
LABEL_28:
    ++v6;
  }
  while (v6 != v7);
  if (((unint64_t)(v37 - v36) >> 2) >= 2)
  {
    OpenSubdiv::v3_1_1::Osd::CpuPatchTable::CpuPatchTable((OpenSubdiv::v3_1_1::Osd::CpuPatchTable *)&v27, v25);
    std::vector<std::vector<CFRange>>::vector(v26, ((v27.n128_u64[1] - v27.n128_u64[0]) >> 4));
    operator new();
  }
  if (v36)
  {
    unint64_t v37 = v36;
    operator delete(v36);
  }
LABEL_35:
  _Block_object_dispose(&v39, 8);
  return 0;
}

uint64_t ___Z40C3DSubdivComputeElementToPatchRangeTablePN10OpenSubdiv6v3_1_13Far15TopologyRefinerEPKNS1_10PatchTableEP9__C3DMesh_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 4) {
    int v4 = 1;
  }
  else {
    int v4 = a4;
  }
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) += v4;
  return result;
}

void C3DSubdivCreateMesh(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, __C3DMesh *a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v10 = (OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(void *)(a3 + 88)
                                                    + 24 * (((unint64_t)*(unsigned __int8 *)(a3 + 8) >> 2) & 0xF));
  unsigned __int16 v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  __C3DSubdivCreateMesh(a2, a4, v10, a1 + 9, 0, (void **)&v25);
  __C3DSubdivCreateMesh(a2, a4, v10, a1 + 18, 0, (void **)&v25);
  unint64_t v12 = (void *)a1[27];
  uint64_t v13 = (void *)a1[28];
  while (v12 != v13)
  {
    __C3DSubdivCreateMesh(a2, a4, v10, v12, 1, (void **)&v25);
    v12 += 9;
  }
  uint8_t v22[8] = v22;
  CFIndex v14 = (-85 * ((v26 - v25) >> 3));
  MEMORY[0x270FA5388](v11);
  int32x4_t v24 = (char *)v22 - v15;
  CFAllocatorRef v23 = (CFAllocatorRef)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v23, v14, MEMORY[0x263EFFF70]);
  if (v14)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 24 * v14;
    uint64_t v19 = v24;
    do
    {
      unint64_t v20 = (const void **)&v25[v17];
      if (v25[v17]) {
        char v21 = v25[v17 + 1] + 1;
      }
      else {
        char v21 = 0;
      }
      *v19++ = v21;
      CFArrayAppendValue(Mutable, v20[2]);
      CFRelease(v20[2]);
      v17 += 24;
    }
    while (v18 != v17);
  }
  C3DSubdivComputeElementToFaceRangeTable((OpenSubdiv::v3_1_1::Far::TopologyRefiner *)a3, a5);
}

void __C3DSubdivCreateMesh(uint64_t a1, uint64_t *a2, OpenSubdiv::v3_1_1::Vtr::internal::Level **a3, void *a4, int a5, void **a6)
{
  uint64_t v12 = a4[1] - *a4;
  if (v12)
  {
    uint64_t v13 = 0;
    unint64_t v14 = v12 / 112;
    if (v14 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v14;
    }
    do
    {
      _ZN23C3DSubdivCPUPrimvarDataIDv2_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext(*a4 + v13, a3, a2, a5, a1 + 2, a6);
      v13 += 112;
      --v15;
    }
    while (v15);
  }
  uint64_t v16 = a4[4] - a4[3];
  if (v16)
  {
    uint64_t v17 = 0;
    unint64_t v18 = v16 / 112;
    if (v18 <= 1) {
      uint64_t v19 = 1;
    }
    else {
      uint64_t v19 = v18;
    }
    do
    {
      _ZN23C3DSubdivCPUPrimvarDataIDv3_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext(a4[3] + v17, a3, a2, a5, a1 + 2, a6);
      v17 += 112;
      --v19;
    }
    while (v19);
  }
  uint64_t v20 = a4[7] - a4[6];
  if (v20)
  {
    uint64_t v21 = 0;
    unint64_t v22 = v20 / 112;
    uint64_t v23 = a1 + 2;
    if (v22 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v22;
    }
    do
    {
      _ZN23C3DSubdivCPUPrimvarDataIDv4_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext(a4[6] + v21, a3, a2, a5, v23, a6);
      v21 += 112;
      --v24;
    }
    while (v24);
  }
}

void C3DGeometryInvalidateSubdivCreaseAndCornerTopologyInfo(__C3DGeometry *a1)
{
  var7 = (void **)a1->var10.var7;
  if (var7)
  {
    free(var7[17]);
    free(var7[18]);
    free(var7[20]);
    free(var7[21]);
    *((_DWORD *)var7 + 32) = 0;
    var7[17] = 0;
    var7[18] = 0;
    *((_DWORD *)var7 + 38) = 0;
    var7[20] = 0;
    var7[21] = 0;
  }
}

uint64_t _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE9push_backB8nn180100ERKS3_(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 4);
    if ((unint64_t)(v10 + 1) > 0x249249249249249) {
      abort();
    }
    unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 4);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x124924924924924) {
      unint64_t v13 = 0x249249249249249;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      unint64_t v14 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m(v4, v13);
    }
    else {
      unint64_t v14 = 0;
    }
    uint64_t v15 = v14;
    uint64_t v16 = &v14[112 * v10];
    unint64_t v18 = &v14[112 * v13];
    _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2ERKS1_((uint64_t)v16, a2);
    uint64_t v17 = v16 + 112;
    _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = (uint64_t)_ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv2_fERNS_9allocatorIS3_EEED2Ev(&v15);
  }
  else
  {
    uint64_t result = _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2ERKS1_(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 112;
  }
  a1[1] = v9;
  return result;
}

uint64_t _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2EPK15__C3DMeshSourceP29C3DGeometrySubdivTopologyInfoPN10OpenSubdiv6v3_1_13Far15TopologyRefinerEh37C3DSubdivPrimvarDataInterpolationMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  *(void *)(a1 + ++*(_DWORD *)(result + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 72) = a5;
  unint64_t v9 = ((unint64_t)*(unsigned __int8 *)(a4 + 8) >> 2) & 0xF;
  *(_DWORD *)(a1 + 76) = v9;
  *(void *)(a1 + 80) = a2;
  *(unsigned char *)(a1 + 88) = a6;
  uint64_t v10 = *(OpenSubdiv::v3_1_1::Vtr::internal::Level ***)(a4 + 88);
  unint64_t v11 = &v10[3 * v9];
  if (a6 == 2)
  {
    uint64_t Content = C3DMeshSourceGetContent(a2);
    uint64_t v14 = v13;
    unint64_t v15 = v13;
    unint64_t NumFVarValues = (int)OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*v11, *(unsigned __int8 *)(a1 + 72));
    int NumFVarValuesTotal = OpenSubdiv::v3_1_1::Far::TopologyRefiner::GetNumFVarValuesTotal((OpenSubdiv::v3_1_1::Far::TopologyRefiner *)a4, *(unsigned __int8 *)(a1 + 72));
    unint64_t v18 = (int)(NumFVarValuesTotal
              - OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*v10, *(unsigned __int8 *)(a1 + 72)))
        - NumFVarValues;
    std::vector<ClippedCorner>::resize(a1, v15);
    if (v14)
    {
      int v22 = 0;
      int v23 = 0;
      do
      {
        *(double *)v19.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v14), (float *)(Content + v22), v19, v20, v21);
        *(void *)(*(void *)a1 + 8 * v23++) = v19.i64[0];
        v22 += BYTE5(v14);
      }
      while (v14 != v23);
    }
  }
  else
  {
    unint64_t v25 = *((int *)*v10 + 2);
    unint64_t NumFVarValues = *((int *)*v11 + 2);
    unint64_t v18 = *(int *)(a4 + 20) - v25 - NumFVarValues;
    std::vector<ClippedCorner>::resize(a1, v25);
    uint64_t v26 = C3DMeshSourceGetContent(a2);
    if (v25)
    {
      uint64_t v32 = v26;
      uint64_t v33 = 0;
      int v34 = v25;
      int v35 = v27;
      int v36 = v28;
      do
      {
        *(double *)v29.i64 = C3DConvertFloatingTypeToFloat4(v35, (float *)(v32 + *(int *)(*(void *)(a3 + 32) + 4 * v33) * (uint64_t)v36), v29, v30, v31);
        *(void *)(*(void *)a1 + 8 * (int)v33++) = v29.i64[0];
      }
      while (v34 != v33);
    }
  }
  std::vector<ClippedCorner>::resize(a1 + 24, v18);
  std::vector<ClippedCorner>::resize(a1 + 48, NumFVarValues);
  if (*(void *)(a1 + 32) == *(void *)(a1 + 24)) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 96) = *(void *)a1;
  *(void *)(a1 + 104) = v37;
  return a1;
}

uint64_t _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2ERKS1_(uint64_t result, uint64_t a2)
{
  *(void *)(result + ++*(_DWORD *)(result + 64) = 0;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(void *)uint64_t result = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  uint64_t v4 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v4;
  uint64_t v5 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v5;
  uint64_t v6 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v6;
  uint64_t v7 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v7;
  uint64_t v8 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v8;
  uint64_t v9 = *(void *)(result + 64);
  *(void *)(result + ++*(_DWORD *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + ++*(_DWORD *)(result + 64) = v9;
  *(unsigned char *)(result + 72) = *(unsigned char *)(a2 + 72);
  *(_DWORD *)(result + 76) = *(_DWORD *)(a2 + 76);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(unsigned char *)(result + 88) = *(unsigned char *)(a2 + 88);
  if (*(void *)(result + 32) == *(void *)(result + 24)) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(result + 24);
  }
  *(void *)(result + 96) = *(void *)result;
  *(void *)(result + 104) = v10;
  return result;
}

uint64_t _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 112;
    uint64_t result = _ZN23C3DSubdivCPUPrimvarDataIDv2_fEC2ERKS1_(result - 112, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(112 * a2);
}

void **_ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv2_fERNS_9allocatorIS3_EEED2Ev(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void _ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv2_fERNS_9allocatorIS3_EEE5clearB8nn180100Ev(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 112;
    _ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEE7destroyB8nn180100EPS3_(v4, i - 112);
  }
}

uint64_t _ZN23C3DSubdivCPUPrimvarDataIDv3_fEC2EPK15__C3DMeshSourceP29C3DGeometrySubdivTopologyInfoPN10OpenSubdiv6v3_1_13Far15TopologyRefinerEh37C3DSubdivPrimvarDataInterpolationMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  *(void *)(a1 + ++*(_DWORD *)(result + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 72) = a5;
  unint64_t v9 = ((unint64_t)*(unsigned __int8 *)(a4 + 8) >> 2) & 0xF;
  *(_DWORD *)(a1 + 76) = v9;
  *(void *)(a1 + 80) = a2;
  *(unsigned char *)(a1 + 88) = a6;
  uint64_t v10 = *(OpenSubdiv::v3_1_1::Vtr::internal::Level ***)(a4 + 88);
  unint64_t v11 = &v10[3 * v9];
  if (a6 == 2)
  {
    uint64_t Content = C3DMeshSourceGetContent(a2);
    uint64_t v14 = v13;
    unint64_t v15 = v13;
    unint64_t NumFVarValues = (int)OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*v11, *(unsigned __int8 *)(a1 + 72));
    int NumFVarValuesTotal = OpenSubdiv::v3_1_1::Far::TopologyRefiner::GetNumFVarValuesTotal((OpenSubdiv::v3_1_1::Far::TopologyRefiner *)a4, *(unsigned __int8 *)(a1 + 72));
    unint64_t v18 = (int)(NumFVarValuesTotal
              - OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*v10, *(unsigned __int8 *)(a1 + 72)))
        - NumFVarValues;
    _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1, v15);
    if (v14)
    {
      int v22 = 0;
      int v23 = 0;
      do
      {
        *(double *)v19.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v14), (float *)(Content + v22), v19, v20, v21);
        *(float32x4_t *)(*(void *)a1 + 16 * v23++) = v19;
        v22 += BYTE5(v14);
      }
      while (v14 != v23);
    }
  }
  else
  {
    unint64_t v25 = *((int *)*v10 + 2);
    unint64_t NumFVarValues = *((int *)*v11 + 2);
    unint64_t v18 = *(int *)(a4 + 20) - v25 - NumFVarValues;
    _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1, v25);
    uint64_t v26 = C3DMeshSourceGetContent(a2);
    if (v25)
    {
      uint64_t v32 = v26;
      uint64_t v33 = 0;
      int v34 = v25;
      int v35 = v27;
      int v36 = v28;
      do
      {
        *(double *)v29.i64 = C3DConvertFloatingTypeToFloat4(v35, (float *)(v32 + *(int *)(*(void *)(a3 + 32) + 4 * v33) * (uint64_t)v36), v29, v30, v31);
        *(float32x4_t *)(*(void *)a1 + 16 * (int)v33++) = v29;
      }
      while (v34 != v33);
    }
  }
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1 + 24, v18);
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1 + 48, NumFVarValues);
  if (*(void *)(a1 + 32) == *(void *)(a1 + 24)) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 96) = *(void *)a1;
  *(void *)(a1 + 104) = v37;
  return a1;
}

void _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      uint64_t v13 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[16 * v10];
    unint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    unint64_t v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void _ZN23C3DSubdivCPUPrimvarDataIDv2_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(uint64_t a1, int a2, int **a3, uint64_t a4, double a5, double a6)
{
  if (*(_DWORD *)(a1 + 76) < a2)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _ZN23C3DSubdivCPUPrimvarDataIDv2_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  int v18 = *(unsigned __int8 *)(a1 + 88);
  if (*(_DWORD *)(a1 + 76) != a2)
  {
    if (v18 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fES7_EEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v18 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner18InterpolateVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t)a3, a2, (void *)(a1 + 96), (void *)(a1 + 104), a5, a6);
    }
    else
    {
      if (*(unsigned char *)(a1 + 88))
      {
LABEL_20:
        uint64_t v19 = *(void *)(a1 + 104);
        uint64_t v20 = v19 + 8 * *(int *)(*(void *)(*(void *)(a4 + 88) + 24 * a2) + 8);
        *(void *)(a1 + 96) = v19;
        *(void *)(a1 + 104) = v20;
        return;
      }
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(unsigned char *)(a1 + 88) == 2)
    {
      *(void *)(a1 + 96) = *(void *)(a1 + 104);
      *(void *)(a1 + 104) += 8
                             * (int)OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(void *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_20;
  }
  if (v18 == 2)
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v18 == 1)
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner18InterpolateVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t)a3, a2, (void *)(a1 + 96), (void *)(a1 + 48), a5, a6);
  }
  else if (!*(unsigned char *)(a1 + 88))
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  std::vector<ClippedCorner>::resize(a1, 0);
  std::vector<ClippedCorner>::resize(a1 + 24, 0);
}

void _ZN23C3DSubdivCPUPrimvarDataIDv3_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(uint64_t a1, int a2, int **a3, uint64_t a4, double a5, double a6, float32x4_t a7)
{
  if (*(_DWORD *)(a1 + 76) < a2)
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      _ZN23C3DSubdivCPUPrimvarDataIDv2_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  int v19 = *(unsigned __int8 *)(a1 + 88);
  if (*(_DWORD *)(a1 + 76) != a2)
  {
    if (v19 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv3_fES7_EEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v19 == 1)
    {
      if (a2 < 1 || (uint64_t v39 = *((void *)*a3 + 8), (int)((unint64_t)(*((void *)*a3 + 9) - v39) >> 3) < a2)) {
        _ZN23C3DSubdivCPUPrimvarDataIDv3_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1();
      }
      uint64_t v40 = *(void *)(v39 + 8 * (a2 - 1));
      uint64_t v41 = *(int **)(v40 + 8);
      if (*(int *)(v40 + 52) >= 1 && *v41 >= 1)
      {
        uint64_t v42 = 0;
        do
        {
          uint64_t v43 = *(int *)(*(void *)(v40 + 168) + 4 * v42);
          if (v43 != -1)
          {
            uint64_t v44 = *((void *)v41 + 6);
            uint64_t v45 = *(unsigned int *)(*((void *)v41 + 3) + 8 * v42);
            uint64_t v46 = *(int *)(*((void *)v41 + 3) + 8 * v42 + 4);
            *(_OWORD *)(*(void *)(a1 + 104) + 16 * v43) = 0uLL;
            if ((int)v45 >= 1)
            {
              uint64_t v47 = (int *)(v44 + 4 * v46);
              a7.f32[0] = 1.0 / (float)(int)v45;
              a7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0);
              do
              {
                uint64_t v48 = *v47++;
                *(float32x4_t *)(*(void *)(a1 + 104) + 16 * v43) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 104) + 16 * v43), *(float32x4_t *)(*(void *)(a1 + 96) + 16 * v48), a7);
                --v45;
              }
              while (v45);
            }
          }
          ++v42;
        }
        while (v42 < *v41);
      }
      int v49 = v41[1];
      if (v49 >= 1)
      {
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        v52.i64[0] = 0x3F0000003F000000;
        v52.i64[1] = 0x3F0000003F000000;
        do
        {
          uint64_t v53 = *(int *)(*(void *)(v40 + 216) + 4 * v51);
          if (v53 != -1)
          {
            unsigned int v54 = (int *)(*((void *)v41 + 15) + v50);
            *(_OWORD *)(*(void *)(a1 + 104) + 16 * v53) = 0uLL;
            *(float32x4_t *)(*(void *)(a1 + 104) + 16 * v53) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 104) + 16 * v53), v52, *(float32x4_t *)(*(void *)(a1 + 96) + 16 * *v54));
            *(float32x4_t *)(*(void *)(a1 + 104) + 16 * v53) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 104) + 16 * v53), v52, *(float32x4_t *)(*(void *)(a1 + 96) + 16 * v54[1]));
            int v49 = v41[1];
          }
          ++v51;
          v50 += 8;
        }
        while (v51 < v49);
      }
      int v55 = v41[2];
      if (v55 >= 1)
      {
        for (uint64_t i = 0; i < v55; ++i)
        {
          uint64_t v57 = *(int *)(*(void *)(v40 + 240) + 4 * i);
          if (v57 != -1)
          {
            *(_OWORD *)(*(void *)(a1 + 104) + 16 * v57) = 0uLL;
            *(float32x4_t *)(*(void *)(a1 + 104) + 16 * v57) = vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 96) + 16 * i), *(float32x4_t *)(*(void *)(a1 + 104) + 16 * v57));
            int v55 = v41[2];
          }
        }
      }
    }
    else
    {
      if (*(unsigned char *)(a1 + 88))
      {
LABEL_58:
        uint64_t v58 = *(void *)(a1 + 104);
        uint64_t v59 = v58 + 16 * *(int *)(*(void *)(*(void *)(a4 + 88) + 24 * a2) + 8);
        *(void *)(a1 + 96) = v58;
        *(void *)(a1 + 104) = v59;
        return;
      }
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(unsigned char *)(a1 + 88) == 2)
    {
      *(void *)(a1 + 96) = *(void *)(a1 + 104);
      *(void *)(a1 + 104) += 16
                             * (int)OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(void *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_58;
  }
  if (v19 == 2)
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v19 == 1)
  {
    if (a2 < 1 || (uint64_t v20 = *((void *)*a3 + 8), (int)((unint64_t)(*((void *)*a3 + 9) - v20) >> 3) < a2)) {
      _ZN23C3DSubdivCPUPrimvarDataIDv3_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1();
    }
    uint64_t v21 = *(void *)(v20 + 8 * (a2 - 1));
    int v22 = *(int **)(v21 + 8);
    if (*(int *)(v21 + 52) >= 1 && *v22 >= 1)
    {
      uint64_t v23 = 0;
      do
      {
        uint64_t v24 = *(int *)(*(void *)(v21 + 168) + 4 * v23);
        if (v24 != -1)
        {
          uint64_t v25 = *((void *)v22 + 6);
          uint64_t v26 = *(unsigned int *)(*((void *)v22 + 3) + 8 * v23);
          uint64_t v27 = *(int *)(*((void *)v22 + 3) + 8 * v23 + 4);
          *(_OWORD *)(*(void *)(a1 + 48) + 16 * v24) = 0uLL;
          if ((int)v26 >= 1)
          {
            unsigned __int8 v28 = (int *)(v25 + 4 * v27);
            a7.f32[0] = 1.0 / (float)(int)v26;
            a7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0);
            do
            {
              uint64_t v29 = *v28++;
              *(float32x4_t *)(*(void *)(a1 + 48) + 16 * v24) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 48) + 16 * v24), *(float32x4_t *)(*(void *)(a1 + 96) + 16 * v29), a7);
              --v26;
            }
            while (v26);
          }
        }
        ++v23;
      }
      while (v23 < *v22);
    }
    int v30 = v22[1];
    if (v30 >= 1)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      v33.i64[0] = 0x3F0000003F000000;
      v33.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v34 = *(int *)(*(void *)(v21 + 216) + 4 * v32);
        if (v34 != -1)
        {
          int v35 = (int *)(*((void *)v22 + 15) + v31);
          *(_OWORD *)(*(void *)(a1 + 48) + 16 * v34) = 0uLL;
          *(float32x4_t *)(*(void *)(a1 + 48) + 16 * v34) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 48) + 16 * v34), v33, *(float32x4_t *)(*(void *)(a1 + 96) + 16 * *v35));
          *(float32x4_t *)(*(void *)(a1 + 48) + 16 * v34) = vmlaq_f32(*(float32x4_t *)(*(void *)(a1 + 48) + 16 * v34), v33, *(float32x4_t *)(*(void *)(a1 + 96) + 16 * v35[1]));
          int v30 = v22[1];
        }
        ++v32;
        v31 += 8;
      }
      while (v32 < v30);
    }
    int v36 = v22[2];
    if (v36 >= 1)
    {
      for (uint64_t j = 0; j < v36; ++j)
      {
        uint64_t v38 = *(int *)(*(void *)(v21 + 240) + 4 * j);
        if (v38 != -1)
        {
          *(_OWORD *)(*(void *)(a1 + 48) + 16 * v38) = 0uLL;
          *(float32x4_t *)(*(void *)(a1 + 48) + 16 * v38) = vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 96) + 16 * j), *(float32x4_t *)(*(void *)(a1 + 48) + 16 * v38));
          int v36 = v22[2];
        }
      }
    }
  }
  else if (!*(unsigned char *)(a1 + 88))
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1, 0);
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1 + 24, 0);
}

void _ZN23C3DSubdivCPUPrimvarDataIDv4_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE(uint64_t a1, int a2, int **a3, uint64_t a4, double a5, float32x4_t a6)
{
  if (*(_DWORD *)(a1 + 76) < a2)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _ZN23C3DSubdivCPUPrimvarDataIDv2_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  int v18 = *(unsigned __int8 *)(a1 + 88);
  if (*(_DWORD *)(a1 + 76) != a2)
  {
    if (v18 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv4_fES7_EEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v18 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner18InterpolateVaryingIP16C3DSubdivCPUDataIDv4_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t)a3, a2, (void *)(a1 + 96), (void *)(a1 + 104), a5, a6);
    }
    else
    {
      if (*(unsigned char *)(a1 + 88))
      {
LABEL_20:
        uint64_t v19 = *(void *)(a1 + 104);
        uint64_t v20 = v19 + 16 * *(int *)(*(void *)(*(void *)(a4 + 88) + 24 * a2) + 8);
        *(void *)(a1 + 96) = v19;
        *(void *)(a1 + 104) = v20;
        return;
      }
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv4_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(unsigned char *)(a1 + 88) == 2)
    {
      *(void *)(a1 + 96) = *(void *)(a1 + 104);
      *(void *)(a1 + 104) += 16
                             * (int)OpenSubdiv::v3_1_1::Vtr::internal::Level::getNumFVarValues(*(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(void *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_20;
  }
  if (v18 == 2)
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv4_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v18 == 1)
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner18InterpolateVaryingIP16C3DSubdivCPUDataIDv4_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t)a3, a2, (void *)(a1 + 96), (void *)(a1 + 48), a5, a6);
  }
  else if (!*(unsigned char *)(a1 + 88))
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv4_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1, 0);
  _ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE6resizeEm(a1 + 24, 0);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = (a2 - 1);
  if (a2 < 1 || (int)((*(void *)(*a1 + 72) - *(void *)(*a1 + 64)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0__cold_1();
  }
  int v9 = *(_DWORD *)*a1;
  if (v9)
  {
    if (v9 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
    }
    else if (v9 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(*(void *)(*a1 + 64) + 8 * v4);
    uint64_t v12 = *(void *)(v11 + 8);
    uint64_t v13 = *(unsigned int *)(v12 + 16);
    std::string __p = 0;
    if (v13 >= 9)
    {
      uint64_t v10 = operator new(4 * v13);
      std::string __p = v10;
    }
    int v14 = *(_DWORD *)(v12 + 4);
    if (v14 >= 1)
    {
      uint64_t v15 = 0;
      for (uint64_t i = 0; i < v14; ++i)
      {
        uint64_t v17 = *(int *)(*(void *)(v11 + 216) + 4 * i);
        if (v17 != -1)
        {
          int v18 = (int *)(*(void *)(v12 + 120) + v15);
          *(void *)(*a4 + 8 * v17) = 0;
          *(float32x2_t *)(*a4 + 8 * v17) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v17), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * *v18));
          *(float32x2_t *)(*a4 + 8 * v17) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v17), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v18[1]));
          int v14 = *(_DWORD *)(v12 + 4);
        }
        v15 += 8;
      }
      uint64_t v10 = __p;
    }
    operator delete(v10);
    uint64_t v19 = 0;
    uint64_t v20 = *(void *)(*(void *)(*a1 + 64) + 8 * v4);
    uint64_t v21 = *(void *)(v20 + 8);
    uint64_t v26 = 0;
    if ((2 * *(_DWORD *)(v21 + 20)) >= 0x21)
    {
      uint64_t v19 = operator new(4 * (2 * *(_DWORD *)(v21 + 20)));
      uint64_t v26 = v19;
    }
    int v22 = *(_DWORD *)(v21 + 8);
    if (v22 >= 1)
    {
      for (uint64_t j = 0; j < v22; ++j)
      {
        uint64_t v24 = *(int *)(*(void *)(v20 + 240) + 4 * j);
        if (v24 != -1)
        {
          *(void *)(*a4 + 8 * v24) = 0;
          *(float32x2_t *)(*a4 + 8 * v24) = vadd_f32(*(float32x2_t *)(*a3 + 8 * j), *(float32x2_t *)(*a4 + 8 * v24));
          int v22 = *(_DWORD *)(v21 + 8);
        }
      }
      uint64_t v19 = v26;
    }
    operator delete(v19);
  }
}

uint64_t _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner18InterpolateVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_(uint64_t result, int a2, void *a3, void *a4, double a5, double a6)
{
  if (a2 < 1
    || (uint64_t v6 = *(void *)(*(void *)result + 64),
        (int)((unint64_t)(*(void *)(*(void *)result + 72) - v6) >> 3) < a2))
  {
    _ZN23C3DSubdivCPUPrimvarDataIDv3_fE11InterpolateEiPN10OpenSubdiv6v3_1_13Far14PrimvarRefinerEPNS4_15TopologyRefinerE_cold_1();
  }
  uint64_t v7 = *(void *)(v6 + 8 * (a2 - 1));
  uint64_t v8 = *(int **)(v7 + 8);
  if (*(int *)(v7 + 52) >= 1 && *v8 >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(int *)(*(void *)(v7 + 168) + 4 * v9);
      if (v10 != -1)
      {
        uint64_t v11 = *((void *)v8 + 6);
        uint64_t v12 = *(unsigned int *)(*((void *)v8 + 3) + 8 * v9);
        uint64_t v13 = *(int *)(*((void *)v8 + 3) + 8 * v9 + 4);
        *(void *)(*a4 + 8 * v10) = 0;
        if ((int)v12 >= 1)
        {
          int v14 = (int *)(v11 + 4 * v13);
          *(float *)&a6 = 1.0 / (float)(int)v12;
          a6 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&a6, 0));
          do
          {
            uint64_t v15 = *v14++;
            *(float32x2_t *)(*a4 + 8 * v10) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v10), *(float32x2_t *)(*a3 + 8 * v15), *(float32x2_t *)&a6);
            --v12;
          }
          while (v12);
        }
      }
      ++v9;
    }
    while (v9 < *v8);
  }
  int v16 = v8[1];
  if (v16 >= 1)
  {
    uint64_t v17 = 0;
    for (uint64_t i = 0; i < v16; ++i)
    {
      uint64_t v19 = *(int *)(*(void *)(v7 + 216) + 4 * i);
      if (v19 != -1)
      {
        uint64_t v20 = (int *)(*((void *)v8 + 15) + v17);
        *(void *)(*a4 + 8 * v19) = 0;
        *(float32x2_t *)(*a4 + 8 * v19) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v19), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * *v20));
        *(float32x2_t *)(*a4 + 8 * v19) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v19), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v20[1]));
        int v16 = v8[1];
      }
      v17 += 8;
    }
  }
  int v21 = v8[2];
  if (v21 >= 1)
  {
    for (uint64_t j = 0; j < v21; ++j)
    {
      uint64_t v23 = *(int *)(*(void *)(v7 + 240) + 4 * j);
      if (v23 != -1)
      {
        *(void *)(*a4 + 8 * v23) = 0;
        *(float32x2_t *)(*a4 + 8 * v23) = vadd_f32(*(float32x2_t *)(*a3 + 8 * j), *(float32x2_t *)(*a4 + 8 * v23));
        int v21 = v8[2];
      }
    }
  }
  return result;
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  if (a2 < 1 || (int)((*((void *)*a1 + 9) - *((void *)*a1 + 8)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i_cold_1();
  }
  int v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fES7_EEviRKT_RT0_i(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  if (a2 < 1 || (int)((*((void *)*a1 + 9) - *((void *)*a1 + 8)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i_cold_1();
  }
  int v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t a1, int a2, void *a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v4 + 52))
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(int **)(v4 + 8);
    uint64_t v9 = v8[5];
    uint64_t v19 = (float *)&v20;
    std::string __p = 0;
    if (v9 >= 0x11)
    {
      uint64_t v7 = operator new(4 * v9);
      std::string __p = v7;
      uint64_t v19 = (float *)v7;
    }
    if (*v8 >= 1)
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t v11 = *(int *)(*(void *)(v4 + 168) + 4 * v10);
        if (v11 != -1)
        {
          uint64_t v12 = (unsigned int *)(*((void *)v8 + 3) + 8 * v10);
          uint64_t v13 = *v12;
          if ((int)v13 < 1)
          {
            *(void *)(*a4 + 8 * v11) = 0;
          }
          else
          {
            uint64_t v14 = *((void *)v8 + 6) + 4 * (int)v12[1];
            uint64_t v15 = v19;
            uint64_t v16 = v13;
            do
            {
              *v15++ = 1.0 / (float)(int)v13;
              --v16;
            }
            while (v16);
            *(void *)(*a4 + 8 * v11) = 0;
            unint64_t v17 = 0;
            uint64_t v18 = 4 * v13;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v11) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v11), *(float32x2_t *)(*a3 + 8 * *(int *)(v14 + v17)), v19[v17 / 4]);
              v17 += 4;
            }
            while (v18 != v17);
          }
        }
        ++v10;
      }
      while (v10 < *v8);
      uint64_t v7 = __p;
    }
    operator delete(v7);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = 0;
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void *)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v33 = *(void *)(v9 + 16);
  int v37 = *(_DWORD *)(v8 + 4);
  uint64_t v11 = *(unsigned int *)(v10 + 16);
  uint64_t v38 = (float *)&v41;
  int v39 = v11;
  int v40 = 8;
  uint64_t v35 = v10;
  std::string __p = 0;
  if (v11 >= 9)
  {
    uint64_t v7 = operator new(4 * v11);
    std::string __p = v7;
    uint64_t v38 = (float *)v7;
    int v40 = v11;
  }
  int v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (uint64_t i = 0; i < v12; ++i)
    {
      uint64_t v14 = *(int *)(*(void *)(v9 + 216) + 4 * i);
      if (v14 != -1)
      {
        uint64_t v15 = (int *)(*(void *)(v10 + 120) + 8 * i);
        uint64_t v16 = *(void *)(v10 + 168);
        unint64_t v17 = (unsigned int *)(*(void *)(v10 + 144) + 8 * i);
        uint64_t v18 = *v17;
        uint64_t v19 = (int)v17[1];
        v34[0] = v43;
        v34[1] = 0;
        void v34[2] = v38;
        memset(&v34[3], 0, 13);
        int v36 = i;
        if (*(float *)(*(void *)(v10 + 216) + 4 * i) <= 0.0) {
          int v20 = 1;
        }
        else {
          int v20 = 4;
        }
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v37, (OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface *)&v35, (uint64_t)v34, v20, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v14) >> 7) & 0xF);
        *(void *)(*a4 + 8 * v14) = 0;
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * *v15), v43[0]);
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * v15[1]), v43[1]);
        if (SLODWORD(v34[4]) >= 1 && (int)v18 >= 1)
        {
          uint64_t v21 = 0;
          uint64_t v22 = v16 + 4 * v19;
          do
          {
            if (BYTE4(v34[4]))
            {
              if (*(int *)(v9 + 52) <= 0) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
              }
              int v23 = *(_DWORD *)(*(void *)(v9 + 168) + 4 * *(int *)(v22 + 4 * v21));
              if (v23 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              uint64_t v24 = *a4;
              uint64_t v25 = *a4;
            }
            else
            {
              uint64_t v26 = 0;
              uint64_t v27 = *(int *)(v22 + 4 * v21);
              uint64_t v28 = *(void *)(v10 + 24);
              uint64_t v29 = *(int *)(v28 + 8 * v27 + 4);
              int v30 = *(_DWORD *)(v28 + 8 * v27);
              do
                uint64_t v31 = *(unsigned int *)(*(void *)(v10 + 72) + 4 * v29 + 4 * v26++);
              while (i != v31);
              uint64_t v32 = *(void *)(v10 + 48) + 4 * v29;
              if ((int)v26 + 1 < v30) {
                int v30 = 0;
              }
              int v23 = *(_DWORD *)(v32 + 4 * ((int)v26 - v30 + 1));
              uint64_t v25 = *a4;
              uint64_t v24 = *a3;
            }
            *(float32x2_t *)(v25 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(v25 + 8 * v14), *(float32x2_t *)(v24 + 8 * v23), v38[v21++]);
          }
          while (v21 != v18);
        }
        int v12 = *(_DWORD *)(v10 + 4);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, void *a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void **)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v11 = v9[1];
  uint64_t v10 = v9[2];
  int v45 = *(_DWORD *)(v8 + 4);
  unsigned int v12 = 2 * *(_DWORD *)(v11 + 20);
  uint64_t v46 = &v49;
  unsigned int v47 = v12;
  int v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  uint64_t v33 = v10;
  std::string __p = 0;
  if (v12 >= 0x21)
  {
    uint64_t v7 = operator new(4 * v12);
    std::string __p = v7;
    uint64_t v46 = (uint64_t *)v7;
    int v48 = v12;
  }
  int v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (uint64_t i = 0; i < v13; ++i)
    {
      int v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        uint64_t v16 = v15;
        uint64_t v36 = *(void *)(v11 + 360);
        uint64_t v17 = *(void *)(v11 + 336);
        uint64_t v18 = (8 * i) | 4;
        uint64_t v35 = *(int *)(v17 + v18);
        uint64_t v19 = *(int *)(v17 + 8 * i);
        uint64_t v20 = *(void *)(v11 + 264);
        uint64_t v34 = *(int *)(v20 + v18);
        uint64_t v21 = *(unsigned int *)(v20 + 8 * i);
        float v39 = 0.0;
        uint64_t v22 = v46;
        int v23 = (float *)v46 + v19;
        int v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        int v41 = i;
        int v42 = v15;
        int v43 = *(_DWORD *)(*(void *)(v40[0] + 336) + 8 * i);
        int v44 = *(_DWORD *)(*(void *)(v40[0] + 264) + 8 * i);
        uint64_t v24 = *(void *)(v11 + 288);
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(void *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(void *)(*a4 + 8 * v16) = 0;
        if (SLODWORD(v38[4]) >= 1)
        {
          if (!BYTE4(v38[4])) {
            _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
          }
          if ((int)v21 >= 1)
          {
            uint64_t v25 = (int *)(v24 + 4 * v34);
            do
            {
              uint64_t v26 = *v25++;
              uint64_t v27 = *(int *)(v9[21] + 4 * v26);
              if (v27 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              float v28 = *v23++;
              *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a4 + 8 * v27), v28);
              --v21;
            }
            while (v21);
          }
        }
        if (SHIDWORD(v38[3]) >= 1)
        {
          uint64_t v29 = v37;
          if (v37 >= 1)
          {
            int v30 = (int *)(v36 + 4 * v35);
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (_DWORD *)(*(void *)(v11 + 120) + 8 * v31);
              LODWORD(v31) = *(_DWORD *)v22;
              uint64_t v22 = (uint64_t *)((char *)v22 + 4);
              *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * (int)v32[i == *v32]), *(float *)&v31);
              --v29;
            }
            while (v29);
          }
        }
        *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * i), v39);
        int v13 = *(_DWORD *)(v11 + 8);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = 0;
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void *)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v33 = *(void *)(v9 + 16);
  int v37 = *(_DWORD *)(v8 + 4);
  uint64_t v11 = *(unsigned int *)(v10 + 16);
  uint64_t v38 = (float *)&v41;
  int v39 = v11;
  int v40 = 8;
  uint64_t v35 = v10;
  std::string __p = 0;
  if (v11 >= 9)
  {
    uint64_t v7 = operator new(4 * v11);
    std::string __p = v7;
    uint64_t v38 = (float *)v7;
    int v40 = v11;
  }
  int v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (uint64_t i = 0; i < v12; ++i)
    {
      uint64_t v14 = *(int *)(*(void *)(v9 + 216) + 4 * i);
      if (v14 != -1)
      {
        int v15 = (int *)(*(void *)(v10 + 120) + 8 * i);
        uint64_t v16 = *(void *)(v10 + 168);
        uint64_t v17 = (unsigned int *)(*(void *)(v10 + 144) + 8 * i);
        uint64_t v18 = *v17;
        uint64_t v19 = (int)v17[1];
        v34[0] = v43;
        v34[1] = 0;
        void v34[2] = v38;
        memset(&v34[3], 0, 13);
        int v36 = i;
        if (*(float *)(*(void *)(v10 + 216) + 4 * i) <= 0.0) {
          int v20 = 1;
        }
        else {
          int v20 = 4;
        }
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v37, (int *)&v35, (uint64_t)v34, v20, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v14) >> 7) & 0xF);
        *(void *)(*a4 + 8 * v14) = 0;
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * *v15), v43[0]);
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * v15[1]), v43[1]);
        if (SLODWORD(v34[4]) >= 1 && (int)v18 >= 1)
        {
          uint64_t v21 = 0;
          uint64_t v22 = v16 + 4 * v19;
          do
          {
            if (BYTE4(v34[4]))
            {
              if (*(int *)(v9 + 52) <= 0) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
              }
              int v23 = *(_DWORD *)(*(void *)(v9 + 168) + 4 * *(int *)(v22 + 4 * v21));
              if (v23 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              uint64_t v24 = *a4;
              uint64_t v25 = *a4;
            }
            else
            {
              uint64_t v26 = 0;
              uint64_t v27 = *(int *)(v22 + 4 * v21);
              uint64_t v28 = *(void *)(v10 + 24);
              uint64_t v29 = *(int *)(v28 + 8 * v27 + 4);
              int v30 = *(_DWORD *)(v28 + 8 * v27);
              do
                uint64_t v31 = *(unsigned int *)(*(void *)(v10 + 72) + 4 * v29 + 4 * v26++);
              while (i != v31);
              uint64_t v32 = *(void *)(v10 + 48) + 4 * v29;
              if ((int)v26 + 1 < v30) {
                int v30 = 0;
              }
              int v23 = *(_DWORD *)(v32 + 4 * ((int)v26 - v30 + 1));
              uint64_t v25 = *a4;
              uint64_t v24 = *a3;
            }
            *(float32x2_t *)(v25 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(v25 + 8 * v14), *(float32x2_t *)(v24 + 8 * v23), v38[v21++]);
          }
          while (v21 != v18);
        }
        int v12 = *(_DWORD *)(v10 + 4);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, void *a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void **)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v11 = v9[1];
  uint64_t v10 = v9[2];
  int v45 = *(_DWORD *)(v8 + 4);
  unsigned int v12 = 2 * *(_DWORD *)(v11 + 20);
  uint64_t v46 = &v49;
  unsigned int v47 = v12;
  int v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  uint64_t v33 = v10;
  std::string __p = 0;
  if (v12 >= 0x21)
  {
    uint64_t v7 = operator new(4 * v12);
    std::string __p = v7;
    uint64_t v46 = (uint64_t *)v7;
    int v48 = v12;
  }
  int v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (uint64_t i = 0; i < v13; ++i)
    {
      int v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        uint64_t v16 = v15;
        uint64_t v36 = *(void *)(v11 + 360);
        uint64_t v17 = *(void *)(v11 + 336);
        uint64_t v18 = (8 * i) | 4;
        uint64_t v35 = *(int *)(v17 + v18);
        uint64_t v19 = *(int *)(v17 + 8 * i);
        uint64_t v20 = *(void *)(v11 + 264);
        uint64_t v34 = *(int *)(v20 + v18);
        uint64_t v21 = *(unsigned int *)(v20 + 8 * i);
        float v39 = 0.0;
        uint64_t v22 = v46;
        int v23 = (float *)v46 + v19;
        int v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        int v41 = i;
        int v42 = v15;
        int v43 = *(_DWORD *)(*(void *)(v40[0] + 336) + 8 * i);
        int v44 = *(_DWORD *)(*(void *)(v40[0] + 264) + 8 * i);
        uint64_t v24 = *(void *)(v11 + 288);
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(void *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(void *)(*a4 + 8 * v16) = 0;
        if (SLODWORD(v38[4]) >= 1)
        {
          if (!BYTE4(v38[4])) {
            _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
          }
          if ((int)v21 >= 1)
          {
            uint64_t v25 = (int *)(v24 + 4 * v34);
            do
            {
              uint64_t v26 = *v25++;
              uint64_t v27 = *(int *)(v9[21] + 4 * v26);
              if (v27 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              float v28 = *v23++;
              *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a4 + 8 * v27), v28);
              --v21;
            }
            while (v21);
          }
        }
        if (SHIDWORD(v38[3]) >= 1)
        {
          uint64_t v29 = v37;
          if (v37 >= 1)
          {
            int v30 = (int *)(v36 + 4 * v35);
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (_DWORD *)(*(void *)(v11 + 120) + 8 * v31);
              LODWORD(v31) = *(_DWORD *)v22;
              uint64_t v22 = (uint64_t *)((char *)v22 + 4);
              *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * (int)v32[i == *v32]), *(float *)&v31);
              --v29;
            }
            while (v29);
          }
        }
        *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * i), v39);
        int v13 = *(_DWORD *)(v11 + 8);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

int *OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(int *result, OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface *this, uint64_t a3, int a4, int a5)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (!a4)
  {
    uint64_t v7 = *(void *)this;
    uint64_t v8 = *((int *)this + 2);
    if (*(float *)(*(void *)(*(void *)this + 216) + 4 * v8) <= 0.0) {
      goto LABEL_13;
    }
LABEL_5:
    if (a5)
    {
      if (a5 != 4)
      {
        uint64_t v9 = *(void *)this;
        LODWORD(v10) = *((_DWORD *)this + 2);
        goto LABEL_8;
      }
    }
    else if (a4 != 4)
    {
      uint64_t v9 = *(void *)this;
      uint64_t v10 = *((int *)this + 2);
      float v23 = *(float *)(*(void *)(*(void *)this + 216) + 4 * v10);
      if (v23 < 1.0 && ((*result & 0x60) == 0 || (float)(v23 + -1.0) <= 0.0))
      {
LABEL_8:
        uint64_t v11 = *(unsigned int *)(*(void *)(v9 + 144) + 8 * v10);
        *(void *)(a3 + 24) = 2;
        *(_DWORD *)(a3 + 32) = v11;
        *(unsigned char *)(a3 + 36) = 1;
        if ((*(_WORD *)result & 0x180) == 0x80)
        {
          if (v11 == 2)
          {
            uint64_t result = OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface::GetNumVerticesPerFace((int *)this, &v43);
            if (v43 == 3 || v44 == 3)
            {
              float v37 = 0.47;
              if (v44 == 3) {
                float v38 = 0.47;
              }
              else {
                float v38 = 0.25;
              }
              if (v43 != 3) {
                float v37 = 0.25;
              }
              float v29 = (float)(v37 + v38) * 0.5;
              float32_t v39 = (float)((float)(v29 * -2.0) + 1.0) * 0.5;
              unsigned int v12 = *(float32x2_t **)a3;
              v12->f32[0] = v39;
              v12->f32[1] = v39;
              float v28 = *(float **)(a3 + 16);
              *float v28 = v29;
              goto LABEL_50;
            }
            unsigned int v12 = *(float32x2_t **)a3;
            __asm { FMOV            V0.2S, #0.25 }
            **(void **)a3 = _D0;
LABEL_32:
            float v28 = *(float **)(a3 + 16);
            *float v28 = 0.25;
            float v29 = 0.25;
LABEL_50:
            v28[1] = v29;
            uint64_t v9 = *(void *)this;
            LODWORD(v11) = *(_DWORD *)(a3 + 32);
LABEL_51:
            float v40 = *(float *)(*(void *)(v9 + 216) + 4 * *((int *)this + 2));
            float32x2_t *v12 = vmla_n_f32(vmul_n_f32(*v12, 1.0 - v40), (float32x2_t)0x3F0000003F000000, v40);
            if ((int)v11 >= 1)
            {
              int v41 = *(float **)(a3 + 16);
              uint64_t v42 = v11;
              do
              {
                *int v41 = (float)(1.0 - v40) * *v41;
                ++v41;
                --v42;
              }
              while (v42);
            }
            return result;
          }
          unsigned int v12 = *(float32x2_t **)a3;
          __asm { FMOV            V0.2S, #0.25 }
          **(void **)a3 = _D0;
        }
        else
        {
          unsigned int v12 = *(float32x2_t **)a3;
          __asm { FMOV            V0.2S, #0.25 }
          **(void **)a3 = _D0;
          if (v11 == 2) {
            goto LABEL_32;
          }
        }
        if ((int)v11 >= 1)
        {
          uint64_t v35 = *(float **)(a3 + 16);
          uint64_t v36 = v11;
          do
          {
            *v35++ = 0.5 / (float)(int)v11;
            --v36;
          }
          while (v36);
        }
        goto LABEL_51;
      }
    }
    *(_DWORD *)(a3 + 24) = 2;
    *(void *)(a3 + 28) = 0;
    *(unsigned char *)(a3 + 36) = 0;
    uint64_t v21 = *(float **)a3;
    **(_DWORD **)a3 = 1056964608;
    float v22 = 0.5;
    goto LABEL_25;
  }
  if (a4 != 1) {
    goto LABEL_5;
  }
  uint64_t v7 = *(void *)this;
  LODWORD(v8) = *((_DWORD *)this + 2);
LABEL_13:
  uint64_t v18 = *(unsigned int *)(*(void *)(v7 + 144) + 8 * v8);
  *(void *)(a3 + 24) = 2;
  *(_DWORD *)(a3 + 32) = v18;
  *(unsigned char *)(a3 + 36) = 1;
  if ((*(_WORD *)result & 0x180) == 0x80)
  {
    if (v18 == 2)
    {
      uint64_t result = OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface::GetNumVerticesPerFace((int *)this, &v43);
      if (v43 == 3 || v44 == 3)
      {
        float v30 = 0.47;
        if (v44 == 3) {
          float v31 = 0.47;
        }
        else {
          float v31 = 0.25;
        }
        if (v43 != 3) {
          float v30 = 0.25;
        }
        float v22 = (float)(v30 + v31) * 0.5;
        float v32 = (float)((float)(v22 * -2.0) + 1.0) * 0.5;
        uint64_t v33 = *(float **)a3;
        *uint64_t v33 = v32;
        v33[1] = v32;
        uint64_t v21 = *(float **)(a3 + 16);
        float *v21 = v22;
        goto LABEL_25;
      }
      __asm { FMOV            V0.2S, #0.25 }
      **(void **)a3 = _D0;
      goto LABEL_19;
    }
    __asm { FMOV            V0.2S, #0.25 }
    **(void **)a3 = _D0;
  }
  else
  {
    __asm { FMOV            V0.2S, #0.25 }
    **(void **)a3 = _D0;
    if (v18 == 2)
    {
LABEL_19:
      uint64_t v21 = *(float **)(a3 + 16);
      float *v21 = 0.25;
      float v22 = 0.25;
LABEL_25:
      v21[1] = v22;
      return result;
    }
  }
  if ((int)v18 >= 1)
  {
    float v25 = 0.5 / (float)(int)v18;
    uint64_t v26 = *(float **)(a3 + 16);
    do
    {
      *v26++ = v25;
      --v18;
    }
    while (v18);
  }
  return result;
}

int *OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface::GetNumVerticesPerFace(int *this, int *a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = this[2];
  uint64_t v4 = *(void *)(*(void *)this + 144);
  uint64_t v5 = *(unsigned int *)(v4 + 8 * v3);
  if ((int)v5 >= 1)
  {
    uint64_t v6 = (int *)(*(void *)(v2 + 168) + 4 * *(int *)(v4 + 8 * v3 + 4));
    uint64_t v7 = *(void *)(v2 + 24);
    do
    {
      uint64_t v8 = *v6++;
      *a2++ = *(_DWORD *)(v7 + 8 * v8);
      --v5;
    }
    while (v5);
  }
  return this;
}

void OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  unsigned int v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    uint64_t v8 = *(unsigned int *)(a2 + 28);
    if (v8 != *(_DWORD *)(a2 + 24)) {
      OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>();
    }
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a3 + 28) = v8;
    *(_DWORD *)(a3 + 32) = v8;
    *(unsigned char *)(a3 + 36) = 1;
    **(float **)a3 = (float)(v8 - 2) / (float)(int)v8;
    if ((int)v8 >= 1)
    {
      float v9 = 1.0 / (float)(v8 * v8);
      uint64_t v10 = *(float **)(a3 + 8);
      uint64_t v11 = *(float **)(a3 + 16);
      do
      {
        *v10++ = v9;
        *v11++ = v9;
        --v8;
      }
      while (v8);
    }
    return;
  }
  int v12 = a4;
  if (a5) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = a4 == 0;
  }
  if (v14) {
    int v15 = a5;
  }
  else {
    int v15 = a4;
  }
  uint64_t v16 = *(int *)(a2 + 24);
  uint64_t v17 = *(unsigned int *)(a2 + 24);
  uint64_t v18 = 4 * v16;
  MEMORY[0x270FA5388](a1);
  uint64_t v19 = (char *)&v79 - ((4 * v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v19, 4 * v16);
  if ((v12 | 4) != 4 && v15 == v12)
  {
    uint64_t v19 = 0;
    float v23 = 0.0;
LABEL_27:
    if (v12 == 4)
    {
      int v80 = v15;
      uint64_t v81 = v17;
      uint64_t v33 = 0xFFFFFFFF00000000;
      uint64_t v34 = (float *)v19;
      do
      {
        float v35 = *v34++;
        v33 += 0x100000000;
      }
      while (v35 <= 0.0);
      uint64_t v36 = v16 << 32;
      float v37 = (float *)&v19[4 * v16 - 4];
      do
      {
        float v38 = *v37--;
        v36 -= 0x100000000;
      }
      while (v38 <= 0.0);
      uint64_t v39 = *(unsigned int *)(a2 + 24);
      *(_DWORD *)(a3 + 24) = 1;
      *(void *)(a3 + 28) = v39;
      *(unsigned char *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1061158912;
      uint64_t v40 = *(void *)(a3 + 8);
      if ((int)v39 >= 1) {
        bzero(*(void **)(a3 + 8), 4 * v39);
      }
      *(_DWORD *)(v40 + (v33 >> 30)) = 1040187392;
      *(_DWORD *)(v40 + (v36 >> 30)) = 1040187392;
      uint64_t v17 = v81;
      int v15 = v80;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(void *)(a3 + 28) = 0;
      *(unsigned char *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v15 != v12)
    {
      int v82 = *a1;
      MEMORY[0x270FA5388](v20);
      bzero((char *)&v79 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0), 4 * v16);
      ChildSharpnessPerEdge = OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge((OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *)a2, (const OpenSubdiv::v3_1_1::Sdc::Crease *)&v82, (float *)((char *)&v79 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0)));
      uint64_t v42 = ChildSharpnessPerEdge;
      uint64_t v43 = *(int *)(a2 + 20);
      uint64_t v44 = *(void *)(*(void *)(a2 + 8) + 408);
      float v45 = *(float *)(v44 + 4 * v43);
      if (v15
        || (ChildSharpnessPerEdge = (float *)OpenSubdiv::v3_1_1::Sdc::Crease::DetermineVertexVertexRule((OpenSubdiv::v3_1_1::Sdc::Crease *)&v82, *(float *)(v44 + 4 * v43), v16, ChildSharpnessPerEdge), int v15 = (int)ChildSharpnessPerEdge, ChildSharpnessPerEdge != v12))
      {
        MEMORY[0x270FA5388](ChildSharpnessPerEdge);
        unsigned int v47 = (float *)((char *)&v79 - v46);
        bzero((char *)&v79 - v46, v48);
        uint64_t v49 = v47 + 1;
        unsigned int v50 = v15 - 1;
        if ((v15 - 1) > 1)
        {
          if (v15 == 4)
          {
            int v79 = 3;
            uint64_t v81 = v17;
            uint64_t v17 = 0xFFFFFFFF00000000;
            uint64_t v57 = (float *)v42;
            do
            {
              float v58 = *v57++;
              v17 += 0x100000000;
            }
            while (v58 <= 0.0);
            uint64_t v59 = v16 << 32;
            __int16 v60 = (float *)&v42[v16 - 1];
            do
            {
              float v61 = *v60--;
              v59 -= 0x100000000;
            }
            while (v61 <= 0.0);
            uint64_t v56 = *(unsigned int *)(a2 + 24);
            *unsigned int v47 = 0.75;
            if ((int)v56 >= 1)
            {
              bzero(v47 + 1, 4 * v56);
              uint64_t v49 = v47 + 1;
            }
            int v80 = 0;
            LODWORD(v51) = 0;
            *(float *)((char *)v49 + (v17 >> 30)) = 0.125;
            int v55 = v49;
            *(float *)((char *)v49 + (v59 >> 30)) = 0.125;
            LODWORD(v17) = v81;
            unsigned int v50 = v79;
          }
          else
          {
            int v55 = v47 + 1;
            int v80 = 0;
            LODWORD(v51) = 0;
            LODWORD(v56) = 0;
            *unsigned int v47 = 1.0;
          }
        }
        else
        {
          uint64_t v51 = *(unsigned int *)(a2 + 28);
          if (v51 != *(_DWORD *)(a2 + 24)) {
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>();
          }
          *unsigned int v47 = (float)(v51 - 2) / (float)(int)v51;
          if ((int)v51 >= 1)
          {
            float v52 = 1.0 / (float)(v51 * v51);
            uint64_t v53 = v47 + 1;
            uint64_t v54 = v51;
            do
            {
              float *v53 = v52;
              v53[v16] = v52;
              ++v53;
              --v54;
            }
            while (v54);
          }
          int v55 = v47 + 1;
          int v80 = 1;
          LODWORD(v56) = v51;
        }
        double v62 = OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v82, v23, v45, v17, (float *)v19, v42);
        float v63 = 1.0 - *(float *)&v62;
        **(float **)a3 = (float)((float)(1.0 - *(float *)&v62) * *v47) + (float)(*(float *)&v62 * **(float **)a3);
        if (v56)
        {
          if (*(_DWORD *)(a3 + 28))
          {
            if ((int)v56 >= 1)
            {
              unsigned __int8 v64 = *(float **)(a3 + 8);
              uint64_t v65 = v56;
              int32x4_t v66 = v55;
              do
              {
                float v67 = *v66++;
                *unsigned __int8 v64 = (float)(v63 * v67) + (float)(*(float *)&v62 * *v64);
                ++v64;
                --v65;
              }
              while (v65);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 28) = v56;
            if ((int)v56 >= 1)
            {
              unsigned __int16 v68 = *(float **)(a3 + 8);
              uint64_t v69 = v56;
              int8x16_t v70 = v55;
              do
              {
                float v71 = *v70++;
                *v68++ = v63 * v71;
                --v69;
              }
              while (v69);
            }
          }
        }
        if (v51)
        {
          int v72 = &v55[v16];
          if (*(_DWORD *)(a3 + 32))
          {
            if (v50 < 2 != (*(unsigned char *)(a3 + 36) != 0)) {
              OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>();
            }
            if ((int)v51 >= 1)
            {
              uint64_t v73 = *(float **)(a3 + 16);
              uint64_t v74 = v51;
              do
              {
                float v75 = *v72++;
                *uint64_t v73 = (float)(v63 * v75) + (float)(*(float *)&v62 * *v73);
                ++v73;
                --v74;
              }
              while (v74);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 32) = v51;
            *(unsigned char *)(a3 + 36) = v80;
            if ((int)v51 >= 1)
            {
              unint64_t v76 = *(float **)(a3 + 16);
              uint64_t v77 = v51;
              do
              {
                float v78 = *v72++;
                *v76++ = v63 * v78;
                --v77;
              }
              while (v77);
            }
          }
        }
      }
    }
    return;
  }
  uint64_t v21 = *(void **)a2;
  uint64_t v22 = *(int *)(a2 + 16);
  float v23 = *(float *)(*(void *)(*(void *)a2 + 408) + 4 * v22);
  if ((int)v16 >= 1)
  {
    uint64_t v24 = (int *)(v21[45] + 4 * *(int *)(v21[42] + 8 * v22 + 4));
    uint64_t v25 = v21[27];
    uint64_t v26 = (int *)((char *)&v79 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
    uint64_t v27 = v17;
    do
    {
      uint64_t v28 = *v24++;
      *v26++ = *(_DWORD *)(v25 + 4 * v28);
      --v27;
    }
    while (v27);
  }
  if (!v12)
  {
    int v82 = *a1;
    uint64_t v20 = OpenSubdiv::v3_1_1::Sdc::Crease::DetermineVertexVertexRule((OpenSubdiv::v3_1_1::Sdc::Crease *)&v82, v23, v17, (float *)((char *)&v79 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0)));
    int v12 = v20;
    unsigned int v7 = v20 - 1;
  }
  if (v7 > 1) {
    goto LABEL_27;
  }
  uint64_t v29 = *(unsigned int *)(a2 + 28);
  if (v29 != *(_DWORD *)(a2 + 24)) {
    OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>();
  }
  *(_DWORD *)(a3 + 24) = 1;
  *(_DWORD *)(a3 + 28) = v29;
  *(_DWORD *)(a3 + 32) = v29;
  *(unsigned char *)(a3 + 36) = 1;
  **(float **)a3 = (float)(v29 - 2) / (float)(int)v29;
  if ((int)v29 >= 1)
  {
    float v30 = 1.0 / (float)(v29 * v29);
    float v31 = *(float **)(a3 + 8);
    float v32 = *(float **)(a3 + 16);
    do
    {
      *v31++ = v30;
      *v32++ = v30;
      --v29;
    }
    while (v29);
  }
}

float *OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge(OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *this, const OpenSubdiv::v3_1_1::Sdc::Crease *a2, float *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((unsigned int *)this + 6);
  unsigned int v7 = &v14;
  std::string __p = 0;
  if (v6 >= 0x11)
  {
    unsigned int v7 = (uint64_t *)operator new(4 * v6);
    std::string __p = v7;
    LODWORD(v6) = *((_DWORD *)this + 6);
  }
  if ((int)v6 >= 1)
  {
    uint64_t v8 = (int *)(*(void *)(*(void *)this + 360)
               + 4 * *(int *)(*(void *)(*(void *)this + 336) + 8 * *((int *)this + 4) + 4));
    uint64_t v9 = *(void *)(*(void *)this + 216);
    uint64_t v10 = v6;
    uint64_t v11 = v7;
    do
    {
      uint64_t v12 = *v8++;
      *(_DWORD *)uint64_t v11 = *(_DWORD *)(v9 + 4 * v12);
      uint64_t v11 = (uint64_t *)((char *)v11 + 4);
      --v10;
    }
    while (v10);
  }
  OpenSubdiv::v3_1_1::Sdc::Crease::SubdivideEdgeSharpnessesAroundVertex(a2, v6, (float *)v7, a3);
  operator delete(__p);
  return a3;
}

_DWORD *OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(_DWORD *result, int *a2, uint64_t a3, int a4, int a5)
{
  if (!a4)
  {
    uint64_t v5 = *(void *)a2;
    uint64_t v6 = a2[2];
    if (*(float *)(*(void *)(*(void *)a2 + 216) + 4 * v6) <= 0.0) {
      goto LABEL_10;
    }
LABEL_5:
    if (a5)
    {
      if (a5 != 4)
      {
        uint64_t v7 = *(void *)a2;
        LODWORD(v8) = a2[2];
LABEL_8:
        uint64_t v9 = (int)v8;
        uint64_t v10 = *(unsigned int *)(*(void *)(v7 + 144) + 8 * (int)v8);
        *(void *)(a3 + 24) = 2;
        *(_DWORD *)(a3 + 32) = v10;
        *(unsigned char *)(a3 + 36) = 0;
        uint64_t v11 = *(float32x2_t **)a3;
        __asm { FMOV            V0.2S, #0.375 }
        **(void **)a3 = _D0;
        if (v10 == 2)
        {
          **(void **)(a3 + 16) = 0x3E0000003E000000;
        }
        else if ((int)v10 >= 1)
        {
          uint64_t v24 = *(float **)(a3 + 16);
          uint64_t v25 = v10;
          do
          {
            *v24++ = (float)(2.0 / (float)(int)v10) * 0.125;
            --v25;
          }
          while (v25);
        }
        float v26 = *(float *)(*(void *)(v7 + 216) + 4 * v9);
        float32x2_t *v11 = vmla_n_f32(vmul_n_f32(*v11, 1.0 - v26), (float32x2_t)0x3F0000003F000000, v26);
        if ((int)v10 >= 1)
        {
          uint64_t v27 = *(float **)(a3 + 16);
          do
          {
            *uint64_t v27 = (float)(1.0 - v26) * *v27;
            ++v27;
            --v10;
          }
          while (v10);
        }
        return result;
      }
    }
    else if (a4 != 4)
    {
      uint64_t v7 = *(void *)a2;
      uint64_t v8 = a2[2];
      float v23 = *(float *)(*(void *)(*(void *)a2 + 216) + 4 * v8);
      if (v23 < 1.0 && ((*result & 0x60) == 0 || (float)(v23 + -1.0) <= 0.0)) {
        goto LABEL_8;
      }
    }
    *(_DWORD *)(a3 + 24) = 2;
    *(void *)(a3 + 28) = 0;
    *(unsigned char *)(a3 + 36) = 0;
    uint64_t v19 = *(float32x2_t **)a3;
    **(_DWORD **)a3 = 1056964608;
    float v20 = 0.5;
    goto LABEL_21;
  }
  if (a4 != 1) {
    goto LABEL_5;
  }
  uint64_t v5 = *(void *)a2;
  LODWORD(v6) = a2[2];
LABEL_10:
  uint64_t v17 = *(unsigned int *)(*(void *)(v5 + 144) + 8 * v6);
  *(void *)(a3 + 24) = 2;
  *(_DWORD *)(a3 + 32) = v17;
  *(unsigned char *)(a3 + 36) = 0;
  __asm { FMOV            V0.2S, #0.375 }
  **(void **)a3 = _D0;
  if (v17 == 2)
  {
    uint64_t v19 = *(float32x2_t **)(a3 + 16);
    v19->i32[0] = 1040187392;
    float v20 = 0.125;
LABEL_21:
    v19->f32[1] = v20;
    return result;
  }
  if ((int)v17 >= 1)
  {
    float v21 = (float)(2.0 / (float)(int)v17) * 0.125;
    uint64_t v22 = *(float **)(a3 + 16);
    do
    {
      *v22++ = v21;
      --v17;
    }
    while (v17);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  unsigned int v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    uint64_t v8 = *(unsigned int *)(a2 + 28);
    *(_DWORD *)(a3 + 24) = 1;
    *(void *)(a3 + 28) = v8;
    *(unsigned char *)(a3 + 36) = 0;
    if (v8 == 6)
    {
      **(_DWORD **)a3 = 1059061760;
      float v9 = 0.0625;
    }
    else
    {
      float v29 = 1.0 / (float)(int)v8;
      float v30 = cosf(v29 * 6.2832);
      float v9 = v29 * (float)(0.625 - (float)((float)((float)(v30 * 0.25) + 0.375) * (float)((float)(v30 * 0.25) + 0.375)));
      **(float **)a3 = 1.0 - (float)(v9 * (float)(int)v8);
      if ((int)v8 < 1) {
        return;
      }
    }
    float v31 = *(float **)(a3 + 8);
    do
    {
      *v31++ = v9;
      --v8;
    }
    while (v8);
    return;
  }
  int v10 = a4;
  if (a5) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = a4 == 0;
  }
  if (v12) {
    int v13 = a5;
  }
  else {
    int v13 = a4;
  }
  uint64_t v14 = *(int *)(a2 + 24);
  uint64_t v15 = *(unsigned int *)(a2 + 24);
  uint64_t v16 = 4 * v14;
  MEMORY[0x270FA5388](a1);
  uint64_t v17 = &v71[-((4 * v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v17, 4 * v14);
  if ((v10 | 4) != 4 && v13 == v10)
  {
    uint64_t v17 = 0;
    float v21 = 0.0;
    goto LABEL_25;
  }
  uint64_t v19 = *(void **)a2;
  uint64_t v20 = *(int *)(a2 + 16);
  float v21 = *(float *)(*(void *)(*(void *)a2 + 408) + 4 * v20);
  if ((int)v14 >= 1)
  {
    uint64_t v22 = (int *)(v19[45] + 4 * *(int *)(v19[42] + 8 * v20 + 4));
    uint64_t v23 = v19[27];
    uint64_t v24 = &v71[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)];
    uint64_t v25 = v15;
    do
    {
      uint64_t v26 = *v22++;
      *v24++ = *(_DWORD *)(v23 + 4 * v26);
      --v25;
    }
    while (v25);
  }
  if (!v10)
  {
    int v74 = *a1;
    uint64_t v18 = OpenSubdiv::v3_1_1::Sdc::Crease::DetermineVertexVertexRule((OpenSubdiv::v3_1_1::Sdc::Crease *)&v74, v21, v15, (float *)&v71[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)]);
    int v10 = v18;
    unsigned int v7 = v18 - 1;
  }
  if (v7 > 1)
  {
LABEL_25:
    if (v10 == 4)
    {
      int v72 = v13;
      uint64_t v73 = v15;
      uint64_t v15 = 0xFFFFFFFF00000000;
      float v32 = (float *)v17;
      do
      {
        float v33 = *v32++;
        v15 += 0x100000000;
      }
      while (v33 <= 0.0);
      uint64_t v34 = v14 << 32;
      float v35 = (float *)&v17[4 * v14 - 4];
      do
      {
        float v36 = *v35--;
        v34 -= 0x100000000;
      }
      while (v36 <= 0.0);
      uint64_t v37 = *(unsigned int *)(a2 + 24);
      *(_DWORD *)(a3 + 24) = 1;
      *(void *)(a3 + 28) = v37;
      *(unsigned char *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1061158912;
      uint64_t v38 = *(void *)(a3 + 8);
      if ((int)v37 >= 1) {
        bzero(*(void **)(a3 + 8), 4 * v37);
      }
      *(_DWORD *)(v38 + (v15 >> 30)) = 1040187392;
      *(_DWORD *)(v38 + (v34 >> 30)) = 1040187392;
      LODWORD(v15) = v73;
      int v13 = v72;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(void *)(a3 + 28) = 0;
      *(unsigned char *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v13 == v10) {
      return;
    }
    int v74 = *a1;
    MEMORY[0x270FA5388](v18);
    bzero(&v71[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)], 4 * v14);
    ChildSharpnessPerEdge = OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge((OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *)a2, (const OpenSubdiv::v3_1_1::Sdc::Crease *)&v74, (float *)&v71[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)]);
    uint64_t v40 = ChildSharpnessPerEdge;
    uint64_t v41 = *(int *)(a2 + 20);
    uint64_t v42 = *(void *)(*(void *)(a2 + 8) + 408);
    float v43 = *(float *)(v42 + 4 * v41);
    if (!v13)
    {
      ChildSharpnessPerEdge = (float *)OpenSubdiv::v3_1_1::Sdc::Crease::DetermineVertexVertexRule((OpenSubdiv::v3_1_1::Sdc::Crease *)&v74, *(float *)(v42 + 4 * v41), v14, ChildSharpnessPerEdge);
      int v13 = (int)ChildSharpnessPerEdge;
      if (ChildSharpnessPerEdge == v10) {
        return;
      }
    }
    MEMORY[0x270FA5388](ChildSharpnessPerEdge);
    float v45 = (float *)&v71[-v44];
    bzero(&v71[-v44], v46);
    unsigned int v47 = v45 + 1;
    if ((v13 - 1) > 1)
    {
      if (v13 == 4)
      {
        int v53 = v15;
        uint64_t v15 = 0xFFFFFFFF00000000;
        uint64_t v54 = (float *)v40;
        do
        {
          float v55 = *v54++;
          v15 += 0x100000000;
        }
        while (v55 <= 0.0);
        uint64_t v56 = v14 << 32;
        uint64_t v57 = (float *)&v40[v14 - 1];
        do
        {
          float v58 = *v57--;
          v56 -= 0x100000000;
        }
        while (v58 <= 0.0);
        uint64_t v48 = *(unsigned int *)(a2 + 24);
        *float v45 = 0.75;
        if ((int)v48 >= 1) {
          bzero(v45 + 1, 4 * v48);
        }
        *(float *)((char *)v47 + (v15 >> 30)) = 0.125;
        *(float *)((char *)v47 + (v56 >> 30)) = 0.125;
        LODWORD(v15) = v53;
      }
      else
      {
        LODWORD(v48) = 0;
        *float v45 = 1.0;
      }
      goto LABEL_57;
    }
    uint64_t v48 = *(unsigned int *)(a2 + 28);
    if (v48 == 6)
    {
      *float v45 = 0.625;
      float v49 = 0.0625;
    }
    else
    {
      float v59 = 1.0 / (float)(int)v48;
      float v60 = cosf(v59 * 6.2832);
      float v49 = v59 * (float)(0.625 - (float)((float)((float)(v60 * 0.25) + 0.375) * (float)((float)(v60 * 0.25) + 0.375)));
      *float v45 = 1.0 - (float)(v49 * (float)(int)v48);
      if ((int)v48 < 1) {
        goto LABEL_57;
      }
    }
    float v61 = v45 + 1;
    uint64_t v62 = v48;
    do
    {
      *v61++ = v49;
      --v62;
    }
    while (v62);
LABEL_57:
    double v63 = OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v74, v21, v43, v15, (float *)v17, v40);
    float v64 = 1.0 - *(float *)&v63;
    **(float **)a3 = (float)((float)(1.0 - *(float *)&v63) * *v45) + (float)(*(float *)&v63 * **(float **)a3);
    if (v48)
    {
      if (*(_DWORD *)(a3 + 28))
      {
        if ((int)v48 >= 1)
        {
          uint64_t v65 = *(float **)(a3 + 8);
          uint64_t v66 = v48;
          do
          {
            float v67 = *v47++;
            *uint64_t v65 = (float)(v64 * v67) + (float)(*(float *)&v63 * *v65);
            ++v65;
            --v66;
          }
          while (v66);
        }
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v48;
        if ((int)v48 >= 1)
        {
          unsigned __int16 v68 = *(float **)(a3 + 8);
          uint64_t v69 = v48;
          do
          {
            float v70 = *v47++;
            *v68++ = v64 * v70;
            --v69;
          }
          while (v69);
        }
      }
    }
    return;
  }
  uint64_t v27 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(void *)(a3 + 28) = v27;
  *(unsigned char *)(a3 + 36) = 0;
  if (v27 == 6)
  {
    **(_DWORD **)a3 = 1059061760;
    float v28 = 0.0625;
  }
  else
  {
    float v50 = 1.0 / (float)(int)v27;
    float v51 = cosf(v50 * 6.2832);
    float v28 = v50 * (float)(0.625 - (float)((float)((float)(v51 * 0.25) + 0.375) * (float)((float)(v51 * 0.25) + 0.375)));
    **(float **)a3 = 1.0 - (float)(v28 * (float)(int)v27);
    if ((int)v27 < 1) {
      return;
    }
  }
  float v52 = *(float **)(a3 + 8);
  do
  {
    *v52++ = v28;
    --v27;
  }
  while (v27);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v5 + 52))
  {
    uint64_t v8 = 0;
    float v9 = *(int **)(v5 + 8);
    int v10 = *(void **)(*((void *)v9 + 57) + 8 * a5);
    uint64_t v11 = *(void *)(*(void *)(*(void *)(v5 + 16) + 456) + 8 * a5);
    uint64_t v12 = v9[5];
    uint64_t v23 = (float *)&v24;
    std::string __p = 0;
    if (v12 >= 0x11)
    {
      uint64_t v8 = operator new(4 * v12);
      std::string __p = v8;
      uint64_t v23 = (float *)v8;
    }
    if (*v9 >= 1)
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(int *)(*(void *)(v5 + 168) + 4 * v13);
        if (v14 != -1)
        {
          uint64_t v15 = *(int *)(*(void *)(v11 + 96) + 4 * v14);
          uint64_t v16 = (unsigned int *)(*(void *)(*v10 + 24) + 8 * v13);
          uint64_t v17 = *v16;
          if ((int)v17 < 1)
          {
            *(void *)(*a4 + 8 * v15) = 0;
          }
          else
          {
            uint64_t v18 = v10[3] + 4 * (int)v16[1];
            uint64_t v19 = v23;
            uint64_t v20 = v17;
            do
            {
              *v19++ = 1.0 / (float)(int)v17;
              --v20;
            }
            while (v20);
            *(void *)(*a4 + 8 * v15) = 0;
            unint64_t v21 = 0;
            uint64_t v22 = 4 * v17;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v15) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v15), *(float32x2_t *)(*a3 + 8 * *(int *)(v18 + v21)), v23[v21 / 4]);
              v21 += 4;
            }
            while (v22 != v21);
          }
        }
        ++v13;
      }
      while (v13 < *v9);
      uint64_t v8 = __p;
    }
    operator delete(v8);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  v56[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v48 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v9 = v8[1];
  uint64_t v10 = *(void *)(v8[60] + 8 * a5);
  uint64_t v11 = *(void *)(*(void *)(v9 + 456) + 8 * a5);
  uint64_t v41 = v8[2];
  uint64_t v12 = *(void **)(*(void *)(v41 + 456) + 8 * a5);
  uint64_t v44 = v9;
  uint64_t v13 = *(unsigned int *)(v9 + 16);
  uint64_t v14 = v54;
  float v51 = v54;
  int v52 = v13;
  int v53 = 8;
  std::string __p = 0;
  if (v13 < 9)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = operator new(4 * v13);
    std::string __p = v15;
    float v51 = v15;
    int v53 = v13;
    uint64_t v14 = v15;
  }
  v47[0] = v56;
  v47[1] = 0;
  v47[2] = v14;
  memset(&v47[3], 0, 13);
  if (*(unsigned char *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v47[3]) = 2;
    LODWORD(v47[4]) = 0;
    v56[0] = 0x3F0000003F000000;
    char v42 = 1;
  }
  else
  {
    char v42 = 0;
  }
  uint64_t v45 = v44;
  if (*(int *)(v44 + 4) >= 1)
  {
    uint64_t v16 = 0;
    float v43 = v8;
    do
    {
      uint64_t v17 = *(int *)(v8[27] + 4 * v16);
      if (v17 != -1)
      {
        uint64_t v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if (*(unsigned char *)(v12[21] + *v18))
        {
          uint64_t v36 = v12[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v17);
          if (*(_WORD *)(v36 + 2 * v17))
          {
            uint64_t v38 = 0;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*(void *)(v10 + 40)
                                        + 2 * (v38 + *(int *)(*(void *)(*(void *)(v10 + 32) + 96) + 4 * v17)));
              if (v38 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, v39, &v49);
              uint64_t v40 = v18[v38];
              *(void *)(*a4 + 8 * v40) = 0;
              *(float32x2_t *)(*a4 + 8 * v40) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v40), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v49));
              *(float32x2_t *)(*a4 + 8 * v40) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v40), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v50));
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          if ((v42 & 1) == 0)
          {
            int v46 = v16;
            if (*(float *)(*(void *)(v44 + 216) + 4 * v16) <= 0.0) {
              int v19 = 1;
            }
            else {
              int v19 = 4;
            }
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v48, (OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface *)&v45, (uint64_t)v47, v19, (*(unsigned __int16 *)(*(void *)(v41 + 432) + 2 * v17) >> 7) & 0xF);
          }
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, 0, &v49);
          uint64_t v20 = *v18;
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v49), *(float *)v56);
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v50), *((float *)v56 + 1));
          if (SLODWORD(v47[4]) >= 1)
          {
            unint64_t v21 = (unsigned int *)(*(void *)(v44 + 144) + 8 * v16);
            uint64_t v22 = *v21;
            if ((int)v22 >= 1)
            {
              uint64_t v23 = 0;
              uint64_t v24 = *(void *)(v44 + 168) + 4 * (int)v21[1];
              do
              {
                uint64_t v25 = *(int *)(v24 + 4 * v23);
                if (BYTE4(v47[4]))
                {
                  uint64_t v26 = *(int *)(v43[21] + 4 * v25);
                  if (v26 == -1) {
                    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
                  }
                  uint64_t v27 = (int *)(v12[12] + 4 * v26);
                  uint64_t v28 = *a4;
                  uint64_t v29 = *a4;
                }
                else
                {
                  uint64_t v30 = 0;
                  uint64_t v31 = (2 * (int)v25) | 1;
                  uint64_t v32 = *(void *)(v44 + 24);
                  uint64_t v33 = *(void *)(v44 + 72) + 4 * *(int *)(v32 + 4 * v31);
                  int v34 = *(_DWORD *)(v32 + 8 * v25);
                  do
                    uint64_t v35 = *(unsigned int *)(v33 + 4 * v30++);
                  while (v16 != v35);
                  if ((int)v30 + 1 < v34) {
                    int v34 = 0;
                  }
                  uint64_t v27 = (int *)(*(void *)(v11 + 24)
                              + 4 * *(int *)(*(void *)(*(void *)v11 + 24) + 4 * v31)
                              + 4 * ((int)v30 - v34 + 1));
                  uint64_t v29 = *a4;
                  uint64_t v28 = *a3;
                }
                *(float32x2_t *)(v29 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(v29 + 8 * v20), *(float32x2_t *)(v28 + 8 * *v27), *(float *)&v51[4 * v23++]);
              }
              while (v23 != v22);
            }
          }
        }
      }
      ++v16;
      uint64_t v8 = v43;
    }
    while (v16 < *(int *)(v44 + 4));
    uint64_t v15 = __p;
  }
  operator delete(v15);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v53 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v65 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v56 = v53[1];
  uint64_t v48 = v53[2];
  uint64_t v57 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v56 + 456) + 8 * a5);
  if (*((unsigned char *)v57 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v52 = v7;
  float v55 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v53[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v48 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v56 + 20);
  uint64_t v75 = &v78;
  int v76 = 2 * v9;
  int v77 = 32;
  int v79 = 0;
  if (2 * v9 >= 0x21)
  {
    int v79 = (uint64_t *)operator new(8 * v9);
    uint64_t v75 = v79;
    int v77 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v56 + 20);
  }
  uint64_t v10 = 0;
  float v70 = (int *)&v73;
  unsigned int v71 = v9;
  int v72 = 16;
  int v74 = 0;
  if (v9 >= 0x11)
  {
    uint64_t v10 = (int *)operator new(4 * v9);
    int v74 = v10;
    float v70 = v10;
    int v72 = v9;
  }
  v60[0] = v56;
  v60[1] = v48;
  if (*(int *)(v56 + 8) >= 1)
  {
    float v51 = v8;
    uint64_t v11 = 0;
    uint64_t v13 = v53;
    uint64_t v12 = a3;
    BOOL v14 = v52;
    uint64_t v15 = v55;
    do
    {
      int v58 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v58 != -1)
      {
        uint64_t v16 = *(int *)(*((void *)v57 + 12) + 4 * v11);
        uint64_t v17 = (int *)(*((void *)v57 + 18) + 4 * v16);
        uint64_t v18 = *(int *)(v51[12] + 4 * v58);
        int v19 = (int *)(v51[18] + 4 * v18);
        uint64_t v20 = *v19;
        uint64_t v21 = v51[21];
        if ((*(unsigned char *)(v21 + v20) & 1) == 0 && v14)
        {
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if (*(unsigned char *)(v21 + v20))
        {
          uint64_t v35 = v51[9];
          uint64_t v36 = *(unsigned __int16 *)(v35 + 2 * v58);
          if (*(_WORD *)(v35 + 2 * v58))
          {
            uint64_t v37 = 0;
            uint64_t v38 = v21 + v18;
            uint64_t v49 = v38;
            uint64_t v50 = *((void *)v57 + 21) + v16;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*((void *)v15 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v15 + 4) + 96) + 4 * v58)
                                         + (unsigned __int16)v37));
              if (v37 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v40 = v17[v39];
              uint64_t v41 = v19[v37];
              *(void *)(*a4 + 8 * v41) = 0;
              if (!v14 && (*(unsigned char *)(v38 + v37) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v57, v11, v39, v66);
                if ((*(unsigned char *)(v50 + v39) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v50 + v39) & 0x20) != 0)
                  {
                    unsigned int v45 = v39 == 0;
                    int v44 = v11;
                  }
                  else
                  {
                    int v44 = v11;
                    unsigned int v45 = v39;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v55, v44, v45, v58);
                  float v47 = 1.0 - FractionalWeight;
                  float v43 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v42 = v47 * 0.125;
                }
                else
                {
                  float v42 = 0.125;
                  float v43 = 0.75;
                }
                uint64_t v13 = v53;
                uint64_t v12 = a3;
                BOOL v14 = v52;
                uint64_t v15 = v55;
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[0]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[1]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v40), v43);
                uint64_t v38 = v49;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v41) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v40), *(float32x2_t *)(*a4 + 8 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          uint64_t v23 = *(int *)(*(void *)(v56 + 336) + 8 * v11);
          float v59 = 0.0;
          uint64_t v24 = v75;
          uint64_t v25 = (float *)v75 + v23;
          *(void *)uint64_t v66 = &v59;
          float v67 = v75;
          unsigned __int16 v68 = v25;
          memset(v69, 0, 13);
          int v61 = v11;
          int v62 = v58;
          int v63 = *(_DWORD *)(*(void *)(v60[0] + 336) + 8 * v11);
          int v64 = *(_DWORD *)(*(void *)(v60[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v65, (uint64_t)v60, (uint64_t)v66, (*(unsigned __int16 *)(*(void *)(v56 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v48 + 432) + 2 * v58) >> 7) & 0xF);
          uint64_t v13 = v53;
          uint64_t v12 = a3;
          uint64_t v26 = *v17;
          uint64_t v27 = *v19;
          *(void *)(*a4 + 8 * v27) = 0;
          if (v69[2] >= 1)
          {
            if (!LOBYTE(v69[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v28 = *(void *)(v56 + 264);
            uint64_t v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              uint64_t v30 = (int *)(*(void *)(v56 + 288) + 4 * *(int *)(v28 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v31 = *v30++;
                uint64_t v32 = *(int *)(v53[21] + 4 * v31);
                if (v32 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v33 = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * *(int *)(v51[12] + 4 * v32)), v33);
                --v29;
              }
              while (v29);
            }
          }
          if (v69[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v57, v11, v70);
            uint64_t v13 = v53;
            uint64_t v12 = a3;
            if ((int)v23 >= 1)
            {
              uint64_t v34 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * v70[v34]), *(float *)((char *)v24 + v34 * 4));
                ++v34;
              }
              while (v23 != v34);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v59);
          BOOL v14 = v52;
          uint64_t v15 = v55;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v56 + 8));
    uint64_t v10 = v74;
  }
  operator delete(v10);
  operator delete(v79);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  v56[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v48 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v9 = v8[1];
  uint64_t v10 = *(void *)(v8[60] + 8 * a5);
  uint64_t v11 = *(void *)(*(void *)(v9 + 456) + 8 * a5);
  uint64_t v41 = v8[2];
  uint64_t v12 = *(void **)(*(void *)(v41 + 456) + 8 * a5);
  uint64_t v44 = v9;
  uint64_t v13 = *(unsigned int *)(v9 + 16);
  BOOL v14 = v54;
  float v51 = v54;
  int v52 = v13;
  int v53 = 8;
  std::string __p = 0;
  if (v13 < 9)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = operator new(4 * v13);
    std::string __p = v15;
    float v51 = v15;
    int v53 = v13;
    BOOL v14 = v15;
  }
  v47[0] = v56;
  v47[1] = 0;
  v47[2] = v14;
  memset(&v47[3], 0, 13);
  if (*(unsigned char *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v47[3]) = 2;
    LODWORD(v47[4]) = 0;
    v56[0] = 0x3F0000003F000000;
    char v42 = 1;
  }
  else
  {
    char v42 = 0;
  }
  uint64_t v45 = v44;
  if (*(int *)(v44 + 4) >= 1)
  {
    uint64_t v16 = 0;
    float v43 = v8;
    do
    {
      uint64_t v17 = *(int *)(v8[27] + 4 * v16);
      if (v17 != -1)
      {
        uint64_t v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if (*(unsigned char *)(v12[21] + *v18))
        {
          uint64_t v36 = v12[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v17);
          if (*(_WORD *)(v36 + 2 * v17))
          {
            uint64_t v38 = 0;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*(void *)(v10 + 40)
                                        + 2 * (v38 + *(int *)(*(void *)(*(void *)(v10 + 32) + 96) + 4 * v17)));
              if (v38 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, v39, &v49);
              uint64_t v40 = v18[v38];
              *(void *)(*a4 + 8 * v40) = 0;
              *(float32x2_t *)(*a4 + 8 * v40) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v40), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v49));
              *(float32x2_t *)(*a4 + 8 * v40) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v40), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v50));
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          if ((v42 & 1) == 0)
          {
            int v46 = v16;
            if (*(float *)(*(void *)(v44 + 216) + 4 * v16) <= 0.0) {
              int v19 = 1;
            }
            else {
              int v19 = 4;
            }
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v48, (int *)&v45, (uint64_t)v47, v19, (*(unsigned __int16 *)(*(void *)(v41 + 432) + 2 * v17) >> 7) & 0xF);
          }
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, 0, &v49);
          uint64_t v20 = *v18;
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v49), *(float *)v56);
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v50), *((float *)v56 + 1));
          if (SLODWORD(v47[4]) >= 1)
          {
            uint64_t v21 = (unsigned int *)(*(void *)(v44 + 144) + 8 * v16);
            uint64_t v22 = *v21;
            if ((int)v22 >= 1)
            {
              uint64_t v23 = 0;
              uint64_t v24 = *(void *)(v44 + 168) + 4 * (int)v21[1];
              do
              {
                uint64_t v25 = *(int *)(v24 + 4 * v23);
                if (BYTE4(v47[4]))
                {
                  uint64_t v26 = *(int *)(v43[21] + 4 * v25);
                  if (v26 == -1) {
                    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
                  }
                  uint64_t v27 = (int *)(v12[12] + 4 * v26);
                  uint64_t v28 = *a4;
                  uint64_t v29 = *a4;
                }
                else
                {
                  uint64_t v30 = 0;
                  uint64_t v31 = (2 * (int)v25) | 1;
                  uint64_t v32 = *(void *)(v44 + 24);
                  uint64_t v33 = *(void *)(v44 + 72) + 4 * *(int *)(v32 + 4 * v31);
                  int v34 = *(_DWORD *)(v32 + 8 * v25);
                  do
                    uint64_t v35 = *(unsigned int *)(v33 + 4 * v30++);
                  while (v16 != v35);
                  if ((int)v30 + 1 < v34) {
                    int v34 = 0;
                  }
                  uint64_t v27 = (int *)(*(void *)(v11 + 24)
                              + 4 * *(int *)(*(void *)(*(void *)v11 + 24) + 4 * v31)
                              + 4 * ((int)v30 - v34 + 1));
                  uint64_t v29 = *a4;
                  uint64_t v28 = *a3;
                }
                *(float32x2_t *)(v29 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(v29 + 8 * v20), *(float32x2_t *)(v28 + 8 * *v27), *(float *)&v51[4 * v23++]);
              }
              while (v23 != v22);
            }
          }
        }
      }
      ++v16;
      uint64_t v8 = v43;
    }
    while (v16 < *(int *)(v44 + 4));
    uint64_t v15 = __p;
  }
  operator delete(v15);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v53 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v65 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v56 = v53[1];
  uint64_t v48 = v53[2];
  uint64_t v57 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v56 + 456) + 8 * a5);
  if (*((unsigned char *)v57 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v52 = v7;
  float v55 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v53[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v48 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v56 + 20);
  uint64_t v75 = &v78;
  int v76 = 2 * v9;
  int v77 = 32;
  int v79 = 0;
  if (2 * v9 >= 0x21)
  {
    int v79 = (uint64_t *)operator new(8 * v9);
    uint64_t v75 = v79;
    int v77 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v56 + 20);
  }
  uint64_t v10 = 0;
  float v70 = (int *)&v73;
  unsigned int v71 = v9;
  int v72 = 16;
  int v74 = 0;
  if (v9 >= 0x11)
  {
    uint64_t v10 = (int *)operator new(4 * v9);
    int v74 = v10;
    float v70 = v10;
    int v72 = v9;
  }
  v60[0] = v56;
  v60[1] = v48;
  if (*(int *)(v56 + 8) >= 1)
  {
    float v51 = v8;
    uint64_t v11 = 0;
    uint64_t v13 = v53;
    uint64_t v12 = a3;
    BOOL v14 = v52;
    uint64_t v15 = v55;
    do
    {
      int v58 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v58 != -1)
      {
        uint64_t v16 = *(int *)(*((void *)v57 + 12) + 4 * v11);
        uint64_t v17 = (int *)(*((void *)v57 + 18) + 4 * v16);
        uint64_t v18 = *(int *)(v51[12] + 4 * v58);
        int v19 = (int *)(v51[18] + 4 * v18);
        uint64_t v20 = *v19;
        uint64_t v21 = v51[21];
        if ((*(unsigned char *)(v21 + v20) & 1) == 0 && v14)
        {
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if (*(unsigned char *)(v21 + v20))
        {
          uint64_t v35 = v51[9];
          uint64_t v36 = *(unsigned __int16 *)(v35 + 2 * v58);
          if (*(_WORD *)(v35 + 2 * v58))
          {
            uint64_t v37 = 0;
            uint64_t v38 = v21 + v18;
            uint64_t v49 = v38;
            uint64_t v50 = *((void *)v57 + 21) + v16;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*((void *)v15 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v15 + 4) + 96) + 4 * v58)
                                         + (unsigned __int16)v37));
              if (v37 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v40 = v17[v39];
              uint64_t v41 = v19[v37];
              *(void *)(*a4 + 8 * v41) = 0;
              if (!v14 && (*(unsigned char *)(v38 + v37) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v57, v11, v39, v66);
                if ((*(unsigned char *)(v50 + v39) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v50 + v39) & 0x20) != 0)
                  {
                    unsigned int v45 = v39 == 0;
                    int v44 = v11;
                  }
                  else
                  {
                    int v44 = v11;
                    unsigned int v45 = v39;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v55, v44, v45, v58);
                  float v47 = 1.0 - FractionalWeight;
                  float v43 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v42 = v47 * 0.125;
                }
                else
                {
                  float v42 = 0.125;
                  float v43 = 0.75;
                }
                uint64_t v13 = v53;
                uint64_t v12 = a3;
                BOOL v14 = v52;
                uint64_t v15 = v55;
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[0]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[1]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v40), v43);
                uint64_t v38 = v49;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v41) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v40), *(float32x2_t *)(*a4 + 8 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          uint64_t v23 = *(int *)(*(void *)(v56 + 336) + 8 * v11);
          float v59 = 0.0;
          uint64_t v24 = v75;
          uint64_t v25 = (float *)v75 + v23;
          *(void *)uint64_t v66 = &v59;
          float v67 = v75;
          unsigned __int16 v68 = v25;
          memset(v69, 0, 13);
          int v61 = v11;
          int v62 = v58;
          int v63 = *(_DWORD *)(*(void *)(v60[0] + 336) + 8 * v11);
          int v64 = *(_DWORD *)(*(void *)(v60[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v65, (uint64_t)v60, (uint64_t)v66, (*(unsigned __int16 *)(*(void *)(v56 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v48 + 432) + 2 * v58) >> 7) & 0xF);
          uint64_t v13 = v53;
          uint64_t v12 = a3;
          uint64_t v26 = *v17;
          uint64_t v27 = *v19;
          *(void *)(*a4 + 8 * v27) = 0;
          if (v69[2] >= 1)
          {
            if (!LOBYTE(v69[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v28 = *(void *)(v56 + 264);
            uint64_t v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              uint64_t v30 = (int *)(*(void *)(v56 + 288) + 4 * *(int *)(v28 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v31 = *v30++;
                uint64_t v32 = *(int *)(v53[21] + 4 * v31);
                if (v32 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v33 = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * *(int *)(v51[12] + 4 * v32)), v33);
                --v29;
              }
              while (v29);
            }
          }
          if (v69[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v57, v11, v70);
            uint64_t v13 = v53;
            uint64_t v12 = a3;
            if ((int)v23 >= 1)
            {
              uint64_t v34 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * v70[v34]), *(float *)((char *)v24 + v34 * 4));
                ++v34;
              }
              while (v23 != v34);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v59);
          BOOL v14 = v52;
          uint64_t v15 = v55;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v56 + 8));
    uint64_t v10 = v74;
  }
  operator delete(v10);
  operator delete(v79);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v8 = 0;
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v22 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v23 = v22[1];
  uint64_t v9 = *(void *)(v22[60] + 8 * a5);
  uint64_t v10 = *(void **)(*(void *)(v23 + 456) + 8 * a5);
  uint64_t v11 = *(void **)(*(void *)(v22[2] + 456) + 8 * a5);
  uint64_t v12 = *(unsigned int *)(v23 + 16);
  uint64_t v26 = &v29;
  int v27 = v12;
  int v28 = 8;
  std::string __p = 0;
  if (v12 >= 9)
  {
    uint64_t v8 = operator new(4 * v12);
    std::string __p = v8;
    uint64_t v26 = (uint64_t *)v8;
    int v28 = v12;
  }
  if (*(int *)(v23 + 4) >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(int *)(v22[27] + 4 * v13);
      if (v14 != -1)
      {
        uint64_t v15 = (int *)(v11[18] + 4 * *(int *)(v11[12] + 4 * v14));
        if (*(unsigned char *)(v11[21] + *v15))
        {
          uint64_t v17 = v11[9];
          uint64_t v18 = *(unsigned __int16 *)(v17 + 2 * v14);
          if (*(_WORD *)(v17 + 2 * v14))
          {
            uint64_t v19 = 0;
            do
            {
              uint64_t v20 = *(unsigned __int16 *)(*(void *)(v9 + 40)
                                        + 2 * (v19 + *(int *)(*(void *)(*(void *)(v9 + 32) + 96) + 4 * v14)));
              if (v19 != v20) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v10, v13, v20, &v24);
              uint64_t v21 = v15[v19];
              *(void *)(*a4 + 8 * v21) = 0;
              *(float32x2_t *)(*a4 + 8 * v21) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v21), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v24));
              *(float32x2_t *)(*a4 + 8 * v21) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v21), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v25));
              ++v19;
            }
            while (v18 != v19);
          }
        }
        else
        {
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v10, v13, 0, &v24);
          uint64_t v16 = *v15;
          *(void *)(*a4 + 8 * v16) = 0;
          *(float32x2_t *)(*a4 + 8 * v16) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v16), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v24));
          *(float32x2_t *)(*a4 + 8 * v16) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v16), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v25));
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(v23 + 4));
    uint64_t v8 = __p;
  }
  operator delete(v8);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v7 = v6[2];
  float v47 = v6;
  uint64_t v48 = v6[1];
  uint64_t v8 = v6[60];
  uint64_t v9 = *(void *)(v7 + 456);
  uint64_t v49 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v48 + 456) + 8 * a5);
  if (*((unsigned char *)v49 + 12)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = **(_DWORD **)a1 == 0;
  }
  BOOL v42 = v10;
  uint64_t v11 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v8 + 8 * a5);
  uint64_t v41 = *(void **)(v9 + 8 * a5);
  unsigned int v12 = *(_DWORD *)(v48 + 20);
  uint64_t v56 = &v59;
  int v57 = 2 * v12;
  int v58 = 32;
  float v60 = 0;
  if (2 * v12 >= 0x21)
  {
    float v60 = operator new(8 * v12);
    uint64_t v56 = (uint64_t *)v60;
    int v58 = 2 * v12;
    unsigned int v12 = *(_DWORD *)(v48 + 20);
  }
  uint64_t v13 = 0;
  float v51 = &v54;
  unsigned int v52 = v12;
  int v53 = 16;
  std::string __p = 0;
  if (v12 >= 0x11)
  {
    uint64_t v13 = operator new(4 * v12);
    std::string __p = v13;
    float v51 = (uint64_t *)v13;
    int v53 = v12;
  }
  if (*(int *)(v48 + 8) >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = a3;
    BOOL v16 = v42;
    while (1)
    {
      uint64_t v17 = *(int *)(v47[30] + 4 * v14);
      if (v17 != -1)
      {
        uint64_t v18 = *(int *)(*((void *)v49 + 12) + 4 * v14);
        uint64_t v19 = (int *)(*((void *)v49 + 18) + 4 * v18);
        uint64_t v20 = *(int *)(v41[12] + 4 * v17);
        uint64_t v21 = (int *)(v41[18] + 4 * v20);
        uint64_t v22 = *v21;
        uint64_t v23 = v41[21];
        if ((*(unsigned char *)(v23 + v22) & 1) == 0 && v16)
        {
          *(void *)(*a4 + 8 * v22) = 0;
          int v25 = (float32x2_t *)(*a4 + 8 * *v21);
          int v26 = *v19;
        }
        else
        {
          if (*(unsigned char *)(v23 + v22))
          {
            uint64_t v27 = v41[9];
            uint64_t v28 = *(unsigned __int16 *)(v27 + 2 * v17);
            if (*(_WORD *)(v27 + 2 * v17))
            {
              uint64_t v29 = 0;
              uint64_t v45 = *((void *)v49 + 21) + v18;
              uint64_t v46 = *(unsigned __int16 *)(v27 + 2 * v17);
              uint64_t v30 = v23 + v20;
              uint64_t v44 = v30;
              do
              {
                uint64_t v31 = *(unsigned __int16 *)(*((void *)v11 + 5)
                                          + 2
                                          * (*(_DWORD *)(*(void *)(*((void *)v11 + 4) + 96) + 4 * v17)
                                           + (unsigned __int16)v29));
                if (v29 != v31) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
                }
                uint64_t v32 = v19[v31];
                uint64_t v33 = v21[v29];
                *(void *)(*a4 + 8 * v33) = 0;
                if (!v16 && (*(unsigned char *)(v30 + v29) & 8) != 0)
                {
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v49, v14, v31, v50);
                  if ((*(unsigned char *)(v45 + v31) & 0x10) != 0)
                  {
                    if ((*(unsigned char *)(v45 + v31) & 0x20) != 0)
                    {
                      unsigned int v38 = v31 == 0;
                      uint64_t v36 = v11;
                      int v37 = v14;
                    }
                    else
                    {
                      uint64_t v36 = v11;
                      int v37 = v14;
                      unsigned int v38 = v31;
                    }
                    Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v36, v37, v38, v17);
                    float v40 = 1.0 - FractionalWeight;
                    float v35 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                    float v34 = v40 * 0.125;
                  }
                  else
                  {
                    float v34 = 0.125;
                    float v35 = 0.75;
                  }
                  uint64_t v15 = a3;
                  uint64_t v30 = v44;
                  BOOL v16 = v42;
                  uint64_t v28 = v46;
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[0]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[1]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v32), v35);
                }
                else
                {
                  *(float32x2_t *)(*a4 + 8 * v33) = vadd_f32(*(float32x2_t *)(*v15 + 8 * v32), *(float32x2_t *)(*a4 + 8 * v33));
                }
                ++v29;
              }
              while (v28 != v29);
            }
            goto LABEL_19;
          }
          int v26 = *v19;
          *(void *)(*a4 + 8 * v22) = 0;
          int v25 = (float32x2_t *)(*a4 + 8 * v22);
        }
        *int v25 = vadd_f32(*(float32x2_t *)(*v15 + 8 * v26), *v25);
      }
LABEL_19:
      if (++v14 >= *(int *)(v48 + 8))
      {
        uint64_t v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v60);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v53 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v65 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v56 = v53[1];
  uint64_t v48 = v53[2];
  int v57 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v56 + 456) + 8 * a5);
  if (*((unsigned char *)v57 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v52 = v7;
  float v55 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v53[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v48 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v56 + 20);
  uint64_t v75 = &v78;
  int v76 = 2 * v9;
  int v77 = 32;
  int v79 = 0;
  if (2 * v9 >= 0x21)
  {
    int v79 = (uint64_t *)operator new(8 * v9);
    uint64_t v75 = v79;
    int v77 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v56 + 20);
  }
  BOOL v10 = 0;
  float v70 = (int *)&v73;
  unsigned int v71 = v9;
  int v72 = 16;
  int v74 = 0;
  if (v9 >= 0x11)
  {
    BOOL v10 = (int *)operator new(4 * v9);
    int v74 = v10;
    float v70 = v10;
    int v72 = v9;
  }
  v60[0] = v56;
  v60[1] = v48;
  if (*(int *)(v56 + 8) >= 1)
  {
    float v51 = v8;
    uint64_t v11 = 0;
    uint64_t v13 = v53;
    unsigned int v12 = a3;
    BOOL v14 = v52;
    uint64_t v15 = v55;
    do
    {
      int v58 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v58 != -1)
      {
        uint64_t v16 = *(int *)(*((void *)v57 + 12) + 4 * v11);
        uint64_t v17 = (int *)(*((void *)v57 + 18) + 4 * v16);
        uint64_t v18 = *(int *)(v51[12] + 4 * v58);
        uint64_t v19 = (int *)(v51[18] + 4 * v18);
        uint64_t v20 = *v19;
        uint64_t v21 = v51[21];
        if ((*(unsigned char *)(v21 + v20) & 1) == 0 && v14)
        {
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if (*(unsigned char *)(v21 + v20))
        {
          uint64_t v35 = v51[9];
          uint64_t v36 = *(unsigned __int16 *)(v35 + 2 * v58);
          if (*(_WORD *)(v35 + 2 * v58))
          {
            uint64_t v37 = 0;
            uint64_t v38 = v21 + v18;
            uint64_t v49 = v38;
            uint64_t v50 = *((void *)v57 + 21) + v16;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*((void *)v15 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v15 + 4) + 96) + 4 * v58)
                                         + (unsigned __int16)v37));
              if (v37 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v40 = v17[v39];
              uint64_t v41 = v19[v37];
              *(void *)(*a4 + 8 * v41) = 0;
              if (!v14 && (*(unsigned char *)(v38 + v37) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v57, v11, v39, v66);
                if ((*(unsigned char *)(v50 + v39) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v50 + v39) & 0x20) != 0)
                  {
                    unsigned int v45 = v39 == 0;
                    int v44 = v11;
                  }
                  else
                  {
                    int v44 = v11;
                    unsigned int v45 = v39;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v55, v44, v45, v58);
                  float v47 = 1.0 - FractionalWeight;
                  float v43 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v42 = v47 * 0.125;
                }
                else
                {
                  float v42 = 0.125;
                  float v43 = 0.75;
                }
                uint64_t v13 = v53;
                unsigned int v12 = a3;
                BOOL v14 = v52;
                uint64_t v15 = v55;
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[0]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[1]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v40), v43);
                uint64_t v38 = v49;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v41) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v40), *(float32x2_t *)(*a4 + 8 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          uint64_t v23 = *(int *)(*(void *)(v56 + 336) + 8 * v11);
          float v59 = 0.0;
          int v24 = v75;
          int v25 = (float *)v75 + v23;
          *(void *)uint64_t v66 = &v59;
          float v67 = v75;
          unsigned __int16 v68 = v25;
          memset(v69, 0, 13);
          int v61 = v11;
          int v62 = v58;
          int v63 = *(_DWORD *)(*(void *)(v60[0] + 336) + 8 * v11);
          int v64 = *(_DWORD *)(*(void *)(v60[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v65, (uint64_t)v60, (uint64_t)v66, (*(unsigned __int16 *)(*(void *)(v56 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v48 + 432) + 2 * v58) >> 7) & 0xF);
          uint64_t v13 = v53;
          unsigned int v12 = a3;
          uint64_t v26 = *v17;
          uint64_t v27 = *v19;
          *(void *)(*a4 + 8 * v27) = 0;
          if (v69[2] >= 1)
          {
            if (!LOBYTE(v69[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v28 = *(void *)(v56 + 264);
            uint64_t v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              uint64_t v30 = (int *)(*(void *)(v56 + 288) + 4 * *(int *)(v28 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v31 = *v30++;
                uint64_t v32 = *(int *)(v53[21] + 4 * v31);
                if (v32 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v33 = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * *(int *)(v51[12] + 4 * v32)), v33);
                --v29;
              }
              while (v29);
            }
          }
          if (v69[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v57, v11, v70);
            uint64_t v13 = v53;
            unsigned int v12 = a3;
            if ((int)v23 >= 1)
            {
              uint64_t v34 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * v70[v34]), *(float *)((char *)v24 + v34 * 4));
                ++v34;
              }
              while (v23 != v34);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v59);
          BOOL v14 = v52;
          uint64_t v15 = v55;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v56 + 8));
    BOOL v10 = v74;
  }
  operator delete(v10);
  operator delete(v79);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v53 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v65 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v56 = v53[1];
  uint64_t v48 = v53[2];
  int v57 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v56 + 456) + 8 * a5);
  if (*((unsigned char *)v57 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v52 = v7;
  float v55 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v53[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v48 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v56 + 20);
  uint64_t v75 = &v78;
  int v76 = 2 * v9;
  int v77 = 32;
  int v79 = 0;
  if (2 * v9 >= 0x21)
  {
    int v79 = (uint64_t *)operator new(8 * v9);
    uint64_t v75 = v79;
    int v77 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v56 + 20);
  }
  BOOL v10 = 0;
  float v70 = (int *)&v73;
  unsigned int v71 = v9;
  int v72 = 16;
  int v74 = 0;
  if (v9 >= 0x11)
  {
    BOOL v10 = (int *)operator new(4 * v9);
    int v74 = v10;
    float v70 = v10;
    int v72 = v9;
  }
  v60[0] = v56;
  v60[1] = v48;
  if (*(int *)(v56 + 8) >= 1)
  {
    float v51 = v8;
    uint64_t v11 = 0;
    uint64_t v13 = v53;
    unsigned int v12 = a3;
    BOOL v14 = v52;
    uint64_t v15 = v55;
    do
    {
      int v58 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v58 != -1)
      {
        uint64_t v16 = *(int *)(*((void *)v57 + 12) + 4 * v11);
        uint64_t v17 = (int *)(*((void *)v57 + 18) + 4 * v16);
        uint64_t v18 = *(int *)(v51[12] + 4 * v58);
        uint64_t v19 = (int *)(v51[18] + 4 * v18);
        uint64_t v20 = *v19;
        uint64_t v21 = v51[21];
        if ((*(unsigned char *)(v21 + v20) & 1) == 0 && v14)
        {
          *(void *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if (*(unsigned char *)(v21 + v20))
        {
          uint64_t v35 = v51[9];
          uint64_t v36 = *(unsigned __int16 *)(v35 + 2 * v58);
          if (*(_WORD *)(v35 + 2 * v58))
          {
            uint64_t v37 = 0;
            uint64_t v38 = v21 + v18;
            uint64_t v49 = v38;
            uint64_t v50 = *((void *)v57 + 21) + v16;
            do
            {
              uint64_t v39 = *(unsigned __int16 *)(*((void *)v15 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v15 + 4) + 96) + 4 * v58)
                                         + (unsigned __int16)v37));
              if (v37 != v39) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v40 = v17[v39];
              uint64_t v41 = v19[v37];
              *(void *)(*a4 + 8 * v41) = 0;
              if (!v14 && (*(unsigned char *)(v38 + v37) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v57, v11, v39, v66);
                if ((*(unsigned char *)(v50 + v39) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v50 + v39) & 0x20) != 0)
                  {
                    unsigned int v45 = v39 == 0;
                    int v44 = v11;
                  }
                  else
                  {
                    int v44 = v11;
                    unsigned int v45 = v39;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v55, v44, v45, v58);
                  float v47 = 1.0 - FractionalWeight;
                  float v43 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v42 = v47 * 0.125;
                }
                else
                {
                  float v42 = 0.125;
                  float v43 = 0.75;
                }
                uint64_t v13 = v53;
                unsigned int v12 = a3;
                BOOL v14 = v52;
                uint64_t v15 = v55;
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[0]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v66[1]), v42);
                *(float32x2_t *)(*a4 + 8 * v41) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v41), *(float32x2_t *)(*a3 + 8 * v40), v43);
                uint64_t v38 = v49;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v41) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v40), *(float32x2_t *)(*a4 + 8 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          uint64_t v23 = *(int *)(*(void *)(v56 + 336) + 8 * v11);
          float v59 = 0.0;
          int v24 = v75;
          int v25 = (float *)v75 + v23;
          *(void *)uint64_t v66 = &v59;
          float v67 = v75;
          unsigned __int16 v68 = v25;
          memset(v69, 0, 13);
          int v61 = v11;
          int v62 = v58;
          int v63 = *(_DWORD *)(*(void *)(v60[0] + 336) + 8 * v11);
          int v64 = *(_DWORD *)(*(void *)(v60[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v65, (uint64_t)v60, (uint64_t)v66, (*(unsigned __int16 *)(*(void *)(v56 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v48 + 432) + 2 * v58) >> 7) & 0xF);
          uint64_t v13 = v53;
          unsigned int v12 = a3;
          uint64_t v26 = *v17;
          uint64_t v27 = *v19;
          *(void *)(*a4 + 8 * v27) = 0;
          if (v69[2] >= 1)
          {
            if (!LOBYTE(v69[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v28 = *(void *)(v56 + 264);
            uint64_t v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              uint64_t v30 = (int *)(*(void *)(v56 + 288) + 4 * *(int *)(v28 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v31 = *v30++;
                uint64_t v32 = *(int *)(v53[21] + 4 * v31);
                if (v32 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v33 = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * *(int *)(v51[12] + 4 * v32)), v33);
                --v29;
              }
              while (v29);
            }
          }
          if (v69[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v57, v11, v70);
            uint64_t v13 = v53;
            unsigned int v12 = a3;
            if ((int)v23 >= 1)
            {
              uint64_t v34 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * v70[v34]), *(float *)((char *)v24 + v34 * 4));
                ++v34;
              }
              while (v23 != v34);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v59);
          BOOL v14 = v52;
          uint64_t v15 = v55;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v56 + 8));
    BOOL v10 = v74;
  }
  operator delete(v10);
  operator delete(v79);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv2_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v7 = v6[2];
  float v47 = v6;
  uint64_t v48 = v6[1];
  uint64_t v8 = v6[60];
  uint64_t v9 = *(void *)(v7 + 456);
  uint64_t v49 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v48 + 456) + 8 * a5);
  if (*((unsigned char *)v49 + 12)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = **(_DWORD **)a1 == 0;
  }
  BOOL v42 = v10;
  uint64_t v11 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v8 + 8 * a5);
  uint64_t v41 = *(void **)(v9 + 8 * a5);
  unsigned int v12 = *(_DWORD *)(v48 + 20);
  uint64_t v56 = &v59;
  int v57 = 2 * v12;
  int v58 = 32;
  float v60 = 0;
  if (2 * v12 >= 0x21)
  {
    float v60 = operator new(8 * v12);
    uint64_t v56 = (uint64_t *)v60;
    int v58 = 2 * v12;
    unsigned int v12 = *(_DWORD *)(v48 + 20);
  }
  uint64_t v13 = 0;
  float v51 = &v54;
  unsigned int v52 = v12;
  int v53 = 16;
  std::string __p = 0;
  if (v12 >= 0x11)
  {
    uint64_t v13 = operator new(4 * v12);
    std::string __p = v13;
    float v51 = (uint64_t *)v13;
    int v53 = v12;
  }
  if (*(int *)(v48 + 8) >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = a3;
    BOOL v16 = v42;
    while (1)
    {
      uint64_t v17 = *(int *)(v47[30] + 4 * v14);
      if (v17 != -1)
      {
        uint64_t v18 = *(int *)(*((void *)v49 + 12) + 4 * v14);
        uint64_t v19 = (int *)(*((void *)v49 + 18) + 4 * v18);
        uint64_t v20 = *(int *)(v41[12] + 4 * v17);
        uint64_t v21 = (int *)(v41[18] + 4 * v20);
        uint64_t v22 = *v21;
        uint64_t v23 = v41[21];
        if ((*(unsigned char *)(v23 + v22) & 1) == 0 && v16)
        {
          *(void *)(*a4 + 8 * v22) = 0;
          int v25 = (float32x2_t *)(*a4 + 8 * *v21);
          int v26 = *v19;
        }
        else
        {
          if (*(unsigned char *)(v23 + v22))
          {
            uint64_t v27 = v41[9];
            uint64_t v28 = *(unsigned __int16 *)(v27 + 2 * v17);
            if (*(_WORD *)(v27 + 2 * v17))
            {
              uint64_t v29 = 0;
              uint64_t v45 = *((void *)v49 + 21) + v18;
              uint64_t v46 = *(unsigned __int16 *)(v27 + 2 * v17);
              uint64_t v30 = v23 + v20;
              uint64_t v44 = v30;
              do
              {
                uint64_t v31 = *(unsigned __int16 *)(*((void *)v11 + 5)
                                          + 2
                                          * (*(_DWORD *)(*(void *)(*((void *)v11 + 4) + 96) + 4 * v17)
                                           + (unsigned __int16)v29));
                if (v29 != v31) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
                }
                uint64_t v32 = v19[v31];
                uint64_t v33 = v21[v29];
                *(void *)(*a4 + 8 * v33) = 0;
                if (!v16 && (*(unsigned char *)(v30 + v29) & 8) != 0)
                {
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v49, v14, v31, v50);
                  if ((*(unsigned char *)(v45 + v31) & 0x10) != 0)
                  {
                    if ((*(unsigned char *)(v45 + v31) & 0x20) != 0)
                    {
                      unsigned int v38 = v31 == 0;
                      uint64_t v36 = v11;
                      int v37 = v14;
                    }
                    else
                    {
                      uint64_t v36 = v11;
                      int v37 = v14;
                      unsigned int v38 = v31;
                    }
                    Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v36, v37, v38, v17);
                    float v40 = 1.0 - FractionalWeight;
                    float v35 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                    float v34 = v40 * 0.125;
                  }
                  else
                  {
                    float v34 = 0.125;
                    float v35 = 0.75;
                  }
                  uint64_t v15 = a3;
                  uint64_t v30 = v44;
                  BOOL v16 = v42;
                  uint64_t v28 = v46;
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[0]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[1]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v32), v35);
                }
                else
                {
                  *(float32x2_t *)(*a4 + 8 * v33) = vadd_f32(*(float32x2_t *)(*v15 + 8 * v32), *(float32x2_t *)(*a4 + 8 * v33));
                }
                ++v29;
              }
              while (v28 != v29);
            }
            goto LABEL_19;
          }
          int v26 = *v19;
          *(void *)(*a4 + 8 * v22) = 0;
          int v25 = (float32x2_t *)(*a4 + 8 * v22);
        }
        *int v25 = vadd_f32(*(float32x2_t *)(*v15 + 8 * v26), *v25);
      }
LABEL_19:
      if (++v14 >= *(int *)(v48 + 8))
      {
        uint64_t v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v60);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = (a2 - 1);
  if (a2 < 1 || (int)((*(void *)(*a1 + 72) - *(void *)(*a1 + 64)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner11InterpolateIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0__cold_1();
  }
  int v9 = *(_DWORD *)*a1;
  if (v9)
  {
    if (v9 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
    }
    else if (v9 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(a1, a2, a3, a4);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_((uint64_t)a1, a2, a3, a4);
    BOOL v10 = 0;
    uint64_t v11 = *(void *)(*(void *)(*a1 + 64) + 8 * v4);
    uint64_t v12 = *(void *)(v11 + 8);
    uint64_t v13 = *(unsigned int *)(v12 + 16);
    std::string __p = 0;
    if (v13 >= 9)
    {
      BOOL v10 = operator new(4 * v13);
      std::string __p = v10;
    }
    int v14 = *(_DWORD *)(v12 + 4);
    if (v14 >= 1)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v18 = *(int *)(*(void *)(v11 + 216) + 4 * v16);
        if (v18 != -1)
        {
          uint64_t v19 = (int *)(*(void *)(v12 + 120) + v15);
          *(_OWORD *)(*a4 + 16 * v18) = 0uLL;
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * *v19));
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * v19[1]));
          int v14 = *(_DWORD *)(v12 + 4);
        }
        ++v16;
        v15 += 8;
      }
      while (v16 < v14);
      BOOL v10 = __p;
    }
    operator delete(v10);
    uint64_t v20 = 0;
    uint64_t v21 = *(void *)(*(void *)(*a1 + 64) + 8 * v4);
    uint64_t v22 = *(void *)(v21 + 8);
    uint64_t v27 = 0;
    if ((2 * *(_DWORD *)(v22 + 20)) >= 0x21)
    {
      uint64_t v20 = operator new(4 * (2 * *(_DWORD *)(v22 + 20)));
      uint64_t v27 = v20;
    }
    int v23 = *(_DWORD *)(v22 + 8);
    if (v23 >= 1)
    {
      for (uint64_t i = 0; i < v23; ++i)
      {
        uint64_t v25 = *(int *)(*(void *)(v21 + 240) + 4 * i);
        if (v25 != -1)
        {
          *(_OWORD *)(*a4 + 16 * v25) = 0uLL;
          *(float32x4_t *)(*a4 + 16 * v25) = vaddq_f32(*(float32x4_t *)(*a3 + 16 * i), *(float32x4_t *)(*a4 + 16 * v25));
          int v23 = *(_DWORD *)(v22 + 8);
        }
      }
      uint64_t v20 = v27;
    }
    operator delete(v20);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  if (a2 < 1 || (int)((*((void *)*a1 + 9) - *((void *)*a1 + 8)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i_cold_1();
  }
  int v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv3_fES7_EEviRKT_RT0_i(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  if (a2 < 1 || (int)((*((void *)*a1 + 9) - *((void *)*a1 + 8)) >> 3) < a2) {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner22InterpolateFaceVaryingIP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS6_NS8_9allocatorIS6_EEEEEEviRKT_RT0_i_cold_1();
  }
  int v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
      _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i((uint64_t)a1, a2, a3, a4, a5);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t a1, int a2, void *a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v4 + 52))
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(int **)(v4 + 8);
    uint64_t v9 = v8[5];
    uint64_t v19 = (float *)&v20;
    std::string __p = 0;
    if (v9 >= 0x11)
    {
      uint64_t v7 = operator new(4 * v9);
      std::string __p = v7;
      uint64_t v19 = (float *)v7;
    }
    if (*v8 >= 1)
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t v11 = *(int *)(*(void *)(v4 + 168) + 4 * v10);
        if (v11 != -1)
        {
          uint64_t v12 = (unsigned int *)(*((void *)v8 + 3) + 8 * v10);
          uint64_t v13 = *v12;
          if ((int)v13 < 1)
          {
            *(_OWORD *)(*a4 + 16 * v11) = 0uLL;
          }
          else
          {
            uint64_t v14 = *((void *)v8 + 6) + 4 * (int)v12[1];
            uint64_t v15 = v19;
            uint64_t v16 = v13;
            do
            {
              *v15++ = 1.0 / (float)(int)v13;
              --v16;
            }
            while (v16);
            *(_OWORD *)(*a4 + 16 * v11) = 0uLL;
            unint64_t v17 = 0;
            uint64_t v18 = 4 * v13;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v11) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v11), *(float32x4_t *)(*a3 + 16 * *(int *)(v14 + v17)), v19[v17 / 4]);
              v17 += 4;
            }
            while (v18 != v17);
          }
        }
        ++v10;
      }
      while (v10 < *v8);
      uint64_t v7 = __p;
    }
    operator delete(v7);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = 0;
  v44[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void *)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v34 = *(void *)(v9 + 16);
  int v38 = *(_DWORD *)(v8 + 4);
  uint64_t v11 = *(unsigned int *)(v10 + 16);
  uint64_t v39 = (float *)&v42;
  int v40 = v11;
  int v41 = 8;
  uint64_t v36 = v10;
  std::string __p = 0;
  if (v11 >= 9)
  {
    uint64_t v7 = operator new(4 * v11);
    std::string __p = v7;
    uint64_t v39 = (float *)v7;
    int v41 = v11;
  }
  int v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (uint64_t i = 0; i < v12; ++i)
    {
      uint64_t v14 = *(int *)(*(void *)(v9 + 216) + 4 * i);
      if (v14 != -1)
      {
        uint64_t v15 = (int *)(*(void *)(v10 + 120) + 8 * i);
        uint64_t v16 = *(void *)(v10 + 168);
        unint64_t v17 = (unsigned int *)(*(void *)(v10 + 144) + 8 * i);
        uint64_t v18 = *v17;
        uint64_t v19 = (int)v17[1];
        v35[0] = v44;
        v35[1] = 0;
        v35[2] = v39;
        memset(&v35[3], 0, 13);
        int v37 = i;
        if (*(float *)(*(void *)(v10 + 216) + 4 * i) <= 0.0) {
          int v20 = 1;
        }
        else {
          int v20 = 4;
        }
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v38, (OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface *)&v36, (uint64_t)v35, v20, (*(unsigned __int16 *)(*(void *)(v34 + 432) + 2 * v14) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v14) = 0u;
        float32x2_t v21 = (float32x2_t)v44[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v44);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v21, 1);
        if (SLODWORD(v35[4]) >= 1 && (int)v18 >= 1)
        {
          uint64_t v22 = 0;
          uint64_t v23 = v16 + 4 * v19;
          do
          {
            if (BYTE4(v35[4]))
            {
              if (*(int *)(v9 + 52) <= 0) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
              }
              int v24 = *(_DWORD *)(*(void *)(v9 + 168) + 4 * *(int *)(v23 + 4 * v22));
              if (v24 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              uint64_t v25 = *a4;
              uint64_t v26 = *a4;
            }
            else
            {
              uint64_t v27 = 0;
              uint64_t v28 = *(int *)(v23 + 4 * v22);
              uint64_t v29 = *(void *)(v10 + 24);
              uint64_t v30 = *(int *)(v29 + 8 * v28 + 4);
              int v31 = *(_DWORD *)(v29 + 8 * v28);
              do
                uint64_t v32 = *(unsigned int *)(*(void *)(v10 + 72) + 4 * v30 + 4 * v27++);
              while (i != v32);
              uint64_t v33 = *(void *)(v10 + 48) + 4 * v30;
              if ((int)v27 + 1 < v31) {
                int v31 = 0;
              }
              int v24 = *(_DWORD *)(v33 + 4 * ((int)v27 - v31 + 1));
              uint64_t v26 = *a4;
              uint64_t v25 = *a3;
            }
            *(float32x4_t *)(v26 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v26 + 16 * v14), *(float32x4_t *)(v25 + 16 * v24), v39[v22++]);
          }
          while (v22 != v18);
        }
        int v12 = *(_DWORD *)(v10 + 4);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, void *a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void **)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v11 = v9[1];
  uint64_t v10 = v9[2];
  int v45 = *(_DWORD *)(v8 + 4);
  unsigned int v12 = 2 * *(_DWORD *)(v11 + 20);
  uint64_t v46 = &v49;
  unsigned int v47 = v12;
  int v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  uint64_t v33 = v10;
  std::string __p = 0;
  if (v12 >= 0x21)
  {
    uint64_t v7 = operator new(4 * v12);
    std::string __p = v7;
    uint64_t v46 = (uint64_t *)v7;
    int v48 = v12;
  }
  int v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (uint64_t i = 0; i < v13; ++i)
    {
      int v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        uint64_t v16 = v15;
        uint64_t v36 = *(void *)(v11 + 360);
        uint64_t v17 = *(void *)(v11 + 336);
        uint64_t v18 = (8 * i) | 4;
        uint64_t v35 = *(int *)(v17 + v18);
        uint64_t v19 = *(int *)(v17 + 8 * i);
        uint64_t v20 = *(void *)(v11 + 264);
        uint64_t v34 = *(int *)(v20 + v18);
        uint64_t v21 = *(unsigned int *)(v20 + 8 * i);
        float v39 = 0.0;
        uint64_t v22 = v46;
        uint64_t v23 = (float *)v46 + v19;
        int v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        int v41 = i;
        int v42 = v15;
        int v43 = *(_DWORD *)(*(void *)(v40[0] + 336) + 8 * i);
        int v44 = *(_DWORD *)(*(void *)(v40[0] + 264) + 8 * i);
        uint64_t v24 = *(void *)(v11 + 288);
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(void *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v16) = 0u;
        if (SLODWORD(v38[4]) >= 1)
        {
          if (!BYTE4(v38[4])) {
            _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
          }
          if ((int)v21 >= 1)
          {
            uint64_t v25 = (int *)(v24 + 4 * v34);
            do
            {
              uint64_t v26 = *v25++;
              uint64_t v27 = *(int *)(v9[21] + 4 * v26);
              if (v27 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              float v28 = *v23++;
              *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v27), v28);
              --v21;
            }
            while (v21);
          }
        }
        if (SHIDWORD(v38[3]) >= 1)
        {
          uint64_t v29 = v37;
          if (v37 >= 1)
          {
            uint64_t v30 = (int *)(v36 + 4 * v35);
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (_DWORD *)(*(void *)(v11 + 120) + 8 * v31);
              LODWORD(v31) = *(_DWORD *)v22;
              uint64_t v22 = (uint64_t *)((char *)v22 + 4);
              *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v32[i == *v32]), *(float *)&v31);
              --v29;
            }
            while (v29);
          }
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v39);
        int v13 = *(_DWORD *)(v11 + 8);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = 0;
  v44[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void *)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v34 = *(void *)(v9 + 16);
  int v38 = *(_DWORD *)(v8 + 4);
  uint64_t v11 = *(unsigned int *)(v10 + 16);
  float v39 = (float *)&v42;
  int v40 = v11;
  int v41 = 8;
  uint64_t v36 = v10;
  std::string __p = 0;
  if (v11 >= 9)
  {
    uint64_t v7 = operator new(4 * v11);
    std::string __p = v7;
    float v39 = (float *)v7;
    int v41 = v11;
  }
  int v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (uint64_t i = 0; i < v12; ++i)
    {
      uint64_t v14 = *(int *)(*(void *)(v9 + 216) + 4 * i);
      if (v14 != -1)
      {
        int v15 = (int *)(*(void *)(v10 + 120) + 8 * i);
        uint64_t v16 = *(void *)(v10 + 168);
        uint64_t v17 = (unsigned int *)(*(void *)(v10 + 144) + 8 * i);
        uint64_t v18 = *v17;
        uint64_t v19 = (int)v17[1];
        v35[0] = v44;
        v35[1] = 0;
        v35[2] = v39;
        memset(&v35[3], 0, 13);
        int v37 = i;
        if (*(float *)(*(void *)(v10 + 216) + 4 * i) <= 0.0) {
          int v20 = 1;
        }
        else {
          int v20 = 4;
        }
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v38, (int *)&v36, (uint64_t)v35, v20, (*(unsigned __int16 *)(*(void *)(v34 + 432) + 2 * v14) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v14) = 0u;
        float32x2_t v21 = (float32x2_t)v44[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v44);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v21, 1);
        if (SLODWORD(v35[4]) >= 1 && (int)v18 >= 1)
        {
          uint64_t v22 = 0;
          uint64_t v23 = v16 + 4 * v19;
          do
          {
            if (BYTE4(v35[4]))
            {
              if (*(int *)(v9 + 52) <= 0) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
              }
              int v24 = *(_DWORD *)(*(void *)(v9 + 168) + 4 * *(int *)(v23 + 4 * v22));
              if (v24 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              uint64_t v25 = *a4;
              uint64_t v26 = *a4;
            }
            else
            {
              uint64_t v27 = 0;
              uint64_t v28 = *(int *)(v23 + 4 * v22);
              uint64_t v29 = *(void *)(v10 + 24);
              uint64_t v30 = *(int *)(v29 + 8 * v28 + 4);
              int v31 = *(_DWORD *)(v29 + 8 * v28);
              do
                uint64_t v32 = *(unsigned int *)(*(void *)(v10 + 72) + 4 * v30 + 4 * v27++);
              while (i != v32);
              uint64_t v33 = *(void *)(v10 + 48) + 4 * v30;
              if ((int)v27 + 1 < v31) {
                int v31 = 0;
              }
              int v24 = *(_DWORD *)(v33 + 4 * ((int)v27 - v31 + 1));
              uint64_t v26 = *a4;
              uint64_t v25 = *a3;
            }
            *(float32x4_t *)(v26 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v26 + 16 * v14), *(float32x4_t *)(v25 + 16 * v24), v39[v22++]);
          }
          while (v22 != v18);
        }
        int v12 = *(_DWORD *)(v10 + 4);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_(uint64_t *a1, int a2, void *a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a1;
  uint64_t v9 = *(void **)(*(void *)(v8 + 64) + 8 * (a2 - 1));
  uint64_t v11 = v9[1];
  uint64_t v10 = v9[2];
  int v45 = *(_DWORD *)(v8 + 4);
  unsigned int v12 = 2 * *(_DWORD *)(v11 + 20);
  uint64_t v46 = &v49;
  unsigned int v47 = v12;
  int v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  uint64_t v33 = v10;
  std::string __p = 0;
  if (v12 >= 0x21)
  {
    uint64_t v7 = operator new(4 * v12);
    std::string __p = v7;
    uint64_t v46 = (uint64_t *)v7;
    int v48 = v12;
  }
  int v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (uint64_t i = 0; i < v13; ++i)
    {
      int v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        uint64_t v16 = v15;
        uint64_t v36 = *(void *)(v11 + 360);
        uint64_t v17 = *(void *)(v11 + 336);
        uint64_t v18 = (8 * i) | 4;
        uint64_t v35 = *(int *)(v17 + v18);
        uint64_t v19 = *(int *)(v17 + 8 * i);
        uint64_t v20 = *(void *)(v11 + 264);
        uint64_t v34 = *(int *)(v20 + v18);
        uint64_t v21 = *(unsigned int *)(v20 + 8 * i);
        float v39 = 0.0;
        uint64_t v22 = v46;
        uint64_t v23 = (float *)v46 + v19;
        int v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        int v41 = i;
        int v42 = v15;
        int v43 = *(_DWORD *)(*(void *)(v40[0] + 336) + 8 * i);
        int v44 = *(_DWORD *)(*(void *)(v40[0] + 264) + 8 * i);
        uint64_t v24 = *(void *)(v11 + 288);
        OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(void *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v16) = 0u;
        if (SLODWORD(v38[4]) >= 1)
        {
          if (!BYTE4(v38[4])) {
            _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_1();
          }
          if ((int)v21 >= 1)
          {
            uint64_t v25 = (int *)(v24 + 4 * v34);
            do
            {
              uint64_t v26 = *v25++;
              uint64_t v27 = *(int *)(v9[21] + 4 * v26);
              if (v27 == -1) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner15interpFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1__cold_2();
              }
              float v28 = *v23++;
              *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v27), v28);
              --v21;
            }
            while (v21);
          }
        }
        if (SHIDWORD(v38[3]) >= 1)
        {
          uint64_t v29 = v37;
          if (v37 >= 1)
          {
            uint64_t v30 = (int *)(v36 + 4 * v35);
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (_DWORD *)(*(void *)(v11 + 120) + 8 * v31);
              LODWORD(v31) = *(_DWORD *)v22;
              uint64_t v22 = (uint64_t *)((char *)v22 + 4);
              *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v32[i == *v32]), *(float *)&v31);
              --v29;
            }
            while (v29);
          }
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v39);
        int v13 = *(_DWORD *)(v11 + 8);
      }
    }
    uint64_t v7 = __p;
  }
  operator delete(v7);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromFacesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v5 + 52))
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(int **)(v5 + 8);
    uint64_t v10 = *(void **)(*((void *)v9 + 57) + 8 * a5);
    uint64_t v11 = *(void *)(*(void *)(*(void *)(v5 + 16) + 456) + 8 * a5);
    uint64_t v12 = v9[5];
    uint64_t v23 = (float *)&v24;
    std::string __p = 0;
    if (v12 >= 0x11)
    {
      uint64_t v8 = operator new(4 * v12);
      std::string __p = v8;
      uint64_t v23 = (float *)v8;
    }
    if (*v9 >= 1)
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(int *)(*(void *)(v5 + 168) + 4 * v13);
        if (v14 != -1)
        {
          uint64_t v15 = *(int *)(*(void *)(v11 + 96) + 4 * v14);
          uint64_t v16 = (unsigned int *)(*(void *)(*v10 + 24) + 8 * v13);
          uint64_t v17 = *v16;
          if ((int)v17 < 1)
          {
            *(_OWORD *)(*a4 + 16 * v15) = 0uLL;
          }
          else
          {
            uint64_t v18 = v10[3] + 4 * (int)v16[1];
            uint64_t v19 = v23;
            uint64_t v20 = v17;
            do
            {
              *v19++ = 1.0 / (float)(int)v17;
              --v20;
            }
            while (v20);
            *(_OWORD *)(*a4 + 16 * v15) = 0uLL;
            unint64_t v21 = 0;
            uint64_t v22 = 4 * v17;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v15) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v15), *(float32x4_t *)(*a3 + 16 * *(int *)(v18 + v21)), v23[v21 / 4]);
              v21 += 4;
            }
            while (v22 != v21);
          }
        }
        ++v13;
      }
      while (v13 < *v9);
      uint64_t v8 = __p;
    }
    operator delete(v8);
  }
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  v60[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v52 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v9 = v8[1];
  uint64_t v10 = *(void *)(v8[60] + 8 * a5);
  uint64_t v11 = *(void *)(*(void *)(v9 + 456) + 8 * a5);
  uint64_t v45 = v8[2];
  uint64_t v12 = *(void **)(*(void *)(v45 + 456) + 8 * a5);
  uint64_t v48 = v9;
  uint64_t v13 = *(unsigned int *)(v9 + 16);
  uint64_t v14 = v58;
  float v55 = v58;
  int v56 = v13;
  int v57 = 8;
  std::string __p = 0;
  if (v13 < 9)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = operator new(4 * v13);
    std::string __p = v15;
    float v55 = v15;
    int v57 = v13;
    uint64_t v14 = v15;
  }
  v51[0] = v60;
  v51[1] = 0;
  v51[2] = v14;
  memset(&v51[3], 0, 13);
  if (*(unsigned char *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v51[3]) = 2;
    LODWORD(v51[4]) = 0;
    v60[0] = 0x3F0000003F000000;
    char v46 = 1;
  }
  else
  {
    char v46 = 0;
  }
  uint64_t v49 = v48;
  if (*(int *)(v48 + 4) >= 1)
  {
    uint64_t v16 = 0;
    unsigned int v47 = v8;
    do
    {
      uint64_t v17 = *(int *)(v8[27] + 4 * v16);
      if (v17 != -1)
      {
        uint64_t v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if (*(unsigned char *)(v12[21] + *v18))
        {
          uint64_t v38 = v12[9];
          uint64_t v39 = *(unsigned __int16 *)(v38 + 2 * v17);
          if (*(_WORD *)(v38 + 2 * v17))
          {
            uint64_t v40 = 0;
            do
            {
              uint64_t v41 = *(unsigned __int16 *)(*(void *)(v10 + 40)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*(void *)(v10 + 32) + 96) + 4 * v17)
                                         + (unsigned __int16)v40));
              if (v40 != v41) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, v41, &v53);
              uint64_t v42 = v18[v40];
              *(_OWORD *)(*a4 + 16 * v42) = 0u;
              uint64_t v43 = v54;
              v44.i64[0] = 0x3F0000003F000000;
              v44.i64[1] = 0x3F0000003F000000;
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v44, *(float32x4_t *)(*a3 + 16 * v53));
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v44, *(float32x4_t *)(*a3 + 16 * v43));
              ++v40;
            }
            while (v39 != v40);
          }
        }
        else
        {
          if ((v46 & 1) == 0)
          {
            int v50 = v16;
            if (*(float *)(*(void *)(v48 + 216) + 4 * v16) <= 0.0) {
              int v19 = 1;
            }
            else {
              int v19 = 4;
            }
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v52, (OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface *)&v49, (uint64_t)v51, v19, (*(unsigned __int16 *)(*(void *)(v45 + 432) + 2 * v17) >> 7) & 0xF);
          }
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, 0, &v53);
          uint64_t v20 = *v18;
          *(_OWORD *)(*a4 + 16 * v20) = 0u;
          uint64_t v21 = v54;
          float32x2_t v22 = (float32x2_t)v60[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v53), *(float *)v60);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v21), v22, 1);
          if (SLODWORD(v51[4]) >= 1)
          {
            uint64_t v23 = (unsigned int *)(*(void *)(v48 + 144) + 8 * v16);
            uint64_t v24 = *v23;
            if ((int)v24 >= 1)
            {
              uint64_t v25 = 0;
              uint64_t v26 = *(void *)(v48 + 168) + 4 * (int)v23[1];
              do
              {
                uint64_t v27 = *(int *)(v26 + 4 * v25);
                if (BYTE4(v51[4]))
                {
                  uint64_t v28 = *(int *)(v47[21] + 4 * v27);
                  if (v28 == -1) {
                    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
                  }
                  uint64_t v29 = (int *)(v12[12] + 4 * v28);
                  uint64_t v30 = *a4;
                  uint64_t v31 = *a4;
                }
                else
                {
                  uint64_t v32 = 0;
                  uint64_t v33 = (2 * (int)v27) | 1;
                  uint64_t v34 = *(void *)(v48 + 24);
                  uint64_t v35 = *(void *)(v48 + 72) + 4 * *(int *)(v34 + 4 * v33);
                  int v36 = *(_DWORD *)(v34 + 8 * v27);
                  do
                    uint64_t v37 = *(unsigned int *)(v35 + 4 * v32++);
                  while (v16 != v37);
                  if ((int)v32 + 1 < v36) {
                    int v36 = 0;
                  }
                  uint64_t v29 = (int *)(*(void *)(v11 + 24)
                              + 4 * *(int *)(*(void *)(*(void *)v11 + 24) + 4 * v33)
                              + 4 * ((int)v32 - v36 + 1));
                  uint64_t v31 = *a4;
                  uint64_t v30 = *a3;
                }
                *(float32x4_t *)(v31 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v31 + 16 * v20), *(float32x4_t *)(v30 + 16 * *v29), *(float *)&v55[4 * v25++]);
              }
              while (v25 != v24);
            }
          }
        }
      }
      ++v16;
      uint64_t v8 = v47;
    }
    while (v16 < *(int *)(v48 + 4));
    uint64_t v15 = __p;
  }
  operator delete(v15);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v54 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v66 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v57 = v54[1];
  uint64_t v49 = v54[2];
  int v58 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v57 + 456) + 8 * a5);
  if (*((unsigned char *)v58 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v53 = v7;
  int v56 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v54[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v49 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v57 + 20);
  int v76 = &v79;
  int v77 = 2 * v9;
  int v78 = 32;
  uint64_t v80 = 0;
  if (2 * v9 >= 0x21)
  {
    uint64_t v80 = (uint64_t *)operator new(8 * v9);
    int v76 = v80;
    int v78 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v57 + 20);
  }
  uint64_t v10 = 0;
  unsigned int v71 = (int *)&v74;
  unsigned int v72 = v9;
  int v73 = 16;
  uint64_t v75 = 0;
  if (v9 >= 0x11)
  {
    uint64_t v10 = (int *)operator new(4 * v9);
    uint64_t v75 = v10;
    unsigned int v71 = v10;
    int v73 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    int v52 = v8;
    uint64_t v11 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = v54;
    uint64_t v13 = a3;
    BOOL v15 = v53;
    uint64_t v16 = v56;
    do
    {
      int v59 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v59 != -1)
      {
        uint64_t v17 = *(int *)(*((void *)v58 + 12) + 4 * v11);
        uint64_t v18 = (int *)(*((void *)v58 + 18) + 4 * v17);
        uint64_t v19 = *(int *)(v52[12] + 4 * v59);
        uint64_t v20 = (int *)(v52[18] + 4 * v19);
        uint64_t v21 = *v20;
        uint64_t v22 = v52[21];
        if ((*(unsigned char *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if (*(unsigned char *)(v22 + v21))
        {
          uint64_t v36 = v52[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v59);
          if (*(_WORD *)(v36 + 2 * v59))
          {
            uint64_t v38 = 0;
            uint64_t v39 = v22 + v19;
            uint64_t v50 = v39;
            uint64_t v51 = *((void *)v58 + 21) + v17;
            do
            {
              uint64_t v40 = *(unsigned __int16 *)(*((void *)v16 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v16 + 4) + 96) + 4 * v59)
                                         + (unsigned __int16)v38));
              if (v38 != v40) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v41 = v18[v40];
              uint64_t v42 = v20[v38];
              *(_OWORD *)(*a4 + 16 * v42) = v12;
              if (!v15 && (*(unsigned char *)(v39 + v38) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v58, v11, v40, v67);
                if ((*(unsigned char *)(v51 + v40) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v51 + v40) & 0x20) != 0)
                  {
                    unsigned int v46 = v40 == 0;
                    int v45 = v11;
                  }
                  else
                  {
                    int v45 = v11;
                    unsigned int v46 = v40;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v56, v45, v46, v59);
                  float v48 = 1.0 - FractionalWeight;
                  float v44 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v43 = v48 * 0.125;
                }
                else
                {
                  float v43 = 0.125;
                  float v44 = 0.75;
                }
                uint64_t v14 = v54;
                uint64_t v13 = a3;
                BOOL v15 = v53;
                uint64_t v16 = v56;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[0]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[1]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v44);
                long long v12 = 0uLL;
                uint64_t v39 = v50;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          uint64_t v24 = *(int *)(*(void *)(v57 + 336) + 8 * v11);
          float v60 = 0.0;
          uint64_t v25 = v76;
          uint64_t v26 = (float *)v76 + v24;
          *(void *)float v67 = &v60;
          unsigned __int16 v68 = v76;
          uint64_t v69 = v26;
          memset(v70, 0, 13);
          int v62 = v11;
          int v63 = v59;
          int v64 = *(_DWORD *)(*(void *)(v61[0] + 336) + 8 * v11);
          int v65 = *(_DWORD *)(*(void *)(v61[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(void *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          long long v12 = 0uLL;
          uint64_t v14 = v54;
          uint64_t v13 = a3;
          uint64_t v27 = *v18;
          uint64_t v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (v70[2] >= 1)
          {
            if (!LOBYTE(v70[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v29 = *(void *)(v57 + 264);
            uint64_t v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              uint64_t v31 = (int *)(*(void *)(v57 + 288) + 4 * *(int *)(v29 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v32 = *v31++;
                uint64_t v33 = *(int *)(v54[21] + 4 * v32);
                if (v33 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v34 = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * *(int *)(v52[12] + 4 * v33)), v34);
                --v30;
              }
              while (v30);
            }
          }
          if (v70[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v58, v11, v71);
            long long v12 = 0uLL;
            uint64_t v14 = v54;
            uint64_t v13 = a3;
            if ((int)v24 >= 1)
            {
              uint64_t v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * v71[v35]), *(float *)((char *)v25 + v35 * 4));
                ++v35;
              }
              while (v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v60);
          BOOL v15 = v53;
          uint64_t v16 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    uint64_t v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  v60[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v52 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v9 = v8[1];
  uint64_t v10 = *(void *)(v8[60] + 8 * a5);
  uint64_t v11 = *(void *)(*(void *)(v9 + 456) + 8 * a5);
  uint64_t v45 = v8[2];
  long long v12 = *(void **)(*(void *)(v45 + 456) + 8 * a5);
  uint64_t v48 = v9;
  uint64_t v13 = *(unsigned int *)(v9 + 16);
  uint64_t v14 = v58;
  float v55 = v58;
  int v56 = v13;
  int v57 = 8;
  std::string __p = 0;
  if (v13 < 9)
  {
    BOOL v15 = 0;
  }
  else
  {
    BOOL v15 = operator new(4 * v13);
    std::string __p = v15;
    float v55 = v15;
    int v57 = v13;
    uint64_t v14 = v15;
  }
  v51[0] = v60;
  v51[1] = 0;
  v51[2] = v14;
  memset(&v51[3], 0, 13);
  if (*(unsigned char *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v51[3]) = 2;
    LODWORD(v51[4]) = 0;
    v60[0] = 0x3F0000003F000000;
    char v46 = 1;
  }
  else
  {
    char v46 = 0;
  }
  uint64_t v49 = v48;
  if (*(int *)(v48 + 4) >= 1)
  {
    uint64_t v16 = 0;
    unsigned int v47 = v8;
    do
    {
      uint64_t v17 = *(int *)(v8[27] + 4 * v16);
      if (v17 != -1)
      {
        uint64_t v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if (*(unsigned char *)(v12[21] + *v18))
        {
          uint64_t v38 = v12[9];
          uint64_t v39 = *(unsigned __int16 *)(v38 + 2 * v17);
          if (*(_WORD *)(v38 + 2 * v17))
          {
            uint64_t v40 = 0;
            do
            {
              uint64_t v41 = *(unsigned __int16 *)(*(void *)(v10 + 40)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*(void *)(v10 + 32) + 96) + 4 * v17)
                                         + (unsigned __int16)v40));
              if (v40 != v41) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, v41, &v53);
              uint64_t v42 = v18[v40];
              *(_OWORD *)(*a4 + 16 * v42) = 0u;
              uint64_t v43 = v54;
              v44.i64[0] = 0x3F0000003F000000;
              v44.i64[1] = 0x3F0000003F000000;
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v44, *(float32x4_t *)(*a3 + 16 * v53));
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v44, *(float32x4_t *)(*a3 + 16 * v43));
              ++v40;
            }
            while (v39 != v40);
          }
        }
        else
        {
          if ((v46 & 1) == 0)
          {
            int v50 = v16;
            if (*(float *)(*(void *)(v48 + 216) + 4 * v16) <= 0.0) {
              int v19 = 1;
            }
            else {
              int v19 = 4;
            }
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v52, (int *)&v49, (uint64_t)v51, v19, (*(unsigned __int16 *)(*(void *)(v45 + 432) + 2 * v17) >> 7) & 0xF);
          }
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues((void *)v11, v16, 0, &v53);
          uint64_t v20 = *v18;
          *(_OWORD *)(*a4 + 16 * v20) = 0u;
          uint64_t v21 = v54;
          float32x2_t v22 = (float32x2_t)v60[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v53), *(float *)v60);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v21), v22, 1);
          if (SLODWORD(v51[4]) >= 1)
          {
            uint64_t v23 = (unsigned int *)(*(void *)(v48 + 144) + 8 * v16);
            uint64_t v24 = *v23;
            if ((int)v24 >= 1)
            {
              uint64_t v25 = 0;
              uint64_t v26 = *(void *)(v48 + 168) + 4 * (int)v23[1];
              do
              {
                uint64_t v27 = *(int *)(v26 + 4 * v25);
                if (BYTE4(v51[4]))
                {
                  uint64_t v28 = *(int *)(v47[21] + 4 * v27);
                  if (v28 == -1) {
                    _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
                  }
                  uint64_t v29 = (int *)(v12[12] + 4 * v28);
                  uint64_t v30 = *a4;
                  uint64_t v31 = *a4;
                }
                else
                {
                  uint64_t v32 = 0;
                  uint64_t v33 = (2 * (int)v27) | 1;
                  uint64_t v34 = *(void *)(v48 + 24);
                  uint64_t v35 = *(void *)(v48 + 72) + 4 * *(int *)(v34 + 4 * v33);
                  int v36 = *(_DWORD *)(v34 + 8 * v27);
                  do
                    uint64_t v37 = *(unsigned int *)(v35 + 4 * v32++);
                  while (v16 != v37);
                  if ((int)v32 + 1 < v36) {
                    int v36 = 0;
                  }
                  uint64_t v29 = (int *)(*(void *)(v11 + 24)
                              + 4 * *(int *)(*(void *)(*(void *)v11 + 24) + 4 * v33)
                              + 4 * ((int)v32 - v36 + 1));
                  uint64_t v31 = *a4;
                  uint64_t v30 = *a3;
                }
                *(float32x4_t *)(v31 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v31 + 16 * v20), *(float32x4_t *)(v30 + 16 * *v29), *(float *)&v55[4 * v25++]);
              }
              while (v25 != v24);
            }
          }
        }
      }
      ++v16;
      uint64_t v8 = v47;
    }
    while (v16 < *(int *)(v48 + 4));
    BOOL v15 = __p;
  }
  operator delete(v15);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  int v54 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v66 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v57 = v54[1];
  uint64_t v49 = v54[2];
  int v58 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v57 + 456) + 8 * a5);
  if (*((unsigned char *)v58 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v53 = v7;
  int v56 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v54[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v49 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v57 + 20);
  int v76 = &v79;
  int v77 = 2 * v9;
  int v78 = 32;
  uint64_t v80 = 0;
  if (2 * v9 >= 0x21)
  {
    uint64_t v80 = (uint64_t *)operator new(8 * v9);
    int v76 = v80;
    int v78 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v57 + 20);
  }
  uint64_t v10 = 0;
  unsigned int v71 = (int *)&v74;
  unsigned int v72 = v9;
  int v73 = 16;
  uint64_t v75 = 0;
  if (v9 >= 0x11)
  {
    uint64_t v10 = (int *)operator new(4 * v9);
    uint64_t v75 = v10;
    unsigned int v71 = v10;
    int v73 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    int v52 = v8;
    uint64_t v11 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = v54;
    uint64_t v13 = a3;
    BOOL v15 = v53;
    uint64_t v16 = v56;
    do
    {
      int v59 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v59 != -1)
      {
        uint64_t v17 = *(int *)(*((void *)v58 + 12) + 4 * v11);
        uint64_t v18 = (int *)(*((void *)v58 + 18) + 4 * v17);
        uint64_t v19 = *(int *)(v52[12] + 4 * v59);
        uint64_t v20 = (int *)(v52[18] + 4 * v19);
        uint64_t v21 = *v20;
        uint64_t v22 = v52[21];
        if ((*(unsigned char *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if (*(unsigned char *)(v22 + v21))
        {
          uint64_t v36 = v52[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v59);
          if (*(_WORD *)(v36 + 2 * v59))
          {
            uint64_t v38 = 0;
            uint64_t v39 = v22 + v19;
            uint64_t v50 = v39;
            uint64_t v51 = *((void *)v58 + 21) + v17;
            do
            {
              uint64_t v40 = *(unsigned __int16 *)(*((void *)v16 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v16 + 4) + 96) + 4 * v59)
                                         + (unsigned __int16)v38));
              if (v38 != v40) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v41 = v18[v40];
              uint64_t v42 = v20[v38];
              *(_OWORD *)(*a4 + 16 * v42) = v12;
              if (!v15 && (*(unsigned char *)(v39 + v38) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v58, v11, v40, v67);
                if ((*(unsigned char *)(v51 + v40) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v51 + v40) & 0x20) != 0)
                  {
                    unsigned int v46 = v40 == 0;
                    int v45 = v11;
                  }
                  else
                  {
                    int v45 = v11;
                    unsigned int v46 = v40;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v56, v45, v46, v59);
                  float v48 = 1.0 - FractionalWeight;
                  float v44 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v43 = v48 * 0.125;
                }
                else
                {
                  float v43 = 0.125;
                  float v44 = 0.75;
                }
                uint64_t v14 = v54;
                uint64_t v13 = a3;
                BOOL v15 = v53;
                uint64_t v16 = v56;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[0]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[1]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v44);
                long long v12 = 0uLL;
                uint64_t v39 = v50;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          uint64_t v24 = *(int *)(*(void *)(v57 + 336) + 8 * v11);
          float v60 = 0.0;
          uint64_t v25 = v76;
          uint64_t v26 = (float *)v76 + v24;
          *(void *)float v67 = &v60;
          unsigned __int16 v68 = v76;
          uint64_t v69 = v26;
          memset(v70, 0, 13);
          int v62 = v11;
          int v63 = v59;
          int v64 = *(_DWORD *)(*(void *)(v61[0] + 336) + 8 * v11);
          int v65 = *(_DWORD *)(*(void *)(v61[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(void *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          long long v12 = 0uLL;
          uint64_t v14 = v54;
          uint64_t v13 = a3;
          uint64_t v27 = *v18;
          uint64_t v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (v70[2] >= 1)
          {
            if (!LOBYTE(v70[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v29 = *(void *)(v57 + 264);
            uint64_t v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              uint64_t v31 = (int *)(*(void *)(v57 + 288) + 4 * *(int *)(v29 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v32 = *v31++;
                uint64_t v33 = *(int *)(v54[21] + 4 * v32);
                if (v33 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v34 = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * *(int *)(v52[12] + 4 * v33)), v34);
                --v30;
              }
              while (v30);
            }
          }
          if (v70[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v58, v11, v71);
            long long v12 = 0uLL;
            uint64_t v14 = v54;
            uint64_t v13 = a3;
            if ((int)v24 >= 1)
            {
              uint64_t v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * v71[v35]), *(float *)((char *)v25 + v35 * 4));
                ++v35;
              }
              while (v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v60);
          BOOL v15 = v53;
          uint64_t v16 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    uint64_t v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v8 = 0;
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v26 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v27 = v26[1];
  uint64_t v9 = *(void *)(v26[60] + 8 * a5);
  uint64_t v10 = *(void **)(*(void *)(v27 + 456) + 8 * a5);
  uint64_t v11 = *(void **)(*(void *)(v26[2] + 456) + 8 * a5);
  uint64_t v12 = *(unsigned int *)(v27 + 16);
  uint64_t v30 = &v33;
  int v31 = v12;
  int v32 = 8;
  std::string __p = 0;
  if (v12 >= 9)
  {
    uint64_t v8 = operator new(4 * v12);
    std::string __p = v8;
    uint64_t v30 = (uint64_t *)v8;
    int v32 = v12;
  }
  if (*(int *)(v27 + 4) >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(int *)(v26[27] + 4 * v13);
      if (v14 != -1)
      {
        BOOL v15 = (int *)(v11[18] + 4 * *(int *)(v11[12] + 4 * v14));
        if (*(unsigned char *)(v11[21] + *v15))
        {
          uint64_t v19 = v11[9];
          uint64_t v20 = *(unsigned __int16 *)(v19 + 2 * v14);
          if (*(_WORD *)(v19 + 2 * v14))
          {
            uint64_t v21 = 0;
            do
            {
              uint64_t v22 = *(unsigned __int16 *)(*(void *)(v9 + 40)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*(void *)(v9 + 32) + 96) + 4 * v14)
                                         + (unsigned __int16)v21));
              if (v21 != v22) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromEdgesILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
              }
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v10, v13, v22, &v28);
              uint64_t v23 = v15[v21];
              *(_OWORD *)(*a4 + 16 * v23) = 0u;
              uint64_t v24 = v29;
              v25.i64[0] = 0x3F0000003F000000;
              v25.i64[1] = 0x3F0000003F000000;
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v23), v25, *(float32x4_t *)(*a3 + 16 * v28));
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v23), v25, *(float32x4_t *)(*a3 + 16 * v24));
              ++v21;
            }
            while (v20 != v21);
          }
        }
        else
        {
          OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v10, v13, 0, &v28);
          uint64_t v16 = *v15;
          *(_OWORD *)(*a4 + 16 * v16) = 0u;
          uint64_t v17 = v29;
          v18.i64[0] = 0x3F0000003F000000;
          v18.i64[1] = 0x3F0000003F000000;
          *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v16), v18, *(float32x4_t *)(*a3 + 16 * v28));
          *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v16), v18, *(float32x4_t *)(*a3 + 16 * v17));
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(v27 + 4));
    uint64_t v8 = __p;
  }
  operator delete(v8);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v7 = v6[2];
  uint64_t v49 = v6;
  uint64_t v50 = v6[1];
  uint64_t v8 = v6[60];
  uint64_t v9 = *(void *)(v7 + 456);
  uint64_t v51 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v50 + 456) + 8 * a5);
  if (*((unsigned char *)v51 + 12)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = **(_DWORD **)a1 == 0;
  }
  BOOL v44 = v10;
  uint64_t v11 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v8 + 8 * a5);
  float v43 = *(void **)(v9 + 8 * a5);
  unsigned int v12 = *(_DWORD *)(v50 + 20);
  int v58 = &v61;
  int v59 = 2 * v12;
  int v60 = 32;
  int v62 = 0;
  if (2 * v12 >= 0x21)
  {
    int v62 = operator new(8 * v12);
    int v58 = (uint64_t *)v62;
    int v60 = 2 * v12;
    unsigned int v12 = *(_DWORD *)(v50 + 20);
  }
  uint64_t v13 = 0;
  BOOL v53 = &v56;
  unsigned int v54 = v12;
  int v55 = 16;
  std::string __p = 0;
  if (v12 >= 0x11)
  {
    uint64_t v13 = operator new(4 * v12);
    std::string __p = v13;
    BOOL v53 = (uint64_t *)v13;
    int v55 = v12;
  }
  if (*(int *)(v50 + 8) >= 1)
  {
    uint64_t v14 = 0;
    long long v15 = 0uLL;
    uint64_t v16 = a3;
    BOOL v17 = v44;
    while (1)
    {
      uint64_t v18 = *(int *)(v49[30] + 4 * v14);
      if (v18 != -1)
      {
        uint64_t v19 = *(int *)(*((void *)v51 + 12) + 4 * v14);
        uint64_t v20 = (int *)(*((void *)v51 + 18) + 4 * v19);
        uint64_t v21 = *(int *)(v43[12] + 4 * v18);
        uint64_t v22 = (int *)(v43[18] + 4 * v21);
        uint64_t v23 = *v22;
        uint64_t v24 = v43[21];
        if ((*(unsigned char *)(v24 + v23) & 1) == 0 && v17)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          uint64_t v26 = (float32x4_t *)(*a4 + 16 * *v22);
          int v27 = *v20;
        }
        else
        {
          if (*(unsigned char *)(v24 + v23))
          {
            uint64_t v28 = v43[9];
            uint64_t v29 = *(unsigned __int16 *)(v28 + 2 * v18);
            if (*(_WORD *)(v28 + 2 * v18))
            {
              uint64_t v30 = 0;
              uint64_t v47 = *((void *)v51 + 21) + v19;
              uint64_t v48 = *(unsigned __int16 *)(v28 + 2 * v18);
              uint64_t v31 = v24 + v21;
              uint64_t v46 = v24 + v21;
              do
              {
                uint64_t v32 = *(unsigned __int16 *)(*((void *)v11 + 5)
                                          + 2
                                          * (*(_DWORD *)(*(void *)(*((void *)v11 + 4) + 96) + 4 * v18)
                                           + (unsigned __int16)v30));
                if (v30 != v32) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
                }
                uint64_t v33 = v20[v32];
                uint64_t v34 = v22[v30];
                *(_OWORD *)(*a4 + 16 * v34) = v15;
                if (!v17 && (*(unsigned char *)(v31 + v30) & 8) != 0)
                {
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v51, v14, v32, v52);
                  if ((*(unsigned char *)(v47 + v32) & 0x10) != 0)
                  {
                    if ((*(unsigned char *)(v47 + v32) & 0x20) != 0)
                    {
                      unsigned int v39 = v32 == 0;
                      uint64_t v37 = v11;
                      int v38 = v14;
                    }
                    else
                    {
                      uint64_t v37 = v11;
                      int v38 = v14;
                      unsigned int v39 = v32;
                    }
                    Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v37, v38, v39, v18);
                    float v41 = 1.0 - FractionalWeight;
                    float v36 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                    float v35 = v41 * 0.125;
                  }
                  else
                  {
                    float v35 = 0.125;
                    float v36 = 0.75;
                  }
                  uint64_t v16 = a3;
                  uint64_t v31 = v46;
                  BOOL v17 = v44;
                  long long v15 = 0uLL;
                  uint64_t v29 = v48;
                  uint64_t v42 = v52[1];
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v52[0]), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v42), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v33), v36);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v34) = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v33), *(float32x4_t *)(*a4 + 16 * v34));
                }
                ++v30;
              }
              while (v29 != v30);
            }
            goto LABEL_19;
          }
          int v27 = *v20;
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          uint64_t v26 = (float32x4_t *)(*a4 + 16 * v23);
        }
        *uint64_t v26 = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v50 + 8))
      {
        uint64_t v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v62);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  unsigned int v54 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v66 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v57 = v54[1];
  uint64_t v49 = v54[2];
  int v58 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v57 + 456) + 8 * a5);
  if (*((unsigned char *)v58 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v53 = v7;
  uint64_t v56 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v54[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v49 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v57 + 20);
  int v76 = &v79;
  int v77 = 2 * v9;
  int v78 = 32;
  uint64_t v80 = 0;
  if (2 * v9 >= 0x21)
  {
    uint64_t v80 = (uint64_t *)operator new(8 * v9);
    int v76 = v80;
    int v78 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v57 + 20);
  }
  BOOL v10 = 0;
  unsigned int v71 = (int *)&v74;
  unsigned int v72 = v9;
  int v73 = 16;
  uint64_t v75 = 0;
  if (v9 >= 0x11)
  {
    BOOL v10 = (int *)operator new(4 * v9);
    uint64_t v75 = v10;
    unsigned int v71 = v10;
    int v73 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    int v52 = v8;
    uint64_t v11 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = v54;
    uint64_t v13 = a3;
    BOOL v15 = v53;
    uint64_t v16 = v56;
    do
    {
      int v59 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v59 != -1)
      {
        uint64_t v17 = *(int *)(*((void *)v58 + 12) + 4 * v11);
        uint64_t v18 = (int *)(*((void *)v58 + 18) + 4 * v17);
        uint64_t v19 = *(int *)(v52[12] + 4 * v59);
        uint64_t v20 = (int *)(v52[18] + 4 * v19);
        uint64_t v21 = *v20;
        uint64_t v22 = v52[21];
        if ((*(unsigned char *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if (*(unsigned char *)(v22 + v21))
        {
          uint64_t v36 = v52[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v59);
          if (*(_WORD *)(v36 + 2 * v59))
          {
            uint64_t v38 = 0;
            uint64_t v39 = v22 + v19;
            uint64_t v50 = v39;
            uint64_t v51 = *((void *)v58 + 21) + v17;
            do
            {
              uint64_t v40 = *(unsigned __int16 *)(*((void *)v16 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v16 + 4) + 96) + 4 * v59)
                                         + (unsigned __int16)v38));
              if (v38 != v40) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v41 = v18[v40];
              uint64_t v42 = v20[v38];
              *(_OWORD *)(*a4 + 16 * v42) = v12;
              if (!v15 && (*(unsigned char *)(v39 + v38) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v58, v11, v40, v67);
                if ((*(unsigned char *)(v51 + v40) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v51 + v40) & 0x20) != 0)
                  {
                    unsigned int v46 = v40 == 0;
                    int v45 = v11;
                  }
                  else
                  {
                    int v45 = v11;
                    unsigned int v46 = v40;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v56, v45, v46, v59);
                  float v48 = 1.0 - FractionalWeight;
                  float v44 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v43 = v48 * 0.125;
                }
                else
                {
                  float v43 = 0.125;
                  float v44 = 0.75;
                }
                uint64_t v14 = v54;
                uint64_t v13 = a3;
                BOOL v15 = v53;
                uint64_t v16 = v56;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[0]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[1]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v44);
                long long v12 = 0uLL;
                uint64_t v39 = v50;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          uint64_t v24 = *(int *)(*(void *)(v57 + 336) + 8 * v11);
          float v60 = 0.0;
          float32x4_t v25 = v76;
          uint64_t v26 = (float *)v76 + v24;
          *(void *)float v67 = &v60;
          unsigned __int16 v68 = v76;
          uint64_t v69 = v26;
          memset(v70, 0, 13);
          int v62 = v11;
          int v63 = v59;
          int v64 = *(_DWORD *)(*(void *)(v61[0] + 336) + 8 * v11);
          int v65 = *(_DWORD *)(*(void *)(v61[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(void *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          long long v12 = 0uLL;
          uint64_t v14 = v54;
          uint64_t v13 = a3;
          uint64_t v27 = *v18;
          uint64_t v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (v70[2] >= 1)
          {
            if (!LOBYTE(v70[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v29 = *(void *)(v57 + 264);
            uint64_t v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              uint64_t v31 = (int *)(*(void *)(v57 + 288) + 4 * *(int *)(v29 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v32 = *v31++;
                uint64_t v33 = *(int *)(v54[21] + 4 * v32);
                if (v33 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v34 = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * *(int *)(v52[12] + 4 * v33)), v34);
                --v30;
              }
              while (v30);
            }
          }
          if (v70[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v58, v11, v71);
            long long v12 = 0uLL;
            uint64_t v14 = v54;
            uint64_t v13 = a3;
            if ((int)v24 >= 1)
            {
              uint64_t v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * v71[v35]), *(float *)((char *)v25 + v35 * 4));
                ++v35;
              }
              while (v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v60);
          BOOL v15 = v53;
          uint64_t v16 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    BOOL v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE2EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a1;
  unsigned int v54 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  int v66 = *(_DWORD *)(*(void *)a1 + 4);
  uint64_t v57 = v54[1];
  uint64_t v49 = v54[2];
  int v58 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v57 + 456) + 8 * a5);
  if (*((unsigned char *)v58 + 12)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *v6 == 0;
  }
  BOOL v53 = v7;
  uint64_t v56 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v54[60] + 8 * a5);
  uint64_t v8 = *(void **)(*(void *)(v49 + 456) + 8 * a5);
  unsigned int v9 = *(_DWORD *)(v57 + 20);
  int v76 = &v79;
  int v77 = 2 * v9;
  int v78 = 32;
  uint64_t v80 = 0;
  if (2 * v9 >= 0x21)
  {
    uint64_t v80 = (uint64_t *)operator new(8 * v9);
    int v76 = v80;
    int v78 = 2 * v9;
    unsigned int v9 = *(_DWORD *)(v57 + 20);
  }
  BOOL v10 = 0;
  unsigned int v71 = (int *)&v74;
  unsigned int v72 = v9;
  int v73 = 16;
  uint64_t v75 = 0;
  if (v9 >= 0x11)
  {
    BOOL v10 = (int *)operator new(4 * v9);
    uint64_t v75 = v10;
    unsigned int v71 = v10;
    int v73 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    int v52 = v8;
    uint64_t v11 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = v54;
    uint64_t v13 = a3;
    BOOL v15 = v53;
    uint64_t v16 = v56;
    do
    {
      int v59 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v59 != -1)
      {
        uint64_t v17 = *(int *)(*((void *)v58 + 12) + 4 * v11);
        uint64_t v18 = (int *)(*((void *)v58 + 18) + 4 * v17);
        uint64_t v19 = *(int *)(v52[12] + 4 * v59);
        uint64_t v20 = (int *)(v52[18] + 4 * v19);
        uint64_t v21 = *v20;
        uint64_t v22 = v52[21];
        if ((*(unsigned char *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if (*(unsigned char *)(v22 + v21))
        {
          uint64_t v36 = v52[9];
          uint64_t v37 = *(unsigned __int16 *)(v36 + 2 * v59);
          if (*(_WORD *)(v36 + 2 * v59))
          {
            uint64_t v38 = 0;
            uint64_t v39 = v22 + v19;
            uint64_t v50 = v39;
            uint64_t v51 = *((void *)v58 + 21) + v17;
            do
            {
              uint64_t v40 = *(unsigned __int16 *)(*((void *)v16 + 5)
                                        + 2
                                        * (*(_DWORD *)(*(void *)(*((void *)v16 + 4) + 96) + 4 * v59)
                                         + (unsigned __int16)v38));
              if (v38 != v40) {
                _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
              }
              uint64_t v41 = v18[v40];
              uint64_t v42 = v20[v38];
              *(_OWORD *)(*a4 + 16 * v42) = v12;
              if (!v15 && (*(unsigned char *)(v39 + v38) & 8) != 0)
              {
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v58, v11, v40, v67);
                if ((*(unsigned char *)(v51 + v40) & 0x10) != 0)
                {
                  if ((*(unsigned char *)(v51 + v40) & 0x20) != 0)
                  {
                    unsigned int v46 = v40 == 0;
                    int v45 = v11;
                  }
                  else
                  {
                    int v45 = v11;
                    unsigned int v46 = v40;
                  }
                  Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v56, v45, v46, v59);
                  float v48 = 1.0 - FractionalWeight;
                  float v44 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                  float v43 = v48 * 0.125;
                }
                else
                {
                  float v43 = 0.125;
                  float v44 = 0.75;
                }
                uint64_t v14 = v54;
                uint64_t v13 = a3;
                BOOL v15 = v53;
                uint64_t v16 = v56;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[0]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v67[1]), v43);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v44);
                long long v12 = 0uLL;
                uint64_t v39 = v50;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          uint64_t v24 = *(int *)(*(void *)(v57 + 336) + 8 * v11);
          float v60 = 0.0;
          float32x4_t v25 = v76;
          uint64_t v26 = (float *)v76 + v24;
          *(void *)float v67 = &v60;
          unsigned __int16 v68 = v76;
          uint64_t v69 = v26;
          memset(v70, 0, 13);
          int v62 = v11;
          int v63 = v59;
          int v64 = *(_DWORD *)(*(void *)(v61[0] + 336) + 8 * v11);
          int v65 = *(_DWORD *)(*(void *)(v61[0] + 264) + 8 * v11);
          OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(void *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(void *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          long long v12 = 0uLL;
          uint64_t v14 = v54;
          uint64_t v13 = a3;
          uint64_t v27 = *v18;
          uint64_t v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (v70[2] >= 1)
          {
            if (!LOBYTE(v70[3])) {
              _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_1();
            }
            uint64_t v29 = *(void *)(v57 + 264);
            uint64_t v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              uint64_t v31 = (int *)(*(void *)(v57 + 288) + 4 * *(int *)(v29 + 4 * ((2 * v11) | 1)));
              do
              {
                uint64_t v32 = *v31++;
                uint64_t v33 = *(int *)(v54[21] + 4 * v32);
                if (v33 == -1) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_2();
                }
                float v34 = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * *(int *)(v52[12] + 4 * v33)), v34);
                --v30;
              }
              while (v30);
            }
          }
          if (v70[1] >= 1)
          {
            OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v58, v11, v71);
            long long v12 = 0uLL;
            uint64_t v14 = v54;
            uint64_t v13 = a3;
            if ((int)v24 >= 1)
            {
              uint64_t v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * v71[v35]), *(float *)((char *)v25 + v35 * 4));
                ++v35;
              }
              while (v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v60);
          BOOL v15 = v53;
          uint64_t v16 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    BOOL v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE0EP16C3DSubdivCPUDataIDv3_fES9_EEviRKT0_RT1_i(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void **)(*(void *)(*(void *)a1 + 64) + 8 * (a2 - 1));
  uint64_t v7 = v6[2];
  uint64_t v49 = v6;
  uint64_t v50 = v6[1];
  uint64_t v8 = v6[60];
  uint64_t v9 = *(void *)(v7 + 456);
  uint64_t v51 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(void *)(v50 + 456) + 8 * a5);
  if (*((unsigned char *)v51 + 12)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = **(_DWORD **)a1 == 0;
  }
  BOOL v44 = v10;
  uint64_t v11 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v8 + 8 * a5);
  float v43 = *(void **)(v9 + 8 * a5);
  unsigned int v12 = *(_DWORD *)(v50 + 20);
  int v58 = &v61;
  int v59 = 2 * v12;
  int v60 = 32;
  int v62 = 0;
  if (2 * v12 >= 0x21)
  {
    int v62 = operator new(8 * v12);
    int v58 = (uint64_t *)v62;
    int v60 = 2 * v12;
    unsigned int v12 = *(_DWORD *)(v50 + 20);
  }
  uint64_t v13 = 0;
  BOOL v53 = &v56;
  unsigned int v54 = v12;
  int v55 = 16;
  std::string __p = 0;
  if (v12 >= 0x11)
  {
    uint64_t v13 = operator new(4 * v12);
    std::string __p = v13;
    BOOL v53 = (uint64_t *)v13;
    int v55 = v12;
  }
  if (*(int *)(v50 + 8) >= 1)
  {
    uint64_t v14 = 0;
    long long v15 = 0uLL;
    uint64_t v16 = a3;
    BOOL v17 = v44;
    while (1)
    {
      uint64_t v18 = *(int *)(v49[30] + 4 * v14);
      if (v18 != -1)
      {
        uint64_t v19 = *(int *)(*((void *)v51 + 12) + 4 * v14);
        uint64_t v20 = (int *)(*((void *)v51 + 18) + 4 * v19);
        uint64_t v21 = *(int *)(v43[12] + 4 * v18);
        uint64_t v22 = (int *)(v43[18] + 4 * v21);
        uint64_t v23 = *v22;
        uint64_t v24 = v43[21];
        if ((*(unsigned char *)(v24 + v23) & 1) == 0 && v17)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          uint64_t v26 = (float32x4_t *)(*a4 + 16 * *v22);
          int v27 = *v20;
        }
        else
        {
          if (*(unsigned char *)(v24 + v23))
          {
            uint64_t v28 = v43[9];
            uint64_t v29 = *(unsigned __int16 *)(v28 + 2 * v18);
            if (*(_WORD *)(v28 + 2 * v18))
            {
              uint64_t v30 = 0;
              uint64_t v47 = *((void *)v51 + 21) + v19;
              uint64_t v48 = *(unsigned __int16 *)(v28 + 2 * v18);
              uint64_t v31 = v24 + v21;
              uint64_t v46 = v24 + v21;
              do
              {
                uint64_t v32 = *(unsigned __int16 *)(*((void *)v11 + 5)
                                          + 2
                                          * (*(_DWORD *)(*(void *)(*((void *)v11 + 4) + 96) + 4 * v18)
                                           + (unsigned __int16)v30));
                if (v30 != v32) {
                  _ZNK10OpenSubdiv6v3_1_13Far14PrimvarRefiner19interpFVarFromVertsILNS0_3Sdc10SchemeTypeE1EP16C3DSubdivCPUDataIDv2_fENSt3__16vectorIS8_NSA_9allocatorIS8_EEEEEEviRKT0_RT1_i_cold_3();
                }
                uint64_t v33 = v20[v32];
                uint64_t v34 = v22[v30];
                *(_OWORD *)(*a4 + 16 * v34) = v15;
                if (!v17 && (*(unsigned char *)(v31 + v30) & 8) != 0)
                {
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v51, v14, v32, v52);
                  if ((*(unsigned char *)(v47 + v32) & 0x10) != 0)
                  {
                    if ((*(unsigned char *)(v47 + v32) & 0x20) != 0)
                    {
                      unsigned int v39 = v32 == 0;
                      uint64_t v37 = v11;
                      int v38 = v14;
                    }
                    else
                    {
                      uint64_t v37 = v11;
                      int v38 = v14;
                      unsigned int v39 = v32;
                    }
                    Fractionalfloat Weight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v37, v38, v39, v18);
                    float v41 = 1.0 - FractionalWeight;
                    float v36 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                    float v35 = v41 * 0.125;
                  }
                  else
                  {
                    float v35 = 0.125;
                    float v36 = 0.75;
                  }
                  uint64_t v16 = a3;
                  uint64_t v31 = v46;
                  BOOL v17 = v44;
                  long long v15 = 0uLL;
                  uint64_t v29 = v48;
                  uint64_t v42 = v52[1];
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v52[0]), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v42), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v33), v36);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v34) = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v33), *(float32x4_t *)(*a4 + 16 * v34));
                }
                ++v30;
              }
              while (v29 != v30);
            }
            goto LABEL_19;
          }
          int v27 = *v20;
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          uint64_t v26 = (float32x4_t *)(*a4 + 16 * v23);
        }
        *uint64_t v26 = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v50 + 8))
      {
        uint64_t v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v62);
}