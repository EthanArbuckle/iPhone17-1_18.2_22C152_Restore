uint64_t __AppendIndexes(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t PrimitiveCount;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t k;
  uint64_t m;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  uint64_t j;
  uint64_t v22;
  uint64_t n;
  uint64_t ii;
  int v26;

  v26 = 0;
  PrimitiveCount = C3DMeshElementGetPrimitiveCount(a2);
  if (C3DMeshElementGetType(a2) == 2) {
    v9 = 2;
  }
  else {
    v9 = 3;
  }
  C3DMeshElementGetIndexes(a2, &v26);
  if (C3DMeshElementGetType(a2) == 1)
  {
    if (a4 == 2)
    {
      if (PrimitiveCount < -1)
      {
        v16 = 0;
      }
      else
      {
        v15 = 0;
        v16 = PrimitiveCount + 2;
        do
        {
          *(_WORD *)(a1 + 2 * v15) = C3DMeshElementGetIndex(a2, 3 * (v15 / 3), v15 % 3, 0) + a3;
          ++v15;
        }
        while (v16 != v15);
      }
      return a1 + 2 * v16;
    }
    else if (a4 == 1)
    {
      if (PrimitiveCount < -1)
      {
        v11 = 0;
      }
      else
      {
        v10 = 0;
        v11 = PrimitiveCount + 2;
        do
        {
          *(unsigned char *)(a1 + v10) = C3DMeshElementGetIndex(a2, 3 * (v10 / 3), v10 % 3, 0) + a3;
          ++v10;
        }
        while (v11 != v10);
      }
      return a1 + v11;
    }
    else
    {
      if (PrimitiveCount < -1)
      {
        v18 = 0;
      }
      else
      {
        v17 = 0;
        v18 = PrimitiveCount + 2;
        do
        {
          *(_DWORD *)(a1 + 4 * v17) = C3DMeshElementGetIndex(a2, 3 * (v17 / 3), v17 % 3, 0) + a3;
          ++v17;
        }
        while (v18 != v17);
      }
      return a1 + 4 * v18;
    }
  }
  else if (a4 == 1)
  {
    if (PrimitiveCount < 1)
    {
      v19 = 0;
    }
    else
    {
      v19 = 0;
      for (i = 0; i != PrimitiveCount; ++i)
      {
        for (j = 0; j != v9; ++j)
          *(unsigned char *)(a1 + v19 + j) = C3DMeshElementGetIndex(a2, i, j, 0) + a3;
        v19 += j;
      }
    }
    return a1 + v19;
  }
  else if (a4 == 2)
  {
    if (PrimitiveCount < 1)
    {
      v12 = 0;
    }
    else
    {
      v12 = 0;
      for (k = 0; k != PrimitiveCount; ++k)
      {
        for (m = 0; m != v9; ++m)
          *(_WORD *)(a1 + 2 * v12 + 2 * m) = C3DMeshElementGetIndex(a2, k, m, 0) + a3;
        v12 += m;
      }
    }
    return a1 + 2 * v12;
  }
  else
  {
    if (PrimitiveCount < 1)
    {
      v22 = 0;
    }
    else
    {
      v22 = 0;
      for (n = 0; n != PrimitiveCount; ++n)
      {
        for (ii = 0; ii != v9; ++ii)
          *(_DWORD *)(a1 + 4 * v22 + 4 * ii) = C3DMeshElementGetIndex(a2, n, ii, 0) + a3;
        v22 += ii;
      }
    }
    return a1 + 4 * v22;
  }
}

void _unifyNormals(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  CFArrayRef ElementsCount = C3DMeshGetElementsCount(a1);
  unsigned int Count = C3DMeshSourceGetCount(a3);
  uint64_t Content = C3DMeshSourceGetContent(a2);
  uint64_t v46 = v12;
  uint64_t v13 = C3DMeshSourceGetContent(a3);
  uint64_t v47 = v17;
  if (a5) {
    WeldRemappingTable = C3DMeshSourceCreateWeldRemappingTable(a2);
  }
  else {
    WeldRemappingTable = 0;
  }
  int v19 = BYTE4(v47);
  int v20 = BYTE5(v47);
  if (Count)
  {
    unsigned int v21 = 0;
    uint64_t v22 = Count;
    do
    {
      C3DConvertFloatingTypeFromFloat4(BYTE4(v47), v13 + v21, (float32x4_t)0);
      v21 += BYTE5(v47);
      --v22;
    }
    while (v22);
  }
  if ((uint64_t)ElementsCount >= 1)
  {
    for (CFIndex i = 0; (const __CFArray *)i != ElementsCount; ++i)
    {
      ElementAtIndex = C3DMeshGetElementAtIndex(a1, i, a4);
      if (a4) {
        uint64_t ChannelForSourceWithSemanticAtIndex = 0;
      }
      else {
        uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
      }
      uint64_t v58 = 0;
      long long v56 = 0u;
      __n128 v57 = 0u;
      long long v55 = 0u;
      C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v55);
      if ((BYTE10(v56) & 0xFA) != 0)
      {
        v26 = scn_default_log();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_20B249000, v26, OS_LOG_TYPE_DEFAULT, "Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons", buf, 2u);
        }
      }
      else
      {
        v53[0] = MEMORY[0x263EF8330];
        v53[1] = 3221225472;
        v53[2] = ___unifyNormals_block_invoke;
        v53[3] = &__block_descriptor_76_e19_v32__0I8_I12I20_B24l;
        int v54 = v46 - 1;
        v53[4] = Content;
        v53[5] = v46;
        v53[6] = WeldRemappingTable;
        v53[7] = v13;
        v53[8] = v47;
        *(_OWORD *)buf = v55;
        long long v50 = v56;
        __n128 v51 = v57;
        uint64_t v52 = v58;
        C3DIndicesContentEnumeratePrimitives((uint64_t *)buf, (uint64_t)v53, v57);
      }
    }
  }
  if (WeldRemappingTable && Count)
  {
    unsigned int v27 = 0;
    for (uint64_t j = 0; j != Count; ++j)
    {
      uint64_t v29 = WeldRemappingTable[j];
      if (j != v29)
      {
        *(double *)v30.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v47), (float *)(v13 + v29 * BYTE5(v47)), v14, v15, v16);
        C3DConvertFloatingTypeFromFloat4(BYTE4(v47), v13 + v27, v30);
      }
      v27 += BYTE5(v47);
    }
  }
  if (Count)
  {
    unsigned int v31 = 0;
    uint64_t v32 = Count;
    __asm { FMOV            V0.4S, #1.0 }
    int8x16_t v48 = (int8x16_t)_Q0;
    do
    {
      *(double *)v38.i64 = C3DConvertFloatingTypeToFloat4(v19, (float *)(v13 + v31), _Q0, v15, v16);
      float32x4_t v39 = vmulq_f32(v38, v38);
      v39.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).u64[0];
      float32x4_t v40 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0);
      float32x4_t v41 = vrsqrteq_f32(v40);
      float32x4_t v42 = vmulq_f32(v41, vrsqrtsq_f32(v40, vmulq_f32(v41, v41)));
      int32x4_t v43 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v39.f32[0] != 0.0)), 0x1FuLL));
      v43.i32[3] = 0;
      float32x4_t v44 = vmulq_f32(v38, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vmulq_f32(v42, vrsqrtsq_f32(v40, vmulq_f32(v42, v42))), v48));
      v44.i32[3] = v38.i32[3];
      C3DConvertFloatingTypeFromFloat4(v19, v13 + v31, v44);
      v31 += v20;
      --v32;
    }
    while (v32);
  }
  free(WeldRemappingTable);
}

void ___unifyNormalsOptimized_block_invoke(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, int32x4_t a5, uint64_t a6, unsigned int *a7, unsigned int a8)
{
  v9 = a7;
  if (a8 <= 2)
  {
    v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      ___unifyNormalsOptimized_block_invoke_cold_1(v34, v35, v36, v37, v38, v39, v40, v41);
      if (!a8) {
        return;
      }
    }
    else if (!a8)
    {
      return;
    }
  }
  else if (a8 == 3)
  {
    unsigned int v11 = *(_DWORD *)(a1 + 72);
    unsigned int v12 = *a7;
    unsigned int v13 = a7[1];
    if (v11 < *a7) {
      unsigned int v12 = *(_DWORD *)(a1 + 72);
    }
    if (v11 < v13) {
      unsigned int v13 = *(_DWORD *)(a1 + 72);
    }
    if (v11 >= a7[2]) {
      unsigned int v11 = a7[2];
    }
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = *(unsigned __int8 *)(a1 + 45);
    uint64_t v16 = v14 + v12 * v15;
    a2.i64[0] = *(void *)v16;
    a2.i32[2] = *(_DWORD *)(v16 + 8);
    uint64_t v17 = v14 + v13 * v15;
    a3.i64[0] = *(void *)v17;
    a3.i32[2] = *(_DWORD *)(v17 + 8);
    uint64_t v18 = v14 + v11 * v15;
    a4.i64[0] = *(void *)v18;
    a4.i32[2] = *(_DWORD *)(v18 + 8);
    float32x4_t v19 = vsubq_f32(a3, a2);
    float32x4_t v20 = vsubq_f32(a4, a2);
    int32x4_t v21 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), vnegq_f32(v19)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL));
    float32x4_t v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL);
    v22.i32[3] = 0;
    int8x16_t v23 = (int8x16_t)vmulq_f32(v22, v22);
    *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
    float32x4_t v24 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1)), 0);
    float32x4_t v25 = vrsqrteq_f32(v24);
    float32x4_t v26 = vmulq_f32(v25, vrsqrtsq_f32(v24, vmulq_f32(v25, v25)));
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v32 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v24), _Q3, (int8x16_t)vmulq_f32(v26, vrsqrtsq_f32(v24, vmulq_f32(v26, v26))));
    float32x4_t v33 = vmulq_f32(v22, v32);
    goto LABEL_26;
  }
  float32x4_t v42 = 0uLL;
  uint64_t v43 = a8;
  float32x4_t v44 = v9;
  do
  {
    unsigned int v46 = *v44++;
    unsigned int v45 = v46;
    if (*(_DWORD *)(a1 + 72) < v46) {
      unsigned int v45 = *(_DWORD *)(a1 + 72);
    }
    uint64_t v47 = *(void *)(a1 + 32) + v45 * *(unsigned __int8 *)(a1 + 45);
    a3.i64[0] = *(void *)v47;
    a3.i32[2] = *(_DWORD *)(v47 + 8);
    float32x4_t v42 = vaddq_f32(v42, a3);
    --v43;
  }
  while (v43);
  uint64_t v48 = 0;
  a3.f32[0] = (float)a8;
  float32x4_t v49 = vdivq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.f32, 0));
  unsigned int v50 = *(_DWORD *)(a1 + 72);
  uint64_t v51 = *(void *)(a1 + 32);
  int v52 = *(unsigned __int8 *)(a1 + 45);
  float32x4_t v53 = 0uLL;
  do
  {
    unsigned int v54 = v9[v48];
    if (v50 < v54) {
      unsigned int v54 = *(_DWORD *)(a1 + 72);
    }
    _ZF = a8 - 1 == v48;
    uint64_t v55 = v48 + 1;
    uint64_t v56 = (v48 + 1);
    if (_ZF) {
      uint64_t v56 = 0;
    }
    unsigned int v57 = v9[v56];
    if (v50 < v57) {
      unsigned int v57 = *(_DWORD *)(a1 + 72);
    }
    uint64_t v58 = v51 + v54 * v52;
    a4.i64[0] = *(void *)v58;
    a4.i32[2] = *(_DWORD *)(v58 + 8);
    uint64_t v59 = v51 + v57 * v52;
    a5.i64[0] = *(void *)v59;
    a5.i32[2] = *(_DWORD *)(v59 + 8);
    float32x4_t v60 = vsubq_f32(a4, v49);
    float32x4_t v61 = vsubq_f32((float32x4_t)a5, v49);
    int32x4_t v62 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v61, (int32x4_t)v61), (int8x16_t)v61, 0xCuLL), vnegq_f32(v60)), v61, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v60, (int32x4_t)v60), (int8x16_t)v60, 0xCuLL));
    a5 = vuzp1q_s32(v62, v62);
    a4 = vaddq_f32(v53, (float32x4_t)vextq_s8((int8x16_t)a5, (int8x16_t)v62, 0xCuLL));
    a4.i32[3] = v53.i32[3];
    uint64_t v48 = v55;
    float32x4_t v53 = a4;
  }
  while (a8 != v55);
  if (a8)
  {
    int8x16_t v63 = (int8x16_t)vmulq_f32(a4, a4);
    *(float32x2_t *)v63.i8 = vadd_f32(*(float32x2_t *)v63.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL));
    float32x4_t v64 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v63.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v63.i8, 1)), 0);
    float32x4_t v65 = vrsqrteq_f32(v64);
    float32x4_t v66 = vmulq_f32(v65, vrsqrtsq_f32(v64, vmulq_f32(v65, v65)));
    float32x4_t v32 = vmulq_f32(v66, vrsqrtsq_f32(v64, vmulq_f32(v66, v66)));
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v33 = vmulq_f32(a4, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v64), _Q3, (int8x16_t)v32));
LABEL_26:
    unsigned int v68 = *(_DWORD *)(a1 + 72);
    uint64_t v69 = *(void *)(a1 + 48);
    uint64_t v70 = *(void *)(a1 + 56);
    uint64_t v71 = a8;
    int v72 = *(unsigned __int8 *)(a1 + 69);
    do
    {
      unsigned int v74 = *v9++;
      unsigned int v73 = v74;
      if (v68 < v74) {
        unsigned int v73 = v68;
      }
      if (v69) {
        unsigned int v73 = *(_DWORD *)(v69 + 4 * v73);
      }
      uint64_t v75 = v70 + v73 * v72;
      v32.i64[0] = *(void *)v75;
      v32.i32[2] = *(_DWORD *)(v75 + 8);
      float32x4_t v32 = vaddq_f32(v33, v32);
      *(void *)uint64_t v75 = v32.i64[0];
      *(_DWORD *)(v75 + 8) = v32.i32[2];
      --v71;
    }
    while (v71);
  }
}

float32x4_t ___unifyNormals_block_invoke(uint64_t a1, float32x4_t a2, float a3, float32x4_t a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  v8 = a6;
  if (a7 <= 2)
  {
    float32x4_t v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      ___unifyNormalsOptimized_block_invoke_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
      if (a7) {
        goto LABEL_14;
      }
    }
    else if (a7)
    {
      goto LABEL_14;
    }
    return (float32x4_t)0;
  }
  if (a7 == 3)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 72);
    unsigned int v11 = *a6;
    if (v10 < *a6) {
      unsigned int v11 = *(_DWORD *)(a1 + 72);
    }
    if (v10 >= a6[1]) {
      unsigned int v12 = a6[1];
    }
    else {
      unsigned int v12 = *(_DWORD *)(a1 + 72);
    }
    if (v10 >= a6[2]) {
      unsigned int v13 = a6[2];
    }
    else {
      unsigned int v13 = *(_DWORD *)(a1 + 72);
    }
    *(double *)v14.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v11 * *(unsigned __int8 *)(a1 + 45)), a2, a3, a4.f32[0]);
    float32x4_t v73 = v14;
    *(double *)v17.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v12 * *(unsigned __int8 *)(a1 + 45)), v14, v15, v16);
    float32x4_t v71 = v17;
    *(double *)v20.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v13 * *(unsigned __int8 *)(a1 + 45)), v17, v18, v19);
    float32x4_t v21 = vsubq_f32(v71, v73);
    float32x4_t v22 = vsubq_f32(v20, v73);
    int32x4_t v23 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), vnegq_f32(v21)), v22, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL));
    float32x4_t result = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL);
    result.i32[3] = 0;
LABEL_29:
    int8x16_t v54 = (int8x16_t)vmulq_f32(result, result);
    *(float32x2_t *)v54.i8 = vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL));
    float32x4_t v55 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v54.i8, 1)), 0);
    float32x4_t v56 = vrsqrteq_f32(v55);
    float32x4_t v57 = vmulq_f32(v56, vrsqrtsq_f32(v55, vmulq_f32(v56, v56)));
    int8x16_t v58 = (int8x16_t)vmulq_f32(v57, vrsqrtsq_f32(v55, vmulq_f32(v57, v57)));
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v64 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v55), _Q3, v58);
    float32x4_t result = vmulq_f32(result, v64);
    float32x4_t v76 = result;
    uint64_t v65 = a7;
    do
    {
      uint64_t v66 = *(void *)(a1 + 48);
      v67 = v8;
      if (v66) {
        v67 = (_DWORD *)(v66 + 4 * *v8);
      }
      unsigned int v68 = (float *)(*(void *)(a1 + 56) + *v67 * *(unsigned __int8 *)(a1 + 69));
      *(double *)v69.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 68), v68, result, v64.f32[0], *(float *)v58.i32);
      C3DConvertFloatingTypeFromFloat4(*(unsigned __int8 *)(a1 + 68), (uint64_t)v68, vaddq_f32(v76, v69));
      ++v8;
      --v65;
    }
    while (v65);
    return result;
  }
LABEL_14:
  float32x4_t v33 = 0uLL;
  uint64_t v34 = a7;
  uint64_t v35 = v8;
  do
  {
    float32x4_t v74 = v33;
    unsigned int v36 = *(_DWORD *)(a1 + 72);
    unsigned int v38 = *v35++;
    unsigned int v37 = v38;
    if (v36 >= v38) {
      unsigned int v36 = v37;
    }
    *(double *)a2.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v36 * *(unsigned __int8 *)(a1 + 45)), a2, v33.f32[0], a4.f32[0]);
    float32x4_t v33 = vaddq_f32(v74, a2);
    --v34;
  }
  while (v34);
  uint64_t v39 = 0;
  a2.f32[0] = (float)a7;
  float32x4_t result = vdivq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0));
  float32x4_t v70 = result;
  float32x4_t v40 = 0uLL;
  do
  {
    float32x4_t v75 = v40;
    unsigned int v41 = *(_DWORD *)(a1 + 72);
    unsigned int v42 = v8[v39];
    if (v41 < v42) {
      unsigned int v42 = *(_DWORD *)(a1 + 72);
    }
    uint64_t v43 = v39 + 1;
    if (a7 - 1 == v39) {
      uint64_t v44 = 0;
    }
    else {
      uint64_t v44 = (v39 + 1);
    }
    unsigned int v45 = v8[v44];
    if (v41 >= v45) {
      unsigned int v46 = v45;
    }
    else {
      unsigned int v46 = *(_DWORD *)(a1 + 72);
    }
    *(double *)v47.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v42 * *(unsigned __int8 *)(a1 + 45)), result, v40.f32[0], a4.f32[0]);
    float32x4_t v72 = v47;
    *(double *)v50.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(void *)(a1 + 32) + v46 * *(unsigned __int8 *)(a1 + 45)), v47, v48, v49);
    float32x4_t v51 = vsubq_f32(v72, v70);
    float32x4_t v52 = vsubq_f32(v50, v70);
    a4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), (int8x16_t)v51, 0xCuLL);
    int32x4_t v53 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v52, (int32x4_t)v52), (int8x16_t)v52, 0xCuLL), vnegq_f32(v51)), v52, a4);
    float32x4_t result = vaddq_f32(v75, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v53, v53), (int8x16_t)v53, 0xCuLL));
    result.i32[3] = v75.i32[3];
    uint64_t v39 = v43;
    float32x4_t v40 = result;
  }
  while (a7 != v43);
  if (a7) {
    goto LABEL_29;
  }
  return result;
}

C3D::RenderPass *C3D::DeferredShadowPass::DeferredShadowPass(C3D::DeferredShadowPass *this, RenderGraph *a2, C3D::Pass *a3, __C3DNode *a4, C3D::DrawNodesPass *a5)
{
  float32x4_t result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)float32x4_t result = &unk_26BF6DAC0;
  *((void *)result + 31) = a4;
  *((void *)result + 32) = a5;
  *((unsigned char *)result + 264) = 0;
  return result;
}

const char *C3D::DeferredShadowPass::name(C3D::DeferredShadowPass *this)
{
  return "DeferredShadowPass";
}

uint64_t C3D::DeferredShadowPass::setup(C3D::DeferredShadowPass *this)
{
  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0);
  *(void *)(v2 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  *(_OWORD *)(v2 + 16) = v7;
  *(_DWORD *)(v2 + 32) = v8;
  *(unsigned char *)(v2 + 64) = 1;
  *(_WORD *)(v2 + 66) |= 4u;
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 1u);
  *(void *)(v3 + 8) = "DEPTH";
  *(unsigned char *)(v3 + 64) = 2;
  uint64_t v4 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 2u);
  *(void *)(v4 + 8) = C3D::Pass::nameWithPrefixAndPointer(this, "SceneKit-spotShadowDepth-", *((void **)this + 31));
  *(unsigned char *)(v4 + 64) = 2;
  *(unsigned char *)(v4 + 24) = 0;
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0);
  *(void *)(v5 + 8) = "COLOR";
  *(unsigned char *)(v5 + 65) = 0;
  uint64_t result = C3DEngineContextGetEyeCount(*((void *)this + 2));
  if (result >= 2)
  {
    uint64_t result = C3DEngineContextGetEyeCount(*((void *)this + 2));
    *((_WORD *)this + 19) = result;
    *((unsigned char *)this + 120) = 1;
    *((unsigned char *)this + 264) = 1;
  }
  return result;
}

void C3D::DeferredShadowPass::compile(C3D::DeferredShadowPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  CFDictionaryRef Light = C3DNodeGetLight(*((void *)this + 31));
  if (Light)
  {
    uint64_t v4 = (uint64_t)Light;
    if (C3DLightSupportsShadowCascades((uint64_t)Light)) {
      ShadowCascadeunsigned int Count = C3DLightGetShadowCascadeCount(v4);
    }
    else {
      ShadowCascadeunsigned int Count = 1;
    }
    EffectiveShadowSampleunsigned int Count = C3DLightGetEffectiveShadowSampleCount(v4);
    float ShadowCascadeDebugFactor = C3DLightGetShadowCascadeDebugFactor(v4);
    int Type = C3DLightGetType(v4);
    if (-[SCNMTLRenderContext enableARMode](RenderContext)) {
      int v10 = 1;
    }
    else {
      int v10 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
    }
    BOOL v11 = Type == 3;
    unsigned int CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*((void *)this + 2));
    uint64_t v13 = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0)
                              + 28);
    uint64_t v14 = 0x2000000;
    if (!v10) {
      uint64_t v14 = 0;
    }
    unint64_t v15 = ((unint64_t)*((unsigned __int8 *)this + 264) << 24) | (v13 << 19) | v14 | (int)((4
                                                                                                * (ShadowCascadeDebugFactor > 0.0)) | (2 * v11) | (CoordinatesSystemOptions >> 3) & 1 | (8 * EffectiveShadowSampleCount) | (ShadowCascadeCount << 11));
    unint64_t v16 = 0xC6A4A7935BD1E995
        * ((*(uint64_t (**)(C3D::DeferredShadowPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v15) ^ ((0xC6A4A7935BD1E995 * v15) >> 47))));
    uint64_t v17 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v16 ^ (v16 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v16 ^ (v16 >> 47))) >> 47));
    *((void *)this + 30) = v17;
    if (!v17) {
      operator new();
    }
  }
  else
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      C3D::DeferredShadowPass::compile(v6);
    }
  }
}

void C3D::DeferredShadowPass::execute(C3D::Pass *a1, uint64_t a2)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)a2;
  CFDictionaryRef Light = C3DNodeGetLight(*((void *)a1 + 31));
  if (Light)
  {
    uint64_t v6 = (uint64_t)Light;
    simd_float4 v61 = 0u;
    simd_float4 v60 = 0u;
    simd_float4 v59 = 0u;
    simd_float4 v58 = 0u;
    memset(&v57[64], 0, 64);
    EffectiveShadowSampleunsigned int Count = C3DLightGetEffectiveShadowSampleCount((uint64_t)Light);
    if (EffectiveShadowSampleCount >= 2) {
      C3DLightComputeShadowKernel(v6, v57, EffectiveShadowSampleCount, *((void *)a1 + 2));
    }
    uint64_t Scene = C3DEngineContextGetScene(*((void *)a1 + 2));
    uint64_t LightingSystem = C3DSceneGetLightingSystem(Scene);
    int v10 = (float32x4_t *)*((void *)a1 + 31);
    char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*((void *)a1 + 2));
    C3DLightingSystemComputeShadowMatrices(LightingSystem, v10, (uint64_t)v76, 0, v75, (uint64_t)&v62, (uint64_t)v63, CoordinatesSystemOptions);
    simd_float4 v58 = v75[0];
    simd_float4 v59 = v75[1];
    simd_float4 v60 = v75[2];
    simd_float4 v61 = v75[3];
    float32x4_t v50 = v78;
    float32x4_t v53 = v77;
    uint64_t CullingContext = C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
    float32x4_t v13 = *(float32x4_t *)(CullingContext + 3088);
    float32x4_t v14 = *(float32x4_t *)(CullingContext + 3104);
    float32x4_t v15 = *(float32x4_t *)(CullingContext + 3120);
    float32x4_t v64 = vaddq_f32(*(float32x4_t *)(CullingContext + 3136), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v14, *(float32x2_t *)v50.f32, 1), v13, v50.f32[0]), v15, v50, 2));
    float32x4_t v65 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v14, *(float32x2_t *)v53.f32, 1), v13, v53.f32[0]), v15, v53, 2);
    C3DLightComputeSpotAttenuations(v6);
    long long v66 = v16;
    v63[16] = C3DLightGetShadowCascadeDebugFactor(v6);
    int8x8_t RealShadowMapSize = C3DLightGetRealShadowMapSize(v6);
    float ShadowRadius = C3DLightGetShadowRadius(v6);
    __int32 v18 = RealShadowMapSize.i32[1];
    if (*(float *)RealShadowMapSize.i32 >= *(float *)&RealShadowMapSize.i32[1]) {
      __int32 v18 = RealShadowMapSize.i32[0];
    }
    float v67 = ShadowRadius / fmaxf(*(float *)&v18, 1.0);
    uint64_t ShadowColor = C3DLightGetShadowColor(v6);
    uint64_t v69 = v20;
    uint64_t v68 = ShadowColor;
    int v21 = *(unsigned __int16 *)(a2 + 16);
    uint64_t v22 = C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
    if (v21)
    {
      simd_float4x4 v80 = __invert_f4(*(simd_float4x4 *)(v22 + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6) + 3472));
      simd_float4 v47 = v80.columns[1];
      simd_float4 v48 = v80.columns[0];
      simd_float4 v51 = v80.columns[3];
      simd_float4 v55 = v80.columns[2];
      simd_float4x4 v81 = *(simd_float4x4 *)(C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32))
                             + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6)
                             + 3088);
      simd_float4x4 v82 = __invert_f4(v81);
      simd_float4 v43 = v82.columns[1];
      simd_float4 v44 = v82.columns[0];
      simd_float4 v45 = v82.columns[3];
      simd_float4 v46 = v82.columns[2];
      int32x4_t v23 = (float32x4_t *)C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
      unint64_t v24 = 0;
      float32x4_t v25 = v23[193];
      float32x4_t v26 = v23[194];
      float32x4_t v27 = v23[195];
      float32x4_t v28 = v23[196];
      simd_float4 v70 = v44;
      simd_float4 v71 = v43;
      simd_float4 v72 = v46;
      simd_float4 v73 = v45;
      do
      {
        v74.columns[v24 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, COERCE_FLOAT(*(_OWORD *)((char *)&v70 + v24 * 4))), v26, *(float32x2_t *)&v70.f32[v24], 1), v27, *(float32x4_t *)((char *)&v70 + v24 * 4), 2), v28, *(float32x4_t *)((char *)&v70 + v24 * 4), 3);
        v24 += 4;
      }
      while (v24 != 16);
      unint64_t v29 = 0;
      float32x4_t v30 = (float32x4_t)v74.columns[0];
      float32x4_t v31 = (float32x4_t)v74.columns[1];
      float32x4_t v32 = (float32x4_t)v74.columns[2];
      float32x4_t v33 = (float32x4_t)v74.columns[3];
      simd_float4 v70 = v48;
      simd_float4 v71 = v47;
      simd_float4 v72 = v55;
      simd_float4 v73 = v51;
      do
      {
        v74.columns[v29 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(*(_OWORD *)((char *)&v70 + v29 * 4))), v31, *(float32x2_t *)&v70.f32[v29], 1), v32, *(float32x4_t *)((char *)&v70 + v29 * 4), 2), v33, *(float32x4_t *)((char *)&v70 + v29 * 4), 3);
        v29 += 4;
      }
      while (v29 != 16);
      simd_float4x4 v34 = v74;
    }
    else
    {
      simd_float4x4 v34 = __invert_f4(*(simd_float4x4 *)(v22 + 3472));
    }
    *(simd_float4x4 *)v57[64].f32 = v34;
    uint64_t v36 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((void *)a1 + 30) + 16) state];
    if (*(void *)(v4 + 3376) != v36)
    {
      *(void *)(v4 + 3376) = v36;
      [*(id *)(v4 + 3392) setRenderPipelineState:v36];
    }
    if (*((unsigned char *)a1 + 264))
    {
      __n128 ViewportAtIndex = C3DEngineContextGetViewportAtIndex(*((void *)a1 + 2), *(unsigned __int16 *)(a2 + 16));
      int8x16_t v56 = vextq_s8((int8x16_t)ViewportAtIndex, (int8x16_t)ViewportAtIndex, 8uLL);
      int32x4_t v38 = *(int32x4_t *)(*(uint64_t (**)(C3D::Pass *))(*(void *)a1 + 88))(a1);
      int32x2_t v49 = (int32x2_t)vextq_s8(v56, v56, 8uLL).u64[0];
      *(float32x2_t *)v38.i8 = vdiv_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v56.i8, v49), (float32x2_t)vdup_laneq_s32(v38, 2));
      int32x4_t v52 = v38;
      int32x4_t v39 = *(int32x4_t *)(*(uint64_t (**)(C3D::Pass *))(*(void *)a1 + 88))(a1);
      *(float32x2_t *)v39.i8 = vdiv_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v56.i8, v49), (float32x2_t)vdup_laneq_s32(v39, 3));
      v74.columns[0] = (simd_float4)vzip1q_s32(v52, v39);
      SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v4, &v74, 0x10uLL, 0);
    }
    float32x4_t v40 = C3D::Pass::inputTextureAtIndex(a1, 0);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v40, 0);
    unsigned int v41 = C3D::Pass::inputTextureAtIndex(a1, 1u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v41, 1uLL);
    unsigned int v42 = C3D::Pass::inputTextureAtIndex(a1, 2u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v42, 2uLL);
    SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v4, v57, 0x560uLL, 0);
    SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v4);
  }
  else
  {
    uint64_t v35 = scn_default_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      C3D::DeferredShadowPass::execute(v35);
    }
  }
}

void C3D::DeferredShadowPassResource::~DeferredShadowPassResource(C3D::DeferredShadowPassResource *this)
{
  *(void *)this = &unk_26BF6E550;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E550;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

BOOL c3dPhysicsField::contains(float32x4_t *a1, float32x2_t *a2)
{
  float32x4_t v3 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *a2, 1), a1[5], COERCE_FLOAT(*(_OWORD *)a2->f32)), a1[7], *(float32x4_t *)a2->f32, 2));
  if (a1[12].i8[15])
  {
    float32x4_t v4 = vdivq_f32(v3, a1[11]);
    float32x4_t v5 = vmulq_f32(v4, v4);
    float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
    float v7 = 1.0;
    if (v6 < 1.0) {
      goto LABEL_3;
    }
LABEL_8:
    int v11 = 0;
    goto LABEL_9;
  }
  uint32x4_t v12 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v3));
  v12.i32[3] = v12.i32[2];
  unsigned int v13 = vminvq_u32(v12);
  float v7 = 1.0;
  if ((v13 & 0x80000000) == 0) {
    goto LABEL_8;
  }
LABEL_3:
  float v8 = a1[12].f32[0];
  if (v8 > 0.0)
  {
    float32x4_t v9 = vmulq_f32(v3, v3);
    float v10 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0])- a1[12].f32[1];
    if (v10 >= 0.0) {
      float v7 = powf(v10, -v8);
    }
  }
  int v11 = 1;
LABEL_9:
  a1[13].f32[0] = v7 * a1[10].f32[0];
  return a1[12].u8[13] != v11;
}

void c3dPhysicsFieldLinearGravity::c3dPhysicsFieldLinearGravity(c3dPhysicsFieldLinearGravity *this)
{
  v1 = (_OWORD *)MEMORY[0x263EF89A8];
  *(void *)this = &unk_26BF6A378;
  long long v2 = v1[1];
  *((_OWORD *)this + 5) = *v1;
  *((_OWORD *)this + 6) = v2;
  long long v3 = v1[3];
  *((_OWORD *)this + 7) = v1[2];
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6BFC0;
  *((_OWORD *)this + 15) = 0u;
}

float32x4_t c3dPhysicsFieldLinearGravity::_transformHasChanged(c3dPhysicsFieldLinearGravity *this)
{
  float32x4_t result = *((float32x4_t *)this + 1);
  *((float32x4_t *)this + 16) = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*((float32x4_t *)this + 2), *(float32x2_t *)((char *)this + 240), 1), result, COERCE_FLOAT(*((_OWORD *)this + 15))), *((float32x4_t *)this + 3), *((float32x4_t *)this + 15), 2);
  return result;
}

double c3dPhysicsFieldLinearGravity::evalForce(float32x4_t *a1, double a2, double a3, float a4)
{
  *(void *)&double result = vmulq_n_f32(a1[16], a1[13].f32[0] * a4).u64[0];
  return result;
}

void c3dPhysicsFieldLinearGravity::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, __n128 a10)
{
  if (a3 < a4)
  {
    uint64_t v12 = a3;
    uint64_t v13 = a4;
    do
    {
      a10.n128_f32[0] = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v14 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)(*(void *)a2 + 16 * v12), 1), a1[5], COERCE_FLOAT(*(_OWORD *)(*(void *)a2 + 16 * v12))), a1[7], *(float32x4_t *)(*(void *)a2 + 16 * v12), 2));
      if (a1[12].i8[15])
      {
        float32x4_t v15 = vmulq_f32(v14, a1[11]);
        float32x4_t v16 = vmulq_f32(v15, v15);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v22 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v14));
        v22.i32[3] = v22.i32[2];
        if ((vminvq_u32(v22) & 0x80000000) != 0)
        {
LABEL_5:
          float v17 = a1[12].f32[0];
          if (v17 > 0.0)
          {
            float32x4_t v18 = vmulq_f32(v14, v14);
            float v19 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0])- a1[12].f32[1];
            float v20 = 1.0;
            if (v19 >= 0.0)
            {
              __n128 v25 = a10;
              float v20 = powf(v19, -v17);
              a10 = v25;
            }
            a10.n128_f32[0] = a10.n128_f32[0] * v20;
          }
          int v21 = 1;
          goto LABEL_12;
        }
      }
      int v21 = 0;
LABEL_12:
      if (a1[12].u8[13] != v21)
      {
        uint64_t v23 = *(void *)(a2 + 8);
        float32x4_t v24 = vmlaq_n_f32(*(float32x4_t *)(v23 + 16 * v12), a1[16], a10.n128_f32[0]);
        v24.i32[3] = HIDWORD(*(_OWORD *)(v23 + 16 * v12));
        *(float32x4_t *)(v23 + 16 * v12) = v24;
      }
      ++v12;
    }
    while (v13 != v12);
  }
}

uint64_t c3dPhysicsFieldLinearGravity::setGravity(_OWORD *a1, _OWORD *a2)
{
  a1[15] = *a2;
  return (*(uint64_t (**)(void))(*(void *)a1 + 40))();
}

void c3dPhysicsFieldRadialGravity::c3dPhysicsFieldRadialGravity(c3dPhysicsFieldRadialGravity *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6C000;
}

double c3dPhysicsFieldRadialGravity::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1[14]);
  float32x4_t v5 = vmulq_f32(v4, v4);
  float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  if (v6 < (float)(a1[12].f32[1] * a1[12].f32[1])) {
    float v6 = a1[12].f32[1] * a1[12].f32[1];
  }
  *(void *)&double result = vmulq_n_f32(vnegq_f32(v4), (float)(a1[13].f32[0] * a4) / (float)(v6 * sqrtf(v6))).u64[0];
  return result;
}

void c3dPhysicsFieldRadialGravity::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
      float v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v11 = vmulq_f32(v10, a1[11]);
        float32x4_t v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          float v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            float32x4_t v14 = vmulq_f32(v10, v10);
            float v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            float v16 = 1.0;
            if (v15 >= 0.0)
            {
              float32x4_t v24 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
              float v16 = powf(v15, -v13);
              float32x4_t v8 = v24;
            }
            float v9 = v9 * v16;
          }
          int v17 = 1;
          goto LABEL_12;
        }
      }
      int v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        float32x4_t v19 = vsubq_f32(v8, a1[14]);
        float32x4_t v20 = vmulq_f32(v19, v19);
        float v21 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
        if (v21 < (float)(a1[12].f32[1] * a1[12].f32[1])) {
          float v21 = a1[12].f32[1] * a1[12].f32[1];
        }
        uint64_t v22 = *(void *)(a2 + 8);
        float32x4_t v23 = vsubq_f32(*(float32x4_t *)(v22 + 16 * v6), vmulq_n_f32(v19, v9 / (float)(v21 * sqrtf(v21))));
        v23.i32[3] = HIDWORD(*(_OWORD *)(v22 + 16 * v6));
        *(float32x4_t *)(v22 + 16 * v6) = v23;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldSpring::c3dPhysicsFieldSpring(c3dPhysicsFieldSpring *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B2D8;
}

double c3dPhysicsFieldSpring::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1[14]);
  float32x4_t v5 = vmulq_f32(v4, v4);
  float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  if (v6 < (float)(a1[12].f32[1] * a1[12].f32[1])) {
    float v6 = a1[12].f32[1] * a1[12].f32[1];
  }
  *(void *)&double result = vmulq_n_f32(vnegq_f32(v4), (float)(a1[13].f32[0] * sqrtf(v6)) * a4).u64[0];
  return result;
}

void c3dPhysicsFieldSpring::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
      float v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v11 = vmulq_f32(v10, a1[11]);
        float32x4_t v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          float v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            float32x4_t v14 = vmulq_f32(v10, v10);
            float v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            float v16 = 1.0;
            if (v15 >= 0.0)
            {
              float32x4_t v24 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
              float v16 = powf(v15, -v13);
              float32x4_t v8 = v24;
            }
            float v9 = v9 * v16;
          }
          int v17 = 1;
          goto LABEL_12;
        }
      }
      int v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        float32x4_t v19 = vsubq_f32(v8, a1[14]);
        float32x4_t v20 = vmulq_f32(v19, v19);
        float v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]);
        if (v21 < a1[12].f32[1]) {
          float v21 = a1[12].f32[1];
        }
        uint64_t v22 = *(void *)(a2 + 8);
        float32x4_t v23 = vsubq_f32(*(float32x4_t *)(v22 + 16 * v6), vmulq_n_f32(v19, v9 * v21));
        v23.i32[3] = HIDWORD(*(_OWORD *)(v22 + 16 * v6));
        *(float32x4_t *)(v22 + 16 * v6) = v23;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldElectric::c3dPhysicsFieldElectric(c3dPhysicsFieldElectric *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B938;
}

double c3dPhysicsFieldElectric::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, float a5)
{
  float32x4_t v5 = vsubq_f32(a2, a1[14]);
  float32x4_t v6 = vmulq_f32(v5, v5);
  int32x2_t v7 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u64[0];
  if (*(float *)v7.i32 < (float)(a1[12].f32[1] * a1[12].f32[1])) {
    *(float *)v7.i32 = a1[12].f32[1] * a1[12].f32[1];
  }
  *(float *)v7.i32 = sqrtf(*(float *)v7.i32);
  *(void *)&double result = vmulq_n_f32(vdivq_f32(v5, (float32x4_t)vdupq_lane_s32(v7, 0)), (float)(a1[13].f32[0] * a5) / *(float *)v7.i32).u64[0];
  return result;
}

void c3dPhysicsFieldElectric::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
      float v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v11 = vmulq_f32(v10, a1[11]);
        float32x4_t v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          float v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            float32x4_t v14 = vmulq_f32(v10, v10);
            float v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            float v16 = 1.0;
            if (v15 >= 0.0)
            {
              float32x4_t v27 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
              float v16 = powf(v15, -v13);
              float32x4_t v8 = v27;
            }
            float v9 = v9 * v16;
          }
          int v17 = 1;
          goto LABEL_12;
        }
      }
      int v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        uint64_t v19 = *(void *)(a2 + 8);
        float32x4_t v20 = vsubq_f32(v8, a1[14]);
        float32x4_t v21 = vmulq_f32(v20, v20);
        float v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
        if (v22 < (float)(a1[12].f32[1] * a1[12].f32[1])) {
          float v22 = a1[12].f32[1] * a1[12].f32[1];
        }
        float v23 = v22;
        float32x2_t v24 = vrecpe_f32((float32x2_t)LODWORD(v22));
        float32x2_t v25 = vmul_f32(v24, vrecps_f32((float32x2_t)LODWORD(v23), v24));
        float32x4_t v26 = vaddq_f32(*(float32x4_t *)(v19 + 16 * v6), vmulq_n_f32(v20, (float)(*(float *)(*(void *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))* (float)(v9 * *(float *)(*(void *)(a2 + 32) + (*(_DWORD *)(a2 + 40) * v6))))* vmul_f32(v25, vrecps_f32((float32x2_t)LODWORD(v23), v25)).f32[0]));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v19 + 16 * v6));
        *(float32x4_t *)(v19 + 16 * v6) = v26;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldMagnetic::c3dPhysicsFieldMagnetic(c3dPhysicsFieldMagnetic *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B978;
  *((_OWORD *)this + 16) = xmmword_20B5CB8B0;
}

float32x4_t c3dPhysicsFieldMagnetic::_transformHasChanged(c3dPhysicsFieldMagnetic *this)
{
  float32x4_t result = *((float32x4_t *)this + 1);
  float32x4_t v2 = *((float32x4_t *)this + 2);
  float32x4_t v3 = *((float32x4_t *)this + 3);
  float32x4_t v4 = vaddq_f32(*((float32x4_t *)this + 4), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 144), 1), result, COERCE_FLOAT(*((_OWORD *)this + 9))), v3, *((float32x4_t *)this + 9), 2));
  float32x4_t v5 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 256), 1), result, COERCE_FLOAT(*((_OWORD *)this + 16))), v3, *((float32x4_t *)this + 16), 2);
  *((float32x4_t *)this + 14) = v4;
  *((float32x4_t *)this + 15) = v5;
  return result;
}

float32x4_t c3dPhysicsField::_transformHasChanged(c3dPhysicsField *this)
{
  float32x4_t result = vaddq_f32(*(float32x4_t *)&this[2].var0, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)&this[1].var0, *(float32x2_t *)&this[4].var5, 1), *(float32x4_t *)&this->var5, COERCE_FLOAT(*(_OWORD *)&this[4].var5)), *(float32x4_t *)&this[1].var5, *(float32x4_t *)&this[4].var5, 2));
  *(float32x4_t *)&this[7].var0 = result;
  return result;
}

double c3dPhysicsFieldMagnetic::evalForce(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, float a5)
{
  float32x4_t v5 = vsubq_f32(a2, *(float32x4_t *)(a1 + 224));
  int32x4_t v6 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)(a1 + 240), *(int32x4_t *)(a1 + 240)), *(int8x16_t *)(a1 + 240), 0xCuLL), vnegq_f32(a3)), *(float32x4_t *)(a1 + 240), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a3, (int32x4_t)a3), (int8x16_t)a3, 0xCuLL));
  float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  float32x4_t v8 = vmulq_f32(v5, v5);
  float v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
  if (v9 < (float)(*(float *)(a1 + 196) * *(float *)(a1 + 196))) {
    float v9 = *(float *)(a1 + 196) * *(float *)(a1 + 196);
  }
  *(void *)&double result = vmulq_n_f32(v7, (float)(*(float *)(a1 + 208) * a5) / sqrtf(v9)).u64[0];
  return result;
}

void c3dPhysicsFieldMagnetic::evalForceBatch(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
      float v9 = *(float *)(a2 + 56) * *(float *)(a1 + 160);
      float32x4_t v10 = vaddq_f32(*(float32x4_t *)(a1 + 128), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)(a1 + 96), *(float32x2_t *)v8.f32, 1), *(float32x4_t *)(a1 + 80), v8.f32[0]), *(float32x4_t *)(a1 + 112), v8, 2));
      if (*(unsigned char *)(a1 + 207))
      {
        float32x4_t v11 = vmulq_f32(v10, *(float32x4_t *)(a1 + 176));
        float32x4_t v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v18 = (uint32x4_t)vcgtq_f32(*(float32x4_t *)(a1 + 176), vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          float v13 = *(float *)(a1 + 192);
          if (v13 > 0.0)
          {
            float32x4_t v14 = vmulq_f32(v10, v10);
            float v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- *(float *)(a1 + 196);
            float v16 = 1.0;
            if (v15 >= 0.0)
            {
              float32x4_t v30 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
              float v16 = powf(v15, -v13);
              float32x4_t v8 = v30;
            }
            float v9 = v9 * v16;
          }
          int v17 = 1;
          goto LABEL_12;
        }
      }
      int v17 = 0;
LABEL_12:
      if (*(unsigned __int8 *)(a1 + 205) != v17)
      {
        uint64_t v19 = *(void *)(a2 + 8);
        float32x4_t v20 = vsubq_f32(v8, *(float32x4_t *)(a1 + 224));
        float32x4_t v21 = *(float32x4_t *)(v19 + 16 * v6);
        int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)(a1 + 240), *(int32x4_t *)(a1 + 240)), *(int8x16_t *)(a1 + 240), 0xCuLL), vnegq_f32(v21)), *(float32x4_t *)(a1 + 240), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL));
        float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL);
        float32x4_t v24 = vmulq_f32(v20, v20);
        float v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
        if (v25 < (float)(*(float *)(a1 + 196) * *(float *)(a1 + 196))) {
          float v25 = *(float *)(a1 + 196) * *(float *)(a1 + 196);
        }
        float v26 = v25;
        float32x2_t v27 = vrsqrte_f32((float32x2_t)LODWORD(v25));
        float32x2_t v28 = vmul_f32(v27, vrsqrts_f32((float32x2_t)LODWORD(v26), vmul_f32(v27, v27)));
        float32x4_t v29 = vaddq_f32(v21, vmulq_n_f32(v23, *(float *)(*(void *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))* (float)((float)(v9 * *(float *)(*(void *)(a2 + 32) + (*(_DWORD *)(a2 + 40) * v6)))* vmul_f32(v28, vrsqrts_f32((float32x2_t)LODWORD(v26), vmul_f32(v28, v28))).f32[0])));
        v29.i32[3] = HIDWORD(*(_OWORD *)(v19 + 16 * v6));
        *(float32x4_t *)(v19 + 16 * v6) = v29;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldDrag::c3dPhysicsFieldDrag(c3dPhysicsFieldDrag *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6AEB8;
}

double c3dPhysicsFieldDrag::evalForce(uint64_t a1, double a2, float32x4_t a3)
{
  *(void *)&double result = vmulq_n_f32(vnegq_f32(a3), *(float *)(a1 + 208)).u64[0];
  return result;
}

void c3dPhysicsFieldDrag::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a4;
    do
    {
      float v8 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v9 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)(*(void *)a2 + 16 * v6), 1), a1[5], COERCE_FLOAT(*(_OWORD *)(*(void *)a2 + 16 * v6))), a1[7], *(float32x4_t *)(*(void *)a2 + 16 * v6), 2));
      if (a1[12].i8[15])
      {
        float32x4_t v10 = vmulq_f32(v9, a1[11]);
        float32x4_t v11 = vmulq_f32(v10, v10);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v17 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v9));
        v17.i32[3] = v17.i32[2];
        if ((vminvq_u32(v17) & 0x80000000) != 0)
        {
LABEL_5:
          float v12 = a1[12].f32[0];
          if (v12 > 0.0)
          {
            float32x4_t v13 = vmulq_f32(v9, v9);
            float v14 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0])- a1[12].f32[1];
            float v15 = 1.0;
            if (v14 >= 0.0) {
              float v15 = powf(v14, -v12);
            }
            float v8 = v8 * v15;
          }
          int v16 = 1;
          goto LABEL_12;
        }
      }
      int v16 = 0;
LABEL_12:
      if (a1[12].u8[13] != v16)
      {
        uint64_t v18 = *(void *)(a2 + 8);
        float32x4_t v19 = vmlaq_n_f32(*(float32x4_t *)(v18 + 16 * v6), *(float32x4_t *)(v18 + 16 * v6), -(float)(v8 * *(float *)(*(void *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))));
        v19.i32[3] = HIDWORD(*(_OWORD *)(v18 + 16 * v6));
        *(float32x4_t *)(v18 + 16 * v6) = v19;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldCustom::c3dPhysicsFieldCustom(c3dPhysicsFieldCustom *this)
{
  uint64_t v1 = (_OWORD *)MEMORY[0x263EF89A8];
  *(void *)this = &unk_26BF6A378;
  long long v2 = v1[1];
  *((_OWORD *)this + 5) = *v1;
  *((_OWORD *)this + 6) = v2;
  long long v3 = v1[3];
  *((_OWORD *)this + 7) = v1[2];
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B298;
  *((void *)this + 30) = 0;
}

double c3dPhysicsFieldCustom::evalForce(uint64_t a1, __n128 a2)
{
  unsigned __int32 v2 = a2.n128_u32[1];
  uint64_t v3 = *(void *)(a1 + 240);
  if (v3) {
    (*(void (**)(__n128, float, float))(v3 + 16))(a2, a2.n128_f32[1], a2.n128_f32[2]);
  }
  a2.n128_u32[1] = v2;
  return a2.n128_f64[0];
}

void c3dPhysicsFieldCustom::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = a1[15].i64[0];
  if (v4) {
    BOOL v5 = a3 >= a4;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unsigned int v7 = a3;
    uint64_t v10 = 16 * a3;
    do
    {
      __n128 v11 = *(__n128 *)(*(void *)a2 + v10);
      float32x4_t v12 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], (float32x2_t)v11.n128_u64[0], 1), a1[5], v11.n128_f32[0]), a1[7], (float32x4_t)v11, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v13 = vmulq_f32(v12, a1[11]);
        float32x4_t v14 = vmulq_f32(v13, v13);
        unsigned int v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0] < 1.0;
      }
      else
      {
        uint32x4_t v16 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v12));
        v16.i32[3] = v16.i32[2];
        unsigned int v15 = vminvq_u32(v16) >> 31;
      }
      if (a1[12].u8[13] != v15)
      {
        float32x4_t v17 = (float32x4_t)((__n128 (*)(uint64_t, __n128, float, float, float, float, float, float, float, double))*(void *)(v4 + 16))(v4, v11, v11.n128_f32[1], v11.n128_f32[2], *(float *)(*(void *)(a2 + 8) + v10), *(float *)(*(void *)(a2 + 8) + v10 + 4), *(float *)(*(void *)(a2 + 8) + v10 + 8), 1.0 / *(float *)(*(void *)(a2 + 16) + *(_DWORD *)(a2 + 24) * v7), *(float *)(*(void *)(a2 + 32) + *(_DWORD *)(a2 + 40) * v7), *(float *)(a2 + 60));
        v17.i32[1] = v18;
        v17.i32[2] = v19;
        uint64_t v20 = *(void *)(a2 + 8);
        float32x4_t v21 = vaddq_f32(*(float32x4_t *)(v20 + v10), vmulq_n_f32(v17, *(float *)(a2 + 56)));
        v21.i32[3] = HIDWORD(*(_OWORD *)(v20 + v10));
        *(float32x4_t *)(v20 + v10) = v21;
      }
      v10 += 16;
      ++v7;
    }
    while (a4 != v7);
  }
}

void c3dPhysicsFieldVortex::c3dPhysicsFieldVortex(c3dPhysicsFieldVortex *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B318;
  *((_OWORD *)this + 15) = xmmword_20B5CB520;
}

double c3dPhysicsFieldVortex::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1[14]);
  float32x4_t v5 = vmulq_f32(v4, v4);
  float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL), vnegq_f32(a1[16])), v4, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[16], (int32x4_t)a1[16]), (int8x16_t)a1[16], 0xCuLL));
  float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL);
  float32x4_t v8 = vmulq_f32(v6, v6);
  v8.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v8)).u64[0];
  float32x4_t v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 0);
  float32x4_t v10 = vrsqrteq_f32(v9);
  float32x4_t v11 = vmulq_f32(v10, vrsqrtsq_f32(v9, vmulq_f32(v10, v10)));
  int8x16_t v12 = (int8x16_t)vmulq_f32(v11, vrsqrtsq_f32(v9, vmulq_f32(v11, v11)));
  int32x4_t v13 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v8.f32[0] != 0.0)), 0x1FuLL));
  v13.i32[3] = 0;
  __asm { FMOV            V5.4S, #1.0 }
  *(void *)&double result = vmulq_n_f32(vmulq_f32(v7, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v13), v12, _Q5)), (float)(a1[13].f32[0] * a4)* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0])).u64[0];
  return result;
}

void c3dPhysicsFieldVortex::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 < a4)
  {
    uint64_t v6 = a3;
    __asm { FMOV            V6.4S, #1.0 }
    uint64_t v12 = a4;
    int8x16_t v35 = _Q6;
    do
    {
      float32x4_t v13 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
      float v14 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v15 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v13.f32, 1), a1[5], v13.f32[0]), a1[7], v13, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v16 = vmulq_f32(v15, a1[11]);
        float32x4_t v17 = vmulq_f32(v16, v16);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0] < 1.0)goto LABEL_5; {
      }
        }
      else
      {
        uint32x4_t v23 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v15));
        v23.i32[3] = v23.i32[2];
        if ((vminvq_u32(v23) & 0x80000000) != 0)
        {
LABEL_5:
          float v18 = a1[12].f32[0];
          if (v18 > 0.0)
          {
            float32x4_t v19 = vmulq_f32(v15, v15);
            float v20 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0])- a1[12].f32[1];
            float v21 = 1.0;
            if (v20 >= 0.0)
            {
              float32x4_t v36 = *(float32x4_t *)(*(void *)a2 + 16 * v6);
              float v21 = powf(v20, -v18);
              _Q6 = v35;
              float32x4_t v13 = v36;
            }
            float v14 = v14 * v21;
          }
          int v22 = 1;
          goto LABEL_12;
        }
      }
      int v22 = 0;
LABEL_12:
      if (a1[12].u8[13] != v22)
      {
        float32x4_t v24 = vsubq_f32(v13, a1[14]);
        float32x4_t v25 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(a1[16])), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[16], (int32x4_t)a1[16]), (int8x16_t)a1[16], 0xCuLL));
        float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL);
        float32x4_t v27 = vmulq_f32(v25, v25);
        v27.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), v27)).u64[0];
        float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0);
        float32x4_t v29 = vrsqrteq_f32(v28);
        float32x4_t v30 = vmulq_f32(v29, vrsqrtsq_f32(v28, vmulq_f32(v29, v29)));
        int32x4_t v31 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v27.f32[0] != 0.0)), 0x1FuLL));
        v31.i32[3] = 0;
        float32x4_t v32 = vmulq_f32(v24, v24);
        uint64_t v33 = *(void *)(a2 + 8);
        float32x4_t v34 = vaddq_f32(*(float32x4_t *)(v33 + 16 * v6), vmulq_n_f32(vmulq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v31), (int8x16_t)vmulq_f32(v30, vrsqrtsq_f32(v28, vmulq_f32(v30, v30))), _Q6)), v14* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0])));
        v34.i32[3] = HIDWORD(*(_OWORD *)(v33 + 16 * v6));
        *(float32x4_t *)(v33 + 16 * v6) = v34;
      }
      ++v6;
    }
    while (v12 != v6);
  }
}

float32x4_t c3dPhysicsFieldVortex::_transformHasChanged(c3dPhysicsFieldVortex *this)
{
  float32x4_t result = *((float32x4_t *)this + 1);
  float32x4_t v2 = *((float32x4_t *)this + 2);
  float32x4_t v3 = *((float32x4_t *)this + 3);
  *((float32x4_t *)this + 14) = vaddq_f32(*((float32x4_t *)this + 4), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 144), 1), result, COERCE_FLOAT(*((_OWORD *)this + 9))), v3, *((float32x4_t *)this + 9), 2));
  *((float32x4_t *)this + 16) = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 240), 1), result, COERCE_FLOAT(*((_OWORD *)this + 15))), v3, *((float32x4_t *)this + 15), 2);
  return result;
}

void c3dPhysicsFieldNoise::c3dPhysicsFieldNoise(c3dPhysicsFieldNoise *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(void *)this = &unk_26BF6B040;
  *((void *)this + 30) = 1056964608;
}

double c3dPhysicsFieldNoise::evalForce(float *a1, float32x4_t a2, double a3, double a4, double a5, float a6)
{
  float v7 = a1[60];
  float v8 = (float)(1.25 / (float)(v7 + 0.083333)) + -1.0;
  BOOL v9 = v7 <= 0.0;
  float v10 = 14.0;
  if (!v9) {
    float v10 = v8;
  }
  float v11 = a1[61] * a6;
  uint64_t v16 = 0;
  __int32 v15 = 0;
  float v12 = srdnoise3((float *)&v16 + 1, (float *)&v16, (float *)&v15, v10 * a2.f32[0], vmuls_lane_f32(v10, *(float32x2_t *)a2.f32, 1), vmuls_lane_f32(v10, a2, 2), v11);
  v13.i64[0] = __PAIR64__(v16, HIDWORD(v16));
  v13.i32[2] = v15;
  *(void *)&double result = vmulq_n_f32(vmulq_n_f32(v13, v12), a1[52]).u64[0];
  return result;
}

void c3dPhysicsFieldNoise::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  float v4 = a1[15].f32[0];
  if (v4 <= 0.0) {
    float v5 = 14.0;
  }
  else {
    float v5 = (float)(1.25 / (float)(v4 + 0.083333)) + -1.0;
  }
  unsigned int v6 = a4 - a3;
  if (a4 > a3)
  {
    float v9 = a1[15].f32[1] * *(float *)(a2 + 60);
    uint64_t v10 = a3;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(*(void *)a2 + 16 * v10);
      float v12 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v13 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v11.f32, 1), a1[5], v11.f32[0]), a1[7], v11, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v14 = vmulq_f32(v13, a1[11]);
        float32x4_t v15 = vmulq_f32(v14, v14);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0] < 1.0)goto LABEL_8; {
      }
        }
      else
      {
        uint32x4_t v21 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v13));
        v21.i32[3] = v21.i32[2];
        if ((vminvq_u32(v21) & 0x80000000) != 0)
        {
LABEL_8:
          float v16 = a1[12].f32[0];
          if (v16 > 0.0)
          {
            float32x4_t v17 = vmulq_f32(v13, v13);
            float v18 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0])- a1[12].f32[1];
            float v19 = 1.0;
            if (v18 >= 0.0)
            {
              float32x4_t v27 = *(float32x4_t *)(*(void *)a2 + 16 * v10);
              float v19 = powf(v18, -v16);
              float32x4_t v11 = v27;
            }
            float v12 = v12 * v19;
          }
          int v20 = 1;
          goto LABEL_15;
        }
      }
      int v20 = 0;
LABEL_15:
      if (a1[12].u8[13] != v20)
      {
        float v22 = *(float *)(*(void *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v10));
        uint64_t v29 = 0;
        __int32 v28 = 0;
        float v23 = srdnoise3((float *)&v29 + 1, (float *)&v29, (float *)&v28, v5 * v11.f32[0], vmuls_lane_f32(v5, *(float32x2_t *)v11.f32, 1), vmuls_lane_f32(v5, v11, 2), v9);
        v24.i64[0] = __PAIR64__(v29, HIDWORD(v29));
        v24.i32[2] = v28;
        uint64_t v25 = *(void *)(a2 + 8);
        float32x4_t v26 = vmlaq_n_f32(*(float32x4_t *)(v25 + 16 * v10), v24, v22 * (float)(v12 * v23));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v25 + 16 * v10));
        *(float32x4_t *)(v25 + 16 * v10) = v26;
      }
      ++v10;
      --v6;
    }
    while (v6);
  }
}

void c3dPhysicsFieldTurbulence::c3dPhysicsFieldTurbulence(c3dPhysicsFieldTurbulence *this)
{
  *(void *)this = &unk_26BF6A378;
  uint64_t v1 = MEMORY[0x263EF89A8];
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x263EF89A8];
  *((_OWORD *)this + 6) = v2;
  long long v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((void *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *((void *)this + 30) = 1056964608;
  *(void *)this = &unk_26BF6BD18;
}

double c3dPhysicsFieldTurbulence::evalForce(float *a1, float32x4_t a2, float32x4_t a3, double a4, double a5, float a6)
{
  float v9 = *(float *)&a4;
  *(double *)v6.i64 = c3dPhysicsFieldNoise::evalForce(a1, a2, *(double *)a3.i64, a4, a5, a6);
  float32x4_t v7 = vmulq_f32(a3, a3);
  *(void *)&double result = vmulq_n_f32(vmulq_n_f32(v6, v9), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0])).u64[0];
  return result;
}

void c3dPhysicsFieldTurbulence::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  float v4 = a1[15].f32[0];
  if (v4 <= 0.0) {
    float v5 = 14.0;
  }
  else {
    float v5 = (float)(1.25 / (float)(v4 + 0.083333)) + -1.0;
  }
  unsigned int v6 = a4 - a3;
  if (a4 > a3)
  {
    float v9 = a1[15].f32[1] * *(float *)(a2 + 60);
    uint64_t v10 = 16 * a3;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(*(void *)a2 + v10);
      float v12 = *(float *)(a2 + 56) * a1[10].f32[0];
      float32x4_t v13 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v11.f32, 1), a1[5], v11.f32[0]), a1[7], v11, 2));
      if (a1[12].i8[15])
      {
        float32x4_t v14 = vmulq_f32(v13, a1[11]);
        float32x4_t v15 = vmulq_f32(v14, v14);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0] < 1.0)goto LABEL_8; {
      }
        }
      else
      {
        uint32x4_t v21 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v13));
        v21.i32[3] = v21.i32[2];
        if ((vminvq_u32(v21) & 0x80000000) != 0)
        {
LABEL_8:
          float v16 = a1[12].f32[0];
          if (v16 > 0.0)
          {
            float32x4_t v17 = vmulq_f32(v13, v13);
            float v18 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0])- a1[12].f32[1];
            float v19 = 1.0;
            if (v18 >= 0.0)
            {
              float32x4_t v27 = *(float32x4_t *)(*(void *)a2 + v10);
              float v19 = powf(v18, -v16);
              float32x4_t v11 = v27;
            }
            float v12 = v12 * v19;
          }
          int v20 = 1;
          goto LABEL_15;
        }
      }
      int v20 = 0;
LABEL_15:
      if (a1[12].u8[13] != v20)
      {
        float32x4_t v28 = *(float32x4_t *)(*(void *)(a2 + 8) + v10);
        uint64_t v30 = 0;
        __int32 v29 = 0;
        float v22 = srdnoise3((float *)&v30 + 1, (float *)&v30, (float *)&v29, v5 * v11.f32[0], vmuls_lane_f32(v5, *(float32x2_t *)v11.f32, 1), vmuls_lane_f32(v5, v11, 2), v9);
        v23.i64[0] = __PAIR64__(v30, HIDWORD(v30));
        v23.i32[2] = v29;
        float32x4_t v24 = vmulq_f32(v28, v28);
        uint64_t v25 = *(void *)(a2 + 8);
        float32x4_t v26 = vmlaq_n_f32(*(float32x4_t *)(v25 + v10), v23, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0])* (float)(v12 * v22));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v25 + v10));
        *(float32x4_t *)(v25 + v10) = v26;
      }
      v10 += 16;
      --v6;
    }
    while (v6);
  }
}

void c3dAether::c3dAether(c3dAether *this)
{
  this->_lastOverrideIndex = 0;
  *(_OWORD *)&this->_fields.__end_cap_.__value_ = 0u;
  *(_OWORD *)&this->_activeFields.__end_ = 0u;
  *(_OWORD *)&this->_fields.__begin_ = 0u;
}

void c3dAether::~c3dAether(c3dAether *this)
{
  begin = this->_fields.__begin_;
  end = this->_fields.__end_;
  while (begin != end)
  {
    if (*begin)
    {
      (*((void (**)(c3dPhysicsField *))(*begin)->var0 + 1))(*begin);
      end = this->_fields.__end_;
    }
    ++begin;
  }
  float v4 = this->_activeFields.__begin_;
  if (v4)
  {
    this->_activeFields.__end_ = v4;
    operator delete(v4);
  }
  float v5 = this->_fields.__begin_;
  if (this->_fields.__begin_)
  {
    this->_fields.__end_ = v5;
    operator delete(v5);
  }
}

void c3dAether::evalForce(uint64_t a1, int a2, __n128 a3, __n128 a4, float a5, float a6, float a7)
{
  __n128 v26 = a3;
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v12 = 0;
    while (1)
    {
      float32x4_t v13 = *(float32x4_t **)(*(void *)(a1 + 24) + 8 * v12);
      if (c3dPhysicsField::contains(v13, (float32x2_t *)&v26) && (v13[12].i32[2] & a2) != 0) {
        break;
      }
      if (++v12 >= (unint64_t)*(unsigned int *)(a1 + 48)) {
        goto LABEL_8;
      }
    }
    float v22 = *(void (**)(float32x4_t *, __n128, __n128, __n128, __n128, __n128))(v13->i64[0] + 16);
    v14.n128_f32[0] = a5;
    v15.n128_f32[0] = a6;
    v16.n128_f32[0] = a7;
    v22(v13, a3, a4, v14, v15, v16);
  }
  else
  {
    LODWORD(v12) = 0;
LABEL_8:
    uint64_t v17 = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    int v18 = v17 - v12;
    if (v17 > v12)
    {
      uint64_t v19 = 8 * v12;
      float32x4_t v25 = 0uLL;
      do
      {
        int v20 = *(float32x4_t **)(*(void *)(a1 + 24) + v19);
        if (c3dPhysicsField::contains(v20, (float32x2_t *)&v26) && (v20[12].i32[2] & a2) != 0)
        {
          *(double *)v21.i64 = (*(double (**)(float32x4_t *, __n128, __n128, float, float, float))(v20->i64[0] + 16))(v20, a3, a4, a5, a6, a7);
          float32x4_t v25 = vaddq_f32(v25, v21);
        }
        v19 += 8;
        --v18;
      }
      while (v18);
    }
  }
}

void c3dAether::evalForcesBatch(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 48))
  {
    int v8 = a4 - a3;
    if (a4 > a3)
    {
      uint64_t v9 = a3;
      do
      {
        float v30 = *(float *)(a2[1].i64[0] + (a2[1].i32[2] * v9));
        float32x2_t v10 = vrecpe_f32((float32x2_t)LODWORD(v30));
        float32x2_t v11 = vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(v30), v10));
        c3dAether::evalForce(a1, a2[3].i64[0], *(__n128 *)(a2->i64[0] + 16 * v9), *(__n128 *)(a2->i64[1] + 16 * v9), vmul_f32(v11, vrecps_f32((float32x2_t)LODWORD(v30), v11)).f32[0], *(float *)(a2[2].i64[0] + (a2[2].i32[2] * v9)), a2[3].f32[3]);
        uint64_t v12 = a2->i64[1];
        float32x4_t v14 = vmlaq_n_f32(*(float32x4_t *)(v12 + 16 * v9), v13, v30 * a2[3].f32[2]);
        v14.i32[3] = HIDWORD(*(_OWORD *)(v12 + 16 * v9));
        *(float32x4_t *)(v12 + 16 * v9++) = v14;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    __n128 v16 = *(uint64_t **)(a1 + 24);
    __n128 v15 = *(uint64_t **)(a1 + 32);
    if (v16 != v15)
    {
      float32x4_t v17 = 0uLL;
      float v18 = 1.0;
      do
      {
        uint64_t v19 = *v16;
        if ((a2[3].i64[0] & *(unsigned int *)(*v16 + 200)) != 0)
        {
          int32x4_t v20 = *(int32x4_t *)(v19 + 176);
          v20.i32[3] = 0;
          float32x4_t v21 = *(float32x4_t *)(v19 + 16);
          float32x4_t v22 = *(float32x4_t *)(v19 + 32);
          float32x4_t v23 = *(float32x4_t *)(v19 + 48);
          float32x4_t v24 = vaddq_f32(*(float32x4_t *)(v19 + 64), vmlaq_f32(vmlaq_f32(vmulq_f32(v22, v17), v17, v21), v17, v23));
          float32x4_t v25 = (float32x4_t)v20;
          v25.i32[1] = *(_OWORD *)(v19 + 176);
          v25.i32[2] = v25.i32[1];
          v24.f32[3] = v18;
          uint32x4_t v26 = (uint32x4_t)vcgeq_f32(vaddq_f32(a2[5], vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v21, v25)), vabsq_f32(vmulq_f32(v22, (float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v20.i8, 1), v20)))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32(v20, v20), v20), v23)))), vabdq_f32(a2[4], v24));
          v26.i32[3] = v26.i32[2];
          if ((vminvq_u32(v26) & 0x80000000) != 0)
          {
            float32x4_t v27 = a2[1];
            v31[0] = *a2;
            v31[1] = v27;
            float32x4_t v28 = a2[5];
            v31[4] = a2[4];
            v31[5] = v28;
            float32x4_t v29 = a2[3];
            v31[2] = a2[2];
            v31[3] = v29;
            (*(void (**)(uint64_t, _OWORD *, uint64_t, uint64_t))(*(void *)v19 + 24))(v19, v31, a3, a4);
            float v18 = 1.0;
            float32x4_t v17 = 0uLL;
            __n128 v15 = *(uint64_t **)(a1 + 32);
          }
        }
        ++v16;
      }
      while (v16 != v15);
    }
  }
}

void c3dAether::fieldsModeHaveChanged(c3dAether *this)
{
  begin = this->_activeFields.__begin_;
  this->_activeFields.__end_ = begin;
  float v4 = this->_fields.__begin_;
  end = this->_fields.__end_;
  if (this->_fields.__begin_ == end)
  {
    this->_lastOverrideIndex = 0;
  }
  else
  {
    p_end_cap = &this->_activeFields.__end_cap_;
    do
    {
      unsigned int v6 = *v4;
      if (LOBYTE((*v4)[6].var4))
      {
        if (begin >= p_end_cap->__value_)
        {
          float32x4_t v7 = this->_activeFields.__begin_;
          uint64_t v8 = begin - v7;
          if ((unint64_t)(v8 + 1) >> 61) {
            abort();
          }
          uint64_t v9 = (char *)p_end_cap->__value_ - (char *)v7;
          uint64_t v10 = v9 >> 2;
          if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
            uint64_t v10 = v8 + 1;
          }
          if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v11 = v10;
          }
          if (v11)
          {
            uint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)&this->_activeFields.__end_cap_, v11);
            unsigned int v6 = *v4;
          }
          else
          {
            uint64_t v12 = 0;
          }
          float32x4_t v13 = (c3dPhysicsField **)&v12[8 * v8];
          *float32x4_t v13 = v6;
          begin = v13 + 1;
          __n128 v15 = this->_activeFields.__begin_;
          float32x4_t v14 = this->_activeFields.__end_;
          if (v14 != v15)
          {
            do
            {
              __n128 v16 = *--v14;
              *--float32x4_t v13 = v16;
            }
            while (v14 != v15);
            float32x4_t v14 = this->_activeFields.__begin_;
          }
          this->_activeFields.__begin_ = v13;
          this->_activeFields.__end_ = begin;
          this->_activeFields.__end_cap_.__value_ = (c3dPhysicsField **)&v12[8 * v11];
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *begin++ = v6;
        }
        this->_activeFields.__end_ = begin;
        end = this->_fields.__end_;
      }
      ++v4;
    }
    while (v4 != end);
    float32x4_t v17 = this->_activeFields.__begin_;
    this->_lastOverrideIndex = 0;
    if (v17 != begin)
    {
      int v18 = 0;
      int v19 = 0;
      do
      {
        if (BYTE2((*v17)[6].var4))
        {
          if (v19 != v18)
          {
            int32x4_t v20 = this->_activeFields.__begin_;
            float32x4_t v21 = v20[v19];
            v20[v19] = v20[v18];
            v20[v18] = v21;
            begin = this->_activeFields.__end_;
          }
          this->_lastOverrideIndex = ++v18;
        }
        ++v17;
        ++v19;
      }
      while (v17 != begin);
    }
  }
}

void c3dAether::addField(c3dAether *this, c3dPhysicsField *a2)
{
  value = this->_fields.__end_cap_.__value_;
  p_end_cap = &this->_fields.__end_cap_;
  float v5 = value;
  float32x4_t v7 = p_end_cap[-1].__value_;
  if (v7 >= value)
  {
    uint64_t v9 = v7 - this->_fields.__begin_;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = (char *)v5 - (char *)this->_fields.__begin_;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      float32x4_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)p_end_cap, v12);
    }
    else {
      float32x4_t v13 = 0;
    }
    float32x4_t v14 = (c3dPhysicsField **)&v13[8 * v9];
    __n128 v15 = (c3dPhysicsField **)&v13[8 * v12];
    *float32x4_t v14 = a2;
    uint64_t v8 = v14 + 1;
    begin = this->_fields.__begin_;
    end = this->_fields.__end_;
    if (end != this->_fields.__begin_)
    {
      do
      {
        int v18 = *--end;
        *--float32x4_t v14 = v18;
      }
      while (end != begin);
      end = this->_fields.__begin_;
    }
    this->_fields.__begin_ = v14;
    this->_fields.__end_ = v8;
    this->_fields.__end_cap_.__value_ = v15;
    if (end) {
      operator delete(end);
    }
  }
  else
  {
    *float32x4_t v7 = a2;
    uint64_t v8 = v7 + 1;
  }
  this->_fields.__end_ = v8;

  c3dAether::fieldsModeHaveChanged(this);
}

void c3dAether::removeField(c3dAether *this, c3dPhysicsField *a2)
{
  begin = this->_fields.__begin_;
  end = this->_fields.__end_;
  if (this->_fields.__begin_ != end)
  {
    uint64_t v5 = 0;
    while (begin[v5] != a2)
    {
      if (&begin[++v5] == end) {
        goto LABEL_9;
      }
    }
    unsigned int v6 = &begin[v5];
    float32x4_t v7 = &begin[v5 + 1];
    int64_t v8 = (char *)end - (char *)v7;
    if (end != v7) {
      memmove(&begin[v5], v7, (char *)end - (char *)v7);
    }
    this->_fields.__end_ = (c3dPhysicsField **)((char *)v6 + v8);
  }
LABEL_9:

  c3dAether::fieldsModeHaveChanged(this);
}

void c3dPhysicsFieldLinearGravity::~c3dPhysicsFieldLinearGravity(c3dPhysicsFieldLinearGravity *this)
{
}

uint64_t c3dPhysicsFieldLinearGravity::type(c3dPhysicsFieldLinearGravity *this)
{
  return 1;
}

void c3dPhysicsFieldRadialGravity::~c3dPhysicsFieldRadialGravity(c3dPhysicsFieldRadialGravity *this)
{
}

uint64_t c3dPhysicsFieldRadialGravity::type(c3dPhysicsFieldRadialGravity *this)
{
  return 2;
}

void c3dPhysicsFieldSpring::~c3dPhysicsFieldSpring(c3dPhysicsFieldSpring *this)
{
}

uint64_t c3dPhysicsFieldSpring::type(c3dPhysicsFieldSpring *this)
{
  return 3;
}

void c3dPhysicsFieldElectric::~c3dPhysicsFieldElectric(c3dPhysicsFieldElectric *this)
{
}

uint64_t c3dPhysicsFieldElectric::type(c3dPhysicsFieldElectric *this)
{
  return 5;
}

void c3dPhysicsFieldMagnetic::~c3dPhysicsFieldMagnetic(c3dPhysicsFieldMagnetic *this)
{
}

uint64_t c3dPhysicsFieldMagnetic::type(c3dPhysicsFieldMagnetic *this)
{
  return 4;
}

void c3dPhysicsFieldDrag::~c3dPhysicsFieldDrag(c3dPhysicsFieldDrag *this)
{
}

uint64_t c3dPhysicsFieldDrag::type(c3dPhysicsFieldDrag *this)
{
  return 6;
}

void c3dPhysicsFieldCustom::~c3dPhysicsFieldCustom(c3dPhysicsFieldCustom *this)
{
}

uint64_t c3dPhysicsFieldCustom::type(c3dPhysicsFieldCustom *this)
{
  return 10;
}

void c3dPhysicsFieldVortex::~c3dPhysicsFieldVortex(c3dPhysicsFieldVortex *this)
{
}

uint64_t c3dPhysicsFieldVortex::type(c3dPhysicsFieldVortex *this)
{
  return 7;
}

void c3dPhysicsFieldNoise::~c3dPhysicsFieldNoise(c3dPhysicsFieldNoise *this)
{
}

uint64_t c3dPhysicsFieldNoise::type(c3dPhysicsFieldNoise *this)
{
  return 8;
}

void c3dPhysicsFieldTurbulence::~c3dPhysicsFieldTurbulence(c3dPhysicsFieldTurbulence *this)
{
}

uint64_t c3dPhysicsFieldTurbulence::type(c3dPhysicsFieldTurbulence *this)
{
  return 9;
}

uint64_t SCNAudioPlayerWasRemovedFromNode(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

void sub_20B2E97A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _C3DHitTestResultCFFinalize(uint64_t a1)
{
  long long v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef _C3DHitTestResultCFCopyDebugDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t Name = *(void *)(a1 + 16);
  if (Name) {
    uint64_t Name = C3DNodeGetName(Name);
  }
  return CFStringCreateWithFormat(v2, 0, @"<C3DHitTestResult %@ %f,%f,%f>", Name, *(float *)(a1 + 96), *(float *)(a1 + 100), *(float *)(a1 + 104));
}

uint64_t __C3DHitTestResultGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DHitTestResultGetTypeID_typeID = result;
  return result;
}

uint64_t C3DHitTestResultCreate()
{
  if (C3DHitTestResultGetTypeID_onceToken != -1) {
    dispatch_once(&C3DHitTestResultGetTypeID_onceToken, &__block_literal_global_9);
  }
  CFTypeID v0 = C3DHitTestResultGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0xD0uLL);
}

uint64_t C3DHitTestResultGetNode(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

uint64_t C3DHitTestResultGetJoint(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

CFTypeRef C3DHitTestResultSetNode(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t C3DHitTestResultGetGeometryElementIndex(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

uint64_t C3DHitTestResultGetPrimitiveIndex(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

uint64_t C3DHitTestResultGetLocalPosition(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 64;
}

uint64_t C3DHitTestResultGetWorldPosition(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 96;
}

uint64_t C3DHitTestResultGetLocalNormal(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 80;
}

double C3DHitTestResultGetWorldNormal(float32x4_t *a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  f32 = a1[7].f32;
  float32x4_t v12 = a1[5];
  simd_float4x4 v14 = (simd_float4x4)vld4q_f32(f32);
  simd_float4x4 v13 = __invert_f4(v14);
  *(void *)&double result = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v13.columns[1], *(float32x2_t *)v12.f32, 1), (float32x4_t)v13.columns[0], v12.f32[0]), (float32x4_t)v13.columns[2], v12, 2).u64[0];
  return result;
}

uint64_t C3DHitTestResultGetModelTransform(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 112;
}

double C3DHitTestResultGetTextureCoordinates(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DHitTestResultGetTextureCoordinates_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 16);
  double v13 = 0.0;
  if (v12)
  {
    uint64_t Geometry = C3DNodeGetGeometry(v12);
    if (Geometry)
    {
      uint64_t Mesh = C3DGeometryGetMesh(Geometry);
      if (Mesh)
      {
        uint64_t v16 = Mesh;
        SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 3, a2, 0);
        if (SourceWithSemanticAtIndex)
        {
          uint64_t v18 = (uint64_t)SourceWithSemanticAtIndex;
          PositionSource = C3DMeshGetPositionSource(v16, 0);
          if (PositionSource)
          {
            uint64_t v20 = (uint64_t)PositionSource;
            ElementAtuint64_t Index = C3DMeshGetElementAtIndex(v16, *(void *)(a1 + 32), 0);
            if (ElementAtIndex)
            {
              uint64_t v22 = (uint64_t)ElementAtIndex;
              uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(v16, 3, a2);
              uint64_t v24 = C3DMeshGetChannelForSourceWithSemanticAtIndex(v16, 0, 0);
              uint64_t Index = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 48), ChannelForSourceWithSemanticAtIndex);
              uint64_t v26 = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 52), ChannelForSourceWithSemanticAtIndex);
              uint64_t v27 = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 56), ChannelForSourceWithSemanticAtIndex);
              uint64_t v36 = v26;
              uint64_t v37 = Index;
              uint64_t v28 = v27;
              if (v24 != ChannelForSourceWithSemanticAtIndex)
              {
                uint64_t Index = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 48), v24);
                uint64_t v26 = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 52), v24);
                uint64_t v28 = C3DMeshElementGetIndex(v22, *(void *)(a1 + 40), *(_DWORD *)(a1 + 56), v24);
              }
              *(double *)&long long v29 = C3DMeshSourceGetValueAtIndexAsVector3(v20, Index);
              v39[0] = v29;
              *(double *)&long long v30 = C3DMeshSourceGetValueAtIndexAsVector3(v20, v26);
              v39[1] = v30;
              *(double *)&long long v31 = C3DMeshSourceGetValueAtIndexAsVector3(v20, v28);
              v39[2] = v31;
              v38.i32[2] = 0;
              v38.i64[0] = 0;
              C3DTriangle3BarycentricCoordinates(v39, (long long *)(a1 + 64), &v38);
              double ValueAtIndexAsVector2 = C3DMeshSourceGetValueAtIndexAsVector2(v18, v37);
              double v33 = C3DMeshSourceGetValueAtIndexAsVector2(v18, v36);
              double v34 = C3DMeshSourceGetValueAtIndexAsVector2(v18, v27);
              return COERCE_DOUBLE(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v33, *(float32x2_t *)v38.f32, 1), *(float32x2_t *)&ValueAtIndexAsVector2, v38.f32[0]), *(float32x2_t *)&v34, v38, 2));
            }
          }
        }
      }
    }
  }
  return v13;
}

uint64_t _C3DProjectPoints(float32x4_t *a1, int a2, float32x4_t *a3, uint64_t a4, char a5, float32x4_t *a6, __n128 a7)
{
  LODWORD(v11) = a2;
  __n128 v49 = a7;
  memset(v48, 0, sizeof(v48));
  memset(&v46, 0, sizeof(v46));
  if (!a3)
  {
    double v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetProjectionInfos_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  uint64_t ProjectionInfos = C3DNodeGetProjectionInfos((uint64_t)a3, (uint64_t)v48);
  if (ProjectionInfos)
  {
    if (a4 && (v48[0] & 2) != 0) {
      C3DAdjustZRangeOfProjectionInfos((uint64_t)v48, a3, 0, a4);
    }
    Matrix = C3DProjectionInfosGetMatrix((char *)v48, (uint64_t)&v49, a5);
    float32x4_t v23 = *((float32x4_t *)Matrix + 3);
    float32x4_t v25 = *(float32x4_t *)Matrix;
    float32x4_t v24 = *((float32x4_t *)Matrix + 1);
    v47[2] = *((float32x4_t *)Matrix + 2);
    v47[3] = v23;
    v47[0] = v25;
    v47[1] = v24;
    memset(&v45, 0, sizeof(v45));
    C3DNodeComputeWorldMatrix(a3, (uint64_t)&v45);
    C3DMatrix4x4Invert(&v45, &v46);
    int8x16_t v42 = (int8x16_t)v49;
    memset(v50, 0, sizeof(v50));
    C3DMatrix4x4Mult((uint64_t)&v46, v47, v50);
    if ((int)v11 >= 1)
    {
      float64x2_t v26 = vcvtq_f64_f32(*(float32x2_t *)v42.i8);
      uint64_t v11 = v11;
      float32x2_t v43 = (float32x2_t)vextq_s8(v42, v42, 8uLL).u64[0];
      float64x2_t v44 = v26;
      float v27 = 1.0;
      __asm
      {
        FMOV            V8.2S, #1.0
        FMOV            V0.2D, #0.5
      }
      float64x2_t v41 = _Q0;
      do
      {
        float32x4_t v34 = *a1;
        v34.f32[3] = v27;
        *(double *)v35.i64 = C3DVector4MultMatrix4x4(v50, v34);
        float v27 = 1.0;
        if (v35.f32[3] == 0.0) {
          break;
        }
        float v36 = 1.0 / v35.f32[3];
        if ((float)(1.0 / v35.f32[3]) == 0.0) {
          break;
        }
        float v37 = vmuls_lane_f32(v36, v35, 2);
        *(float32x2_t *)v35.f32 = vcvt_f32_f64(vaddq_f64(vmulq_f64(vcvtq_f64_f32(vmul_f32(v43, vadd_f32(vmul_n_f32(*(float32x2_t *)v35.f32, v36), _D8))), v41), v44));
        a6->i32[2] = a6->i64[1];
        a6->i64[0] = v35.i64[0];
        if ((a5 & 8) != 0 && (v38 = C3DWasLinkedBeforeMajorOSYear2021(), v35 = *a6, float v27 = 1.0, (v38 & 1) == 0)) {
          float v39 = 1.0 - v37;
        }
        else {
          float v39 = (float)(v37 + v27) * 0.5;
        }
        a6->f32[2] = v39;
        a6->i64[0] = v35.i64[0];
        ++a6;
        ++a1;
        --v11;
      }
      while (v11);
    }
  }
  return ProjectionInfos;
}

uint64_t _C3DUnProjectPoints(uint64_t a1, int a2, float32x4_t *a3, uint64_t a4, char a5, float32x4_t *a6, __n128 a7)
{
  if (!a3)
  {
    double v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetProjectionInfos_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  memset(v29, 0, sizeof(v29));
  uint64_t result = C3DNodeGetProjectionInfos((uint64_t)a3, (uint64_t)v29);
  if (result)
  {
    if (a4 && (v29[0] & 2) != 0) {
      C3DAdjustZRangeOfProjectionInfos((uint64_t)v29, a3, 0, a4);
    }
    uint64_t result = C3DProjectionInfosUnproject((uint64_t)v29, a1, a2, a5, a6, a7);
    if (result)
    {
      WorldMatrix = C3DNodeGetWorldMatrix(a3);
      if (a2 >= 1)
      {
        float32x4_t v24 = WorldMatrix[2];
        float32x4_t v23 = WorldMatrix[3];
        uint64_t v25 = a2;
        float32x4_t v27 = *WorldMatrix;
        float32x4_t v26 = WorldMatrix[1];
        do
        {
          *a6 = vaddq_f32(v23, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v26, *(float32x2_t *)a6->f32, 1), v27, COERCE_FLOAT(*a6)), v24, *a6, 2));
          ++a6;
          --v25;
        }
        while (v25);
      }
      return 1;
    }
  }
  return result;
}

double _C3DHitTestComputeHitSegment(float32x4_t *a1, uint64_t a2, float32x4_t *a3, _OWORD *a4, __n128 a5, double a6)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (a1)
  {
    __asm { FMOV            V2.4S, #1.0 }
    *(double *)&_Q2 = a6;
    v16[0] = *(unint64_t *)&a6;
    v16[1] = _Q2;
    _C3DUnProjectPoints((uint64_t)v16, 2, a1, a2, 0, &v14, a5);
    if (a3)
    {
      a5.n128_u64[0] = v14.i64[0];
      *a3 = v14;
    }
    if (a4)
    {
      a5.n128_u64[0] = v15;
      *a4 = v15;
    }
  }
  return a5.n128_f64[0];
}

uint64_t C3DHitTestContextFillOptionsFromDictionary(uint64_t a1, const __CFDictionary *a2)
{
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)a1 = -1;
  *(unsigned char *)(a1 + 8) = 63;
  uint64_t result = C3DWasLinkedBeforeMajorOSYear2017();
  __int16 v5 = *(_WORD *)(a1 + 8);
  if (result) {
    __int16 v6 = 0;
  }
  else {
    __int16 v6 = 256;
  }
  *(unsigned char *)(a1 + 10) = 1;
  *(_WORD *)(a1 + 8) = v5 & 0xFEFF | v6 | 0x400;
  if (!a2) {
    return result;
  }
  Value = CFDictionaryGetValue(a2, @"kHitTestAllLayers");
  uint64_t v8 = (CFTypeRef *)MEMORY[0x263EFFB40];
  if (Value)
  {
    if (CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], Value)) {
      char v9 = 3;
    }
    else {
      char v9 = 1;
    }
    *(unsigned char *)(a1 + 10) = v9;
  }
  uint64_t v10 = (void *)CFDictionaryGetValue(a2, @"kHitTestLayerMask");
  if (v10)
  {
    uint64_t v11 = [v10 integerValue];
    if (v11 >= 1) {
      *(unsigned char *)(a1 + 10) = v11;
    }
  }
  uint64_t v12 = CFDictionaryGetValue(a2, @"kHitTestClipToZRange");
  if (v12) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFFD | (2 * (CFEqual(*v8, v12) != 0));
  }
  double v13 = CFDictionaryGetValue(a2, @"kHitTestBackFaceCulling");
  if (v13) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFF7 | (8 * (CFEqual(*v8, v13) != 0));
  }
  float32x4_t v14 = CFDictionaryGetValue(a2, @"kHitTestSkipTransparentNode");
  if (v14) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFEF | (16 * (CFEqual(*v8, v14) != 0));
  }
  CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kHitTestCategoryBitMask");
  if (v15)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(v15, kCFNumberLongType, &valuePtr);
    *(void *)a1 = valuePtr;
  }
  uint64_t v16 = CFDictionaryGetValue(a2, @"kHitTestSkipHiddenNode");
  if (v16) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFDF | (32 * (CFEqual(*v8, v16) != 0));
  }
  uint64_t v17 = CFDictionaryGetValue(a2, @"kHitTestIgnoreChildNodes");
  if (v17) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFFE | (CFEqual(*v8, v17) == 0);
  }
  uint64_t v18 = CFDictionaryGetValue(a2, @"kHitTestFirstFoundOnly");
  if (v18) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFF7F | ((CFEqual(*v8, v18) != 0) << 7);
  }
  uint64_t v19 = CFDictionaryGetValue(a2, @"kHitTestSortResults");
  if (v19) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFFB | (4 * (CFEqual(*v8, v19) != 0));
  }
  uint64_t v20 = (void *)CFDictionaryGetValue(a2, @"kHitTestSearchMode");
  if (v20)
  {
    uint64_t v21 = [v20 integerValue];
    switch(v21)
    {
      case 2:
        __int16 v22 = *(_WORD *)(a1 + 8) & 0xFE7F | 0x80;
        goto LABEL_36;
      case 1:
        __int16 v22 = *(_WORD *)(a1 + 8) & 0xFE7F;
        goto LABEL_36;
      case 0:
        __int16 v22 = *(_WORD *)(a1 + 8) & 0xFE7F | 0x100;
LABEL_36:
        *(_WORD *)(a1 + 8) = v22;
        break;
    }
  }
  float32x4_t v23 = CFDictionaryGetValue(a2, @"kHitTestBoundingBoxOnly");
  if (v23) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFFBF | ((CFEqual(*v8, v23) != 0) << 6);
  }
  float32x4_t v24 = CFDictionaryGetValue(a2, @"kHitTestShowDebugInfo");
  if (v24) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFDFF | ((CFEqual(*v8, v24) != 0) << 9);
  }
  uint64_t v25 = CFDictionaryGetValue(a2, @"kHitTestResultIgnoreLightArea");
  if (v25) {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0xFBFF | ((CFEqual(*v8, v25) & 1) << 10);
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(a2, @"auth");
  *(void *)(a1 + 416) = result;
  return result;
}

void __AddLocalResult(uint64_t a1, unsigned int a2, int a3, int a4, int a5, float a6, float32x4_t a7, __n128 a8)
{
  uint64_t v14 = C3DHitTestResultCreate();
  C3DHitTestResultSetNode(v14, *(CFTypeRef *)(a1 + 112));
  CFTypeRef v15 = *(CFTypeRef *)(v14 + 24);
  CFTypeRef v16 = *(CFTypeRef *)(a1 + 120);
  if (v15 != v16)
  {
    if (v15)
    {
      CFRelease(*(CFTypeRef *)(v14 + 24));
      *(void *)(v14 + 24) = 0;
      CFTypeRef v16 = *(CFTypeRef *)(a1 + 120);
    }
    if (v16) {
      CFTypeRef v16 = CFRetain(v16);
    }
    *(void *)(v14 + 24) = v16;
  }
  long long v17 = *(_OWORD *)(a1 + 128);
  long long v18 = *(_OWORD *)(a1 + 144);
  long long v19 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(v14 + 144) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v14 + 160) = v19;
  *(_OWORD *)(v14 + 112) = v17;
  *(_OWORD *)(v14 + 128) = v18;
  *(__n128 *)(v14 + 80) = a8;
  *(void *)(v14 + 32) = *(void *)(a1 + 192);
  *(void *)(v14 + 40) = a2;
  *(_DWORD *)(v14 + 48) = a3;
  *(_DWORD *)(v14 + 52) = a4;
  *(_DWORD *)(v14 + 56) = a5;
  *(float32x4_t *)(v14 + 64) = a7;
  *(float32x4_t *)(v14 + 96) = vaddq_f32(*(float32x4_t *)(a1 + 176), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)(a1 + 144), *(float32x2_t *)a7.f32, 1), *(float32x4_t *)(a1 + 128), a7.f32[0]), *(float32x4_t *)(a1 + 160), a7, 2));
  if ((*(_WORD *)(a1 + 8) & 0x100) != 0)
  {
    float v20 = a6 / *(float *)(a1 + 108);
    *(float *)(a1 + 108) = a6;
    *(float *)(a1 + 60) = v20 * *(float *)(a1 + 60);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 312), (const void *)v14);

  CFRelease((CFTypeRef)v14);
}

void __AddWorldResult(uint64_t a1, unsigned int a2, int a3, int a4, int a5, float a6, float32x4_t a7, __n128 a8)
{
  uint64_t v14 = C3DHitTestResultCreate();
  C3DHitTestResultSetNode(v14, *(CFTypeRef *)(a1 + 112));
  long long v15 = *(_OWORD *)(a1 + 128);
  long long v16 = *(_OWORD *)(a1 + 144);
  long long v17 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(v14 + 144) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v14 + 160) = v17;
  *(_OWORD *)(v14 + 112) = v15;
  *(_OWORD *)(v14 + 128) = v16;
  *(__n128 *)(v14 + 80) = a8;
  *(void *)(v14 + 32) = *(void *)(a1 + 192);
  *(void *)(v14 + 40) = a2;
  *(_DWORD *)(v14 + 48) = a3;
  *(_DWORD *)(v14 + 52) = a4;
  *(_DWORD *)(v14 + 56) = a5;
  *(float32x4_t *)(v14 + 96) = a7;
  simd_float4x4 v21 = __invert_f4(*(simd_float4x4 *)(a1 + 128));
  *(float32x4_t *)(v14 + 64) = vaddq_f32((float32x4_t)v21.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v21.columns[1], *(float32x2_t *)a7.f32, 1), (float32x4_t)v21.columns[0], a7.f32[0]), (float32x4_t)v21.columns[2], a7, 2));
  if ((*(_WORD *)(a1 + 8) & 0x100) != 0) {
    *(float *)(a1 + 60) = a6;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 312), (const void *)v14);

  CFRelease((CFTypeRef)v14);
}

uint64_t scn_plane_ray_intersection(uint64_t a1, uint64_t a2, float *a3, float32x4_t a4, float32x4_t a5, __n128 a6)
{
  v6.i64[0] = a1;
  v6.i64[1] = a2;
  int8x16_t v7 = (int8x16_t)vmulq_f32(a5, v6);
  float v8 = vaddv_f32(vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  if (v8 == 0.0) {
    return 0;
  }
  int8x16_t v9 = (int8x16_t)vmulq_f32(a4, v6);
  float v10 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL))) / v8;
  if (v10 < 0.0 || v10 > a6.n128_f32[3]) {
    return 0;
  }
  *a3 = v10;
  return 1;
}

BOOL __ProcessTriangleIndicesBatch(uint64_t a1, uint64_t a2, unsigned int a3, float32x4_t a4, float32x4_t a5, __n128 a6, uint64_t a7, char a8, uint64_t a9)
{
  if (a3)
  {
    float32x4_t v11 = a5;
    float32x4_t v12 = a4;
    uint64_t v15 = 0;
    float v16 = a6.n128_f32[3];
    BOOL v17 = 1;
    unsigned int v18 = 2;
    unint64_t v19 = a3;
    while (1)
    {
      float32x4_t v20 = *(float32x4_t *)(a1 + 16 * (v18 - 2));
      float32x4_t v21 = *(float32x4_t *)(a1 + 16 * (v18 - 1));
      float32x4_t v22 = *(float32x4_t *)(a1 + 16 * v18);
      float32x4_t v23 = vsubq_f32(v21, v20);
      float32x4_t v24 = vsubq_f32(v22, v20);
      float32x4_t v25 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(v23)), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL));
      float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL);
      int32x4_t v27 = (int32x4_t)vmulq_f32(v25, v25);
      v27.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), *(float32x2_t *)v27.i8)).u32[0];
      float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
      float32x4_t v30 = vmulq_n_f32(v26, vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28))).f32[0]);
      float32x4_t v29 = vmulq_f32(v30, v20);
      v30.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0];
      int8x16_t v31 = (int8x16_t)vmulq_f32(v11, v30);
      float v32 = vaddv_f32(vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL)));
      if (*(_WORD *)(a9 + 8) & 8) == 0 || (a8)
      {
        if (v32 == 0.0) {
          goto LABEL_15;
        }
      }
      else if (v32 >= 0.0)
      {
        goto LABEL_15;
      }
      int8x16_t v33 = (int8x16_t)vmulq_f32(v12, v30);
      float v34 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL))) / v32;
      if (v34 >= 0.0 && v34 <= v16)
      {
        float v44 = v34;
        __n128 v45 = (__n128)v30;
        float32x4_t v41 = vmlaq_n_f32(v12, v11, v34);
        *(double *)v36.i64 = scn_triangle_barycentric_coordinates(v20, v21, v22, v41);
        float32x4_t v12 = a4;
        float32x4_t v11 = a5;
        v37.i64[0] = 0xBF000000BF000000;
        v37.i64[1] = 0xBF000000BF000000;
        float32x4_t v38 = vabsq_f32(vaddq_f32(v36, v37));
        v37.i64[0] = 0x3F0000003F000000;
        v37.i64[1] = 0x3F0000003F000000;
        uint32x4_t v39 = (uint32x4_t)vcgeq_f32(v37, v38);
        v39.i32[3] = v39.i32[2];
        if ((vminvq_u32(v39) & 0x80000000) != 0)
        {
          __AddLocalResult(a9, *(_DWORD *)(a2 + 4 * v15), 0, 1, 2, v44, v41, v45);
          float32x4_t v12 = a4;
          float32x4_t v11 = a5;
          if ((*(_WORD *)(a9 + 8) & 0x80) != 0) {
            return v17;
          }
        }
      }
LABEL_15:
      BOOL v17 = ++v15 < v19;
      v18 += 3;
      if (v19 == v15) {
        return v17;
      }
    }
  }
  return 0;
}

uint64_t C3DMeshElementGetPrimitiveGroupBoundingBoxes(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v94 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    float v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DMeshElementCreate_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  uint64_t result = *(void *)(a1 + 208);
  if (result) {
    goto LABEL_5;
  }
  if ((*((unsigned char *)a2 + 26) & 0xFA) == 0)
  {
    unsigned int v19 = *((_DWORD *)a2 + 2) + 31;
    *(_DWORD *)(a1 + 216) = v19 >> 5;
    *(void *)(a1 + 208) = malloc_type_malloc(v19 & 0xFFFFFFE0, 0x1000040E0EAB150uLL);
    uint64_t v20 = a4 & 0xFF000000000000;
    uint64_t v80 = 0;
    simd_float4x4 v81 = &v80;
    uint64_t v82 = 0x2020000000;
    int v83 = 0;
    uint64_t v90 = 0;
    v91 = (float32x4_t *)&v90;
    uint64_t v92 = 0x3020000000;
    int32x4_t v93 = vdupq_n_s32(0x7F7FFFFFu);
    uint64_t v86 = 0;
    v87 = (float32x4_t *)&v86;
    uint64_t v88 = 0x3020000000;
    *(void *)&long long v21 = 0x80000000800000;
    *((void *)&v21 + 1) = 0x80000000800000;
    long long v89 = v21;
    uint64_t v76 = 0;
    float32x4_t v77 = &v76;
    uint64_t v78 = 0x2020000000;
    int v79 = 0;
    if (*((unsigned char *)a2 + 26) == 4)
    {
      v65[0] = MEMORY[0x263EF8330];
      v65[1] = 3221225472;
      long long v22 = a2[1];
      long long v66 = *a2;
      long long v67 = v22;
      long long v24 = *a2;
      long long v23 = a2[1];
      long long v68 = a2[2];
      v65[2] = __C3DMeshElementGetPrimitiveGroupBoundingBoxes_block_invoke;
      v65[3] = &unk_264004E98;
      BOOL v71 = v20 == 0x1000000000000;
      v65[8] = a3;
      v65[9] = a4;
      v65[4] = &v90;
      v65[5] = &v86;
      uint64_t v69 = *((void *)a2 + 6);
      uint64_t v70 = a1;
      v65[6] = &v80;
      v65[7] = &v76;
      long long v72 = v24;
      long long v73 = v23;
      __n128 v74 = (__n128)a2[2];
      uint64_t v75 = *((void *)a2 + 6);
      C3DIndicesContentEnumeratePrimitives((uint64_t *)&v72, (uint64_t)v65, v74);
    }
    else
    {
      int v85 = 0;
      uint64_t v84 = 0;
      if (*((_DWORD *)a2 + 2))
      {
        unint64_t v25 = 0;
        int32x4_t v62 = vdupq_n_s32(0x7F7FFFFFu);
        do
        {
          long long v26 = a2[1];
          long long v72 = *a2;
          long long v73 = v26;
          __n128 v74 = (__n128)a2[2];
          uint64_t v75 = *((void *)a2 + 6);
          C3DIndicesContentGetTriangleIndex_0((uint64_t *)&v72, v25, &v84, (_DWORD *)&v84 + 1, &v85);
          uint64_t v30 = a3 + v84 * BYTE5(a4);
          if (v20 == 0x1000000000000)
          {
            v32.i64[0] = *(void *)v30;
            uint64_t v31 = a3 + HIDWORD(v84) * BYTE5(a4);
            v33.i64[0] = *(void *)v31;
            v32.i64[1] = *(unsigned int *)(v30 + 8);
            v33.i64[1] = *(unsigned int *)(v31 + 8);
            uint64_t v34 = a3 + v85 * BYTE5(a4);
            v35.i64[0] = *(void *)v34;
            v35.i64[1] = *(unsigned int *)(v34 + 8);
          }
          else
          {
            *(double *)v36.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(a4), (float *)v30, v27, v28, v29);
            float32x4_t v64 = v36;
            *(double *)v39.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(a4), (float *)(a3 + HIDWORD(v84) * BYTE5(a4)), v36, v37, v38);
            float32x4_t v63 = v39;
            *(double *)v35.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(a4), (float *)(a3 + v85 * BYTE5(a4)), v39, v40, v41);
            float32x4_t v33 = v63;
            float32x4_t v32 = v64;
          }
          int8x16_t v42 = v91;
          v91[2] = vminq_f32(vminq_f32(vminq_f32(v91[2], v32), v33), v35);
          float32x2_t v43 = v87;
          v87[2] = vmaxq_f32(vmaxq_f32(vmaxq_f32(v87[2], v32), v33), v35);
          unsigned int v44 = *((_DWORD *)v81 + 6) + 1;
          *((_DWORD *)v81 + 6) = v44;
          if (v44 > 0x1F || (unsigned int v45 = *((_DWORD *)a2 + 2), v25 >= v45 - 1))
          {
            uint64_t v46 = *(void *)(a1 + 208);
            uint64_t v47 = *((unsigned int *)v77 + 6);
            *((_DWORD *)v77 + 6) = v47 + 1;
            simd_float4 v48 = (float32x4_t *)(v46 + 32 * v47);
            float32x4_t v49 = v42[2];
            float32x4_t v50 = v43[2];
            v51.i64[0] = 0x3F0000003F000000;
            v51.i64[1] = 0x3F0000003F000000;
            float32x4_t v52 = vmulq_f32(vaddq_f32(v49, v50), v51);
            v52.i32[3] = 1.0;
            float32x4_t v53 = vmulq_f32(vsubq_f32(v50, v49), v51);
            v53.i32[3] = 0;
            *simd_float4 v48 = v52;
            v48[1] = v53;
            v91[2] = (float32x4_t)v62;
            v53.i64[0] = 0x80000000800000;
            v53.i64[1] = 0x80000000800000;
            v87[2] = v53;
            *((_DWORD *)v81 + 6) = 0;
            unsigned int v45 = *((_DWORD *)a2 + 2);
          }
          ++v25;
        }
        while (v25 < v45);
      }
    }
    if (*((_DWORD *)v77 + 6) != *(_DWORD *)(a1 + 216))
    {
      int8x16_t v54 = scn_default_log();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
        C3DMeshElementGetPrimitiveGroupBoundingBoxes_cold_1(v54, v55, v56, v57, v58, v59, v60, v61);
      }
    }
    _Block_object_dispose(&v76, 8);
    _Block_object_dispose(&v86, 8);
    _Block_object_dispose(&v90, 8);
    _Block_object_dispose(&v80, 8);
    uint64_t result = *(void *)(a1 + 208);
LABEL_5:
    *a5 = *(_DWORD *)(a1 + 216);
    return result;
  }
  return 0;
}

void sub_20B2EB9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose((const void *)(v45 - 208), 8);
  _Block_object_dispose((const void *)(v45 - 160), 8);
  _Block_object_dispose((const void *)(v45 - 256), 8);
  _Unwind_Resume(a1);
}

void C3DIndicesContentGetTriangleIndex_0(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v5 = *((unsigned __int8 *)a1 + 26);
  uint64_t v6 = 3;
  if (a2) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 2;
  }
  if (a2) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 1;
  }
  BOOL v9 = v5 == 1 || v5 != 5;
  if (v5 != 1)
  {
    uint64_t v7 = 2;
    uint64_t v8 = 1;
  }
  BOOL v10 = v5 == 0;
  if (*((unsigned char *)a1 + 26)) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = 3;
  }
  if (*((unsigned char *)a1 + 26))
  {
    uint64_t v6 = 1;
    uint64_t v12 = v7;
  }
  else
  {
    uint64_t v12 = 2;
  }
  if (v10) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v8;
  }
  uint64_t v14 = *a1;
  if (!*a1)
  {
    *a3 = v11 * a2;
    *a4 = v13 + v6 * a2;
    int v20 = v6 * a2 + v12;
    goto LABEL_29;
  }
  uint64_t v16 = (unsigned __int8 *)a1 + 27;
  int v15 = *((unsigned __int8 *)a1 + 27);
  switch(v15)
  {
    case 4:
      uint64_t v21 = a1[5];
      uint64_t v22 = a1[6];
      *a3 = *(_DWORD *)(v14 + 4 * (v21 + v11 * a2 * v22));
      uint64_t v23 = v6 * a2;
      *a4 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v13 + v23)));
      int v20 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v23 + v12)));
      goto LABEL_29;
    case 2:
      uint64_t v24 = a1[5];
      uint64_t v25 = a1[6];
      *a3 = *(unsigned __int16 *)(v14 + 2 * (v24 + v11 * a2 * v25));
      uint64_t v26 = v6 * a2;
      *a4 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v13 + v26)));
      int v20 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v26 + v12)));
      goto LABEL_29;
    case 1:
      uint64_t v17 = a1[5];
      uint64_t v18 = a1[6];
      *a3 = *(unsigned __int8 *)(v14 + v17 + v11 * a2 * v18);
      uint64_t v19 = v6 * a2;
      *a4 = *(unsigned __int8 *)(v14 + v17 + v18 * (v13 + v19));
      int v20 = *(unsigned __int8 *)(v14 + v17 + v18 * (v19 + v12));
LABEL_29:
      *a5 = v20;
      return;
  }
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  float32x4_t v27 = scn_default_log();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
    C3DIndicesContentGetTriangleIndex_cold_1_0(v16, v27);
  }
}

float32x4_t __C3DMeshElementGetPrimitiveGroupBoundingBoxes_block_invoke(uint64_t a1, unsigned int a2, int *a3, unsigned int a4, float32x4_t result, float32x4_t a6, float a7)
{
  if (*(unsigned char *)(a1 + 144))
  {
    if (a4)
    {
      uint64_t v10 = a4;
      result.i32[3] = 0;
      do
      {
        int v11 = *a3++;
        uint64_t v12 = *(void *)(a1 + 64) + v11 * *(unsigned __int8 *)(a1 + 77);
        v13.i64[0] = *(void *)v12;
        v13.i32[2] = *(_DWORD *)(v12 + 8);
        v13.i32[3] = result.i32[3];
        *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vminq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8)+ 32), v13);
        *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32) = vmaxq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8)+ 32), v13);
        uint64_t result = v13;
        --v10;
      }
      while (v10);
    }
  }
  else if (a4)
  {
    uint64_t v14 = a4;
    do
    {
      int v15 = *a3++;
      *(double *)v16.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 76), (float *)(*(void *)(a1 + 64) + v15 * *(unsigned __int8 *)(a1 + 77)), result, a6.f32[0], a7);
      *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vminq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8)+ 32), v16);
      uint64_t v17 = *(__n128 **)(*(void *)(a1 + 40) + 8);
      a6 = (float32x4_t)v17[2];
      uint64_t result = vmaxq_f32(a6, v16);
      v17[2] = (__n128)result;
      --v14;
    }
    while (v14);
  }
  if (++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) > 0x1Fu || *(_DWORD *)(a1 + 88) - 1 <= a2)
  {
    uint64_t v18 = *(void *)(*(void *)(a1 + 136) + 208);
    uint64_t v19 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v20 = *(unsigned int *)(v19 + 24);
    *(_DWORD *)(v19 + 24) = v20 + 1;
    uint64_t v21 = (float32x4_t *)(v18 + 32 * v20);
    float32x4_t v22 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32);
    float32x4_t v23 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32);
    v24.i64[0] = 0x3F0000003F000000;
    v24.i64[1] = 0x3F0000003F000000;
    float32x4_t v25 = vmulq_f32(vaddq_f32(v22, v23), v24);
    v25.i32[3] = 1.0;
    float32x4_t v26 = vmulq_f32(vsubq_f32(v23, v22), v24);
    v26.i32[3] = 0;
    *uint64_t v21 = v25;
    v21[1] = v26;
    *(int32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vdupq_n_s32(0x7F7FFFFFu);
    result.i64[0] = 0x80000000800000;
    result.i64[1] = 0x80000000800000;
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32) = result;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  return result;
}

BOOL __ProcessTriangleRange_Generic(unsigned int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a3 + 200);
  int v4 = *(unsigned __int8 *)(a3 + 212);
  int v5 = *(unsigned __int8 *)(a3 + 213);
  long long v6 = *(_OWORD *)(a3 + 232);
  long long v63 = *(_OWORD *)(a3 + 216);
  long long v64 = v6;
  long long v65 = *(_OWORD *)(a3 + 248);
  uint64_t v66 = *(void *)(a3 + 264);
  BOOL v7 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  BOOL v8 = 0;
  int v9 = *(unsigned __int8 *)(a3 + 214);
  int v10 = *(unsigned __int8 *)(a3 + 273);
  float32x4_t v54 = *(float32x4_t *)(a3 + 64);
  float32x4_t v60 = *(float32x4_t *)(a3 + 80);
  long long v11 = *(_OWORD *)(a3 + 96);
  int v68 = 0;
  uint64_t v67 = 0;
  unsigned int v12 = a2 - a1;
  if (a2 > a1)
  {
    float v13 = *((float *)&v11 + 3);
    uint64_t v14 = a1;
    unint64_t v59 = a2;
    BOOL v8 = 1;
    do
    {
      v61[0] = v63;
      v61[1] = v64;
      v61[2] = v65;
      uint64_t v62 = v66;
      if (v10)
      {
        int v15 = &v67;
        uint64_t v16 = v14;
        uint64_t v17 = (uint64_t *)((char *)&v67 + 4);
      }
      else
      {
        uint64_t v17 = &v67;
        uint64_t v16 = v14;
        int v15 = (uint64_t *)((char *)&v67 + 4);
      }
      C3DIndicesContentGetTriangleIndex_0((uint64_t *)v61, v16, v17, v15, &v68);
      uint64_t v21 = v3 + (v67 * v5);
      if (v9 == 1)
      {
        v23.i64[0] = *(void *)v21;
        uint64_t v22 = v3 + (HIDWORD(v67) * v5);
        v24.i64[0] = *(void *)v22;
        v23.i64[1] = *(unsigned int *)(v21 + 8);
        v24.i64[1] = *(unsigned int *)(v22 + 8);
        uint64_t v25 = v3 + (v68 * v5);
        v26.i64[0] = *(void *)v25;
        v26.i64[1] = *(unsigned int *)(v25 + 8);
      }
      else
      {
        *(double *)v27.i64 = C3DConvertFloatingTypeToFloat4(v4, (float *)v21, v18, v19, v20);
        float32x4_t v57 = v27;
        *(double *)v30.i64 = C3DConvertFloatingTypeToFloat4(v4, (float *)(v3 + (HIDWORD(v67) * v5)), v27, v28, v29);
        float32x4_t v55 = v30;
        *(double *)v33.i64 = C3DConvertFloatingTypeToFloat4(v4, (float *)(v3 + (v68 * v5)), v30, v31, v32);
        float32x4_t v24 = v55;
        float32x4_t v23 = v57;
        float32x4_t v26 = v33;
      }
      float32x4_t v34 = vsubq_f32(v24, v23);
      float32x4_t v35 = vsubq_f32(v26, v23);
      float32x4_t v36 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL), vnegq_f32(v34)), v35, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL));
      float32x4_t v37 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL);
      int32x4_t v38 = (int32x4_t)vmulq_f32(v36, v36);
      v38.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v38, 2), *(float32x2_t *)v38.i8)).u32[0];
      float32x2_t v39 = vrsqrte_f32((float32x2_t)v38.u32[0]);
      float32x4_t v41 = vmulq_n_f32(v37, vmul_f32(v39, vrsqrts_f32((float32x2_t)v38.u32[0], vmul_f32(v39, v39))).f32[0]);
      float32x4_t v40 = vmulq_f32(v23, v41);
      v41.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0];
      int8x16_t v42 = (int8x16_t)vmulq_f32(v60, v41);
      float v43 = vaddv_f32(vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL)));
      if (v7)
      {
        if (v43 >= 0.0) {
          goto LABEL_23;
        }
      }
      else if (v43 == 0.0)
      {
        goto LABEL_23;
      }
      int8x16_t v44 = (int8x16_t)vmulq_f32(v54, v41);
      float v45 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL))) / v43;
      if (v45 >= 0.0 && v45 <= v13)
      {
        float v56 = v45;
        __n128 v58 = (__n128)v41;
        float32x4_t v53 = vmlaq_n_f32(v54, v60, v45);
        *(double *)v47.i64 = scn_triangle_barycentric_coordinates(v23, v24, v26, v53);
        v48.i64[0] = 0xBF000000BF000000;
        v48.i64[1] = 0xBF000000BF000000;
        float32x4_t v49 = vabsq_f32(vaddq_f32(v47, v48));
        v48.i64[0] = 0x3F0000003F000000;
        v48.i64[1] = 0x3F0000003F000000;
        uint32x4_t v50 = (uint32x4_t)vcgeq_f32(v48, v49);
        v50.i32[3] = v50.i32[2];
        if ((vminvq_u32(v50) & 0x80000000) != 0)
        {
          __AddLocalResult(a3, v14, 0, 1, 2, v56, v53, v58);
          if ((*(_WORD *)(a3 + 8) & 0x80) != 0) {
            return v8;
          }
        }
      }
LABEL_23:
      BOOL v8 = ++v14 < v59;
      --v12;
    }
    while (v12);
  }
  return v8;
}

uint64_t __ProcessPrimitiveRange_Generic(unsigned int a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 200);
  char v4 = *(unsigned char *)(a3 + 212);
  int v5 = *(unsigned __int8 *)(a3 + 213);
  v29[0] = a1;
  v29[1] = a2 - a1;
  BOOL v6 = *(unsigned char *)(a3 + 214) == 1;
  BOOL v7 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  char v8 = *(unsigned char *)(a3 + 273);
  long long v9 = *(_OWORD *)(a3 + 80);
  long long v16 = *(_OWORD *)(a3 + 64);
  long long v17 = v9;
  long long v18 = *(_OWORD *)(a3 + 96);
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  char v28 = 0;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = ____ProcessPrimitiveRange_Generic_block_invoke;
  v15[3] = &unk_264004EC0;
  char v23 = v8;
  BOOL v24 = v6;
  int v22 = v5;
  char v25 = v4;
  BOOL v26 = v7;
  uint64_t v20 = v3;
  uint64_t v21 = a3;
  float v19 = v27;
  long long v11 = *(_OWORD *)(a3 + 216);
  unsigned int v12 = v29;
  __int16 v13 = 1;
  v14[0] = *(_OWORD *)(a3 + 242);
  *(_OWORD *)((char *)v14 + 14) = *(_OWORD *)(a3 + 256);
  C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges((uint64_t)&v11, (uint64_t)v15, *(__n128 *)((char *)v14 + 14));
  _Block_object_dispose(v27, 8);
  return 0;
}

void sub_20B2EC208(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

BOOL __ProcessTriangleRange_Mask(unsigned int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a3 + 200);
  int v55 = *(unsigned __int8 *)(a3 + 212);
  int v5 = *(unsigned __int8 *)(a3 + 213);
  long long v6 = *(_OWORD *)(a3 + 232);
  long long v66 = *(_OWORD *)(a3 + 216);
  long long v67 = v6;
  long long v68 = *(_OWORD *)(a3 + 248);
  uint64_t v69 = *(void *)(a3 + 264);
  BOOL v7 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  BOOL v8 = 0;
  int v9 = *(unsigned __int8 *)(a3 + 214);
  int v63 = *(unsigned __int8 *)(a3 + 273);
  float32x4_t v56 = *(float32x4_t *)(a3 + 64);
  float32x4_t v61 = *(float32x4_t *)(a3 + 80);
  long long v10 = *(_OWORD *)(a3 + 96);
  unsigned int v71 = 0;
  uint64_t v70 = 0;
  unsigned int v11 = a2 - a1;
  if (a2 > a1)
  {
    float v12 = *((float *)&v10 + 3);
    uint64_t v13 = a1;
    unint64_t v62 = a2;
    BOOL v8 = 1;
    do
    {
      v64[0] = v66;
      v64[1] = v67;
      v64[2] = v68;
      uint64_t v65 = v69;
      if (v63)
      {
        uint64_t v14 = &v70;
        uint64_t v15 = v13;
        long long v16 = (uint64_t *)((char *)&v70 + 4);
      }
      else
      {
        long long v16 = &v70;
        uint64_t v15 = v13;
        uint64_t v14 = (uint64_t *)((char *)&v70 + 4);
      }
      C3DIndicesContentGetTriangleIndex_0((uint64_t *)v64, v15, v16, v14, &v71);
      int v20 = HIDWORD(v70);
      unsigned int v21 = v71;
      if (((*(unsigned char *)(*(void *)(v3 + 304) + HIDWORD(v70)) & *(unsigned char *)(*(void *)(v3 + 304)
                                                                                          + v70)) & *(unsigned char *)(*(void *)(v3 + 304) + v71)) != 0)
        goto LABEL_10;
      uint64_t v22 = v4 + (v70 * v5);
      if (v9 == 1)
      {
        v23.i64[0] = *(void *)v22;
        v23.i64[1] = *(unsigned int *)(v22 + 8);
        uint64_t v24 = v4 + (HIDWORD(v70) * v5);
        v25.i64[0] = *(void *)v24;
        v25.i64[1] = *(unsigned int *)(v24 + 8);
        uint64_t v26 = v4 + v71 * v5;
        v27.i64[0] = *(void *)v26;
        v27.i64[1] = *(unsigned int *)(v26 + 8);
      }
      else
      {
        *(double *)v28.i64 = C3DConvertFloatingTypeToFloat4(v55, (float *)v22, v17, v18, v19);
        float32x4_t v59 = v28;
        *(double *)v31.i64 = C3DConvertFloatingTypeToFloat4(v55, (float *)(v4 + (v20 * v5)), v28, v29, v30);
        float32x4_t v57 = v31;
        uint64_t v3 = a3;
        *(double *)v34.i64 = C3DConvertFloatingTypeToFloat4(v55, (float *)(v4 + v21 * v5), v31, v32, v33);
        float32x4_t v25 = v57;
        float32x4_t v23 = v59;
        float32x4_t v27 = v34;
      }
      float32x4_t v35 = vsubq_f32(v25, v23);
      float32x4_t v36 = vsubq_f32(v27, v23);
      float32x4_t v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL), vnegq_f32(v35)), v36, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL));
      float32x4_t v38 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), (int8x16_t)v37, 0xCuLL);
      int32x4_t v39 = (int32x4_t)vmulq_f32(v37, v37);
      v39.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v39, 2), *(float32x2_t *)v39.i8)).u32[0];
      float32x2_t v40 = vrsqrte_f32((float32x2_t)v39.u32[0]);
      float32x4_t v42 = vmulq_n_f32(v38, vmul_f32(v40, vrsqrts_f32((float32x2_t)v39.u32[0], vmul_f32(v40, v40))).f32[0]);
      float32x4_t v41 = vmulq_f32(v23, v42);
      v42.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0];
      int8x16_t v43 = (int8x16_t)vmulq_f32(v61, v42);
      float v44 = vaddv_f32(vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)));
      if (v7)
      {
        if (v44 >= 0.0) {
          goto LABEL_10;
        }
      }
      else if (v44 == 0.0)
      {
        goto LABEL_10;
      }
      int8x16_t v45 = (int8x16_t)vmulq_f32(v56, v42);
      float v46 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL))) / v44;
      if (v46 >= 0.0 && v46 <= v12)
      {
        float v58 = v46;
        __n128 v60 = (__n128)v42;
        float32x4_t v53 = vmlaq_n_f32(v56, v61, v46);
        *(double *)v48.i64 = scn_triangle_barycentric_coordinates(v23, v25, v27, v53);
        v49.i64[0] = 0xBF000000BF000000;
        v49.i64[1] = 0xBF000000BF000000;
        float32x4_t v50 = vabsq_f32(vaddq_f32(v48, v49));
        v49.i64[0] = 0x3F0000003F000000;
        v49.i64[1] = 0x3F0000003F000000;
        uint32x4_t v51 = (uint32x4_t)vcgeq_f32(v49, v50);
        v51.i32[3] = v51.i32[2];
        if ((vminvq_u32(v51) & 0x80000000) != 0)
        {
          __AddLocalResult(v3, v13, 0, 1, 2, v58, v53, v60);
          if ((*(_WORD *)(v3 + 8) & 0x80) != 0) {
            return v8;
          }
        }
      }
LABEL_10:
      BOOL v8 = ++v13 < v62;
      --v11;
    }
    while (v11);
  }
  return v8;
}

uint64_t __ProcessPrimitiveRange_Mask(unsigned int a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 200);
  char v4 = *(unsigned char *)(a3 + 212);
  int v5 = *(unsigned __int8 *)(a3 + 213);
  v29[0] = a1;
  v29[1] = a2 - a1;
  BOOL v6 = *(unsigned char *)(a3 + 214) == 1;
  BOOL v7 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  char v8 = *(unsigned char *)(a3 + 273);
  long long v9 = *(_OWORD *)(a3 + 80);
  long long v16 = *(_OWORD *)(a3 + 64);
  long long v17 = v9;
  long long v18 = *(_OWORD *)(a3 + 96);
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  char v28 = 0;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = ____ProcessPrimitiveRange_Mask_block_invoke;
  v15[3] = &unk_264004EC0;
  char v23 = v8;
  BOOL v24 = v6;
  uint64_t v20 = a3;
  uint64_t v21 = v3;
  int v22 = v5;
  char v25 = v4;
  BOOL v26 = v7;
  float v19 = v27;
  long long v11 = *(_OWORD *)(a3 + 216);
  float v12 = v29;
  __int16 v13 = 1;
  v14[0] = *(_OWORD *)(a3 + 242);
  *(_OWORD *)((char *)v14 + 14) = *(_OWORD *)(a3 + 256);
  C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges((uint64_t)&v11, (uint64_t)v15, *(__n128 *)((char *)v14 + 14));
  _Block_object_dispose(v27, 8);
  return 0;
}

void sub_20B2EC970(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

BOOL __ProcessTriangleRange_Mask_Ind16VrtFloat3CullBack(unsigned int a1, unsigned int a2, uint64_t a3, int32x4_t a4, float32x4_t a5, float32x4_t a6)
{
  uint64_t v9 = *(void *)(a3 + 200);
  unsigned int v10 = *(unsigned __int8 *)(a3 + 213);
  uint64_t v11 = *(void *)(a3 + 216);
  if (*(void *)(a3 + 256) || *(void *)(a3 + 264) != 1)
  {
    float v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      __ProcessTriangleRange_Mask_Ind16VrtFloat3CullBack_cold_1(v12);
    }
  }
  unsigned int v13 = a2 - a1;
  if (a2 <= a1)
  {
    return 0;
  }
  else
  {
    uint64_t v14 = a1;
    BOOL v15 = 1;
    unsigned int v16 = 3 * a1;
    do
    {
      if (((*(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v11 + 2 * (v16 + 1))) & *(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v11 + 2 * v16))) & *(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v11 + 2 * (v16 + 2)))) == 0)
      {
        uint64_t v17 = v9 + *(unsigned __int16 *)(v11 + 2 * v16) * (unint64_t)v10;
        a4.i64[0] = *(void *)v17;
        a4.i32[2] = *(_DWORD *)(v17 + 8);
        uint64_t v18 = v9 + *(unsigned __int16 *)(v11 + 2 * (v16 + 1)) * (unint64_t)v10;
        a5.i64[0] = *(void *)v18;
        a5.i32[2] = *(_DWORD *)(v18 + 8);
        uint64_t v19 = v9 + *(unsigned __int16 *)(v11 + 2 * (v16 + 2)) * (unint64_t)v10;
        a6.i64[0] = *(void *)v19;
        a6.i32[2] = *(_DWORD *)(v19 + 8);
        float32x4_t v20 = vsubq_f32(a5, (float32x4_t)a4);
        float32x4_t v21 = vsubq_f32(a6, (float32x4_t)a4);
        float32x4_t v22 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL), vnegq_f32(v20)), v21, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL));
        float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL);
        int32x4_t v24 = (int32x4_t)vmulq_f32(v22, v22);
        v24.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v24.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v24, 2), *(float32x2_t *)v24.i8)).u32[0];
        float32x2_t v25 = vrsqrte_f32((float32x2_t)v24.u32[0]);
        float32x4_t v27 = vmulq_n_f32(v23, vmul_f32(v25, vrsqrts_f32((float32x2_t)v24.u32[0], vmul_f32(v25, v25))).f32[0]);
        float32x4_t v26 = vmulq_f32((float32x4_t)a4, v27);
        v27.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
        float32x4_t v28 = *(float32x4_t *)(a3 + 80);
        int8x16_t v29 = (int8x16_t)vmulq_f32(v28, v27);
        float v30 = vaddv_f32(vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL)));
        if (v30 < 0.0)
        {
          float32x4_t v31 = *(float32x4_t *)(a3 + 64);
          int8x16_t v32 = (int8x16_t)vmulq_f32(v31, v27);
          float v33 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)))
              / v30;
          if (v33 >= 0.0 && v33 <= *(float *)(a3 + 108))
          {
            float32x4_t v40 = vmlaq_n_f32(v31, v28, v33);
            __n128 v41 = (__n128)v27;
            float v39 = v33;
            *(double *)v35.i64 = scn_triangle_barycentric_coordinates((float32x4_t)a4, a5, a6, v40);
            a6.i32[3] = v41.n128_i32[3];
            v36.i64[0] = 0xBF000000BF000000;
            v36.i64[1] = 0xBF000000BF000000;
            float32x4_t v37 = vabsq_f32(vaddq_f32(v35, v36));
            a5.i64[0] = 0x3F0000003F000000;
            a5.i64[1] = 0x3F0000003F000000;
            a4 = vcgeq_f32(a5, v37);
            a4.i32[3] = a4.i32[2];
            if ((vminvq_u32((uint32x4_t)a4) & 0x80000000) != 0)
            {
              __AddLocalResult(a3, v14, 0, 1, 2, v39, v40, v41);
              if ((*(_WORD *)(a3 + 8) & 0x80) != 0) {
                break;
              }
            }
          }
        }
      }
      BOOL v15 = ++v14 < (unint64_t)a2;
      v16 += 3;
      --v13;
    }
    while (v13);
  }
  return v15;
}

BOOL __ProcessTriangleRange_Ind16VrtFloat3CullBack(unsigned int a1, unsigned int a2, uint64_t a3, int32x4_t a4, float32x4_t a5, float32x4_t a6)
{
  uint64_t v9 = *(void *)(a3 + 200);
  unsigned int v10 = *(unsigned __int8 *)(a3 + 213);
  uint64_t v11 = *(void *)(a3 + 216);
  if (*(void *)(a3 + 256) || *(void *)(a3 + 264) != 1)
  {
    float v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      __ProcessTriangleRange_Ind16VrtFloat3CullBack_cold_1(v12);
    }
  }
  unsigned int v13 = a2 - a1;
  if (a2 <= a1)
  {
    return 0;
  }
  else
  {
    uint64_t v14 = a1;
    BOOL v15 = 1;
    unsigned int v16 = 3 * a1;
    do
    {
      if (v11)
      {
        unsigned __int16 v17 = *(_WORD *)(v11 + 2 * v16);
        unsigned __int16 v18 = *(_WORD *)(v11 + 2 * (v16 + 1));
        unsigned __int16 v19 = *(_WORD *)(v11 + 2 * (v16 + 2));
      }
      else
      {
        unsigned __int16 v18 = v16 + 1;
        unsigned __int16 v19 = v16 + 2;
        unsigned __int16 v17 = v16;
      }
      uint64_t v20 = v9 + v10 * (unint64_t)v17;
      a4.i64[0] = *(void *)v20;
      a4.i32[2] = *(_DWORD *)(v20 + 8);
      uint64_t v21 = v9 + v10 * (unint64_t)v18;
      a5.i64[0] = *(void *)v21;
      a5.i32[2] = *(_DWORD *)(v21 + 8);
      uint64_t v22 = v9 + v10 * (unint64_t)v19;
      a6.i64[0] = *(void *)v22;
      a6.i32[2] = *(_DWORD *)(v22 + 8);
      float32x4_t v23 = vsubq_f32(a5, (float32x4_t)a4);
      float32x4_t v24 = vsubq_f32(a6, (float32x4_t)a4);
      float32x4_t v25 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(v23)), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL));
      float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL);
      int32x4_t v27 = (int32x4_t)vmulq_f32(v25, v25);
      v27.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), *(float32x2_t *)v27.i8)).u32[0];
      float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
      float32x4_t v30 = vmulq_n_f32(v26, vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28))).f32[0]);
      float32x4_t v29 = vmulq_f32((float32x4_t)a4, v30);
      v30.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0];
      float32x4_t v31 = *(float32x4_t *)(a3 + 80);
      int8x16_t v32 = (int8x16_t)vmulq_f32(v31, v30);
      float v33 = vaddv_f32(vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)));
      if (v33 < 0.0)
      {
        float32x4_t v34 = *(float32x4_t *)(a3 + 64);
        int8x16_t v35 = (int8x16_t)vmulq_f32(v34, v30);
        float v36 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)))
            / v33;
        if (v36 >= 0.0 && v36 <= *(float *)(a3 + 108))
        {
          float32x4_t v43 = vmlaq_n_f32(v34, v31, v36);
          __n128 v44 = (__n128)v30;
          float v42 = v36;
          *(double *)v38.i64 = scn_triangle_barycentric_coordinates((float32x4_t)a4, a5, a6, v43);
          a6.i32[3] = v44.n128_i32[3];
          v39.i64[0] = 0xBF000000BF000000;
          v39.i64[1] = 0xBF000000BF000000;
          float32x4_t v40 = vabsq_f32(vaddq_f32(v38, v39));
          a5.i64[0] = 0x3F0000003F000000;
          a5.i64[1] = 0x3F0000003F000000;
          a4 = vcgeq_f32(a5, v40);
          a4.i32[3] = a4.i32[2];
          if ((vminvq_u32((uint32x4_t)a4) & 0x80000000) != 0)
          {
            __AddLocalResult(a3, v14, 0, 1, 2, v42, v43, v44);
            if ((*(_WORD *)(a3 + 8) & 0x80) != 0) {
              break;
            }
          }
        }
      }
      BOOL v15 = ++v14 < (unint64_t)a2;
      v16 += 3;
      --v13;
    }
    while (v13);
  }
  return v15;
}

BOOL __ProcessSkinnedGeometryForJointIndex(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  Materialsunsigned int Count = C3DGeometryGetMaterialsCount(a2);
  uint64_t Mesh = C3DGeometryGetMesh(a2);
  PositionSource = C3DMeshGetPositionSource(Mesh, 0);
  uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 0, 0);
  uint64_t Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
  uint64_t v40 = v12;
  uint64_t v38 = Content;
  if (!Content) {
    return 0;
  }
  uint64_t IndexedBoneIndices = C3DSkinGetIndexedBoneIndices(a1);
  if (!IndexedBoneIndices)
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      __ProcessSkinnedGeometryForJointIndex_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  uint64_t v37 = C3DMeshSourceGetContent(IndexedBoneIndices);
  unint64_t v39 = v22;
  if (HIWORD(v22) == 1040
    && (long long v23 = *(_OWORD *)(a4 + 80),
        long long v78 = *(_OWORD *)(a4 + 64),
        long long v79 = v23,
        long long v80 = *(_OWORD *)(a4 + 96),
        CFArrayRef ElementsCount = C3DMeshGetElementsCount(Mesh),
        (uint64_t)ElementsCount >= 1))
  {
    CFIndex v26 = 0;
    *(int16x4_t *)v25.i8 = vdup_n_s16(a3);
    BOOL v27 = 1;
    int32x4_t v36 = vdupq_n_s32(0x7F7FFFFFu);
    *(int8x8_t *)v25.i8 = vmovn_s16(v25);
    __n128 v35 = (__n128)v25;
    do
    {
      *(void *)(a4 + 192) = v26;
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex(Mesh, v26, 0);
      uint64_t v77 = 0;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v74 = 0u;
      C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v74);
      if ((((uint64_t)MaterialsCount > 0) & (*(unsigned __int16 *)(a4 + 8) >> 3)) == 1)
      {
        MaterialAtuint64_t Index = C3DGeometryGetMaterialAtIndex(a2, v26 % (uint64_t)MaterialsCount);
        char IsDoubleSided = C3DMaterialIsDoubleSided((uint64_t)MaterialAtIndex);
        int CullMode = C3DMaterialGetCullMode((uint64_t)MaterialAtIndex);
      }
      else
      {
        char IsDoubleSided = 0;
        int CullMode = 0;
      }
      if ((BYTE10(v75) & 0xFA) == 0)
      {
        v72[0] = 0;
        v72[1] = v72;
        v72[2] = 0x2020000000;
        int v73 = 0;
        v83[0] = 0;
        v83[1] = v83;
        v83[2] = 0x3020000000;
        int32x4_t v84 = v36;
        v81[0] = 0;
        v81[1] = v81;
        v81[2] = 0x3020000000;
        *(void *)&long long v32 = 0x80000000800000;
        *((void *)&v32 + 1) = 0x80000000800000;
        long long v82 = v32;
        uint64_t v68 = 0;
        uint64_t v69 = &v68;
        uint64_t v70 = 0x2020000000;
        char v71 = 0;
        v44[0] = MEMORY[0x263EF8330];
        v44[1] = 3221225472;
        long long v59 = v75;
        long long v60 = v76;
        long long v58 = v74;
        long long v46 = v79;
        long long v47 = v80;
        long long v45 = v78;
        v44[2] = ____ProcessSkinnedGeometryForJointIndex_block_invoke;
        v44[3] = &unk_264004EE8;
        int v64 = CullMode;
        uint64_t v52 = v37;
        unint64_t v53 = v39;
        unsigned __int32 v65 = v35.n128_u32[0];
        BOOL v66 = (v40 & 0xFF000000000000) == 0x1000000000000;
        uint64_t v54 = v38;
        uint64_t v55 = v40;
        float32x4_t v48 = v83;
        float32x4_t v49 = v81;
        float32x4_t v56 = &v86;
        float32x4_t v57 = &v85;
        uint64_t v61 = v77;
        char v67 = IsDoubleSided;
        CFIndex v62 = v26;
        uint64_t v63 = a4;
        float32x4_t v50 = v72;
        uint32x4_t v51 = &v68;
        v42[0] = v74;
        v42[1] = v75;
        v42[2] = v76;
        uint64_t v43 = v77;
        C3DIndicesContentEnumerateTriangulatedPrimitives((uint64_t *)v42, (uint64_t)v44, v35);
        int v33 = *((unsigned __int8 *)v69 + 24);
        _Block_object_dispose(&v68, 8);
        _Block_object_dispose(v81, 8);
        _Block_object_dispose(v83, 8);
        _Block_object_dispose(v72, 8);
        if (v33) {
          break;
        }
      }
      BOOL v27 = ++v26 < (uint64_t)ElementsCount;
    }
    while (ElementsCount != (const __CFArray *)v26);
  }
  else
  {
    return 0;
  }
  return v27;
}

void sub_20B2ED478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&STACK[0x250], 8);
  _Block_object_dispose(&STACK[0x280], 8);
  _Block_object_dispose(&a65, 8);
  _Unwind_Resume(a1);
}

uint64_t __ProcessSkinner(uint64_t a1, uint64_t a2)
{
  uint64_t JointBoundingBoxes = C3DSkinnerGetJointBoundingBoxes(a1, *(void *)(a2 + 112));
  uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial(a1);
  uint64_t Geometry = C3DNodeGetGeometry(*(void *)(a2 + 112));
  uint64_t v7 = Geometry;
  if ((*(_WORD *)(a2 + 8) & 0x40) != 0 || Geometry)
  {
    uint64_t IOSurface = C3DTextureGetIOSurface(OverrideMaterial);
    CFArrayRef Joints = (const __CFArray *)C3DSkinnerGetJoints(a1);
    if (Joints)
    {
      CFArrayRef v10 = Joints;
      CFIndex Count = CFArrayGetCount(Joints);
      if (Count >= 1)
      {
        CFIndex v12 = Count;
        char v13 = 0;
        CFIndex v14 = 0;
        while (1)
        {
          uint64_t v15 = (float32x4_t *)(JointBoundingBoxes + 32 * v14);
          if ((vminvq_u32((uint32x4_t)vcgezq_f32(v15[1])) & 0x80000000) != 0)
          {
            float32x4_t v93 = *v15;
            float32x4_t v95 = v15[1];
            ValueAtuint64_t Index = (float32x4_t *)CFArrayGetValueAtIndex(v10, v14);
            *(void *)(a2 + 120) = ValueAtIndex;
            WorldMatrix = C3DNodeGetWorldMatrix(ValueAtIndex);
            float32x4_t v18 = *WorldMatrix;
            float32x4_t v19 = WorldMatrix[1];
            float32x4_t v20 = WorldMatrix[2];
            float32x4_t v21 = WorldMatrix[3];
            float32x4_t v22 = vaddq_f32(v21, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v19, *(float32x2_t *)v93.f32, 1), *WorldMatrix, v93.f32[0]), v20, v93, 2));
            int8x16_t v23 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), vnegq_f32(v19)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL));
            float32x4_t v24 = vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), v23, 0xCuLL));
            _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0] < 0.0;
            float32x4_t v25 = vmulq_f32(v18, v18);
            float32x4_t v28 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1)));
            float32x4_t v26 = vmulq_f32(v19, v19);
            v28.f32[0] = sqrtf(v28.f32[0]);
            float32x4_t v27 = vmulq_f32(v20, v20);
            v28.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
            v28.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]);
            float v29 = 1.0;
            if (_NF) {
              float v29 = -1.0;
            }
            float32x4_t v30 = vmulq_n_f32(v28, v29);
            int32x4_t v31 = (int32x4_t)vdivq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0));
            int32x4_t v32 = (int32x4_t)vdivq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1));
            int32x4_t v33 = (int32x4_t)vdivq_f32(v20, (float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2));
            float32x4_t v34 = vmulq_f32(v95, v30);
            float32x4_t v35 = *(float32x4_t *)(a2 + 16);
            float32x4_t v36 = *(float32x4_t *)(a2 + 32);
            float32x4_t v37 = vsubq_f32(v22, v35);
            float32x4_t v38 = (float32x4_t)vzip1q_s32(vzip1q_s32(v31, v33), v32);
            float32x4_t v39 = (float32x4_t)vtrn2q_s32(v31, v32);
            v39.i32[2] = v33.i32[1];
            float32x4_t v40 = (float32x4_t)vzip1q_s32(vzip2q_s32(v31, v33), vdupq_laneq_s32(v32, 2));
            float32x4_t v41 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v39, *(float32x2_t *)v37.f32, 1), v38, v37.f32[0]), v40, v37, 2);
            float32x4_t v42 = vaddq_f32(v34, v41);
            float32x4_t v43 = vsubq_f32(v41, v34);
            v34.i32[3] = v95.i32[3];
            v99.columns[1] = (simd_float4)v31;
            v99.columns[2] = (simd_float4)v32;
            v99.columns[3] = (simd_float4)v33;
            float32x4_t v100 = v34;
            float32x4_t v44 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v39, *(float32x2_t *)v36.f32, 1), v38, v36.f32[0]), v40, v36, 2);
            float32x4_t v45 = vdivq_f32(v42, v44);
            v45.i32[3] = 0;
            float32x4_t v46 = vdivq_f32(v43, v44);
            v46.i32[3] = 0;
            int8x16_t v47 = (int8x16_t)vminnmq_f32(v45, v46);
            float32x4_t v48 = vmaxnmq_f32(v45, v46);
            if (*(float *)v47.i32 < *(float *)&v47.i32[2]) {
              float v49 = *(float *)&v47.i32[2];
            }
            else {
              float v49 = *(float *)v47.i32;
            }
            if (v49 < *(float *)&v47.i32[1]) {
              float v49 = *(float *)&v47.i32[1];
            }
            float v50 = v48.f32[2];
            if (v48.f32[0] <= v48.f32[2]) {
              float v50 = v48.f32[0];
            }
            v48.i32[0] = v48.i32[1];
            if (v50 <= v48.f32[1]) {
              v48.f32[0] = v50;
            }
            if (v48.f32[0] >= v49)
            {
              _NF = v48.f32[0] >= 0.0 && v49 < *(float *)(a2 + 60);
              if (_NF)
              {
                LODWORD(v52) = 2 * (*(float *)v47.i32 <= *(float *)&v47.i32[2]);
                if (*(float *)&v47.i32[1] > *(float *)&v47.i32[2]) {
                  unsigned int v53 = 1;
                }
                else {
                  unsigned int v53 = 2;
                }
                if (*(float *)v47.i32 <= *(float *)&v47.i32[1]) {
                  uint64_t v52 = v53;
                }
                else {
                  uint64_t v52 = v52;
                }
                if (v49 >= 0.0) {
                  float v54 = v49;
                }
                else {
                  float v54 = v48.f32[0];
                }
                simd_float4 v55 = v99.columns[v52 + 1];
                float32x4_t v98 = v44;
                v44.i32[0] = *(_DWORD *)((unint64_t)&v98 | (4 * v52));
                v47.i32[0] = 1.0;
                v56.i64[0] = 0x8000000080000000;
                v56.i64[1] = 0x8000000080000000;
                v47.i32[0] = vbslq_s8(v56, v47, (int8x16_t)v44).u32[0];
                if (v44.f32[0] == 0.0) {
                  float v57 = 0.0;
                }
                else {
                  float v57 = *(float *)v47.i32;
                }
                float v58 = v57;
                if ((*(_WORD *)(a2 + 8) & 0x40) != 0)
                {
                  float32x4_t v90 = (float32x4_t)v55;
                  float32x4_t v92 = v36;
                  float v94 = v54;
                  float32x4_t v96 = v35;
                  uint64_t v71 = C3DHitTestResultCreate();
                  C3DHitTestResultSetNode(v71, *(CFTypeRef *)(a2 + 112));
                  uint64_t v72 = *(float32x4_t **)(v71 + 24);
                  if (v72 != ValueAtIndex)
                  {
                    if (v72)
                    {
                      CFRelease(v72);
                      *(void *)(v71 + 24) = 0;
                    }
                    if (ValueAtIndex) {
                      CFTypeRef v73 = CFRetain(ValueAtIndex);
                    }
                    else {
                      CFTypeRef v73 = 0;
                    }
                    *(void *)(v71 + 24) = v73;
                  }
                  float32x4_t v91 = vmulq_n_f32(v90, -v58);
                  float32x4_t v97 = vmlaq_n_f32(v96, v92, v94);
                  long long v85 = *(_OWORD *)(a2 + 128);
                  long long v86 = *(_OWORD *)(a2 + 144);
                  long long v87 = *(_OWORD *)(a2 + 176);
                  *(_OWORD *)(v71 + 144) = *(_OWORD *)(a2 + 160);
                  *(_OWORD *)(v71 + 160) = v87;
                  *(_OWORD *)(v71 + 112) = v85;
                  *(_OWORD *)(v71 + 128) = v86;
                  *(float32x4_t *)(v71 + 96) = v97;
                  simd_float4x4 v103 = __invert_f4(*(simd_float4x4 *)(a2 + 128));
                  float32x4_t v88 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v103.columns[1], *(float32x2_t *)v97.f32, 1), (float32x4_t)v103.columns[0], v97.f32[0]), (float32x4_t)v103.columns[2], v97, 2);
                  v103.columns[1] = (simd_float4)vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v103.columns[1], *(float32x2_t *)v91.f32, 1), (float32x4_t)v103.columns[0], v91.f32[0]), (float32x4_t)v103.columns[2], v91, 2);
                  v103.columns[0] = (simd_float4)vmulq_f32((float32x4_t)v103.columns[1], (float32x4_t)v103.columns[1]);
                  v103.columns[0].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v103.columns[0], 2), vadd_f32(*(float32x2_t *)v103.columns[0].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v103.columns[0].f32, 1))).u32[0];
                  v103.columns[2] = (simd_float4)vaddq_f32((float32x4_t)v103.columns[3], v88);
                  *(float32x2_t *)v103.columns[3].f32 = vrsqrte_f32((float32x2_t)v103.columns[0].u32[0]);
                  *(float32x2_t *)v103.columns[3].f32 = vmul_f32(*(float32x2_t *)v103.columns[3].f32, vrsqrts_f32((float32x2_t)v103.columns[0].u32[0], vmul_f32(*(float32x2_t *)v103.columns[3].f32, *(float32x2_t *)v103.columns[3].f32)));
                  *(simd_float4 *)(v71 + 64) = v103.columns[2];
                  *(float32x4_t *)(v71 + 80) = vmulq_n_f32((float32x4_t)v103.columns[1], vmul_f32(*(float32x2_t *)v103.columns[3].f32, vrsqrts_f32((float32x2_t)v103.columns[0].u32[0], vmul_f32(*(float32x2_t *)v103.columns[3].f32, *(float32x2_t *)v103.columns[3].f32))).f32[0]);
                  CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 312), (const void *)v71);
                  CFRelease((CFTypeRef)v71);
                  __int16 v84 = *(_WORD *)(a2 + 8);
                  if ((v84 & 0x100) != 0) {
                    *(float *)(a2 + 60) = v94;
                  }
LABEL_53:
                  char v13 = 1;
                  if ((v84 & 0x80) != 0) {
                    return v13 & 1;
                  }
                  goto LABEL_54;
                }
                uint64_t v59 = 0;
                long long v60 = (_OWORD *)(IOSurface + (v14 << 6));
                long long v61 = v60[1];
                long long v62 = v60[2];
                long long v63 = v60[3];
                v101[0] = *v60;
                v101[1] = v61;
                v101[2] = v62;
                v101[3] = v63;
                memset(&v99, 0, sizeof(v99));
                do
                {
                  v99.columns[v59] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v18, COERCE_FLOAT(v101[v59])), v19, *(float32x2_t *)&v101[v59], 1), v20, (float32x4_t)v101[v59], 2), v21, (float32x4_t)v101[v59], 3);
                  ++v59;
                }
                while (v59 != 4);
                simd_float4x4 v102 = __invert_f4(v99);
                float32x4_t v64 = *(float32x4_t *)(a2 + 16);
                float32x4_t v65 = *(float32x4_t *)(a2 + 32);
                float32x4_t v66 = vaddq_f32((float32x4_t)v102.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v102.columns[1], *(float32x2_t *)v64.f32, 1), (float32x4_t)v102.columns[0], v64.f32[0]), (float32x4_t)v102.columns[2], v64, 2));
                if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(a2 + 48))) >= 1.0e20)
                {
                  float32x4_t v74 = vaddq_f32(v64, v65);
                  float32x4_t v75 = vsubq_f32(vaddq_f32((float32x4_t)v102.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v102.columns[1], *(float32x2_t *)v74.f32, 1), (float32x4_t)v102.columns[0], v74.f32[0]), (float32x4_t)v102.columns[2], v74, 2)), v66);
                  float32x4_t v69 = vmulq_f32(v75, v75);
                  v69.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v69, 2), vadd_f32(*(float32x2_t *)v69.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v69.f32, 1))).u32[0];
                  float32x2_t v76 = vrsqrte_f32((float32x2_t)v69.u32[0]);
                  float32x2_t v77 = vmul_f32(v76, vrsqrts_f32((float32x2_t)v69.u32[0], vmul_f32(v76, v76)));
                  float32x4_t v70 = vmulq_n_f32(v75, vmul_f32(v77, vrsqrts_f32((float32x2_t)v69.u32[0], vmul_f32(v77, v77))).f32[0]);
                  v66.i32[3] = 1.0;
                  v69.i32[0] = 2139095040;
                }
                else
                {
                  float32x4_t v67 = vmlaq_laneq_f32(v64, v65, *(float32x4_t *)(a2 + 48), 3);
                  float32x4_t v68 = vsubq_f32(vaddq_f32((float32x4_t)v102.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v102.columns[1], *(float32x2_t *)v67.f32, 1), (float32x4_t)v102.columns[0], v67.f32[0]), (float32x4_t)v102.columns[2], v67, 2)), v66);
                  v66.i32[3] = 1.0;
                  float32x4_t v69 = vmulq_f32(v68, v68);
                  v69.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1))).u64[0];
                  v69.f32[0] = sqrtf(v69.f32[0]);
                  float32x4_t v70 = vdivq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 0));
                }
                float32x4_t v78 = v70;
                v70.i32[3] = 0;
                __asm { FMOV            V3.4S, #1.0 }
                float32x4_t v83 = vdivq_f32(_Q3, v78);
                v83.i32[3] = v69.i32[0];
                *(float32x4_t *)(a2 + 64) = v66;
                *(float32x4_t *)(a2 + 80) = v70;
                *(float32x4_t *)(a2 + 96) = v83;
                if (__ProcessSkinnedGeometryForJointIndex(OverrideMaterial, v7, v14, a2))
                {
                  __int16 v84 = *(_WORD *)(a2 + 8);
                  goto LABEL_53;
                }
              }
            }
          }
LABEL_54:
          if (++v14 == v12) {
            return v13 & 1;
          }
        }
      }
    }
  }
  char v13 = 0;
  return v13 & 1;
}

uint64_t __ProcessNode(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = (uint64_t)v1;
  uint64_t v4 = (uint64_t)v3;
  uint64_t v252 = *MEMORY[0x263EF8340];
  v1[14] = v3;
  v1[15] = 0;
  v1[24] = 0;
  WorldMatrix = C3DNodeGetWorldMatrix(v3);
  float32x4_t v6 = WorldMatrix[2];
  float32x4_t v7 = WorldMatrix[3];
  float32x4_t v224 = WorldMatrix[1];
  float32x4_t v230 = *WorldMatrix;
  *(float32x4_t *)(v2 + 128) = *WorldMatrix;
  *(float32x4_t *)(v2 + 144) = v224;
  float32x4_t v218 = v7;
  float32x4_t v221 = v6;
  *(float32x4_t *)(v2 + 160) = v6;
  *(float32x4_t *)(v2 + 176) = v7;
  uint64_t Skinner = C3DNodeGetSkinner(v4);
  if (Skinner)
  {
    uint64_t v9 = Skinner;
    uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry(v4);
    int EffectiveCalculationMode = C3DSkinnerGetEffectiveCalculationMode(v9, Geometry);
    if (C3DSkinnerCalculationModeUsesGPU(EffectiveCalculationMode))
    {
      return __ProcessSkinner(v9, v2);
    }
    *(double *)v13.columns[0].i64 = C3DSkinnerAdjustTransformIfUsesNodeTransformCalculationMode(v9, EffectiveCalculationMode, v230, v224, v221, v218);
  }
  else
  {
    v13.columns[1] = (simd_float4)v224;
    v13.columns[0] = (simd_float4)v230;
    v13.columns[3] = (simd_float4)v218;
    v13.columns[2] = (simd_float4)v221;
  }
  float v246 = 0.0;
  simd_float4x4 v254 = __invert_f4(v13);
  float32x4_t v14 = *(float32x4_t *)(v2 + 16);
  float32x4_t v15 = *(float32x4_t *)(v2 + 32);
  float32x4_t v16 = vaddq_f32((float32x4_t)v254.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v254.columns[1], *(float32x2_t *)v14.f32, 1), (float32x4_t)v254.columns[0], v14.f32[0]), (float32x4_t)v254.columns[2], v14, 2));
  if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(v2 + 48))) >= 1.0e20)
  {
    float32x4_t v21 = vaddq_f32(v14, v15);
    float32x4_t v22 = vsubq_f32(vaddq_f32((float32x4_t)v254.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v254.columns[1], *(float32x2_t *)v21.f32, 1), (float32x4_t)v254.columns[0], v21.f32[0]), (float32x4_t)v254.columns[2], v21, 2)), v16);
    float32x4_t v19 = vmulq_f32(v22, v22);
    v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v19, 2), vadd_f32(*(float32x2_t *)v19.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
    float32x2_t v23 = vrsqrte_f32((float32x2_t)v19.u32[0]);
    float32x2_t v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v23, v23)));
    float32x4_t v20 = vmulq_n_f32(v22, vmul_f32(v24, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v24, v24))).f32[0]);
    v16.i32[3] = 1.0;
    v19.i32[0] = 2139095040;
  }
  else
  {
    float32x4_t v17 = vmlaq_laneq_f32(v14, v15, *(float32x4_t *)(v2 + 48), 3);
    float32x4_t v18 = vsubq_f32(vaddq_f32((float32x4_t)v254.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v254.columns[1], *(float32x2_t *)v17.f32, 1), (float32x4_t)v254.columns[0], v17.f32[0]), (float32x4_t)v254.columns[2], v17, 2)), v16);
    v16.i32[3] = 1.0;
    float32x4_t v19 = vmulq_f32(v18, v18);
    v19.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u64[0];
    v19.f32[0] = sqrtf(v19.f32[0]);
    float32x4_t v20 = vdivq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0));
  }
  float32x4_t v25 = v20;
  v20.i32[3] = 0;
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v231 = _Q3;
  float32x4_t v29 = vdivq_f32(_Q3, v25);
  v29.i32[3] = v19.i32[0];
  *(float32x4_t *)(v2 + 64) = v16;
  *(float32x4_t *)(v2 + 80) = v20;
  *(float32x4_t *)(v2 + 96) = v29;
  if ((*(unsigned char *)(v2 + 9) & 4) == 0)
  {
    CFDictionaryRef Light = C3DNodeGetLight(v4);
    if (Light)
    {
      uint64_t v31 = (uint64_t)Light;
      if (C3DLightGetType((uint64_t)Light) == 6)
      {
        if (C3DLightGetDrawsArea(v31))
        {
          v32.i32[0] = *(_DWORD *)(v2 + 88);
          v33.i32[0] = 1.0;
          v34.i64[0] = 0x8000000080000000;
          v34.i64[1] = 0x8000000080000000;
          v33.i32[0] = vbslq_s8(v34, v33, v32).u32[0];
          if (*(float *)v32.i32 == 0.0) {
            *(float *)v33.i32 = 0.0;
          }
          float v35 = *(float *)v33.i32;
          int DoubleSided = C3DLightGetDoubleSided(v31);
          float32x4_t v242 = 0u;
          float32x4_t v243 = 0u;
          C3DLightGetAreaDescription(v31, (long long *)&v242);
          switch(v242.i8[0])
          {
            case 1:
              if (v35 > 0.0) {
                int v37 = 1;
              }
              else {
                int v37 = DoubleSided;
              }
              if (v37 == 1)
              {
                long long v247 = 0u;
                long long v248 = xmmword_20B5CB520;
                long long v249 = xmmword_20B5CB820;
                v250.i64[0] = v243.i64[0];
                float32x4_t v225 = *(float32x4_t *)(v2 + 80);
                float32x4_t v232 = *(float32x4_t *)(v2 + 64);
                int v38 = scn_rectangle_ray_intersection((uint64_t)&v247, &v246, v232, v225, *(__n128 *)(v2 + 96));
                v39.n128_u64[0] = 0;
                v39.n128_u32[3] = 0;
                float32x4_t v41 = v225;
                float32x4_t v40 = v232;
                if (v38)
                {
                  v39.n128_f32[2] = -v35;
                  float v42 = v246;
                  goto LABEL_56;
                }
              }
              break;
            case 2:
              if (v35 > 0.0) {
                int v43 = 1;
              }
              else {
                int v43 = DoubleSided;
              }
              if (v43 == 1)
              {
                float32x2_t v44 = *(float32x2_t *)v243.f32;
                float32x4_t v45 = *(float32x4_t *)(v2 + 80);
                float32x4_t v226 = v45;
                float32x4_t v233 = *(float32x4_t *)(v2 + 64);
                __n128 v46 = *(__n128 *)(v2 + 96);
                LODWORD(v247) = 0;
                int v47 = scn_plane_ray_intersection(0, 0x800000003F800000, (float *)&v247, v233, v45, v46);
                float32x4_t v41 = v226;
                float32x4_t v40 = v233;
                if (v47)
                {
                  float v42 = *(float *)&v247;
                  float32x4_t v48 = vmlaq_n_f32(v233, v226, *(float *)&v247);
                  int32x4_t v49 = (int32x4_t)vmulq_f32(v48, (float32x4_t)xmmword_20B5CB820);
                  int32x4_t v50 = (int32x4_t)vmulq_f32(v48, (float32x4_t)xmmword_20B5CB7D0);
                  *(float32x2_t *)v50.i8 = vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v49, 2), vadd_f32(*(float32x2_t *)v49.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v49.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1)))),
                                             v44);
                  if (vaddv_f32(vmul_f32(*(float32x2_t *)v50.i8, *(float32x2_t *)v50.i8)) <= 1.0)
                  {
                    v39.n128_u64[0] = 0;
                    v39.n128_u32[3] = 0;
                    v39.n128_f32[2] = -v35;
                    float v246 = *(float *)&v247;
                    goto LABEL_56;
                  }
                }
              }
              break;
            case 3:
              float32x4_t v51 = v243;
              float32x4_t v40 = *(float32x4_t *)(v2 + 64);
              float32x4_t v41 = *(float32x4_t *)(v2 + 80);
              float32x4_t v52 = vdivq_f32(v231, v243);
              float32x4_t v53 = (float32x4_t)v52.u32[0];
              v54.i32[0] = 0;
              v54.i64[1] = 0;
              v54.i32[1] = v52.i32[1];
              v55.i64[0] = 0;
              v55.i64[1] = v52.u32[2];
              float32x4_t v56 = vaddq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v54.u64[0], *(float32x2_t *)v40.f32, 1), (float32x4_t)v52.u32[0], v40.f32[0]), v55, v40, 2), (float32x4_t)0);
              if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(v2 + 96))) >= 1.0e20)
              {
                float32x4_t v85 = vaddq_f32(v40, v41);
                float32x4_t v86 = vsubq_f32(vaddq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v54, *(float32x2_t *)v85.f32, 1), (float32x4_t)v52.u32[0], v85.f32[0]), v55, v85, 2), (float32x4_t)0), v56);
                int32x4_t v87 = (int32x4_t)vmulq_f32(v86, v86);
                v87.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v87, 2), vadd_f32(*(float32x2_t *)v87.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 1))).u32[0];
                float32x2_t v88 = vrsqrte_f32((float32x2_t)v87.u32[0]);
                float32x2_t v89 = vmul_f32(v88, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v88, v88)));
                float32x4_t v57 = vmulq_n_f32(v86, vmul_f32(v89, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v89, v89))).f32[0]);
                v56.i32[3] = 1.0;
                v57.i32[3] = 0;
                float v58 = INFINITY;
              }
              else
              {
                float32x4_t v227 = *(float32x4_t *)(v2 + 80);
                float32x4_t v234 = *(float32x4_t *)(v2 + 64);
                float32x4_t v219 = v54;
                float32x4_t v222 = (float32x4_t)v52.u32[0];
                float32x4_t v215 = v243;
                float32x4_t v216 = v55;
                scn_ray_create_segment();
                float32x4_t v51 = v215;
                float32x4_t v55 = v216;
                float32x4_t v54 = v219;
                float32x4_t v53 = v222;
                float32x4_t v41 = v227;
                float32x4_t v40 = v234;
                float32x4_t v56 = v59;
              }
              float32x4_t v90 = vmulq_f32(v56, v57);
              LODWORD(v91) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 2), vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v90.f32, 1))).u32[0];
              float32x4_t v92 = vmulq_f32(v56, v56);
              float v93 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 2), vaddq_f32(v92, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v92.f32, 1))).f32[0]+ -1.0;
              if (v93 <= 0.0 || v91 <= 0.0)
              {
                float v94 = -(float)(v93 - (float)(v91 * v91));
                if (v94 >= 0.0)
                {
                  float v95 = sqrtf(v94);
                  float v96 = (float)-v91 - v95;
                  float v97 = v91 + v95;
                  if (v96 >= 0.0) {
                    float v97 = v96;
                  }
                  if (v97 <= v58)
                  {
                    LODWORD(v98) = 0;
                    HIDWORD(v98) = v51.i32[1];
                    v99.i64[0] = 0;
                    v99.i64[1] = v51.u32[2];
                    float32x4_t v100 = vmlaq_f32(v56, (float32x4_t)0, v57);
                    float32x4_t v101 = vsubq_f32(vaddq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.u32[0], v100.f32[0]), (float32x4_t)v98, *(float32x2_t *)v100.f32, 1), v99, v100, 2), (float32x4_t)0), v40);
                    float32x4_t v102 = vmulq_f32(v101, v101);
                    float v42 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 2), vaddq_f32(v102, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v102.f32, 1))).f32[0]);
                    float v246 = v42;
                    float32x4_t v103 = vaddq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v53, v100.f32[0]), v54, *(float32x2_t *)v100.f32, 1), v55, v100, 2), (float32x4_t)0);
                    int32x4_t v104 = (int32x4_t)vmulq_f32(v103, v103);
                    v104.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v104, 2), vadd_f32(*(float32x2_t *)v104.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v104.i8, 1))).u32[0];
                    *(float32x2_t *)v100.f32 = vrsqrte_f32((float32x2_t)v104.u32[0]);
                    *(float32x2_t *)v100.f32 = vmul_f32(*(float32x2_t *)v100.f32, vrsqrts_f32((float32x2_t)v104.u32[0], vmul_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v100.f32)));
                    __n128 v39 = (__n128)vmulq_n_f32(v103, vmul_f32(*(float32x2_t *)v100.f32, vrsqrts_f32((float32x2_t)v104.u32[0], vmul_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v100.f32))).f32[0]);
                    goto LABEL_56;
                  }
                }
              }
              break;
            case 4:
              if (v35 > 0.0) {
                int v60 = 1;
              }
              else {
                int v60 = DoubleSided;
              }
              if (v60 == 1)
              {
                uint64_t v61 = v243.i64[1];
                uint64_t v62 = v243.u8[0];
                float32x4_t v63 = *(float32x4_t *)(v2 + 64);
                float32x4_t v64 = *(float32x4_t *)(v2 + 80);
                __n128 v65 = *(__n128 *)(v2 + 96);
                LODWORD(v247) = 0;
                float32x4_t v228 = v64;
                float32x4_t v235 = v63;
                if (scn_plane_ray_intersection(0, 0x80000000BF800000, (float *)&v247, v63, v64, v65))
                {
                  float v42 = *(float *)&v247;
                  if (v62)
                  {
                    uint64_t v66 = 0;
                    char v67 = 0;
                    v39.n128_u64[0] = 0;
                    v39.n128_u32[3] = 0;
                    v39.n128_f32[2] = -v35;
                    float32x4_t v41 = v228;
                    float32x4_t v40 = v235;
                    float32x4_t v68 = vmlaq_n_f32(v235, v228, *(float *)&v247);
                    int8x16_t v69 = (int8x16_t)vmulq_f32(v68, (float32x4_t)xmmword_20B5CB8E0);
                    int8x16_t v70 = (int8x16_t)vmulq_f32(v68, (float32x4_t)xmmword_20B5CB7D0);
                    float32x2_t v71 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v69.i8, *(int32x2_t *)v70.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v69.i8, *(int32x2_t *)v70.i8)));
                    v72.i32[1] = v71.i32[1];
                    v72.i32[0] = -859915232;
                    int32x2_t v73 = (int32x2_t)vsub_f32(v72, v71);
                    float v74 = -*(float *)&v73.i32[1];
                    float32x2_t v75 = (float32x2_t)vdup_lane_s32(v73, 0);
                    do
                    {
                      float32x2_t v76 = *(float32x2_t *)(v61 + 8 * v66);
                      if (v62 - 1 == v66) {
                        uint64_t v77 = 0;
                      }
                      else {
                        uint64_t v77 = v66 + 1;
                      }
                      float32x2_t v78 = *(float32x2_t *)(v61 + 8 * v77);
                      float32x2_t v79 = vsub_f32(v71, v76);
                      float32x2_t v80 = vsub_f32(v72, v76);
                      float32x2_t v81 = vsub_f32(v78, v76);
                      if (vmlas_n_f32((float)-v81.f32[1] * v79.f32[0], v79.f32[1], v81.f32[0]) < 0.0 == vmlas_n_f32((float)-v81.f32[1] * v80.f32[0], v80.f32[1], v81.f32[0]) >= 0.0)
                      {
                        int32x2_t v82 = (int32x2_t)vsub_f32(v78, v71);
                        int32x2_t v83 = (int32x2_t)vsub_f32(v76, v71);
                        int32x2_t v84 = vcgez_f32(vmla_f32(vmul_n_f32((float32x2_t)vzip1_s32(v83, v82), v74), (float32x2_t)vzip2_s32(v83, v82), v75));
                        v67 -= veor_s8((int8x8_t)v84, (int8x8_t)vdup_lane_s32(v84, 1)).u8[0];
                      }
                      ++v66;
                    }
                    while (v62 != v66);
                    float v246 = *(float *)&v247;
                    if (v67) {
LABEL_56:
                    }
                      __AddLocalResult(v2, 0, 0, 0, 0, v42, vmlaq_n_f32(v40, v41, v42), v39);
                  }
                  else
                  {
                    float v246 = *(float *)&v247;
                  }
                }
              }
              break;
            default:
              break;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)(v4 + 221) & 0x10) != 0)
  {
    float32x4_t v142 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)(v2 + 144), *(float32x2_t *)(v2 + 288), 1), *(float32x4_t *)(v2 + 128), COERCE_FLOAT(*(_OWORD *)(v2 + 288))), *(float32x4_t *)(v2 + 160), *(float32x4_t *)(v2 + 288), 2);
    int32x4_t v143 = (int32x4_t)vmulq_f32(v142, v142);
    v143.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v143, 2), vadd_f32(*(float32x2_t *)v143.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v143.i8, 1))).u32[0];
    float32x2_t v144 = vrsqrte_f32((float32x2_t)v143.u32[0]);
    float32x2_t v145 = vmul_f32(v144, vrsqrts_f32((float32x2_t)v143.u32[0], vmul_f32(v144, v144)));
    float32x4_t v146 = vmulq_n_f32(v142, vmul_f32(v145, vrsqrts_f32((float32x2_t)v143.u32[0], vmul_f32(v145, v145))).f32[0]);
    float32x4_t v147 = vmulq_f32(*(float32x4_t *)(v2 + 176), v146);
    float32x4_t v148 = v146;
    v148.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v147, 2), vaddq_f32(v147, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v147.f32, 1))).f32[0];
    int8x16_t v149 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v2 + 32), v148);
    float v150 = vaddv_f32(vadd_f32(*(float32x2_t *)v149.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v149, v149, 8uLL)));
    if (v150 == 0.0) {
      return 0;
    }
    int8x16_t v151 = (int8x16_t)vmulq_f32(v148, *(float32x4_t *)(v2 + 16));
    float v152 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v151.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v151, v151, 8uLL)))
         / v150;
    if (v152 < 0.0 || v152 > *(float *)(v2 + 60)) {
      return 0;
    }
    __n128 v236 = (__n128)v146;
    float v246 = v152;
  }
  else
  {
    float32x4_t v242 = 0u;
    float32x4_t v243 = 0u;
    if ((C3DNodeGetLocalBoundingBox(v4, &v242) & 1) == 0) {
      return 0;
    }
    float32x4_t v105 = *(float32x4_t *)(v2 + 128);
    float32x4_t v106 = *(float32x4_t *)(v2 + 144);
    float32x4_t v107 = *(float32x4_t *)(v2 + 160);
    int8x16_t v108 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v107, (int32x4_t)v107), (int8x16_t)v107, 0xCuLL), vnegq_f32(v106)), v107, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v106, (int32x4_t)v106), (int8x16_t)v106, 0xCuLL));
    float32x4_t v109 = vmulq_f32(v105, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v108, (int32x4_t)v108), v108, 0xCuLL));
    float32x4_t v110 = vaddq_f32(*(float32x4_t *)(v2 + 176), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v106, *(float32x2_t *)v242.f32, 1), v105, v242.f32[0]), v107, v242, 2));
    _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v109, 2), vaddq_f32(v109, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.f32, 1))).f32[0] < 0.0;
    float v111 = 1.0;
    float32x4_t v112 = vmulq_f32(v105, v105);
    float32x4_t v115 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 2), vaddq_f32(v112, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.f32, 1)));
    float32x4_t v113 = vmulq_f32(v106, v106);
    v115.f32[0] = sqrtf(v115.f32[0]);
    float32x4_t v114 = vmulq_f32(v107, v107);
    v115.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 2), vaddq_f32(v113, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v113.f32, 1))).f32[0]);
    v115.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 2), vaddq_f32(v114, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1))).f32[0]);
    if (_NF) {
      float v111 = -1.0;
    }
    float32x4_t v116 = vmulq_n_f32(v115, v111);
    int32x4_t v117 = (int32x4_t)vdivq_f32(v105, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v116.f32, 0));
    int32x4_t v118 = (int32x4_t)vdivq_f32(v106, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v116.f32, 1));
    int32x4_t v119 = (int32x4_t)vdivq_f32(v107, (float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 2));
    float32x4_t v120 = vmulq_f32(v243, v116);
    float32x4_t v121 = *(float32x4_t *)(v2 + 32);
    float32x4_t v122 = vsubq_f32(v110, *(float32x4_t *)(v2 + 16));
    float32x4_t v123 = (float32x4_t)vzip1q_s32(vzip1q_s32(v117, v119), v118);
    float32x4_t v124 = (float32x4_t)vtrn2q_s32(v117, v118);
    v124.i32[2] = v119.i32[1];
    float32x4_t v125 = (float32x4_t)vzip1q_s32(vzip2q_s32(v117, v119), vdupq_laneq_s32(v118, 2));
    float32x4_t v126 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v124, *(float32x2_t *)v122.f32, 1), v123, v122.f32[0]), v125, v122, 2);
    float32x4_t v127 = vaddq_f32(v120, v126);
    float32x4_t v128 = vsubq_f32(v126, v120);
    v120.i32[3] = v243.i32[3];
    long long v248 = (__int128)v117;
    long long v249 = (__int128)v118;
    int32x4_t v250 = v119;
    float32x4_t v251 = v120;
    float32x4_t v129 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v124, *(float32x2_t *)v121.f32, 1), v123, v121.f32[0]), v125, v121, 2);
    float32x4_t v130 = vdivq_f32(v127, v129);
    v130.i32[3] = 0;
    float32x4_t v131 = vdivq_f32(v128, v129);
    v131.i32[3] = 0;
    float32x4_t v132 = vminnmq_f32(v130, v131);
    float32x4_t v133 = vmaxnmq_f32(v130, v131);
    if (v132.f32[0] < v132.f32[2]) {
      float v134 = v132.f32[2];
    }
    else {
      float v134 = v132.f32[0];
    }
    if (v134 < v132.f32[1]) {
      float v134 = v132.f32[1];
    }
    float v135 = v133.f32[2];
    if (v133.f32[0] <= v133.f32[2]) {
      float v135 = v133.f32[0];
    }
    v133.i32[0] = v133.i32[1];
    if (v135 <= v133.f32[1]) {
      v133.f32[0] = v135;
    }
    if (v133.f32[0] < v134) {
      return 0;
    }
    _NF = v133.f32[0] >= v246 && v134 < *(float *)(v2 + 60);
    if (!_NF) {
      return 0;
    }
    LODWORD(v137) = 2 * (v132.f32[0] <= v132.f32[2]);
    if (v132.f32[1] > v132.f32[2]) {
      unsigned int v138 = 1;
    }
    else {
      unsigned int v138 = 2;
    }
    if (v132.f32[0] <= v132.f32[1]) {
      uint64_t v137 = v138;
    }
    else {
      uint64_t v137 = v137;
    }
    if (v134 >= v246) {
      float v139 = v134;
    }
    else {
      float v139 = v133.f32[0];
    }
    float v246 = v139;
    float32x4_t v140 = (float32x4_t)*(&v248 + v137);
    float32x4_t v238 = v129;
    v129.i32[0] = *(_DWORD *)((unint64_t)&v238 | (4 * v137));
    v130.i32[0] = 1.0;
    v141.i64[0] = 0x8000000080000000;
    v141.i64[1] = 0x8000000080000000;
    v130.i32[0] = vbslq_s8(v141, (int8x16_t)v130, (int8x16_t)v129).u32[0];
    if (v129.f32[0] == 0.0) {
      v130.f32[0] = 0.0;
    }
    __n128 v236 = (__n128)vmulq_n_f32(v140, -v130.f32[0]);
  }
  uint64_t v155 = C3DNodeGetGeometry(v4);
  if (!v155) {
    goto LABEL_172;
  }
  uint64_t v156 = v155;
  uint64_t Mesh = C3DGeometryGetMesh(v155);
  if (!Mesh) {
    goto LABEL_172;
  }
  uint64_t v158 = Mesh;
  CFArrayRef ElementsCount = C3DMeshGetElementsCount(Mesh);
  if ((uint64_t)ElementsCount < 1) {
    goto LABEL_172;
  }
  CFArrayRef v160 = ElementsCount;
  ElementAtuint64_t Index = C3DMeshGetElementAtIndex(v158, 0, 0);
  char Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
  BOOL v163 = C3DMeshElementTypeDefinesSurface(Type);
  BOOL v164 = 0;
  if (!v163)
  {
    CFIndex v165 = 1;
    do
    {
      CFIndex v166 = v165;
      if (v160 == (const __CFArray *)v165) {
        break;
      }
      v167 = C3DMeshGetElementAtIndex(v158, v165, 0);
      char v168 = C3DMeshElementGetType((uint64_t)v167);
      BOOL v169 = C3DMeshElementTypeDefinesSurface(v168);
      CFIndex v165 = v166 + 1;
    }
    while (!v169);
    BOOL v164 = v166 >= (uint64_t)v160;
  }
  if (v164 || (*(_WORD *)(v2 + 8) & 0x40) != 0 || (*(unsigned char *)(v4 + 221) & 0x10) != 0)
  {
LABEL_172:
    __AddWorldResult(v2, 0, 0, 0, 0, v246, vmlaq_n_f32(*(float32x4_t *)(v2 + 16), *(float32x4_t *)(v2 + 32), v246), v236);
    return 1;
  }
  MaterialsCFIndex Count = C3DGeometryGetMaterialsCount(v156);
  PositionSource = C3DMeshGetPositionSource(v158, 0);
  if (!PositionSource) {
    return 0;
  }
  uint64_t v172 = (uint64_t)PositionSource;
  uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(v158, 0, 0);
  uint64_t Content = C3DMeshSourceGetContent(v172);
  if (!Content) {
    return 0;
  }
  uint64_t v177 = v174;
  uint64_t v223 = v174 & 0xFFFFF000;
  if ((v174 & 0xFFFFF000) == 0)
  {
    C3DMeshSourceContentClassifyRay(Content, v174, &v247, *(float32x4_t *)(v2 + 64), *(__n128 *)(v2 + 80), *(double *)(v2 + 96), v175, v176);
    *(void *)(v2 + 304) = &v247;
  }
  CFArrayRef v178 = C3DMeshGetElementsCount(v158);
  if ((uint64_t)v178 < 1) {
    return 0;
  }
  CFArrayRef v179 = v178;
  CFIndex v180 = 0;
  uint64_t v229 = v177;
  uint64_t v217 = v177 & 0xFF000000000000;
  CFArrayRef v214 = MaterialsCount;
  BOOL v154 = 1;
  uint64_t v220 = ChannelForSourceWithSemanticAtIndex;
  while (1)
  {
    *(void *)(v2 + 192) = v180;
    v181 = C3DMeshGetElementAtIndex(v158, v180, 0);
    uint64_t v245 = 0;
    float32x4_t v243 = 0u;
    long long v244 = 0u;
    float32x4_t v242 = 0u;
    C3DMeshElementGetContent((uint64_t)v181, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v242);
    if (C3DMeshElementGetMTLBuffer((uint64_t)v181) || !C3DMeshElementTypeDefinesSurface(v243.i8[10])) {
      goto LABEL_170;
    }
    int IsDoubleSided = 0;
    if ((*(_WORD *)(v2 + 8) & 8) != 0)
    {
      int CullMode = 0;
      if ((uint64_t)MaterialsCount >= 1)
      {
        MaterialAtuint64_t Index = C3DGeometryGetMaterialAtIndex(v156, v180 % (uint64_t)MaterialsCount);
        int IsDoubleSided = C3DMaterialIsDoubleSided((uint64_t)MaterialAtIndex);
        uint64_t v185 = (uint64_t)MaterialAtIndex;
        uint64_t ChannelForSourceWithSemanticAtIndex = v220;
        int CullMode = C3DMaterialGetCullMode(v185);
      }
    }
    else
    {
      int CullMode = 0;
    }
    *(unsigned char *)(v2 + 272) = IsDoubleSided;
    *(unsigned char *)(v2 + 273) = CullMode == 1;
    float32x4_t v186 = v243;
    *(float32x4_t *)(v2 + 216) = v242;
    *(float32x4_t *)(v2 + 232) = v186;
    *(_OWORD *)(v2 + 248) = v244;
    *(void *)(v2 + 264) = v245;
    *(void *)(v2 + 200) = Content;
    *(void *)(v2 + 208) = v229;
    BOOL v190 = v217 == 0x1000000000000 && v243.u8[10] == 0 && v243.u8[11] == 2 && CullMode == 0;
    if (!v223)
    {
      v211 = __ProcessTriangleRange_Mask;
      if (v243.u8[10] == 4) {
        v211 = __ProcessPrimitiveRange_Mask;
      }
      if (v190 && !((*(_WORD *)(v2 + 8) & 8) != 0 ? IsDoubleSided : 1)) {
        v211 = __ProcessTriangleRange_Mask_Ind16VrtFloat3CullBack;
      }
      ((void (*)(void, void, uint64_t))v211)(0, v242.u32[2], v2);
      goto LABEL_170;
    }
    if (v243.u8[10] == 4) {
      v191 = (unsigned int (*)(void))__ProcessPrimitiveRange_Generic;
    }
    else {
      v191 = (unsigned int (*)(void))__ProcessTriangleRange_Generic;
    }
    if (v190 && !((*(_WORD *)(v2 + 8) & 8) != 0 ? IsDoubleSided : 1)) {
      v191 = (unsigned int (*)(void))__ProcessTriangleRange_Ind16VrtFloat3CullBack;
    }
    if (v242.i32[2] < 0x41u)
    {
      int v213 = ((uint64_t (*)(void))v191)(0);
      uint64_t ChannelForSourceWithSemanticAtIndex = v220;
      if (v213) {
        return v154;
      }
      goto LABEL_170;
    }
    unsigned int v241 = 0;
    v239[0] = (__int128)v242;
    v239[1] = (__int128)v243;
    v239[2] = v244;
    uint64_t v240 = v245;
    uint64_t PrimitiveGroupBoundingBoxes = C3DMeshElementGetPrimitiveGroupBoundingBoxes((uint64_t)v181, v239, Content, v229, &v241);
    if (v241) {
      break;
    }
LABEL_159:
    MaterialsCFIndex Count = v214;
    uint64_t ChannelForSourceWithSemanticAtIndex = v220;
LABEL_170:
    BOOL v154 = ++v180 < (uint64_t)v179;
    if ((const __CFArray *)v180 == v179) {
      return v154;
    }
  }
  uint64_t v194 = PrimitiveGroupBoundingBoxes;
  uint64_t v195 = 0;
  uint64_t v196 = 32 * v241;
  while (1)
  {
    float32x4_t v197 = *(float32x4_t *)(v194 + v195);
    float32x4_t v198 = *(float32x4_t *)(v194 + v195 + 16);
    float32x4_t v199 = *(float32x4_t *)(v2 + 64);
    float32x4_t v200 = *(float32x4_t *)(v2 + 96);
    float32x4_t v201 = vsubq_f32(v197, v198);
    float32x4_t v202 = vaddq_f32(v197, v198);
    float32x4_t v203 = vmulq_f32(v200, vsubq_f32(v201, v199));
    float32x4_t v204 = vmulq_f32(v200, vsubq_f32(v202, v199));
    v203.i32[3] = 0;
    v204.i32[3] = 0;
    float32x4_t v205 = vminnmq_f32(v203, v204);
    float32x4_t v206 = vmaxnmq_f32(v203, v204);
    float v207 = v205.f32[2];
    if (v205.f32[0] >= v205.f32[2]) {
      float v207 = v205.f32[0];
    }
    if (v207 < v205.f32[1]) {
      float v207 = v205.f32[1];
    }
    float v208 = v206.f32[2];
    if (v206.f32[0] <= v206.f32[2]) {
      float v208 = v206.f32[0];
    }
    v206.i32[0] = v206.i32[1];
    if (v208 <= v206.f32[1]) {
      v206.f32[0] = v208;
    }
    uint64_t v209 = v195 + 32;
    BOOL v210 = v206.f32[0] >= v207 && v207 < v200.f32[3];
    if (v210 && v191()) {
      return v154;
    }
    uint64_t v195 = v209;
    if (v196 == v209) {
      goto LABEL_159;
    }
  }
}

uint64_t scn_rectangle_ray_intersection(uint64_t a1, float *a2, float32x4_t a3, float32x4_t a4, __n128 a5)
{
  float32x4_t v5 = *(float32x4_t *)(a1 + 16);
  float32x4_t v6 = vmulq_f32(v5, *(float32x4_t *)a1);
  float32_t v7 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0];
  float32x4_t v8 = v5;
  v8.f32[3] = v7;
  int8x16_t v9 = (int8x16_t)vmulq_f32(a4, v8);
  float v10 = vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
  if (v10 == 0.0) {
    return 0;
  }
  int8x16_t v11 = (int8x16_t)vmulq_f32(a3, v8);
  float v12 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL))) / v10;
  if (v12 < 0.0 || v12 > a5.n128_f32[3]) {
    return 0;
  }
  float32x4_t v14 = vmlaq_n_f32(a3, a4, v12);
  float32x4_t v15 = *(float32x4_t *)(a1 + 32);
  int32x4_t v16 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), vnegq_f32(v5)), v15, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL));
  float32x4_t v17 = vsubq_f32(v14, *(float32x4_t *)a1);
  int8x16_t v18 = (int8x16_t)vmulq_f32(v15, v17);
  float32x4_t v19 = vmulq_f32(v17, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL));
  v20.i32[0] = vdup_lane_s32(*(int32x2_t *)v18.i8, 1).u32[0];
  float32x2_t v21 = (float32x2_t)__PAIR64__(v19.u32[0], v18.u32[0]);
  v18.i32[0] = vextq_s8(v18, v18, 8uLL).u32[0];
  v20.i32[1] = v19.i32[1];
  v18.i32[1] = v19.i32[2];
  float32x2_t v22 = vadd_f32(*(float32x2_t *)v18.i8, vadd_f32(v21, v20));
  float32x2_t v23 = *(float32x2_t *)(a1 + 48);
  uint32x2_t v24 = (uint32x2_t)vcgt_f32(vneg_f32(v23), v22);
  if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  uint32x2_t v25 = (uint32x2_t)vcgt_f32(v22, v23);
  if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  if (a2) {
    *a2 = v12;
  }
  return 1;
}

uint64_t C3DSceneCreateHitTestResultsWithSegment(__n128 *a1, float32x4_t *a2, const __CFDictionary *a3)
{
  if (!a1 && (float32x4_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float32x4_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DSceneCreateHitTestResultsWithSegment_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  memset(__src, 0, 432);
  C3DHitTestContextFillOptionsFromDictionary((uint64_t)__src, a3);
  C3DSceneGetUpAxis(a1, (__n128 *)&__src[18]);
  *((void *)&__src[19] + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  float32x4_t v22 = *a2;
  float32x4_t v23 = vsubq_f32(a2[1], *a2);
  if ((BYTE8(__src[0]) & 2) != 0)
  {
    v22.i32[3] = 1.0;
    float32x4_t v27 = vmulq_f32(v23, v23);
    v27.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u64[0];
    v27.f32[0] = sqrtf(v27.f32[0]);
    float32x4_t v26 = vdivq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0));
  }
  else
  {
    float32x4_t v27 = vmulq_f32(v23, v23);
    v27.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v27, 2), vadd_f32(*(float32x2_t *)v27.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
    float32x2_t v24 = vrsqrte_f32((float32x2_t)v27.u32[0]);
    float32x2_t v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v24, v24)));
    float32x4_t v26 = vmulq_n_f32(v23, vmul_f32(v25, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v25, v25))).f32[0]);
    v22.i32[3] = 1.0;
    v27.i32[0] = 2139095040;
  }
  float32x4_t v28 = v26;
  v26.i32[3] = 0;
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v34 = vdivq_f32(_Q4, v28);
  v34.i32[3] = v27.i32[0];
  __src[1] = v22;
  __src[2] = v26;
  __src[3] = v34;
  uint64_t RootNode = C3DSceneGetRootNode((uint64_t)a1);
  if (a3) {
    Value = CFDictionaryGetValue(a3, @"kHitTestRootNode");
  }
  else {
    Value = 0;
  }
  if (!Value) {
    Value = (const void *)RootNode;
  }
  if ((BYTE8(__src[0]) & 1) != 0 && Value == (const void *)RootNode)
  {
    v66.n128_u64[0] = 0;
    long long v64 = 0u;
    long long v65 = 0u;
    v75[0] = MEMORY[0x263EF8330];
    v75[1] = 3221225472;
    v75[2] = __C3DSceneCreateHitTestResultsWithSegment_block_invoke;
    v75[3] = &__block_descriptor_40_e23_v24__0_____C3DNode_8q16l;
    v75[4] = __src;
    C3DCullingSystemQueryMake((uint64_t)v75, (uint64_t)&v64);
    *(void *)&long long v64 = *(void *)&__src[0];
    BYTE12(v65) = BYTE9(__src[0]) & 1;
    if ((BYTE8(__src[0]) & 0x20) != 0) {
      DWORD1(v65) |= 1u;
    }
    DWORD2(v65) = BYTE10(__src[0]);
    uint64_t CullingSystem = C3DSceneGetCullingSystem((uint64_t)a1);
    C3DCullingSystemRayIntersect(CullingSystem);
  }
  else if (BYTE8(__src[0]))
  {
    *(void *)&long long v64 = MEMORY[0x263EF8330];
    *((void *)&v64 + 1) = 3221225472;
    *(void *)&long long v65 = ____ProcessHierarchy_block_invoke;
    *((void *)&v65 + 1) = &__block_descriptor_40_e315_q16__0____C3DNode____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DNode_____C3DNode_____C3DNode_i____C3DMatrix4x4__16f__4_____4__________C3DMatrix4x4_BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1______SS_I_________C3DGeometry_____C3DDeformerStack_f_____8l;
    v66.n128_u64[0] = (unint64_t)__src;
    C3DNodeApplyHierarchy((uint64_t)Value, (uint64_t)&v64);
  }
  else
  {
    __ProcessNode((uint64_t)Value);
  }
  uint64_t Count = CFArrayGetCount(*((CFArrayRef *)&__src[19] + 1));
  __int16 v39 = WORD4(__src[0]);
  if ((BYTE8(__src[0]) & 4) != 0)
  {
    v40.length = Count;
    if (Count >= 2)
    {
      v40.location = 0;
      CFArraySortValues(*((CFMutableArrayRef *)&__src[19] + 1), v40, (CFComparatorFunction)_C3DHitTestSortFunc, a2);
      __int16 v39 = WORD4(__src[0]);
    }
  }
  if ((v39 & 0x200) != 0 && *(void *)&__src[26])
  {
    long long v74 = 0uLL;
    C3DColor4Make((float *)&v74, 1.0, 0.0, 0.0, 1.0);
    long long v73 = 0uLL;
    C3DColor4Make((float *)&v73, 0.0, 1.0, 0.0, 1.0);
    v72[1] = 0;
    v72[0] = 0;
    C3DColor4Make((float *)v72, 0.0, 0.0, 1.0, 1.0);
    C3DAuthoringEnvironmentBeginTimedRecord(*(uint64_t *)&__src[26], 5.0);
    CFIndex v41 = CFArrayGetCount(*((CFArrayRef *)&__src[19] + 1));
    if (v41 >= 1)
    {
      CFIndex v42 = v41;
      for (CFIndex i = 0; i != v42; ++i)
      {
        ValueAtuint64_t Index = (float32x4_t *)CFArrayGetValueAtIndex(*((CFArrayRef *)&__src[19] + 1), i);
        uint64_t v68 = 0;
        int8x16_t v69 = &v68;
        uint64_t v70 = 0x2020000000;
        int v71 = 1065353216;
        uint64_t v45 = ValueAtIndex[1].i64[0];
        if (v45)
        {
          uint64_t Geometry = C3DNodeGetGeometry(v45);
          if (Geometry)
          {
            uint64_t Mesh = C3DGeometryGetMesh(Geometry);
            uint64_t v48 = Mesh;
            if (Mesh)
            {
              uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 0, 0);
              PositionSource = C3DMeshGetPositionSource(v48, 0);
              if (PositionSource)
              {
                ElementAtuint64_t Index = C3DMeshGetElementAtIndex(v48, ValueAtIndex[2].i64[0], 0);
                if (ElementAtIndex)
                {
                  uint64_t v67 = 0;
                  long long v65 = 0u;
                  __n128 v66 = 0u;
                  long long v64 = 0u;
                  C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v64);
                  v63[0] = ValueAtIndex[2].i64[1];
                  v63[1] = 1;
                  *(void *)&long long v65 = v63;
                  WORD4(v65) = 1;
                  v57[0] = MEMORY[0x263EF8330];
                  v57[1] = 3221225472;
                  v57[2] = __C3DSceneCreateHitTestResultsWithSegment_block_invoke_2;
                  v57[3] = &unk_264004F50;
                  uint64_t v61 = PositionSource;
                  int v60 = &v68;
                  memcpy(v58, __src, sizeof(v58));
                  uint64_t v62 = ValueAtIndex;
                  long long v59 = v74;
                  v55[0] = v64;
                  v55[1] = v65;
                  v55[2] = v66;
                  uint64_t v56 = v67;
                  C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges((uint64_t)v55, (uint64_t)v57, v66);
                }
              }
            }
          }
        }
        float32x4_t v52 = ValueAtIndex[6];
        v52.i32[3] = *((_DWORD *)v69 + 6);
        C3DAuthoringEnvironmentAppendDebugBoundingSphere(*(uint64_t *)&__src[26], ValueAtIndex[6].i64[0], v52.i64[1], 0, &v73);
        f32 = ValueAtIndex[7].f32;
        simd_float4x4 v78 = (simd_float4x4)vld4q_f32(f32);
        simd_float4x4 v77 = __invert_f4(v78);
        v77.columns[1] = (simd_float4)vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v77.columns[1], *(float32x2_t *)ValueAtIndex[5].f32, 1), (float32x4_t)v77.columns[0], COERCE_FLOAT(*(_OWORD *)&ValueAtIndex[5])), (float32x4_t)v77.columns[2], ValueAtIndex[5], 2);
        v77.columns[0] = (simd_float4)vmulq_f32((float32x4_t)v77.columns[1], (float32x4_t)v77.columns[1]);
        v77.columns[0].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v77.columns[0], 2), vadd_f32(*(float32x2_t *)v77.columns[0].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v77.columns[0].f32, 1))).u32[0];
        *(float32x2_t *)v77.columns[2].f32 = vrsqrte_f32((float32x2_t)v77.columns[0].u32[0]);
        *(float32x2_t *)v77.columns[2].f32 = vmul_f32(*(float32x2_t *)v77.columns[2].f32, vrsqrts_f32((float32x2_t)v77.columns[0].u32[0], vmul_f32(*(float32x2_t *)v77.columns[2].f32, *(float32x2_t *)v77.columns[2].f32)));
        C3DAuthoringEnvironmentAppendDebugRay(*(uint64_t *)&__src[26], 0, (float *)v72, ValueAtIndex[6], vaddq_f32(ValueAtIndex[6], vmulq_n_f32((float32x4_t)v77.columns[1], vmul_f32(*(float32x2_t *)v77.columns[2].f32, vrsqrts_f32((float32x2_t)v77.columns[0].u32[0], vmul_f32(*(float32x2_t *)v77.columns[2].f32, *(float32x2_t *)v77.columns[2].f32))).f32[0])));
        _Block_object_dispose(&v68, 8);
      }
    }
    C3DAuthoringEnvironmentEndTimedRecord(*(uint64_t *)&__src[26]);
  }
  return *((void *)&__src[19] + 1);
}

void sub_20B2EF438(_Unwind_Exception *a1)
{
}

void scn_ray_create_segment()
{
  __asm { FMOV            V2.4S, #1.0 }
}

uint64_t __C3DSceneCreateHitTestResultsWithSegment_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v5 = result;
    for (uint64_t i = 0; i < a3; ++i)
    {
      uint64_t result = __ProcessNode(*(void *)(a2 + 8 * i));
      if (result && (*(_WORD *)(*(void *)(v5 + 32) + 8) & 0x80) != 0) {
        break;
      }
    }
  }
  return result;
}

uint64_t _C3DHitTestSortFunc(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  WorldPosition = (float32x4_t *)C3DHitTestResultGetWorldPosition(a1);
  float32x4_t v6 = (float32x4_t *)C3DHitTestResultGetWorldPosition(a2);
  float32x4_t v7 = vsubq_f32(*WorldPosition, *a3);
  float32x4_t v8 = vmulq_f32(v7, v7);
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  float32x4_t v10 = vsubq_f32(*v6, *a3);
  float32x4_t v11 = vmulq_f32(v10, v10);
  float32x4_t v12 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1)));
  unsigned __int8 v13 = vmovn_s32(vcgtq_f32(v12, v9)).u8[0];
  unsigned __int8 v14 = vmovn_s32(vcgtq_f32(v9, v12)).u8[0];
  if (v13) {
    return -1;
  }
  else {
    return v14 & 1;
  }
}

void __C3DSceneCreateHitTestResultsWithSegment_block_invoke_2(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v7 = a4;
  MEMORY[0x270FA5388](a1);
  float32x4_t v8 = (_OWORD *)&v26.f32[-4 * v7];
  if (v9)
  {
    float32x4_t v10 = 0uLL;
    uint64_t v11 = v7;
    float32x4_t v12 = &v26 - v7;
    do
    {
      float32x4_t v26 = v10;
      unsigned int v13 = *a3++;
      *(double *)v14.i64 = C3DMeshSourceGetValueAtIndexAsVector3(*(void *)(a1 + 488), v13);
      float32x4_t v15 = v26;
      *v12++ = v14;
      float32x4_t v10 = vaddq_f32(v15, v14);
      --v11;
    }
    while (v11);
    v14.f32[0] = (float)a4;
    float32x4_t v16 = vdivq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0));
    float v17 = 3.4028e38;
    uint64_t v18 = v7;
    uint64_t v19 = &v26 - v7;
    do
    {
      float32x4_t v20 = *v19++;
      float32x4_t v21 = vsubq_f32(v20, v16);
      float32x4_t v22 = vmulq_f32(v21, v21);
      float v17 = fminf(v17, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0]));
      --v18;
    }
    while (v18);
    *(float *)(*(void *)(*(void *)(a1 + 480) + 8) + 24) = v17 * 0.5;
    do
    {
      float32x4_t v23 = (float32x4_t)v8[v18];
      uint64_t v24 = v18 + 1;
      if (v7 - 1 == v18) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = v18 + 1;
      }
      C3DAuthoringEnvironmentAppendDebugSegment(*(void *)(a1 + 448), *(void *)(a1 + 496) + 112, (float *)(a1 + 464), 0, v23, (float32x4_t)v8[v25]);
      uint64_t v18 = v24;
    }
    while (v7 != v24);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 480) + 8) + 24) = 2130706431;
  }
}

uint64_t C3DSceneCreateHitTestResultsAtPoint(__n128 *a1, float32x4_t *a2, const __CFDictionary *a3, double a4, __n128 a5)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (a1
    || (double v40 = a4,
        __n128 v41 = a5,
        float32x4_t v8 = scn_default_log(),
        BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_FAULT),
        a4 = v40,
        a5 = v41,
        !v9))
  {
    if (a2) {
      goto LABEL_4;
    }
LABEL_13:
    float32x4_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      C3DNodeGetProjectionInfos_cold_1(v26, v27, v28, v29, v30, v31, v32, v33);
    }
    return 0;
  }
  C3DSceneCreateHitTestResultsWithSegment_cold_2(v8, v10, v11, v12, v13, v14, v15, v16);
  a4 = v40;
  a5 = v41;
  if (!a2) {
    goto LABEL_13;
  }
LABEL_4:
  __asm { FMOV            V3.4S, #1.0 }
  *(double *)&_Q3 = a4;
  long long v44 = *(unint64_t *)&a4;
  long long v45 = _Q3;
  int v22 = _C3DUnProjectPoints((uint64_t)&v44, 2, a2, (uint64_t)a1, 0, (float32x4_t *)v58, a5);
  float32x4_t v42 = (float32x4_t)v58[0];
  float32x4_t v43 = (float32x4_t)v58[1];
  if (v22)
  {
    if (!a3) {
      return C3DSceneCreateHitTestResultsWithSegment(a1, &v42, a3);
    }
    Value = CFDictionaryGetValue(a3, @"kHitTestClipToZRange");
    if (!Value || CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], Value)) {
      return C3DSceneCreateHitTestResultsWithSegment(a1, &v42, a3);
    }
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    if (C3DNodeGetProjectionInfos((uint64_t)a2, (uint64_t)&v44))
    {
      if (v44)
      {
        *(unint64_t *)((char *)v58[0].n128_u64 + 4) = 0;
        v58[0].n128_u32[0] = 0;
        C3DNodeGetWorldPosition(a2, v58);
        float32x4_t v34 = vsubq_f32(v43, v42);
        int32x4_t v35 = (int32x4_t)vmulq_f32(v34, v34);
        v35.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v35, 2), vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v35.i8, 1))).u32[0];
        float32x2_t v36 = vrsqrte_f32((float32x2_t)v35.u32[0]);
        float32x2_t v37 = vmul_f32(v36, vrsqrts_f32((float32x2_t)v35.u32[0], vmul_f32(v36, v36)));
        float32x4_t v38 = vmulq_n_f32(v34, vmul_f32(v37, vrsqrts_f32((float32x2_t)v35.u32[0], vmul_f32(v37, v37))).f32[0]);
        float32x4_t v39 = vmulq_f32(vsubq_f32(v42, (float32x4_t)v58[0]), v38);
        float32x4_t v42 = vmlsq_lane_f32(v42, v38, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))), 0);
      }
      else
      {
        WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix(a2);
        C3DMatrix4x4GetTranslation(WorldMatrix, (__n128 *)&v42);
      }
      return C3DSceneCreateHitTestResultsWithSegment(a1, &v42, a3);
    }
  }
  return 0;
}

uint64_t C3DHitTestResultCreateFromBulletResults(float32x4_t *a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v4 = C3DHitTestResultCreate();
  WorldMatrix = C3DNodeGetWorldMatrix(a1);
  float32x4_t v6 = WorldMatrix[3];
  float32x4_t v8 = *WorldMatrix;
  float32x4_t v7 = WorldMatrix[1];
  *(float32x4_t *)(v4 + 144) = WorldMatrix[2];
  *(float32x4_t *)(v4 + 160) = v6;
  *(float32x4_t *)(v4 + 112) = v8;
  *(float32x4_t *)(v4 + 12_Block_object_dispose(&STACK[0x2A0], 8) = v7;
  memset(&v18, 0, sizeof(v18));
  C3DMatrix4x4Invert((simd_float4x4 *)(v4 + 112), &v18);
  *(float32x4_t *)(v4 + 96) = a2;
  float32x4_t v14 = (float32x4_t)v18.columns[0];
  simd_float4 v15 = v18.columns[1];
  simd_float4 v16 = v18.columns[2];
  simd_float4 v17 = v18.columns[3];
  *(double *)&long long v9 = C3DVector3MultMatrix4x4(&v14, a2);
  *(_OWORD *)(v4 + 64) = v9;
  C3DHitTestResultSetNode(v4, a1);
  float32x4_t v14 = (float32x4_t)v18.columns[0];
  simd_float4 v15 = v18.columns[1];
  simd_float4 v16 = v18.columns[2];
  simd_float4 v17 = v18.columns[3];
  *(double *)&long long v10 = C3DVector3Rotate((float32x2_t *)&v14, a3);
  *(_OWORD *)(v4 + 80) = v10;
  return v4;
}

uint64_t C3DIntersectionRay3Plane(uint64_t a1, float *a2, float32x4_t *a3)
{
  float32x4_t v6 = (float32x4_t *)C3DSceneSourcePerformConsistencyCheck(a1);
  float32x4_t v7 = (float32x4_t *)C3DRay3Vector(a1);
  float v8 = a2[1];
  float v9 = a2[2];
  float v10 = (float)((float)(v7->f32[1] * v8) + (float)(v7->f32[0] * *a2)) + (float)(v7->f32[2] * v9);
  if (v10 == 0.0) {
    return 0;
  }
  float v11 = (float)-(float)(a2[3]
                      + (float)((float)((float)(v8 * v6->f32[1]) + (float)(*a2 * v6->f32[0])) + (float)(v9 * v6->f32[2])))
      / v10;
  if (v11 < 0.0) {
    return 0;
  }
  if (a3) {
    *a3 = vmlaq_n_f32(*v6, *v7, v11);
  }
  return 1;
}

BOOL C3DIntersectionLinePlane(uint64_t a1, float *a2, float32x4_t *a3)
{
  float32x4_t v6 = (float32x4_t *)C3DSceneSourcePerformConsistencyCheck(a1);
  float32x4_t v7 = (float32x4_t *)C3DRay3Vector(a1);
  float v8 = a2[1];
  float v9 = a2[2];
  float v10 = (float)((float)(v7->f32[1] * v8) + (float)(v7->f32[0] * *a2)) + (float)(v7->f32[2] * v9);
  if (a3 && v10 != 0.0) {
    *a3 = vmlaq_n_f32(*v6, *v7, (float)-(float)(a2[3]+ (float)((float)((float)(v8 * v6->f32[1]) + (float)(*a2 * v6->f32[0]))+ (float)(v9 * v6->f32[2])))/ v10);
  }
  return v10 != 0.0;
}

BOOL C3DIntersectionSegment3Plane(float32x4_t *a1, float *a2, float32x4_t *a3)
{
  v13.i32[2] = 0;
  v13.i64[0] = 0;
  memset(v12, 0, sizeof(v12));
  C3DRay3MakeWithSegment(v12, a1);
  int v6 = C3DIntersectionRay3Plane((uint64_t)v12, a2, &v13);
  BOOL result = 0;
  if (v6)
  {
    float v8 = (float32x4_t *)C3DSceneSourcePerformConsistencyCheck(a1);
    float v9 = (float32x4_t *)C3DRay3Vector((uint64_t)a1);
    float32x4_t v10 = vmulq_f32(vsubq_f32(v13, *v8), vsubq_f32(v13, *v9));
    float v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
    BOOL result = v11 <= 0.0;
    if (a3)
    {
      if (v11 <= 0.0)
      {
        *a3 = v13;
        return 1;
      }
    }
  }
  return result;
}

CFStringRef _C3DListCFCopyDebugDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DList %p: head %p, tail %p, %ld objects>", a1, a1[2], a1[3], a1[6]);
}

uint64_t __C3DListGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DListGetTypeID_typeID = result;
  return result;
}

uint64_t C3DListCreate()
{
  if (C3DListGetTypeID_onceToken != -1) {
    dispatch_once(&C3DListGetTypeID_onceToken, &__block_literal_global_6);
  }
  CFTypeID v0 = C3DListGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x28uLL);
}

uint64_t C3DListRemoveAllObjects(void *a1)
{
  uint64_t result = C3DListGetLastLinkableObject((uint64_t)a1);
  if (result)
  {
    uint64_t v3 = (void *)result;
    do
    {
      C3DListRemoveLinkableObject(a1, v3);
      uint64_t result = C3DListGetLastLinkableObject((uint64_t)a1);
      uint64_t v3 = (void *)result;
    }
    while (result);
  }
  return result;
}

uint64_t C3DListGetLastLinkableObject(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DListGetLastLinkableObject_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void C3DListRemoveLinkableObject(void *a1, void *cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DListGetLastLinkableObject_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*((unsigned char *)cf + 32))
  {
    uint64_t v12 = cf[3];
    if (v12)
    {
      *(void *)(v12 + 16) = cf[2];
      uint64_t v13 = cf[2];
      if (v13)
      {
LABEL_7:
        *(void *)(v13 + 24) = v12;
LABEL_16:
        *((unsigned char *)cf + 32) = 0;
        --a1[6];
        CFRelease(cf);
        return;
      }
LABEL_12:
      if ((void *)a1[3] == cf)
      {
        a1[3] = v12;
      }
      else
      {
        simd_float4 v15 = scn_default_log();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          C3DListRemoveLinkableObject_cold_1(v15);
        }
      }
      goto LABEL_16;
    }
    if ((void *)a1[2] == cf)
    {
      uint64_t v13 = cf[2];
      a1[2] = v13;
      if (v13) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
    float32x4_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      C3DListRemoveLinkableObject_cold_2(v14);
    }
  }
}

CFTypeRef C3DListAddLinkableObjectFirst(void *a1, CFTypeRef cf)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DListGetLastLinkableObject_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFTypeRef result = CFRetain(cf);
  float32x4_t v21 = (void *)a1[2];
  *((void *)cf + 2) = v21;
  *((void *)cf + 3) = 0;
  if (!v21) {
    float32x4_t v21 = a1;
  }
  v21[3] = cf;
  a1[2] = cf;
  uint64_t v22 = a1[6] + 1;
  a1[5] = -1;
  a1[6] = v22;
  *((unsigned char *)cf + 32) = 1;
  return result;
}

uint64_t C3DListMoveLinkableObjectFirst(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (v2)
  {
    *(void *)(v2 + 16) = *(void *)(a2 + 16);
    uint64_t v3 = *(void *)(a2 + 16);
    if (v3) {
      *(void *)(v3 + 24) = v2;
    }
    if (*(void *)(result + 24) == a2) {
      *(void *)(result + 24) = *(void *)(a2 + 24);
    }
    uint64_t v4 = *(void *)(result + 16);
    *(void *)(a2 + 16) = v4;
    *(void *)(a2 + 24) = 0;
    if (v4) {
      *(void *)(v4 + 24) = a2;
    }
    *(void *)(result + 16) = a2;
  }
  return result;
}

C3D::DrawNodesPass *C3D::RenderGraph::createPass<C3D::SSAODepthNormalPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::DrawNodesPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5376, 16, 0);
  C3D::SSAODepthNormalPass::SSAODepthNormalPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::DrawNodesPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::GenerateMipmapPass *C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::GenerateMipmapPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 112, 8, 0);
  *(void *)&v6.var0 = 0;
  C3D::GenerateMipmapPass::GenerateMipmapPass(Aligned, (RenderGraph *)a1, *a2, v6);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::GenerateMipmapPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::SSAOMinMaxOffsetPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::SSAOMinMaxOffsetPass::SSAOMinMaxOffsetPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::SSAORaytracePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::SSAORaytracePass::SSAORaytracePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::SSAOBlurPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&,BOOL>(uint64_t a1, C3D::Pass **a2, uint64_t *a3, char *a4)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::SSAOBlurPass::SSAOBlurPass(Aligned, (RenderGraph *)a1, *a2, *a3, *a4);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ComputePass *C3D::RenderGraph::createPass<C3D::SSAOUpSamplePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>(uint64_t a1, C3D::Pass **a2, uint64_t *a3)
{
  Aligned = (C3D::ComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::SSAOUpSamplePass::SSAOUpSamplePass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

__n128 C3DMatrix4x4MakeRotation(_OWORD *a1, float32x4_t *a2)
{
  float32x4_t v2 = *a2;
  long long v8 = *MEMORY[0x263EF89A8];
  long long v3 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v4 = vmulq_f32(v2, v2);
  float32x4_t v5 = vaddq_f32(v4, v4);
  float32x4_t v6 = vmulq_laneq_f32(v2, v2, 3);
  float v7 = vmulq_lane_f32(v2, *(float32x2_t *)v2.f32, 1).f32[0];
  *(float *)&long long v8 = (float)(1.0 - v5.f32[1]) - v5.f32[2];
  *((float *)&v8 + 1) = (float)(v7 + v6.f32[2]) + (float)(v7 + v6.f32[2]);
  *(float *)&long long v3 = (float)(v7 - v6.f32[2]) + (float)(v7 - v6.f32[2]);
  v5.f32[0] = 1.0 - v5.f32[0];
  *((float *)&v3 + 1) = v5.f32[0] - v5.f32[2];
  *(float32x2_t *)v2.f32 = vmul_laneq_f32(*(float32x2_t *)v2.f32, v2, 2);
  *((float *)&v8 + 2) = (float)(v2.f32[0] - v6.f32[1]) + (float)(v2.f32[0] - v6.f32[1]);
  *((float *)&v3 + 2) = (float)(v2.f32[1] + v6.f32[0]) + (float)(v2.f32[1] + v6.f32[0]);
  *(int32x2_t *)v6.f32 = vrev64_s32(*(int32x2_t *)v6.f32);
  v9.i32[0] = vadd_f32(*(float32x2_t *)v2.f32, *(float32x2_t *)v6.f32).u32[0];
  v9.i32[1] = vsub_f32(*(float32x2_t *)&v2, *(float32x2_t *)&v6).i32[1];
  long long v10 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  *(float32x2_t *)v6.f32 = vadd_f32(v9, v9);
  v6.i32[3] = HIDWORD(*(void *)(MEMORY[0x263EF89A8] + 40));
  v6.f32[2] = v5.f32[0] - v5.f32[1];
  *a1 = v8;
  a1[1] = v3;
  a1[2] = v6;
  a1[3] = v10;
  result.n128_u64[0] = v8;
  result.n128_u32[2] = DWORD2(v8);
  return result;
}

double C3DMatrix4x4GetRotation(float32x4_t *a1)
{
  float32x4_t v2 = *a1;
  float32x4_t v1 = a1[1];
  float32x4_t v3 = a1[2];
  int32x4_t v4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), vnegq_f32(v1)), v3, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v1, (int32x4_t)v1), (int8x16_t)v1, 0xCuLL));
  float32x4_t v5 = vmulq_f32(*a1, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL));
  BOOL v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0] < 0.0;
  float v7 = 1.0;
  if (v6) {
    float v7 = -1.0;
  }
  float32x4_t v8 = vmulq_f32(v2, v2);
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  float32x4_t v10 = vmulq_f32(v1, v1);
  v9.f32[0] = sqrtf(v9.f32[0]);
  float32x4_t v11 = vmulq_f32(v3, v3);
  v9.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  v9.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  float32x4_t v12 = vmulq_n_f32(v9, v7);
  uint32x4_t v13 = (uint32x4_t)vceqzq_f32(v12);
  v13.i32[3] = v13.i32[2];
  if ((vmaxvq_u32(v13) & 0x80000000) != 0
    || (uint32x4_t v14 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v12), (int8x16_t)vcgezq_f32(v12))),
        v14.i32[3] = v14.i32[2],
        (vmaxvq_u32(v14) & 0x80000000) != 0))
  {
    __n128 v24 = *(__n128 *)(MEMORY[0x263EF89A8] + 48);
  }
  else
  {
    float32x4_t v15 = vdivq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0));
    float32x4_t v16 = vdivq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1));
    float32x4_t v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2);
    float v18 = v16.f32[1];
    int32x4_t v19 = (int32x4_t)vdivq_f32(v3, v17);
    float v20 = *(float *)&v19.i32[2] + (float)(v15.f32[0] + v16.f32[1]);
    if (v20 <= 0.0)
    {
      if (v15.f32[0] <= v16.f32[1] || v15.f32[0] <= *(float *)&v19.i32[2])
      {
        if (v16.f32[1] <= *(float *)&v19.i32[2])
        {
          float32_t v30 = (float)(*(float *)&v19.i32[2] + 1.0) - v15.f32[0];
          float32x4_t v31 = (float32x4_t)vzip2q_s32((int32x4_t)v15, vzip1q_s32(v19, (int32x4_t)v15));
          int8x16_t v32 = (int8x16_t)vrev64q_s32((int32x4_t)v16);
          float32x4_t v33 = (float32x4_t)vextq_s8(v32, v32, 8uLL);
          v33.i32[0] = v19.i32[0];
          v22.i64[0] = vaddq_f32(v31, v33).u64[0];
          v31.f32[2] = v30;
          float32x4_t v16 = vsubq_f32(v31, v33);
          v22.i64[1] = v16.i64[1];
          v23.i32[0] = v16.i32[2];
        }
        else
        {
          float32x4_t v26 = v16;
          v26.i32[0] = v15.i32[1];
          v16.i32[1] = v19.i32[2];
          v16.i32[2] = v19.i32[1];
          int32x4_t v27 = (int32x4_t)vaddq_f32(v26, v16);
          v26.f32[1] = (float)(v18 + 1.0) - v15.f32[0];
          v26.i32[3] = v19.i32[0];
          v16.i32[3] = v15.i32[2];
          float32x4_t v16 = vsubq_f32(v26, v16);
          float32x4_t v22 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v27), (int32x4_t)v16);
          v23.i32[0] = v16.i32[1];
        }
      }
      else
      {
        float32x4_t v28 = v15;
        v28.f32[0] = (float)(v15.f32[0] + 1.0) - v16.f32[1];
        v28.i32[3] = v16.i32[2];
        float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL);
        float32x4_t v23 = vsubq_f32(v28, v29);
        v29.i32[1] = v16.i32[0];
        float32x4_t v22 = vaddq_f32(v15, v29);
        v22.i32[0] = v23.i32[0];
        v22.i32[3] = v23.i32[3];
      }
    }
    else
    {
      float32x4_t v23 = (float32x4_t)vzip2q_s32((int32x4_t)v16, vuzp1q_s32((int32x4_t)v16, v19));
      v23.i32[2] = v15.i32[1];
      float32x4_t v21 = (float32x4_t)vtrn2q_s32(v19, vzip2q_s32(v19, (int32x4_t)v15));
      v21.i32[2] = v16.i32[0];
      float32x4_t v22 = vsubq_f32(v23, v21);
      v21.i32[3] = 1.0;
      v23.f32[3] = v20;
      float32x4_t v16 = vaddq_f32(v23, v21);
      v22.i32[3] = v16.i32[3];
      v23.i32[0] = v16.i32[3];
    }
    v16.i32[0] = 0;
    float32x4_t v34 = vmulq_n_f32(v22, 0.5 / sqrtf(v23.f32[0]));
    int32x4_t v35 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v34), (int8x16_t)vcgezq_f32(v34)));
    v35.i32[0] = vmaxvq_u32((uint32x4_t)v35);
    __n128 v24 = (__n128)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32((int32x4_t)v16, v35), 0), *(int8x16_t *)(MEMORY[0x263EF89A8] + 48), (int8x16_t)v34);
  }
  __n128 v37 = 0uLL;
  C3DQuaternionMake(&v37, v24, v24.n128_f32[1], v24.n128_f32[2], v24.n128_f32[3]);
  return v37.n128_f64[0];
}

float32x4_t C3DMatrix4x4MultFloat(float32x4_t *a1, float32x4_t *a2, float a3)
{
  float32x4_t v3 = vmulq_n_f32(*a1, a3);
  float32x4_t v4 = vmulq_n_f32(a1[1], a3);
  float32x4_t v5 = vmulq_n_f32(a1[2], a3);
  float32x4_t result = vmulq_n_f32(a1[3], a3);
  *a2 = v3;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = result;
  return result;
}

float32x4_t C3DMatrix4x4Add(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t result = vaddq_f32(*a1, *a2);
  float32x4_t v4 = vaddq_f32(a1[1], a2[1]);
  float32x4_t v5 = vaddq_f32(a1[2], a2[2]);
  float32x4_t v6 = vaddq_f32(a1[3], a2[3]);
  *a3 = result;
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = v6;
  return result;
}

float32x4_t C3DMatrix4x4Sub(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t result = vsubq_f32(*a1, *a2);
  float32x4_t v4 = vsubq_f32(a1[1], a2[1]);
  float32x4_t v5 = vsubq_f32(a1[2], a2[2]);
  float32x4_t v6 = vsubq_f32(a1[3], a2[3]);
  *a3 = result;
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = v6;
  return result;
}

float C3DMatrix4x4Distance(float32x4_t *a1)
{
  float32x4_t v1 = vsubq_f32(*a1, *a1);
  float32x4_t v2 = vsubq_f32(a1[1], a1[1]);
  float32x4_t v3 = vsubq_f32(a1[2], a1[2]);
  float32x4_t v4 = vsubq_f32(a1[3], a1[3]);
  int8x16_t v5 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v1, v1), v2, v2), v3, v3), v4, v4);
  return vaddv_f32(vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL)));
}

__n128 C3DMatrix4x4Mult3x3(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  long long v4 = *(_OWORD *)(a1 + 32);
  float32x4_t v5 = *a2;
  float32x4_t v6 = a2[1];
  float32x4_t v7 = a2[2];
  HIDWORD(v4) = 0;
  v11[2] = v4;
  __n128 v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v12 + v3 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5, COERCE_FLOAT(v11[v3])), v6, *(float32x2_t *)&v11[v3], 1), v7, (float32x4_t)v11[v3], 2);
    ++v3;
  }
  while (v3 != 3);
  __n128 result = v12;
  long long v8 = v13;
  long long v9 = v14;
  result.n128_u32[3] = *(_DWORD *)(a3 + 12);
  HIDWORD(v_Block_object_dispose(&STACK[0x2A0], 8) = *(_DWORD *)(a3 + 28);
  *(__n128 *)a3 = result;
  *(_OWORD *)(a3 + 16) = v8;
  HIDWORD(v9) = *(_DWORD *)(a3 + 44);
  *(_OWORD *)(a3 + 32) = v9;
  return result;
}

double C3DMatrix4x4MakeZero(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

__n128 C3DMatrix4x4MakeTranslation(uint64_t a1, __n128 *a2)
{
  __n128 result = *a2;
  long long v2 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  long long v3 = *(_OWORD *)(MEMORY[0x263EF89A8] + 32);
  result.n128_u32[3] = *(_DWORD *)(MEMORY[0x263EF89A8] + 60);
  *(_OWORD *)a1 = *MEMORY[0x263EF89A8];
  *(_OWORD *)(a1 + 16) = v2;
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = result;
  return result;
}

float32x4_t C3DMatrix4x4Translate(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t result = vaddq_f32(*a2, a1[3]);
  result.i32[3] = HIDWORD(*(_OWORD *)&a1[3]);
  a1[3] = result;
  return result;
}

double C3DMatrix4x4MakeScale(_OWORD *a1, void *a2)
{
  *(void *)&long long v2 = 0;
  LODWORD(v3) = 0;
  HIDWORD(v3) = 0;
  *(void *)((char *)&v3 + 4) = HIDWORD(*a2);
  *((void *)&v2 + 1) = a2[1];
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  double result = 0.0;
  a1[2] = v2;
  a1[3] = xmmword_20B5CB530;
  return result;
}

float C3DMatrix4x4MakeRotationX(_OWORD *a1, float a2)
{
  __float2 v3 = __sincosf_stret(a2);
  long long v4 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  DWORD1(v4) = LODWORD(v3.__cosval);
  long long v5 = *(_OWORD *)(MEMORY[0x263EF89A8] + 32);
  long long v6 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  DWORD2(v4) = LODWORD(v3.__sinval);
  float result = -v3.__sinval;
  *((float *)&v5 + 1) = -v3.__sinval;
  DWORD2(v5) = LODWORD(v3.__cosval);
  *a1 = *MEMORY[0x263EF89A8];
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  return result;
}

void C3DMatrix4x4MakeRotationY(_OWORD *a1, float a2)
{
  __float2 v3 = __sincosf_stret(a2);
  long long v4 = *MEMORY[0x263EF89A8];
  long long v5 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *(float *)&long long v4 = v3.__cosval;
  long long v6 = *(_OWORD *)(MEMORY[0x263EF89A8] + 32);
  long long v7 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  *((float *)&v4 + 2) = -v3.__sinval;
  *(float *)&long long v6 = v3.__sinval;
  DWORD2(v6) = LODWORD(v3.__cosval);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
}

float C3DMatrix4x4MakeRotationZ(_OWORD *a1, float a2)
{
  __float2 v3 = __sincosf_stret(a2);
  long long v4 = *MEMORY[0x263EF89A8];
  long long v5 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *(void *)&long long v4 = __PAIR64__(LODWORD(v3.__sinval), LODWORD(v3.__cosval));
  long long v6 = *(_OWORD *)(MEMORY[0x263EF89A8] + 32);
  long long v7 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  float result = -v3.__sinval;
  *(void *)&long long v5 = __PAIR64__(LODWORD(v3.__cosval), -v3.__sinval);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return result;
}

double C3DMatrix4x4MakeEulerRotation(float32x4_t *a1, _OWORD *a2)
{
  long long v25 = *a2;
  __float2 v3 = __sincosf_stret(COERCE_FLOAT(*a2));
  float32x4_t v26 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  float32x4_t v20 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v21 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  float32x4_t v4 = v20;
  v4.i32[1] = LODWORD(v3.__cosval);
  v4.i32[2] = LODWORD(v3.__sinval);
  float32x4_t v23 = v4;
  float32x4_t v24 = *(float32x4_t *)MEMORY[0x263EF89A8];
  float32x4_t v5 = v26;
  v5.f32[1] = -v3.__sinval;
  v5.i32[2] = LODWORD(v3.__cosval);
  float32x4_t v22 = v5;
  __float2 v6 = __sincosf_stret(*((float *)&v25 + 1));
  float32x4_t v7 = v24;
  v7.i32[0] = LODWORD(v6.__cosval);
  v7.f32[2] = -v6.__sinval;
  float32x4_t v8 = v26;
  v8.i32[0] = LODWORD(v6.__sinval);
  v8.i32[2] = LODWORD(v6.__cosval);
  float32x4_t v18 = v8;
  float32x4_t v19 = v7;
  __float2 v9 = __sincosf_stret(*((float *)&v25 + 2));
  v12.i64[1] = v24.i64[1];
  unint64_t v10 = 0;
  v11.i64[1] = v20.i64[1];
  float32x4_t v27 = v24;
  v12.i32[0] = LODWORD(v9.__cosval);
  float32x4_t v28 = v23;
  float32x4_t v29 = v22;
  float32x4_t v30 = v21;
  float32x4_t v31 = 0u;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v31 + v10) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, COERCE_FLOAT(*(_OWORD *)((char *)&v27 + v10))), v20, *(float32x2_t *)&v27.f32[v10 / 4], 1), v18, *(float32x4_t *)((char *)&v27 + v10), 2), v21, *(float32x4_t *)((char *)&v27 + v10), 3);
    v10 += 16;
  }
  while (v10 != 64);
  unint64_t v13 = 0;
  v12.i32[1] = LODWORD(v9.__sinval);
  v11.i32[1] = LODWORD(v9.__cosval);
  float32x4_t v27 = v31;
  float32x4_t v28 = v32;
  float32x4_t v29 = v33;
  float32x4_t v30 = v34;
  float32x4_t v31 = 0u;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  do
  {
    v11.f32[0] = -v9.__sinval;
    *(float32x4_t *)((char *)&v31 + v13) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(_OWORD *)((char *)&v27 + v13))), v11, *(float32x2_t *)&v27.f32[v13 / 4], 1), v26, *(float32x4_t *)((char *)&v27 + v13), 2), v21, *(float32x4_t *)((char *)&v27 + v13), 3);
    v13 += 16;
  }
  while (v13 != 64);
  double result = *(double *)v31.i64;
  float32x4_t v15 = v32;
  float32x4_t v16 = v33;
  float32x4_t v17 = v34;
  *a1 = v31;
  a1[1] = v15;
  a1[2] = v16;
  a1[3] = v17;
  return result;
}

float32x4_t C3DMatrix4x4MakeAffine(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float32x2_t *a4)
{
  float32x4_t v4 = *a3;
  float32x4_t v6 = *(float32x4_t *)MEMORY[0x263EF89A8];
  float32x4_t v5 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v7 = vmulq_f32(v4, v4);
  float32x4_t v8 = vaddq_f32(v7, v7);
  float32x4_t v9 = vmulq_laneq_f32(v4, v4, 3);
  float v10 = vmulq_lane_f32(v4, *(float32x2_t *)v4.f32, 1).f32[0];
  v6.f32[0] = (float)(1.0 - v8.f32[1]) - v8.f32[2];
  v6.f32[1] = (float)(v10 + v9.f32[2]) + (float)(v10 + v9.f32[2]);
  v5.f32[0] = (float)(v10 - v9.f32[2]) + (float)(v10 - v9.f32[2]);
  v8.f32[0] = 1.0 - v8.f32[0];
  v5.f32[1] = v8.f32[0] - v8.f32[2];
  *(float32x2_t *)v4.f32 = vmul_laneq_f32(*(float32x2_t *)v4.f32, v4, 2);
  v6.f32[2] = (float)(v4.f32[0] - v9.f32[1]) + (float)(v4.f32[0] - v9.f32[1]);
  v5.f32[2] = (float)(v4.f32[1] + v9.f32[0]) + (float)(v4.f32[1] + v9.f32[0]);
  float32x4_t v11 = *(float32x4_t *)a4->f32;
  *(int32x2_t *)v9.f32 = vrev64_s32(*(int32x2_t *)v9.f32);
  v12.i32[0] = vadd_f32(*(float32x2_t *)v4.f32, *(float32x2_t *)v9.f32).u32[0];
  v12.i32[1] = vsub_f32(*(float32x2_t *)&v4, *(float32x2_t *)&v9).i32[1];
  *(float32x2_t *)v9.f32 = vadd_f32(v12, v12);
  v9.i32[3] = HIDWORD(*(void *)(MEMORY[0x263EF89A8] + 40));
  v9.f32[2] = v8.f32[0] - v8.f32[1];
  float32x4_t v13 = vaddq_f32(*a2, *(float32x4_t *)(MEMORY[0x263EF89A8] + 48));
  v13.i32[3] = HIDWORD(*(_OWORD *)(MEMORY[0x263EF89A8] + 48));
  float32x4_t v14 = vmulq_lane_f32(v5, *a4, 1);
  *a1 = vmulq_n_f32(v6, COERCE_FLOAT(*(_OWORD *)a4->f32));
  a1[1] = v14;
  float32x4_t result = vmulq_laneq_f32(v9, v11, 2);
  a1[2] = result;
  a1[3] = v13;
  return result;
}

void C3DMatrix4x4ComputeNormalMatrix(__n128 *a1, _OWORD *a2)
{
  *(double *)&long long v3 = scn_matrix_compute_normal(a1->n128_f64[0], a1[1], a1[2]);
  *a2 = v3;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = v6;
}

uint64_t C3DMatrix4x4Project(float32x4_t *a1, float32x2_t *a2, float32x4_t *a3)
{
  float32x4_t v3 = vaddq_f32(a1[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a1, COERCE_FLOAT(*(_OWORD *)a2->f32)), a1[1], *a2, 1), a1[2], *(float32x4_t *)a2->f32, 2));
  float32x2_t v4 = (float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL), 0);
  float32x2_t v5 = vrecpe_f32(v4);
  float32x2_t v6 = vmul_f32(v5, vrecps_f32(v4, v5));
  *a3 = vmulq_n_f32(v3, vmul_f32(v6, vrecps_f32(v4, v6)).f32[0]);
  return 1;
}

__n128 C3DMatrix4x4SetTranslation(__n128 *a1, __n128 result)
{
  result.n128_u32[3] = a1[3].n128_u32[3];
  a1[3] = result;
  return result;
}

float32x4_t C3DMatrix4x4ClearScale(float32x4_t *a1)
{
  float32x4_t v1 = a1[1];
  int32x4_t v2 = (int32x4_t)vmulq_f32(*a1, *a1);
  v2.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v2, 2), vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v2.i8, 1))).u32[0];
  float32x2_t v3 = vrsqrte_f32((float32x2_t)v2.u32[0]);
  float32x2_t v4 = vmul_f32(v3, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v3, v3)));
  float32x4_t v5 = vmulq_n_f32(*a1, vmul_f32(v4, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v4, v4))).f32[0]);
  v5.i32[3] = HIDWORD(*(unsigned long long *)a1);
  int32x4_t v6 = (int32x4_t)vmulq_f32(v1, v1);
  v6.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))).u32[0];
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
  float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)));
  float32x4_t v9 = vmulq_n_f32(v1, vmul_f32(v8, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]);
  v9.i32[3] = v1.i32[3];
  float32x4_t v10 = a1[2];
  int32x4_t v11 = (int32x4_t)vmulq_f32(v10, v10);
  v11.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1))).u32[0];
  *a1 = v5;
  a1[1] = v9;
  *(float32x2_t *)v9.f32 = vrsqrte_f32((float32x2_t)v11.u32[0]);
  *(float32x2_t *)v9.f32 = vmul_f32(*(float32x2_t *)v9.f32, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(*(float32x2_t *)v9.f32, *(float32x2_t *)v9.f32)));
  float32x4_t result = vmulq_n_f32(v10, vmul_f32(*(float32x2_t *)v9.f32, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(*(float32x2_t *)v9.f32, *(float32x2_t *)v9.f32))).f32[0]);
  result.i32[3] = v10.i32[3];
  a1[2] = result;
  return result;
}

float32x4_t C3DMatrix4x4Lerp(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float a4)
{
  float32x4_t v4 = vmlaq_n_f32(vmulq_n_f32(*a2, a4), *a1, 1.0 - a4);
  float32x4_t v5 = vmlaq_n_f32(vmulq_n_f32(a2[1], a4), a1[1], 1.0 - a4);
  float32x4_t v6 = vmlaq_n_f32(vmulq_n_f32(a2[2], a4), a1[2], 1.0 - a4);
  float32x4_t result = vmlaq_n_f32(vmulq_n_f32(a2[3], a4), a1[3], 1.0 - a4);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = result;
  return result;
}

void C3DMatrix4x4Interpolate(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float a4)
{
  *(float *)v4.i32 = a4;
  float32x4_t v6 = *a1;
  float32x4_t v7 = a1[1];
  _Q2 = a1[2];
  float32x4_t v10 = *a2;
  float32x4_t v9 = a2[1];
  float32x4_t v11 = a2[2];
  int32x4_t v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL), vnegq_f32(v7)), _Q2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL));
  float32x4_t v13 = vmulq_f32(*a1, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL));
  _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0] < 0.0;
  float v15 = 1.0;
  if (_NF) {
    float v15 = -1.0;
  }
  float32x4_t v16 = vmulq_f32(v6, v6);
  float32x4_t v17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1)));
  v17.f32[0] = sqrtf(v17.f32[0]);
  float32x4_t v18 = vmulq_f32(v7, v7);
  float32x4_t v19 = vmulq_f32(_Q2, _Q2);
  v17.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0]);
  v17.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0]);
  float32x4_t v20 = vmulq_n_f32(v17, v15);
  int32x4_t v21 = vcltzq_f32(v20);
  int32x4_t v22 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)v21, (int8x16_t)vcgezq_f32(v20)));
  v22.i32[3] = v22.i32[2];
  v22.i32[0] = vmaxvq_u32((uint32x4_t)v22);
  v21.i32[0] = -1;
  float32x4_t v23 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v22, v21), 0), (int8x16_t)v20, (int8x16_t)0);
  uint32x4_t v24 = (uint32x4_t)vceqzq_f32(v23);
  v24.i32[3] = v24.i32[2];
  if ((vmaxvq_u32(v24) & 0x80000000) != 0)
  {
    BOOL v33 = 0;
    float32x4_t v34 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
    _Q23 = v34;
    float32x4_t v23 = 0uLL;
  }
  else
  {
    __int32 v25 = v22.i32[0];
    float32x4_t v26 = vdivq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0));
    float32x4_t v27 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1));
    int32x4_t v28 = (int32x4_t)vdivq_f32(_Q2, (float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2));
    float v29 = *(float *)&v28.i32[2] + (float)(v26.f32[0] + v27.f32[1]);
    if (v29 <= 0.0)
    {
      if (v26.f32[0] <= v27.f32[1] || v26.f32[0] <= *(float *)&v28.i32[2])
      {
        if (v27.f32[1] <= *(float *)&v28.i32[2])
        {
          float32_t v43 = (float)(*(float *)&v28.i32[2] + 1.0) - v26.f32[0];
          float32x4_t v44 = (float32x4_t)vzip2q_s32((int32x4_t)v26, vzip1q_s32(v28, (int32x4_t)v26));
          int8x16_t v45 = (int8x16_t)vrev64q_s32((int32x4_t)v27);
          float32x4_t v46 = (float32x4_t)vextq_s8(v45, v45, 8uLL);
          v46.i32[0] = v28.i32[0];
          v32.i64[0] = vaddq_f32(v44, v46).u64[0];
          v44.f32[2] = v43;
          v32.i64[1] = vsubq_f32(v44, v46).i64[1];
          v28.i32[0] = v32.i32[2];
        }
        else
        {
          float32_t v37 = (float)(v27.f32[1] + 1.0) - v26.f32[0];
          float32x4_t v38 = v27;
          v38.i32[0] = v26.i32[1];
          v27.i32[1] = v28.i32[2];
          v27.i32[2] = v28.i32[1];
          int32x4_t v39 = (int32x4_t)vaddq_f32(v38, v27);
          v38.f32[1] = v37;
          v38.i32[3] = v28.i32[0];
          v27.i32[3] = v26.i32[2];
          int32x4_t v40 = (int32x4_t)vsubq_f32(v38, v27);
          float32x4_t v32 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v39), v40);
          v28.i32[0] = v40.i32[1];
        }
      }
      else
      {
        float32x4_t v41 = v26;
        v41.f32[0] = (float)(v26.f32[0] + 1.0) - v27.f32[1];
        v41.i32[3] = v27.i32[2];
        float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL);
        int32x4_t v28 = (int32x4_t)vsubq_f32(v41, v42);
        v42.i32[1] = v27.i32[0];
        float32x4_t v32 = vaddq_f32(v26, v42);
        v32.i32[0] = v28.i32[0];
        v32.i32[3] = v28.i32[3];
      }
    }
    else
    {
      float32x4_t v30 = (float32x4_t)vzip2q_s32((int32x4_t)v27, vuzp1q_s32((int32x4_t)v27, v28));
      v30.i32[2] = v26.i32[1];
      float32x4_t v31 = (float32x4_t)vtrn2q_s32(v28, vzip2q_s32(v28, (int32x4_t)v26));
      v31.i32[2] = v27.i32[0];
      float32x4_t v32 = vsubq_f32(v30, v31);
      v31.i32[3] = 1.0;
      v30.f32[3] = v29;
      v32.i32[3] = vaddq_f32(v30, v31).i32[3];
      v28.i32[0] = v32.i32[3];
    }
    float32x4_t v47 = vmulq_n_f32(v32, 0.5 / sqrtf(*(float *)v28.i32));
    int32x4_t v48 = vcltzq_f32(v47);
    int32x4_t v49 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)v48, (int8x16_t)vcgezq_f32(v47)));
    v49.i32[0] = vmaxvq_u32((uint32x4_t)v49);
    v48.i32[0] = -1;
    float32x4_t v34 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
    _Q23 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v49, v48), 0), (int8x16_t)v47, (int8x16_t)v34);
    BOOL v33 = (v49.i32[0] | v25) >= 0;
  }
  float32x4_t v50 = a1[3];
  int32x4_t v51 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v9)), v11, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL));
  float32x4_t v52 = vmulq_f32(v10, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v51, v51), (int8x16_t)v51, 0xCuLL));
  _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0] < 0.0;
  float v53 = 1.0;
  if (_NF) {
    float v53 = -1.0;
  }
  float32x4_t v54 = vmulq_f32(v10, v10);
  float32x4_t v55 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), vaddq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1)));
  v55.f32[0] = sqrtf(v55.f32[0]);
  float32x4_t v56 = vmulq_f32(v9, v9);
  float32x4_t v57 = vmulq_f32(v11, v11);
  v55.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2), vaddq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1))).f32[0]);
  v55.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2), vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 1))).f32[0]);
  float32x4_t v58 = vmulq_n_f32(v55, v53);
  int32x4_t v59 = vcltzq_f32(v58);
  int32x4_t v60 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)v59, (int8x16_t)vcgezq_f32(v58)));
  v60.i32[3] = v60.i32[2];
  v60.i32[0] = vmaxvq_u32((uint32x4_t)v60);
  v59.i32[0] = -1;
  float32x4_t v61 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v60, v59), 0), (int8x16_t)v58, (int8x16_t)0);
  uint32x4_t v62 = (uint32x4_t)vceqzq_f32(v61);
  v62.i32[3] = v62.i32[2];
  if ((vmaxvq_u32(v62) & 0x80000000) == 0)
  {
    int v63 = v60.i32[0];
    float32x4_t v64 = vdivq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 0));
    float32x4_t v65 = vdivq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 1));
    float v66 = v65.f32[1];
    int32x4_t v67 = (int32x4_t)vdivq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 2));
    float v68 = *(float *)&v67.i32[2] + (float)(v64.f32[0] + v65.f32[1]);
    if (v68 <= 0.0)
    {
      if (v64.f32[0] <= v65.f32[1] || v64.f32[0] <= *(float *)&v67.i32[2])
      {
        if (v65.f32[1] <= *(float *)&v67.i32[2])
        {
          float32_t v78 = (float)(*(float *)&v67.i32[2] + 1.0) - v64.f32[0];
          float32x4_t v79 = (float32x4_t)vzip2q_s32((int32x4_t)v64, vzip1q_s32(v67, (int32x4_t)v64));
          int8x16_t v80 = (int8x16_t)vrev64q_s32((int32x4_t)v65);
          float32x4_t v81 = (float32x4_t)vextq_s8(v80, v80, 8uLL);
          v81.i32[0] = v67.i32[0];
          v70.i64[0] = vaddq_f32(v79, v81).u64[0];
          v79.f32[2] = v78;
          v70.i64[1] = vsubq_f32(v79, v81).i64[1];
          v71.i32[0] = v70.i32[2];
        }
        else
        {
          float32x4_t v73 = v65;
          v73.i32[0] = v64.i32[1];
          v65.i32[1] = v67.i32[2];
          v65.i32[2] = v67.i32[1];
          int32x4_t v74 = (int32x4_t)vaddq_f32(v73, v65);
          v73.f32[1] = (float)(v66 + 1.0) - v64.f32[0];
          v73.i32[3] = v67.i32[0];
          v65.i32[3] = v64.i32[2];
          int32x4_t v75 = (int32x4_t)vsubq_f32(v73, v65);
          float32x4_t v70 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v74), v75);
          v71.i32[0] = v75.i32[1];
        }
      }
      else
      {
        float32x4_t v76 = v64;
        v76.f32[0] = (float)(v64.f32[0] + 1.0) - v65.f32[1];
        v76.i32[3] = v65.i32[2];
        float32x4_t v77 = (float32x4_t)vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL);
        float32x4_t v71 = vsubq_f32(v76, v77);
        v77.i32[1] = v65.i32[0];
        float32x4_t v70 = vaddq_f32(v64, v77);
        v70.i32[0] = v71.i32[0];
        v70.i32[3] = v71.i32[3];
      }
    }
    else
    {
      float32x4_t v71 = (float32x4_t)vzip2q_s32((int32x4_t)v65, vuzp1q_s32((int32x4_t)v65, v67));
      v71.i32[2] = v64.i32[1];
      float32x4_t v69 = (float32x4_t)vtrn2q_s32(v67, vzip2q_s32(v67, (int32x4_t)v64));
      v69.i32[2] = v65.i32[0];
      float32x4_t v70 = vsubq_f32(v71, v69);
      v69.i32[3] = 1.0;
      v71.f32[3] = v68;
      v70.i32[3] = vaddq_f32(v71, v69).i32[3];
      v71.i32[0] = v70.i32[3];
    }
    _NF = v63 < 0;
    float32x4_t v82 = vmulq_n_f32(v70, 0.5 / sqrtf(v71.f32[0]));
    unsigned int v83 = vmaxvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v82), (int8x16_t)vcgezq_f32(v82))));
    if (_NF) {
      BOOL v33 = 0;
    }
    if ((v83 & 0x80000000) == 0 && v33)
    {
      float32x4_t v84 = (float32x4_t)vdupq_lane_s32(v4, 0);
      float32x4_t v85 = vmlaq_n_f32(v50, vsubq_f32(a2[3], v50), *(float *)v4.i32);
      _Q0 = vmulq_f32(_Q23, v82);
      _S1 = v82.i32[2];
      __asm { FMLA            S0, S1, V23.S[2] }
      _Q2.i32[0] = v82.i32[3];
      float v90 = -(float)(_Q0.f32[0] + (float)(_Q23.f32[3] * v82.f32[3]));
      __asm { FMLA            S0, S2, V23.S[3] }
      _Q2.i64[0] = 0;
      float32x4_t v92 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(_Q2, _Q0), 0), (int8x16_t)vnegq_f32(v82), (int8x16_t)v82);
      if (_Q0.f32[0] < 0.0) {
        _Q0.f32[0] = v90;
      }
      if (1.0 - _Q0.f32[0] <= 0.00100000005)
      {
        float v98 = 1.0 - *(float *)v4.i32;
      }
      else
      {
        float32x4_t v114 = v23;
        float v115 = *(float *)v4.i32;
        float32x4_t v112 = v34;
        float32x4_t v113 = v85;
        float32x4_t v110 = v61;
        float32x4_t v111 = _Q23;
        float32x4_t v108 = v92;
        float32x4_t v109 = v84;
        float v93 = acosf(_Q0.f32[0]);
        float v94 = sinf(v93);
        float v95 = sinf((float)(1.0 - v115) * v93);
        float v96 = v93 * v115;
        float v116 = v95 / v94;
        float v97 = sinf(v96);
        float32x4_t v92 = v108;
        float32x4_t v84 = v109;
        float32x4_t v61 = v110;
        _Q23 = v111;
        float32x4_t v34 = v112;
        float32x4_t v85 = v113;
        *(float *)v4.i32 = v97 / v94;
        float32x4_t v23 = v114;
        float v98 = v116;
      }
      float32x4_t v99 = vmlaq_n_f32(vmulq_n_f32(v92, *(float *)v4.i32), _Q23, v98);
      float32x4_t v100 = *(float32x4_t *)MEMORY[0x263EF89A8];
      float32x4_t v101 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
      float32x4_t v102 = vmulq_f32(v99, v99);
      float32x4_t v103 = vaddq_f32(v102, v102);
      float32x4_t v104 = vmulq_laneq_f32(v99, v99, 3);
      float v105 = vmulq_lane_f32(v99, *(float32x2_t *)v99.f32, 1).f32[0];
      v100.f32[0] = (float)(1.0 - v103.f32[1]) - v103.f32[2];
      v100.f32[1] = (float)(v105 + v104.f32[2]) + (float)(v105 + v104.f32[2]);
      v101.f32[0] = (float)(v105 - v104.f32[2]) + (float)(v105 - v104.f32[2]);
      v103.f32[0] = 1.0 - v103.f32[0];
      v101.f32[1] = v103.f32[0] - v103.f32[2];
      *(float32x2_t *)v99.f32 = vmul_laneq_f32(*(float32x2_t *)v99.f32, v99, 2);
      v100.f32[2] = (float)(v99.f32[0] - v104.f32[1]) + (float)(v99.f32[0] - v104.f32[1]);
      float32x4_t v106 = vmlaq_f32(v23, vsubq_f32(v61, v23), v84);
      v101.f32[2] = (float)(v99.f32[1] + v104.f32[0]) + (float)(v99.f32[1] + v104.f32[0]);
      *(int32x2_t *)v104.f32 = vrev64_s32(*(int32x2_t *)v104.f32);
      v107.i32[0] = vadd_f32(*(float32x2_t *)v99.f32, *(float32x2_t *)v104.f32).u32[0];
      v107.i32[1] = vsub_f32(*(float32x2_t *)&v99, *(float32x2_t *)&v104).i32[1];
      *(float32x2_t *)v99.f32 = vadd_f32(v107, v107);
      v99.i32[3] = HIDWORD(*(void *)(MEMORY[0x263EF89A8] + 40));
      v99.f32[2] = v103.f32[0] - v103.f32[1];
      float32x4_t v6 = vmulq_n_f32(v100, v106.f32[0]);
      float32x4_t v7 = vmulq_lane_f32(v101, *(float32x2_t *)v106.f32, 1);
      _Q2 = vmulq_laneq_f32(v99, v106, 2);
      float32x4_t v50 = vaddq_f32(v85, v34);
      v50.i32[3] = v34.i32[3];
    }
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = _Q2;
  a3[3] = v50;
}

BOOL C3DMatrix4x4GetAffineTransforms(uint64_t a1, _OWORD *a2, int8x16_t *a3, float32x4_t *a4)
{
  float32x4_t v5 = *(float32x4_t *)a1;
  float32x4_t v4 = *(float32x4_t *)(a1 + 16);
  float32x4_t v7 = *(float32x4_t *)(a1 + 32);
  long long v6 = *(_OWORD *)(a1 + 48);
  int32x4_t v8 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), vnegq_f32(v4)), v7, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL));
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL));
  BOOL v33 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0] < 0.0;
  float v10 = 1.0;
  if (v33) {
    float v10 = -1.0;
  }
  float32x4_t v11 = vmulq_f32(v5, v5);
  float32x4_t v12 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1)));
  v12.f32[0] = sqrtf(v12.f32[0]);
  float32x4_t v13 = vmulq_f32(v4, v4);
  float32x4_t v14 = vmulq_f32(v7, v7);
  v12.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  v12.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
  float32x4_t v15 = vmulq_n_f32(v12, v10);
  int32x4_t v16 = vcltzq_f32(v15);
  int32x4_t v17 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)v16, (int8x16_t)vcgezq_f32(v15)));
  v17.i32[3] = v17.i32[2];
  v17.i32[0] = vmaxvq_u32((uint32x4_t)v17);
  v16.i32[0] = -1;
  float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v17, v16), 0), (int8x16_t)v15, (int8x16_t)0);
  if (a4) {
    *a4 = v18;
  }
  uint32x4_t v19 = (uint32x4_t)vceqzq_f32(v18);
  v19.i32[3] = v19.i32[2];
  if ((vmaxvq_u32(v19) & 0x80000000) != 0)
  {
    int8x16_t v30 = *(int8x16_t *)(MEMORY[0x263EF89A8] + 48);
    BOOL result = 0;
    if (a4) {
      *a4 = 0u;
    }
  }
  else
  {
    __int32 v20 = v17.i32[0];
    float32x4_t v21 = vdivq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 0));
    float32x4_t v22 = vdivq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1));
    float32x4_t v23 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2);
    float v24 = v22.f32[1];
    int32x4_t v25 = (int32x4_t)vdivq_f32(v7, v23);
    float v26 = *(float *)&v25.i32[2] + (float)(v21.f32[0] + v22.f32[1]);
    if (v26 <= 0.0)
    {
      if (v21.f32[0] > v22.f32[1])
      {
        BOOL v32 = v21.f32[0] == *(float *)&v25.i32[2];
        BOOL v33 = v21.f32[0] < *(float *)&v25.i32[2];
      }
      else
      {
        BOOL v32 = 1;
        BOOL v33 = 0;
      }
      if (v33 || v32)
      {
        if (v22.f32[1] <= *(float *)&v25.i32[2])
        {
          float32_t v39 = (float)(*(float *)&v25.i32[2] + 1.0) - v21.f32[0];
          float32x4_t v40 = (float32x4_t)vzip2q_s32((int32x4_t)v21, vzip1q_s32(v25, (int32x4_t)v21));
          int8x16_t v41 = (int8x16_t)vrev64q_s32((int32x4_t)v22);
          float32x4_t v42 = (float32x4_t)vextq_s8(v41, v41, 8uLL);
          v42.i32[0] = v25.i32[0];
          v28.i64[0] = vaddq_f32(v40, v42).u64[0];
          v40.f32[2] = v39;
          v28.i64[1] = vsubq_f32(v40, v42).i64[1];
          v29.i32[0] = v28.i32[2];
        }
        else
        {
          float32x4_t v34 = v22;
          v34.i32[0] = v21.i32[1];
          v22.i32[1] = v25.i32[2];
          v22.i32[2] = v25.i32[1];
          int32x4_t v35 = (int32x4_t)vaddq_f32(v34, v22);
          v34.f32[1] = (float)(v24 + 1.0) - v21.f32[0];
          v34.i32[3] = v25.i32[0];
          v22.i32[3] = v21.i32[2];
          int32x4_t v36 = (int32x4_t)vsubq_f32(v34, v22);
          float32x4_t v28 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v35), v36);
          v29.i32[0] = v36.i32[1];
        }
      }
      else
      {
        float32x4_t v37 = v21;
        v37.f32[0] = (float)(v21.f32[0] + 1.0) - v22.f32[1];
        v37.i32[3] = v22.i32[2];
        float32x4_t v38 = (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL);
        float32x4_t v29 = vsubq_f32(v37, v38);
        v38.i32[1] = v22.i32[0];
        float32x4_t v28 = vaddq_f32(v21, v38);
        v28.i32[0] = v29.i32[0];
        v28.i32[3] = v29.i32[3];
      }
    }
    else
    {
      float32x4_t v29 = (float32x4_t)vzip2q_s32((int32x4_t)v22, vuzp1q_s32((int32x4_t)v22, v25));
      v29.i32[2] = v21.i32[1];
      float32x4_t v27 = (float32x4_t)vtrn2q_s32(v25, vzip2q_s32(v25, (int32x4_t)v21));
      v27.i32[2] = v22.i32[0];
      float32x4_t v28 = vsubq_f32(v29, v27);
      v27.i32[3] = 1.0;
      v29.f32[3] = v26;
      v28.i32[3] = vaddq_f32(v29, v27).i32[3];
      v29.i32[0] = v28.i32[3];
    }
    float32x4_t v43 = vmulq_n_f32(v28, 0.5 / sqrtf(v29.f32[0]));
    int32x4_t v44 = vcltzq_f32(v43);
    int32x4_t v45 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)v44, (int8x16_t)vcgezq_f32(v43)));
    v45.i32[0] = vmaxvq_u32((uint32x4_t)v45);
    v44.i32[0] = -1;
    int8x16_t v30 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v45, v44), 0), (int8x16_t)v43, *(int8x16_t *)(MEMORY[0x263EF89A8] + 48));
    BOOL result = (v45.i32[0] | v20) >= 0;
  }
  if (a2) {
    *a2 = v6;
  }
  if (a3) {
    *a3 = v30;
  }
  return result;
}

uint64_t C3DMatrix4x4CopyPropertyList(uint64_t result)
{
  if (result) {
    return C3DCreatePropertyListFromC3DFloatBuffer(result, 16);
  }
  return result;
}

uint64_t C3DMatrix4x4InitWithPropertyList(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result) {
    return C3DInitC3DFloatArrayWithPropertyList(a2, result, a4);
  }
  return result;
}

int32x4_t *C3DMatrix4x4MakeLookAt(int32x4_t *result, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t v4 = vsubq_f32(*a3, *a2);
  int32x4_t v5 = (int32x4_t)vmulq_f32(v4, v4);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  float32x4_t v8 = vmulq_n_f32(v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]);
  int32x4_t v9 = (int32x4_t)vmulq_f32(*a4, *a4);
  v9.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2), vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1))).u32[0];
  float32x2_t v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
  float32x2_t v11 = vmul_f32(v10, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)));
  float32x4_t v12 = vmulq_n_f32(*a4, vmul_f32(v11, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))).f32[0]);
  float32x4_t v13 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL);
  float32x4_t v14 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), vnegq_f32(v8)), v12, v13);
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL);
  int32x4_t v16 = (int32x4_t)vmulq_f32(v14, v14);
  v16.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2), *(float32x2_t *)v16.i8)).u32[0];
  float32x2_t v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
  float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
  float32x4_t v19 = vmulq_n_f32(v15, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]);
  int32x4_t v20 = (int32x4_t)vmlaq_f32(vmulq_f32(v13, vnegq_f32(v19)), v8, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL));
  float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL);
  float32x4_t v22 = vmulq_f32(*a2, v19);
  float32x4_t v23 = vmulq_f32(*a2, v8);
  v8.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0];
  int32x4_t v24 = (int32x4_t)vnegq_f32(v8);
  float32x2x2_t v25 = (float32x2x2_t)vzip1q_s32((int32x4_t)v19, v24);
  v19.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
  float32x4_t v26 = vmulq_f32(*a2, v21);
  int32x4_t v27 = *(int32x4_t *)(MEMORY[0x263EF89A8] + 48);
  int32x4_t v28 = vzip1q_s32((int32x4_t)v21, v27);
  v21.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
  float32x2x2_t v29 = (float32x2x2_t)vzip2q_s32((int32x4_t)v19, v24);
  int32x4_t v30 = vzip2q_s32((int32x4_t)v21, v27);
  float32x4_t v31 = (float *)result;
  vst2_f32(v31, v25);
  v31 += 4;
  *(int32x4_t *)float32x4_t v31 = vzip2q_s32((int32x4_t)v25, v28);
  i32 = (float *)result[2].i32;
  vst2_f32(i32, v29);
  result[3] = vzip2q_s32((int32x4_t)v29, v30);
  return result;
}

double C3DMatrix4x4Determinant3x3(uint64_t a1)
{
  int32x4_t v1 = *(int32x4_t *)(a1 + 16);
  int32x4_t v2 = *(int32x4_t *)(a1 + 32);
  float32x4_t v3 = vmulq_f32(*(float32x4_t *)a1, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v2, (int8x16_t)v2, 0xCuLL), (int8x16_t)v2, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v1, v1), (int8x16_t)v1, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v2, v2), (int8x16_t)v2, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v1, (int8x16_t)v1, 0xCuLL), (int8x16_t)v1, 8uLL)));
  *(void *)&double result = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u64[0];
  return result;
}

float32x4_t C3DMatrix4x4Scale(float32x4_t *a1, float32x2_t *a2)
{
  float32x4_t v2 = vmulq_lane_f32(a1[1], *a2, 1);
  float32x4_t result = vmulq_laneq_f32(a1[2], *(float32x4_t *)a2->f32, 2);
  *a1 = vmulq_n_f32(*a1, COERCE_FLOAT(*(_OWORD *)a2->f32));
  a1[1] = v2;
  a1[2] = result;
  return result;
}

_DWORD *C3DDelaunayTriangulationForSimplePlanarPolygon(uint64_t a1, unsigned int *a2, unsigned int a3, int *a4)
{
  uint64_t v5 = a3 - 2;
  if (a3 <= 2)
  {
    float32x2_t v6 = 0;
    *a4 = 0;
    return v6;
  }
  float32x4_t v8 = a2;
  if (a3 == 4)
  {
    float32x2_t v6 = malloc_type_malloc(0x18uLL, 0x100004052888210uLL);
    _DWORD *v6 = *v8;
    v6[1] = v8[1];
    v6[2] = v8[2];
    v6[3] = *v8;
    v6[4] = v8[2];
    v6[5] = v8[3];
    int v9 = 6;
    goto LABEL_7;
  }
  if (a3 == 3)
  {
    float32x2_t v6 = malloc_type_malloc(0xCuLL, 0x100004052888210uLL);
    _DWORD *v6 = *v8;
    v6[1] = v8[1];
    v6[2] = v8[2];
    int v9 = 3;
LABEL_7:
    *a4 = v9;
    return v6;
  }
  *(double *)v11.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a1, *a2);
  float32x4_t v69 = v11;
  *(double *)v12.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a1, v8[1]);
  BOOL v13 = 0;
  char v14 = 0;
  float32x4_t v15 = vsubq_f32(v12, v69);
  int32x4_t v16 = (int32x4_t)vmulq_f32(v15, v15);
  v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2), vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.i8, 1))).u32[0];
  float32x2_t v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
  float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
  float32x4_t v64 = vmulq_n_f32(v15, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]);
  float32x4_t v65 = 0u;
  uint64_t v19 = 2;
  float32x4_t v66 = vnegq_f32(v64);
  float32x4_t v67 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), (int8x16_t)v64, 0xCuLL);
  do
  {
    *(double *)v20.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a1, v8[v19]);
    float32x4_t v21 = vsubq_f32(v20, v69);
    float32x4_t v22 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL), v66), v21, v67);
    float32x4_t v23 = vmulq_f32(v22, v22);
    if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), v23)).f32[0] != 0.0)
    {
      float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL);
      float32x4_t v25 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), v66), v24, v67);
      float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL);
      int32x4_t v27 = (int32x4_t)vmulq_f32(v25, v25);
      v27.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), *(float32x2_t *)v27.i8)).u32[0];
      float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
      float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28)));
      float32x4_t v30 = vmulq_n_f32(v26, vmul_f32(v29, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v29, v29))).f32[0]);
      if (v14)
      {
        float32x4_t v31 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), vnegq_f32(v65)), v30, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v65, (int32x4_t)v65), (int8x16_t)v65, 0xCuLL));
        float32x4_t v32 = vmulq_f32(v31, v31);
        char v14 = 1;
        if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), v32)).f32[0] > 0.00001)break; {
      }
        }
      else
      {
        char v14 = 1;
        float32x4_t v65 = v30;
      }
    }
    BOOL v13 = ++v19 >= (unint64_t)a3;
  }
  while (a3 != v19);
  if (v13 && (v14 & 1) != 0)
  {
    BOOL v33 = (char *)malloc_type_malloc(80 * a3, 0x1000040392EC4B1uLL);
    uint64_t v34 = 0;
    double v35 = 0.0;
    long long v68 = *MEMORY[0x263F00148];
    double v36 = 0.0;
    double v37 = 0.0;
    double v38 = 0.0;
    do
    {
      *(double *)v39.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a1, *v8);
      float32x4_t v40 = vsubq_f32(v39, v69);
      float32x4_t v41 = vmulq_f32(v64, v40);
      double v42 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0];
      float32x4_t v43 = vmulq_f32(v65, v40);
      double v44 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v43, 2), vaddq_f32(v43, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 1))).f32[0];
      int32x4_t v45 = (double *)&v33[v34];
      int v46 = *v8++;
      *int32x4_t v45 = v42;
      v45[1] = v44;
      *((_OWORD *)v45 + 1) = v68;
      *((_OWORD *)v45 + 2) = v68;
      *((_OWORD *)v45 + 3) = v68;
      v45[8] = 0.0;
      *((unsigned char *)v45 + 72) = 0;
      *((_DWORD *)v45 + 19) = v46;
      double v47 = fmin(v38, v42);
      double v48 = fmin(v36, v44);
      double v49 = fmax(v37, v42);
      double v50 = fmax(v35, v44);
      if (v34) {
        double v38 = v47;
      }
      else {
        double v38 = v42;
      }
      if (v34) {
        double v37 = v49;
      }
      else {
        double v37 = v42;
      }
      if (v34) {
        double v36 = v48;
      }
      else {
        double v36 = v44;
      }
      if (v34) {
        double v35 = v50;
      }
      else {
        double v35 = v44;
      }
      v34 += 80;
    }
    while (80 * a3 != v34);
    uint64_t v83 = 0;
    float32x4_t v76 = v33;
    unsigned int v77 = a3;
    unsigned int v78 = a3;
    double v79 = v38 + -1.0;
    double v80 = v37 + 1.0;
    double v81 = v36 + -1.0;
    double v82 = v35 + 1.0;
    int Orientation = C3DShapeBoundaryGetOrientation((unsigned int *)&v76);
    if (Orientation != 2) {
      C3DShapeBoundaryReverse(&v76);
    }
    unsigned int v75 = 0;
    float32x4_t v70 = &v76;
    int v71 = 1;
    uint64_t v73 = 0;
    uint64_t v72 = 0;
    int v74 = 0;
    float32x4_t v52 = C3DShapeConnectedComponentTriangulate((uint64_t)&v70, &v75);
    float v53 = malloc_type_malloc(12 * v75, 0x100004052888210uLL);
    float32x2_t v6 = v53;
    if (v75)
    {
      unint64_t v54 = 0;
      uint64_t v55 = 1;
      if (Orientation == 2) {
        uint64_t v56 = 1;
      }
      else {
        uint64_t v56 = 2;
      }
      if (Orientation == 2) {
        uint64_t v55 = 2;
      }
      unsigned int v57 = 2;
      float32x4_t v58 = v52;
      do
      {
        v53[v57 - 2] = *(_DWORD *)(*v58 + 76);
        v53[v57 - 1] = *(_DWORD *)(v58[v56] + 76);
        v53[v57] = *(_DWORD *)(v58[v55] + 76);
        ++v54;
        v57 += 3;
        v58 += 7;
      }
      while (v54 < v75);
    }
    else if (!v52)
    {
LABEL_47:
      free(v33);
      *a4 = (int)v52;
      return v6;
    }
    free(v52);
    LODWORD(v52) = 3 * v75;
    goto LABEL_47;
  }
  int32x4_t v59 = malloc_type_malloc(4 * (3 * v5), 0x100004052888210uLL);
  float32x2_t v6 = v59;
  uint64_t v60 = 0;
  unsigned int v61 = 2;
  do
  {
    v59[v61 - 2] = *v8;
    uint32x4_t v62 = &v8[v60];
    v59[v61 - 1] = v62[1];
    v59[v61] = v62[2];
    v61 += 3;
    ++v60;
  }
  while (v5 != v60);
  *a4 = 3 * v5;
  return v6;
}

void sub_20B2F42FC(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C407B4F9BAFLL);
  _Unwind_Resume(a1);
}

void sub_20B2F4368(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40CC86CA3FLL);
  _Unwind_Resume(a1);
}

void sub_20B2F43D4(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40CC86CA3FLL);
  _Unwind_Resume(a1);
}

void sub_20B2F4440(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C407B4F9BAFLL);
  _Unwind_Resume(a1);
}

void sub_20B2F4588(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40CC86CA3FLL);
  _Unwind_Resume(a1);
}

void sub_20B2F45F4(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40CC86CA3FLL);
  _Unwind_Resume(a1);
}

void sub_20B2F4754(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C404D916FF5);
  _Unwind_Resume(a1);
}

void sub_20B2F4814(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C407B4F9BAFLL);
  _Unwind_Resume(a1);
}

void sub_20B2F49EC(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40F20E8228);
  _Unwind_Resume(a1);
}

void sub_20B2F4F04(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1081C40F20E8228);
  _Unwind_Resume(a1);
}

void *SCNMTLComputeCommandEncoder::setBytes(SCNMTLComputeCommandEncoder *this, const void *a2, size_t a3, unint64_t a4)
{
  bufferPool = this->_bufferPool;
  if (!bufferPool)
  {
    float32x4_t result = (void *)[(MTLComputeCommandEncoder *)this->_encoder setBytes:a2 length:a3 atIndex:a4];
    float32x4_t v11 = &this->_buffers[a4];
    *float32x4_t v11 = 0;
    v11[31] = 0;
    return result;
  }
  char v14 = 0;
  float32x4_t v15 = 0;
  int32x4_t v16 = 0;
  float32x4_t result = SCNMTLBufferPool::allocateAndCopy(bufferPool, a2, a3, &v14);
  float32x4_t v8 = v16;
  if (this->_buffers[a4] == v15)
  {
    float32x4_t v12 = &this->_buffers[a4];
    BOOL v13 = v12[31];
    float32x2_t v10 = v12 + 31;
    if (v13 == v16) {
      return result;
    }
  }
  else
  {
    int v9 = &this->_buffers[a4];
    float32x4_t *v9 = v15;
    float32x2_t v10 = v9 + 31;
  }
  *float32x2_t v10 = v8;
  this->_buffersToBind[a4 >> 6] |= 1 << a4;
  return result;
}

uint64_t SCNMTLComputeCommandEncoder::dispatch(SCNMTLComputeCommandEncoder *this, MTLComputePipelineState *a2, MTLSize *a3, MTLSize *a4)
{
  if (this->_computePipelineState != a2)
  {
    this->_computePipelineState = a2;
    [(MTLComputeCommandEncoder *)this->_encoder setComputePipelineState:a2];
  }
  MTLSize v9 = *a3;
  MTLSize v8 = *a4;
  return SCNMTLComputeCommandEncoder::dispatch(this, &v9, &v8);
}

uint64_t SCNMTLComputeCommandEncoder::dispatch(SCNMTLComputeCommandEncoder *this, MTLSize *a2, MTLSize *a3)
{
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  encoder = this->_encoder;
  MTLSize v9 = *a2;
  MTLSize v8 = *a3;
  return [(MTLComputeCommandEncoder *)encoder dispatchThreadgroups:&v9 threadsPerThreadgroup:&v8];
}

void C3D::DOFDownsampleCoCPass::DOFDownsampleCoCPass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *uint64_t v5 = &unk_26BF6DE20;
  v5[14] = a4;
}

const char *C3D::DOFDownsampleCoCPass::name(C3D::DOFDownsampleCoCPass *this)
{
  return "DOFDownsampleCoCPass";
}

uint64_t C3D::DOFDownsampleCoCPass::setup(float **this)
{
  uint64_t v1 = this;
  C3D::Pass::setInputCount((C3D::Pass *)this, 1u);
  C3D::Pass::setOutputCount((C3D::Pass *)v1, 1u);
  uint64_t v2 = (*((uint64_t (**)(float **))*v1 + 11))(v1);
  int v3 = (int)fmax(*(float *)(v2 + 8) * 0.5 / *v1[14], 1.0);
  float32x4_t v4 = (C3D::PassDescriptor *)(v1 + 4);
  *(_WORD *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(v1 + 4), 0) + 16) = v3;
  int v5 = (int)fmax(*(float *)(v2 + 12) * 0.5 / *v1[14], 1.0);
  *(_WORD *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(v1 + 4), 0) + 1_Block_object_dispose(&STACK[0x2A0], 8) = v5;
  *(_WORD *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(v1 + 4), 0) + 2_Block_object_dispose(&STACK[0x2A0], 8) = 115;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(v1 + 4), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "DofColorCoC";
  int v6 = (int)fmax(*(float *)(v2 + 8) * 0.5 / *v1[14] * 0.25, 1.0);
  *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(v1 + 4), 0) + 16) = v6;
  LODWORD(v1) = (int)fmax(*(float *)(v2 + 12) * 0.5 / *v1[14] * 0.25, 1.0);
  *(_WORD *)(C3D::PassDescriptor::outputAtIndex(v4, 0) + 1_Block_object_dispose(&STACK[0x2A0], 8) = (_WORD)v1;
  uint64_t result = C3D::PassDescriptor::outputAtIndex(v4, 0);
  *(_WORD *)(result + 2_Block_object_dispose(&STACK[0x2A0], 8) = 115;
  return result;
}

uint64_t C3D::DOFDownsampleCoCPass::compile(C3D::DOFDownsampleCoCPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::DOFDownsampleCoCPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v3);
  *((void *)this + 15) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::DOFDownsampleCoCPass::execute(C3D::Pass *this, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *((void *)this + 14);
  int v6 = *(MTLBuffer **)(v4 + 40);
  unint64_t v5 = *(void *)(v4 + 48);
  if ((*a2)->_buffers[0] == v6)
  {
    if (v3->_offsets[0] == v5) {
      goto LABEL_5;
    }
  }
  else
  {
    v3->_buffers[0] = v6;
  }
  v3->_offsets[0] = v5;
  v3->_buffersToBind[0] |= 1uLL;
LABEL_5:
  float32x2_t v7 = C3D::Pass::inputTextureAtIndex(this, 0);
  if ((void **)v3->_textures[0] != v7)
  {
    v3->_textures[0] = (MTLTexture *)v7;
    v3->_texturesToBind[0] |= 1uLL;
  }
  MTLSize v8 = (MTLTexture *)C3D::Pass::outputTextureAtIndex(this, 0);
  if (v3->_textures[1] != v8)
  {
    v3->_textures[1] = v8;
    v3->_texturesToBind[0] |= 2uLL;
  }
  MTLSize v9 = C3D::Pass::outputTextureAtIndex(this, 0);
  uint64_t v10 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)this + 15) + 16);
  float32x4_t v11 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v10);

  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v9, v11);
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnTexture2D(SCNMTLComputeCommandEncoder *a1, void *a2, MTLComputePipelineState *a3)
{
  if (a1->_computePipelineState != a3)
  {
    a1->_computePipelineState = a3;
    -[MTLComputeCommandEncoder setComputePipelineState:](a1->_encoder, "setComputePipelineState:");
  }
  unint64_t v5 = [a2 width];
  unint64_t v6 = [a2 height];

  return SCNMTLComputeCommandEncoder::dispatchOnGrid2D(a1, v5, v6);
}

void C3D::DOFDownsampleCoCPassResource::~DOFDownsampleCoCPassResource(C3D::DOFDownsampleCoCPassResource *this)
{
  *(void *)this = &unk_26BF6E640;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E640;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

uint64_t _C3DNodeIterateTreePreOrder(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (!*a2 || (uint64_t v6 = (*a2)(a1, a3)) == 0)
  {
    float32x2_t v7 = a2[1];
    if (!v7)
    {
      uint64_t v6 = 0;
LABEL_10:
      v10[0] = MEMORY[0x263EF8330];
      v10[1] = 0x40000000;
      v10[2] = ___C3DNodeIterateTreePreOrder_block_invoke;
      v10[3] = &__block_descriptor_tmp_5;
      v10[4] = a2;
      v10[5] = a3;
      if (C3DNodeApplyChildrenInterruptible(a1, (uint64_t)v10)) {
        uint64_t v6 = 3;
      }
      goto LABEL_12;
    }
    uint64_t v6 = v7(a1, a3);
  }
  if ((unint64_t)(v6 - 4) <= 0xFFFFFFFFFFFFFFFDLL) {
    goto LABEL_10;
  }
LABEL_12:
  MTLSize v8 = (void (*)(uint64_t, uint64_t))a2[2];
  if (v8) {
    v8(a1, a3);
  }
  return v6;
}

uint64_t _C3DNodeIterateTreePostOrder(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (!*a2)
  {
    uint64_t v6 = 0;
    goto LABEL_6;
  }
  uint64_t v6 = (*a2)(a1, a3);
  if ((unint64_t)(v6 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_6:
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    v10[2] = ___C3DNodeIterateTreePostOrder_block_invoke;
    v10[3] = &__block_descriptor_tmp_1;
    v10[4] = a2;
    v10[5] = a3;
    C3DNodeApplyChildrenInterruptible(a1, (uint64_t)v10);
  }
  float32x2_t v7 = (void (*)(uint64_t, uint64_t))a2[2];
  if (v7) {
    v7(a1, a3);
  }
  if (!v6)
  {
    MTLSize v8 = a2[1];
    if (v8) {
      return v8(a1, a3);
    }
    return 0;
  }
  return v6;
}

uint64_t C3DNodeIterateTree(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  if (!a1 && (MTLSize v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DNodeIterateTree_cold_2(v8);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  MTLSize v9 = scn_default_log();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
    C3DNodeIterateTree_cold_1(v9);
  }
LABEL_6:
  if (a3) {
    return _C3DNodeIterateTreePostOrder(a1, a2, a4);
  }
  else {
    return _C3DNodeIterateTreePreOrder(a1, a2, a4);
  }
}

__n128 C3DPlaneMakeWithVectors(__n128 *a1, float32x4_t *a2, float32x4_t *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DPlaneMakeWithVectors_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  char v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DPlaneMakeWithVectors_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    float32x4_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DPlaneMakeWithVectors_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  __n128 result = *(__n128 *)a3;
  result.n128_u32[3] = a1->n128_u32[3];
  *a1 = result;
  float32x4_t v30 = vmulq_f32(*a2, *a3);
  result.n128_f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
  *a1 = result;
  return result;
}

BOOL C3DPlaneMakeWithPoints(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t v4 = vsubq_f32(*a4, *a2);
  float32x4_t v5 = vsubq_f32(*a3, *a2);
  float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL), vnegq_f32(v4)), v5, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL));
  float32x4_t v7 = vmulq_f32(v6, v6);
  int32x2_t v8 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), v7)).u64[0];
  *(float *)v8.i32 = sqrtf(*(float *)v8.i32);
  if (*(float *)v8.i32 == 0.0)
  {
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
    float v11 = 0.0;
    *(void *)a1 = 0;
  }
  else
  {
    float32x4_t v9 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL), (float32x4_t)vdupq_lane_s32(v8, 0));
    *(void *)a1 = v9.i64[0];
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = v9.i32[2];
    float32x4_t v10 = vmulq_f32(v9, *a4);
    float v11 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  }
  *(float *)(a1 + 12) = v11;
  return *(float *)v8.i32 != 0.0;
}

BOOL C3DPlaneMakeWithTriangle(uint64_t a1, uint64_t a2)
{
  float32x4_t v4 = (float32x4_t *)C3DTriangle3PointAtIndex(a2, 0);
  float32x4_t v5 = (float32x4_t *)C3DTriangle3PointAtIndex(a2, 1u);
  float32x4_t v6 = (float32x4_t *)C3DTriangle3PointAtIndex(a2, 2u);

  return C3DPlaneMakeWithPoints(a1, v4, v5, v6);
}

uint64_t C3DGeometryCreateSmoothIcosahedron(int a1, float a2)
{
  values[3] = *(void **)MEMORY[0x263EF8340];
  values[0] = (void *)__CreateSmoothIcosahedronSource(0, a2);
  values[1] = (void *)__CreateSmoothIcosahedronSource(1, a2);
  values[2] = (void *)__CreateSmoothIcosahedronSource(3, a2);
  float32x4_t v4 = (const void *)C3DMeshElementCreate();
  CFTypeRef cf = v4;
  if (a1)
  {
    if (a1 == 2)
    {
      long long v28 = xmmword_20B5CBB58;
      long long v29 = unk_20B5CBB68;
      long long v30 = xmmword_20B5CBB78;
      long long v24 = xmmword_20B5CBB18;
      long long v25 = unk_20B5CBB28;
      long long v26 = xmmword_20B5CBB38;
      long long v27 = unk_20B5CBB48;
      long long v20 = xmmword_20B5CBAD8;
      long long v21 = unk_20B5CBAE8;
      long long v22 = xmmword_20B5CBAF8;
      long long v23 = *(_OWORD *)asc_20B5CBB08;
      *(_OWORD *)bytes = xmmword_20B5CBA98;
      long long v17 = unk_20B5CBAA8;
      long long v18 = xmmword_20B5CBAB8;
      long long v19 = unk_20B5CBAC8;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 240);
      uint64_t v7 = (uint64_t)v4;
      int v8 = 60;
    }
    else
    {
      if (a1 != 3)
      {
        CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        goto LABEL_9;
      }
      *(_OWORD *)bytes = xmmword_20B5CBB88;
      *(void *)&long long v17 = 0x10000F000E000DLL;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 24);
      uint64_t v7 = (uint64_t)v4;
      int v8 = 12;
    }
  }
  else
  {
    long long v20 = xmmword_20B5CBA60;
    long long v21 = unk_20B5CBA70;
    long long v22 = xmmword_20B5CBA80;
    *(void *)&long long v23 = 0x14000F000E0013;
    *(_OWORD *)bytes = xmmword_20B5CBA20;
    long long v17 = unk_20B5CBA30;
    long long v18 = xmmword_20B5CBA40;
    long long v19 = unk_20B5CBA50;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 120);
    uint64_t v7 = (uint64_t)v4;
    int v8 = 20;
  }
  C3DMeshElementSetPrimitives(v7, v8, v6, 2);
  CFRelease(v6);
LABEL_9:
  bytes[2] = 0;
  *(_WORD *)bytes = 0;
  float32x4_t v9 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
  CFArrayRef v10 = CFArrayCreate(v5, (const void **)values, 3, MEMORY[0x263EFFF70]);
  CFArrayRef v11 = CFArrayCreate(v5, &cf, 1, v9);
  uint64_t v12 = C3DMeshCreateWithMeshSourcesAndMeshElements(v10, v11, (uint64_t)bytes);
  for (uint64_t i = 0; i != 3; ++i)
    CFRelease(values[i]);
  CFRelease(cf);
  CFRelease(v10);
  CFRelease(v11);
  return v12;
}

uint64_t __CreateSmoothIcosahedronSource(int a1, float a2)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  *(double *)v4.i64 = (float)(a2 + a2) * 2.23606798;
  *(float *)&unsigned int v5 = *(double *)v4.i64 / 5.0;
  v4.f32[0] = *(double *)v4.i64 / 10.0;
  float v76 = *(float *)&v5;
  __int32 v77 = v4.i32[0];
  float v6 = -v4.f32[0];
  v4.i32[0] = 0;
  float v66 = v6;
  v4.f32[1] = v6;
  v4.i64[1] = v5;
  float32x4_t v67 = v4;
  *(float32x2_t *)v7.f32 = C3DVector3EulerRotate(v4, (__n128)xmmword_20B5CB960);
  float32x4_t v70 = v7;
  *(float32x2_t *)v8.f32 = C3DVector3EulerRotate(v7, (__n128)xmmword_20B5CB960);
  float32x4_t v71 = v8;
  *(float32x2_t *)v9.f32 = C3DVector3EulerRotate(v8, (__n128)xmmword_20B5CB960);
  float32x4_t v72 = v9;
  *(float32x2_t *)v10.f32 = C3DVector3EulerRotate(v9, (__n128)xmmword_20B5CB960);
  float32x4_t v69 = v10;
  v10.i32[0] = 0;
  v10.i32[3] = 0;
  v10.i32[1] = v77;
  v10.f32[2] = -v76;
  float32x4_t v68 = v10;
  *(float32x2_t *)v11.f32 = C3DVector3EulerRotate(v10, (__n128)xmmword_20B5CB960);
  float32x4_t v73 = v11;
  *(float32x2_t *)v12.f32 = C3DVector3EulerRotate(v11, (__n128)xmmword_20B5CB960);
  float32x4_t v74 = v12;
  *(float32x2_t *)v13.f32 = C3DVector3EulerRotate(v12, (__n128)xmmword_20B5CB960);
  float32x4_t v75 = v13;
  *(float32x2_t *)v14.f32 = C3DVector3EulerRotate(v13, (__n128)xmmword_20B5CB960);
  switch(a1)
  {
    case 0:
      *(_DWORD *)bytes = 0;
      *(float *)&bytes[4] = -a2;
      *(void *)&bytes[8] = 0;
      *(float *)&long long v79 = -a2;
      *(void *)((char *)&v79 + 4) = 0;
      *((float *)&v79 + 3) = -a2;
      *(void *)double v80 = 0;
      *(float *)&v80[8] = -a2;
      *(void *)&v80[12] = 0;
      *(float *)&v80[20] = -a2;
      *(void *)&v80[24] = 0;
      *(float *)&v80[32] = v66;
      *(float *)&v80[36] = v76;
      float32x4_t v60 = v70;
      v60.i32[3] = v71.i32[0];
      *(float32x4_t *)&v80[40] = v60;
      *(int8x16_t *)&v80[56] = vextq_s8(vextq_s8((int8x16_t)v71, (int8x16_t)v71, 0xCuLL), (int8x16_t)v72, 8uLL);
      *(int8x16_t *)&v80[72] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v72, (int32x4_t)v72), (int8x16_t)v69, 0xCuLL);
      *(_DWORD *)&v80[88] = 0;
      *(float *)&v80[92] = v66;
      *(float *)&v80[96] = v76;
      float32x4_t v61 = v75;
      v61.i32[3] = v14.i32[0];
      *(float32x4_t *)&v80[100] = v61;
      *(void *)&v80[116] = vextq_s8((int8x16_t)v14, (int8x16_t)v14, 4uLL).u64[0];
      *(_DWORD *)&v80[124] = 0;
      float32x4_t v62 = v73;
      v62.i32[3] = v74.i32[0];
      *(_DWORD *)&v80[128] = v77;
      *(float *)&v80[132] = -v76;
      *(float32x4_t *)&v80[136] = v62;
      *(void *)&v80[152] = vextq_s8((int8x16_t)v74, (int8x16_t)v74, 4uLL).u64[0];
      LODWORD(v81) = 0;
      *((float *)&v81 + 1) = a2;
      *((void *)&v81 + 1) = 0;
      *(void *)((char *)&v82 + 4) = 0;
      *(float *)&long long v82 = a2;
      *((float *)&v82 + 3) = a2;
      *(void *)uint64_t v83 = 0;
      *(void *)&v83[12] = 0;
      *(float *)&v83[8] = a2;
      *(float *)&v83[20] = a2;
      int v84 = 0;
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 252);
      CFDataRef v16 = v15;
      __int16 v17 = 0;
      goto LABEL_7;
    case 1:
      int32x4_t v19 = (int32x4_t)vmulq_f32(v69, v69);
      v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v19, 2), vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1))).u32[0];
      float32x2_t v20 = vrsqrte_f32((float32x2_t)v19.u32[0]);
      float32x2_t v21 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v20, v20)));
      float32x4_t v22 = vmulq_n_f32(v69, vmul_f32(v21, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v21, v21))).f32[0]);
      int32x4_t v23 = (int32x4_t)vmulq_f32(v67, v67);
      v23.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v23, 2), vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1))).u32[0];
      float32x2_t v24 = vrsqrte_f32((float32x2_t)v23.u32[0]);
      float32x2_t v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)v23.u32[0], vmul_f32(v24, v24)));
      v23.i32[0] = vmul_f32(v25, vrsqrts_f32((float32x2_t)v23.u32[0], vmul_f32(v25, v25))).u32[0];
      int32x4_t v26 = (int32x4_t)vmulq_f32(v70, v70);
      v26.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v26, 2), vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v26.i8, 1))).u32[0];
      int8x16_t v27 = (int8x16_t)vmulq_n_f32(v67, *(float *)v23.i32);
      float32x2_t v28 = vrsqrte_f32((float32x2_t)v26.u32[0]);
      float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v28, v28)));
      int8x16_t v30 = (int8x16_t)vmulq_n_f32(v70, vmul_f32(v29, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v29, v29))).f32[0]);
      int32x4_t v31 = (int32x4_t)vmulq_f32(v71, v71);
      v31.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))).u32[0];
      float32x2_t v32 = vrsqrte_f32((float32x2_t)v31.u32[0]);
      float32x2_t v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v32, v32)));
      v31.i32[0] = vmul_f32(v33, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v33, v33))).u32[0];
      int32x4_t v34 = (int32x4_t)vmulq_f32(v72, v72);
      int8x16_t v35 = (int8x16_t)vmulq_n_f32(v71, *(float *)v31.i32);
      v34.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v34, 2), vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1))).u32[0];
      float32x2_t v36 = vrsqrte_f32((float32x2_t)v34.u32[0]);
      float32x2_t v37 = vmul_f32(v36, vrsqrts_f32((float32x2_t)v34.u32[0], vmul_f32(v36, v36)));
      int8x16_t v38 = (int8x16_t)vmulq_n_f32(v72, vmul_f32(v37, vrsqrts_f32((float32x2_t)v34.u32[0], vmul_f32(v37, v37))).f32[0]);
      int32x4_t v39 = (int32x4_t)vmulq_f32(v73, v73);
      v39.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v39, 2), vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.i8, 1))).u32[0];
      float32x2_t v40 = vrsqrte_f32((float32x2_t)v39.u32[0]);
      float32x2_t v41 = vmul_f32(v40, vrsqrts_f32((float32x2_t)v39.u32[0], vmul_f32(v40, v40)));
      int8x16_t v42 = (int8x16_t)vmulq_n_f32(v73, vmul_f32(v41, vrsqrts_f32((float32x2_t)v39.u32[0], vmul_f32(v41, v41))).f32[0]);
      int32x4_t v43 = (int32x4_t)vmulq_f32(v74, v74);
      v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
      float32x2_t v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
      float32x2_t v45 = vmul_f32(v44, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)));
      int8x16_t v46 = (int8x16_t)vmulq_n_f32(v74, vmul_f32(v45, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v45, v45))).f32[0]);
      int32x4_t v47 = (int32x4_t)vmulq_f32(v75, v75);
      v47.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v47, 2), vadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v47.i8, 1))).u32[0];
      float32x2_t v48 = vrsqrte_f32((float32x2_t)v47.u32[0]);
      float32x2_t v49 = vmul_f32(v48, vrsqrts_f32((float32x2_t)v47.u32[0], vmul_f32(v48, v48)));
      v47.i32[0] = vmul_f32(v49, vrsqrts_f32((float32x2_t)v47.u32[0], vmul_f32(v49, v49))).u32[0];
      int32x4_t v50 = (int32x4_t)vmulq_f32(v14, v14);
      v50.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1))).u32[0];
      int8x16_t v51 = (int8x16_t)vmulq_n_f32(v75, *(float *)v47.i32);
      float32x2_t v52 = vrsqrte_f32((float32x2_t)v50.u32[0]);
      float32x2_t v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v52, v52)));
      int8x16_t v54 = (int8x16_t)vmulq_n_f32(v14, vmul_f32(v53, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v53, v53))).f32[0]);
      int32x4_t v55 = (int32x4_t)vmulq_f32(v68, v68);
      v55.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v55, 2), vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v55.i8, 1))).u32[0];
      float32x2_t v56 = vrsqrte_f32((float32x2_t)v55.u32[0]);
      float32x2_t v57 = vmul_f32(v56, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(v56, v56)));
      *(_OWORD *)bytes = xmmword_20B5CB8B0;
      long long v79 = xmmword_20B5CBA10;
      *(_OWORD *)double v80 = xmmword_20B5CB810;
      *(void *)&v80[16] = 0xBF80000000000000;
      v22.i32[3] = v27.i32[0];
      int8x16_t v58 = vextq_s8(v27, v27, 0xCuLL);
      v27.i32[3] = v30.i32[0];
      *(_DWORD *)&v80[24] = 0;
      *(int8x16_t *)&v80[28] = v27;
      *(int8x16_t *)&v80[44] = vextq_s8(vextq_s8(v30, v30, 0xCuLL), v35, 8uLL);
      *(int8x16_t *)&v80[60] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), v38, 0xCuLL);
      float32x4_t v59 = vmulq_n_f32(v68, vmul_f32(v57, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(v57, v57))).f32[0]);
      *(float32x4_t *)&v80[76] = v22;
      *(int8x16_t *)&v80[92] = vextq_s8(v58, v51, 8uLL);
      *(int8x16_t *)&v80[108] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), v54, 0xCuLL);
      v59.i32[3] = v42.i32[0];
      *(float32x4_t *)&v80[124] = v59;
      *(int8x16_t *)&v80[140] = vextq_s8(vextq_s8(v42, v42, 0xCuLL), v46, 8uLL);
      *(_DWORD *)&v80[156] = v46.i32[2];
      long long v81 = xmmword_20B5CB7D0;
      long long v82 = xmmword_20B5CB6E0;
      *(_OWORD *)uint64_t v83 = xmmword_20B5CB520;
      *(void *)&v83[16] = 0x3F80000000000000;
      int v84 = 0;
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 252);
      CFDataRef v16 = v15;
      __int16 v17 = 1;
LABEL_7:
      uint64_t v18 = 3;
      goto LABEL_8;
    case 3:
      *(_OWORD *)bytes = xmmword_20B5CB970;
      long long v79 = xmmword_20B5CB980;
      *(_OWORD *)double v80 = xmmword_20B5CB990;
      *(_OWORD *)&v80[16] = xmmword_20B5CB9A0;
      *(_OWORD *)&v80[32] = xmmword_20B5CB9B0;
      *(_OWORD *)&v80[48] = xmmword_20B5CB9C0;
      *(_OWORD *)&v80[64] = xmmword_20B5CB9D0;
      *(_OWORD *)&v80[80] = xmmword_20B5CB9E0;
      *(_OWORD *)&v80[96] = xmmword_20B5CB9F0;
      *(_OWORD *)&v80[112] = xmmword_20B5CBA00;
      *(void *)&v80[128] = 1061997773;
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 168);
      CFDataRef v16 = v15;
      __int16 v17 = 3;
      uint64_t v18 = 2;
LABEL_8:
      int v63 = (const void *)C3DMeshSourceCreate(v15, v17, 21, v18, 1);
      CFRelease(v16);
      uint64_t MutableCopy = C3DMeshSourceCreateMutableCopy((uint64_t)v63);
      if (v63) {
        CFRelease(v63);
      }
      return MutableCopy;
  }

  return C3DMeshSourceCreateMutableCopy(0);
}

uint64_t CreateSphereNormalsAndTexCoordForPoints(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = C3DMeshSourceGetCount(a1);
  if (result >= 1)
  {
    uint64_t v7 = result;
    for (uint64_t i = 0; i != v7; ++i)
    {
      v18.i32[2] = 0;
      v18.i64[0] = 0;
      *(double *)v9.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a1, i);
      int32x4_t v10 = (int32x4_t)vmulq_f32(v9, v9);
      v10.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))).u32[0];
      float32x2_t v11 = vrsqrte_f32((float32x2_t)v10.u32[0]);
      float32x2_t v12 = vmul_f32(v11, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(v11, v11)));
      float32x4_t v18 = vmulq_n_f32(v9, vmul_f32(v12, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(v12, v12))).f32[0]);
      C3DMeshSourceAppendVector3(a2, (uint64_t)&v18, 1);
      float v15 = v18.f32[1];
      float v13 = asinf(v18.f32[0]) / 3.14159265 + 0.5;
      float v16 = v13;
      *(float *)&unsigned int v14 = 1.0 - (asinf(v15) / 3.14159265 + 0.5);
      unint64_t v17 = __PAIR64__(v14, LODWORD(v16));
      uint64_t result = C3DMeshSourceAppendVector2(a3, (uint64_t)&v17, 1);
    }
  }
  return result;
}

uint64_t C3DMeshCreateGeosphere(int a1, uint64_t a2, double a3)
{
  float v5 = a3;
  SmoothIcosahedron = (CFArrayRef *)C3DGeometryCreateSmoothIcosahedron(0, v5);
  unint64_t v7 = 6;
  if (a2 > 6) {
    unint64_t v7 = a2;
  }
  double v8 = (double)(uint64_t)(v7 - 5);
  if (v7 >= 0x138D) {
    double v8 = 5000.0;
  }
  int v9 = vcvtpd_s64_f64(log(v8) / 1.09861229);
  if (v9 < 1)
  {
    float v16 = SmoothIcosahedron;
  }
  else
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    int v11 = v9 + 1;
    float32x2_t v12 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
    do
    {
      SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)SmoothIcosahedron, 0, 0, 0);
      unsigned int v14 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)SmoothIcosahedron, 1, 0, 0);
      values = 0;
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)SmoothIcosahedron, 0, 0);
      values = (void *)C3DMeshSubdivide((uint64_t)SmoothIcosahedron, 0, ElementAtIndex, (uint64_t)SourceWithSemanticAtIndex, (uint64_t)v14, 0, 1);
      float v16 = (CFArrayRef *)C3DMeshCreate();
      C3DMeshAddSource((uint64_t)v16, SourceWithSemanticAtIndex, 0, 0);
      C3DMeshAddSource((uint64_t)v16, v14, 0, 0);
      CFArrayRef v17 = CFArrayCreate(v10, (const void **)&values, 1, v12);
      C3DMeshSetMeshElements((uint64_t)v16, v17);
      CFRelease(v17);
      if (SmoothIcosahedron) {
        CFRelease(SmoothIcosahedron);
      }
      --v11;
      SmoothIcosahedron = v16;
    }
    while (v11 > 1);
  }
  Mutable = (const void *)C3DMeshSourceCreateMutable(0, 1, 0, 3, 1);
  int32x4_t v19 = (const void *)C3DMeshSourceCreateMutable(0, 3, 0, 2, 1);
  float32x2_t v20 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v16, 0, 0, 0);
  CreateSphereNormalsAndTexCoordForPoints((uint64_t)v20, (uint64_t)Mutable, (uint64_t)v19);
  float32x2_t v21 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v16, 1, 0, 0);
  C3DMeshRemoveSource(v16, v21);
  C3DMeshAddSource((uint64_t)v16, Mutable, 0, 0);
  C3DMeshAddSource((uint64_t)v16, v19, 0, 0);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v19) {
    CFRelease(v19);
  }
  C3DMeshSetOriginalElementType((uint64_t)v16, a1);
  uint64_t DeepCopy = C3DMeshCreateDeepCopy((uint64_t)v16);
  if (v16) {
    CFRelease(v16);
  }
  return DeepCopy;
}

uint64_t C3DFXTechniqueCreateFloor(uint64_t a1, __C3DNode *a2)
{
  uint64_t v3 = (const void *)C3DDictionaryNamed(@"C3DFXFloorPass.plist");
  uint64_t v4 = C3DFXTechniqueCreateWithDescription(v3, (uint64_t)a2);
  uint64_t PassNamed = C3DFXTechniqueGetPassNamed(v4, @"SceneKit_renderMirroredScene");
  C3DFXPassSetInitializeCallback(PassNamed, (uint64_t)_initialize);
  C3DFXPassSetShouldExecuteCallback(PassNamed, (uint64_t)_shouldExecute);
  uint64_t v6 = C3DFXTechniqueGetPassNamed(v4, @"SceneKit_renderFloor");
  C3DFXPassSetWillExecuteCallback(v6, (uint64_t)_willExecuteRenderFloor);
  uint64_t Floor = C3DNodeGetFloor((uint64_t)a2);
  PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(v4, 0);
  uint64_t v9 = PassAtIndex;
  if (Floor)
  {
    if (PassAtIndex)
    {
      double ReflectionResolutionScaleFactor = C3DFloorGetReflectionResolutionScaleFactor(Floor);
      *(double *)(v9 + 376) = ReflectionResolutionScaleFactor;
      *(double *)(v9 + 384) = ReflectionResolutionScaleFactor;
      ReflectionSampleuint64_t Count = C3DFloorGetReflectionSampleCount(Floor);
      if (ReflectionSampleCount) {
        *(unsigned char *)(v9 + 176) = ReflectionSampleCount;
      }
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  float32x2_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueCreateFloor_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  if (!v9)
  {
LABEL_8:
    float32x2_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueCreateFloor_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    }
  }
LABEL_10:
  __attachModifierToFloor(a2);
  uint64_t v28 = C3DFXTechniqueGetPassNamed(v4, @"SceneKit_renderFloor");
  InputWithuint64_t Name = C3DFXPassGetInputWithName(v28, @"u_floorReflectionColor");
  CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFStringRef v31 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"SceneKit-floor-color-%p", a2);
  CFStringRef v32 = (CFStringRef)InputWithName[8];
  if (v32 != v31)
  {
    if (v32)
    {
      CFRelease(v32);
      InputWithName[8] = 0;
    }
    if (v31) {
      CFTypeRef v33 = CFRetain(v31);
    }
    else {
      CFTypeRef v33 = 0;
    }
    InputWithName[8] = v33;
  }
  CFRelease(v31);
  if (C3DFloorGetReflectionFalloffEnd(Floor) != 0.0)
  {
    int32x4_t v34 = C3DFXPassGetInputWithName(v28, @"u_floorReflectionDepth");
    CFStringRef v35 = CFStringCreateWithFormat(v30, 0, @"SceneKit-floor-depth-%p", a2);
    CFStringRef v36 = (CFStringRef)v34[8];
    if (v36 != v35)
    {
      if (v36)
      {
        CFRelease(v36);
        v34[8] = 0;
      }
      if (v35) {
        CFTypeRef v37 = CFRetain(v35);
      }
      else {
        CFTypeRef v37 = 0;
      }
      v34[8] = v37;
    }
    CFRelease(v35);
  }
  return v4;
}

CFTypeRef _initialize(uint64_t a1)
{
  return C3DFXPassSetMirrorNode(*(void *)a1, *(CFTypeRef *)(a1 + 16));
}

__C3DFloor *_shouldExecute(__C3DFXPass *a1, __C3DNode *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = (__C3DFloor *)C3DNodeGetFloor((uint64_t)a2);
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    float v5 = __computeFloorOpacity(a2, result);
    float v6 = *(float *)(v4 + 244);
    *(float *)(v4 + 244) = v5;
    if (v6 == 1.0 && v5 != 1.0) {
      __attachModifierToFloor(a2);
    }
    return (__C3DFloor *)(C3DFloorGetReflectivity(v4) != 0.0);
  }
  return result;
}

void _willExecuteRenderFloor(uint64_t *a1)
{
  uint64_t v1 = (float32x4_t *)a1[2];
  if (v1)
  {
    uint64_t Floor = C3DNodeGetFloor(a1[2]);
    if (Floor)
    {
      uint64_t v4 = Floor;
      uint64_t Scene = (__n128 *)C3DEngineContextGetScene(a1[3]);
      v45.i32[2] = 0;
      v45.i64[0] = 0;
      C3DSceneGetUpAxis(Scene, (__n128 *)&v45);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorNormal", &v45);
      v6.i32[0] = v45.i32[1];
      if (v45.f32[1] == 0.0 && (v6.i32[0] = v45.i32[2], v45.f32[2] == 0.0))
      {
        v41.i32[0] = 0;
        v41.f32[1] = -v45.f32[0];
        v41.i32[2] = 0;
        v41.i32[3] = 1.0;
        v46[0].columns[0] = v41;
      }
      else
      {
        v6.i32[1] = 0;
        v6.i32[2] = 0;
        v6.i32[3] = 1.0;
        v46[0].columns[0] = v6;
      }
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorTangent", v46);
      PointOfView = C3DEngineContextGetPointOfView(a1[3]);
      if (PointOfView)
      {
        uint64_t v9 = PointOfView;
        if (C3DNodeGetProjectionInfos((uint64_t)PointOfView, (uint64_t)v46))
        {
          if (*(double *)v46[0].columns[1].i64 >= 10000.0) {
            double v10 = *(double *)v46[0].columns[1].i64;
          }
          else {
            double v10 = 10000.0;
          }
          if (v46[0].columns[0].i8[0])
          {
            double v21 = sqrt(*(double *)v46[0].columns[3].i64 * *(double *)v46[0].columns[3].i64 + v10 * v10);
          }
          else
          {
            double v11 = v47;
            if (v47 < v48) {
              double v11 = v48;
            }
            double v12 = cos(v11 * 0.5 / 180.0 * 3.14159265);
            if (v12 <= 0.0)
            {
              uint64_t v13 = scn_default_log();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
                _willExecuteRenderFloor(v13, v14, v15, v16, v17, v18, v19, v20);
              }
            }
            double v21 = (v10 + v10) / v12;
          }
          v44.columns[0].i32[2] = 0;
          v44.columns[0].i64[0] = 0;
          C3DNodeGetWorldPosition(v9, (__n128 *)&v44);
          float32x4_t v8 = (float32x4_t)v44.columns[0];
          float32_t v22 = v21;
          v8.f32[3] = v22;
        }
      }
      int32x2_t v23 = vdup_laneq_s32((int32x4_t)v8, 3);
      v46[0].columns[0] = (simd_float4)vmlsq_f32(v8, v45, v8);
      *(int32x2_t *)v44.columns[0].f32 = v23;
      float v24 = *(float *)(v4 + 236);
      if (v24 != 0.0)
      {
        v46[0].columns[0].i32[0] = 0;
        *(float *)v23.i32 = v24;
        *(int32x2_t *)v44.columns[0].f32 = v23;
      }
      float v25 = *(float *)(v4 + 240);
      if (v25 != 0.0)
      {
        v46[0].columns[0].i32[2] = 0;
        v44.columns[0].f32[1] = v25;
      }
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorCenter", v46);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorExtent", &v44);
      __n128 Viewport = C3DEngineContextGetViewport((__n128 *)a1[3]);
      float SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(a1[3]);
      Eyeuint64_t Count = C3DEngineContextGetEyeCount(a1[3]);
      float32x4_t v29 = (float32x4_t)Viewport;
      if (EyeCount >= 2)
      {
        *(float *)v27.i32 = (float)EyeCount;
        v28.f32[0] = (float)a1[9];
        int32x4_t v30 = (int32x4_t)vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL);
        *(int32x2_t *)v30.i8 = vdup_lane_s32((int32x2_t)vmul_f32(*(float32x2_t *)v30.i8, *(float32x2_t *)v27.i8), 0);
        *(float32x2_t *)v27.i8 = vdiv_f32(v28, *(float32x2_t *)v27.i8);
        v30.i32[0] = v27.i32[0];
        float32x4_t v29 = (float32x4_t)vtrn2q_s32(vrev64q_s32(vzip1q_s32(v30, v27)), (int32x4_t)Viewport);
      }
      int8x16_t v31 = (int8x16_t)vmulq_n_f32(v29, SuperSamplingFactor);
      __asm { FMOV            V2.2S, #1.0 }
      v31.u64[1] = (unint64_t)vdiv_f32(_D2, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      v46[0].columns[0] = (simd_float4)v31;
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floor_viewport", v46);
      v46[0].columns[0].i32[0] = C3DFloorGetReflectivity(v4);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorReflectivity", v46);
      v46[0].columns[0].i32[0] = C3DFloorGetReflectionFalloffStart(v4);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorFalloffStart", v46);
      float ReflectionFalloffEnd = C3DFloorGetReflectionFalloffEnd(v4);
      float v38 = ReflectionFalloffEnd - C3DFloorGetReflectionFalloffStart(v4);
      if (v38 <= 0.0) {
        float v38 = 1.0;
      }
      v46[0].columns[0].f32[0] = v38;
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorFalloff", v46);
      C3DComputeMirrorPlane(v1, &v45, (__n128 *)v46);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorPlane", v46);
      uint64_t Matrix4x4 = C3DEngineContextGetMatrix4x4(a1[3], 1);
      float32x2_t v40 = (float32x4_t *)C3DEngineContextGetMatrix4x4(a1[3], 0);
      C3DMatrix4x4Mult(Matrix4x4, v40, v46);
      C3DMatrix4x4Invert(v46, &v44);
      C3DFXTechniqueSetValueForSymbol(a1[1], @"u_floorMVP_i", &v44);
    }
  }
}

void __attachModifierToFloor(__C3DNode *a1)
{
  uint64_t Floor = (__C3DFloor *)C3DNodeGetFloor((uint64_t)a1);
  if (Floor)
  {
    uint64_t v3 = (CFTypeRef *)Floor;
    float v4 = __computeFloorOpacity(a1, Floor);
    Mutable = CFArrayCreateMutable(0, 4, MEMORY[0x263EFFF70]);
    CFStringRef v6 = (const __CFString *)C3DGetTextResourceWithNameAllowingHotReload(@"FloorGeomImpl.glsl");
    unint64_t v7 = (const void *)C3DShaderModifiersCreate(v6, 0, 0, 1, 0, 0);
    CFArrayAppendValue(Mutable, v7);
    CFRelease(v7);
    CFStringRef v8 = (const __CFString *)C3DGetTextResourceWithNameAllowingHotReload(@"FloorGeomImpl-metal.h");
    uint64_t v9 = (const void *)C3DShaderModifiersCreate(v8, 0, 0, 0, 0, 0);
    CFArrayAppendValue(Mutable, v9);
    CFRelease(v9);
    if (C3DFloorGetReflectivity((uint64_t)v3) > 0.0)
    {
      double v10 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      if (C3DFloorGetReflectionFalloffEnd((uint64_t)v3) != 0.0) {
        CFDictionaryAddValue(v10, @"USE_FALLOFF", &stru_26BF72F58);
      }
      int v11 = 2 * (v4 != 1.0);
      if (C3DFloorGetReflectionFalloffStart((uint64_t)v3) != 0.0) {
        CFDictionaryAddValue(v10, @"USE_FALLOFF_START", &stru_26BF72F58);
      }
      if (v4 < 1.0) {
        CFDictionaryAddValue(v10, @"USE_TRANSPARENCY", &stru_26BF72F58);
      }
      CFStringRef v12 = (const __CFString *)C3DGetTextResourceWithNameAllowingHotReload(@"FloorImpl.glsl");
      CFStringRef v13 = (const __CFString *)C3DGetTextResourceWithNameAllowingHotReload(@"FloorImpl-metal.h");
      uint64_t v14 = (const void *)C3DShaderModifiersCreate(v12, 2, v10, 1, 0, v11);
      CFArrayAppendValue(Mutable, v14);
      CFRelease(v14);
      uint64_t v15 = (const void *)C3DShaderModifiersCreate(v13, 2, v10, 0, 0, v11);
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
      CFRelease(v10);
    }
    C3DEntitySetAttribute(v3, @"kShaderModifiers", Mutable);
    CFRelease(Mutable);
  }
}

float __computeFloorOpacity(__C3DNode *a1, __C3DFloor *a2)
{
  if (!a1)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __computeFloorOpacity(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = 1.0;
  if (C3DFloorGetReflectivity((uint64_t)a2) != 0.0)
  {
    C3DNodeGetWorldAlpha((uint64_t)a1);
    float v12 = v14;
    MaterialAtuint64_t Index = C3DGeometryGetMaterialAtIndex((uint64_t)a2, 0);
    if (MaterialAtIndex)
    {
      CommonProfile = (float *)C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
      if (CommonProfile) {
        return v12 * C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18);
      }
    }
  }
  return v12;
}

uint64_t C3DFinalizeDeserialization(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v9 = (uint64_t (*)(const void *, uint64_t, uint64_t, uint64_t))ClassWithTypeID[25];
  if (!v9) {
    return 0;
  }

  return v9(a1, a2, a3, a4);
}

void *C3DFillLibraryForSerialization(const void *a1, uint64_t a2, uint64_t a3)
{
  CFGetTypeID(a1);
  uint64_t result = (void *)_CFRuntimeGetClassWithTypeID();
  if (*result == 749405696)
  {
    uint64_t v7 = (uint64_t (*)(const void *, uint64_t, uint64_t))result[26];
    if (v7)
    {
      return (void *)v7(a1, a2, a3);
    }
  }
  return result;
}

uint64_t C3DInitWithPropertyList(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v9 = (uint64_t (*)(const void *, uint64_t, uint64_t, uint64_t))ClassWithTypeID[23];
  if (!v9) {
    return 0;
  }

  return v9(a1, a2, a3, a4);
}

uint64_t C3DCopyPropertyList(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v9 = (uint64_t (*)(const void *, uint64_t, uint64_t, uint64_t))ClassWithTypeID[24];
  if (!v9) {
    return 0;
  }

  return v9(a1, a2, a3, a4);
}

void *C3DSetValue(CFTypeRef cf, void *a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  if (!cf)
  {
    float v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (double v21 = (uint64_t (*)(CFTypeRef, void *, const void *, size_t, uint64_t, uint64_t))ClassWithTypeID[12]) != 0)
  {
    return (void *)v21(cf, a2, a3, a4, a5, a6);
  }
  else
  {
    return memcpy(a2, a3, a4);
  }
}

void *(*C3DGetValueGetter(const void *a1))(int a1, const void *a2, void *__dst, size_t __n)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return _C3DGenericGetValue;
  }
  uint64_t result = (void *(*)(int, const void *, void *, size_t))ClassWithTypeID[13];
  if (!result) {
    return _C3DGenericGetValue;
  }
  return result;
}

void *_C3DGenericGetValue(int a1, const void *a2, void *__dst, size_t __n)
{
  return memcpy(__dst, a2, __n);
}

void *(*C3DGetValueSetter(const void *a1))(int a1, void *__dst, void *__src, size_t __n)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return _C3DGenericSetValue;
  }
  uint64_t result = (void *(*)(int, void *, void *, size_t))ClassWithTypeID[12];
  if (!result) {
    return _C3DGenericSetValue;
  }
  return result;
}

void *_C3DGenericSetValue(int a1, void *__dst, void *__src, size_t __n)
{
  return memcpy(__dst, __src, __n);
}

void *C3DGenericSourceDidChange(CFTypeRef cf, uint64_t a2)
{
  if (!cf)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFGetTypeID(cf);
  uint64_t result = (void *)_CFRuntimeGetClassWithTypeID();
  if (*result == 749405696)
  {
    uint64_t v13 = (uint64_t (*)(CFTypeRef, uint64_t))result[28];
    if (v13) {
      return (void *)v13(cf, a2);
    }
  }
  return result;
}

uint64_t C3DGetBoundingSphere(CFTypeRef cf, uint64_t a2, uint64_t a3)
{
  if (!cf)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (uint64_t v15 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t))ClassWithTypeID[16]) != 0)
  {
    return v15(cf, a2, a3);
  }
  else
  {
    return 0;
  }
}

uint64_t __C3DRemoveSceneRef_block_invoke(int a1, CFTypeRef cf)
{
  return C3DRemoveSceneRef(cf);
}

void _removeFromScene(void *a1, uint64_t a2)
{
  uint64_t AnimationManager = C3DSceneGetAnimationManager(a2);
  if (AnimationManager)
  {
    uint64_t v4 = AnimationManager;
    C3DAnimationManagerRemoveAllAnimationsForObject(AnimationManager, a1);
    C3DAnimationManagerRemoveAllBindings(v4, (uint64_t)a1);
    C3DAnimationManagerRemoveActionsForObject(v4, a1);
  }
}

uint64_t C3DSearchByID(const void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v5 = (uint64_t (*)(const void *, uint64_t))ClassWithTypeID[22];
  if (!v5) {
    return 0;
  }

  return v5(a1, a2);
}

BOOL C3DTypeConformsToProtocol(uint64_t a1, int a2)
{
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  switch(a2)
  {
    case 0:
      uint64_t v4 = ClassWithTypeID + 24;
      break;
    case 1:
      uint64_t v4 = ClassWithTypeID + 13;
      break;
    case 2:
      uint64_t v4 = ClassWithTypeID + 14;
      break;
    case 3:
      uint64_t v4 = ClassWithTypeID + 15;
      break;
    case 4:
      uint64_t v4 = ClassWithTypeID + 17;
      break;
    case 5:
      uint64_t v4 = ClassWithTypeID + 22;
      break;
    default:
      return 0;
  }
  return *v4 != 0;
}

__n128 C3DQuaternionMake(__n128 *a1, __n128 result, float a3, float a4, float a5)
{
  result.n128_f32[1] = a3;
  result.n128_u64[1] = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *a1 = result;
  return result;
}

void C3DQuaternionMakeAxisAngle(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v3 = *a2;
  float32x4_t v4 = vmulq_f32(v3, v3);
  float v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  if (v5 <= 0.000000001)
  {
    float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  }
  else
  {
    float v10 = v5;
    float32x4_t v11 = *a2;
    __float2 v6 = __sincosf_stret(vmuls_lane_f32(0.5, v3, 3));
    float32x2_t v7 = vrsqrte_f32((float32x2_t)LODWORD(v10));
    float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v7, v7)));
    float32x4_t v9 = vmulq_n_f32(vmulq_n_f32(v11, vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v8, v8))).f32[0]), v6.__sinval);
    v9.i32[3] = LODWORD(v6.__cosval);
  }
  *a1 = v9;
}

float32_t C3DQuaternionGetAxisAngle(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v12 = *a1;
  LODWORD(_S_Block_object_dispose(&STACK[0x2A0], 8) = HIDWORD(*(unsigned long long *)a1);
  float v4 = acosf(_S8);
  _Q3 = v12;
  float32_t result = v4 + v4;
  __asm { FMLS            S1, S8, V3.S[3] }
  *(float *)_D1.i32 = sqrtf(*(float *)_D1.i32);
  if (*(float *)_D1.i32 > 0.000001) {
    _Q3 = vdivq_f32(v12, (float32x4_t)vdupq_lane_s32(_D1, 0));
  }
  _Q3.f32[3] = result;
  *a2 = _Q3;
  return result;
}

float32x4_t C3DQuaternionAdd(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t result = vaddq_f32(*a1, *a2);
  *a3 = result;
  return result;
}

__n128 C3DQuaternionConjugate(float32x4_t *a1)
{
  __n128 result = *(__n128 *)a1;
  float32x4_t v2 = vnegq_f32(*a1);
  v2.i32[3] = HIDWORD(*(unsigned long long *)a1);
  *a1 = v2;
  return result;
}

float32x4_t C3DQuaternionNormalize(float32x4_t *a1)
{
  int8x16_t v1 = (int8x16_t)vmulq_f32(*a1, *a1);
  *(float32x2_t *)v1.i8 = vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v1, v1, 8uLL));
  float32x4_t v2 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1)), 0);
  float32x4_t v3 = vrsqrteq_f32(v2);
  float32x4_t v4 = vmulq_f32(v3, vrsqrtsq_f32(v2, vmulq_f32(v3, v3)));
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t result = vmulq_f32(*a1, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v2), _Q3, (int8x16_t)vmulq_f32(v4, vrsqrtsq_f32(v2, vmulq_f32(v4, v4)))));
  *a1 = result;
  return result;
}

float32x4_t C3DQuaternionMult(float32x4_t *a1, int32x4_t *a2, float32x4_t *a3)
{
  int32x4_t v3 = *(int32x4_t *)a1;
  int32x4_t v4 = *a2;
  float32x4_t v5 = *a1;
  v5.i32[3] = (__int32)*a1;
  float32x4_t v6 = (float32x4_t)vzip1q_s32(v4, v4);
  v6.i32[0] = a2->i64[1];
  float32x4_t v7 = vmlaq_f32(vmlaq_laneq_f32(vmulq_f32(vmulq_f32(v5, (float32x4_t)vextq_s8((int8x16_t)vdupq_laneq_s32(*a2, 3), *(int8x16_t *)a2, 4uLL)), (float32x4_t)xmmword_20B5CBBD0), *(float32x4_t *)a2, *a1, 3), (float32x4_t)xmmword_20B5CBBD0, vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), *(int8x16_t *)a1, 8uLL), v6));
  float32x4_t result = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), *(int8x16_t *)a1, 0xCuLL);
  float32x4_t v9 = (float32x4_t)vuzp1q_s32(v4, v4);
  v9.i32[0] = HIDWORD(a2->i64[0]);
  *a3 = vmlsq_f32(v7, v9, result);
  return result;
}

float32x4_t C3DQuaternionSlerp(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float a4, double a5, double a6, double a7, double a8, double a9, float32x4_t _Q6)
{
  _Q3 = *a1;
  float32x4_t v13 = *a2;
  _Q0 = vmulq_f32(*a1, *a2);
  _S1 = a2->i64[1];
  __asm { FMLA            S0, S1, V3.S[2] }
  LODWORD(_S2) = HIDWORD(*(unsigned long long *)a2);
  __asm { FMLA            S6, S2, V3.S[3] }
  if (_Q6.f32[0] >= 0.0) {
    float v21 = _Q6.f32[0];
  }
  else {
    float v21 = -(float)(_Q0.f32[0] + (float)(COERCE_FLOAT(HIDWORD(*(unsigned long long *)a1)) * _S2));
  }
  if (1.0 - v21 <= 0.00100000005)
  {
    float v26 = 1.0 - a4;
  }
  else
  {
    float32x4_t v29 = *a2;
    float32x4_t v30 = *a1;
    float v31 = a4;
    float32x4_t v28 = _Q6;
    float v22 = acosf(v21);
    float v23 = sinf(v22);
    float v24 = sinf((float)(1.0 - v31) * v22);
    float v25 = v22 * v31;
    float v32 = v24 / v23;
    _Q0.f32[0] = sinf(v25);
    _Q3 = v30;
    float v26 = v32;
    _Q6 = v28;
    float32x4_t v13 = v29;
    a4 = _Q0.f32[0] / v23;
  }
  _Q0.i64[0] = 0;
  float32x4_t result = vmlaq_n_f32(vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(_Q0, _Q6), 0), (int8x16_t)vnegq_f32(v13), (int8x16_t)v13), a4), _Q3, v26);
  *a3 = result;
  return result;
}

float C3DQuaternionMakeEuler(_OWORD *a1, float a2, float a3, float a4)
{
  __float2 v7 = __sincosf_stret(a2 * 0.5);
  __float2 v8 = __sincosf_stret(a3 * 0.5);
  __float2 v9 = __sincosf_stret(a4 * 0.5);
  *(float *)&long long v10 = (float)(v7.__sinval * (float)(v8.__cosval * v9.__cosval))
                 - (float)(v7.__cosval * (float)(v8.__sinval * v9.__sinval));
  *((float *)&v10 + 1) = (float)((float)(v7.__sinval * v8.__cosval) * v9.__sinval)
                       + (float)((float)(v7.__cosval * v8.__sinval) * v9.__cosval);
  float result = (float)((float)-(float)(v7.__sinval * v8.__sinval) * v9.__cosval)
         + (float)((float)(v7.__cosval * v8.__cosval) * v9.__sinval);
  *((void *)&v10 + 1) = __PAIR64__((float)(v7.__sinval * (float)(v8.__sinval * v9.__sinval))+ (float)(v7.__cosval * (float)(v8.__cosval * v9.__cosval)), LODWORD(result));
  *a1 = v10;
  return result;
}

double C3DQuaternionGetRotationBetweenQuaternions(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vnegq_f32(a1);
  v2.i32[3] = a1.i32[3];
  int8x16_t v3 = (int8x16_t)vmulq_f32(v2, v2);
  *(float32x2_t *)v3.i8 = vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  float32x4_t v4 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1)), 0);
  float32x4_t v5 = vrsqrteq_f32(v4);
  float32x4_t v6 = vmulq_f32(v5, vrsqrtsq_f32(v4, vmulq_f32(v5, v5)));
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v12 = vmulq_f32(v2, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v4), _Q4, (int8x16_t)vmulq_f32(v6, vrsqrtsq_f32(v4, vmulq_f32(v6, v6)))));
  float32x4_t v13 = a2;
  v13.i32[3] = a2.i32[0];
  float32x4_t v14 = (float32x4_t)vzip1q_s32((int32x4_t)v12, (int32x4_t)v12);
  v14.i32[0] = v12.i32[2];
  float32x4_t v15 = (float32x4_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12);
  v15.i32[0] = v12.i32[1];
  *(void *)&double result = vmlsq_f32(vmlaq_f32(vmlaq_laneq_f32(vmulq_f32(vmulq_f32(v13, (float32x4_t)vextq_s8((int8x16_t)vdupq_laneq_s32((int32x4_t)v12, 3), (int8x16_t)v12, 4uLL)), (float32x4_t)xmmword_20B5CBBD0), v12, a2, 3), (float32x4_t)xmmword_20B5CBBD0, vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a2, (int8x16_t)a2, 0xCuLL), (int8x16_t)a2, 8uLL), v14)), v15, (float32x4_t)vextq_s8(
                                        (int8x16_t)vuzp1q_s32((int32x4_t)a2, (int32x4_t)a2),
                                        (int8x16_t)a2,
                                        0xCuLL)).u64[0];
  return result;
}

void C3DQuaternionGetEuler(float32x4_t *a1, int8x16_t *a2)
{
  float32x4_t v3 = *a1;
  int8x16_t v4 = (int8x16_t)vmulq_f32(v3, v3);
  float v5 = vaddv_f32(vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL)));
  int8x16_t v6 = 0uLL;
  if (v5 != 0.0)
  {
    LODWORD(v7) = a1->i64[1];
    LODWORD(v_Block_object_dispose(&STACK[0x2A0], 8) = HIDWORD(a1->i64[0]);
    LODWORD(v9) = HIDWORD(*(unsigned long long *)a1);
    float v10 = vmlas_n_f32(vmuls_lane_f32(-v3.f32[1], v3, 3), v3.f32[2], v3.f32[0]) / v5;
    if (v10 <= 0.499)
    {
      if (v10 >= -0.499)
      {
        float v13 = *(float *)&v4.i32[1];
        uint64_t v14 = v4.i64[1];
        float32x4_t v17 = *a1;
        int8x16_t v18 = v4;
        float v19 = atan2f((float)((float)(v3.f32[2] * v3.f32[3]) + (float)(v3.f32[0] * v3.f32[1]))+ (float)((float)(v3.f32[2] * v3.f32[3]) + (float)(v3.f32[0] * v3.f32[1])), *(float *)&v4.i32[3] + (float)((float)(*(float *)v4.i32 - *(float *)&v4.i32[1]) - *(float *)&v4.i32[2]));
        *(float *)&uint64_t v15 = atan2f((float)((float)(v17.f32[0] * v9) + (float)(v8 * v7))+ (float)((float)(v17.f32[0] * v9) + (float)(v8 * v7)), *((float *)&v14 + 1) + (float)(*(float *)&v14 + (float)((float)-*(float *)v18.i32 - v13)));
        v18.i64[0] = v15;
        float v16 = asinf(v10 * -2.0);
        int8x16_t v6 = v18;
        *(float *)&v6.i32[1] = v16;
        *(float *)&v6.i32[2] = v19;
        goto LABEL_8;
      }
      *(float *)v6.i32 = atan2f(COERCE_FLOAT(*a1), v3.f32[3]) * -2.0;
      float32x4_t v12 = &dword_20B5CBBB0;
    }
    else
    {
      float v11 = atan2f(COERCE_FLOAT(*a1), v3.f32[3]);
      *(float *)v6.i32 = v11 + v11;
      float32x4_t v12 = &dword_20B5CBBB4;
    }
    v6.i32[1] = *v12;
    v6.i32[2] = 0;
  }
LABEL_8:
  *a2 = v6;
}

C3D::ShadowMapPass *C3D::ShadowMapPass::ShadowMapPass(C3D::ShadowMapPass *this, RenderGraph *a2, C3D::Pass *a3, __C3DNode *a4)
{
  v24[0] = 0;
  v24[1] = a4;
  memset(&v24[2], 0, 24);
  long long v25 = xmmword_20B5CBBE0;
  char v26 = 0;
  uint64_t v27 = 16842752;
  char v28 = 2;
  float v5 = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, (const Parameters *)v24);
  *(void *)float v5 = &unk_26BF6D120;
  CFDictionaryRef Light = C3DNodeGetLight(*((void *)v5 + 31));
  if (!Light)
  {
    float v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3D::ShadowMapPass::ShadowMapPass(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  if ((C3DLightGetCastsShadow((uint64_t)Light) & 1) == 0)
  {
    uint64_t v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3D::ShadowMapPass::ShadowMapPass(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  return this;
}

const char *C3D::ShadowMapPass::name(C3D::ShadowMapPass *this)
{
  return "ShadowMapPass";
}

const char *C3D::ShadowMapPass::programHashCodeStoreName(C3D::ShadowMapPass *this)
{
  return "ShadowMapPass";
}

void C3D::ShadowMapPass::setup(C3D::ShadowMapPass *this)
{
  *((unsigned char *)this + 119) = 0;
  float32x4_t v2 = (void *)*((void *)this + 31);
  float32x4_t v3 = C3D::Pass::nameWithPrefixAndPointer(this, "SceneKit-spotShadowDepth-", v2);
  uint64_t Scene = C3DEngineContextGetScene(*((void *)this + 2));
  uint64_t LightingSystem = C3DSceneGetLightingSystem(Scene);
  C3DLightingSystemSetShadowMapNameForNode(LightingSystem, v2, (const void *)[NSString stringWithUTF8String:v3]);
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t v6 = C3D::PassDescriptor::outputAtIndex((C3D::ShadowMapPass *)((char *)this + 32), 0);
  *(unsigned char *)(v6 + 64) = 2;
  *(void *)(v6 + _Block_object_dispose(&STACK[0x2A0], 8) = v3;
  *(_WORD *)(v6 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 252;
  *(_WORD *)(v6 + 66) = *(_WORD *)(v6 + 66) & 0xFFEC | 0x12;
  CFDictionaryRef Light = C3DNodeGetLight((uint64_t)v2);
  int8x8_t RealShadowMapSize = C3DLightGetRealShadowMapSize((uint64_t)Light);
  *(_WORD *)(v6 + 16) = (int)*(float *)RealShadowMapSize.i32;
  *(_WORD *)(v6 + 1_Block_object_dispose(&STACK[0x2A0], 8) = (int)*(float *)&RealShadowMapSize.i32[1];
  BOOL v9 = C3DLightSupportsShadowCascades((uint64_t)Light);
  ShadowCascadeuint64_t Count = C3DLightGetShadowCascadeCount((uint64_t)Light);
  int Type = C3DLightGetType((uint64_t)Light);
  BOOL v12 = ShadowCascadeCount > 1 && v9;
  if (!v12 && Type != 2)
  {
    *((unsigned char *)this + 121) = 1;
    v13.i32[0] = *(unsigned __int16 *)(v6 + 16);
    v13.i32[1] = *(unsigned __int16 *)(v6 + 18);
    __asm { FMOV            V1.2S, #1.0 }
    *((float32x2_t *)&_Q1 + 1) = vadd_f32(vcvt_f32_u32(v13), (float32x2_t)0xC0000000C0000000);
    *((_OWORD *)this + _Block_object_dispose(&STACK[0x2A0], 8) = _Q1;
LABEL_11:
    char v20 = !v9;
    if (ShadowCascadeCount < 2) {
      char v20 = 1;
    }
    if (v20)
    {
      LOWORD(ShadowCascadeCount) = 1;
      char v21 = 2;
    }
    else
    {
      *(_WORD *)(v6 + 22) = ShadowCascadeCount;
      char v21 = 3;
    }
    *(unsigned char *)(v6 + 24) = v21;
    *((_WORD *)this + 19) = ShadowCascadeCount;
    *(_WORD *)((char *)this + 117) = 0;
    goto LABEL_17;
  }
  if (Type != 2) {
    goto LABEL_11;
  }
  unsigned int v19 = *(unsigned __int16 *)(v6 + 16);
  if (v19 <= *(unsigned __int16 *)(v6 + 18)) {
    LOWORD(v19) = *(_WORD *)(v6 + 18);
  }
  *(_WORD *)(v6 + 16) = v19;
  *(_WORD *)(v6 + 1_Block_object_dispose(&STACK[0x2A0], 8) = v19;
  *(unsigned char *)(v6 + 24) = 5;
LABEL_17:

  C3D::DrawNodesPass::setup(this);
}

void C3D::ShadowMapPass::compile(C3D::ShadowMapPass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::ShadowMapPass *))(*(void *)this + 64))(this);
  uint64_t v3 = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 670) = v3;
  if (!v3) {
    operator new();
  }
  *((void *)this + 32) = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v3 + 16);
  C3D::DrawNodesPass::compile(this);
}

void C3D::ShadowMapPass::execute(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  CFDictionaryRef Light = C3DNodeGetLight(a1[31]);
  float v6 = 2.0;
  if (C3DLightGetForceCasterBackFaceOnly((uint64_t)Light))
  {
    if (!*(unsigned char *)(v4 + 73) && *(void *)(v4 + 16) != 1)
    {
      *(void *)(v4 + 16) = 1;
      *(unsigned char *)(v4 + 41) = 1;
    }
    *(unsigned char *)(v4 + 73) = 1;
    float v6 = 0.0;
  }
  if (C3DLightGetType((uint64_t)Light) != 2)
  {
    float ShadowBias = C3DLightGetShadowBias((uint64_t)Light);
    char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(a1[2]);
    if ((CoordinatesSystemOptions & 8) != 0) {
      *(float *)&double v10 = -v6;
    }
    else {
      *(float *)&double v10 = v6;
    }
    LODWORD(v9) = 1036831949;
    if ((CoordinatesSystemOptions & 8) != 0) {
      *(float *)&double v9 = -10.0;
    }
    *(float *)&double v9 = *(float *)&v9 * ShadowBias;
    [*(id *)(v4 + 3392) setDepthBias:v9 slopeScale:v10 clamp:0.0];
  }

  C3D::DrawNodesPass::execute(a1, (uint64_t)a2);
}

void C3D::ShadowMapPass::_setupPointOfViewMatrices(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  uint64_t Scene = C3DEngineContextGetScene(*(void *)(a1 + 16));
  uint64_t LightingSystem = C3DSceneGetLightingSystem(Scene);
  char CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*(void *)(a1 + 16));
  C3D::DrawNodesPass::_setupPointOfViewMatrices(a1, a2, a3);
  if (*(unsigned char *)(a1 + 302)) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = a1 + 3024;
  }

  C3DLightingSystemComputeShadowMatrices(LightingSystem, a2, v9, a1 + 3792, 0, 0, 0, CoordinatesSystemOptions);
}

void C3D::ShadowMapPass::Resource::~Resource(C3D::ShadowMapPass::Resource *this)
{
  *(void *)this = &unk_26BF6D100;
  int8x16_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6D100;
  int8x16_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x210534FE0);
}

void C3DSphereMake(_OWORD *a1, long long *a2, float a3)
{
  if (!a1
    && (float v24 = a3, v5 = scn_default_log(), v6 = os_log_type_enabled(v5, OS_LOG_TYPE_FAULT), a3 = v24, v6))
  {
    C3DPlaneMakeWithVectors_cold_3(v5, v7, v8, v9, v10, v11, v12, v13);
    a3 = v24;
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float v25 = a3;
  uint64_t v14 = scn_default_log();
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_FAULT);
  a3 = v25;
  if (v15)
  {
    C3DSphereMake_cold_1(v14, v16, v17, v18, v19, v20, v21, v22);
    a3 = v25;
  }
LABEL_6:
  long long v23 = *a2;
  *((float *)&v23 + 3) = a3;
  *a1 = v23;
}

void C3DSphereMakeByMergingSpheres(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t v4 = *a2;
  LODWORD(v5) = HIDWORD(*(unsigned long long *)a2);
  if (v5 < 0.0) {
    goto LABEL_2;
  }
  float32x4_t v7 = *a3;
  LODWORD(v_Block_object_dispose(&STACK[0x2A0], 8) = HIDWORD(*(unsigned long long *)a3);
  if (v8 < 0.0)
  {
LABEL_4:
    float32x4_t v6 = *a2;
    goto LABEL_5;
  }
  float32x4_t v9 = vsubq_f32(v4, v7);
  float32x4_t v10 = vmulq_f32(v9, v9);
  int32x2_t v11 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u64[0];
  float v12 = sqrtf(*(float *)v11.i32);
  if ((float)(v5 + v12) >= v8)
  {
    if ((float)(v8 + v12) >= v5)
    {
      float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v11, 0);
      float32x4_t v14 = vrsqrteq_f32(v13);
      float32x4_t v15 = vmulq_f32(v14, vrsqrtsq_f32(v13, vmulq_f32(v14, v14)));
      int8x16_t v16 = (int8x16_t)vmulq_f32(v15, vrsqrtsq_f32(v13, vmulq_f32(v15, v15)));
      int32x4_t v17 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(*(float *)v11.i32 != 0.0)), 0x1FuLL));
      v17.i32[3] = 0;
      __asm { FMOV            V5.4S, #1.0 }
      float32x4_t v23 = vmulq_f32(v9, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v17), v16, _Q5));
      float32x4_t v24 = vsubq_f32(v7, vmulq_laneq_f32(v23, v7, 3));
      float32x4_t v25 = vaddq_f32(v4, vmulq_laneq_f32(v23, v4, 3));
      float32x4_t v26 = vsubq_f32(v24, v25);
      float32x4_t v27 = vmulq_f32(v26, v26);
      a1->f32[3] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0])* 0.5;
      *(double *)v6.i64 = C3DVector3MidVector(v25, v24);
      v6.i32[3] = a1->i32[3];
      goto LABEL_5;
    }
    if (a2 != a1) {
      goto LABEL_4;
    }
  }
  else if (a3 != a1)
  {
LABEL_2:
    float32x4_t v6 = *a3;
LABEL_5:
    *a1 = v6;
  }
}

float C3DSphereXFormMatrix4x4(float32x4_t *a1, float32x4_t *a2, uint64_t a3)
{
  float32x4_t v6 = *a1;
  float32x4_t v7 = a2[1];
  v12[0] = *a2;
  v12[1] = v7;
  float32x4_t v8 = a2[3];
  float32x4_t v12[2] = a2[2];
  v12[3] = v8;
  *(double *)&long long v9 = C3DVector3MultMatrix4x4(v12, v6);
  HIDWORD(v9) = *(_DWORD *)(a3 + 12);
  *(_OWORD *)a3 = v9;
  v12[0].i32[2] = 0;
  v12[0].i64[0] = 0;
  C3DMatrix4x4GetScale(a2, v12);
  float32x4_t v10 = vabsq_f32(v12[0]);
  float result = a1->f32[3] * fmaxf(fmaxf(v10.f32[0], v10.f32[2]), v10.f32[1]);
  *(float *)(a3 + 12) = result;
  return result;
}

CFTypeRef __CFTypeStackRetainCallback(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void __CFTypeStackReleaseCallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void _C3DStackCFFinalize(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  C3DStackReset(a1);
  float32x4_t v10 = *(void **)(a1 + 16);
  if (v10) {
    free(v10);
  }
}

CFStringRef _C3DStackCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DStack>");
}

CFStringRef _C3DStackCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DStack>");
}

uint64_t __C3DStackGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DStackGetTypeID_typeID = result;
  return result;
}

uint64_t C3DStackCreate(unsigned int a1, uint64_t a2, size_t a3)
{
  if (C3DStackGetTypeID_onceToken != -1) {
    dispatch_once(&C3DStackGetTypeID_onceToken, &__block_literal_global_13);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DStackGetTypeID_typeID, 0x20uLL);
  *(_DWORD *)(Instance + 24) = a1;
  *(void *)(Instance + 32) = a3;
  *(void *)(Instance + 16) = malloc_type_calloc(a1, a3, 0x39951513uLL);
  *(_DWORD *)(Instance + 2_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(void *)(Instance + 40) = a2;
  return Instance;
}

uint64_t C3DStackGetCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 28);
}

void C3DStackPop(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (!*(_DWORD *)(a1 + 28))
  {
    float32x4_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DStackPop_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  --*(_DWORD *)(a1 + 28);
}

uint64_t C3DStackSetValue(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 32) != 8)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DStackSetValue_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t v20 = *(void *)(a1 + 16);
  uint64_t v21 = *(unsigned int *)(a1 + 28);
  uint64_t result = *(void *)(v20 + 8 * v21);
  if (result != a2)
  {
    uint64_t v23 = *(void *)(a1 + 40);
    if (v23)
    {
      (*(void (**)(void))(v23 + 8))();
      uint64_t result = (*(uint64_t (**)(uint64_t))v23)(a2);
      uint64_t v20 = *(void *)(a1 + 16);
      uint64_t v21 = *(unsigned int *)(a1 + 28);
    }
    *(void *)(v20 + 8 * v21) = a2;
  }
  return result;
}

void C3DStackPush(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 28) + 1;
  *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = v11;
  if (v11 >= v10)
  {
    LODWORD(v12) = 2 * v10;
    if (2 * (int)v10 >= (v10 + 1024)) {
      uint64_t v12 = (v10 + 1024);
    }
    else {
      uint64_t v12 = v12;
    }
    *(_DWORD *)(a1 + 24) = v12;
    uint64_t v13 = (char *)malloc_type_realloc(*(void **)(a1 + 16), *(void *)(a1 + 32) * v12, 0x6256DF45uLL);
    *(void *)(a1 + 16) = v13;
    bzero(&v13[*(void *)(a1 + 32) * v10], *(void *)(a1 + 32) * (*(_DWORD *)(a1 + 24) - v10));
  }
}

uint64_t C3DStackGetValue(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(void *)(a1 + 32) != 8)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DStackGetValue_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  return *(void *)(*(void *)(a1 + 16) + *(void *)(a1 + 32) * *(unsigned int *)(a1 + 28));
}

void C3DStackReset(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10)
  {
    unint64_t v11 = *(unsigned int *)(a1 + 24);
    if (v11)
    {
      unint64_t v12 = 0;
      uint64_t v13 = *(void *)(a1 + 16);
      do
      {
        if (*(void *)(v13 + *(void *)(a1 + 32) * v12))
        {
          (*(void (**)(void))(v10 + 8))();
          unint64_t v11 = *(unsigned int *)(a1 + 24);
        }
        ++v12;
      }
      while (v12 < v11);
    }
  }
}

btHingeConstraint *_createConstraintFromDefinition(uint64_t a1)
{
  id v2 = *(id *)a1;
  if (*(void *)(a1 + 8))
  {
    uint64_t v4 = (btRigidBody *)[v2 _handle];
    *(void *)v13.var0.var0 = *(void *)(a1 + 40);
    *(void *)&v13.var0.var0[2] = *(unsigned int *)(a1 + 48);
    *(void *)v12.var0.var0 = *(void *)(a1 + 16);
    *(void *)&v12.var0.var0[2] = *(unsigned int *)(a1 + 24);
    uint64_t v5 = (btRigidBody *)[*(id *)(a1 + 8) _handle];
    *(void *)v11.var0.var0 = *(void *)(a1 + 52);
    *(void *)&v11.var0.var0[2] = *(unsigned int *)(a1 + 60);
    *(void *)v10.var0.var0 = *(void *)(a1 + 28);
    *(void *)&v10.var0.var0[2] = *(unsigned int *)(a1 + 36);
    uint64_t v6 = (btHingeConstraint *)btAlignedAllocInternal(880, 16);
    btHingeConstraint::btHingeConstraint(v6, v4, v5, &v12, &v10, &v13, &v11, 0);
  }
  else
  {
    if (!v2)
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        _createConstraintFromDefinition(v7);
      }
    }
    uint64_t v8 = (btRigidBody *)[*(id *)a1 _handle];
    *(void *)v13.var0.var0 = *(void *)(a1 + 40);
    *(void *)&v13.var0.var0[2] = *(unsigned int *)(a1 + 48);
    *(void *)v12.var0.var0 = *(void *)(a1 + 16);
    *(void *)&v12.var0.var0[2] = *(unsigned int *)(a1 + 24);
    uint64_t v6 = (btHingeConstraint *)btAlignedAllocInternal(880, 16);
    btHingeConstraint::btHingeConstraint(v6, v8, &v12, &v13, 0);
  }
  return v6;
}

void sub_20B2F90B0(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

float32x4_t btHingeConstraint::setAxis(btHingeConstraint *this, float32x4_t *a2)
{
  float v2 = a2->f32[2];
  float v3 = a2->f32[1];
  if (fabsf(v2) <= 0.70711)
  {
    float v12 = (float)(v3 * v3) + (float)(a2->f32[0] * a2->f32[0]);
    float v13 = 1.0 / sqrtf(v12);
    v9.i64[1] = 0;
    *(float *)v9.i32 = -(float)(v3 * v13);
    *(float *)&v9.i32[1] = a2->f32[0] * v13;
    float v8 = -(float)(v2 * *(float *)&v9.i32[1]);
    float v10 = v2 * *(float *)v9.i32;
    float v11 = v12 * v13;
  }
  else
  {
    float v4 = (float)(v2 * v2) + (float)(v3 * v3);
    float v5 = 1.0 / sqrtf(v4);
    *(float *)&__int32 v6 = -(float)(v2 * v5);
    *(float *)&unsigned int v7 = v3 * v5;
    float v8 = v4 * v5;
    v9.i32[0] = 0;
    v9.i32[1] = v6;
    v9.i64[1] = v7;
    float v10 = -(float)(a2->f32[0] * *(float *)&v7);
    float v11 = a2->f32[0] * *(float *)&v6;
  }
  float32x4_t v14 = *(float32x4_t *)&this->var17;
  LODWORD(this->var16.var0.var0[1].var0.var0[0]) = v9.i32[0];
  this->var16.var0.var0[1].var0.var0[1] = v8;
  *(void *)&this->var16.var0.var0[1].var0.var0[2] = a2->u32[0];
  LODWORD(this->var16.var0.var0[2].var0.var0[0]) = v9.i32[1];
  this->var16.var0.var0[2].var0.var0[1] = v10;
  *(void *)&this->var16.var0.var0[2].var0.var0[2] = a2->u32[1];
  LODWORD(this->var16.var1.var0.var0[0]) = v9.i32[2];
  this->var16.var1.var0.var0[1] = v11;
  *(void *)&this->var16.var1.var0.var0[2] = a2->u32[2];
  var8 = this->var8;
  float32x4_t v16 = *a2;
  float32x4_t v17 = *((float32x4_t *)var8 + 1);
  float32x4_t v18 = *((float32x4_t *)var8 + 2);
  int8x16_t v19 = (int8x16_t)vmulq_f32(v17, *a2);
  int8x16_t v20 = (int8x16_t)vmulq_f32(*a2, v18);
  float32x4_t v21 = *((float32x4_t *)var8 + 3);
  int8x16_t v22 = (int8x16_t)vmulq_f32(*a2, v21);
  v22.i32[3] = 0;
  int8x8_t v23 = (int8x8_t)vadd_f32(vpadd_f32(*(float32x2_t *)v19.i8, *(float32x2_t *)v20.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL)));
  int8x8_t v24 = (int8x8_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), 0);
  *(int8x8_t *)v25.f32 = vext_s8(v23, v24, 4uLL);
  *(int8x8_t *)&v25.u32[2] = v23;
  *(int8x8_t *)v26.f32 = v23;
  *(int8x8_t *)&v26.u32[2] = v24;
  int8x16_t v27 = (int8x16_t)vmulq_f32(*a2, v26);
  float v28 = vadd_f32(vpadd_f32(*(float32x2_t *)v27.i8, *(float32x2_t *)v27.i8), (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL)).f32[0];
  if (v28 >= -1.0)
  {
    v38.i64[0] = vextq_s8((int8x16_t)v16, (int8x16_t)v16, 4uLL).u64[0];
    v38.i64[1] = a2->i64[0];
    int8x16_t v39 = (int8x16_t)vsubq_f32(vmulq_f32(v16, v25), vmulq_f32(v38, v26));
    float32x4_t v40 = (float32x4_t)vextq_s8(vextq_s8(v39, v39, 0xCuLL), v39, 8uLL);
    v40.i32[3] = sqrtf((float)(v28 + 1.0) + (float)(v28 + 1.0));
    v41.i32[1] = 1056964608;
    v41.i64[1] = 0x3F0000003F000000;
    *(float *)v41.i32 = 1.0 / v40.f32[3];
    float32x4_t v42 = (float32x4_t)vzip1q_s32(v41, v41);
    v42.f32[2] = 1.0 / v40.f32[3];
    float32x4_t v37 = vmulq_f32(v40, v42);
  }
  else
  {
    LODWORD(v29) = HIDWORD(a2->i64[0]);
    float v30 = fabsf(v16.f32[2]);
    float v31 = 1.0 / sqrtf((float)(v29 * v29) + (float)(v16.f32[0] * v16.f32[0]));
    float v32 = -(float)(v16.f32[1] * v31);
    float v33 = v16.f32[0] * v31;
    float v34 = v32;
    v16.f32[0] = 1.0 / sqrtf((float)(v16.f32[2] * v16.f32[2]) + (float)(v29 * v29));
    float v35 = v16.f32[1] * v16.f32[0];
    if (v30 <= 0.70711)
    {
      float v36 = v33;
    }
    else
    {
      float v34 = 0.0;
      float v36 = -(float)(v16.f32[2] * v16.f32[0]);
    }
    if (v30 <= 0.70711) {
      float v35 = 0.0;
    }
    v37.i64[0] = __PAIR64__(LODWORD(v36), LODWORD(v34));
    v37.i64[1] = LODWORD(v35);
  }
  int32x2_t v43 = (int32x2_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL).u64[0];
  float32x2_t v44 = (float32x2_t)vext_s8((int8x8_t)v43, *(int8x8_t *)v37.f32, 4uLL);
  float32x2_t v45 = (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL), *(int32x2_t *)v9.i8);
  float32x2_t v46 = (float32x2_t)vzip1_s32(v43, *(int32x2_t *)v37.f32);
  float32x2_t v47 = (float32x2_t)vext_s8(*(int8x8_t *)v37.f32, (int8x8_t)v43, 4uLL);
  *(float32x2_t *)v48.f32 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 4uLL), v46);
  *(float32x2_t *)&v48.u32[2] = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v45), v47);
  *(float32x2_t *)v49.i8 = vadd_f32(vmul_laneq_f32(*(float32x2_t *)v9.i8, v37, 3), vmul_f32(v45, v47));
  v49.u64[1] = (unint64_t)vadd_f32(vmul_lane_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v9.i8, 1), vmul_f32(v45, v44));
  float32x4_t v50 = vsubq_f32((float32x4_t)veorq_s8(v49, (int8x16_t)xmmword_20B5CBC00), v48);
  float32x4_t v51 = (float32x4_t)veorq_s8((int8x16_t)v37, (int8x16_t)xmmword_20B5CBC10);
  float32x2_t v52 = (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), *(int32x2_t *)v50.f32);
  int32x2_t v53 = (int32x2_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL).u64[0];
  *(int32x2_t *)v48.f32 = vzip1_s32(v53, *(int32x2_t *)v51.f32);
  float32x2_t v54 = (float32x2_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 4uLL).u64[0];
  float32x2_t v55 = vmul_laneq_f32(*(float32x2_t *)v50.f32, v51, 3);
  float32x2_t v56 = vmul_f32((float32x2_t)vext_s8((int8x8_t)v53, *(int8x8_t *)v51.f32, 4uLL), v52);
  *(float32x2_t *)v57.f32 = vmul_f32((float32x2_t)vext_s8(*(int8x8_t *)v51.f32, (int8x8_t)v53, 4uLL), v52);
  *(float32x2_t *)&v57.u32[2] = vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v48.f32), v54);
  float32x2_t v58 = vmul_lane_f32(*(float32x2_t *)v50.f32, *(float32x2_t *)v51.f32, 1);
  float32x4_t v59 = vmulq_laneq_f32(v51, v50, 3);
  *(float32x2_t *)v50.f32 = vadd_f32(v55, vmul_f32(*(float32x2_t *)v48.f32, v54));
  *(float32x2_t *)&v50.u32[2] = vadd_f32(v58, v56);
  float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v57), (float32x4_t)veorq_s8((int8x16_t)v50, (int8x16_t)xmmword_20B5CBC00));
  v59.i64[0] = vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL).u64[0];
  v60.i32[3] = 0;
  *(int8x8_t *)v59.f32 = vext_s8(*(int8x8_t *)v60.f32, *(int8x8_t *)v59.f32, 4uLL);
  v59.i64[1] = v60.i64[0];
  var9 = this->var9;
  float32x4_t v62 = *((float32x4_t *)var9 + 1);
  int32x4_t v63 = *((int32x4_t *)var9 + 2);
  int8x16_t v64 = *((int8x16_t *)var9 + 3);
  float32x4_t v65 = (float32x4_t)vtrn1q_s32((int32x4_t)v62, v63);
  int32x2_t v66 = vzip2_s32(*(int32x2_t *)v64.i8, 0);
  unsigned __int32 v67 = vextq_s8(v64, v64, 8uLL).u32[0];
  _Q25.i64[0] = vextq_s8((int8x16_t)v65, (int8x16_t)v65, 8uLL).u64[0];
  v65.i64[1] = v64.u32[0];
  v64.i64[0] = 0x8000000080000000;
  v64.i64[1] = 0x8000000080000000;
  float32x4_t v69 = (float32x4_t)veorq_s8(*((int8x16_t *)var9 + 4), v64);
  _Q21 = (int8x16_t)vmulq_f32(v65, v69);
  *(int32x2_t *)v62.f32 = vzip2_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v63.i8);
  *(int32x2_t *)&v62.u32[2] = v66;
  _Q19 = (int8x16_t)vmulq_f32(v62, v69);
  _Q25.i64[1] = v67;
  _Q20 = (int8x16_t)vmulq_f32(_Q25, v69);
  _Q20.i32[3] = 0;
  float32x4_t v73 = vmulq_f32(v14, v17);
  int8x16_t v74 = (int8x16_t)vmulq_f32(v14, v18);
  int8x16_t v75 = (int8x16_t)vmulq_f32(v14, v21);
  v75.i32[3] = 0;
  *(float32x2_t *)v73.f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v73, (int8x16_t)v73, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL)), vpadd_f32(*(float32x2_t *)v73.f32, *(float32x2_t *)v74.i8));
  *(float32x2_t *)&v73.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL)), 0);
  float32x4_t v76 = vaddq_f32(v73, *((float32x4_t *)var8 + 4));
  int8x16_t v77 = (int8x16_t)vmulq_f32(v65, v76);
  _Q4 = (int8x16_t)vmulq_f32(v62, v76);
  int8x16_t v79 = (int8x16_t)vmulq_f32(_Q25, v76);
  v79.i32[3] = 0;
  *(float32x2_t *)v77.i8 = vadd_f32(vadd_f32(vpadd_f32(*(float32x2_t *)_Q21.i8, *(float32x2_t *)_Q19.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(_Q21, _Q21, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(_Q19, _Q19, 8uLL))), vadd_f32(vpadd_f32(*(float32x2_t *)v77.i8, *(float32x2_t *)_Q4.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(_Q4, _Q4, 8uLL))));
  v77.u64[1] = (unint64_t)vadd_f32(vpadd_f32(vpadd_f32(*(float32x2_t *)_Q20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(_Q20, _Q20, 8uLL)), 0), vpadd_f32(vpadd_f32(*(float32x2_t *)v79.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL)), 0));
  _Q2 = (int32x4_t)vsubq_f32(vmulq_f32(v26, v59), vmulq_f32(v25, v60));
  *(int8x16_t *)&this->var29 = v77;
  *(int8x8_t *)v77.i8 = vext_s8(*(int8x8_t *)v60.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)_Q2, (int8x16_t)_Q2, 8uLL), 4uLL);
  _Q4.i64[0] = vzip2q_s32((int32x4_t)v60, vuzp1q_s32((int32x4_t)v60, _Q2)).u64[0];
  v60.i32[1] = _Q2.i32[1];
  *(void *)&this->var19.var2 = v60.i64[0];
  LODWORD(this->var19.var4) = v23.i32[0];
  this->var19.var5 = 0.0;
  *(void *)&this->var19.var6 = v77.i64[0];
  LODWORD(this->var20) = v23.i32[1];
  this->var21 = 0.0;
  *(void *)&this->var22 = _Q4.i64[0];
  *(_DWORD *)&this->var24 = v24.i32[0];
  *(_DWORD *)&this->var28 = 0;
  _S1 = *((float *)var9 + 13);
  _Q2.i32[0] = *((_DWORD *)var9 + 14);
  float v82 = *((float *)var9 + 9);
  _Q4.i32[0] = *((_DWORD *)var9 + 10);
  _Q19.i32[0] = *((_DWORD *)var9 + 12);
  _Q20.i32[0] = *((_DWORD *)var9 + 8);
  _Q5 = *((float32x4_t *)var9 + 1);
  float32x4_t v85 = *(float32x4_t *)&this->var19.var2;
  float32x4_t v84 = *(float32x4_t *)&this->var19.var6;
  float32x4_t result = *(float32x4_t *)&this->var22;
  result.i32[3] = 0;
  v62.f32[0] = (float)(v82 * *(float *)_Q2.i32) - (float)(*(float *)_Q4.i32 * _S1);
  v87.i32[3] = 0;
  v87.f32[0] = v62.f32[0];
  v87.f32[1] = (float)(*(float *)_Q4.i32 * *(float *)_Q19.i32) - (float)(*(float *)_Q20.i32 * *(float *)_Q2.i32);
  v87.f32[2] = (float)(*(float *)_Q20.i32 * _S1) - (float)(v82 * *(float *)_Q19.i32);
  int8x16_t v88 = (int8x16_t)vmulq_f32(_Q5, v87);
  *(float *)v88.i32 = 1.0
                    / vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v88, v88, 8uLL), vpadd_f32(*(float32x2_t *)v88.i8, *(float32x2_t *)v88.i8)).f32[0];
  v84.i32[3] = 0;
  __asm { FMLA            S25, S19, V5.S[1] }
  v85.i32[3] = 0;
  float32x4_t v93 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v85, (float)((float)(*(float *)_Q20.i32 * _S1) - (float)(v82 * *(float *)_Q19.i32)) * *(float *)v88.i32), v84, _Q25.f32[0] * *(float *)v88.i32), result, vmlas_n_f32(-(float)(COERCE_FLOAT(HIDWORD(*((void *)var9 + 2))) * *(float *)_Q20.i32), v82, _Q5.f32[0])* *(float *)v88.i32);
  __asm { FMLA            S21, S20, V5.S[2] }
  float32x4_t v94 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v85, (float)((float)(*(float *)_Q4.i32 * *(float *)_Q19.i32) - (float)(*(float *)_Q20.i32 * *(float *)_Q2.i32))* *(float *)v88.i32), v84, vmlas_n_f32(-(float)(COERCE_FLOAT(*((void *)var9 + 3)) * *(float *)_Q19.i32), *(float *)_Q2.i32, _Q5.f32[0])* *(float *)v88.i32), result, *(float *)_Q21.i32 * *(float *)v88.i32);
  __asm
  {
    FMLA            S16, S4, V5.S[1]
    FMLA            S2, S1, V5.S[2]
  }
  *(float32x4_t *)&this->var19.var2 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v85, v62.f32[0] * *(float *)v88.i32), v84, *(float *)_Q2.i32 * *(float *)v88.i32), result, _S16 * *(float *)v88.i32);
  *(float32x4_t *)&this->var19.var6 = v94;
  *(float32x4_t *)&this->var22 = v93;
  return result;
}

void sub_20B2FA964(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_20B2FB258(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnGrid1D(SCNMTLComputeCommandEncoder *this, uint64_t a2)
{
  if (!this->_computePipelineState)
  {
    float v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      SCNMTLComputeCommandEncoder::dispatchOnGrid1D(v4);
    }
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  unsigned int features = this->_features;
  unint64_t v6 = [(MTLComputePipelineState *)this->_computePipelineState threadExecutionWidth];
  encoder = this->_encoder;
  if ((features & 0x40) != 0)
  {
    uint64_t v15 = a2;
    int64x2_t v16 = vdupq_n_s64(1uLL);
    unint64_t v13 = v6;
    int64x2_t v14 = v16;
    return [(MTLComputeCommandEncoder *)encoder dispatchThreads:&v15 threadsPerThreadgroup:&v13];
  }
  else
  {
    unint64_t v11 = (a2 + v6 - 1) / v6;
    int64x2_t v12 = vdupq_n_s64(1uLL);
    unint64_t v9 = v6;
    int64x2_t v10 = v12;
    return [(MTLComputeCommandEncoder *)encoder dispatchThreadgroups:&v11 threadsPerThreadgroup:&v9];
  }
}

void OUTLINED_FUNCTION_0_2(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

void sub_20B2FBF38(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_20B2FBFC0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *_arrowNode(uint64_t a1)
{
  if (_arrowNode_onceToken != -1) {
    dispatch_once(&_arrowNode_onceToken, &__block_literal_global_192);
  }
  float v2 = (void *)[(id)_arrowNode_arrowNode clone];
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___arrowNode_block_invoke_2;
  v4[3] = &unk_264005228;
  v4[4] = a1;
  [v2 enumerateHierarchyUsingBlock:v4];
  return v2;
}

void *_axisNode(uint64_t a1)
{
  if (_axisNode_onceToken != -1) {
    dispatch_once(&_axisNode_onceToken, &__block_literal_global_196);
  }
  float v2 = (void *)[(id)_axisNode_axisNode clone];
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___axisNode_block_invoke_2;
  v4[3] = &unk_264005228;
  v4[4] = a1;
  [v2 enumerateHierarchyUsingBlock:v4];
  return v2;
}

void *_translationPlaneNode(uint64_t a1)
{
  if (_translationPlaneNode_onceToken != -1) {
    dispatch_once(&_translationPlaneNode_onceToken, &__block_literal_global_198);
  }
  float v2 = (void *)[(id)_translationPlaneNode_planeNode clone];
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___translationPlaneNode_block_invoke_2;
  v4[3] = &unk_264005228;
  v4[4] = a1;
  [v2 enumerateHierarchyUsingBlock:v4];
  return v2;
}

void *_rotationArcNode(uint64_t a1)
{
  if (_rotationArcNode_onceToken != -1) {
    dispatch_once(&_rotationArcNode_onceToken, &__block_literal_global_202);
  }
  float v2 = (void *)[(id)_rotationArcNode_arcNode clone];
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___rotationArcNode_block_invoke_2;
  v4[3] = &unk_264005228;
  v4[4] = a1;
  [v2 enumerateHierarchyUsingBlock:v4];
  return v2;
}

void *_wireframeCircle(uint64_t a1, float a2)
{
  if (_wireframeCircle_onceToken != -1) {
    dispatch_once(&_wireframeCircle_onceToken, &__block_literal_global_204);
  }
  float v4 = (void *)[(id)_wireframeCircle_circleNode clone];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___wireframeCircle_block_invoke_2;
  v6[3] = &unk_264005250;
  float v7 = a2;
  v6[4] = a1;
  [v4 enumerateHierarchyUsingBlock:v6];
  return v4;
}

void __computeAnchorMatrix(void *a1@<X0>, float32x4_t *a2@<X8>)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v4 = objc_msgSend((id)objc_msgSend(a1, "targets"), "firstObject");
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    long long v69 = 0u;
    float32x4_t v70 = 0u;
    float32x4_t v67 = 0u;
    long long v68 = 0u;
    switch([a1 effectiveEditingSpace])
    {
      case 0:
        long long v65 = 0u;
        float32x4_t v66 = 0u;
        float32x4_t v63 = 0u;
        long long v64 = 0u;
        float v7 = v5;
        goto LABEL_8;
      case 1:
        float v7 = (void *)[v5 parentItem];
        long long v65 = 0u;
        float32x4_t v66 = 0u;
        if (!v7) {
          float v7 = v5;
        }
        float32x4_t v63 = 0uLL;
        long long v64 = 0uLL;
LABEL_8:
        [v7 worldTransform];
        goto LABEL_14;
      case 2:
        __n128 Identity = C3DMatrix4x4MakeIdentity((uint64_t)&v67);
        break;
      case 3:
        long long v65 = 0u;
        float32x4_t v66 = 0u;
        float32x4_t v63 = 0u;
        long long v64 = 0u;
        unint64_t v11 = (void *)[a1 authoringEnvironment];
        if (v11)
        {
          [v11 viewMatrix];
        }
        else
        {
          long long v65 = 0u;
          float32x4_t v66 = 0u;
          float32x4_t v63 = 0u;
          long long v64 = 0u;
        }
        *(float32x4_t *)&m.m11 = v63;
        *(_OWORD *)&m.m21 = v64;
        *(_OWORD *)&m.m31 = v65;
        *(float32x4_t *)&m.m41 = v66;
        SCNMatrix4Invert(&v62, &m);
        float32x4_t v63 = *(float32x4_t *)&v62.m11;
        long long v64 = *(_OWORD *)&v62.m21;
        long long v65 = *(_OWORD *)&v62.m31;
        float32x4_t v66 = *(float32x4_t *)&v62.m41;
LABEL_14:
        __n128 Identity = C3DMatrix4x4FromSCNMatrix4(&v67, (uint64_t)&v63);
        break;
      default:
        break;
    }
    Identity.n128_u64[0] = 0;
    __n128 v54 = Identity;
    __n128 v55 = Identity;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    int64x2_t v12 = (void *)[a1 targets];
    uint64_t v13 = [v12 countByEnumeratingWithState:&v57 objects:v71 count:16];
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)v58;
      int64x2_t v16 = (int64x2_t *)(a1 + 77);
      __n128 v17 = v54;
      v17.n128_u32[0] = v54.n128_u32[1];
      __n128 v50 = v17;
      v17.n128_u64[0] = 0;
      __n128 v52 = v17;
      do
      {
        uint64_t v18 = 0;
        __n128 v19 = v55;
        do
        {
          __n128 v56 = v19;
          if (*(void *)v58 != v15)
          {
            objc_enumerationMutation(v12);
            __n128 v19 = v56;
          }
          int8x16_t v20 = *(void **)(*((void *)&v57 + 1) + 8 * v18);
          long long v65 = 0u;
          float32x4_t v66 = 0u;
          float32x4_t v63 = 0u;
          long long v64 = 0u;
          if (v20)
          {
            [v20 worldTransform];
            __n128 v19 = v56;
          }
          uint64_t v21 = v16->i64[0];
          if (v16->i64[0] == 2)
          {
            __n128 v22 = v54;
            if (v54.n128_f32[0] < v66.f32[0]) {
              v22.n128_f32[0] = v66.f32[0];
            }
          }
          else if (v21 == 1)
          {
            __n128 v22 = v54;
            if (v54.n128_f32[0] >= v66.f32[0]) {
              v22.n128_f32[0] = v66.f32[0];
            }
          }
          else
          {
            __n128 v22 = v54;
            v22.n128_f32[0] = v54.n128_f32[0] + v66.f32[0];
          }
          __n128 v54 = v22;
          uint64_t v23 = a1[78];
          __n128 v24 = v50;
          if (v23 == 2)
          {
            if (v50.n128_f32[0] < v66.f32[1]) {
              v24.n128_f32[0] = v66.f32[1];
            }
          }
          else if (v23 == 1)
          {
            if (v50.n128_f32[0] >= v66.f32[1]) {
              v24.n128_f32[0] = v66.f32[1];
            }
          }
          else
          {
            v24.n128_f32[0] = v50.n128_f32[0] + v66.f32[1];
          }
          __n128 v50 = v24;
          if (a1[79] == 1)
          {
            if (v19.n128_f32[0] >= v66.f32[2]) {
              v19.n128_f32[0] = v66.f32[2];
            }
          }
          else
          {
            float v25 = v66.f32[2];
            if (v19.n128_f32[0] >= v66.f32[2]) {
              float v25 = v19.n128_f32[0];
            }
            if (v21 == 2) {
              v19.n128_f32[0] = v25;
            }
            else {
              v19.n128_f32[0] = v19.n128_f32[0] + v66.f32[2];
            }
          }
          __n128 v26 = v52;
          v26.n128_f32[0] = v52.n128_f32[0] + 1.0;
          __n128 v52 = v26;
          ++v18;
        }
        while (v14 != v18);
        __n128 v55 = v19;
        uint64_t v14 = [v12 countByEnumeratingWithState:&v57 objects:v71 count:16];
      }
      while (v14);
      if (v52.n128_f32[0] == 0.0)
      {
        v54.n128_u64[0] = __PAIR64__(v50.n128_u32[0], v54.n128_u32[0]);
      }
      else
      {
        __asm { FMOV            V2.2S, #1.0 }
        float32x2_t v32 = vdiv_f32((float32x2_t)__PAIR64__(v50.n128_u32[0], v54.n128_u32[0]), (float32x2_t)vbsl_s8((int8x8_t)vmovn_s64(vceqzq_s64(*v16)), (int8x8_t)vdup_lane_s32((int32x2_t)v52.n128_u64[0], 0), _D2));
        float v33 = v55.n128_f32[0];
        if (!a1[79]) {
          float v33 = v55.n128_f32[0] / v52.n128_f32[0];
        }
        v54.n128_u64[0] = (unint64_t)v32;
        v55.n128_f32[0] = v33;
      }
    }
    float32x4_t v63 = v67;
    long long v64 = v68;
    long long v65 = v69;
    float32x4_t v66 = v70;
    *(double *)v34.i64 = C3DVector3MultMatrix4x4(&v63, (float32x4_t)xmmword_20B5CB820);
    float32x4_t v51 = v34;
    float32x4_t v63 = v67;
    long long v64 = v68;
    long long v65 = v69;
    float32x4_t v66 = v70;
    *(double *)v35.i64 = C3DVector3MultMatrix4x4(&v63, (float32x4_t)xmmword_20B5CB7D0);
    float32x4_t v53 = v35;
    float32x4_t v63 = v67;
    long long v64 = v68;
    long long v65 = v69;
    float32x4_t v66 = v70;
    *(double *)v36.i64 = C3DVector3MultMatrix4x4(&v63, (float32x4_t)xmmword_20B5CB520);
    float32x4_t v37 = vsubq_f32(v51, v70);
    int32x4_t v38 = (int32x4_t)vmulq_f32(v37, v37);
    v38.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v38, 2), vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1))).u32[0];
    float32x2_t v39 = vrsqrte_f32((float32x2_t)v38.u32[0]);
    float32x2_t v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)v38.u32[0], vmul_f32(v39, v39)));
    float32x4_t v41 = vmulq_n_f32(v37, vmul_f32(v40, vrsqrts_f32((float32x2_t)v38.u32[0], vmul_f32(v40, v40))).f32[0]);
    float32x4_t v42 = vsubq_f32(v53, v70);
    int32x4_t v43 = (int32x4_t)vmulq_f32(v42, v42);
    v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
    float32x2_t v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
    float32x2_t v45 = vmul_f32(v44, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)));
    float32x4_t v46 = vmulq_n_f32(v42, vmul_f32(v45, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v45, v45))).f32[0]);
    float32x4_t v47 = vsubq_f32(v36, v70);
    int32x4_t v48 = (int32x4_t)vmulq_f32(v47, v47);
    v48.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v48, 2), vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v48.i8, 1))).u32[0];
    *(float32x2_t *)v43.i8 = vrsqrte_f32((float32x2_t)v48.u32[0]);
    *(float32x2_t *)v43.i8 = vmul_f32(*(float32x2_t *)v43.i8, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(*(float32x2_t *)v43.i8, *(float32x2_t *)v43.i8)));
    float32x4_t v49 = vmulq_n_f32(v47, vmul_f32(*(float32x2_t *)v43.i8, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(*(float32x2_t *)v43.i8, *(float32x2_t *)v43.i8))).f32[0]);
    v41.i32[3] = 0;
    v46.i32[3] = 0;
    v49.i32[3] = 0;
    v43.i64[0] = v54.n128_u64[0];
    v43.i64[1] = __PAIR64__(1.0, v55.n128_u32[0]);
    *a2 = v41;
    a2[1] = v46;
    a2[2] = v49;
    a2[3] = (float32x4_t)v43;
  }
  else
  {
    float v8 = (float32x4_t *)C3DMatrix4x4GetIdentity();
    float32x4_t v9 = v8[1];
    *a2 = *v8;
    a2[1] = v9;
    float32x4_t v10 = v8[3];
    a2[2] = v8[2];
    a2[3] = v10;
  }
}

double __resolveAxisMove(float32x4_t *a1, float32x4_t a2, float32x4_t a3)
{
  int32x4_t v3 = (int32x4_t)vmulq_f32(a3, a3);
  v3.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v3, 2), vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1))).u32[0];
  float32x2_t v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  float32x2_t v5 = vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4)));
  v5.i32[0] = vmul_f32(v5, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v5, v5))).u32[0];
  float32x4_t v6 = a1[19];
  float32x4_t v7 = a1[20];
  int32x4_t v8 = (int32x4_t)vmulq_f32(v7, v7);
  v8.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))).u32[0];
  float32x4_t v9 = vmulq_n_f32(a3, v5.f32[0]);
  float32x2_t v10 = vrsqrte_f32((float32x2_t)v8.u32[0]);
  float32x2_t v11 = vmul_f32(v10, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v10, v10)));
  float32x4_t v12 = vmulq_n_f32(v7, vmul_f32(v11, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v11, v11))).f32[0]);
  float32x4_t v13 = vmulq_f32(v9, v12);
  float32x4_t v14 = vsubq_f32(v6, a2);
  float32x4_t v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1)));
  float32x4_t v16 = vmulq_f32(v9, v14);
  float32x4_t v17 = vmulq_f32(v14, v12);
  v17.f32[0] = vmlas_n_f32(-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0], v15.f32[0])/ (1.0 - vmulq_f32(v15, v15).f32[0]);
  *(void *)&double result = vmlaq_n_f32(v6, v12, v17.f32[0]).u64[0];
  return result;
}

uint64_t _snapPositionToGrid(uint64_t result, unsigned char *a2, __n128 a3, float a4, float a5, float a6, long double a7, float32x4_t a8, float32x4_t a9)
{
  int v10 = result;
  __n128 v14 = a3;
  float32x4_t v33 = a9;
  float32x4_t v34 = a8;
  if (vabds_f32(a3.n128_f32[0], a4) <= 0.00001)
  {
    BOOL v15 = 0;
    __n128 v16 = a3;
  }
  else
  {
    v35.n128_u32[0] = 0;
    double result = _snapPositionComponentToGrid((float *)&v35, a3.n128_f32[0], a7);
    __n128 v14 = a3;
    BOOL v15 = result;
    __n128 v16 = a3;
    if (result)
    {
      v16.n128_u32[0] = v35.n128_u32[0];
      *(unint64_t *)((char *)v16.n128_u64 + 4) = *(unint64_t *)((char *)a3.n128_u64 + 4);
    }
  }
  __n128 v30 = v16;
  __int32 v26 = v14.n128_i32[1];
  if (vabds_f32(v14.n128_f32[1], a5) <= 0.00001)
  {
    int v17 = 0;
  }
  else
  {
    v35.n128_u32[0] = 0;
    double result = _snapPositionComponentToGrid((float *)&v35, v14.n128_f32[1], a7);
    int v17 = result;
    if (result)
    {
      v18.n128_u64[0] = __PAIR64__(v35.n128_u32[0], v30.n128_u32[0]);
      v18.n128_u64[1] = v30.n128_u64[1];
      __n128 v30 = v18;
    }
    __n128 v14 = a3;
  }
  __int32 v19 = v14.n128_i32[2];
  if (vabds_f32(v14.n128_f32[2], a6) <= 0.00001)
  {
    int v20 = 0;
    float32x4_t v21 = (float32x4_t)v30;
  }
  else
  {
    v35.n128_u32[0] = 0;
    double result = _snapPositionComponentToGrid((float *)&v35, v14.n128_f32[2], a7);
    int v20 = result;
    if (result)
    {
      v21.i64[0] = v30.n128_u64[0];
      v21.i64[1] = __PAIR64__(v30.n128_u32[3], v35.n128_u32[0]);
    }
    else
    {
      float32x4_t v21 = (float32x4_t)v30;
    }
    v14.n128_u32[0] = a3.n128_u32[0];
  }
  float32x4_t v22 = a9;
  if (v15)
  {
    *a2 = 1;
  }
  else
  {
    *a2 = v17 | v20;
    if (((v17 | v20) & 1) == 0) {
      return result;
    }
  }
  if (v10)
  {
    __n128 v35 = 0u;
    __n128 v36 = 0u;
    float32x4_t v31 = v21;
    C3DRay3Make(&v35, &v34, (__n128 *)&v33);
    return _adjustSnapForAxisMove(v15, v17, v20, 0, v31, a3, v35, v36);
  }
  float32x4_t v23 = vmulq_f32(a9, a8);
  float32x4_t v24 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1)));
  v22.f32[3] = -v24.f32[0];
  float32x4_t v41 = v22;
  if (v15 | v17 | v20)
  {
    float32x4_t v39 = v21;
    float32x4_t v37 = v21;
    float32x4_t v38 = v21;
    __n128 v35 = 0u;
    __n128 v36 = 0u;
    float32x4_t v25 = vmulq_f32(v21, v22);
    if (vsubq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))), v24).f32[0] >= 5.0)
    {
      float32x4_t v32 = v21;
      if (v15)
      {
        v21.i32[1] = v26;
        v39.i32[2] = v19;
        v39.i64[0] = v21.i64[0];
        long long v40 = xmmword_20B5CB7D0;
        C3DRay3Make(&v35, &v39, (__n128 *)&v40);
        double result = C3DIntersectionLinePlane((uint64_t)&v35, v41.f32, &v39);
        if (result)
        {
          v14.n128_u32[0] = a3.n128_u32[0];
          float32x4_t v21 = v32;
          if (!v17)
          {
LABEL_32:
            if (!v20) {
              return result;
            }
LABEL_35:
            v37.i32[2] = v21.i32[2];
            v37.i64[0] = __PAIR64__(v26, v14.n128_u32[0]);
            long long v40 = xmmword_20B5CB520;
            C3DRay3Make(&v35, &v37, (__n128 *)&v40);
            return C3DIntersectionLinePlane((uint64_t)&v35, v41.f32, &v37);
          }
        }
        else
        {
          v14.n128_u32[0] = a3.n128_u32[0];
          float32x4_t v21 = v32;
          if (!v17) {
            goto LABEL_32;
          }
        }
      }
      else if (!v17)
      {
        goto LABEL_32;
      }
      v21.i32[0] = v14.n128_u32[0];
      v38.i32[2] = v19;
      v38.i64[0] = v21.i64[0];
      long long v40 = xmmword_20B5CB7D0;
      C3DRay3Make(&v35, &v38, (__n128 *)&v40);
      double result = C3DIntersectionLinePlane((uint64_t)&v35, v41.f32, &v38);
      if (result)
      {
        v14.n128_u32[0] = a3.n128_u32[0];
        v21.i32[2] = v32.i32[2];
        if (!v20) {
          return result;
        }
      }
      else
      {
        v14.n128_u32[0] = a3.n128_u32[0];
        v21.i32[2] = v32.i32[2];
        if (!v20) {
          return result;
        }
      }
      goto LABEL_35;
    }
  }
  return result;
}

void sub_20B2FFE50(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t _sortSnapData(float *a1, float *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t _itemsContainsNode(void *a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a2) {
    return 0;
  }
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v4 = [a1 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v10;
    while (2)
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v10 != v6) {
          objc_enumerationMutation(a1);
        }
        if ((void *)[*(id *)(*((void *)&v9 + 1) + 8 * v7) node] == a2) {
          return 1;
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [a1 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
  return _itemsContainsNode(a1, [a2 parentNode]);
}

uint64_t _closestSnapToAlignItem(uint64_t a1, uint64_t a2, float *a3, float a4)
{
  if (a2 < 2) {
    return 0;
  }
  if (a2 == 2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2 - 1;
    do
    {
      uint64_t v7 = v6 + v5;
      if (v6 + v5 < 0 != __OFADD__(v6, v5)) {
        ++v7;
      }
      uint64_t v8 = v7 >> 1;
      if (*(float *)(a1 + 24 * v8) > a4) {
        uint64_t v6 = v8;
      }
      else {
        uint64_t v5 = v8;
      }
    }
    while (v6 - v5 > 1);
  }
  float v9 = vabds_f32(a4, *(float *)(a1 + 24 * v5));
  float v10 = vabds_f32(*(float *)(a1 + 24 * v6), a4);
  if (v9 >= v10)
  {
    uint64_t result = v6;
  }
  else
  {
    float v10 = v9;
    uint64_t result = v5;
  }
  *a3 = v10;
  return result;
}

uint64_t _snapPositionToAlign(uint64_t a1, uint64_t a2, _DWORD *a3, float a4, double a5)
{
  float v11 = 0.0;
  uint64_t result = _closestSnapToAlignItem(a1, a2, &v11, a4);
  double v9 = a5 * 0.3;
  if (a5 <= 0.1) {
    double v9 = 0.03;
  }
  float v10 = v9;
  if (v11 >= v10) {
    return -1;
  }
  *a3 = *(_DWORD *)(a1 + 24 * result);
  return result;
}

BOOL _adjustSnapForAxisMove(BOOL result, int a2, int a3, void *a4, float32x4_t a5, __n128 a6, __n128 a7, __n128 a8)
{
  v18[0] = a7;
  v18[1] = a8;
  if (!result && (a2 & 1) == 0 && !a3) {
    return result;
  }
  float32x4_t v15 = a5;
  float32x4_t v16 = a5;
  float32x4_t v14 = a5;
  __n128 v13 = 0uLL;
  __int32 v11 = a5.i32[2];
  __n128 v12 = a6;
  if (result)
  {
    a5.i32[1] = a6.n128_i32[1];
    v16.i32[2] = a6.n128_i32[2];
    v16.i64[0] = a5.i64[0];
    long long v17 = xmmword_20B5CB820;
    C3DPlaneMakeWithVectors(&v13, &v15, (float32x4_t *)&v17);
    uint64_t result = C3DIntersectionLinePlane((uint64_t)v18, (float *)&v13, &v16);
    if (result)
    {
      a6 = v12;
      if (!a2) {
        goto LABEL_16;
      }
      goto LABEL_11;
    }
    a6 = v12;
    if (a4) {
      *a4 = -1;
    }
  }
  if (!a2) {
    goto LABEL_16;
  }
LABEL_11:
  v15.i32[2] = a6.n128_i32[2];
  v15.i64[0] = __PAIR64__(v15.u32[1], a6.n128_u32[0]);
  long long v17 = xmmword_20B5CB7D0;
  C3DPlaneMakeWithVectors(&v13, &v15, (float32x4_t *)&v17);
  uint64_t result = C3DIntersectionLinePlane((uint64_t)v18, (float *)&v13, &v15);
  if (result)
  {
    a6.n128_u64[0] = v12.n128_u64[0];
    if (!a3) {
      return result;
    }
    goto LABEL_17;
  }
  a6.n128_u64[0] = v12.n128_u64[0];
  if (a4) {
    a4[1] = -1;
  }
LABEL_16:
  if (!a3) {
    return result;
  }
LABEL_17:
  v14.i32[2] = v11;
  v14.i64[0] = a6.n128_u64[0];
  long long v17 = xmmword_20B5CB520;
  C3DPlaneMakeWithVectors(&v13, &v14, (float32x4_t *)&v17);
  uint64_t result = C3DIntersectionLinePlane((uint64_t)v18, (float *)&v13, &v14);
  if (!result)
  {
    if (a4) {
      a4[2] = -1;
    }
  }
  return result;
}

uint64_t ___arrowNode_block_invoke()
{
  _arrowNode_arrowNode = +[SCNNode node];
  CFTypeID v0 = +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", +[SCNCylinder cylinderWithRadius:0.015 height:0.7]);
  LODWORD(v1) = 1051931443;
  -[SCNNode setPosition:](v0, "setPosition:", 0.0, v1, 0.0);
  [(id)_arrowNode_arrowNode addChildNode:v0];
  float v2 = +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", +[SCNCone coneWithTopRadius:0.0 bottomRadius:0.06 height:0.3]);
  LODWORD(v3) = 1062836634;
  -[SCNNode setPosition:](v2, "setPosition:", 0.0, v3, 0.0);
  [(id)_arrowNode_arrowNode addChildNode:v2];
  _arrowNode_arrowNode = [(id)_arrowNode_arrowNode flattenedCopy];
  uint64_t v4 = +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", +[SCNCylinder cylinderWithRadius:0.05 height:0.7]);
  LODWORD(v5) = 1051931443;
  -[SCNNode setPosition:](v4, "setPosition:", 0.0, v5, 0.0);
  [(SCNNode *)v4 setHidden:1];
  [(SCNNode *)v4 setCategoryBitMask:0xFFFFLL];
  uint64_t v6 = (void *)_arrowNode_arrowNode;

  return [v6 addChildNode:v4];
}

uint64_t ___arrowNode_block_invoke_2(uint64_t a1, void *a2)
{
  v6[1] = *MEMORY[0x263EF8340];
  objc_msgSend(a2, "setGeometry:", (id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "copy"));
  if (objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"))
  {
    v6[0] = (id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "copy");
    uint64_t v4 = [MEMORY[0x263EFF8C0] arrayWithObjects:v6 count:1];
  }
  else
  {
    uint64_t v4 = MEMORY[0x263EFFA68];
  }
  objc_msgSend((id)objc_msgSend(a2, "geometry"), "setMaterials:", v4);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "diffuse"), "setContents:", *(void *)(a1 + 32));
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setLightingModelName:", @"SCNLightingModelConstant");
  return [a2 setAuthoringEnvironmentNode:1];
}

uint64_t ___axisNode_block_invoke()
{
  _axisNode_axisNode = +[SCNNode node];
  CFTypeID v0 = +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", +[SCNCylinder cylinderWithRadius:0.01 height:0.6]);
  LODWORD(v1) = 1050253722;
  -[SCNNode setPosition:](v0, "setPosition:", 0.0, v1, 0.0);
  [(id)_axisNode_axisNode addChildNode:v0];
  uint64_t result = [(id)_axisNode_axisNode flattenedCopy];
  _axisNode_axisNode = result;
  return result;
}

uint64_t ___axisNode_block_invoke_2(uint64_t a1, void *a2)
{
  v6[1] = *MEMORY[0x263EF8340];
  objc_msgSend(a2, "setGeometry:", (id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "copy"));
  if (objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"))
  {
    v6[0] = (id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "copy");
    uint64_t v4 = [MEMORY[0x263EFF8C0] arrayWithObjects:v6 count:1];
  }
  else
  {
    uint64_t v4 = MEMORY[0x263EFFA68];
  }
  objc_msgSend((id)objc_msgSend(a2, "geometry"), "setMaterials:", v4);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "diffuse"), "setContents:", *(void *)(a1 + 32));
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setLightingModelName:", @"SCNLightingModelConstant");
  return [a2 setAuthoringEnvironmentNode:1];
}

uint64_t ___translationPlaneNode_block_invoke()
{
  _translationPlaneNode_planeNode = +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", +[SCNPlane planeWithWidth:0.3 height:0.3]);
  CFTypeID v0 = +[SCNTorus torusWithRingRadius:0.212132037 pipeRadius:0.01];
  [(SCNTorus *)v0 setPipeSegmentCount:3];
  [(SCNTorus *)v0 setRingSegmentCount:4];
  double v1 = +[SCNNode nodeWithGeometry:v0];
  LODWORD(v2) = 1070141403;
  LODWORD(v3) = 1061752795;
  -[SCNNode setEulerAngles:](v1, "setEulerAngles:", v2, 0.0, v3);
  uint64_t v4 = (void *)_translationPlaneNode_planeNode;

  return [v4 addChildNode:v1];
}

uint64_t ___translationPlaneNode_block_invoke_2(uint64_t a1, void *a2)
{
  v7[1] = *MEMORY[0x263EF8340];
  objc_msgSend(a2, "setGeometry:", (id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "copy"));
  if (objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"))
  {
    v7[0] = (id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "copy");
    uint64_t v4 = [MEMORY[0x263EFF8C0] arrayWithObjects:v7 count:1];
  }
  else
  {
    uint64_t v4 = MEMORY[0x263EFFA68];
  }
  objc_msgSend((id)objc_msgSend(a2, "geometry"), "setMaterials:", v4);
  [a2 geometry];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "diffuse"), "setContents:", *(void *)(a1 + 32));
  if ((isKindOfClass & 1) == 0)
  {
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setTransparency:", 0.3);
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setDoubleSided:", 1);
  }
  [a2 setAuthoringEnvironmentNode:1];
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setLightingModelName:", @"SCNLightingModelConstant");
}

uint64_t ___rotationArcNode_block_invoke()
{
  _rotationArcNode_arcNode = +[SCNNode node];
  CFTypeID v0 = +[SCNCylinder cylinderWithRadius:0.3 height:0.0];
  [(SCNCylinder *)v0 setRadialSpan:0.25];
  objc_msgSend((id)_rotationArcNode_arcNode, "addChildNode:", +[SCNNode nodeWithGeometry:](SCNNode, "nodeWithGeometry:", v0));
  double v1 = +[SCNTorus torusWithRingRadius:0.68 pipeRadius:0.015];
  [(SCNTorus *)v1 setRadialSpan:0.25];
  double v2 = (void *)_rotationArcNode_arcNode;
  double v3 = +[SCNNode nodeWithGeometry:v1];

  return [v2 addChildNode:v3];
}

uint64_t ___rotationArcNode_block_invoke_2(uint64_t a1, void *a2)
{
  v7[1] = *MEMORY[0x263EF8340];
  uint64_t result = [a2 geometry];
  if (result)
  {
    objc_msgSend(a2, "setGeometry:", (id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "copy"));
    if (objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"))
    {
      v7[0] = (id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "copy");
      uint64_t v5 = [MEMORY[0x263EFF8C0] arrayWithObjects:v7 count:1];
    }
    else
    {
      uint64_t v5 = MEMORY[0x263EFFA68];
    }
    objc_msgSend((id)objc_msgSend(a2, "geometry"), "setMaterials:", v5);
    [a2 geometry];
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
    objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "diffuse"), "setContents:", *(void *)(a1 + 32));
    if ((isKindOfClass & 1) == 0) {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setTransparency:", 0.6);
    }
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setDoubleSided:", 1);
    [a2 setAuthoringEnvironmentNode:1];
    return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setLightingModelName:", @"SCNLightingModelConstant");
  }
  return result;
}

uint64_t ___wireframeCircle_block_invoke()
{
  CFTypeID v0 = +[SCNTorus torusWithRingRadius:1.0 pipeRadius:0.01];
  [(SCNTorus *)v0 setPipeSegmentCount:5];
  [(SCNTorus *)v0 setRingSegmentCount:64];
  _wireframeCircle_circleNode = +[SCNNode nodeWithGeometry:v0];
  [(id)_wireframeCircle_circleNode setHittable:0];
  double v1 = +[SCNTorus torusWithRingRadius:1.0 pipeRadius:0.07];
  [(SCNTorus *)v1 setPipeSegmentCount:5];
  [(SCNTorus *)v1 setRingSegmentCount:30];
  double v2 = +[SCNNode nodeWithGeometry:v1];
  [(SCNNode *)v2 setHidden:1];
  [(SCNNode *)v2 setCategoryBitMask:0xFFFFLL];
  double v3 = (void *)_wireframeCircle_circleNode;

  return [v3 addChildNode:v2];
}

uint64_t ___wireframeCircle_block_invoke_2(uint64_t a1, void *a2)
{
  v7[1] = *MEMORY[0x263EF8340];
  objc_msgSend(a2, "setGeometry:", (id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "copy"));
  float v4 = *(float *)(a1 + 40);
  if (v4 != 1.0) {
    objc_msgSend((id)objc_msgSend(a2, "geometry"), "setRingRadius:", v4);
  }
  if (objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"))
  {
    v7[0] = (id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "copy");
    uint64_t v5 = [MEMORY[0x263EFF8C0] arrayWithObjects:v7 count:1];
  }
  else
  {
    uint64_t v5 = MEMORY[0x263EFFA68];
  }
  objc_msgSend((id)objc_msgSend(a2, "geometry"), "setMaterials:", v5);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "diffuse"), "setContents:", *(void *)(a1 + 32));
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "geometry"), "firstMaterial"), "setLightingModelName:", @"SCNLightingModelConstant");
  return [a2 setAuthoringEnvironmentNode:1];
}

uint64_t _snapPositionComponentToGrid(float *a1, float a2, long double a3)
{
  float v6 = -a2;
  if (a2 >= 0.0) {
    float v7 = a2;
  }
  else {
    float v7 = v6;
  }
  float v8 = fmod(v7, a3);
  float v9 = a3 * 0.3;
  if (v8 >= v9)
  {
    double v11 = v8;
    if (a3 - v9 >= v11) {
      return 0;
    }
    float v10 = a3 - v11 + v7;
  }
  else
  {
    float v10 = v7 - v8;
  }
  if (a2 < 0.0) {
    float v10 = -v10;
  }
  *a1 = v10;
  return 1;
}

const char *C3D::FinalPass::name(C3D::FinalPass *this)
{
  return "FinalPass";
}

C3D::Pass *C3D::FinalPass::_createCustomTechniquePassesIfNeeded(uint64_t *a1, uint64_t a2, _DWORD *a3, C3D::Pass **a4)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  if (!a4)
  {
    float v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3D::FinalPass::_createCustomTechniquePassesIfNeeded(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (!a2)
  {
    float32x4_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3D::FinalPass::_createCustomTechniquePassesIfNeeded(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  a1[14] = a2;
  Passuint64_t Count = C3DFXTechniqueGetPassCount(a2);
  if (!PassCount) {
    return 0;
  }
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(a1[2]);
  C3DStackAllocatorPushFrame(StackAllocator);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v89, StackAllocator);
  if (v91 < PassCount)
  {
    float32x4_t v23 = v92;
    Aligned = C3DStackAllocatorAllocateAligned(v89, 8 * PassCount, 8, 0);
    memcpy(Aligned, v23, 8 * v90);
    float32x4_t v92 = Aligned;
    unsigned int v91 = PassCount;
  }
  v87[0] = StackAllocator;
  C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate((uint64_t)v87, 32);
  uint64_t v25 = 0;
  char v86 = 0;
  int8x16_t v75 = 0;
  uint64_t v26 = PassCount;
  do
  {
    PassAtuint64_t Index = (__C3DFXPass *)C3DFXTechniqueGetPassAtIndex(a2, v25);
    uint64_t Scene = C3DEngineContextGetScene(a1[2]);
    C3DFXContextResolveNodeReferences(PassAtIndex, Scene);
    int DrawInstruction = C3DFXPassGetDrawInstruction((uint64_t)PassAtIndex);
    float32x4_t v85 = 0;
    switch(DrawInstruction)
    {
      case 1:
        __n128 v30 = C3D::FinalPass::_createTechniquePassCustom(a1, PassAtIndex, (uint64_t)v87, &v86);
        goto LABEL_23;
      case 2:
        float32x4_t v31 = scn_default_log();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          C3D::FinalPass::_createCustomTechniquePassesIfNeeded(&v83, v84);
        }
        goto LABEL_19;
      case 3:
        __n128 v30 = C3D::FinalPass::_createTechniquePassDrawScene((C3D::Pass *)a1, PassAtIndex, (uint64_t)v87, &v86, 0);
        goto LABEL_25;
      case 4:
        __n128 v30 = C3D::FinalPass::_createTechniquePassDrawQuad(a1, PassAtIndex, (uint64_t)v87, &v86);
        goto LABEL_23;
      case 6:
        __n128 v30 = C3D::FinalPass::_createTechniquePassDrawNodes((C3D::Pass *)a1, PassAtIndex, (uint64_t)v87, &v86);
LABEL_23:
        float32x4_t v85 = v30;
        goto LABEL_26;
      case 7:
        float32x4_t v33 = scn_default_log();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          C3D::FinalPass::_createCustomTechniquePassesIfNeeded(&v81, v82);
        }
        goto LABEL_19;
      case 8:
        __n128 v30 = C3D::FinalPass::_createTechniquePassDrawScene((C3D::Pass *)a1, PassAtIndex, (uint64_t)v87, &v86, 1u);
LABEL_25:
        float32x4_t v85 = v30;
        int8x16_t v75 = v30;
        goto LABEL_26;
      default:
        float32x4_t v32 = scn_default_log();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          C3D::FinalPass::_createCustomTechniquePassesIfNeeded(&v79, v80);
        }
LABEL_19:
        __n128 v30 = v85;
LABEL_26:
        PassAtIndex[1].var5 = (__C3DFXTechnique *)v30;
        if (!v30) {
          goto LABEL_73;
        }
        C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v78, StackAllocator);
        float32x4_t v34 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
        if (C3D::PassDescriptor::inputCount(v34))
        {
          unsigned __int8 v35 = 0;
          do
          {
            __n128 v36 = (void *)(C3D::Pass::inputBufferParameterAtIndex(v85, v35) + 8);
            if (*v36) {
              C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(v78, v36);
            }
            float32x4_t v37 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
            ++v35;
          }
          while (C3D::PassDescriptor::inputCount(v37) > v35);
        }
        if (v86 && v90)
        {
          float32x4_t v38 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
          if (!C3D::PassDescriptor::outputCount(v38)) {
            goto LABEL_43;
          }
          unsigned __int8 v39 = 0;
          char appended = 0;
          do
          {
            uint64_t v41 = C3D::Pass::outputBufferParameterAtIndex(v85, v39);
            __int16 v42 = *(_WORD *)(v41 + 66);
            if ((v42 & 0x40) == 0 && (v42 & 3) != 2)
            {
              int32x4_t v43 = *(unsigned char **)(v41 + 8);
              if (v43)
              {
                if (*v43) {
                  char appended = C3D::FinalPass::_appendRenderTargetDependencyForPass(v41, (uint64_t)&v89, v85, v41);
                }
              }
            }
            float32x2_t v44 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
            ++v39;
          }
          while (C3D::PassDescriptor::outputCount(v44) > v39);
          if ((appended & 1) == 0)
          {
LABEL_43:
            float32x2_t v45 = scn_default_log();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
            {
              uint64_t v65 = (**(uint64_t (***)(C3D::Pass *))v85)(v85);
              *(_DWORD *)buf = 136315394;
              float32x4_t v94 = "dependencyFound";
              __int16 v95 = 2080;
              uint64_t v96 = v65;
              _os_log_fault_impl(&dword_20B249000, v45, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Unable to find dependency in previous techniques for pass %s", buf, 0x16u);
            }
          }
        }
        float32x4_t v46 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
        if (!C3D::PassDescriptor::inputCount(v46)) {
          goto LABEL_72;
        }
        unsigned __int8 v47 = 0;
        break;
    }
    do
    {
      uint64_t v48 = C3D::Pass::inputBufferParameterAtIndex(v85, v47);
      uint64_t v49 = v48;
      __n128 v50 = *(_anonymous_namespace_ **)(v48 + 8);
      if (!v50) {
        goto LABEL_67;
      }
      size_t v51 = strlen(*(const char **)(v48 + 8));
      unint64_t v53 = 0xC6A4A7935BD1E995 * v51;
      if (v51 >= 8)
      {
        uint64_t v55 = v51 >> 3;
        __n128 v54 = (unsigned __int8 *)v50 + 8 * v55;
        uint64_t v56 = 8 * v55;
        long long v57 = v50;
        do
        {
          uint64_t v58 = *(void *)v57;
          long long v57 = (_anonymous_namespace_ *)((char *)v57 + 8);
          unint64_t v53 = 0xC6A4A7935BD1E995
              * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v58) ^ ((0xC6A4A7935BD1E995 * v58) >> 47))) ^ v53);
          v56 -= 8;
        }
        while (v56);
      }
      else
      {
        __n128 v54 = (unsigned __int8 *)v50;
      }
      switch(v51 & 7)
      {
        case 1uLL:
          goto LABEL_59;
        case 2uLL:
          goto LABEL_58;
        case 3uLL:
          goto LABEL_57;
        case 4uLL:
          goto LABEL_56;
        case 5uLL:
          goto LABEL_55;
        case 6uLL:
          goto LABEL_54;
        case 7uLL:
          v53 ^= (unint64_t)v54[6] << 48;
LABEL_54:
          v53 ^= (unint64_t)v54[5] << 40;
LABEL_55:
          v53 ^= (unint64_t)v54[4] << 32;
LABEL_56:
          v53 ^= (unint64_t)v54[3] << 24;
LABEL_57:
          v53 ^= (unint64_t)v54[2] << 16;
LABEL_58:
          v53 ^= (unint64_t)v54[1] << 8;
LABEL_59:
          unint64_t v53 = 0xC6A4A7935BD1E995 * (v53 ^ *v54);
          break;
        default:
          break;
      }
      unint64_t v59 = (0xC6A4A7935BD1E995 * (v53 ^ (v53 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v53 ^ (v53 >> 47))) >> 47);
      unsigned int v60 = (v88 - 1) & v59;
      unsigned int v61 = *(unsigned __int16 *)(v87[3] + 2 * v60);
      if (v61 >= 2)
      {
        while ((v61 & 2) == 0 || v59 != *(void *)(v87[1] + 8 * v60))
        {
          ++v60;
          BOOL v62 = v61 >= 4;
          v61 >>= 1;
          if (!v62) {
            goto LABEL_64;
          }
        }
        if (v87[2])
        {
          if (C3D::FinalPass::_appendRenderTargetDependencyForPass(v51, (uint64_t)&v89, v85, v49)) {
            goto LABEL_67;
          }
          __n128 v50 = *(_anonymous_namespace_ **)(v49 + 8);
        }
      }
LABEL_64:
      {
        C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(a3, &v85);
      }
LABEL_67:
      long long v64 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
      ++v47;
    }
    while (C3D::PassDescriptor::inputCount(v64) > v47);
LABEL_72:
    C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v89, &v85);
LABEL_73:
    ++v25;
  }
  while (v25 != v26);
  signed int v66 = v90 - 1;
  if ((int)(v90 - 1) < 0)
  {
    float32x4_t v67 = 0;
  }
  else
  {
    do
    {
      float32x4_t v67 = *(C3D::Pass **)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[]((uint64_t)&v89, v66);
      long long v68 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v67);
      int v69 = C3D::PassDescriptor::outputCount(v68);
      if (v69)
      {
        int v70 = 0;
        while (1)
        {
          uint64_t v71 = C3D::Pass::outputBufferParameterAtIndex(v67, v70);
          if (*(unsigned char *)(v71 + 64) == 1 && !strcmp(*(const char **)(v71 + 8), "COLOR")) {
            break;
          }
          if (v69 == ++v70) {
            goto LABEL_80;
          }
        }
      }
      else
      {
LABEL_80:
        float32x4_t v67 = 0;
      }
      if (v67) {
        break;
      }
    }
    while (v66-- > 0);
  }
  *a4 = v67;
  C3DStackAllocatorPopFrame(StackAllocator);
  return v75;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::OverlayPass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 240, 16, 0);
  *(void *)C3D::RenderPass::RenderPass(Aligned, (RenderGraph *)a1, *a2) = &unk_26BF6CBD0;
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::DownsamplePass *C3D::RenderGraph::createPass<C3D::DownsamplePass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::DownsamplePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::DownsamplePass::DownsamplePass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::DownsamplePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::RenderPass *C3D::RenderGraph::createPass<C3D::JitteringPass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::RenderPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  *(void *)C3D::RenderPass::RenderPass(Aligned, (RenderGraph *)a1, *a2) = &unk_26BF6D020;
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ManipulatorPass *C3D::RenderGraph::createPass<C3D::ManipulatorPass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::ManipulatorPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5376, 16, 0);
  C3D::ManipulatorPass::ManipulatorPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ManipulatorPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::GridPass *C3D::RenderGraph::createPass<C3D::GridPass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::GridPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::GridPass::GridPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::GridPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::AuthoringPass *C3D::RenderGraph::createPass<C3D::AuthoringPass,C3D::FinalPass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::AuthoringPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5392, 16, 0);
  C3D::AuthoringPass::AuthoringPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::AuthoringPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::CompositeARPass *C3D::RenderGraph::createPass<C3D::CompositeARPass,C3D::ScenePass *&>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::CompositeARPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 272, 16, 0);
  C3D::CompositeARPass::CompositeARPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::CompositeARPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::DrawBackgroundPass *C3D::RenderGraph::createPass<C3D::DrawBackgroundPass,C3D::ScenePass *&>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::DrawBackgroundPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5280, 16, 0);
  C3D::DrawBackgroundPass::DrawBackgroundPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::DrawBackgroundPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ScenePass *C3D::FinalPass::_createTechniquePassDrawScene(C3D::Pass *a1, __C3DFXPass *a2, uint64_t a3, unsigned char *a4, unsigned __int8 a5)
{
  v14.var4 = 1;
  *(_DWORD *)&v14.var0 = 16843009;
  v14.var5 = a5;
  uint64_t v9 = *((void *)a1 + 3);
  uint64_t v13 = a1;
  C3D::FinalPass::_parametersForDrawNodesTechniquePass((const __CFArray **)a1, a2, (uint64_t)v12);
  uint64_t v10 = C3D::RenderGraph::createPass<C3D::ScenePass,C3D::FinalPass *,C3D::ScenePass::Parameters &,C3D::DrawNodesPass::Parameters>(v9, &v13, &v14, v12);
  C3D::FinalPass::_setupTechniquePassCommonData((uint64_t *)a1, (__n128 *)v10, (uint64_t)a2, a3, a4);
  return v10;
}

C3D::DrawNodesPass *C3D::FinalPass::_createTechniquePassDrawNodes(C3D::Pass *a1, __C3DFXPass *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v8 = *((void *)a1 + 3);
  uint64_t v12 = a1;
  C3D::FinalPass::_parametersForDrawNodesTechniquePass((const __CFArray **)a1, a2, (uint64_t)v11);
  uint64_t v9 = C3D::RenderGraph::createPass<C3D::DrawNodesPass,C3D::FinalPass *,C3D::DrawNodesPass::Parameters>(v8, &v12, v11);
  C3D::FinalPass::_setupTechniquePassCommonData((uint64_t *)a1, (__n128 *)v9, (uint64_t)a2, a3, a4);
  return v9;
}

C3D::DrawQuadPass *C3D::FinalPass::_createTechniquePassDrawQuad(uint64_t *a1, __C3DFXPass *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v9 = (C3D::Pass *)a1;
  uint64_t v10 = a2;
  uint64_t v7 = C3D::RenderGraph::createPass<C3D::DrawQuadPass,C3D::FinalPass *,__C3DFXPass *&>(a1[3], &v9, &v10);
  C3D::FinalPass::_setupTechniquePassCommonData(a1, (__n128 *)v7, (uint64_t)v10, a3, a4);
  return v7;
}

C3D::CustomPass *C3D::FinalPass::_createTechniquePassCustom(uint64_t *a1, __C3DFXPass *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v13 = (C3D::Pass *)a1;
  Parameters v14 = a2;
  uint64_t v7 = C3D::RenderGraph::createPass<C3D::CustomPass,C3D::FinalPass *,__C3DFXPass *&>(a1[3], &v13, &v14);
  C3D::FinalPass::_setupTechniquePassCommonData(a1, (__n128 *)v7, (uint64_t)v14, a3, a4);
  uint64_t v8 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v7);
  if (C3D::PassDescriptor::outputCount(v8))
  {
    unsigned int v9 = 0;
    do
    {
      uint64_t v10 = (unsigned char *)C3D::Pass::outputBufferParameterAtIndex(v7, v9);
      if (*v10 == 1) {
        v10[26] = 7;
      }
      ++v9;
      uint64_t v11 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v7);
    }
    while (v9 < C3D::PassDescriptor::outputCount(v11));
  }
  return v7;
}

uint64_t C3D::FinalPass::_appendRenderTargetDependencyForPass(uint64_t a1, uint64_t a2, C3D::Pass *a3, uint64_t a4)
{
  signed int v4 = *(_DWORD *)(a2 + 8) - 1;
  if (v4 < 0) {
    return 0;
  }
  while (1)
  {
    uint64_t v8 = *(C3D::Pass **)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](a2, v4);
    unsigned int v9 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v8);
    unsigned int v10 = C3D::PassDescriptor::outputCount(v9);
    if (v10) {
      break;
    }
LABEL_7:
    if (v4-- <= 0) {
      return 0;
    }
  }
  unsigned int v11 = v10;
  int v12 = 0;
  while (1)
  {
    uint64_t v13 = C3D::Pass::outputBufferParameterAtIndex(v8, v12);
    if (*(unsigned __int8 *)(v13 + 64) == *(unsigned __int8 *)(a4 + 64)
      && !strcmp(*(const char **)(v13 + 8), *(const char **)(a4 + 8)))
    {
      break;
    }
    if (++v12 >= v11) {
      goto LABEL_7;
    }
  }
  C3D::Pass::addDependency(a3, v8);
  return 1;
}

uint64_t anonymous namespace'::SymbolNameHasPrefix(_anonymous_namespace_ *this, const char *a2, char *a3, unsigned __int8 *a4)
{
  unsigned int v7 = strlen((const char *)this);
  unsigned int v8 = strlen(a2);
  if (v8 + 1 < v7) {
    return 0;
  }
  if (!v7)
  {
LABEL_8:
    if (!a3) {
      return 1;
    }
    LOBYTE(v13) = 0;
LABEL_10:
    *a3 = v13;
    return 1;
  }
  uint64_t v10 = v7;
  unsigned int v11 = this;
  uint64_t v12 = v8;
  while (v12)
  {
    if (*(unsigned __int8 *)a2 != *(unsigned __int8 *)v11) {
      return 0;
    }
    --v12;
    ++a2;
    unsigned int v11 = (_anonymous_namespace_ *)((char *)v11 + 1);
    if (!--v10) {
      goto LABEL_8;
    }
  }
  unsigned int v13 = *((unsigned __int8 *)this + v8) - 48;
  if (v13 > 9) {
    return 0;
  }
  if (a3) {
    goto LABEL_10;
  }
  return 1;
}

uint64_t C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    signed int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 8);
      int v7 = 136315906;
      unsigned int v8 = "i < size()";
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v6;
      _os_log_fault_impl(&dword_20B249000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(void *)(a1 + 16) + 8 * a2;
}

BOOL C3D::__IsSameRenderTarget(C3D *this, const C3D::PassIODescriptor *a2, const C3D::PassIODescriptor *a3)
{
  uint64_t v5 = (const char *)*((void *)this + 1);
  if (!v5 || (int v6 = (const char *)*((void *)a2 + 1)) == 0 || strcmp(v5, v6))
  {
    int v7 = *((unsigned __int8 *)this + 64);
    if (v7 != *((unsigned __int8 *)a2 + 64)) {
      return 0;
    }
    if (v7 == 1) {
      return *((unsigned __int8 *)this + 65) == *((unsigned __int8 *)a2 + 65);
    }
  }
  return 1;
}

uint64_t C3D::FinalPass::_setupTechniquePassCommonData(uint64_t *a1, __n128 *this, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  *(void *)((char *)&v204[1] + 4) = *MEMORY[0x263EF8340];
  v170 = this;
  if ((*(unsigned char *)(a3 + 187) & 8) == 0)
  {
    uint64_t v5 = a1[14];
    *(void *)uint64_t v196 = a3;
    *(void *)&v196[8] = v5;
    uint64_t v6 = a1[2];
    *(void *)&v196[16] = 0;
    *(void *)&v196[24] = v6;
    long long v197 = 0uLL;
    uint64_t v7 = *(void *)(a3 + 280);
    *(void *)&long long v198 = 0xBFF0000000000000;
    *((void *)&v198 + 1) = v7;
    uint64_t v200 = 0;
    long long v199 = 0uLL;
    C3DFXPassInitialize((uint64_t *)v196, 0);
    this = v170;
  }
  *a5 = 0;
  if (*(_DWORD *)C3D::Pass::descriptor((C3D::Pass *)this) == 2)
  {
    uint64_t RasterizerStates = C3DFXPassGetRasterizerStates(a3);
    if (RasterizerStates)
    {
      C3DRasterizerStatesGetDesc(RasterizerStates, (uint64_t)v196);
      v170[14].n128_u32[0] = v196[16];
    }
    if (C3DFXPassGetHasCustomViewport(a3))
    {
      v170[7].n128_u8[9] = 1;
      v170[8] = C3DFXPassGetViewport((__n128 *)a3);
    }
  }
  __int16 v9 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
  if (C3D::PassDescriptor::outputCount(v9))
  {
    uint64_t v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
    if (C3D::PassDescriptor::outputCount(v10))
    {
      unsigned int v11 = 0;
      do
      {
        uint64_t v12 = C3D::Pass::outputBufferParameterAtIndex((C3D::Pass *)v170, v11);
        uint64_t v13 = v12;
        unsigned int v14 = *(unsigned __int8 *)(a3 + 176);
        if (v14 <= 1) {
          LOBYTE(v14) = 0;
        }
        *(unsigned char *)(v12 + 31) = v14;
        uint64_t v15 = *(unsigned __int8 *)(v12 + 24);
        BOOL IsMultisampled = SCNMTLTextureTypeIsMultisampled(v15);
        BOOL v17 = IsMultisampled;
        unsigned int v18 = *(unsigned __int8 *)(a3 + 176);
        char v19 = v18 < 2 || IsMultisampled;
        if ((v19 & 1) == 0)
        {
          *(unsigned char *)(v13 + 24) = SCNMTLTextureTypeMultisampledEquivalent(v15);
          unsigned int v18 = *(unsigned __int8 *)(a3 + 176);
        }
        if (v18 < 2 && v17) {
          *(unsigned char *)(v13 + 24) = SCNMTLTextureTypeNonMultisampledEquivalent(v15);
        }
        uint64_t v21 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
        ++v11;
      }
      while (v11 < C3D::PassDescriptor::outputCount(v21));
    }
  }
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(a1[2]);
  C3DStackAllocatorPushFrame(StackAllocator);
  uint64_t v22 = C3DEngineContextGetStackAllocator(a1[2]);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v179, v22);
  uint64_t v165 = *(void *)(a3 + 512);
  uint64_t v166 = *(unsigned int *)(a3 + 520);
  if (*(_DWORD *)(a3 + 520))
  {
    uint64_t v25 = *(uint64_t **)(a3 + 512);
    for (uint64_t i = *(unsigned int *)(a3 + 520); i; --i)
    {
      uint64_t v26 = *v25;
      if (*(_DWORD *)(*v25 + 16) == 1)
      {
        *(void *)uint64_t v196 = 0;
        int v27 = *(_DWORD *)(v26 + 32);
        if (v27)
        {
LABEL_30:
          C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v179, v196);
          goto LABEL_31;
        }
        if (*(void *)v196) {
          goto LABEL_30;
        }
      }
LABEL_31:
      ++v25;
    }
  }
  v176[0] = C3DEngineContextGetStackAllocator(a1[2]);
  C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::_allocate((uint64_t)v176, 32);
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(&v172, StackAllocator);
  int v28 = *(_DWORD *)(a3 + 440);
  float v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
  unsigned int v31 = v28 + C3D::PassDescriptor::outputCount(v29);
  if (v174 < v31)
  {
    float32x4_t v33 = v175;
    Aligned = C3DStackAllocatorAllocateAligned(v172, 80 * v31, 16, 0);
    memcpy(Aligned, v33, 80 * v173);
    int8x16_t v175 = (C3D::PassIODescriptor *)Aligned;
    unsigned int v174 = v31;
  }
  if (*(_DWORD *)(a3 + 440))
  {
    unint64_t v35 = 0;
    uint64_t v164 = *(void *)(a3 + 432);
    do
    {
      uint64_t v36 = v164 + (v35 << 6);
      CFStringRef v37 = *(const __CFString **)(v36 + 8);
      if (v37) {
      else
      }
        float32x4_t v38 = 0;
      unsigned int v41 = *(_DWORD *)(v36 + 16);
      long long v40 = (_DWORD *)(v36 + 16);
      char v39 = v41;
      if (v41 >= 6)
      {
        unsigned __int8 v47 = scn_default_log();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          C3D::FinalPass::_setupTechniquePassCommonData(&v182, v183);
        }
        unsigned int v42 = 0;
        BOOL v43 = 0;
        BOOL v44 = 0;
        LOBYTE(v45) = 0;
        char v46 = 1;
      }
      else
      {
        unsigned int v42 = (0x1Eu >> v39) & 1;
        BOOL v43 = (v39 & 0x3F) == 0;
        BOOL v44 = (v39 & 0x3F) == 5;
        unint64_t v45 = 0x30101010102uLL >> (8 * v39);
        char v46 = (0x1Eu >> v39) & 1;
      }
      uint64_t v48 = "COLOR";
      if (((v38 == 0) & v42) == 0) {
        uint64_t v48 = v38;
      }
      if (v43 && v48 == 0) {
        uint64_t v49 = "DEPTH";
      }
      else {
        uint64_t v49 = (char *)v48;
      }
      if (*(unsigned __int8 *)(a3 + 176) <= 1u) {
        char v50 = 2;
      }
      else {
        char v50 = 4;
      }
      C3D::PassIODescriptor::PassIODescriptor((uint64_t)__s, v50);
      __s[1] = v49;
      LOBYTE(v195) = v45;
      if (!strcmp(v49, "DEPTH")) {
        WORD1(v195) |= 8u;
      }
      if (*v40 >= 6u)
      {
        __n128 v52 = scn_default_log();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
          C3D::FinalPass::_setupTechniquePassCommonData(&v184, v185);
        }
        unsigned int v51 = 255;
      }
      else
      {
        unsigned int v51 = (0xFF03020100FFuLL >> (8 * *v40));
      }
      uint64_t FramebufferDescription = C3DFXPassGetFramebufferDescription(a3);
      if ((*(unsigned char *)(FramebufferDescription + 80) & 8) != 0) {
        float32x2_t v54 = (float32x2_t)a1[17];
      }
      else {
        float32x2_t v54 = *(float32x2_t *)FramebufferDescription;
      }
      float32x2_t v169 = v54;
      if (v42)
      {
        float v55 = *(float *)(a3 + 4 * v51 + 392);
        uint64_t v56 = FramebufferDescription + 8 * v51;
        int v58 = *(unsigned __int8 *)(v56 + 8);
        long long v57 = (unsigned __int8 *)(v56 + 8);
        if (v58 == 1)
        {
          uint64_t v59 = a1[19];
        }
        else
        {
          if ((*(unsigned char *)(FramebufferDescription + 80) & 7u) <= v51)
          {
            unsigned int v60 = scn_default_log();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT)) {
              C3D::FinalPass::_setupTechniquePassCommonData(v201, &v202, v60);
            }
          }
          LOWORD(v59) = C3DRenderBufferFormatToMTLPixelFormat(*v57, 0, 0);
        }
      }
      else if (v46)
      {
        LOWORD(v59) = 0;
        float v55 = 1.0;
      }
      else
      {
        LOWORD(v59) = C3DRenderBufferFormatToMTLPixelFormat(*(unsigned __int8 *)(FramebufferDescription + 72), 0, 0);
        float v55 = *(float *)(a3 + 424);
      }
      LOWORD(v192) = (int)(float)(v55 * v169.f32[0]);
      WORD1(v192) = (int)vmuls_lane_f32(v55, v169, 1);
      WORD6(v192) = v59;
      unsigned int v61 = *(unsigned __int8 *)(a3 + 176);
      if (v61 <= 1) {
        LOBYTE(v61) = 0;
      }
      HIBYTE(v192) = v61;
      long long v194 = *(_OWORD *)(a3 + 128);
      unsigned int v62 = *(_DWORD *)(a3 + 184);
      char v63 = v42 ^ 1;
      if ((v62 & 1) == 0) {
        char v63 = 1;
      }
      if (v63)
      {
        char v65 = !v43;
        if ((v62 & 2) == 0) {
          char v65 = 1;
        }
        if (v65)
        {
          char v66 = !v44;
          if ((*(_DWORD *)(a3 + 184) & 4) == 0) {
            char v66 = 1;
          }
          if (v66) {
            goto LABEL_86;
          }
        }
        LOWORD(v64) = WORD1(v195) & 0xFFFC | 2;
      }
      else
      {
        int v64 = (WORD1(v195) & 0xFFBC | (v62 >> 3) & 0x40) ^ 0x42;
      }
      WORD1(v195) = v64;
LABEL_86:
      BYTE1(v195) = v51;
      if (v49)
      {
        float32x4_t v67 = __s[1];
        unsigned int v68 = strlen(__s[1]);
        unint64_t v69 = 0xC6A4A7935BD1E995 * v68;
        if (v68 >= 8)
        {
          uint64_t v71 = v68 >> 3;
          int v70 = (unsigned __int8 *)&__s[1][8 * v71];
          uint64_t v72 = 8 * v71;
          float32x4_t v73 = __s[1];
          do
          {
            uint64_t v74 = *(void *)v73;
            v73 += 8;
            unint64_t v69 = 0xC6A4A7935BD1E995
                * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v74) ^ ((0xC6A4A7935BD1E995 * v74) >> 47))) ^ v69);
            v72 -= 8;
          }
          while (v72);
        }
        else
        {
          int v70 = (unsigned __int8 *)__s[1];
        }
        switch(v68 & 7)
        {
          case 1u:
            goto LABEL_98;
          case 2u:
            goto LABEL_97;
          case 3u:
            goto LABEL_96;
          case 4u:
            goto LABEL_95;
          case 5u:
            goto LABEL_94;
          case 6u:
            goto LABEL_93;
          case 7u:
            v69 ^= (unint64_t)v70[6] << 48;
LABEL_93:
            v69 ^= (unint64_t)v70[5] << 40;
LABEL_94:
            v69 ^= (unint64_t)v70[4] << 32;
LABEL_95:
            v69 ^= (unint64_t)v70[3] << 24;
LABEL_96:
            v69 ^= (unint64_t)v70[2] << 16;
LABEL_97:
            v69 ^= (unint64_t)v70[1] << 8;
LABEL_98:
            unint64_t v69 = 0xC6A4A7935BD1E995 * (v69 ^ *v70);
            break;
          default:
            break;
        }
        unint64_t v75 = (0xC6A4A7935BD1E995 * (v69 ^ (v69 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v69 ^ (v69 >> 47))) >> 47);
        unsigned int v76 = (*(_DWORD *)(a4 + 36) - 1) & v75;
        unsigned int v77 = *(unsigned __int16 *)(*(void *)(a4 + 24) + 2 * v76);
        if (v77 < 2) {
          goto LABEL_103;
        }
        while ((v77 & 2) == 0 || v75 != *(void *)(*(void *)(a4 + 8) + 8 * v76))
        {
          ++v76;
          BOOL v78 = v77 >= 4;
          v77 >>= 1;
          if (!v78) {
            goto LABEL_103;
          }
        }
        if (!*(void *)(a4 + 16) || (__int16 v79 = WORD1(v195), (BYTE2(v195) & 3) == 2))
        {
LABEL_103:
          v196[0] = v45;
          *(_OWORD *)&v196[4] = v192;
          *(_DWORD *)&v196[20] = v193;
          C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::insert(a4, v75, (long long *)v196);
        }
        else
        {
          double v80 = v181;
          uint64_t v81 = v180;
          if (v180)
          {
            uint64_t v82 = 8 * v180;
            char v83 = v181;
            while (strcmp(*v83, v67))
            {
              ++v83;
              v82 -= 8;
              if (!v82) {
                goto LABEL_115;
              }
            }
          }
          else
          {
            char v83 = v181;
          }
          if (v83 == &v80[v81])
          {
LABEL_115:
            WORD1(v195) = v79 & 0xFF74 | 0x81;
            *a5 = 1;
            long long v197 = v193;
            long long v198 = v194;
            long long v199 = v195;
            *(_OWORD *)uint64_t v196 = *(_OWORD *)__s;
            *(_OWORD *)&v196[16] = v192;
            C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::insert((uint64_t)v176, v75, v196);
          }
        }
      }
      __n128 v32 = C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v172, (uint64_t)__s);
      ++v35;
    }
    while (v35 < *(unsigned int *)(a3 + 440));
  }
  float32x4_t v84 = v175;
  unint64_t v85 = v173;
  char v86 = (char *)v175 + 80 * v173;
  if (v173 < 0x81)
  {
    float32x4_t v87 = 0;
    uint64_t v89 = 0;
  }
  else
  {
    float32x4_t v87 = std::get_temporary_buffer[abi:nn180100]<C3D::PassIODescriptor>(v173);
    uint64_t v89 = v88;
  }
  std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>((uint64_t)v84, v86, v85, (uint64_t)v87, v89, v32);
  if (v87) {
    operator delete(v87);
  }
  unsigned int v90 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
  if (C3D::PassDescriptor::outputCount(v90))
  {
    unsigned int v91 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
    if (C3D::PassDescriptor::outputCount(v91))
    {
      unsigned int v92 = 0;
      do
      {
        float32x4_t v94 = (C3D *)C3D::Pass::outputBufferParameterAtIndex((C3D::Pass *)v170, v92);
        __int16 v95 = v175;
        unsigned int v96 = v173;
        if (v173)
        {
          uint64_t v97 = 80 * v173;
          float v98 = v175;
          while (!C3D::__IsSameRenderTarget(v94, v98, v93))
          {
            float v98 = (C3D::PassIODescriptor *)((char *)v98 + 80);
            v97 -= 80;
            if (!v97) {
              goto LABEL_131;
            }
          }
        }
        else
        {
          float v98 = v175;
        }
        if (v98 == (C3D::PassIODescriptor *)((char *)v95 + 80 * v96)) {
LABEL_131:
        }
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v172, (uint64_t)v94);
        float32x4_t v99 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
        ++v92;
      }
      while (v92 < C3D::PassDescriptor::outputCount(v99));
    }
  }
  C3D::Pass::setOutputCount((C3D::Pass *)v170, v173);
  if (v173)
  {
    int v100 = 0;
    float32x4_t v101 = v175;
    uint64_t v102 = 80 * v173;
    do
    {
      float32x4_t v103 = (_OWORD *)C3D::Pass::outputBufferParameterAtIndex((C3D::Pass *)v170, v100++);
      *float32x4_t v103 = *(_OWORD *)v101;
      long long v104 = *((_OWORD *)v101 + 1);
      long long v105 = *((_OWORD *)v101 + 2);
      long long v106 = *((_OWORD *)v101 + 4);
      v103[3] = *((_OWORD *)v101 + 3);
      v103[4] = v106;
      v103[1] = v104;
      v103[2] = v105;
      float32x4_t v101 = (C3D::PassIODescriptor *)((char *)v101 + 80);
      v102 -= 80;
    }
    while (v102);
  }
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(__s, StackAllocator);
  uint64_t v107 = *(void *)(a3 + 520);
  unsigned int v108 = v177;
  float32x4_t v109 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
  unsigned int v110 = v107 + v108 + C3D::PassDescriptor::inputCount(v109);
  if (HIDWORD(__s[1]) < v110)
  {
    float32x4_t v111 = (const void *)v192;
    float32x4_t v112 = C3DStackAllocatorAllocateAligned((uint64_t)__s[0], 80 * v110, 16, 0);
    memcpy(v112, v111, 80 * LODWORD(__s[1]));
    *(void *)&long long v192 = v112;
    HIDWORD(__s[1]) = v110;
  }
  unsigned int v113 = v177;
  C3D::PassIODescriptor::PassIODescriptor((uint64_t)v196, 2);
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::resize(__s, v113, v196);
  int v115 = v178;
  if (v178 != -15)
  {
    unint64_t v116 = 0;
    do
    {
      if (*(_WORD *)(v176[3] + 2 * v116))
      {
        int32x4_t v117 = (_OWORD *)(v176[2] + 80 * v116);
        long long v199 = v117[4];
        *(_OWORD *)&v196[16] = v117[1];
        long long v197 = v117[2];
        long long v198 = v117[3];
        *(_OWORD *)uint64_t v196 = *v117;
        WORD1(v199) = WORD1(v199) & 0xFF74 | 0x81;
        unsigned int v118 = v173;
        if (v173)
        {
          unsigned int v119 = 0;
          float32x4_t v120 = v175;
          uint64_t v121 = 80 * v173;
          while (!C3D::__IsSameRenderTarget(v120, (const C3D::PassIODescriptor *)v196, v114))
          {
            ++v119;
            float32x4_t v120 = (C3D::PassIODescriptor *)((char *)v120 + 80);
            v121 -= 80;
            if (!v121) {
              goto LABEL_149;
            }
          }
        }
        else
        {
          unsigned int v119 = 0;
        }
        BOOL v78 = v119 >= v118;
        unsigned int v118 = v119;
        if (v78)
        {
LABEL_149:
          float32x4_t v122 = scn_default_log();
          if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT)) {
            C3D::FinalPass::_setupTechniquePassCommonData(v203, v204, v122);
          }
        }
        float32x4_t v123 = (_OWORD *)C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::operator[]((uint64_t)__s, v118);
        v123[1] = *(_OWORD *)&v196[16];
        v123[2] = v197;
        v123[3] = v198;
        v123[4] = v199;
        *float32x4_t v123 = *(_OWORD *)v196;
        int v115 = v178;
      }
      ++v116;
    }
    while (v116 < (v115 + 15));
  }
  if (v166)
  {
    uint64_t v124 = 0;
    while (1)
    {
      uint64_t v125 = *(void *)(v165 + 8 * v124);
      if (*(_DWORD *)(v125 + 16) == 1) {
        break;
      }
LABEL_169:
      if (++v124 == v166) {
        goto LABEL_206;
      }
    }
    if (*(unsigned __int8 *)(a3 + 176) <= 1u) {
      char v126 = 2;
    }
    else {
      char v126 = 4;
    }
    C3D::PassIODescriptor::PassIODescriptor((uint64_t)v196, v126);
    int v128 = *(_DWORD *)(v125 + 32);
    if (v128)
    {
    }
    else
    {
      if (!*(void *)&v196[8])
      {
        float32x4_t v129 = scn_default_log();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT)) {
          C3D::FinalPass::_setupTechniquePassCommonData(v189, &v190, v129);
        }
      }
      int v128 = *(_DWORD *)(v125 + 32);
    }
    if ((v128 - 20) >= 8)
    {
      if (v128 != 28)
      {
        float32x4_t v132 = *(_anonymous_namespace_ **)&v196[8];
        unsigned int v133 = strlen(*(const char **)&v196[8]);
        unint64_t v135 = 0xC6A4A7935BD1E995 * v133;
        if (v133 >= 8)
        {
          uint64_t v137 = v133 >> 3;
          v136 = (unsigned __int8 *)(*(void *)&v196[8] + 8 * v137);
          uint64_t v138 = 8 * v137;
          float v139 = *(uint64_t **)&v196[8];
          do
          {
            uint64_t v140 = *v139++;
            unint64_t v135 = 0xC6A4A7935BD1E995
                 * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v140) ^ ((0xC6A4A7935BD1E995 * v140) >> 47))) ^ v135);
            v138 -= 8;
          }
          while (v138);
        }
        else
        {
          v136 = *(unsigned __int8 **)&v196[8];
        }
        switch(v133 & 7)
        {
          case 1u:
            goto LABEL_186;
          case 2u:
            goto LABEL_185;
          case 3u:
            goto LABEL_184;
          case 4u:
            goto LABEL_183;
          case 5u:
            goto LABEL_182;
          case 6u:
            goto LABEL_181;
          case 7u:
            v135 ^= (unint64_t)v136[6] << 48;
LABEL_181:
            v135 ^= (unint64_t)v136[5] << 40;
LABEL_182:
            v135 ^= (unint64_t)v136[4] << 32;
LABEL_183:
            v135 ^= (unint64_t)v136[3] << 24;
LABEL_184:
            v135 ^= (unint64_t)v136[2] << 16;
LABEL_185:
            v135 ^= (unint64_t)v136[1] << 8;
LABEL_186:
            unint64_t v135 = 0xC6A4A7935BD1E995 * (v135 ^ *v136);
            break;
          default:
            break;
        }
        unint64_t v141 = (0xC6A4A7935BD1E995 * (v135 ^ (v135 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v135 ^ (v135 >> 47))) >> 47);
        unsigned int v142 = (*(_DWORD *)(a4 + 36) - 1) & v141;
        unsigned int v143 = *(unsigned __int16 *)(*(void *)(a4 + 24) + 2 * v142);
        if (v143 < 2) {
          goto LABEL_191;
        }
        while ((v143 & 2) == 0 || v141 != *(void *)(*(void *)(a4 + 8) + 8 * v142))
        {
          ++v142;
          BOOL v78 = v143 >= 4;
          v143 >>= 1;
          if (!v78) {
            goto LABEL_191;
          }
        }
        uint64_t v146 = *(void *)(a4 + 16);
        if (v146)
        {
          uint64_t v147 = v146 + 24 * v142;
          LOBYTE(v199) = *(unsigned char *)v147;
          long long v148 = *(_OWORD *)(v147 + 4);
          LODWORD(v197) = *(_DWORD *)(v147 + 20);
          *(_OWORD *)&v196[16] = v148;
          unsigned int v149 = *(unsigned __int8 *)(a3 + 176);
          if (v149 <= 1) {
            char v150 = 0;
          }
          else {
            char v150 = *(unsigned char *)(a3 + 176);
          }
          v196[31] = v150;
          if (v196[24] == 2)
          {
            if (v149 >= 2) {
              v196[24] = 4;
            }
          }
          else if (v196[24] == 4 && v149 <= 1)
          {
            v196[24] = 2;
          }
        }
        else
        {
LABEL_191:
          {
            char v145 = 1;
          }
          else
          {
              goto LABEL_169;
            char v145 = 2;
          }
          char v186 = -1;
          LOBYTE(v199) = v145;
        }
        goto LABEL_168;
      }
      float32x4_t v131 = scn_default_log();
      if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR)) {
        C3D::FinalPass::_setupTechniquePassCommonData(&v187, v188);
      }
      char v130 = 2;
    }
    else
    {
      char v130 = 1;
    }
    LOBYTE(v199) = v130;
LABEL_168:
    C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)__s, (uint64_t)v196);
    goto LABEL_169;
  }
LABEL_206:
  for (unsigned int j = 0; ; ++j)
  {
    float v152 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v170);
    if (j >= C3D::PassDescriptor::inputCount(v152)) {
      break;
    }
    uint64_t v153 = C3D::Pass::inputBufferParameterAtIndex((C3D::Pass *)v170, j);
    C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)__s, v153);
  }
  C3D::Pass::setInputCount((C3D::Pass *)v170, __s[1]);
  if (LODWORD(__s[1]))
  {
    int v154 = 0;
    uint64_t v155 = (_OWORD *)v192;
    uint64_t v156 = 80 * LODWORD(__s[1]);
    do
    {
      v157 = (_OWORD *)C3D::Pass::inputBufferParameterAtIndex((C3D::Pass *)v170, v154++);
      _OWORD *v157 = *v155;
      long long v158 = v155[1];
      long long v159 = v155[2];
      long long v160 = v155[4];
      v157[3] = v155[3];
      v157[4] = v160;
      v157[1] = v158;
      v157[2] = v159;
      v155 += 5;
      v156 -= 80;
    }
    while (v156);
  }
  return C3DStackAllocatorPopFrame(StackAllocator);
}

void sub_20B303B28(_Unwind_Exception *exception_object)
{
}

void *anonymous namespace'::ScratchAllocatedCStringFromCFString(const __CFString *this, const __CFString *a2, void *a3)
{
  size_t v5 = CFStringGetLength(this) + 1;
  Aligned = (void *)C3DScratchAllocatorAllocateAligned(a2, v5, 1, 0);
  bzero(Aligned, v5);
  CFStringGetCString(this, (char *)Aligned, v5, 0x8000100u);
  return Aligned;
}

const char *anonymous namespace'::InputNameForFXSemantic(int a1)
{
  if ((a1 - 1) > 0x1B) {
    return "Invalid";
  }
  else {
    return off_264005270[a1 - 1];
  }
}

uint64_t C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::insert(uint64_t a1, uint64_t a2, long long *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      unsigned int v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          uint64_t v27 = v26 + 24 * v15;
          int v28 = (long long *)(v26 + 24 * v21);
          long long v29 = *v28;
          *(void *)(v27 + 16) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v27 = v29;
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      uint64_t v33 = *(void *)(a1 + 16) + 24 * v21;
      long long v34 = *a3;
      *(void *)(v33 + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v33 = v34;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v35 = *(void *)(a1 + 24);
      *(_WORD *)(v35 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v35 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  uint64_t v31 = *(void *)(a1 + 16) + 24 * v10;
  long long v32 = *a3;
  *(void *)(v31 + 16) = *((void *)a3 + 2);
  *(_OWORD *)uint64_t v31 = v32;
  return result;
}

__n128 C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 12);
  int v6 = *(char **)(a1 + 16);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    Aligned = (char *)C3DStackAllocatorAllocateAligned(*(void *)a1, 80 * v7, 16, 0);
    memcpy(Aligned, v6, 80 * *(unsigned int *)(a1 + 8));
    *(void *)(a1 + 16) = Aligned;
    *(_DWORD *)(a1 + 12) = v7;
    int v6 = Aligned;
    int v4 = *(_DWORD *)(a1 + 8);
  }
  unsigned int v9 = &v6[80 * v4];
  *(_OWORD *)unsigned int v9 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v11 = *(_OWORD *)(a2 + 32);
  long long v12 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v9 + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)v9 + 4) = v12;
  *((__n128 *)v9 + 1) = result;
  *((_OWORD *)v9 + 2) = v11;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

_DWORD *C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::resize(_DWORD *result, unsigned int a2, _OWORD *a3)
{
  unsigned int v3 = result[2];
  if (v3 != a2)
  {
    unsigned int v5 = result;
    if (v3 <= a2)
    {
      if (result[3] < a2)
      {
        unsigned int v7 = (const void *)*((void *)result + 2);
        unsigned int v8 = ((double)a2 * 1.5);
        Aligned = C3DStackAllocatorAllocateAligned(*(void *)result, 80 * v8, 16, 0);
        __n128 result = memcpy(Aligned, v7, 80 * v5[2]);
        *((void *)v5 + 2) = Aligned;
        v5[3] = v8;
        unsigned int v3 = v5[2];
      }
      if (v3 < a2)
      {
        uint64_t v10 = 80 * v3;
        unint64_t v11 = a2 - (unint64_t)v3;
        do
        {
          long long v12 = (_OWORD *)(*((void *)v5 + 2) + v10);
          *long long v12 = *a3;
          long long v13 = a3[1];
          long long v14 = a3[2];
          long long v15 = a3[4];
          v12[3] = a3[3];
          float32x4_t v12[4] = v15;
          v12[1] = v13;
          float32x4_t v12[2] = v14;
          v10 += 80;
          --v11;
        }
        while (v11);
      }
    }
    v5[2] = a2;
  }
  return result;
}

uint64_t C3D::FinalPass::_parametersForDrawNodesTechniquePass@<X0>(const __CFArray **this@<X0>, __C3DFXPass *a2@<X1>, uint64_t a3@<X8>)
{
  Nodes = (C3D *)C3DFXPassGetNodes((uint64_t)a2);
  if (Nodes) {
    unsigned int v8 = C3D::flattenedNodesForSelectedNodes(Nodes, this[2], *((__C3DEngineContext **)this[3] + 2), v7);
  }
  else {
    unsigned int v8 = 0;
  }
  PointOfView = C3DEngineContextGetPointOfView((uint64_t)this[2]);
  if (PointOfView && (CFDictionaryRef Camera = C3DNodeGetCamera((uint64_t)PointOfView)) != 0)
  {
    if (C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) > 0.0) {
      __int16 v11 = 16;
    }
    else {
      __int16 v11 = 0;
    }
  }
  else
  {
    __int16 v11 = 0;
  }
  uint64_t var60_low = LODWORD(a2->var60);
  if (var60_low)
  {
    long long v13 = (int *)(*(void *)&a2->var59 + 16);
    do
    {
      int v14 = *v13;
      v13 += 16;
      if (v14 == 2) {
        v11 |= 0x80u;
      }
      --var60_low;
    }
    while (var60_low);
  }
  *(void *)a3 = a2;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x2A0], 8) = C3DFXPassGetPointOfView((uint64_t)a2);
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = C3DFXPassGetRootNode((uint64_t)a2);
  *(void *)(a3 + 32) = v8;
  *(void *)(a3 + 40) = C3DFXPassGetIncludeCategoryMask((uint64_t)a2);
  *(void *)(a3 + 4_Block_object_dispose(&STACK[0x2A0], 8) = C3DFXPassGetExcludeCategoryMask((uint64_t)a2);
  *(unsigned char *)(a3 + 56) = 1;
  *(_WORD *)(a3 + 5_Block_object_dispose(&STACK[0x2A0], 8) = v11;
  *(_WORD *)(a3 + 60) = 0;
  *(unsigned char *)(a3 + 62) = 0;
  uint64_t result = C3DFXPassGetUsesSceneBackgroundColor((uint64_t)a2);
  *(unsigned char *)(a3 + 63) = result;
  *(_WORD *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 66) = 2;
  return result;
}

C3D::ScenePass *C3D::RenderGraph::createPass<C3D::ScenePass,C3D::FinalPass *,C3D::ScenePass::Parameters &,C3D::DrawNodesPass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3, const Parameters *a4)
{
  Aligned = (C3D::ScenePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5456, 16, 0);
  C3D::ScenePass::ScenePass(Aligned, (RenderGraph *)a1, *a2, a3, a4);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ScenePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::DrawNodesPass *C3D::RenderGraph::createPass<C3D::DrawNodesPass,C3D::FinalPass *,C3D::DrawNodesPass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::DrawNodesPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5360, 16, 0);
  C3D::DrawNodesPass::DrawNodesPass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::DrawNodesPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::DrawQuadPass *C3D::RenderGraph::createPass<C3D::DrawQuadPass,C3D::FinalPass *,__C3DFXPass *&>(uint64_t a1, C3D::Pass **a2, __C3DFXPass **a3)
{
  Aligned = (C3D::DrawQuadPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::DrawQuadPass::DrawQuadPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::DrawQuadPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::CustomPass *C3D::RenderGraph::createPass<C3D::CustomPass,C3D::FinalPass *,__C3DFXPass *&>(uint64_t a1, C3D::Pass **a2, __C3DFXPass **a3)
{
  Aligned = (C3D::CustomPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::CustomPass::CustomPass(Aligned, (RenderGraph *)a1, *a2, *a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::CustomPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

void C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate(uint64_t a1, int a2)
{
  if ((a2 & (a2 - 1)) != 0) {
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  *(void *)(a1 + 24) = C3DStackAllocatorAllocateAligned(*(void *)a1, (2 * (a2 + 15)), 4, 0);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = C3DStackAllocatorAllocateAligned(*(void *)a1, (8 * v3) & 0xFFFFFFF8, 8, 0);
  *(void *)(a1 + 16) = C3DStackAllocatorAllocateAligned(*(void *)a1, 24 * v3, 4, 0);
  memset(*(void **)(a1 + 8), 255, 8 * v3);
  unsigned int v5 = *(void **)(a1 + 24);

  bzero(v5, v4);
}

void C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::_allocate(uint64_t a1, int a2)
{
  if ((a2 & (a2 - 1)) != 0) {
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  *(void *)(a1 + 24) = C3DStackAllocatorAllocateAligned(*(void *)a1, (2 * (a2 + 15)), 4, 0);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = C3DStackAllocatorAllocateAligned(*(void *)a1, (8 * v3) & 0xFFFFFFF8, 8, 0);
  *(void *)(a1 + 16) = C3DStackAllocatorAllocateAligned(*(void *)a1, 80 * v3, 16, 0);
  memset(*(void **)(a1 + 8), 255, 8 * v3);
  unsigned int v5 = *(void **)(a1 + 24);

  bzero(v5, v4);
}

uint64_t C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::insert(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      int v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          uint64_t v27 = (_OWORD *)(v26 + 80 * v15);
          int v28 = (_OWORD *)(v26 + 80 * v21);
          long long v29 = v28[1];
          long long v30 = v28[2];
          long long v31 = v28[4];
          void v27[3] = v28[3];
          v27[4] = v31;
          v27[1] = v29;
          v27[2] = v30;
          *uint64_t v27 = *v28;
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      CFStringRef v37 = (_OWORD *)(*(void *)(a1 + 16) + 80 * v21);
      *CFStringRef v37 = *a3;
      long long v38 = a3[1];
      long long v39 = a3[2];
      long long v40 = a3[4];
      v37[3] = a3[3];
      v37[4] = v40;
      v37[1] = v38;
      v37[2] = v39;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v41 = *(void *)(a1 + 24);
      *(_WORD *)(v41 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v41 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  uint64_t v33 = (_OWORD *)(*(void *)(a1 + 16) + 80 * v10);
  *uint64_t v33 = *a3;
  long long v34 = a3[1];
  long long v35 = a3[2];
  long long v36 = a3[4];
  v33[3] = a3[3];
  v33[4] = v36;
  v33[1] = v34;
  v33[2] = v35;
  return result;
}

void C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::_grow(uint64_t a1)
{
  unsigned int v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  size_t v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<C3D::PassIODescriptor,C3D::StackAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 80;
      --v6;
    }
    while (v6);
  }
}

void C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_grow(uint64_t a1)
{
  unsigned int v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  size_t v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 24;
      --v6;
    }
    while (v6);
  }
}

void *std::get_temporary_buffer[abi:nn180100]<C3D::PassIODescriptor>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0x199999999999999) {
    unint64_t v1 = 0x199999999999999;
  }
  else {
    unint64_t v1 = a1;
  }
  uint64_t v2 = (const std::nothrow_t *)MEMORY[0x263F8C180];
  while (1)
  {
    uint64_t result = operator new(80 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

__n128 std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 result)
{
  if (a3 >= 2)
  {
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      if (((*((unsigned __int16 *)a2 - 7) >> 7) & 1u) > ((*(unsigned __int16 *)(a1 + 66) >> 7) & 1u))
      {
        long long v49 = *(_OWORD *)(a1 + 32);
        long long v51 = *(_OWORD *)(a1 + 48);
        long long v53 = *(_OWORD *)(a1 + 64);
        __n128 v45 = *(__n128 *)a1;
        long long v47 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)a1 = *((_OWORD *)a2 - 5);
        long long v8 = *((_OWORD *)a2 - 1);
        long long v10 = *((_OWORD *)a2 - 4);
        long long v9 = *((_OWORD *)a2 - 3);
        *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *((_OWORD *)a2 - 2);
        *(_OWORD *)(a1 + 64) = v8;
        *(_OWORD *)(a1 + 16) = v10;
        *(_OWORD *)(a1 + 32) = v9;
        *((_OWORD *)a2 - 2) = v51;
        *((_OWORD *)a2 - 1) = v53;
        uint64_t result = v45;
        *((__n128 *)a2 - 5) = v45;
        *((_OWORD *)a2 - 4) = v47;
        *((_OWORD *)a2 - 3) = v49;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v25 = a4;
      unint64_t v26 = a3 >> 1;
      uint64_t v27 = a1 + 80 * (a3 >> 1);
      unint64_t v28 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v29 = std::__stable_sort_move<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(a1, v27, v28, a4, result);
        uint64_t v30 = v25 + 80 * v26;
        result.n128_u64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(v7 + 80 * (a3 >> 1), (uint64_t)a2, a3 - (a3 >> 1), v30, v29).n128_u64[0];
        unint64_t v31 = v25 + 80 * a3;
        uint64_t v32 = v30;
        while (v32 != v31)
        {
          if (((*(unsigned __int16 *)(v32 + 66) >> 7) & 1u) <= ((*(unsigned __int16 *)(v25 + 66) >> 7) & 1u))
          {
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v25;
            uint64_t result = *(__n128 *)(v25 + 16);
            long long v35 = *(_OWORD *)(v25 + 32);
            long long v36 = *(_OWORD *)(v25 + 64);
            *(_OWORD *)(v7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v25 + 48);
            *(_OWORD *)(v7 + 64) = v36;
            *(__n128 *)(v7 + 16) = result;
            *(_OWORD *)(v7 + 32) = v35;
            v25 += 80;
          }
          else
          {
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v32;
            uint64_t result = *(__n128 *)(v32 + 16);
            long long v33 = *(_OWORD *)(v32 + 32);
            long long v34 = *(_OWORD *)(v32 + 64);
            *(_OWORD *)(v7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v32 + 48);
            *(_OWORD *)(v7 + 64) = v34;
            *(__n128 *)(v7 + 16) = result;
            *(_OWORD *)(v7 + 32) = v33;
            v32 += 80;
          }
          v7 += 80;
          if (v25 == v30)
          {
            if (v32 != v31)
            {
              uint64_t v37 = 0;
              do
              {
                uint64_t v38 = v7 + v37;
                *(_OWORD *)uint64_t v38 = *(_OWORD *)(v32 + v37);
                uint64_t result = *(__n128 *)(v32 + v37 + 16);
                long long v39 = *(_OWORD *)(v32 + v37 + 32);
                long long v40 = *(_OWORD *)(v32 + v37 + 64);
                *(_OWORD *)(v38 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v32 + v37 + 48);
                *(_OWORD *)(v38 + 64) = v40;
                *(__n128 *)(v38 + 16) = result;
                *(_OWORD *)(v38 + 32) = v39;
                v37 += 80;
              }
              while (v32 + v37 != v31);
            }
            return result;
          }
        }
        if (v25 != v30)
        {
          uint64_t v41 = 0;
          do
          {
            uint64_t v42 = v7 + v41;
            *(_OWORD *)uint64_t v42 = *(_OWORD *)(v25 + v41);
            uint64_t result = *(__n128 *)(v25 + v41 + 16);
            long long v43 = *(_OWORD *)(v25 + v41 + 32);
            long long v44 = *(_OWORD *)(v25 + v41 + 64);
            *(_OWORD *)(v42 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v25 + v41 + 48);
            *(_OWORD *)(v42 + 64) = v44;
            *(__n128 *)(v42 + 16) = result;
            *(_OWORD *)(v42 + 32) = v43;
            v41 += 80;
          }
          while (v25 + v41 != v30);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(a1, v27, v28, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(v7 + 80 * (a3 >> 1), a2, a3 - (a3 >> 1), v25, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>((char *)v7, (char *)(v7 + 80 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), (char *)v25, a5);
      }
    }
    else if ((char *)a1 != a2)
    {
      uint64_t v12 = a1 + 80;
      if ((char *)(a1 + 80) != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = a1;
        do
        {
          uint64_t v15 = v12;
          unsigned int v16 = *(unsigned __int16 *)(v14 + 146);
          unsigned int v17 = (v16 >> 7) & 1;
          if (v17 > ((*(unsigned __int16 *)(v14 + 66) >> 7) & 1u))
          {
            long long v50 = *(_OWORD *)(v15 + 32);
            long long v52 = *(_OWORD *)(v15 + 48);
            __int16 v54 = *(_WORD *)(v15 + 64);
            long long v46 = *(_OWORD *)v15;
            __n128 v48 = *(__n128 *)(v15 + 16);
            uint64_t v55 = *(void *)(v14 + 148);
            int v18 = *(_DWORD *)(v14 + 156);
            uint64_t v19 = v13;
            int v56 = v18;
            while (1)
            {
              char v20 = (_OWORD *)(a1 + v19);
              long long v21 = *(_OWORD *)(a1 + v19 + 48);
              v20[7] = *(_OWORD *)(a1 + v19 + 32);
              v20[8] = v21;
              v20[9] = *(_OWORD *)(a1 + v19 + 64);
              long long v22 = *(_OWORD *)(a1 + v19 + 16);
              v20[5] = *(_OWORD *)(a1 + v19);
              v20[6] = v22;
              if (!v19) {
                break;
              }
              v19 -= 80;
              if (v17 <= ((*((unsigned __int16 *)v20 - 7) >> 7) & 1u))
              {
                uint64_t v23 = a1 + v19 + 80;
                goto LABEL_15;
              }
            }
            uint64_t v23 = a1;
LABEL_15:
            *(_OWORD *)(v23 + 32) = v50;
            *(_OWORD *)(v23 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v52;
            *(_WORD *)(v23 + 64) = v54;
            uint64_t result = v48;
            *(_OWORD *)uint64_t v23 = v46;
            *(__n128 *)(v23 + 16) = v48;
            *(_WORD *)(v23 + 66) = v16;
            *(void *)(v23 + 6_Block_object_dispose(&STACK[0x2A0], 8) = v55;
            *(_DWORD *)(v23 + 76) = v56;
          }
          uint64_t v12 = v15 + 80;
          v13 += 80;
          uint64_t v14 = v15;
        }
        while ((char *)(v15 + 80) != a2);
      }
    }
  }
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    uint64_t v8 = a1;
    if (a3 == 2)
    {
      BOOL v11 = (__n128 *)(a2 - 80);
      if (((*(unsigned __int16 *)(a2 - 14) >> 7) & 1u) <= ((*(unsigned __int16 *)(a1 + 66) >> 7) & 1u))
      {
        *(_OWORD *)a4 = *(_OWORD *)a1;
        long long v33 = *(_OWORD *)(a1 + 16);
        long long v34 = *(_OWORD *)(a1 + 32);
        long long v35 = *(_OWORD *)(a1 + 64);
        *(_OWORD *)(a4 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a1 + 48);
        *(_OWORD *)(a4 + 64) = v35;
        *(_OWORD *)(a4 + 16) = v33;
        *(_OWORD *)(a4 + 32) = v34;
        long long v36 = *(_OWORD *)(a2 - 16);
        long long v38 = *(_OWORD *)(a2 - 64);
        long long v37 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a4 + 12_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a4 + 144) = v36;
        *(_OWORD *)(a4 + 96) = v38;
        *(_OWORD *)(a4 + 112) = v37;
        uint64_t result = *v11;
      }
      else
      {
        *(__n128 *)a4 = *v11;
        long long v12 = *(_OWORD *)(a2 - 64);
        long long v13 = *(_OWORD *)(a2 - 48);
        long long v14 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a4 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a4 + 64) = v14;
        *(_OWORD *)(a4 + 16) = v12;
        *(_OWORD *)(a4 + 32) = v13;
        long long v15 = *(_OWORD *)(a1 + 64);
        long long v17 = *(_OWORD *)(a1 + 16);
        long long v16 = *(_OWORD *)(a1 + 32);
        *(_OWORD *)(a4 + 12_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a1 + 48);
        *(_OWORD *)(a4 + 144) = v15;
        *(_OWORD *)(a4 + 96) = v17;
        *(_OWORD *)(a4 + 112) = v16;
        uint64_t result = *(__n128 *)a1;
      }
      *(__n128 *)(a4 + 80) = result;
    }
    else if (a3 == 1)
    {
      *(_OWORD *)a4 = *(_OWORD *)a1;
      uint64_t result = *(__n128 *)(a1 + 16);
      long long v9 = *(_OWORD *)(a1 + 32);
      long long v10 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)(a4 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a1 + 48);
      *(_OWORD *)(a4 + 64) = v10;
      *(__n128 *)(a4 + 16) = result;
      *(_OWORD *)(a4 + 32) = v9;
    }
    else if ((uint64_t)a3 > 8)
    {
      uint64_t v39 = a1 + 80 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(a1, v39, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(v8 + 80 * (a3 >> 1), a2, a3 - (a3 >> 1), v5 + 80 * (a3 >> 1), a3 - (a3 >> 1));
      uint64_t v40 = v8 + 80 * (a3 >> 1);
      while (v40 != a2)
      {
        if (((*(unsigned __int16 *)(v40 + 66) >> 7) & 1u) <= ((*(unsigned __int16 *)(v8 + 66) >> 7) & 1u))
        {
          *(_OWORD *)uint64_t v5 = *(_OWORD *)v8;
          uint64_t result = *(__n128 *)(v8 + 16);
          long long v43 = *(_OWORD *)(v8 + 32);
          long long v44 = *(_OWORD *)(v8 + 64);
          *(_OWORD *)(v5 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v8 + 48);
          *(_OWORD *)(v5 + 64) = v44;
          *(__n128 *)(v5 + 16) = result;
          *(_OWORD *)(v5 + 32) = v43;
          v8 += 80;
        }
        else
        {
          *(_OWORD *)uint64_t v5 = *(_OWORD *)v40;
          uint64_t result = *(__n128 *)(v40 + 16);
          long long v41 = *(_OWORD *)(v40 + 32);
          long long v42 = *(_OWORD *)(v40 + 64);
          *(_OWORD *)(v5 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v40 + 48);
          *(_OWORD *)(v5 + 64) = v42;
          *(__n128 *)(v5 + 16) = result;
          *(_OWORD *)(v5 + 32) = v41;
          v40 += 80;
        }
        v5 += 80;
        if (v8 == v39)
        {
          if (v40 != a2)
          {
            uint64_t v45 = 0;
            do
            {
              uint64_t v46 = v5 + v45;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)(v40 + v45);
              uint64_t result = *(__n128 *)(v40 + v45 + 16);
              long long v47 = *(_OWORD *)(v40 + v45 + 32);
              long long v48 = *(_OWORD *)(v40 + v45 + 64);
              *(_OWORD *)(v46 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v40 + v45 + 48);
              *(_OWORD *)(v46 + 64) = v48;
              *(__n128 *)(v46 + 16) = result;
              *(_OWORD *)(v46 + 32) = v47;
              v45 += 80;
            }
            while (v40 + v45 != a2);
          }
          return result;
        }
      }
      if (v8 != v39)
      {
        uint64_t v49 = 0;
        do
        {
          uint64_t v50 = v5 + v49;
          *(_OWORD *)uint64_t v50 = *(_OWORD *)(v8 + v49);
          uint64_t result = *(__n128 *)(v8 + v49 + 16);
          long long v51 = *(_OWORD *)(v8 + v49 + 32);
          long long v52 = *(_OWORD *)(v8 + v49 + 64);
          *(_OWORD *)(v50 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(v8 + v49 + 48);
          *(_OWORD *)(v50 + 64) = v52;
          *(__n128 *)(v50 + 16) = result;
          *(_OWORD *)(v50 + 32) = v51;
          v49 += 80;
        }
        while (v8 + v49 != v39);
      }
    }
    else if (a1 != a2)
    {
      *(_OWORD *)a4 = *(_OWORD *)a1;
      uint64_t result = *(__n128 *)(a1 + 16);
      long long v18 = *(_OWORD *)(a1 + 32);
      long long v19 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)(a4 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_OWORD *)(a1 + 48);
      *(_OWORD *)(a4 + 64) = v19;
      *(__n128 *)(a4 + 16) = result;
      *(_OWORD *)(a4 + 32) = v18;
      uint64_t v20 = a1 + 80;
      if (a1 + 80 != a2)
      {
        uint64_t v21 = 0;
        long long v22 = (_OWORD *)a4;
        do
        {
          uint64_t v23 = v8;
          unsigned int v24 = v22;
          uint64_t v8 = v20;
          v22 += 5;
          uint64_t v25 = v22;
          if (((*(unsigned __int16 *)(v23 + 146) >> 7) & 1u) > ((*((unsigned __int16 *)v24 + 33) >> 7) & 1u))
          {
            long long v26 = v24[3];
            v22[2] = v24[2];
            v22[3] = v26;
            v22[4] = v24[4];
            long long v27 = v24[1];
            *long long v22 = *v24;
            v22[1] = v27;
            uint64_t v25 = (_OWORD *)a4;
            if (v24 != (_OWORD *)a4)
            {
              uint64_t v28 = v21;
              while (1)
              {
                uint64_t v25 = (_OWORD *)(a4 + v28);
                if (((*(unsigned __int16 *)(v23 + 146) >> 7) & 1u) <= ((*(unsigned __int16 *)(a4 + v28 - 14) >> 7) & 1u)) {
                  break;
                }
                long long v29 = *(v25 - 2);
                v25[2] = *(v25 - 3);
                v25[3] = v29;
                v25[4] = *(v25 - 1);
                long long v30 = *(v25 - 4);
                *uint64_t v25 = *(v25 - 5);
                v25[1] = v30;
                v28 -= 80;
                if (!v28)
                {
                  uint64_t v25 = (_OWORD *)a4;
                  break;
                }
              }
            }
          }
          *uint64_t v25 = *(_OWORD *)v8;
          uint64_t result = *(__n128 *)(v8 + 16);
          long long v31 = *(_OWORD *)(v8 + 32);
          long long v32 = *(_OWORD *)(v8 + 64);
          v25[3] = *(_OWORD *)(v8 + 48);
          v25[4] = v32;
          v25[1] = result;
          v25[2] = v31;
          uint64_t v20 = v8 + 80;
          v21 += 80;
        }
        while (v8 + 80 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    while (v8 > a7 && a4 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v10 = 0;
      uint64_t v11 = -a4;
      while (1)
      {
        long long v12 = &result[v10];
        if (((*((unsigned __int16 *)a2 + 33) >> 7) & 1u) > ((*(unsigned __int16 *)&result[v10 + 66] >> 7) & 1u)) {
          break;
        }
        v10 += 80;
        if (__CFADD__(v11++, 1)) {
          return result;
        }
      }
      uint64_t v14 = -v11;
      uint64_t v74 = a3;
      unint64_t v75 = a6;
      uint64_t v76 = a7;
      if (-v11 >= v8)
      {
        if (v11 == -1)
        {
          char v65 = &result[v10];
          long long v77 = *(_OWORD *)v65;
          long long v80 = *((_OWORD *)v65 + 3);
          long long v81 = *((_OWORD *)v65 + 4);
          long long v78 = *((_OWORD *)v65 + 1);
          long long v79 = *((_OWORD *)v65 + 2);
          long long v66 = *((_OWORD *)a2 + 4);
          long long v68 = *((_OWORD *)a2 + 1);
          long long v67 = *((_OWORD *)a2 + 2);
          *((_OWORD *)v65 + 3) = *((_OWORD *)a2 + 3);
          *((_OWORD *)v65 + 4) = v66;
          *((_OWORD *)v65 + 1) = v68;
          *((_OWORD *)v65 + 2) = v67;
          *(_OWORD *)char v65 = *(_OWORD *)a2;
          *((_OWORD *)a2 + 3) = v80;
          *((_OWORD *)a2 + 4) = v81;
          *((_OWORD *)a2 + 1) = v78;
          *((_OWORD *)a2 + 2) = v79;
          *(_OWORD *)a2 = v77;
          return result;
        }
        if (v11 > 0) {
          uint64_t v14 = 1 - v11;
        }
        uint64_t v24 = v14 >> 1;
        if (a3 == a2)
        {
          long long v26 = a3;
        }
        else
        {
          unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((a3 - a2) >> 4);
          long long v26 = a2;
          do
          {
            unint64_t v27 = v25 >> 1;
            uint64_t v28 = &v26[80 * (v25 >> 1)];
            unsigned int v29 = (*((unsigned __int16 *)v28 + 33) >> 7) & 1;
            long long v30 = v28 + 80;
            v25 += ~(v25 >> 1);
            if (v29 > ((*(unsigned __int16 *)&result[80 * v24 + 66 + v10] >> 7) & 1u)) {
              long long v26 = v30;
            }
            else {
              unint64_t v25 = v27;
            }
          }
          while (v25);
        }
        long long v19 = &result[80 * v24 + v10];
        uint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((v26 - a2) >> 4);
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v15 = v8;
        }
        else {
          uint64_t v15 = v8 + 1;
        }
        uint64_t v16 = v15 >> 1;
        if (v12 == a2)
        {
          long long v17 = &result[v10];
          long long v19 = a2;
        }
        else
        {
          long long v17 = &result[v10];
          unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - result - v10) >> 4);
          long long v19 = v12;
          do
          {
            unint64_t v20 = v18 >> 1;
            uint64_t v21 = &v19[80 * (v18 >> 1)];
            unsigned int v22 = (*((unsigned __int16 *)v21 + 33) >> 7) & 1;
            uint64_t v23 = v21 + 80;
            v18 += ~(v18 >> 1);
            if (((*(unsigned __int16 *)&a2[80 * v16 + 66] >> 7) & 1u) > v22) {
              unint64_t v18 = v20;
            }
            else {
              long long v19 = v23;
            }
          }
          while (v18);
        }
        long long v26 = &a2[80 * v16];
        uint64_t v24 = 0xCCCCCCCCCCCCCCCDLL * ((v19 - v17) >> 4);
      }
      a4 = -(v24 + v11);
      uint64_t v31 = v8 - v16;
      uint64_t v32 = v16;
      long long v33 = std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,C3D::PassIODescriptor *,C3D::PassIODescriptor *>(v19, a2, v26);
      uint64_t v34 = v32;
      long long v35 = v33;
      if (v24 + v34 >= v8 - (v24 + v34) - v11)
      {
        uint64_t v37 = -(v24 + v11);
        uint64_t v38 = v34;
        std::__inplace_merge<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(v33, v26, v74, v37, v31, v75, v76);
        long long v26 = v19;
        a6 = v75;
        uint64_t v31 = v38;
        a4 = v24;
        a3 = v35;
      }
      else
      {
        long long v36 = v19;
        a6 = v75;
        std::__inplace_merge<std::_ClassicAlgPolicy,C3D::FinalPass::_setupTechniquePassCommonData(C3D::Pass *,__C3DFXPass *,C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator> &,BOOL &)::$_1 &,C3D::PassIODescriptor *>(v12, v36, v33, v24, v34, v75, v76);
        long long v12 = v35;
        a3 = v74;
      }
      uint64_t v8 = v31;
      uint64_t result = v12;
      a2 = v26;
      a7 = v76;
      if (!v31) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (result != a2)
      {
        unint64_t v53 = 0;
        do
        {
          __int16 v54 = &a6[v53];
          *(_OWORD *)__int16 v54 = *(_OWORD *)&result[v53];
          long long v55 = *(_OWORD *)&result[v53 + 16];
          long long v56 = *(_OWORD *)&result[v53 + 32];
          long long v57 = *(_OWORD *)&result[v53 + 64];
          *((_OWORD *)v54 + 3) = *(_OWORD *)&result[v53 + 48];
          *((_OWORD *)v54 + 4) = v57;
          *((_OWORD *)v54 + 1) = v55;
          *((_OWORD *)v54 + 2) = v56;
          v53 += 80;
        }
        while (&result[v53] != a2);
        if (v53)
        {
          int v58 = a6;
          while (a2 != a3)
          {
            if (((*((unsigned __int16 *)a2 + 33) >> 7) & 1u) <= ((*((unsigned __int16 *)v58 + 33) >> 7) & 1u))
            {
              *(_OWORD *)uint64_t result = *(_OWORD *)v58;
              long long v62 = *((_OWORD *)v58 + 1);
              long long v63 = *((_OWORD *)v58 + 2);
              long long v64 = *((_OWORD *)v58 + 4);
              *((_OWORD *)result + 3) = *((_OWORD *)v58 + 3);
              *((_OWORD *)result + 4) = v64;
              *((_OWORD *)result + 1) = v62;
              *((_OWORD *)result + 2) = v63;
              v58 += 80;
            }
            else
            {
              *(_OWORD *)uint64_t result = *(_OWORD *)a2;
              long long v59 = *((_OWORD *)a2 + 1);
              long long v60 = *((_OWORD *)a2 + 2);
              long long v61 = *((_OWORD *)a2 + 4);
              *((_OWORD *)result + 3) = *((_OWORD *)a2 + 3);
              *((_OWORD *)result + 4) = v61;
              *((_OWORD *)result + 1) = v59;
              *((_OWORD *)result + 2) = v60;
              a2 += 80;
            }
            result += 80;
            if (&a6[v53] == v58) {
              return result;
            }
          }
          return (char *)memmove(result, v58, a6 - v58 + v53);
        }
      }
    }
    else if (a2 != a3)
    {
      unint64_t v39 = 0;
      do
      {
        uint64_t v40 = &a6[v39];
        *(_OWORD *)uint64_t v40 = *(_OWORD *)&a2[v39];
        long long v41 = *(_OWORD *)&a2[v39 + 16];
        long long v42 = *(_OWORD *)&a2[v39 + 32];
        long long v43 = *(_OWORD *)&a2[v39 + 64];
        *((_OWORD *)v40 + 3) = *(_OWORD *)&a2[v39 + 48];
        *((_OWORD *)v40 + 4) = v43;
        *((_OWORD *)v40 + 1) = v41;
        *((_OWORD *)v40 + 2) = v42;
        v39 += 80;
      }
      while (&a2[v39] != a3);
      if (v39)
      {
        long long v44 = &a6[v39];
        uint64_t v45 = a3 - 80;
        while (a2 != result)
        {
          unsigned int v46 = (*((unsigned __int16 *)v44 - 7) >> 7) & 1;
          unsigned int v47 = (*((unsigned __int16 *)a2 - 7) >> 7) & 1;
          BOOL v48 = v46 > v47;
          if (v46 <= v47) {
            uint64_t v49 = v44 - 80;
          }
          else {
            uint64_t v49 = a2 - 80;
          }
          if (v48) {
            a2 -= 80;
          }
          else {
            v44 -= 80;
          }
          long long v50 = *((_OWORD *)v49 + 4);
          long long v52 = *((_OWORD *)v49 + 1);
          long long v51 = *((_OWORD *)v49 + 2);
          *((_OWORD *)v45 + 3) = *((_OWORD *)v49 + 3);
          *((_OWORD *)v45 + 4) = v50;
          *((_OWORD *)v45 + 1) = v52;
          *((_OWORD *)v45 + 2) = v51;
          *(_OWORD *)uint64_t v45 = *(_OWORD *)v49;
          v45 -= 80;
          if (v44 == a6) {
            return result;
          }
        }
        uint64_t v69 = 0;
        do
        {
          int v70 = &v45[v69];
          *(_OWORD *)int v70 = *(_OWORD *)&v44[v69 - 80];
          long long v71 = *(_OWORD *)&v44[v69 - 64];
          long long v72 = *(_OWORD *)&v44[v69 - 48];
          long long v73 = *(_OWORD *)&v44[v69 - 16];
          *((_OWORD *)v70 + 3) = *(_OWORD *)&v44[v69 - 32];
          *((_OWORD *)v70 + 4) = v73;
          *((_OWORD *)v70 + 1) = v71;
          *((_OWORD *)v70 + 2) = v72;
          v69 -= 80;
        }
        while (&v44[v69] != a6);
      }
    }
  }
  return result;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,C3D::PassIODescriptor *,C3D::PassIODescriptor *>(char *__src, char *a2, char *a3)
{
  BOOL v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 80 == a2)
    {
      long long v13 = *((_OWORD *)__src + 2);
      long long v15 = *((_OWORD *)__src + 3);
      long long v17 = *((_OWORD *)__src + 4);
      long long v9 = *(_OWORD *)__src;
      long long v11 = *((_OWORD *)__src + 1);
      int64_t v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      BOOL v4 = &__src[v6];
      *((_OWORD *)v4 + 2) = v13;
      *((_OWORD *)v4 + 3) = v15;
      *((_OWORD *)v4 + 4) = v17;
      *(_OWORD *)BOOL v4 = v9;
      *((_OWORD *)v4 + 1) = v11;
    }
    else if (a2 + 80 == a3)
    {
      BOOL v4 = __src + 80;
      long long v14 = *((_OWORD *)a3 - 3);
      long long v16 = *((_OWORD *)a3 - 2);
      long long v18 = *((_OWORD *)a3 - 1);
      long long v10 = *((_OWORD *)a3 - 5);
      long long v12 = *((_OWORD *)a3 - 4);
      size_t v7 = a3 - 80 - __src;
      if (a3 - 80 != __src) {
        memmove(__src + 80, __src, v7);
      }
      *((_OWORD *)__src + 2) = v14;
      *((_OWORD *)__src + 3) = v16;
      *((_OWORD *)__src + 4) = v18;
      *(_OWORD *)__src = v10;
      *((_OWORD *)__src + 1) = v12;
    }
    else
    {
      return (char *)std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,C3D::PassIODescriptor *>(__src, a2, a3);
    }
  }
  return v4;
}

_OWORD *std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,C3D::PassIODescriptor *>(_OWORD *a1, _OWORD *a2, _OWORD *a3)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * (a2 - a1);
  if (v3 == 0xCCCCCCCCCCCCCCCDLL * (a3 - a2))
  {
    if (a1 != a2 && a2 != a3)
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = &a2[v4];
        int64_t v6 = &a1[v4];
        long long v33 = a1[v4 + 2];
        long long v35 = a1[v4 + 3];
        long long v37 = a1[v4 + 4];
        long long v30 = a1[v4];
        long long v31 = a1[v4 + 1];
        _OWORD *v6 = a2[v4];
        long long v7 = a2[v4 + 4];
        long long v9 = a2[v4 + 1];
        long long v8 = a2[v4 + 2];
        v6[3] = a2[v4 + 3];
        v6[4] = v7;
        v6[1] = v9;
        void v6[2] = v8;
        v5[3] = v35;
        v5[4] = v37;
        *uint64_t v5 = v30;
        v5[1] = v31;
        v5[2] = v33;
        if (&a1[v4 + 5] == a2) {
          break;
        }
        v4 += 5;
      }
      while (v5 + 5 != a3);
    }
  }
  else
  {
    uint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (a3 - a2);
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * (a2 - a1);
    do
    {
      uint64_t v12 = v11;
      unint64_t v11 = v10;
      uint64_t v10 = v12 % v10;
    }
    while (v10);
    if (v11)
    {
      long long v13 = &a1[5 * v11];
      do
      {
        long long v14 = *(v13 - 3);
        long long v15 = *(v13 - 2);
        long long v16 = *(v13 - 1);
        long long v18 = *(v13 - 5);
        long long v17 = *(v13 - 4);
        v13 -= 5;
        long long v34 = v14;
        long long v36 = v15;
        long long v32 = v17;
        long long v19 = &v13[a2 - a1];
        unint64_t v20 = v13;
        do
        {
          uint64_t v21 = v20;
          unint64_t v20 = v19;
          *uint64_t v21 = *v19;
          long long v22 = v19[1];
          long long v23 = v19[2];
          long long v24 = v19[4];
          v21[3] = v19[3];
          v21[4] = v24;
          v21[1] = v22;
          v21[2] = v23;
          unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * (a3 - v19);
          BOOL v26 = __OFSUB__(v3, v25);
          uint64_t v28 = v3 - v25;
          char v27 = (v28 < 0) ^ v26;
          long long v19 = &a1[5 * v28];
          if (v27) {
            long long v19 = &v20[a2 - a1];
          }
        }
        while (v19 != v13);
        *unint64_t v20 = v18;
        v20[3] = v36;
        v20[4] = v16;
        v20[1] = v32;
        v20[2] = v34;
      }
      while (v13 != a1);
    }
    return &a1[a3 - a2];
  }
  return a2;
}

uint64_t C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 8);
      int v7 = 136315906;
      long long v8 = "i < size()";
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v6;
      _os_log_fault_impl(&dword_20B249000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(void *)(a1 + 16) + 80 * a2;
}

unsigned char *OUTLINED_FUNCTION_1_1(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

void OUTLINED_FUNCTION_2_0(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

uint64_t __C3DAnimationClusterKeyframesGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DAnimationClusterKeyframesGetTypeID_typeID = result;
  return result;
}

uint64_t C3DAnimationClusterKeyframesCreate()
{
  if (C3DAnimationClusterKeyframesGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterKeyframesGetTypeID_onceToken, &__block_literal_global_15);
  }
  CFTypeID v0 = C3DAnimationClusterKeyframesGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x40uLL);
}

uint64_t C3DAnimationClusterCreate()
{
  if (C3DAnimationClusterGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterGetTypeID_onceToken, &__block_literal_global_3);
  }
  CFTypeID v0 = C3DAnimationClusterGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0xA0uLL);
}

uint64_t C3DKeyframeAnimationCreateWithClusteredKeyframe(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = C3DKeyframedAnimationCreate();
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(__int16 *)(*(void *)(a1 + 32) + 2 * a2);
  char Semantic = C3DKeyFrameInterpolatorGetSemantic(*(double (**)(float32x4_t *, float32x4_t *, double, double, double, double, double, double, float32x4_t, uint64_t, uint64_t, uint64_t, int, float32x4_t *))(*(void *)(a1 + 48) + 8 * a2));
  long long v8 = (const void *)C3DKeyframeControllerCreateWithCapacity(v5, v6, Semantic, 0, 0, 0, 0);
  __int16 v9 = *(char **)(a1 + 64);
  if (a2 >= 1)
  {
    uint64_t v10 = *(char **)(a1 + 40);
    uint64_t v11 = a2;
    do
    {
      char v12 = *v10++;
      v9 += (v12 + 15) & 0xF0;
      --v11;
    }
    while (v11);
  }
  if (*(_DWORD *)(a1 + 16))
  {
    unint64_t v13 = 0;
    do
    {
      C3DKeyframeControllerSetKeyframeAtIndex((uint64_t)v8, v13, v9, 0, 0, 0, 0, *(float *)(*(void *)(a1 + 56) + 4 * v13), 0.0, 0.0, 0.0);
      v9 += *(unsigned int *)(a1 + 24);
      ++v13;
    }
    while (v13 < *(unsigned int *)(a1 + 16));
  }
  C3DAnimationSetKeyPath(v4, *(CFTypeRef *)(*(void *)(a1 + 72) + 8 * a2));
  C3DKeyframedAnimationSetController(v4, v8);
  CFRelease(v8);
  return v4;
}

__n128 *C3DAnimationGroupCreateWithAnimationCluster(uint64_t a1)
{
  uint64_t v2 = (__n128 *)C3DAnimationGroupCreate();
  C3DAnimationCopySettingsToAnimation(a1, v2);
  ID = (const void *)C3DEntityGetID(a1);
  C3DEntitySetID((uint64_t)v2, ID);
  float Duration = C3DAnimationGetDuration(a1);
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 168) + 20);
  if (v5)
  {
    float v6 = Duration;
    for (uint64_t i = 0; i != v5; ++i)
    {
      long long v8 = (void *)C3DKeyframeAnimationCreateWithClusteredKeyframe(*(void *)(a1 + 168), i);
      C3DAnimationSetDuration((uint64_t)v8, v6);
      C3DAnimationGroupAddAnimation((uint64_t)v2, v8);
      CFRelease(v8);
    }
  }
  return v2;
}

__n128 *C3DAnimationClusterCreateWithAnimationGroup(uint64_t a1)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  if (C3DWasLinkedBeforeMajorOSYear2017()) {
    return 0;
  }
  if (!_checkCompatibility(a1))
  {
    C3DAnimationGroupGetAnimationCount(a1);
    return 0;
  }
  unsigned int v2 = _countAnimation(a1);
  if (v2 < 3) {
    return 0;
  }
  unsigned int v3 = v2;
  if (C3DAnimationClusterGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterGetTypeID_onceToken, &__block_literal_global_3);
  }
  uint64_t Instance = (__n128 *)C3DTypeCreateInstance_(C3DAnimationClusterGetTypeID_typeID, 0xA0uLL);
  ID = (const void *)C3DEntityGetID(a1);
  C3DEntitySetID((uint64_t)Instance, ID);
  Instance[10].n128_u64[1] = C3DAnimationClusterKeyframesCreate();
  C3DAnimationCommonInit((uint64_t)Instance);
  unint64_t v6 = Instance[10].n128_u64[1];
  *(_DWORD *)(v6 + 20) = v3;
  uint64_t v7 = v3;
  *(void *)(v6 + 32) = malloc_type_malloc(2 * v3, 0x1000040BDFB0063uLL);
  *(void *)(v6 + 40) = malloc_type_malloc(v3, 0x100004077774924uLL);
  unsigned int v64 = v3;
  *(void *)(v6 + 4_Block_object_dispose(&STACK[0x2A0], 8) = malloc_type_malloc(8 * v3, 0x80040B8603338uLL);
  *(void *)(v6 + 72) = malloc_type_malloc(8 * v3, 0x6004044C4A2DFuLL);
  long long v8 = (uint64_t *)malloc_type_malloc(8 * *(unsigned int *)(v6 + 20), 0x2004093837F09uLL);
  unint64_t v66 = 0;
  _getAnimations(a1, (uint64_t)v8, (uint64_t *)&v66);
  uint64_t v9 = 0;
  for (uint64_t i = 0; i != v7; ++i)
  {
    uint64_t v11 = v8[i];
    *(void *)(*(void *)(v6 + 72) + 8 * i) = C3DAnimationGetKeyPath(v11);
    CFRetain(*(CFTypeRef *)(*(void *)(v6 + 72) + 8 * i));
    uint64_t v12 = *(void *)(v11 + 168);
    *(_WORD *)(*(void *)(v6 + 32) + 2 * i) = *(_WORD *)(v12 + 28);
    *(unsigned char *)(*(void *)(v6 + 40) + i) = *(unsigned char *)(v12 + 30);
    *(void *)(*(void *)(v6 + 48) + 8 * i) = *(void *)(*(void *)(v11 + 168) + 32);
    v9 += (*(unsigned char *)(*(void *)(v6 + 40) + i) + 15) & 0xF0;
  }
  *(_DWORD *)(v6 + 24) = v9;
  float Duration = C3DAnimationGetDuration(a1);
  double v14 = Duration;
  uint64_t v65 = a1;
  if (Duration < 0.0)
  {
    unint64_t v66 = v7;
LABEL_24:
    long long v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DAnimationClusterCreateWithAnimationGroup_cold_4(v24, v25, v26, v27, v28, v29, v30, v31);
    }
    unsigned int v16 = 0;
    char v23 = 1;
    goto LABEL_27;
  }
  unsigned int v16 = 0;
  double v17 = 0.0;
  do
  {
    uint64_t v18 = v7;
    long long v19 = v8;
    double v20 = Duration;
    do
    {
      uint64_t v21 = *v19++;
      _getNextKeyTime(v21, v17, v14);
      if (v22 < v20) {
        double v20 = v22;
      }
      --v18;
    }
    while (v18);
    if (v20 >= v17 + 0.00833333333) {
      double v17 = v20;
    }
    else {
      double v17 = v17 + 0.00833333333;
    }
    ++v16;
  }
  while (v17 <= v14);
  unint64_t v66 = v7;
  if (!v16) {
    goto LABEL_24;
  }
  char v23 = 0;
LABEL_27:
  *(_DWORD *)(v6 + 16) = v16;
  unint64_t v32 = v16;
  *(void *)(v6 + 56) = malloc_type_malloc(4 * v16, 0x100004052888210uLL);
  if (Duration >= 0.0)
  {
    uint64_t v33 = 0;
    double v45 = 0.0;
    do
    {
      double v46 = v45;
      uint64_t v47 = v7;
      BOOL v48 = v8;
      double v49 = Duration;
      do
      {
        uint64_t v50 = *v48++;
        _getNextKeyTime(v50, v46, v14);
        if (v51 < v49) {
          double v49 = v51;
        }
        --v47;
      }
      while (v47);
      double v45 = v46 + 0.00833333333;
      if (v49 >= v46 + 0.00833333333) {
        double v45 = v49;
      }
      float v52 = v46;
      *(float *)(*(void *)(v6 + 56) + 4 * v33++) = v52;
    }
    while (v45 <= v14);
  }
  else
  {
    LODWORD(v33) = 0;
  }
  if (v33 != v32)
  {
    long long v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      C3DAnimationClusterCreateWithAnimationGroup_cold_2(v34, v35, v36, v37, v38, v39, v40, v41);
    }
  }
  long long v42 = (char *)malloc_type_malloc(v9 * v32, 0x2528734CuLL);
  uint64_t v43 = (uint64_t)v42;
  *(void *)(v6 + 64) = v42;
  unint64_t v66 = 0;
  if (v23)
  {
    long long v44 = v42;
  }
  else
  {
    unint64_t v53 = 0;
    do
    {
      uint64_t v54 = 0;
      double v55 = *(float *)(*(void *)(v6 + 56) + 4 * v53);
      do
      {
        C3DKeyframeControllerEvaluateAtTime(*(void *)(v8[v54] + 168), 0, 0, v43, v55);
        v43 += (*(unsigned char *)(*(void *)(v6 + 40) + v54++) + 15) & 0xF0;
      }
      while (v64 != v54);
      unint64_t v53 = v66 + 1;
      unint64_t v66 = v53;
    }
    while (v53 < v32);
    long long v44 = *(char **)(v6 + 64);
  }
  if ((char *)v43 != &v44[v9 * v32])
  {
    long long v56 = scn_default_log();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
      C3DAnimationClusterCreateWithAnimationGroup_cold_1(v56, v57, v58, v59, v60, v61, v62, v63);
    }
  }
  free(v8);
  Instance[4].n128_f32[2] = Duration;
  C3DAnimationCopySettingsToAnimation(v65, Instance);
  return Instance;
}

BOOL _checkCompatibility(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 84) & 6) != 0) {
    return 0;
  }
  Animationuint64_t Count = C3DAnimationGroupGetAnimationCount(a1);
  if (C3DAnimationGetDuration(a1) == 0.0) {
    return 0;
  }
  if (AnimationCount < 1) {
    return 1;
  }
  AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex(a1, 0);
  if ((AnimationAtIndex[42] & 6) != 0)
  {
    return 0;
  }
  else
  {
    unint64_t v6 = AnimationAtIndex;
    BOOL v3 = 0;
    CFIndex v7 = 1;
    while (C3DAnimationNodeGetPauseTime((uint64_t)v6) == 0.0
         && C3DAnimationGetTimeOffset((uint64_t)v6) == 0.0
         && C3DAnimationGetDuration((uint64_t)v6) != 0.0)
    {
      if (C3DAnimationIsGroup(v6))
      {
        if ((_checkCompatibility(v6) & 1) == 0) {
          return v3;
        }
      }
      else
      {
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 != C3DKeyframedAnimationGetTypeID()) {
          return v3;
        }
        uint64_t Controller = C3DKeyframedAnimationGetController((uint64_t)v6);
        if (C3DKeyframeControllerHasTCB(Controller)
          || C3DKeyframeControllerGetDefaultInterpolationMode(Controller)
          || C3DKeyframeControllerGetCalculationMode(Controller)
          || C3DKeyframeControllerHasInterpolationModesPerKey(Controller)
          || C3DKeyframeControllerHasTimingFunctions(Controller)
          || *(void *)(Controller + 96))
        {
          return v3;
        }
      }
      BOOL v3 = v7 >= AnimationCount;
      if (AnimationCount != v7)
      {
        unint64_t v6 = C3DAnimationGroupGetAnimationAtIndex(a1, v7++);
        if ((v6[42] & 6) == 0) {
          continue;
        }
      }
      return v3;
    }
  }
  return v3;
}

uint64_t _countAnimation(uint64_t a1)
{
  Animationuint64_t Count = C3DAnimationGroupGetAnimationCount(a1);
  if (AnimationCount < 1) {
    return 0;
  }
  CFIndex v3 = AnimationCount;
  CFIndex v4 = 0;
  LODWORD(v5) = 0;
  do
  {
    AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex(a1, v4);
    if (C3DAnimationIsGroup(AnimationAtIndex)) {
      int v7 = _countAnimation(AnimationAtIndex);
    }
    else {
      int v7 = 1;
    }
    uint64_t v5 = (v7 + v5);
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

void _getAnimations(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&v14[5] = *MEMORY[0x263EF8340];
  Animationuint64_t Count = C3DAnimationGroupGetAnimationCount(a1);
  if (AnimationCount >= 1)
  {
    CFIndex v7 = AnimationCount;
    for (CFIndex i = 0; i != v7; ++i)
    {
      AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex(a1, i);
      if (C3DAnimationIsGroup(AnimationAtIndex))
      {
        _getAnimations(AnimationAtIndex, a2, a3);
      }
      else
      {
        CFTypeID v10 = CFGetTypeID(AnimationAtIndex);
        if (v10 != C3DKeyframedAnimationGetTypeID())
        {
          uint64_t v11 = scn_default_log();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
            _getAnimations_cold_1(v13, v14, v11);
          }
        }
        uint64_t v12 = *a3;
        *(void *)(a2 + 8 * *a3) = AnimationAtIndex;
        *a3 = v12 + 1;
      }
    }
  }
}

void _getNextKeyTime(uint64_t a1, double a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 168);
  double v4 = a2 / a3 * *(double *)(v3 + 16);
  float v5 = v4 + 0.00001;
  float v16 = v5;
  unsigned int v6 = C3DPreviousKeyFrameIndexForTime(*(float **)(v3 + 40), *(_DWORD *)(v3 + 24), &v16);
  if (v6 < *(_DWORD *)(v3 + 24) - 1)
  {
    float v7 = v4;
    if (*(float *)(*(void *)(v3 + 40) + 4 * (v6 + 1)) < v7)
    {
      CFTypeID v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        _getNextKeyTime_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
  }
}

CFTypeRef C3DAnimationClusterCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (double v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DAnimationClusterCopy_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DAnimationClusterCopy_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFTypeRef result = *(CFTypeRef *)(a1 + 168);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a2 + 16_Block_object_dispose(&STACK[0x2A0], 8) = result;
  return result;
}

__CFArray *C3DAnimationClusterCopyKeyPaths(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 168);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(v1 + 20);
  if (!v2) {
    return 0;
  }
  Mutable = CFArrayCreateMutable(0, *(unsigned int *)(v1 + 20), MEMORY[0x263EFFF70]);
  uint64_t v5 = 0;
  uint64_t v6 = 8 * v2;
  do
  {
    CFArrayRef v7 = C3DCreatePathFromComponents(*(const __CFArray **)(*(void *)(*(void *)(a1 + 168) + 72) + v5));
    if (v7)
    {
      CFArrayRef v8 = v7;
      CFArrayAppendValue(Mutable, v7);
      CFRelease(v8);
    }
    v5 += 8;
  }
  while (v6 != v5);
  return Mutable;
}

void _C3DAnimationClusterKeyframesCFFinalize(uint64_t a1)
{
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  unint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      double v4 = *(const void **)(*(void *)(a1 + 72) + 8 * i);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(*(void *)(a1 + 72) + 8 * i) = 0;
        unint64_t v2 = *(unsigned int *)(a1 + 20);
      }
    }
  }
  uint64_t v5 = *(void **)(a1 + 72);

  free(v5);
}

CFStringRef _C3DAnimationClusterKeyframesCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationClusterKeyframes %p>", a1);
}

CFStringRef _C3DAnimationClusterKeyframesCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationClusterKeyframes %p>", a1);
}

void _C3DAnimationClusterCFFinalize(void *a1)
{
  _C3DAnimationCFFinalize(a1);
  CFAllocatorRef v2 = (const void *)a1[21];
  if (v2)
  {
    CFRelease(v2);
    a1[21] = 0;
  }
}

CFStringRef _C3DAnimationClusterCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationCluster %p>", a1);
}

CFStringRef _C3DAnimationClusterCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationCluster %p>", a1);
}

uint64_t _C3DAnimationClusterInitWithPropertyList()
{
  return 1;
}

uint64_t _C3DAnimationClusterCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    CFArrayRef v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  uint64_t v16 = C3DAnimationGroupCreateWithAnimationCluster(a1);
  if (!v16) {
    return 0;
  }
  uint64_t v17 = v16;
  uint64_t v18 = C3DCopyPropertyList(v16, a2, a3, a4);
  CFRelease(v17);
  return v18;
}

float32x2_t C3DVector3RotateAndScale(float32x2_t *a1, float32x4_t _Q0)
{
  _S2 = a1[5].i32[0];
  __asm { FMLA            S3, S2, V0.S[2] }
  return vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(a1[2], *(float32x2_t *)_Q0.f32, 1), *a1, _Q0.f32[0]), a1[4], _Q0, 2);
}

double C3DVector3Rescale(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_f32(a1, a1);
  float v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).f32[0];
  if (v3 != 0.0)
  {
    float v4 = sqrtf(v3);
    if (v4 != a2) {
      a1.i64[0] = vmulq_n_f32(a1, a2 / v4).u64[0];
    }
  }
  return *(double *)a1.i64;
}

float32x2_t C3DVector3EulerRotate(float32x4_t a1, __n128 a2)
{
  __n128 v15 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  float32x4_t v11 = 0u;
  long long v12 = 0u;
  C3DMatrix4x4MakeEulerRotation(&v11, &v15);
  _S3 = DWORD2(v13);
  _V6.S[2] = a1.u32[2];
  float32x2_t result = vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v12, *(float32x2_t *)a1.f32, 1), *(float32x2_t *)v11.f32, a1.f32[0]), *(float32x2_t *)&v13, a1, 2);
  __asm { FMLA            S2, S3, V6.S[2] }
  return result;
}

float C3DVector3Angle(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_f32(a1, a1);
  float32x4_t v3 = vmulq_f32(a2, a2);
  float v4 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).f32[0])* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]);
  if (v4 == 0.0)
  {
    float v6 = 0.0;
  }
  else
  {
    float32x4_t v5 = vmulq_f32(a1, a2);
    float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0]/ v4;
    float v7 = 0.0;
    if (v6 >= 1.0) {
      return v7;
    }
    if (v6 <= -1.0) {
      return 3.1416;
    }
  }
  return acosf(v6);
}

uint64_t C3DVector3InitWithPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 && a2) {
    return C3DInitC3DFloatArrayWithPropertyList(a2, a1, a4);
  }
  else {
    return 0;
  }
}

uint64_t C3DVector3CopyPropertyList(uint64_t result)
{
  if (result) {
    return C3DCreatePropertyListFromC3DFloatBuffer(result, 3);
  }
  return result;
}

int8x16_t C3DVectorGenerateOrthogonalBasis(float32x4_t *a1, int8x16_t *a2, float32x4_t a3)
{
  float32x4_t v3 = vabsq_f32(a3);
  if (v3.f32[0] >= v3.f32[1])
  {
    if (v3.f32[1] < v3.f32[2])
    {
      v4.i32[1] = 0;
      v4.f32[0] = -a3.f32[2];
      v4.i64[1] = a3.u32[0];
      goto LABEL_7;
    }
LABEL_6:
    v4.i64[1] = 0;
    v4.f32[0] = -a3.f32[1];
    v4.i32[1] = a3.i32[0];
    goto LABEL_7;
  }
  if (v3.f32[0] >= v3.f32[2]) {
    goto LABEL_6;
  }
  v4.i32[0] = 0;
  v4.f32[1] = -a3.f32[2];
  v4.i64[1] = a3.u32[1];
LABEL_7:
  *a1 = v4;
  int32x4_t v5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL), vnegq_f32(a3)), v4, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a3, (int32x4_t)a3), (int8x16_t)a3, 0xCuLL));
  int8x16_t result = vextq_s8((int8x16_t)vuzp1q_s32(v5, v5), (int8x16_t)v5, 0xCuLL);
  *a2 = result;
  return result;
}

double C3DVector4MultMatrix4x4(float32x4_t *a1, float32x4_t a2)
{
  *(void *)&double result = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a1, a2.f32[0]), a1[1], *(float32x2_t *)a2.f32, 1), a1[2], a2, 2), a1[3], a2, 3).u64[0];
  return result;
}

__n128 C3DVector4GetAxisAngleRotationBetweenVectors(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a2, a2), (int8x16_t)a2, 0xCuLL), vnegq_f32(a1)), (float32x4_t)a2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1, (int32x4_t)a1), (int8x16_t)a1, 0xCuLL));
  float32x4_t v3 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL);
  float32x4_t v4 = vmulq_f32(v2, v2);
  float v5 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), v4)).f32[0]);
  if (v5 != 0.0) {
    float32x4_t v3 = vmulq_n_f32(v3, 1.0 / v5);
  }
  float32x4_t v7 = v3;
  asin(v5);
  return (__n128)v7;
}

double C3DVector4MakeAxisAngleFromEuler(float32x4_t a1)
{
  __float2 v1 = __sincosf_stret(0.5 * a1.f32[0]);
  __float2 v2 = __sincosf_stret(vmuls_lane_f32(0.5, *(float32x2_t *)a1.f32, 1));
  __float2 v3 = __sincosf_stret(vmuls_lane_f32(0.5, a1, 2));
  v4.f32[0] = (float)(v3.__cosval * (float)(v1.__sinval * v2.__sinval))
            + (float)((float)(v1.__cosval * v2.__cosval) * v3.__sinval);
  v4.f32[1] = (float)(v3.__sinval * (float)(v1.__cosval * v2.__sinval))
            + (float)((float)(v1.__sinval * v2.__cosval) * v3.__cosval);
  v4.f32[2] = (float)((float)(v1.__cosval * v2.__sinval) * v3.__cosval)
            - (float)((float)(v1.__sinval * v2.__cosval) * v3.__sinval);
  float32x4_t v10 = v4;
  acosf((float)((float)(v1.__cosval * v2.__cosval) * v3.__cosval)- (float)((float)(v1.__sinval * v2.__sinval) * v3.__sinval));
  int32x4_t v5 = (int32x4_t)vmulq_f32(v10, v10);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  *(void *)&double result = vmulq_n_f32(v10, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]).u64[0];
  return result;
}

void C3DVector3MakeEulerFromAxisAngle(float32x4_t a1)
{
  float v1 = a1.f32[3];
  __float2 v2 = __sincosf_stret(a1.f32[3]);
  float v3 = 1.0 - v2.__cosval;
  float32x4_t v4 = vmulq_f32(a1, a1);
  v4.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u64[0];
  float32x4_t v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 0);
  float32x4_t v6 = vrsqrteq_f32(v5);
  float32x4_t v7 = vmulq_f32(v6, vrsqrtsq_f32(v5, vmulq_f32(v6, v6)));
  int32x4_t v8 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v4.f32[0] != 0.0)), 0x1FuLL));
  v8.i32[3] = 0;
  int8x16_t v9 = (int8x16_t)vmulq_f32(v7, vrsqrtsq_f32(v5, vmulq_f32(v7, v7)));
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v15 = vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v8), v9, _Q2), a1);
  float v16 = vmuls_lane_f32(v2.__sinval, v15, 2)
      + (float)(vmuls_lane_f32(v15.f32[0], *(float32x2_t *)v15.f32, 1) * (float)(1.0 - v2.__cosval));
  float v22 = v15.f32[0];
  if (v16 <= 0.998)
  {
    if (v16 >= -0.998)
    {
      float v19 = v15.f32[1];
      float v20 = v15.f32[2];
      atan2f((float)(v3 * (float)-(float)(v15.f32[0] * v15.f32[2])) + (float)(v15.f32[1] * v2.__sinval), 1.0 - (float)((float)((float)(v20 * v20) + (float)(v19 * v19)) * v3));
      asinf(v16);
      atan2f((float)(v3 * (float)-(float)(v19 * v20)) + (float)(v22 * v2.__sinval), 1.0 - (float)((float)((float)(v20 * v20) + (float)(v22 * v22)) * v3));
    }
    else
    {
      __float2 v18 = __sincosf_stret(v1 * 0.5);
      atan2f(v18.__sinval * v22, v18.__cosval);
    }
  }
  else
  {
    __float2 v17 = __sincosf_stret(v1 * 0.5);
    atan2f(v17.__sinval * v22, v17.__cosval);
  }
}

void *_mm_realloc(void *a1, size_t a2, size_t size, unint64_t a4)
{
  if (a4 == 1)
  {
    float32x4_t v6 = malloc_type_malloc(size, 0x295520E9uLL);
    if (!a2) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if ((a4 & (a4 - 1)) != 0 || a4 >= 8) {
    size_t v8 = a4;
  }
  else {
    size_t v8 = 8;
  }
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, v8, size, 0xBA8A1232uLL)) {
    float32x4_t v6 = 0;
  }
  else {
    float32x4_t v6 = memptr;
  }
  if (a2) {
LABEL_14:
  }
    memcpy(v6, a1, a2);
LABEL_15:
  free(a1);
  return v6;
}

double C3DCullingSystemQueryMake@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = a1;
  *(_OWORD *)a2 = xmmword_20B5CBCD0;
  *(void *)&double result = 255;
  *(void *)(a2 + 16) = 255;
  *(_DWORD *)(a2 + 24) = 255;
  *(unsigned char *)(a2 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  return result;
}

CFStringRef _C3DCullingSystemCFCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v3, 0, @"<C3DCullingSystem %p>", a1);
}

CFStringRef _C3DCullingSystemCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DCullingSystem %p>", a1);
}

void C3DCullingSystemUpdateWorldTransforms(uint64_t a1, int *a2, float32x4_t *a3, int a4)
{
  LODWORD(v4) = a4;
  if (!a1 && (size_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DCullingSystemAdd_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (!v4) {
      return;
    }
  }
  else if (!v4)
  {
    return;
  }
  uint64_t v4 = v4;
  float v16 = a3 + 2;
  __float2 v17 = (__n128 *)MEMORY[0x263EF89A8];
  do
  {
    uint64_t v19 = *a2++;
    uint64_t v18 = v19;
    if (v19 != -1)
    {
      uint64_t v20 = *(unsigned int *)(*(void *)(a1 + 32) + 4 * v18);
      if (v20 < *(_DWORD *)(a1 + 16))
      {
        if ((*(_WORD *)(*(void *)(a1 + 88) + 2 * v20) & 0x10) != 0)
        {
          __n128 v24 = v17[3];
          __n128 v26 = (__n128)xmmword_20B5CBCE0;
        }
        else
        {
          uint64_t v21 = (float32x4_t *)(*(void *)(a1 + 64) + 32 * v20);
          float32x4_t v22 = v16[-2];
          float32x4_t v23 = v16[-1];
          __n128 v24 = (__n128)vaddq_f32(v16[1], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v23, *(float32x2_t *)v21->f32, 1), v22, COERCE_FLOAT(*v21)), *v16, *v21, 2));
          v24.n128_u32[3] = 1.0;
          float32x4_t v25 = v21[1];
          v25.i32[1] = v25.i32[0];
          v25.i32[2] = (__int32)v21[1];
          __n128 v26 = (__n128)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v22, v25)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v21[1].f32, 1), (int32x4_t)v21[1]), v23))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v21[1], (int32x4_t)v21[1]), (int32x4_t)v21[1]), *v16)));
        }
        __C3DCullingSystem::_setWorldAABBAtIndex(a1, v20, v24, v26);
      }
    }
    v16 += 4;
    --v4;
  }
  while (v4);
}

double C3DCullingSystemRemove(__C3DCullingSystem *this, unsigned int a2)
{
  if (!this)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystemAdd_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)&double result = __C3DCullingSystem::remove(this, a2).n128_u64[0];
  return result;
}

__n128 __C3DCullingSystem::remove(__C3DCullingSystem *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || a2 >= (unint64_t)((uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 2))
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __C3DCullingSystem::remove();
    }
  }
  unint64_t v5 = *(unsigned int *)(*((void *)this + 4) + 4 * (int)a2);
  if (v5 >= *((_DWORD *)this + 4))
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __C3DCullingSystem::remove(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  int v14 = *((_DWORD *)this + 4);
  unint64_t v15 = (v14 - 1);
  *((_DWORD *)this + 4) = v15;
  if (v5 == v15)
  {
    int v16 = 1 << ((v14 - 1) & 7);
    unint64_t v17 = v15 >> 3;
  }
  else
  {
    WorldAABBAtuint64_t Index = __C3DCullingSystem::_getWorldAABBAtIndex(this, v14 - 1);
    __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, v5, WorldAABBAtIndex, v19);
    uint64_t v20 = *((void *)this + 8);
    uint64_t v21 = (_OWORD *)(v20 + 32 * v15);
    long long v22 = v21[1];
    float32x4_t v23 = (_OWORD *)(v20 + 32 * v5);
    *float32x4_t v23 = *v21;
    v23[1] = v22;
    *(void *)(*((void *)this + 13) + 8 * v5) = *(void *)(*((void *)this + 13) + 8 * v15);
    uint64_t v24 = *((void *)this + 10);
    *(_DWORD *)(*((void *)this + 9) + 4 * v5) = *(_DWORD *)(*((void *)this + 9) + 4 * v15);
    *(_DWORD *)(v24 + 4 * v5) = *(_DWORD *)(v24 + 4 * v15);
    *(_WORD *)(*((void *)this + 11) + 2 * v5) = *(_WORD *)(*((void *)this + 11) + 2 * v15);
    int v16 = 1 << (v15 & 7);
    uint64_t v25 = *((void *)this + 14);
    unint64_t v17 = v15 >> 3;
    LODWORD(v24) = 1 << (v5 & 7);
    char v26 = *(unsigned char *)(v25 + (v5 >> 3));
    char v27 = v26 & ~(_BYTE)v24;
    char v28 = v26 | v24;
    if ((v16 & *(unsigned char *)(v25 + (v15 >> 3))) == 0) {
      char v28 = v27;
    }
    *(unsigned char *)(v25 + (v5 >> 3)) = v28;
    *(_DWORD *)(*((void *)this + 4)
              + 4 * *(int *)(*(void *)(*((void *)this + 13) + 8 * v15) + 216)) = v5;
  }
  uint64_t v29 = MEMORY[0x263EF89A8];
  __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, v15, *(__n128 *)(MEMORY[0x263EF89A8] + 48), (__n128)xmmword_20B5CB570);
  uint64_t v30 = (_OWORD *)(*((void *)this + 8) + 32 * v15);
  __n128 result = (__n128)xmmword_20B5CB570;
  *uint64_t v30 = *(_OWORD *)(v29 + 48);
  v30[1] = xmmword_20B5CB570;
  *(void *)(*((void *)this + 13) + 8 * v15) = 0;
  uint64_t v32 = *((void *)this + 10);
  *(_DWORD *)(*((void *)this + 9) + 4 * v15) = 0;
  *(_DWORD *)(v32 + 4 * v15) = 0;
  *(_WORD *)(*((void *)this + 11) + 2 * v15) = 0;
  *(unsigned char *)(*((void *)this + 14) + v17) &= ~(_BYTE)v16;
  *(_DWORD *)(*((void *)this + 4) + 4 * (int)a2) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = a2;
  return result;
}

void C3DCullingSystemCull(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!v5)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystemAdd_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = *(void *)(v6 + 88);
  uint64_t v30 = *(void *)(v6 + 96);
  uint64_t v31 = v15;
  long long v32 = *(_OWORD *)(v6 + 72);
  uint64_t v33 = *(void *)(v6 + 64);
  uint64_t v34 = *(void *)(v6 + 104);
  if (v2)
  {
    long long v16 = *(_OWORD *)v2;
    uint64_t v17 = *(void *)(v2 + 16);
    int v18 = *(_DWORD *)(v2 + 24);
    char v19 = *(unsigned char *)(v2 + 28);
    LOWORD(v28[0]) = *(_WORD *)(v2 + 29);
    BYTE2(v28[0]) = *(unsigned char *)(v2 + 31);
    uint64_t v20 = *(void *)(v2 + 32);
  }
  else
  {
    uint64_t v20 = 0;
    char v19 = 0;
    long long v16 = xmmword_20B5CBCD0;
    uint64_t v17 = 255;
    int v18 = 255;
  }
  uint64_t v21 = 0;
  long long v35 = v16;
  uint64_t v36 = v17;
  int v37 = v18;
  char v38 = v19;
  __int16 v39 = v28[0];
  char v40 = BYTE2(v28[0]);
  uint64_t v41 = v20;
  int v43 = 1;
  do
  {
    *(float32x4_t *)&v29[v21] = vnegq_f32(*(float32x4_t *)(v4 + v21));
    v21 += 16;
  }
  while (v21 != 96);
  unsigned int v22 = *(_DWORD *)(v6 + 16) + 2047;
  memset(v28, 0, 512);
  long long v42 = v28;
  if (v22 >= 0x800)
  {
    unsigned int v23 = v22 >> 11;
    unsigned int v24 = 2048;
    do
    {
      unsigned int v25 = *(_DWORD *)(v6 + 16);
      if (v24 >= v25) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v24;
      }
      unsigned int v27 = (*(uint64_t (**)(unsigned char *, void, uint64_t))(v6 + 176))(v29, v24 - 2048, v26);
      if (v27) {
        (*(void (**)(uint64_t, _OWORD *, void))(v41 + 16))(v41, v42, v27);
      }
      v24 += 2048;
      --v23;
    }
    while (v23);
  }
}

void C3DCullingSystemRayIntersect(uint64_t a1)
{
  *(double *)&long long v1 = MEMORY[0x270FA5388](a1);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (!v6)
  {
    long long v30 = v2;
    long long v31 = v3;
    long long v29 = v1;
    uint64_t v8 = scn_default_log();
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_FAULT);
    long long v1 = v29;
    long long v2 = v30;
    long long v3 = v31;
    if (v9)
    {
      C3DCullingSystemAdd_cold_1(v8, v10, v11, v12, v13, v14, v15, v16);
      long long v1 = v29;
      long long v2 = v30;
      long long v3 = v31;
    }
  }
  uint64_t v17 = *(void *)(v7 + 88);
  uint64_t v33 = *(void *)(v7 + 96);
  unsigned int v18 = *(_DWORD *)(v7 + 16) + 2047;
  memset(v50, 0, 512);
  uint64_t v34 = v17;
  long long v35 = *(_OWORD *)(v7 + 72);
  uint64_t v36 = *(void *)(v7 + 64);
  uint64_t v37 = *(void *)(v7 + 104);
  if (v5)
  {
    long long v19 = *(_OWORD *)v5;
    uint64_t v20 = *(void *)(v5 + 16);
    int v21 = *(_DWORD *)(v5 + 24);
    char v22 = *(unsigned char *)(v5 + 28);
    __int16 v48 = *(_WORD *)(v5 + 29);
    char v49 = *(unsigned char *)(v5 + 31);
    uint64_t v23 = *(void *)(v5 + 32);
  }
  else
  {
    uint64_t v23 = 0;
    char v22 = 0;
    long long v19 = xmmword_20B5CBCD0;
    uint64_t v20 = 255;
    int v21 = 255;
  }
  uint64_t v39 = v20;
  int v40 = v21;
  char v41 = v22;
  __int16 v42 = v48;
  char v43 = v49;
  uint64_t v44 = v23;
  int v47 = 1;
  double v45 = v50;
  double v46 = &v48;
  v32[0] = v1;
  v32[1] = v2;
  long long v38 = v19;
  v32[2] = v3;
  if (v18 >= 0x800)
  {
    unsigned int v24 = v18 >> 11;
    if (v24 <= 1) {
      int v25 = 1;
    }
    else {
      int v25 = v24;
    }
    unsigned int v26 = 2048;
    do
    {
      unsigned int v27 = *(_DWORD *)(v7 + 16);
      if (v26 >= v27) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = v26;
      }
      __C3DCullingSystem::__rayIntersectRange(v7, (uint64_t)v32, v26 - 2048, v28);
      v26 += 2048;
      --v25;
    }
    while (v25);
  }
}

uint64_t __C3DCullingSystem::__rayIntersectRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v51[1] = *(uint64_t (**)(long long *, long long *))MEMORY[0x263EF8340];
  uint64_t v6 = 168;
  if (!*(unsigned char *)(a2 + 844)) {
    uint64_t v6 = 160;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + v6))(a2, a3, a4);
  if (result)
  {
    unint64_t v8 = result;
    if (*(unsigned char *)(a2 + 844))
    {
      MEMORY[0x270FA5388](result);
      BOOL v9 = &v49 - v8;
      uint64_t v10 = 0;
      uint64_t v11 = &v9->i32[2];
      do
      {
        uint64_t v12 = *(unsigned int *)(*(void *)(a2 + 864) + v10);
        uint64_t v13 = *(float32x4_t **)(*(void *)(a1 + 104) + 8 * v12);
        uint64_t v14 = *(void *)(a1 + 64) + 32 * v12;
        float32x4_t v15 = *(float32x4_t *)(v14 + 16);
        float32x4_t v49 = *(float32x4_t *)v14;
        float32x4_t v50 = v15;
        WorldMatrix = C3DNodeGetWorldMatrix(v13);
        float32x4_t v17 = *WorldMatrix;
        float32x4_t v18 = WorldMatrix[1];
        float32x4_t v19 = WorldMatrix[2];
        float32x4_t v20 = vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v18, *(float32x2_t *)v49.f32, 1), *WorldMatrix, v49.f32[0]), v19, v49, 2));
        int8x16_t v21 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), vnegq_f32(v18)), v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL));
        float32x4_t v22 = vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL));
        BOOL v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0] < 0.0;
        float32x4_t v23 = vmulq_f32(v17, v17);
        float32x4_t v26 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1)));
        float32x4_t v24 = vmulq_f32(v18, v18);
        v26.f32[0] = sqrtf(v26.f32[0]);
        float32x4_t v25 = vmulq_f32(v19, v19);
        v26.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0]);
        v26.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]);
        if (v46) {
          float v27 = -1.0;
        }
        else {
          float v27 = 1.0;
        }
        float32x4_t v28 = vmulq_n_f32(v26, v27);
        int32x4_t v29 = (int32x4_t)vdivq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0));
        int32x4_t v30 = (int32x4_t)vdivq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1));
        int32x4_t v31 = (int32x4_t)vdivq_f32(v19, (float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2));
        float32x4_t v32 = vmulq_f32(v50, v28);
        float32x4_t v33 = vsubq_f32(v20, *(float32x4_t *)a2);
        int32x4_t v34 = vzip2q_s32(v29, v31);
        float32x4_t v35 = (float32x4_t)vzip1q_s32(vzip1q_s32(v29, v31), v30);
        float32x4_t v36 = (float32x4_t)vtrn2q_s32(v29, v30);
        v36.i32[2] = v31.i32[1];
        float32x4_t v37 = (float32x4_t)vzip1q_s32(v34, vdupq_laneq_s32(v30, 2));
        float32x4_t v38 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v36, *(float32x2_t *)v33.f32, 1), v35, v33.f32[0]), v37, v33, 2);
        float32x4_t v39 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v36, *(float32x2_t *)(a2 + 16), 1), v35, COERCE_FLOAT(*(_OWORD *)(a2 + 16))), v37, *(float32x4_t *)(a2 + 16), 2);
        float32x4_t v40 = vdivq_f32(vaddq_f32(v32, v38), v39);
        float32x4_t v41 = vdivq_f32(vsubq_f32(v38, v32), v39);
        v40.i32[3] = 0;
        v41.i32[3] = 0;
        float32x4_t v42 = vminnmq_f32(v40, v41);
        __n128 v43 = (__n128)vmaxnmq_f32(v40, v41);
        float v44 = v42.f32[2];
        if (v42.f32[0] >= v42.f32[2]) {
          float v44 = v42.f32[0];
        }
        if (v44 < v42.f32[1]) {
          float v44 = v42.f32[1];
        }
        float v45 = v43.n128_f32[2];
        if (v43.n128_f32[0] <= v43.n128_f32[2]) {
          float v45 = v43.n128_f32[0];
        }
        if (v45 > v43.n128_f32[1]) {
          float v45 = v43.n128_f32[1];
        }
        v43.n128_u64[0] = 0;
        if (v45 >= v44)
        {
          BOOL v46 = v45 >= 0.0 && v44 < *(float *)(a2 + 44);
          if (v46)
          {
            if (v44 >= 0.0) {
              v43.n128_f32[0] = v44;
            }
            else {
              v43.n128_f32[0] = v45;
            }
          }
        }
        v10 += 4;
        *((void *)v11 - 1) = v13;
        *uint64_t v11 = v43.n128_u32[0];
        v11 += 4;
      }
      while (4 * v8 != v10);
      v51[0] = (uint64_t (*)(long long *, long long *))HitResultCmp;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*,false>((long long *)&v49 - v8, (long long *)&v49, v51, 126 - 2 * __clz(v8), 1, v43);
      uint64_t v47 = 0;
      do
      {
        uint64_t v48 = v9->i64[0];
        ++v9;
        *(void *)(*(void *)(a2 + 856) + v47) = v48;
        v47 += 8;
      }
      while (8 * v8 != v47);
    }
    return (*(uint64_t (**)(void))(*(void *)(a2 + 848) + 16))();
  }
  return result;
}

void C3DCullingSystemAABBIntersect(uint64_t a1)
{
  *(double *)&long long v1 = MEMORY[0x270FA5388](a1);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (!v5)
  {
    long long v28 = v1;
    long long v29 = v2;
    uint64_t v7 = scn_default_log();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_FAULT);
    long long v1 = v28;
    long long v2 = v29;
    if (v8)
    {
      C3DCullingSystemAdd_cold_1(v7, v9, v10, v11, v12, v13, v14, v15);
      long long v1 = v28;
      long long v2 = v29;
    }
  }
  uint64_t v16 = *(void *)(v6 + 88);
  uint64_t v33 = *(void *)(v6 + 96);
  unsigned int v17 = *(_DWORD *)(v6 + 16) + 2047;
  memset(v47, 0, 512);
  uint64_t v34 = v16;
  long long v35 = *(_OWORD *)(v6 + 72);
  uint64_t v36 = *(void *)(v6 + 64);
  uint64_t v37 = *(void *)(v6 + 104);
  if (v4)
  {
    long long v18 = *(_OWORD *)v4;
    uint64_t v19 = *(void *)(v4 + 16);
    int v20 = *(_DWORD *)(v4 + 24);
    char v21 = *(unsigned char *)(v4 + 28);
    __int16 v30 = *(_WORD *)(v4 + 29);
    char v31 = *(unsigned char *)(v4 + 31);
    uint64_t v22 = *(void *)(v4 + 32);
  }
  else
  {
    uint64_t v22 = 0;
    char v21 = 0;
    long long v18 = xmmword_20B5CBCD0;
    uint64_t v19 = 255;
    int v20 = 255;
  }
  long long v38 = v18;
  uint64_t v39 = v19;
  int v40 = v20;
  char v41 = v21;
  __int16 v42 = v30;
  char v43 = v31;
  uint64_t v44 = v22;
  int v46 = 1;
  v32[0] = v1;
  v32[1] = v2;
  float v45 = v47;
  if (v17 >= 0x800)
  {
    int v23 = 0;
    unsigned int v24 = v17 >> 11;
    if (v24 <= 1) {
      int v25 = 1;
    }
    else {
      int v25 = v24;
    }
    do
    {
      int v26 = v23 + 2048;
      unsigned int v27 = (*(uint64_t (**)(_OWORD *))(v6 + 152))(v32);
      if (v27) {
        (*(void (**)(uint64_t, unsigned char *, void))(v44 + 16))(v44, v45, v27);
      }
      int v23 = v26;
      --v25;
    }
    while (v25);
  }
}

__n128 __C3DCullingSystem::_getWorldAABBAtIndex(__C3DCullingSystem *this, unsigned int a2)
{
  int v2 = *((_DWORD *)this + 6);
  if (v2 == 4)
  {
    uint64_t v9 = (unsigned __int32 *)(*((void *)this + 12) + 96 * (a2 >> 2) + 4 * (a2 & 3));
    __asm { FMOV            V0.4S, #1.0 }
    result.n128_u32[0] = *v9;
    result.n128_u32[1] = v9[4];
  }
  else if (v2 == 8)
  {
    uint64_t v3 = (unsigned __int32 *)(*((void *)this + 12) + 192 * (a2 >> 3) + 4 * (a2 & 7));
    __asm { FMOV            V0.4S, #1.0 }
    result.n128_u32[0] = *v3;
    result.n128_u32[1] = v3[8];
  }
  else
  {
    return *(__n128 *)(*((void *)this + 12) + 32 * a2);
  }
  return result;
}

__n128 C3DCullingSystemComputeHierarchicalAABB(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = 0;
  char v21 = &v20;
  uint64_t v22 = 0x5002000000;
  int v23 = __Block_byref_object_copy__1;
  unsigned int v24 = __Block_byref_object_dispose__1;
  long long v25 = *(_OWORD *)(MEMORY[0x263EF89A8] + 48);
  long long v26 = xmmword_20B5CB570;
  if (a3)
  {
    WorldMatrix = C3DNodeGetWorldMatrix(a2);
    v28.columns[0] = (simd_float4)*WorldMatrix;
    v28.columns[1] = (simd_float4)WorldMatrix[1];
    v28.columns[2] = (simd_float4)WorldMatrix[2];
    v28.columns[3] = (simd_float4)WorldMatrix[3];
    simd_float4x4 v29 = __invert_f4(v28);
    uint64_t v6 = a2[13].i32[2];
    if (v6 != -1)
    {
      uint64_t v7 = (long long *)(*(void *)(a1 + 64) + 32 * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v6));
      long long v8 = *v7;
      long long v9 = v7[1];
      uint64_t v10 = v21;
      *((_OWORD *)v21 + 3) = v8;
      *((_OWORD *)v10 + 4) = v9;
    }
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    v15[2] = __C3DCullingSystemComputeHierarchicalAABB_block_invoke;
    v15[3] = &unk_264005C50;
    long long v18 = a2;
    uint64_t v19 = a1;
    simd_float4x4 v16 = v29;
    unsigned int v17 = &v20;
    uint64_t v11 = v15;
  }
  else
  {
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 0x40000000;
    _OWORD v14[2] = __C3DCullingSystemComputeHierarchicalAABB_block_invoke_2;
    v14[3] = &unk_264005C78;
    v14[4] = &v20;
    v14[5] = a1;
    uint64_t v11 = v14;
  }
  C3DNodeApplyHierarchy((uint64_t)a2, (uint64_t)v11);
  long long v13 = *((_OWORD *)v21 + 3);
  _Block_object_dispose(&v20, 8);
  return (__n128)v13;
}

uint64_t __C3DCullingSystemComputeHierarchicalAABB_block_invoke(float32x4_t *a1, uint64_t a2)
{
  if (a1[6].i64[1] != a2)
  {
    uint64_t v2 = *(int *)(a2 + 216);
    if (v2 != -1)
    {
      WorldAABBAtuint64_t Index = __C3DCullingSystem::_getWorldAABBAtIndex((__C3DCullingSystem *)a1[7].i64[0], *(_DWORD *)(*(void *)(a1[7].i64[0] + 32) + 4 * v2));
      float32x4_t v5 = a1[2];
      float32x4_t v6 = a1[3];
      float32x4_t v7 = a1[4];
      float32x4_t v8 = vaddq_f32(a1[5], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v6, (float32x2_t)WorldAABBAtIndex.n128_u64[0], 1), v5, WorldAABBAtIndex.n128_f32[0]), v7, (float32x4_t)WorldAABBAtIndex, 2));
      float32x4_t v10 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_n_f32(v5, v9.f32[0])), vabsq_f32(vmulq_lane_f32(v6, *(float32x2_t *)v9.f32, 1))), vabsq_f32(vmulq_laneq_f32(v7, v9, 2)));
      uint64_t v11 = *(float32x4_t **)(a1[6].i64[0] + 8);
      float32x4_t v12 = v11[3];
      float32x4_t v13 = v11[4];
      float32x4_t v14 = vsubq_f32(v8, v10);
      float32x4_t v15 = vsubq_f32(v12, v13);
      v14.i32[3] = 0;
      v15.i32[3] = 0;
      float32x4_t v16 = vminnmq_f32(v14, v15);
      float32x4_t v17 = vaddq_f32(v8, v10);
      float32x4_t v18 = vaddq_f32(v12, v13);
      v17.i32[3] = 0;
      v18.i32[3] = 0;
      float32x4_t v19 = vmaxnmq_f32(v17, v18);
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      float32x4_t v20 = vmulq_f32(vaddq_f32(v16, v19), v12);
      float32x4_t v21 = vmulq_f32(vsubq_f32(v19, v16), v12);
      v20.i32[3] = 1.0;
      v21.i32[3] = 0;
      _OWORD v11[3] = v20;
      v11[4] = v21;
    }
  }
  return 0;
}

uint64_t __C3DCullingSystemComputeHierarchicalAABB_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int *)(a2 + 216);
  if (v2 != -1)
  {
    WorldAABBAtuint64_t Index = __C3DCullingSystem::_getWorldAABBAtIndex((__C3DCullingSystem *)*(void *)(a1 + 40), *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 32) + 4 * v2));
    float32x4_t v5 = *(float32x4_t **)(*(void *)(a1 + 32) + 8);
    float32x4_t v6 = v5[3];
    float32x4_t v7 = v5[4];
    float32x4_t v9 = vsubq_f32((float32x4_t)WorldAABBAtIndex, v8);
    float32x4_t v10 = vsubq_f32(v6, v7);
    v9.i32[3] = 0;
    v10.i32[3] = 0;
    float32x4_t v11 = vminnmq_f32(v9, v10);
    float32x4_t v12 = vaddq_f32((float32x4_t)WorldAABBAtIndex, v8);
    float32x4_t v13 = vaddq_f32(v6, v7);
    v12.i32[3] = 0;
    v13.i32[3] = 0;
    float32x4_t v14 = vmaxnmq_f32(v12, v13);
    v6.i64[0] = 0x3F0000003F000000;
    v6.i64[1] = 0x3F0000003F000000;
    float32x4_t v15 = vmulq_f32(vaddq_f32(v11, v14), v6);
    float32x4_t v16 = vmulq_f32(vsubq_f32(v14, v11), v6);
    v15.i32[3] = 1.0;
    v16.i32[3] = 0;
    v5[3] = v15;
    v5[4] = v16;
  }
  return 0;
}

uint64_t C3DCullingSystemGetSceneBoundingBox(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 88);
  uint64_t v12 = *(void *)(a1 + 96);
  uint64_t v13 = v2;
  long long v14 = *(_OWORD *)(a1 + 72);
  uint64_t v15 = *(void *)(a1 + 64);
  uint64_t v16 = *(void *)(a1 + 104);
  if (a2)
  {
    long long v3 = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
    int v5 = *(_DWORD *)(a2 + 24);
    char v6 = *(unsigned char *)(a2 + 28);
    __int16 v9 = *(_WORD *)(a2 + 29);
    char v10 = *(unsigned char *)(a2 + 31);
    uint64_t v7 = *(void *)(a2 + 32);
  }
  else
  {
    uint64_t v7 = 0;
    char v6 = 0;
    long long v3 = xmmword_20B5CBCD0;
    uint64_t v4 = 255;
    int v5 = 255;
  }
  long long v17 = v3;
  uint64_t v18 = v4;
  int v19 = v5;
  char v20 = v6;
  __int16 v21 = v9;
  char v22 = v10;
  uint64_t v23 = v7;
  int v24 = 1;
  return (*(uint64_t (**)(unsigned char *, void, void))(a1 + 144))(v11, 0, *(unsigned int *)(a1 + 16));
}

uint64_t C3DCullingSystem_AABBRange_x8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 7) != 0)
  {
    char v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 3;
  if (v14 >= (a3 + 7) >> 3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  uint64_t v18 = (const float *)(a1 + 816);
  uint64_t v19 = *(void *)(a1 + 784);
  char v20 = (const float *)(a1 + 820);
  int8x16_t v21 = (int8x16_t)vld1q_dup_f32(v18);
  uint64_t v22 = *(void *)(a1 + 792);
  int8x16_t v23 = (int8x16_t)vld1q_dup_f32(v20);
  int32x4_t v24 = *(int32x4_t *)(a1 + 16);
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  float32x4_t v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  float32x4_t v27 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 0);
  float32x4_t v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 1);
  float32x4_t v30 = (float32x4_t)vdupq_laneq_s32(v24, 2);
  unsigned int v31 = a2 & 0xFFFFFFF8;
  uint64_t v32 = *(void *)(a1 + 768);
  do
  {
    uint64_t v33 = (float32x4_t *)(v32 + 192 * v14);
    int8x8_t v34 = vmovn_s16((int16x8_t)vandq_s8(vandq_s8(vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v17, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 16 * v14)))), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v17, (int8x16_t)vmovl_high_u16(*(uint16x8_t *)(v16 + 16 * v14))))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v22 + 32 * v14), v23), vandq_s8(*(int8x16_t *)(v19 + 32 * v14), v21))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(
                                                                                       *(int8x16_t *)(v22 + 32 * v14 + 16),
                                                                                       v23),
                                                                                     vandq_s8(*(int8x16_t *)(v19 + 32 * v14 + 16), v21))))), (int8x16_t)vuzp1q_s16((int16x8_t)vcgeq_f32(vaddq_f32(v28, v33[6]), vabdq_f32(v25, *v33)), (int16x8_t)vcgeq_f32(vaddq_f32(v28, v33[7]), vabdq_f32(v25, v33[1])))), vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgeq_f32(vaddq_f32(v29, v33[8]), vabdq_f32(v26, v33[2])), (int16x8_t)vcgeq_f32(vaddq_f32(v29, v33[9]), vabdq_f32(v26, v33[3]))), (int8x16_t)vuzp1q_s16((int16x8_t)vcgeq_f32(vaddq_f32(v30, v33[10]), vabdq_f32(v27, v33[4])), (int16x8_t)vcgeq_f32(vaddq_f32(v30, v33[11]), vabdq_f32(v27, v33[5]))))));
    int8x16_t v35 = vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(v34, *(int8x8_t *)v17.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBD00), vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(v34, *(int8x8_t *)v17.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBCF0));
    *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v35.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
    unsigned __int32 v36 = vadd_s32(*(int32x2_t *)v35.i8, vdup_lane_s32(*(int32x2_t *)v35.i8, 1)).u32[0];
    if (v36) {
      BOOL v37 = 8 * (int)v14 >= a3;
    }
    else {
      BOOL v37 = 1;
    }
    if (!v37)
    {
      unint64_t v38 = v31;
      do
      {
        if (v36)
        {
          *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v38);
          uint64_t result = (result + 1);
        }
        if (v36 < 2) {
          break;
        }
        ++v38;
        v36 >>= 1;
      }
      while (v38 < a3);
    }
    ++v14;
    v31 += 8;
  }
  while (v14 != (a3 + 7) >> 3);
  return result;
}

uint64_t C3DCullingSystem_AABBRange_x4(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 3) != 0)
  {
    char v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 2;
  if (v14 >= (a3 + 3) >> 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (const float *)(a1 + 816);
  int8x16_t v18 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  uint64_t v19 = *(void *)(a1 + 784);
  int8x16_t v20 = (int8x16_t)vld1q_dup_f32(v17);
  int8x16_t v21 = (const float *)(a1 + 820);
  uint64_t v22 = *(void *)(a1 + 792);
  int8x16_t v23 = (int8x16_t)vld1q_dup_f32(v21);
  int32x4_t v24 = *(int32x4_t *)(a1 + 16);
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  float32x4_t v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  float32x4_t v27 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 0);
  float32x4_t v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 1);
  float32x4_t v30 = (float32x4_t)vdupq_laneq_s32(v24, 2);
  unsigned int v31 = a2 & 0xFFFFFFFC;
  uint64_t v32 = *(void *)(a1 + 768);
  do
  {
    uint64_t v33 = (float32x4_t *)(v32 + 96 * v14);
    int8x16_t v34 = vandq_s8(vandq_s8(vandq_s8(vbicq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8(v18, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 8 * v14)))), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v22 + 16 * v14), v23), vandq_s8(*(int8x16_t *)(v19 + 16 * v14), v20)))), (int8x16_t)vcgeq_f32(vaddq_f32(v28, v33[3]), vabdq_f32(v25, *v33))), vandq_s8((int8x16_t)vcgeq_f32(vaddq_f32(v29, v33[4]), vabdq_f32(v26, v33[1])), (int8x16_t)vcgeq_f32(vaddq_f32(v30, v33[5]), vabdq_f32(v27, v33[2])))), (int8x16_t)xmmword_20B5CBD00);
    *(int8x8_t *)v34.i8 = vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
    unsigned __int32 v35 = vadd_s32(*(int32x2_t *)v34.i8, vdup_lane_s32(*(int32x2_t *)v34.i8, 1)).u32[0];
    if (v35) {
      BOOL v36 = 4 * (int)v14 >= a3;
    }
    else {
      BOOL v36 = 1;
    }
    if (!v36)
    {
      unint64_t v37 = v31;
      do
      {
        if (v35)
        {
          *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v37);
          uint64_t result = (result + 1);
        }
        if (v35 < 2) {
          break;
        }
        ++v37;
        v35 >>= 1;
      }
      while (v37 < a3);
    }
    ++v14;
    v31 += 4;
  }
  while (v14 != (a3 + 3) >> 2);
  return result;
}

uint64_t C3DCullingSystem_AABBRange_x1(float32x4_t *a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a1[48].i64[1];
  int v6 = a1[52].i32[1] | (~a1[52].i32[2] << 8);
  uint64_t v7 = a1[49].i64[0];
  __int32 v8 = a1[51].i32[0];
  __int32 v9 = a1[51].i32[1];
  uint64_t v10 = a1[49].i64[1];
  uint64_t v11 = a2;
  uint64_t v12 = (32 * a2) | 0x10;
  do
  {
    if (*(_DWORD *)(v10 + 4 * v11) & v9 | *(_DWORD *)(v7 + 4 * v11) & v8) {
      BOOL v13 = (unsigned __int16)(v6 & *(_WORD *)(v5 + 2 * v11)) == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      uint32x4_t v14 = (uint32x4_t)vcgeq_f32(vaddq_f32(a1[1], *(float32x4_t *)(a1[48].i64[0] + v12)), vabdq_f32(*a1, *(float32x4_t *)(a1[48].i64[0] + v12 - 16)));
      v14.i32[3] = v14.i32[2];
      if ((vminvq_u32(v14) & 0x80000000) != 0)
      {
        *(void *)(a1[53].i64[1] + 8 * result) = *(void *)(a1[50].i64[1] + 8 * v11);
        uint64_t result = (result + 1);
      }
    }
    ++v11;
    v12 += 32;
  }
  while (a3 != v11);
  return result;
}

double C3DCullingSystem_MergeAABBRange_x8(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  if ((a2 & 7) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 776);
  uint64_t v15 = a2 >> 3;
  uint64_t v16 = (const float *)(a1 + 816);
  int v17 = *(_DWORD *)(a1 + 836);
  int v18 = *(_DWORD *)(a1 + 840);
  int32x2_t v19 = *(int32x2_t *)(a1 + 832);
  uint64_t v20 = *(void *)(a1 + 784);
  int8x16_t v21 = (const float *)(a1 + 820);
  int8x16_t v22 = (int8x16_t)vld1q_dup_f32(v16);
  int8x16_t v23 = (int8x16_t)vld1q_dup_f32(v21);
  uint64_t v24 = *(void *)(a1 + 792);
  long long v76 = xmmword_20B5CBF40;
  float32x4_t v77 = (float32x4_t)unk_20B5CBF50;
  long long v78 = xmmword_20B5CBF60;
  float32x4_t v79 = (float32x4_t)unk_20B5CBF70;
  long long v74 = xmmword_20B5CBF20;
  float32x4_t v75 = (float32x4_t)unk_20B5CBF30;
  long long v70 = xmmword_20B5CBFA0;
  float32x4_t v71 = (float32x4_t)unk_20B5CBFB0;
  long long v72 = xmmword_20B5CBFC0;
  float32x4_t v73 = (float32x4_t)unk_20B5CBFD0;
  long long v68 = xmmword_20B5CBF80;
  float32x4_t v69 = (float32x4_t)unk_20B5CBF90;
  if (v15 >= (a3 + 7) >> 3)
  {
    float32x4_t v50 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v56.i64[0] = 0x80000000800000;
    v56.i64[1] = 0x80000000800000;
    v57.i64[0] = 0x80000000800000;
    v57.i64[1] = 0x80000000800000;
    v54.i64[0] = 0x80000000800000;
    v54.i64[1] = 0x80000000800000;
    v55.i64[0] = 0x80000000800000;
    v55.i64[1] = 0x80000000800000;
    v52.i64[0] = 0x80000000800000;
    v52.i64[1] = 0x80000000800000;
    float32x4_t v51 = v50;
    v53.i64[0] = 0x80000000800000;
    v53.i64[1] = 0x80000000800000;
    float32x4_t v48 = v50;
    float32x4_t v49 = v50;
    float32x4_t v46 = v50;
    float32x4_t v47 = v50;
  }
  else
  {
    int8x16_t v25 = (int8x16_t)vdupq_n_s32(v17 | (~v18 << 8));
    int8x16_t v26 = (int8x16_t)vdupq_lane_s32(v19, 0);
    uint64_t v27 = *(void *)(a1 + 768) + 192 * v15 + 96;
    do
    {
      uint64_t v28 = 0;
      uint16x8_t v29 = *(uint16x8_t *)(v14 + 16 * v15);
      int8x16_t v30 = (int8x16_t)vmovl_high_u16(v29);
      int8x16_t v31 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v29.i8);
      int8x8_t v32 = vmovn_s16((int16x8_t)vbicq_s8(vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v25, v31)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v25, v30))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v24 + 32 * v15), v23), vandq_s8(*(int8x16_t *)(v20 + 32 * v15), v22))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v24 + 32 * v15 + 16), v23), vandq_s8(*(int8x16_t *)(v20 + 32 * v15 + 16), v22))))),
                                   (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v26, v31)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v26, v30)))));
      int8x16_t v33 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(v32, *(int8x8_t *)v22.i8)), 0x1FuLL));
      int8x16_t v34 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(v32, *(int8x8_t *)v22.i8)), 0x1FuLL));
      do
      {
        unsigned __int32 v35 = (float32x4_t *)((char *)&v74 + v28);
        float32x4_t v36 = *(float32x4_t *)((char *)&v74 + v28 + 16);
        float32x4_t v37 = *(float32x4_t *)(v27 + v28 - 96);
        float32x4_t v38 = *(float32x4_t *)(v27 + v28 - 80);
        float32x4_t v39 = *(float32x4_t *)(v27 + v28);
        float32x4_t v40 = *(float32x4_t *)(v27 + v28 + 16);
        int8x16_t v41 = (int8x16_t)vcgezq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(v32, *(int8x8_t *)v22.i8)), 0x1FuLL));
        int8x16_t v42 = (int8x16_t)vcgezq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(v32, *(int8x8_t *)v22.i8)), 0x1FuLL));
        char v43 = (float32x4_t *)((char *)&v68 + v28);
        float32x4_t v45 = *(float32x4_t *)((char *)&v68 + v28);
        float32x4_t v44 = *(float32x4_t *)((char *)&v68 + v28 + 16);
        *unsigned __int32 v35 = vminnmq_f32(*(float32x4_t *)((char *)&v74 + v28), (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vsubq_f32(v37, v39), v34), vandq_s8(*(int8x16_t *)((char *)&v74 + v28), v41)));
        v35[1] = vminnmq_f32(v36, (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vsubq_f32(v38, v40), v33), vandq_s8((int8x16_t)v36, v42)));
        *char v43 = vmaxnmq_f32(v45, (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v45, v41), vandq_s8((int8x16_t)vaddq_f32(v37, v39), v34)));
        v43[1] = vmaxnmq_f32(v44, (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v44, v42), vandq_s8((int8x16_t)vaddq_f32(v38, v40), v33)));
        v28 += 32;
      }
      while (v28 != 96);
      ++v15;
      v27 += 192;
    }
    while (v15 != (a3 + 7) >> 3);
    float32x4_t v46 = (float32x4_t)v74;
    float32x4_t v47 = v75;
    float32x4_t v48 = (float32x4_t)v76;
    float32x4_t v49 = v77;
    float32x4_t v50 = (float32x4_t)v78;
    float32x4_t v51 = v79;
    float32x4_t v52 = (float32x4_t)v68;
    float32x4_t v53 = v69;
    float32x4_t v54 = (float32x4_t)v70;
    float32x4_t v55 = v71;
    float32x4_t v56 = (float32x4_t)v72;
    float32x4_t v57 = v73;
  }
  int64x2_t v58 = (int64x2_t)vminq_f32(v46, v47);
  float32x4_t v59 = vminq_f32((float32x4_t)vdupq_lane_s64(v58.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v58, 1));
  int64x2_t v60 = (int64x2_t)vminq_f32(v48, v49);
  v59.f32[0] = fminf(v59.f32[0], v59.f32[1]);
  v60.i64[0] = vminq_f32((float32x4_t)vdupq_lane_s64(v60.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v60, 1)).u64[0];
  int64x2_t v61 = (int64x2_t)vminq_f32(v50, v51);
  v61.i64[0] = vminq_f32((float32x4_t)vdupq_lane_s64(v61.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v61, 1)).u64[0];
  v59.i32[1] = fminf(*(float *)v60.i32, *(float *)&v60.i32[1]);
  v59.i32[2] = fminf(*(float *)v61.i32, *(float *)&v61.i32[1]);
  int64x2_t v62 = (int64x2_t)vmaxq_f32(v52, v53);
  float32x4_t v63 = vmaxq_f32((float32x4_t)vdupq_lane_s64(v62.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v62, 1));
  int64x2_t v64 = (int64x2_t)vmaxq_f32(v54, v55);
  v63.f32[0] = fmaxf(v63.f32[0], v63.f32[1]);
  v64.i64[0] = vmaxq_f32((float32x4_t)vdupq_lane_s64(v64.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v64, 1)).u64[0];
  int64x2_t v65 = (int64x2_t)vmaxq_f32(v56, v57);
  v65.i64[0] = vmaxq_f32((float32x4_t)vdupq_lane_s64(v65.i64[0], 0), (float32x4_t)vdupq_laneq_s64(v65, 1)).u64[0];
  v63.i32[1] = fmaxf(*(float *)v64.i32, *(float *)&v64.i32[1]);
  v63.i32[2] = fmaxf(*(float *)v65.i32, *(float *)&v65.i32[1]);
  v66.i64[0] = 0x3F0000003F000000;
  v66.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v59, v63), v66).u64[0];
  return result;
}

double C3DCullingSystem_MergeAABBRange_x4(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if ((a2 & 3) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 776);
  uint64_t v15 = a2 >> 2;
  uint64_t v16 = (const float *)(a1 + 816);
  int v17 = *(_DWORD *)(a1 + 836);
  int v18 = *(_DWORD *)(a1 + 840);
  int32x2_t v19 = (const float *)(a1 + 832);
  int32x4_t v20 = (int32x4_t)vld1q_dup_f32(v19);
  uint64_t v21 = *(void *)(a1 + 784);
  int8x16_t v22 = (const float *)(a1 + 820);
  int8x16_t v23 = (int8x16_t)vld1q_dup_f32(v16);
  int8x16_t v24 = (int8x16_t)vld1q_dup_f32(v22);
  uint64_t v25 = *(void *)(a1 + 792);
  long long v47 = xmmword_20B5CBFE0;
  float32x4_t v48 = (float32x4_t)unk_20B5CBFF0;
  long long v49 = xmmword_20B5CC000;
  long long v44 = xmmword_20B5CC010;
  float32x4_t v45 = (float32x4_t)unk_20B5CC020;
  long long v46 = xmmword_20B5CC030;
  if (v15 >= (a3 + 3) >> 2)
  {
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    v41.i64[0] = 0x80000000800000;
    v41.i64[1] = 0x80000000800000;
    v39.i64[0] = 0x80000000800000;
    v39.i64[1] = 0x80000000800000;
    v40.i64[0] = 0x80000000800000;
    v40.i64[1] = 0x80000000800000;
    float32x4_t v36 = v38;
    float32x4_t v37 = v38;
  }
  else
  {
    int8x16_t v26 = (int8x16_t)vdupq_n_s32(v17 | (~v18 << 8));
    uint64_t v27 = *(void *)(a1 + 768) + 96 * v15 + 48;
    do
    {
      uint64_t v28 = 0;
      int32x4_t v29 = (int32x4_t)vmovl_u16(*(uint16x4_t *)(v14 + 8 * v15));
      int32x4_t v30 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)vtstq_s32(v20, v29), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v25 + 16 * v15), v24), vandq_s8(*(int8x16_t *)(v21 + 16 * v15), v23)))), (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8(v26, (int8x16_t)v29)));
      int16x4_t v31 = vmovn_s32(v30);
      do
      {
        float32x4_t v32 = *(float32x4_t *)(v27 + v28 - 48);
        float32x4_t v33 = *(float32x4_t *)(v27 + v28);
        int8x16_t v34 = (int8x16_t)vmovl_s16(v31);
        float32x4_t v35 = *(float32x4_t *)((char *)&v44 + v28);
        *(long long *)((char *)&v47 + v2_Block_object_dispose(&STACK[0x2A0], 8) = (__int128)vminnmq_f32(*(float32x4_t *)((char *)&v47 + v28), (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vsubq_f32(v32, v33), (int8x16_t)v30), vbicq_s8(*(int8x16_t *)((char *)&v47 + v28), v34)));
        *(long long *)((char *)&v44 + v2_Block_object_dispose(&STACK[0x2A0], 8) = (__int128)vmaxnmq_f32(v35, (float32x4_t)vorrq_s8(vbicq_s8((int8x16_t)v35, v34), vandq_s8((int8x16_t)vaddq_f32(v32, v33), (int8x16_t)v30)));
        v28 += 16;
      }
      while (v28 != 48);
      ++v15;
      v27 += 96;
    }
    while (v15 != (a3 + 3) >> 2);
    float32x4_t v37 = (float32x4_t)v47;
    float32x4_t v36 = v48;
    float32x4_t v38 = (float32x4_t)v49;
    float32x4_t v40 = (float32x4_t)v44;
    float32x4_t v39 = v45;
    float32x4_t v41 = (float32x4_t)v46;
  }
  v37.f32[0] = vminvq_f32(v37);
  v37.i32[1] = vminvq_f32(v36);
  v37.i32[2] = vminvq_f32(v38);
  v40.f32[0] = vmaxvq_f32(v40);
  v40.i32[1] = vmaxvq_f32(v39);
  v40.i32[2] = vmaxvq_f32(v41);
  v42.i64[0] = 0x3F0000003F000000;
  v42.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v37, v40), v42).u64[0];
  return result;
}

uint64_t C3DCullingSystem_MergeAABBRange_x1(uint64_t result, unsigned int a2, unsigned int a3)
{
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  if (a2 < a3)
  {
    int v4 = *(_DWORD *)(result + 836) | (~*(_DWORD *)(result + 840) << 8);
    int v5 = *(_DWORD *)(result + 832);
    int v6 = *(_DWORD *)(result + 816);
    int v7 = *(_DWORD *)(result + 820);
    uint64_t v8 = (int *)(*(void *)(result + 784) + 4 * a2);
    uint64_t v9 = (int *)(*(void *)(result + 792) + 4 * a2);
    uint64_t v10 = (unsigned __int16 *)(*(void *)(result + 776) + 2 * a2);
    uint64_t v11 = (float32x4_t *)(*(void *)(result + 768) + 32 * a2 + 16);
    float32x4_t v12 = (float32x4_t)xmmword_20B5CB570;
    v13.i64[0] = 0x3F0000003F000000;
    v13.i64[1] = 0x3F0000003F000000;
    unint64_t v14 = a3 - (unint64_t)a2;
    do
    {
      int v15 = *v8++;
      int v16 = v15 & v6;
      int v17 = *v9++;
      int v18 = v17 & v7;
      unsigned int v19 = *v10++;
      int v20 = v18 | v16;
      double result = v5 & v19;
      if ((v4 & v19) == 0 && v20 != 0 && result != 0)
      {
        float32x4_t v23 = v11[-1];
        float32x4_t v24 = vsubq_f32(v3, v12);
        float32x4_t v25 = vsubq_f32(v23, *v11);
        v24.i32[3] = 0;
        v25.i32[3] = 0;
        float32x4_t v26 = vminnmq_f32(v24, v25);
        float32x4_t v27 = vaddq_f32(v3, v12);
        v27.i32[3] = 0;
        float32x4_t v28 = vaddq_f32(v23, *v11);
        v28.i32[3] = 0;
        float32x4_t v29 = vmaxnmq_f32(v27, v28);
        float32x4_t v3 = vmulq_f32(vaddq_f32(v26, v29), v13);
        float32x4_t v12 = vmulq_f32(vsubq_f32(v29, v26), v13);
        v3.i32[3] = 1.0;
        v12.i32[3] = 0;
      }
      v11 += 2;
      --v14;
    }
    while (v14);
  }
  return result;
}

uint64_t C3DCullingSystem_RayRange_x8<true>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 7) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 3;
  if (v14 >= (a3 + 7) >> 3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  int v18 = (const float *)(a1 + 816);
  unsigned int v19 = (const float *)(a1 + 820);
  int8x16_t v20 = (int8x16_t)vld1q_dup_f32(v18);
  int8x16_t v21 = (int8x16_t)vld1q_dup_f32(v19);
  uint64_t v22 = *(void *)(a1 + 784);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  uint64_t v25 = *(void *)(a1 + 792);
  float32x4_t v26 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  float32x4_t v27 = *(float32x4_t *)(a1 + 32);
  float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3);
  uint64_t v29 = *(void *)(a1 + 768);
  do
  {
    int8x8_t v30 = vmovn_s16((int16x8_t)vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v17, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 16 * v14)))), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v17, (int8x16_t)vmovl_high_u16(*(uint16x8_t *)(v16 + 16 * v14))))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v25 + 32 * v14), v21), vandq_s8(*(int8x16_t *)(v22 + 32 * v14), v20))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v25 + 32 * v14 + 16), v21),
                                                                                 vandq_s8(*(int8x16_t *)(v22 + 32 * v14 + 16), v20))))));
    if ((vmaxvq_u32((uint32x4_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vorr_s8(vzip1_s8(v30, *(int8x8_t *)v17.i8), vzip2_s8(v30, *(int8x8_t *)v17.i8))), 0x1FuLL))) & 0x80000000) != 0)
    {
      int16x4_t v31 = (float32x4_t *)(v29 + 192 * v14);
      float32x4_t v32 = v31[1];
      float32x4_t v33 = v31[6];
      float32x4_t v34 = v31[7];
      float32x4_t v35 = vmulq_n_f32(vsubq_f32(vsubq_f32(v32, v34), v23), v27.f32[0]);
      float32x4_t v36 = vmulq_n_f32(vsubq_f32(vsubq_f32(*v31, v33), v23), v27.f32[0]);
      float32x4_t v37 = v31[2];
      float32x4_t v38 = v31[3];
      float32x4_t v39 = v31[8];
      float32x4_t v40 = v31[9];
      float32x4_t v41 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v38, v40), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v42 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v37, v39), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v44 = v31[4];
      float32x4_t v43 = v31[5];
      float32x4_t v45 = v31[10];
      float32x4_t v46 = v31[11];
      float32x4_t v47 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v43, v46), v26), v27, 2);
      float32x4_t v48 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v44, v45), v26), v27, 2);
      float32x4_t v49 = vmulq_n_f32(vsubq_f32(vaddq_f32(v32, v34), v23), v27.f32[0]);
      float32x4_t v50 = vmulq_n_f32(vsubq_f32(vaddq_f32(*v31, v33), v23), v27.f32[0]);
      float32x4_t v51 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v38, v40), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v52 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v37, v39), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v53 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v43, v46), v26), v27, 2);
      float32x4_t v54 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v44, v45), v26), v27, 2);
      float32x4_t v55 = vminnmq_f32(v36, v50);
      float32x4_t v56 = vminnmq_f32(v35, v49);
      float32x4_t v57 = vminnmq_f32(v47, v53);
      float32x4_t v58 = vmaxnmq_f32(v36, v50);
      float32x4_t v59 = vmaxnmq_f32(v35, v49);
      float32x4_t v60 = vmaxnmq_f32(v48, v54);
      float32x4_t v61 = vmaxnmq_f32(v47, v53);
      float32x4_t v62 = vmaxnmq_f32(v55, vmaxnmq_f32(vminnmq_f32(v42, v52), vminnmq_f32(v48, v54)));
      float32x4_t v63 = vmaxnmq_f32(v56, vmaxnmq_f32(vminnmq_f32(v41, v51), v57));
      int8x8_t v64 = vand_s8(vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v28, v62), (int16x8_t)vcgtq_f32(v28, v63)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgeq_f32(vminnmq_f32(v58, vminnmq_f32(vmaxnmq_f32(v42, v52), v60)), v62), (int16x8_t)vcgeq_f32(vminnmq_f32(v59, vminnmq_f32(vmaxnmq_f32(v41, v51), v61)), v63)))), v30);
      int8x16_t v65 = vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(v64, *(int8x8_t *)v17.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBD00), vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(v64, *(int8x8_t *)v17.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBCF0));
      *(int8x8_t *)v65.i8 = vorr_s8(*(int8x8_t *)v65.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL));
      unsigned __int32 v66 = vadd_s32(*(int32x2_t *)v65.i8, vdup_lane_s32(*(int32x2_t *)v65.i8, 1)).u32[0];
      unsigned int v67 = 8 * v14;
      if (v66 && v67 < a3)
      {
        uint64_t v69 = *(void *)(a1 + 864);
        do
        {
          if (v66)
          {
            *(_DWORD *)(v69 + 4 * result) = v67;
            uint64_t result = (result + 1);
          }
          if (v66 < 2) {
            break;
          }
          ++v67;
          v66 >>= 1;
        }
        while (v67 < a3);
      }
    }
    ++v14;
  }
  while (v14 != (a3 + 7) >> 3);
  return result;
}

uint64_t C3DCullingSystem_RayRange_x8<false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 7) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 3;
  if (v14 >= (a3 + 7) >> 3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (const float *)(a1 + 816);
  int8x16_t v18 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  uint64_t v19 = *(void *)(a1 + 784);
  int8x16_t v20 = (const float *)(a1 + 820);
  int8x16_t v21 = (int8x16_t)vld1q_dup_f32(v17);
  int8x16_t v22 = (int8x16_t)vld1q_dup_f32(v20);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  float32x4_t v25 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  uint64_t v26 = *(void *)(a1 + 792);
  float32x4_t v27 = *(float32x4_t *)(a1 + 32);
  float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3);
  unsigned int v29 = a2 & 0xFFFFFFF8;
  uint64_t v30 = *(void *)(a1 + 768);
  do
  {
    int8x8_t v31 = vmovn_s16((int16x8_t)vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v18, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 16 * v14)))), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v18, (int8x16_t)vmovl_high_u16(*(uint16x8_t *)(v16 + 16 * v14))))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v26 + 32 * v14), v22), vandq_s8(*(int8x16_t *)(v19 + 32 * v14), v21))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v26 + 32 * v14 + 16), v22),
                                                                                 vandq_s8(*(int8x16_t *)(v19 + 32 * v14 + 16), v21))))));
    if ((vmaxvq_u32((uint32x4_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vorr_s8(vzip1_s8(v31, *(int8x8_t *)v18.i8), vzip2_s8(v31, *(int8x8_t *)v18.i8))), 0x1FuLL))) & 0x80000000) != 0)
    {
      float32x4_t v32 = (float32x4_t *)(v30 + 192 * v14);
      float32x4_t v33 = v32[1];
      float32x4_t v34 = v32[6];
      float32x4_t v35 = v32[7];
      float32x4_t v36 = vmulq_n_f32(vsubq_f32(vsubq_f32(v33, v35), v23), v27.f32[0]);
      float32x4_t v37 = vmulq_n_f32(vsubq_f32(vsubq_f32(*v32, v34), v23), v27.f32[0]);
      float32x4_t v38 = v32[2];
      float32x4_t v39 = v32[3];
      float32x4_t v40 = v32[8];
      float32x4_t v41 = v32[9];
      float32x4_t v42 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v39, v41), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v43 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v38, v40), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v45 = v32[4];
      float32x4_t v44 = v32[5];
      float32x4_t v46 = v32[10];
      float32x4_t v47 = v32[11];
      float32x4_t v48 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v44, v47), v25), v27, 2);
      float32x4_t v49 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v45, v46), v25), v27, 2);
      float32x4_t v50 = vmulq_n_f32(vsubq_f32(vaddq_f32(v33, v35), v23), v27.f32[0]);
      float32x4_t v51 = vmulq_n_f32(vsubq_f32(vaddq_f32(*v32, v34), v23), v27.f32[0]);
      float32x4_t v52 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v39, v41), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v53 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v38, v40), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v54 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v44, v47), v25), v27, 2);
      float32x4_t v55 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v45, v46), v25), v27, 2);
      float32x4_t v56 = vminnmq_f32(v37, v51);
      float32x4_t v57 = vminnmq_f32(v36, v50);
      float32x4_t v58 = vminnmq_f32(v48, v54);
      float32x4_t v59 = vmaxnmq_f32(v37, v51);
      float32x4_t v60 = vmaxnmq_f32(v36, v50);
      float32x4_t v61 = vmaxnmq_f32(v49, v55);
      float32x4_t v62 = vmaxnmq_f32(v48, v54);
      float32x4_t v63 = vmaxnmq_f32(v56, vmaxnmq_f32(vminnmq_f32(v43, v53), vminnmq_f32(v49, v55)));
      float32x4_t v64 = vmaxnmq_f32(v57, vmaxnmq_f32(vminnmq_f32(v42, v52), v58));
      int8x8_t v65 = vand_s8(vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v28, v63), (int16x8_t)vcgtq_f32(v28, v64)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgeq_f32(vminnmq_f32(v59, vminnmq_f32(vmaxnmq_f32(v43, v53), v61)), v63), (int16x8_t)vcgeq_f32(vminnmq_f32(v60, vminnmq_f32(vmaxnmq_f32(v42, v52), v62)), v64)))), v31);
      int8x16_t v66 = vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(v65, *(int8x8_t *)v18.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBD00), vandq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(v65, *(int8x8_t *)v18.i8)), 0x1FuLL)), (int8x16_t)xmmword_20B5CBCF0));
      *(int8x8_t *)v66.i8 = vorr_s8(*(int8x8_t *)v66.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL));
      unsigned __int32 v67 = vadd_s32(*(int32x2_t *)v66.i8, vdup_lane_s32(*(int32x2_t *)v66.i8, 1)).u32[0];
      if (v67 && 8 * (int)v14 < a3)
      {
        unint64_t v69 = v29;
        do
        {
          if (v67)
          {
            *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v69);
            uint64_t result = (result + 1);
          }
          if (v67 < 2) {
            break;
          }
          ++v69;
          v67 >>= 1;
        }
        while (v69 < a3);
      }
    }
    ++v14;
    v29 += 8;
  }
  while (v14 != (a3 + 7) >> 3);
  return result;
}

uint64_t C3DCullingSystem_RayRange_x4<true>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 3) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 2;
  if (v14 >= (a3 + 3) >> 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (const float *)(a1 + 816);
  int8x16_t v18 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  uint64_t v19 = *(void *)(a1 + 784);
  int8x16_t v20 = (int8x16_t)vld1q_dup_f32(v17);
  int8x16_t v21 = (const float *)(a1 + 820);
  int8x16_t v22 = (int8x16_t)vld1q_dup_f32(v21);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  uint64_t v24 = *(void *)(a1 + 792);
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  float32x4_t v26 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  float32x4_t v27 = *(float32x4_t *)(a1 + 32);
  float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3);
  uint64_t v29 = *(void *)(a1 + 768);
  do
  {
    int32x4_t v30 = (int32x4_t)vbicq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8(v18, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 8 * v14)))), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v24 + 16 * v14), v22), vandq_s8(*(int8x16_t *)(v19 + 16 * v14), v20))));
    if ((vmaxvq_u32((uint32x4_t)v30) & 0x80000000) != 0)
    {
      int8x8_t v31 = (float32x4_t *)(v29 + 96 * v14);
      float32x4_t v32 = v31[1];
      float32x4_t v34 = v31[2];
      float32x4_t v33 = v31[3];
      float32x4_t v35 = vmulq_n_f32(vsubq_f32(vsubq_f32(*v31, v33), v23), v27.f32[0]);
      float32x4_t v36 = v31[4];
      float32x4_t v37 = v31[5];
      float32x4_t v38 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v32, v36), v25), *(float32x2_t *)v27.f32, 1);
      float32x4_t v39 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v34, v37), v26), v27, 2);
      float32x4_t v40 = vmulq_n_f32(vsubq_f32(vaddq_f32(*v31, v33), v23), v27.f32[0]);
      float32x4_t v41 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v32, v36), v25), *(float32x2_t *)v27.f32, 1);
      float32x4_t v42 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v34, v37), v26), v27, 2);
      float32x4_t v43 = vmaxnmq_f32(vminnmq_f32(v35, v40), vmaxnmq_f32(vminnmq_f32(v38, v41), vminnmq_f32(v39, v42)));
      int8x16_t v44 = vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f32(v28, v43), (int8x16_t)vcgeq_f32(vminnmq_f32(vmaxnmq_f32(v35, v40), vminnmq_f32(vmaxnmq_f32(v38, v41), vmaxnmq_f32(v39, v42))), v43))), (int8x8_t)vmovn_s32(v30))), (int8x16_t)xmmword_20B5CBD00);
      *(int8x8_t *)v44.i8 = vorr_s8(*(int8x8_t *)v44.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL));
      unsigned __int32 v45 = vadd_s32(*(int32x2_t *)v44.i8, vdup_lane_s32(*(int32x2_t *)v44.i8, 1)).u32[0];
      unsigned int v46 = 4 * v14;
      if (v45 && v46 < a3)
      {
        uint64_t v48 = *(void *)(a1 + 864);
        do
        {
          if (v45)
          {
            *(_DWORD *)(v48 + 4 * result) = v46;
            uint64_t result = (result + 1);
          }
          if (v45 < 2) {
            break;
          }
          ++v46;
          v45 >>= 1;
        }
        while (v46 < a3);
      }
    }
    ++v14;
  }
  while (v14 != (a3 + 3) >> 2);
  return result;
}

uint64_t C3DCullingSystem_RayRange_x4<false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 3) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 2;
  if (v14 >= (a3 + 3) >> 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = *(void *)(a1 + 776);
  int8x16_t v17 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  int8x16_t v18 = (const float *)(a1 + 816);
  uint64_t v19 = (const float *)(a1 + 820);
  int8x16_t v20 = (int8x16_t)vld1q_dup_f32(v18);
  int8x16_t v21 = (int8x16_t)vld1q_dup_f32(v19);
  uint64_t v22 = *(void *)(a1 + 784);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 0);
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1, 1);
  uint64_t v25 = *(void *)(a1 + 792);
  float32x4_t v26 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a1, 2);
  float32x4_t v27 = *(float32x4_t *)(a1 + 32);
  float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3);
  uint64_t v29 = *(void *)(a1 + 768);
  unsigned int v30 = a2 & 0xFFFFFFFC;
  do
  {
    int32x4_t v31 = (int32x4_t)vbicq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8(v17, (int8x16_t)vmovl_u16(*(uint16x4_t *)(v16 + 8 * v14)))), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v25 + 16 * v14), v21), vandq_s8(*(int8x16_t *)(v22 + 16 * v14), v20))));
    if ((vmaxvq_u32((uint32x4_t)v31) & 0x80000000) != 0)
    {
      float32x4_t v32 = (float32x4_t *)(v29 + 96 * v14);
      float32x4_t v33 = v32[1];
      float32x4_t v35 = v32[2];
      float32x4_t v34 = v32[3];
      float32x4_t v36 = vmulq_n_f32(vsubq_f32(vsubq_f32(*v32, v34), v23), v27.f32[0]);
      float32x4_t v37 = v32[4];
      float32x4_t v38 = v32[5];
      float32x4_t v39 = vmulq_lane_f32(vsubq_f32(vsubq_f32(v33, v37), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v40 = vmulq_laneq_f32(vsubq_f32(vsubq_f32(v35, v38), v26), v27, 2);
      float32x4_t v41 = vmulq_n_f32(vsubq_f32(vaddq_f32(*v32, v34), v23), v27.f32[0]);
      float32x4_t v42 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v33, v37), v24), *(float32x2_t *)v27.f32, 1);
      float32x4_t v43 = vmulq_laneq_f32(vsubq_f32(vaddq_f32(v35, v38), v26), v27, 2);
      float32x4_t v44 = vmaxnmq_f32(vminnmq_f32(v36, v41), vmaxnmq_f32(vminnmq_f32(v39, v42), vminnmq_f32(v40, v43)));
      int8x16_t v45 = vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f32(v28, v44), (int8x16_t)vcgeq_f32(vminnmq_f32(vmaxnmq_f32(v36, v41), vminnmq_f32(vmaxnmq_f32(v39, v42), vmaxnmq_f32(v40, v43))), v44))), (int8x8_t)vmovn_s32(v31))), (int8x16_t)xmmword_20B5CBD00);
      *(int8x8_t *)v45.i8 = vorr_s8(*(int8x8_t *)v45.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL));
      unsigned __int32 v46 = vadd_s32(*(int32x2_t *)v45.i8, vdup_lane_s32(*(int32x2_t *)v45.i8, 1)).u32[0];
      if (v46 && 4 * (int)v14 < a3)
      {
        unint64_t v48 = v30;
        do
        {
          if (v46)
          {
            *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v48);
            uint64_t result = (result + 1);
          }
          if (v46 < 2) {
            break;
          }
          ++v48;
          v46 >>= 1;
        }
        while (v48 < a3);
      }
    }
    ++v14;
    v30 += 4;
  }
  while (v14 != (a3 + 3) >> 2);
  return result;
}

uint64_t C3DCullingSystem_RayRange_x1<true>(float32x4_t *a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a1[48].i64[1];
  int v6 = a1[52].i32[1] | (~a1[52].i32[2] << 8);
  uint64_t v7 = a1[49].i64[0];
  __int32 v8 = a1[51].i32[0];
  __int32 v9 = a1[51].i32[1];
  uint64_t v10 = a1[49].i64[1];
  uint64_t v11 = a1[54].i64[0];
  uint64_t v12 = a2;
  uint64_t v13 = (32 * a2) | 0x10;
  do
  {
    uint64_t v14 = (float32x4_t *)(a1[48].i64[0] + v13);
    float32x4_t v15 = v14[-1];
    float32x4_t v16 = a1[2];
    float32x4_t v17 = vmulq_f32(v16, vsubq_f32(vsubq_f32(v15, *v14), *a1));
    v17.i32[3] = 0;
    float32x4_t v18 = vmulq_f32(v16, vsubq_f32(vaddq_f32(v15, *v14), *a1));
    v18.i32[3] = 0;
    float32x4_t v19 = vminnmq_f32(v17, v18);
    float32x4_t v20 = vmaxnmq_f32(v17, v18);
    float v21 = v19.f32[2];
    if (v19.f32[0] >= v19.f32[2]) {
      float v21 = v19.f32[0];
    }
    if (v21 < v19.f32[1]) {
      float v21 = v19.f32[1];
    }
    float v22 = v20.f32[2];
    if (v20.f32[0] <= v20.f32[2]) {
      float v22 = v20.f32[0];
    }
    v20.i32[0] = v20.i32[1];
    if (v22 <= v20.f32[1]) {
      v20.f32[0] = v22;
    }
    if (*(_DWORD *)(v10 + 4 * v12) & v9 | *(_DWORD *)(v7 + 4 * v12) & v8
      && ((unsigned __int16)v6 & *(_WORD *)(v5 + 2 * v12)) == 0
      && v20.f32[0] >= v21
      && v21 < v16.f32[3])
    {
      *(_DWORD *)(v11 + 4 * result) = v12;
      uint64_t result = (result + 1);
    }
    ++v12;
    v13 += 32;
  }
  while (a3 != v12);
  return result;
}

uint64_t C3DCullingSystem_RayRange_x1<false>(float32x4_t *a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a1[48].i64[1];
  int v6 = a1[52].i32[1] | (~a1[52].i32[2] << 8);
  uint64_t v7 = a1[49].i64[0];
  __int32 v8 = a1[51].i32[0];
  __int32 v9 = a1[51].i32[1];
  uint64_t v10 = a1[49].i64[1];
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  uint64_t v13 = (32 * a2) | 0x10;
  do
  {
    uint64_t v14 = (float32x4_t *)(a1[48].i64[0] + v13);
    float32x4_t v15 = v14[-1];
    float32x4_t v16 = a1[2];
    float32x4_t v17 = vmulq_f32(v16, vsubq_f32(vsubq_f32(v15, *v14), *a1));
    v17.i32[3] = 0;
    float32x4_t v18 = vmulq_f32(v16, vsubq_f32(vaddq_f32(v15, *v14), *a1));
    v18.i32[3] = 0;
    float32x4_t v19 = vminnmq_f32(v17, v18);
    float32x4_t v20 = vmaxnmq_f32(v17, v18);
    float v21 = v19.f32[2];
    if (v19.f32[0] >= v19.f32[2]) {
      float v21 = v19.f32[0];
    }
    if (v21 < v19.f32[1]) {
      float v21 = v19.f32[1];
    }
    float v22 = v20.f32[2];
    if (v20.f32[0] <= v20.f32[2]) {
      float v22 = v20.f32[0];
    }
    v20.i32[0] = v20.i32[1];
    if (v22 <= v20.f32[1]) {
      v20.f32[0] = v22;
    }
    if (*(_DWORD *)(v10 + 4 * v11) & v9 | *(_DWORD *)(v7 + 4 * v11) & v8
      && ((unsigned __int16)v6 & *(_WORD *)(v5 + 2 * v11)) == 0
      && v20.f32[0] >= v21
      && v21 < v16.f32[3])
    {
      *(void *)(a1[53].i64[1] + 8 * result) = *(void *)(a1[50].i64[1] + 8 * v11);
      uint64_t result = (result + 1);
    }
    ++v11;
    v13 += 32;
  }
  while (v12 != v11);
  return result;
}

void __C3DCullingSystem::~__C3DCullingSystem(__C3DCullingSystem *this)
{
  free(*((void **)this + 14));
  free(*((void **)this + 12));
  free(*((void **)this + 8));
  free(*((void **)this + 13));
  free(*((void **)this + 9));
  free(*((void **)this + 10));
  free(*((void **)this + 11));
  uint64_t v2 = (const void *)*((void *)this + 17);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 17) = 0;
  }
  float32x4_t v3 = *((void *)this + 15);
  if (v3)
  {
    dispatch_release(v3);
    dispatch_release(*((dispatch_object_t *)this + 16));
  }
  int v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
}

BOOL HitResultCmp(uint64_t a1, uint64_t a2)
{
  return *(float *)(a1 + 8) < *(float *)(a2 + 8);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*,false>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *), uint64_t a4, char a5, __n128 a6)
{
LABEL_1:
  uint64_t v12 = a2 - 1;
  uint64_t v13 = a1;
LABEL_2:
  uint64_t v14 = 1 - a4;
  while (1)
  {
    a1 = v13;
    uint64_t v15 = v14;
    uint64_t v16 = (char *)a2 - (char *)v13;
    unint64_t v17 = a2 - v13;
    if (!(!v7 & v6))
    {
      switch(v17)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((*a3)(a2 - 1, v13))
          {
            long long v24 = *v13;
            *uint64_t v13 = *v12;
            *uint64_t v12 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13, v13 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13, v13 + 1, v13 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13, v13 + 1, v13 + 2, v13 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v16 <= 383) {
      break;
    }
    if (v15 == 1)
    {
      if (v13 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*,HitResult*>(v13, a2, a2, (unsigned int (**)(long long *, long long *))a3, a6);
      }
      return;
    }
    unint64_t v18 = v17 >> 1;
    float32x4_t v19 = &v13[v17 >> 1];
    if ((unint64_t)v16 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13, &v13[v17 >> 1], a2 - 1, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13 + 1, v19 - 1, a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13 + 2, &v13[v18 + 1], a2 - 3, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v19 - 1, v19, &v13[v18 + 1], a3);
      long long v23 = *v13;
      *uint64_t v13 = *v19;
      *float32x4_t v19 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(&v13[v17 >> 1], v13, a2 - 1, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)(v13 - 1, v13) & 1) == 0)
    {
      uint64_t v13 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,HitResult *,BOOL (*&)(HitResult const&,HitResult const&)>(v13, a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    float32x4_t v20 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,HitResult *,BOOL (*&)(HitResult const&,HitResult const&)>(v13, a2, a3);
    if ((v21 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v22 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v13, v20, a3);
    uint64_t v13 = v20 + 1;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(v20 + 1, a2, a3))
    {
      a4 = -v15;
      a2 = v20;
      if (v22) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v14 = v15 + 1;
    if (!v22)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*,false>(a1, v20, a3, -v15, a5 & 1);
      uint64_t v13 = v20 + 1;
LABEL_18:
      a5 = 0;
      a4 = -v15;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>((uint64_t)v13, a2, (uint64_t (**)(_OWORD *, void))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>((uint64_t)v13, a2, (uint64_t (**)(_OWORD *, void))a3);
  }
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(_OWORD *, void))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v15 = v3;
    uint64_t v16 = v4;
    char v6 = (_OWORD *)result;
    char v7 = (_OWORD *)(result + 16);
    if ((_OWORD *)(result + 16) != a2)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (_OWORD *)result;
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = v7;
        uint64_t result = (*a3)(v7, v11);
        if (result)
        {
          long long v14 = *v10;
          uint64_t v12 = v9;
          while (1)
          {
            *(_OWORD *)((char *)v6 + v12 + 16) = *(_OWORD *)((char *)v6 + v12);
            if (!v12) {
              break;
            }
            v12 -= 16;
            uint64_t result = (*a3)(&v14, (char *)v6 + v12);
            if ((result & 1) == 0)
            {
              uint64_t v13 = (_OWORD *)((char *)v6 + v12 + 16);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v6;
LABEL_10:
          *uint64_t v13 = v14;
        }
        char v7 = v10 + 1;
        v9 += 16;
      }
      while (v10 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(_OWORD *, void))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v13 = v3;
    uint64_t v14 = v4;
    char v6 = (_OWORD *)result;
    char v7 = (_OWORD *)(result + 16);
    if ((_OWORD *)(result + 16) != a2)
    {
      uint64_t v9 = result - 16;
      do
      {
        uint64_t v10 = v6;
        char v6 = v7;
        uint64_t result = (*a3)(v7, v10);
        if (result)
        {
          long long v12 = *v6;
          uint64_t v11 = v9;
          do
          {
            *(_OWORD *)(v11 + 32) = *(_OWORD *)(v11 + 16);
            uint64_t result = (*a3)(&v12, v11);
            v11 -= 16;
          }
          while ((result & 1) != 0);
          *(_OWORD *)(v11 + 32) = v12;
        }
        char v7 = v6 + 1;
        v9 += 16;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(long long *a1, long long *a2, long long *a3, uint64_t (**a4)(long long *, long long *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    long long v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!(*a4)(a2, a1)) {
      return 1;
    }
    long long v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  if (!result)
  {
    long long v13 = *a1;
    *a1 = *a2;
    *a2 = v13;
    if (!(*a4)(a3, a2)) {
      return 1;
    }
    long long v14 = *a2;
    *a2 = *a3;
    *a3 = v14;
    return 2;
  }
  long long v10 = *a1;
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

long long *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,HitResult *,BOOL (*&)(HitResult const&,HitResult const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v4 = a2;
  long long v11 = *a1;
  if ((*a3)(&v11, a2 - 1))
  {
    char v6 = a1;
    do
      ++v6;
    while (((*a3)(&v11, v6) & 1) == 0);
  }
  else
  {
    char v7 = a1 + 1;
    do
    {
      char v6 = v7;
      if (v7 >= v4) {
        break;
      }
      int v8 = (*a3)(&v11, v7);
      char v7 = v6 + 1;
    }
    while (!v8);
  }
  if (v6 < v4)
  {
    do
      --v4;
    while (((*a3)(&v11, v4) & 1) != 0);
  }
  while (v6 < v4)
  {
    long long v12 = *v6;
    long long *v6 = *v4;
    *uint64_t v4 = v12;
    do
      ++v6;
    while (!(*a3)(&v11, v6));
    do
      --v4;
    while (((*a3)(&v11, v4) & 1) != 0);
  }
  uint64_t v9 = v6 - 1;
  if (v6 - 1 != a1) {
    *a1 = *v9;
  }
  long long *v9 = v11;
  return v6;
}

long long *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,HitResult *,BOOL (*&)(HitResult const&,HitResult const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = 0;
  long long v13 = *a1;
  do
    ++v6;
  while (((*a3)(&a1[v6], &v13) & 1) != 0);
  char v7 = &a1[v6];
  int v8 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v7 >= a2) {
        break;
      }
      --a2;
    }
    while (((*a3)(a2, &v13) & 1) == 0);
  }
  else
  {
    do
      --a2;
    while (!(*a3)(a2, &v13));
  }
  if (v7 < a2)
  {
    uint64_t v9 = &a1[v6];
    long long v10 = a2;
    do
    {
      long long v14 = *v9;
      long long v11 = v14;
      long long *v9 = *v10;
      *long long v10 = v11;
      do
        ++v9;
      while (((*a3)(v9, &v13) & 1) != 0);
      do
        --v10;
      while (!(*a3)(v10, &v13));
    }
    while (v9 < v10);
    int v8 = v9 - 1;
  }
  if (v8 != a1) {
    *a1 = *v8;
  }
  long long *v8 = v13;
  return v8;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v8 = a2 - 1;
      if ((*a3)(a2 - 1, a1))
      {
        long long v9 = *a1;
        *a1 = *v8;
        long long *v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      long long v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a1 + 1, a1 + 2, a3);
      long long v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v11, v10))
    {
      long long v17 = *v11;
      uint64_t v14 = v12;
      while (1)
      {
        uint64_t v15 = (long long *)((char *)a1 + v14);
        *(long long *)((char *)a1 + v14 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(long long *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        v14 -= 16;
        if (((*a3)(&v17, v15 + 1) & 1) == 0)
        {
          uint64_t v16 = (long long *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *uint64_t v16 = v17;
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }
    long long v10 = v11;
    v12 += 16;
    if (++v11 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(long long *a1, long long *a2, long long *a3, long long *a4, uint64_t (**a5)(long long *, long long *))
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    long long v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    if ((*a5)(a3, a2))
    {
      long long v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      if ((*a5)(a2, a1))
      {
        __n128 result = (__n128)*a1;
        *a1 = *a2;
        *a2 = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(long long *a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t (**a6)(long long *, long long *))
{
  __n128 v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(long long *, long long *, __n128))*a6)(a5, a4, v12))
  {
    long long v14 = *a4;
    *a4 = *a5;
    *a5 = v14;
    if ((*a6)(a4, a3))
    {
      long long v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      if ((*a6)(a3, a2))
      {
        long long v16 = *a2;
        *a2 = *a3;
        *a3 = v16;
        if ((*a6)(a2, a1))
        {
          __n128 result = (__n128)*a1;
          *a1 = *a2;
          *a2 = (__int128)result;
        }
      }
    }
  }
  return result;
}

long long *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*,HitResult*>(long long *a1, long long *a2, long long *a3, unsigned int (**a4)(long long *, long long *), __n128 a5)
{
  if (a1 != a2)
  {
    char v7 = a2;
    uint64_t v9 = (char *)a2 - (char *)a1;
    uint64_t v10 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v11 = (unint64_t)(v10 - 2) >> 1;
      unint64_t v12 = v11 + 1;
      int v13 = &a1[v11];
      do
      {
        a5.n128_f64[0] = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>((uint64_t)a1, a4, v10, v13--);
        --v12;
      }
      while (v12);
    }
    long long v14 = v7;
    if (v7 != a3)
    {
      long long v15 = v7;
      do
      {
        if (((unsigned int (*)(long long *, long long *, __n128))*a4)(v15, a1, a5))
        {
          long long v16 = *v15;
          *long long v15 = *a1;
          *a1 = v16;
          a5.n128_f64[0] = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>((uint64_t)a1, a4, v10, a1);
        }
        ++v15;
      }
      while (v15 != a3);
      long long v14 = a3;
    }
    if (v9 < 17)
    {
      return v14;
    }
    else
    {
      uint64_t v25 = v14;
      uint64_t v17 = (unint64_t)v9 >> 4;
      do
      {
        uint64_t v18 = 0;
        long long v26 = *a1;
        float32x4_t v19 = a1;
        do
        {
          float32x4_t v20 = &v19[v18 + 1];
          uint64_t v21 = (2 * v18) | 1;
          uint64_t v22 = 2 * v18 + 2;
          if (v22 < v17 && (*a4)(&v19[v18 + 1], &v19[v18 + 2]))
          {
            ++v20;
            uint64_t v21 = v22;
          }
          *float32x4_t v19 = *v20;
          float32x4_t v19 = v20;
          uint64_t v18 = v21;
        }
        while (v21 <= (uint64_t)((unint64_t)(v17 - 2) >> 1));
        if (v20 == --v7)
        {
          *float32x4_t v20 = v26;
        }
        else
        {
          *float32x4_t v20 = *v7;
          *char v7 = v26;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>((uint64_t)a1, (uint64_t)(v20 + 1), (uint64_t (**)(long long *, long long *))a4, v20 + 1 - a1);
        }
      }
      while (v17-- > 2);
      return v25;
    }
  }
  return a3;
}

double std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(uint64_t a1, unsigned int (**a2)(long long *, long long *), uint64_t a3, long long *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v21 = v4;
    uint64_t v22 = v5;
    char v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 4)
    {
      uint64_t v12 = ((uint64_t)a4 - a1) >> 3;
      uint64_t v13 = v12 + 1;
      long long v14 = (long long *)(a1 + 16 * (v12 + 1));
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3 && (*a2)(v14, v14 + 1))
      {
        ++v14;
        uint64_t v13 = v15;
      }
      if ((((uint64_t (*)(long long *, long long *))*a2)(v14, v7) & 1) == 0)
      {
        long long v20 = *v7;
        do
        {
          uint64_t v17 = v14;
          *char v7 = *v14;
          if (v9 < v13) {
            break;
          }
          uint64_t v18 = (2 * v13) | 1;
          long long v14 = (long long *)(a1 + 16 * v18);
          uint64_t v19 = 2 * v13 + 2;
          if (v19 < a3)
          {
            if ((*a2)((long long *)(a1 + 16 * v18), v14 + 1))
            {
              ++v14;
              uint64_t v18 = v19;
            }
          }
          char v7 = v17;
          uint64_t v13 = v18;
        }
        while (!(*a2)(v14, &v20));
        double result = *(double *)&v20;
        *uint64_t v17 = v20;
      }
    }
  }
  return result;
}

double std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(HitResult const&,HitResult const&),HitResult*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v15 = v4;
    uint64_t v16 = v5;
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = (long long *)(a1 + 16 * (v6 >> 1));
    unint64_t v11 = (long long *)(a2 - 16);
    if ((*a3)(v10, (long long *)(a2 - 16)))
    {
      long long v14 = *v11;
      do
      {
        uint64_t v13 = v10;
        *unint64_t v11 = *v10;
        if (!v9) {
          break;
        }
        unint64_t v9 = (v9 - 1) >> 1;
        uint64_t v10 = (long long *)(a1 + 16 * v9);
        unint64_t v11 = v13;
      }
      while (((*a3)(v10, &v14) & 1) != 0);
      double result = *(double *)&v14;
      *uint64_t v13 = v14;
    }
  }
  return result;
}

uint64_t C3DCullingSystem_CullRange_x8<false,true>(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  unsigned int v2 = v1;
  unsigned int v4 = v3;
  unint64_t v6 = v5;
  uint64_t v94 = *MEMORY[0x263EF8340];
  if ((v3 & 7) != 0)
  {
    char v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = v4 >> 3;
  uint64_t v16 = (v2 + 7) >> 3;
  uint64_t v17 = v6[110].u32[0];
  if (v17)
  {
    uint64_t v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    v21.i64[0] = 0x8000000080000000;
    v21.i64[1] = 0x8000000080000000;
    uint64_t v22 = v6;
    do
    {
      for (uint64_t i = 0; i != 12; i += 2)
      {
        int32x4_t v24 = *(int32x4_t *)v22[i].i8;
        int8x16_t v25 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 0);
        long long v26 = (int8x16_t *)&v93[2 * v19 + 290];
        int8x16_t *v26 = v25;
        v26[1] = v25;
        int8x16_t v27 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 1);
        v26[2] = v27;
        v26[3] = v27;
        int8x16_t v28 = (int8x16_t)vdupq_laneq_s32(v24, 2);
        int32x4_t v29 = vdupq_laneq_s32(v24, 3);
        v26[4] = v28;
        v26[5] = v28;
        v26[6] = (int8x16_t)v29;
        v26[7] = (int8x16_t)v29;
        unsigned int v30 = (int8x16_t *)&v93[2 * v20 + 2];
        int8x16_t v31 = vandq_s8(v25, v21);
        *unsigned int v30 = v31;
        v30[1] = v31;
        int8x16_t v32 = vandq_s8(v27, v21);
        v30[2] = v32;
        v30[3] = v32;
        int8x16_t v33 = vandq_s8(v28, v21);
        v30[4] = v33;
        v30[5] = v33;
        v19 += 4;
        v20 += 3;
      }
      ++v18;
      v22 += 12;
    }
    while (v18 != v17);
  }
  if (v15 >= v16) {
    return 0;
  }
  uint64_t result = 0;
  int32x2_t v35 = v6[97];
  float32x4_t v36 = (const float *)&v6[102];
  int8x16_t v37 = (int8x16_t)vdupq_n_s32(v6[104].i32[1] | (~v6[105].i32[0] << 8));
  int8x16_t v38 = (int8x16_t)vdupq_lane_s32(v6[104], 0);
  int32x2_t v39 = v6[98];
  float32x4_t v40 = (const float *)&v6[102] + 1;
  int8x16_t v41 = (int8x16_t)vld1q_dup_f32(v36);
  float32x4_t v42 = (const float *)&v6[103];
  float32x4_t v43 = (const float *)&v6[103] + 1;
  int8x16_t v44 = (int8x16_t)vld1q_dup_f32(v42);
  int8x16_t v45 = (int8x16_t)vld1q_dup_f32(v40);
  int32x2_t v46 = v6[99];
  int8x16_t v47 = (int8x16_t)vld1q_dup_f32(v43);
  unsigned int v48 = v4 & 0xFFFFFFF8;
  int32x2_t v49 = v6[96];
  int8x16_t v91 = v38;
  int8x16_t v92 = v37;
  do
  {
    float32x4_t v50 = (int8x16_t *)(*(void *)&v39 + 32 * v15);
    int8x16_t v51 = *v50;
    int8x16_t v52 = v50[1];
    int8x16_t v53 = vandq_s8(*v50, v41);
    float32x4_t v54 = (int8x16_t *)(*(void *)&v46 + 32 * v15);
    int8x16_t v55 = v54[1];
    int8x16_t v56 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*v54, v45), v53)), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v55, v45), vandq_s8(v52, v41))));
    uint16x8_t v57 = *(uint16x8_t *)(*(void *)&v35 + 16 * v15);
    int8x16_t v58 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v57.i8);
    int8x16_t v59 = (int8x16_t)vmovl_high_u16(v57);
    *(int8x8_t *)v51.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v38, v58)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v38, v59)))), v56), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(*v54, v47), vandq_s8(v51, v44)), vandq_s8(v37, v58))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(v55, v47), vandq_s8(v52, v44)), vandq_s8(v37, v59))))));
    int8x16_t v60 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v37.i8)), 0x1FuLL));
    int8x16_t v61 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v37.i8)), 0x1FuLL));
    if ((vmaxvq_u32((uint32x4_t)vorrq_s8(v61, v60)) & 0x80000000) != 0)
    {
      if (v17)
      {
        uint64_t v62 = 0;
        unsigned int v63 = 0;
        int v64 = 0;
        int8x8_t v65 = (_OWORD *)(*(void *)&v49 + 192 * v15);
        int8x16_t v67 = *((int8x16_t *)v65 + 6);
        int8x16_t v66 = *((int8x16_t *)v65 + 7);
        int8x16_t v69 = *((int8x16_t *)v65 + 8);
        int8x16_t v68 = *((int8x16_t *)v65 + 9);
        int8x16_t v71 = *((int8x16_t *)v65 + 10);
        int8x16_t v70 = *((int8x16_t *)v65 + 11);
        float32x4_t v73 = *(float32x4_t *)v65;
        float32x4_t v72 = *((float32x4_t *)v65 + 1);
        float32x4_t v75 = *((float32x4_t *)v65 + 2);
        float32x4_t v74 = *((float32x4_t *)v65 + 3);
        float32x4_t v77 = *((float32x4_t *)v65 + 4);
        float32x4_t v76 = *((float32x4_t *)v65 + 5);
        int8x16_t v78 = 0uLL;
        int8x16_t v79 = 0uLL;
        do
        {
          int v80 = 0;
          int v81 = v64 + 24;
          v82.i64[0] = -1;
          v82.i64[1] = -1;
          v83.i64[0] = -1;
          v83.i64[1] = -1;
          unsigned int v84 = v63;
          do
          {
            unint64_t v85 = (int8x16_t *)&v93[2 * v84 + 2];
            char v86 = (float32x4_t *)&v93[2 * (v64 + v80) + 290];
            int32x4_t v83 = (int32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v86[7], v86[1], vsubq_f32(v72, (float32x4_t)veorq_s8(v85[1], v66))), v86[3], vsubq_f32(v74, (float32x4_t)veorq_s8(v85[3], v68))), v86[5], vsubq_f32(v76, (float32x4_t)veorq_s8(v85[5], v70))));
            int32x4_t v82 = (int32x4_t)vandq_s8((int8x16_t)v82, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v86[6], *v86, vsubq_f32(v73, (float32x4_t)veorq_s8(*v85, v67))), v86[2], vsubq_f32(v75, (float32x4_t)veorq_s8(v85[2], v69))), v86[4], vsubq_f32(v77, (float32x4_t)veorq_s8(v85[4], v71))));
            v84 += 3;
            v80 += 4;
          }
          while (v80 != 24);
          v63 += 18;
          float32x4_t v87 = (int8x16_t *)((char *)&unk_20B5CBDA0 + 32 * v62);
          int8x16_t v78 = vorrq_s8(vandq_s8(vandq_s8(*v87, v61), (int8x16_t)vcltzq_s32(v82)), v78);
          int8x16_t v79 = vorrq_s8(vandq_s8(vandq_s8(v87[1], v60), (int8x16_t)vcltzq_s32(v83)), v79);
          ++v62;
          int v64 = v81;
        }
        while (v62 != v17);
      }
      else
      {
        int8x16_t v78 = 0uLL;
        int8x16_t v79 = 0uLL;
      }
      if ((vminvq_u32((uint32x4_t)vceqzq_s32((int32x4_t)vorrq_s8(v78, v79))) & 0x80000000) != 0)
      {
        int8x16_t v38 = v91;
        int8x16_t v37 = v92;
      }
      else
      {
        int8x16_t v38 = v91;
        int8x16_t v37 = v92;
        if (8 * (int)v15 < v2)
        {
          unsigned int v88 = 0;
          unint64_t v89 = v48;
          do
          {
            v93[0] = v78;
            v93[1] = v79;
            int v90 = *((_DWORD *)v93 + (v88 & 7));
            if ((_BYTE)v90)
            {
              *(unsigned char *)(*(void *)&v6[109] + result) = v90;
              *(void *)(*(void *)&v6[107] + 8 * result) = *(void *)(*(void *)&v6[101] + 8 * v89);
              uint64_t result = (result + 1);
            }
            if (v88 > 6) {
              break;
            }
            ++v88;
            ++v89;
          }
          while (v89 < v2);
        }
      }
    }
    ++v15;
    v48 += 8;
  }
  while (v15 != v16);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x4<false,true>(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  unsigned int v2 = v1;
  unsigned int v4 = v3;
  uint64_t v6 = v5;
  uint64_t v66 = *MEMORY[0x263EF8340];
  if ((v3 & 3) != 0)
  {
    char v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = v4 >> 2;
  uint64_t v16 = (v2 + 3) >> 2;
  uint64_t v17 = *(unsigned int *)(v6 + 880);
  if (v17)
  {
    uint64_t v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    v21.i64[0] = 0x8000000080000000;
    v21.i64[1] = 0x8000000080000000;
    uint64_t v22 = v6;
    do
    {
      for (uint64_t i = 0; i != 96; i += 16)
      {
        int32x4_t v24 = *(int32x4_t *)(v22 + i);
        int8x16_t v25 = (int8x16_t *)&v65[v19 + 145];
        int8x16_t v26 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 0);
        int8x16_t v27 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v24.i8, 1);
        *int8x16_t v25 = v26;
        v25[1] = v27;
        int8x16_t v28 = (int8x16_t)vdupq_laneq_s32(v24, 2);
        v25[2] = v28;
        v25[3] = (int8x16_t)vdupq_laneq_s32(v24, 3);
        int32x4_t v29 = (int8x16_t *)&v65[v20 + 1];
        *int32x4_t v29 = vandq_s8(v26, v21);
        v29[1] = vandq_s8(v27, v21);
        void v29[2] = vandq_s8(v28, v21);
        v19 += 4;
        v20 += 3;
      }
      ++v18;
      v22 += 96;
    }
    while (v18 != v17);
  }
  if (v15 >= v16) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v31 = *(void *)(v6 + 768);
  uint64_t v32 = *(void *)(v6 + 776);
  int8x16_t v33 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(v6 + 836) | (~*(_DWORD *)(v6 + 840) << 8));
  float32x4_t v34 = (const float *)(v6 + 816);
  int32x2_t v35 = (const float *)(v6 + 832);
  int32x4_t v36 = (int32x4_t)vld1q_dup_f32(v35);
  uint64_t v37 = *(void *)(v6 + 784);
  int8x16_t v38 = (const float *)(v6 + 820);
  int8x16_t v39 = (int8x16_t)vld1q_dup_f32(v34);
  float32x4_t v40 = (const float *)(v6 + 824);
  int8x16_t v41 = (const float *)(v6 + 828);
  int8x16_t v42 = (int8x16_t)vld1q_dup_f32(v40);
  uint64_t v43 = *(void *)(v6 + 792);
  int8x16_t v44 = (int8x16_t)vld1q_dup_f32(v38);
  int8x16_t v45 = (int8x16_t)vld1q_dup_f32(v41);
  unsigned int v46 = v4 & 0xFFFFFFFC;
  do
  {
    int8x16_t v47 = *(int8x16_t *)(v37 + 16 * v15);
    int8x16_t v48 = *(int8x16_t *)(v43 + 16 * v15);
    int8x16_t v49 = (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v48, v44), vandq_s8(v47, v39)));
    int8x16_t v50 = vorrq_s8(vandq_s8(v48, v45), vandq_s8(v47, v42));
    int32x4_t v51 = (int32x4_t)vmovl_u16(*(uint16x4_t *)(v32 + 8 * v15));
    int8x16_t v52 = vandq_s8(vbicq_s8((int8x16_t)vtstq_s32(v36, v51), v49), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(v50, vandq_s8(v33, (int8x16_t)v51))));
    if ((vmaxvq_u32((uint32x4_t)v52) & 0x80000000) != 0)
    {
      if (v17)
      {
        uint64_t v53 = 0;
        unsigned int v54 = 0;
        int v55 = 0;
        int32x4_t v57 = 0uLL;
        do
        {
          int v58 = 0;
          v59.i64[0] = -1;
          v59.i64[1] = -1;
          unsigned int v60 = v54;
          do
          {
            int8x16_t v61 = (float32x4_t *)&v65[(v55 + v58) + 145];
            uint64_t v56 = v31 + 96 * v15;
            int32x4_t v59 = (int32x4_t)vandq_s8((int8x16_t)v59, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v61[3], *v61, vsubq_f32(*(float32x4_t *)v56, (float32x4_t)veorq_s8((int8x16_t)v65[v60 + 1], *(int8x16_t *)(v56 + 48)))), v61[1], vsubq_f32(*(float32x4_t *)(v56 + 16), (float32x4_t)veorq_s8((int8x16_t)v65[v60 + 2], *(int8x16_t *)(v56 + 64)))), v61[2], vsubq_f32(*(float32x4_t *)(v56 + 32), (float32x4_t)veorq_s8((int8x16_t)v65[v60 + 3], *(int8x16_t *)(v56 + 80)))));
            v60 += 3;
            v58 += 4;
          }
          while (v58 != 24);
          v54 += 18;
          int32x4_t v57 = (int32x4_t)vorrq_s8(vandq_s8(vandq_s8(xmmword_20B5CBEA0[v53++], v52), (int8x16_t)vcltzq_s32(v59)), (int8x16_t)v57);
          v55 += 24;
        }
        while (v53 != v17);
      }
      else
      {
        int32x4_t v57 = 0uLL;
      }
      if ((vminvq_u32((uint32x4_t)vceqzq_s32(v57)) & 0x80000000) == 0 && 4 * (int)v15 < v2)
      {
        unsigned int v62 = 0;
        unint64_t v63 = v46;
        do
        {
          v65[0] = v57;
          int v64 = *(_DWORD *)((unint64_t)v65 & 0xFFFFFFFFFFFFFFF3 | (4 * (v62 & 3)));
          if ((_BYTE)v64)
          {
            *(unsigned char *)(*(void *)(v6 + 872) + result) = v64;
            *(void *)(*(void *)(v6 + 856) + 8 * result) = *(void *)(*(void *)(v6 + 808) + 8 * v63);
            uint64_t result = (result + 1);
          }
          if (v62 > 2) {
            break;
          }
          ++v62;
          ++v63;
        }
        while (v63 < v2);
      }
    }
    ++v15;
    v46 += 4;
  }
  while (v15 != v16);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x1<false,true>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  int v5 = *(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8);
  int v6 = *(_DWORD *)(a1 + 832);
  uint64_t v7 = a2;
  do
  {
    int v8 = *(unsigned __int16 *)(*(void *)(a1 + 776) + 2 * v7);
    int v9 = v6 & v8;
    int v10 = v5 & v8;
    if (v9) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 784) + 4 * v7) | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 792) + 4 * v7) << 32);
      if ((v12 & *(void *)(a1 + 816)) != 0 && (*(void *)(a1 + 824) & v12) == 0)
      {
        int v13 = 0;
        int v14 = 0;
        uint64_t v15 = (float32x4_t *)(*(void *)(a1 + 768) + 32 * v7);
        float32x4_t v16 = *v15;
        float32x4_t v17 = v15[1];
        do
        {
          unint64_t v18 = 0;
          BOOL v19 = 0;
          long long v20 = *(_OWORD *)(a1 + 48);
          v26[2] = *(_OWORD *)(a1 + 32);
          v26[3] = v20;
          long long v21 = *(_OWORD *)(a1 + 80);
          v26[4] = *(_OWORD *)(a1 + 64);
          v26[5] = v21;
          long long v22 = *(_OWORD *)(a1 + 16);
          v26[0] = *(_OWORD *)a1;
          v26[1] = v22;
          do
          {
            float32x4_t v23 = (float32x4_t)v26[v18];
            int8x16_t v24 = (int8x16_t)vmulq_f32(v16, v23);
            float32x4_t v25 = vmulq_f32(v17, vabsq_f32(v23));
            if (vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL))) > vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]) {
              break;
            }
            BOOL v19 = v18++ > 4;
          }
          while (v18 != 6);
          v14 |= (v19 << v13++);
        }
        while (v13 != 6);
        if (v14)
        {
          *(unsigned char *)(*(void *)(a1 + 872) + result) = v14;
          *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v7);
          uint64_t result = (result + 1);
        }
      }
    }
    ++v7;
  }
  while (v7 != a3);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x8<true,false>(int32x2_t *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  if ((a2 & 7) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 3;
  uint64_t v15 = (a3 + 7) >> 3;
  uint64_t v16 = a1[110].u32[0];
  if (v16)
  {
    uint64_t v17 = 0;
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    v20.i64[0] = 0x8000000080000000;
    v20.i64[1] = 0x8000000080000000;
    long long v21 = a1;
    do
    {
      for (uint64_t i = 0; i != 12; i += 2)
      {
        int32x4_t v23 = *(int32x4_t *)v21[i].i8;
        int8x16_t v24 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 0);
        float32x4_t v25 = (int8x16_t *)&v73[2 * v18 + 36];
        *float32x4_t v25 = v24;
        v25[1] = v24;
        int8x16_t v26 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 1);
        v25[2] = v26;
        v25[3] = v26;
        int8x16_t v27 = (int8x16_t)vdupq_laneq_s32(v23, 2);
        int32x4_t v28 = vdupq_laneq_s32(v23, 3);
        v25[4] = v27;
        v25[5] = v27;
        v25[6] = (int8x16_t)v28;
        v25[7] = (int8x16_t)v28;
        int32x4_t v29 = (int8x16_t *)&v73[2 * v19];
        int8x16_t v30 = vandq_s8(v24, v20);
        *int32x4_t v29 = v30;
        v29[1] = v30;
        int8x16_t v31 = vandq_s8(v26, v20);
        void v29[2] = v31;
        v29[3] = v31;
        int8x16_t v32 = vandq_s8(v27, v20);
        v29[4] = v32;
        v29[5] = v32;
        v18 += 4;
        v19 += 3;
      }
      ++v17;
      v21 += 12;
    }
    while (v17 != v16);
  }
  if (v14 >= v15) {
    return 0;
  }
  uint64_t result = 0;
  int32x2_t v34 = a1[97];
  int32x2_t v35 = (const float *)&a1[102];
  int8x16_t v36 = (int8x16_t)vdupq_n_s32(a1[104].i32[1] | (~a1[105].i32[0] << 8));
  int8x16_t v37 = (int8x16_t)vdupq_lane_s32(a1[104], 0);
  int32x2_t v38 = a1[98];
  int8x16_t v39 = (int8x16_t)vld1q_dup_f32(v35);
  float32x4_t v40 = (const float *)&a1[102] + 1;
  int8x16_t v41 = (const float *)&a1[103];
  int8x16_t v42 = (const float *)&a1[103] + 1;
  int8x16_t v43 = (int8x16_t)vld1q_dup_f32(v41);
  int32x2_t v44 = a1[99];
  int8x16_t v45 = (int8x16_t)vld1q_dup_f32(v40);
  int8x16_t v46 = (int8x16_t)vld1q_dup_f32(v42);
  int32x2_t v47 = a1[96];
  do
  {
    int8x16_t v48 = (int8x16_t *)(*(void *)&v38 + 32 * v14);
    int8x16_t v49 = *v48;
    int8x16_t v50 = v48[1];
    int8x16_t v51 = vandq_s8(*v48, v39);
    int8x16_t v52 = (int8x16_t *)(*(void *)&v44 + 32 * v14);
    int8x16_t v53 = v52[1];
    int8x16_t v54 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*v52, v45), v51)), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v53, v45), vandq_s8(v50, v39))));
    uint16x8_t v55 = *(uint16x8_t *)(*(void *)&v34 + 16 * v14);
    int8x16_t v56 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v55.i8);
    int8x16_t v57 = (int8x16_t)vmovl_high_u16(v55);
    *(int8x8_t *)v50.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v37, v56)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v37, v57)))), v54), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(*v52, v46), vandq_s8(v49, v43)), vandq_s8(v36, v56))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(v53, v46), vandq_s8(v50, v43)), vandq_s8(v36, v57))))));
    int32x4_t v58 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v36.i8)), 0x1FuLL));
    int32x4_t v59 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v36.i8)), 0x1FuLL));
    if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)v59, (int8x16_t)v58)) & 0x80000000) != 0)
    {
      if (v16)
      {
        unsigned int v60 = 0;
        int v61 = 0;
        int v62 = 0;
        uint64_t v63 = *(void *)&v47 + 192 * v14;
        do
        {
          int v64 = 0;
          unsigned int v65 = v60;
          do
          {
            uint64_t v66 = (int8x16_t *)&v73[2 * v65];
            int8x16_t v67 = (float32x4_t *)&v73[2 * (v61 + v64) + 36];
            int32x4_t v58 = (int32x4_t)vandq_s8((int8x16_t)v58, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v67[7], v67[1], vsubq_f32(*(float32x4_t *)(v63 + 16), (float32x4_t)veorq_s8(v66[1], *(int8x16_t *)(v63 + 112)))), v67[3], vsubq_f32(*(float32x4_t *)(v63 + 48), (float32x4_t)veorq_s8(v66[3], *(int8x16_t *)(v63 + 144)))), v67[5], vsubq_f32(*(float32x4_t *)(v63 + 80), (float32x4_t)veorq_s8(v66[5], *(int8x16_t *)(v63 + 176)))));
            int32x4_t v59 = (int32x4_t)vandq_s8((int8x16_t)v59, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v67[6], *v67, vsubq_f32(*(float32x4_t *)v63, (float32x4_t)veorq_s8(*v66, *(int8x16_t *)(v63 + 96)))), v67[2], vsubq_f32(*(float32x4_t *)(v63 + 32), (float32x4_t)veorq_s8(v66[2], *(int8x16_t *)(v63 + 128)))), v67[4], vsubq_f32(*(float32x4_t *)(v63 + 64), (float32x4_t)veorq_s8(v66[4], *(int8x16_t *)(v63 + 160)))));
            v65 += 3;
            v64 += 4;
          }
          while (v64 != 24);
          v60 += 18;
          ++v62;
          v61 += 24;
        }
        while (v62 != v16);
      }
      int8x16_t v68 = vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(v59), (int8x16_t)xmmword_20B5CBD00), vandq_s8((int8x16_t)vcltzq_s32(v58), (int8x16_t)xmmword_20B5CBCF0));
      *(int8x8_t *)v68.i8 = vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
      unsigned __int32 v69 = vadd_s32(*(int32x2_t *)v68.i8, vdup_lane_s32(*(int32x2_t *)v68.i8, 1)).u32[0];
      unsigned int v70 = 8 * v14;
      if (v69) {
        BOOL v71 = v70 >= a3;
      }
      else {
        BOOL v71 = 1;
      }
      if (!v71)
      {
        int32x2_t v72 = a1[108];
        do
        {
          if (v69)
          {
            *(_DWORD *)(*(void *)&v72 + 4 * result) = v70;
            uint64_t result = (result + 1);
          }
          if (v69 < 2) {
            break;
          }
          ++v70;
          v69 >>= 1;
        }
        while (v70 < a3);
      }
    }
    ++v14;
  }
  while (v14 != v15);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x4<true,false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if ((a2 & 3) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 2;
  uint64_t v15 = (a3 + 3) >> 2;
  uint64_t v16 = *(unsigned int *)(a1 + 880);
  if (v16)
  {
    uint64_t v17 = 0;
    unsigned int v18 = 0;
    int v19 = 0;
    v20.i64[0] = 0x8000000080000000;
    v20.i64[1] = 0x8000000080000000;
    uint64_t v21 = a1;
    do
    {
      for (uint64_t i = 0; i != 96; i += 16)
      {
        int32x4_t v23 = *(int32x4_t *)(v21 + i);
        int8x16_t v24 = (int8x16_t *)&v63[v18 + 18];
        int8x16_t v25 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 0);
        int8x16_t v26 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 1);
        *int8x16_t v24 = v25;
        v24[1] = v26;
        int8x16_t v27 = (int8x16_t)vdupq_laneq_s32(v23, 2);
        v24[2] = v27;
        v24[3] = (int8x16_t)vdupq_laneq_s32(v23, 3);
        int32x4_t v28 = (int8x16_t *)&v63[v19];
        *int32x4_t v28 = vandq_s8(v25, v20);
        v28[1] = vandq_s8(v26, v20);
        v28[2] = vandq_s8(v27, v20);
        v18 += 4;
        v19 += 3;
      }
      ++v17;
      v21 += 96;
    }
    while (v17 != v16);
  }
  if (v14 >= v15) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v30 = *(void *)(a1 + 768);
  uint64_t v31 = *(void *)(a1 + 776);
  int8x16_t v32 = (const float *)(a1 + 816);
  int8x16_t v33 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  int32x2_t v34 = (const float *)(a1 + 832);
  int32x4_t v35 = (int32x4_t)vld1q_dup_f32(v34);
  uint64_t v36 = *(void *)(a1 + 784);
  int8x16_t v37 = (const float *)(a1 + 820);
  int8x16_t v38 = (int8x16_t)vld1q_dup_f32(v32);
  int8x16_t v39 = (const float *)(a1 + 824);
  float32x4_t v40 = (const float *)(a1 + 828);
  int8x16_t v41 = (int8x16_t)vld1q_dup_f32(v39);
  int8x16_t v42 = (int8x16_t)vld1q_dup_f32(v37);
  int8x16_t v43 = (int8x16_t)vld1q_dup_f32(v40);
  uint64_t v44 = *(void *)(a1 + 792);
  do
  {
    int8x16_t v45 = *(int8x16_t *)(v36 + 16 * v14);
    int8x16_t v46 = *(int8x16_t *)(v44 + 16 * v14);
    int8x16_t v47 = (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v46, v42), vandq_s8(v45, v38)));
    int8x16_t v48 = vorrq_s8(vandq_s8(v46, v43), vandq_s8(v45, v41));
    int32x4_t v49 = (int32x4_t)vmovl_u16(*(uint16x4_t *)(v31 + 8 * v14));
    int32x4_t v50 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)vtstq_s32(v35, v49), v47), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(v48, vandq_s8(v33, (int8x16_t)v49))));
    if ((vmaxvq_u32((uint32x4_t)v50) & 0x80000000) != 0)
    {
      if (v16)
      {
        unsigned int v51 = 0;
        int v52 = 0;
        int v53 = 0;
        do
        {
          int v55 = 0;
          unsigned int v56 = v51;
          do
          {
            int8x16_t v57 = (float32x4_t *)&v63[(v52 + v55) + 18];
            uint64_t v54 = v30 + 96 * v14;
            int32x4_t v50 = (int32x4_t)vandq_s8((int8x16_t)v50, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v57[3], *v57, vsubq_f32(*(float32x4_t *)v54, (float32x4_t)veorq_s8((int8x16_t)v63[v56], *(int8x16_t *)(v54 + 48)))), v57[1], vsubq_f32(*(float32x4_t *)(v54 + 16), (float32x4_t)veorq_s8((int8x16_t)v63[v56 + 1], *(int8x16_t *)(v54 + 64)))), v57[2], vsubq_f32(*(float32x4_t *)(v54 + 32), (float32x4_t)veorq_s8((int8x16_t)v63[v56 + 2], *(int8x16_t *)(v54 + 80)))));
            v56 += 3;
            v55 += 4;
          }
          while (v55 != 24);
          v51 += 18;
          ++v53;
          v52 += 24;
        }
        while (v53 != v16);
      }
      int8x16_t v58 = vandq_s8((int8x16_t)vcltzq_s32(v50), (int8x16_t)xmmword_20B5CBD00);
      *(int8x8_t *)v58.i8 = vorr_s8(*(int8x8_t *)v58.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL));
      unsigned __int32 v59 = vadd_s32(*(int32x2_t *)v58.i8, vdup_lane_s32(*(int32x2_t *)v58.i8, 1)).u32[0];
      unsigned int v60 = 4 * v14;
      if (v59) {
        BOOL v61 = v60 >= a3;
      }
      else {
        BOOL v61 = 1;
      }
      if (!v61)
      {
        uint64_t v62 = *(void *)(a1 + 864);
        do
        {
          if (v59)
          {
            *(_DWORD *)(v62 + 4 * result) = v60;
            uint64_t result = (result + 1);
          }
          if (v59 < 2) {
            break;
          }
          ++v60;
          v59 >>= 1;
        }
        while (v60 < a3);
      }
    }
    ++v14;
  }
  while (v14 != v15);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x1<true,false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  int v5 = *(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8);
  int v6 = *(_DWORD *)(a1 + 832);
  uint64_t v7 = *(void *)(a1 + 816);
  uint64_t v8 = *(void *)(a1 + 824);
  uint64_t v9 = *(void *)(a1 + 864);
  uint64_t v10 = a2;
  do
  {
    int v11 = *(unsigned __int16 *)(*(void *)(a1 + 776) + 2 * v10);
    int v12 = v6 & v11;
    int v13 = v5 & v11;
    if (v12) {
      BOOL v14 = v13 == 0;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14)
    {
      unint64_t v15 = *(unsigned int *)(*(void *)(a1 + 784) + 4 * v10) | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 792) + 4 * v10) << 32);
      unint64_t v16 = v15 & v7;
      unint64_t v17 = v8 & v15;
      if (v16 && v17 == 0)
      {
        uint64_t v19 = 0;
        long long v20 = *(_OWORD *)(a1 + 48);
        v27[2] = *(_OWORD *)(a1 + 32);
        void v27[3] = v20;
        long long v21 = *(_OWORD *)(a1 + 80);
        v27[4] = *(_OWORD *)(a1 + 64);
        v27[5] = v21;
        long long v22 = *(_OWORD *)(a1 + 16);
        v27[0] = *(_OWORD *)a1;
        v27[1] = v22;
        int32x4_t v23 = (float32x4_t *)(*(void *)(a1 + 768) + 32 * v10);
        while (1)
        {
          float32x4_t v24 = (float32x4_t)v27[v19];
          int8x16_t v25 = (int8x16_t)vmulq_f32(*v23, v24);
          float32x4_t v26 = vmulq_f32(v23[1], vabsq_f32(v24));
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL))) > vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]) {
            break;
          }
          if (++v19 == 6)
          {
            *(_DWORD *)(v9 + 4 * result) = v10;
            uint64_t result = (result + 1);
            break;
          }
        }
      }
    }
    ++v10;
  }
  while (v10 != a3);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x8<false,false>(int32x2_t *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  if ((a2 & 7) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 3;
  uint64_t v15 = (a3 + 7) >> 3;
  uint64_t v16 = a1[110].u32[0];
  if (v16)
  {
    uint64_t v17 = 0;
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    v20.i64[0] = 0x8000000080000000;
    v20.i64[1] = 0x8000000080000000;
    long long v21 = a1;
    do
    {
      for (uint64_t i = 0; i != 12; i += 2)
      {
        int32x4_t v23 = *(int32x4_t *)v21[i].i8;
        int8x16_t v24 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 0);
        int8x16_t v25 = (int8x16_t *)&v73[2 * v18 + 36];
        *int8x16_t v25 = v24;
        v25[1] = v24;
        int8x16_t v26 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 1);
        v25[2] = v26;
        v25[3] = v26;
        int8x16_t v27 = (int8x16_t)vdupq_laneq_s32(v23, 2);
        int32x4_t v28 = vdupq_laneq_s32(v23, 3);
        v25[4] = v27;
        v25[5] = v27;
        v25[6] = (int8x16_t)v28;
        v25[7] = (int8x16_t)v28;
        int32x4_t v29 = (int8x16_t *)&v73[2 * v19];
        int8x16_t v30 = vandq_s8(v24, v20);
        *int32x4_t v29 = v30;
        v29[1] = v30;
        int8x16_t v31 = vandq_s8(v26, v20);
        void v29[2] = v31;
        v29[3] = v31;
        int8x16_t v32 = vandq_s8(v27, v20);
        v29[4] = v32;
        v29[5] = v32;
        v18 += 4;
        v19 += 3;
      }
      ++v17;
      v21 += 12;
    }
    while (v17 != v16);
  }
  if (v14 >= v15) {
    return 0;
  }
  uint64_t result = 0;
  int32x2_t v34 = a1[97];
  int8x16_t v35 = (int8x16_t)vdupq_n_s32(a1[104].i32[1] | (~a1[105].i32[0] << 8));
  int8x16_t v36 = (int8x16_t)vdupq_lane_s32(a1[104], 0);
  int8x16_t v37 = (const float *)&a1[102];
  int32x2_t v38 = a1[98];
  int8x16_t v39 = (const float *)&a1[102] + 1;
  int8x16_t v40 = (int8x16_t)vld1q_dup_f32(v37);
  int8x16_t v41 = (const float *)&a1[103];
  int8x16_t v42 = (const float *)&a1[103] + 1;
  int8x16_t v43 = (int8x16_t)vld1q_dup_f32(v41);
  int32x2_t v44 = a1[99];
  int8x16_t v45 = (int8x16_t)vld1q_dup_f32(v39);
  int8x16_t v46 = (int8x16_t)vld1q_dup_f32(v42);
  int32x2_t v47 = a1[96];
  unsigned int v48 = a2 & 0xFFFFFFF8;
  do
  {
    int32x4_t v49 = (int8x16_t *)(*(void *)&v38 + 32 * v14);
    int8x16_t v50 = *v49;
    int8x16_t v51 = v49[1];
    int8x16_t v52 = vandq_s8(*v49, v40);
    int v53 = (int8x16_t *)(*(void *)&v44 + 32 * v14);
    int8x16_t v54 = v53[1];
    int8x16_t v55 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(*v53, v45), v52)), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v54, v45), vandq_s8(v51, v40))));
    uint16x8_t v56 = *(uint16x8_t *)(*(void *)&v34 + 16 * v14);
    int8x16_t v57 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v56.i8);
    int8x16_t v58 = (int8x16_t)vmovl_high_u16(v56);
    *(int8x8_t *)v51.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, v57)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, v58)))), v55), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(*v53, v46), vandq_s8(v50, v43)), vandq_s8(v35, v57))), (int16x8_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8(v54, v46), vandq_s8(v51, v43)), vandq_s8(v35, v58))))));
    int32x4_t v59 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v35.i8)), 0x1FuLL));
    int32x4_t v60 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v35.i8)), 0x1FuLL));
    if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)v60, (int8x16_t)v59)) & 0x80000000) != 0)
    {
      if (v16)
      {
        unsigned int v61 = 0;
        int v62 = 0;
        int v63 = 0;
        uint64_t v64 = *(void *)&v47 + 192 * v14;
        do
        {
          int v65 = 0;
          unsigned int v66 = v61;
          do
          {
            int8x16_t v67 = (int8x16_t *)&v73[2 * v66];
            int8x16_t v68 = (float32x4_t *)&v73[2 * (v62 + v65) + 36];
            int32x4_t v59 = (int32x4_t)vandq_s8((int8x16_t)v59, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v68[7], v68[1], vsubq_f32(*(float32x4_t *)(v64 + 16), (float32x4_t)veorq_s8(v67[1], *(int8x16_t *)(v64 + 112)))), v68[3], vsubq_f32(*(float32x4_t *)(v64 + 48), (float32x4_t)veorq_s8(v67[3], *(int8x16_t *)(v64 + 144)))), v68[5], vsubq_f32(*(float32x4_t *)(v64 + 80), (float32x4_t)veorq_s8(v67[5], *(int8x16_t *)(v64 + 176)))));
            int32x4_t v60 = (int32x4_t)vandq_s8((int8x16_t)v60, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v68[6], *v68, vsubq_f32(*(float32x4_t *)v64, (float32x4_t)veorq_s8(*v67, *(int8x16_t *)(v64 + 96)))), v68[2], vsubq_f32(*(float32x4_t *)(v64 + 32), (float32x4_t)veorq_s8(v67[2], *(int8x16_t *)(v64 + 128)))), v68[4], vsubq_f32(*(float32x4_t *)(v64 + 64), (float32x4_t)veorq_s8(v67[4], *(int8x16_t *)(v64 + 160)))));
            v66 += 3;
            v65 += 4;
          }
          while (v65 != 24);
          v61 += 18;
          ++v63;
          v62 += 24;
        }
        while (v63 != v16);
      }
      int8x16_t v69 = vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(v60), (int8x16_t)xmmword_20B5CBD00), vandq_s8((int8x16_t)vcltzq_s32(v59), (int8x16_t)xmmword_20B5CBCF0));
      *(int8x8_t *)v69.i8 = vorr_s8(*(int8x8_t *)v69.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
      unsigned __int32 v70 = vadd_s32(*(int32x2_t *)v69.i8, vdup_lane_s32(*(int32x2_t *)v69.i8, 1)).u32[0];
      if (v70) {
        BOOL v71 = 8 * (int)v14 >= a3;
      }
      else {
        BOOL v71 = 1;
      }
      unint64_t v72 = v48;
      if (!v71)
      {
        do
        {
          if (v70)
          {
            *(void *)(*(void *)&a1[107] + 8 * result) = *(void *)(*(void *)&a1[101] + 8 * v72);
            uint64_t result = (result + 1);
          }
          if (v70 < 2) {
            break;
          }
          ++v72;
          v70 >>= 1;
        }
        while (v72 < a3);
      }
    }
    ++v14;
    v48 += 8;
  }
  while (v14 != v15);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x4<false,false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if ((a2 & 3) != 0)
  {
    int v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DCullingSystem_AABBRange_x8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a2 >> 2;
  uint64_t v15 = (a3 + 3) >> 2;
  uint64_t v16 = *(unsigned int *)(a1 + 880);
  if (v16)
  {
    uint64_t v17 = 0;
    unsigned int v18 = 0;
    int v19 = 0;
    v20.i64[0] = 0x8000000080000000;
    v20.i64[1] = 0x8000000080000000;
    uint64_t v21 = a1;
    do
    {
      for (uint64_t i = 0; i != 96; i += 16)
      {
        int32x4_t v23 = *(int32x4_t *)(v21 + i);
        int8x16_t v24 = (int8x16_t *)&v63[v18 + 18];
        int8x16_t v25 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 0);
        int8x16_t v26 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v23.i8, 1);
        *int8x16_t v24 = v25;
        v24[1] = v26;
        int8x16_t v27 = (int8x16_t)vdupq_laneq_s32(v23, 2);
        v24[2] = v27;
        v24[3] = (int8x16_t)vdupq_laneq_s32(v23, 3);
        int32x4_t v28 = (int8x16_t *)&v63[v19];
        *int32x4_t v28 = vandq_s8(v25, v20);
        v28[1] = vandq_s8(v26, v20);
        v28[2] = vandq_s8(v27, v20);
        v18 += 4;
        v19 += 3;
      }
      ++v17;
      v21 += 96;
    }
    while (v17 != v16);
  }
  if (v14 >= v15) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v30 = *(void *)(a1 + 768);
  uint64_t v31 = *(void *)(a1 + 776);
  int8x16_t v32 = (int8x16_t)vdupq_n_s32(*(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8));
  int8x16_t v33 = (const float *)(a1 + 816);
  int32x2_t v34 = (const float *)(a1 + 832);
  int32x4_t v35 = (int32x4_t)vld1q_dup_f32(v34);
  uint64_t v36 = *(void *)(a1 + 784);
  int8x16_t v37 = (const float *)(a1 + 820);
  int8x16_t v38 = (int8x16_t)vld1q_dup_f32(v33);
  int8x16_t v39 = (const float *)(a1 + 824);
  int8x16_t v40 = (const float *)(a1 + 828);
  int8x16_t v41 = (int8x16_t)vld1q_dup_f32(v39);
  uint64_t v42 = *(void *)(a1 + 792);
  int8x16_t v43 = (int8x16_t)vld1q_dup_f32(v37);
  int8x16_t v44 = (int8x16_t)vld1q_dup_f32(v40);
  unsigned int v45 = a2 & 0xFFFFFFFC;
  do
  {
    int8x16_t v46 = *(int8x16_t *)(v36 + 16 * v14);
    int8x16_t v47 = *(int8x16_t *)(v42 + 16 * v14);
    int8x16_t v48 = (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(v47, v43), vandq_s8(v46, v38)));
    int8x16_t v49 = vorrq_s8(vandq_s8(v47, v44), vandq_s8(v46, v41));
    int32x4_t v50 = (int32x4_t)vmovl_u16(*(uint16x4_t *)(v31 + 8 * v14));
    int32x4_t v51 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)vtstq_s32(v35, v50), v48), (int8x16_t)vceqzq_s32((int32x4_t)vorrq_s8(v49, vandq_s8(v32, (int8x16_t)v50))));
    if ((vmaxvq_u32((uint32x4_t)v51) & 0x80000000) != 0)
    {
      if (v16)
      {
        unsigned int v52 = 0;
        int v53 = 0;
        int v54 = 0;
        do
        {
          int v56 = 0;
          unsigned int v57 = v52;
          do
          {
            int8x16_t v58 = (float32x4_t *)&v63[(v53 + v56) + 18];
            uint64_t v55 = v30 + 96 * v14;
            int32x4_t v51 = (int32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v58[3], *v58, vsubq_f32(*(float32x4_t *)v55, (float32x4_t)veorq_s8((int8x16_t)v63[v57], *(int8x16_t *)(v55 + 48)))), v58[1], vsubq_f32(*(float32x4_t *)(v55 + 16), (float32x4_t)veorq_s8((int8x16_t)v63[v57 + 1], *(int8x16_t *)(v55 + 64)))), v58[2], vsubq_f32(*(float32x4_t *)(v55 + 32), (float32x4_t)veorq_s8((int8x16_t)v63[v57 + 2], *(int8x16_t *)(v55 + 80)))));
            v57 += 3;
            v56 += 4;
          }
          while (v56 != 24);
          v52 += 18;
          ++v54;
          v53 += 24;
        }
        while (v54 != v16);
      }
      int8x16_t v59 = vandq_s8((int8x16_t)vcltzq_s32(v51), (int8x16_t)xmmword_20B5CBD00);
      *(int8x8_t *)v59.i8 = vorr_s8(*(int8x8_t *)v59.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL));
      unsigned __int32 v60 = vadd_s32(*(int32x2_t *)v59.i8, vdup_lane_s32(*(int32x2_t *)v59.i8, 1)).u32[0];
      if (v60) {
        BOOL v61 = 4 * (int)v14 >= a3;
      }
      else {
        BOOL v61 = 1;
      }
      unint64_t v62 = v45;
      if (!v61)
      {
        do
        {
          if (v60)
          {
            *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v62);
            uint64_t result = (result + 1);
          }
          if (v60 < 2) {
            break;
          }
          ++v62;
          v60 >>= 1;
        }
        while (v62 < a3);
      }
    }
    ++v14;
    v45 += 4;
  }
  while (v14 != v15);
  return result;
}

uint64_t C3DCullingSystem_CullRange_x1<false,false>(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  int v5 = *(_DWORD *)(a1 + 836) | (~*(_DWORD *)(a1 + 840) << 8);
  int v6 = *(_DWORD *)(a1 + 832);
  uint64_t v7 = *(void *)(a1 + 816);
  uint64_t v8 = *(void *)(a1 + 824);
  uint64_t v9 = a2;
  do
  {
    int v10 = *(unsigned __int16 *)(*(void *)(a1 + 776) + 2 * v9);
    int v11 = v6 & v10;
    int v12 = v5 & v10;
    if (v11) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      unint64_t v14 = *(unsigned int *)(*(void *)(a1 + 784) + 4 * v9) | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 792) + 4 * v9) << 32);
      unint64_t v15 = v14 & v7;
      unint64_t v16 = v8 & v14;
      if (v15 && v16 == 0)
      {
        uint64_t v18 = 0;
        long long v19 = *(_OWORD *)(a1 + 48);
        v26[2] = *(_OWORD *)(a1 + 32);
        v26[3] = v19;
        long long v20 = *(_OWORD *)(a1 + 80);
        v26[4] = *(_OWORD *)(a1 + 64);
        v26[5] = v20;
        long long v21 = *(_OWORD *)(a1 + 16);
        v26[0] = *(_OWORD *)a1;
        v26[1] = v21;
        long long v22 = (float32x4_t *)(*(void *)(a1 + 768) + 32 * v9);
        while (1)
        {
          float32x4_t v23 = (float32x4_t)v26[v18];
          int8x16_t v24 = (int8x16_t)vmulq_f32(*v22, v23);
          float32x4_t v25 = vmulq_f32(v22[1], vabsq_f32(v23));
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL))) > vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]) {
            break;
          }
          if (++v18 == 6)
          {
            *(void *)(*(void *)(a1 + 856) + 8 * result) = *(void *)(*(void *)(a1 + 808) + 8 * v9);
            uint64_t result = (result + 1);
            break;
          }
        }
      }
    }
    ++v9;
  }
  while (v9 != a3);
  return result;
}

void OUTLINED_FUNCTION_2_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x12u);
}

void C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_grow(uint64_t a1)
{
  unsigned int v2 = *(void **)a1;
  unsigned int v3 = *(uint64_t **)(a1 + 8);
  unsigned int v4 = *(__int16 **)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 28);
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v5 != -15)
  {
    uint64_t v7 = v3;
    uint64_t v8 = v2;
    uint64_t v9 = v4;
    do
    {
      __int16 v10 = *v9++;
      if (v10)
      {
        C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::insert(a1, *v8, v7);
        uint64_t v11 = *v7;
        *uint64_t v7 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  free(v3);
  free(v2);

  free(v4);
}

void C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>(uint64_t a1, void *a2)
{
  unsigned int v4 = *(_DWORD *)a1;
  unsigned int v5 = *(_DWORD *)a1 + 1;
  if (v5 > *(_DWORD *)(a1 + 4))
  {
    C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::GrowCapacityBy((unsigned int *)a1, 1, 0);
    unsigned int v4 = *(_DWORD *)a1;
    unsigned int v5 = *(_DWORD *)a1 + 1;
  }
  *(void *)(*(void *)(a1 + 8) + 8 * v4) = *a2;
  *(_DWORD *)a1 = v5;
}

__CFString *C3DMeshSourceSemanticToSemanticString(int a1)
{
  switch(a1)
  {
    case 0:
      unsigned int v1 = kC3DPositionKey;
      goto LABEL_10;
    case 1:
      unsigned int v1 = kC3DNormalKey;
      goto LABEL_10;
    case 2:
      unsigned int v1 = kC3DColorKey;
      goto LABEL_10;
    case 3:
      unsigned int v1 = kC3DTexcoordKey;
      goto LABEL_10;
    case 4:
      unsigned int v1 = kC3DTexTangentKey;
      goto LABEL_10;
    case 5:
      unsigned int v1 = kC3DSkinningJointsKey;
      goto LABEL_10;
    case 6:
      unsigned int v1 = kC3DSkinningWeightsKey;
LABEL_10:
      uint64_t result = *v1;
      break;
    case 7:
      uint64_t result = @"vertexCrease";
      break;
    case 8:
      uint64_t result = @"edgeCrease";
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t __GetSemanticFromSerializedSemanticString(const __CFString *a1)
{
  if (CFStringCompare(a1, @"vertex", 0))
  {
    if (CFStringCompare(a1, @"normal", 0))
    {
      if (CFStringCompare(a1, @"color", 0))
      {
        if (CFStringCompare(a1, @"texcoord", 0))
        {
          if (CFStringCompare(a1, @"textangent", 0))
          {
            if (CFStringCompare(a1, @"joints", 0))
            {
              if (CFStringCompare(a1, @"weights", 0)) {
                return -1;
              }
              else {
                return 6;
              }
            }
            else
            {
              return 5;
            }
          }
          else
          {
            return 4;
          }
        }
        else
        {
          return 3;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t C3DMeshSourceCreateMutableWithMutableData(__int16 a1, const void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a2)
  {
    unint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithData_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  if (a4 >= 5)
  {
    long long v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithData_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t v30 = (const void *)C3DSourceAccessorCreate(a3, a4, a5, a6, a7);
  uint64_t v31 = C3DMeshSourceCreateWithAccessor(v30, a1);
  *(void *)(v31 + 72) = CFRetain(a2);
  *(unsigned char *)(v31 + 88) |= 1u;
  C3DSourceAccessorSetSource((uint64_t)v30, v31);
  if (v30) {
    CFRelease(v30);
  }
  return v31;
}

uint64_t C3DMeshSourceCreateDeltaSource(uint64_t a1, uint64_t a2)
{
  uint64_t Content = C3DMeshSourceGetContent(a1);
  uint64_t v5 = v4;
  uint64_t v6 = C3DMeshSourceGetContent(a2);
  unint64_t v8 = v7;
  if (v5 == v7)
  {
    uint64_t v9 = v6;
    if (!Content && (__int16 v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
    {
      C3DMeshSourceCreateDeltaSource_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
      if (!v9)
      {
LABEL_5:
        uint64_t v18 = scn_default_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          C3DMeshSourceCreateDeltaSource_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
        }
      }
    }
    else if (!v9)
    {
      goto LABEL_5;
    }
    if ((v8 & 0xFF000000000000) == 0x1000000000000 && (v5 & 0xFF000000000000) == 0x1000000000000)
    {
      if (HIBYTE(v8) >= 3) {
        uint64_t v26 = 3;
      }
      else {
        uint64_t v26 = HIBYTE(v8);
      }
      uint64_t v27 = (const UInt8 *)malloc_type_malloc((4 * v26) * (unint64_t)v5, 0x96BB1F87uLL);
      CFDataRef v28 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v27, (4 * v26) * (unint64_t)v5, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
      if (v5)
      {
        unsigned int v29 = 0;
        unsigned int v30 = 0;
        uint64_t v31 = 0;
        do
        {
          if (v26)
          {
            int8x16_t v32 = (float *)(v9 + v30);
            uint64_t v33 = v26;
            int32x2_t v34 = (float *)v27;
            int32x4_t v35 = (float *)(Content + v29);
            do
            {
              float v36 = *v32++;
              float v37 = v36;
              float v38 = *v35++;
              *v34++ = v37 - v38;
              --v33;
            }
            while (v33);
          }
          ++v31;
          v30 += BYTE5(v8);
          v29 += BYTE5(v5);
          v27 += 4 * v26;
        }
        while (v31 != v5);
      }
      __int16 Semantic = C3DMeshSourceGetSemantic(a2);
      uint64_t v40 = C3DSizeOfBaseType(1);
      uint64_t v41 = C3DMeshSourceCreateWithData(Semantic, v28, 1, v26, v5, v40 * v26, 0);
      CFDataRef v42 = v28;
    }
    else
    {
      uint64_t v61 = C3DSizeOfBaseType(BYTE4(v5));
      int8x16_t v44 = (const UInt8 *)malloc_type_malloc(v61 * v5, 0xF4C6A125uLL);
      CFDataRef v60 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v44, v61 * v5, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
      if (v5)
      {
        uint64_t v48 = v9;
        uint64_t v49 = Content;
        unsigned int v50 = 0;
        unsigned int v51 = 0;
        uint64_t v52 = v5;
        do
        {
          *(double *)v53.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v5), (float *)(v49 + v50), v45, v46, v47);
          float32x4_t v62 = v53;
          *(double *)v56.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v8), (float *)(v48 + v51), v53, v54, v55);
          C3DConvertFloatingTypeFromFloat4(BYTE4(v5), (uint64_t)v44, vsubq_f32(v56, v62));
          v51 += BYTE5(v8);
          v50 += BYTE5(v5);
          v44 += v61;
          --v52;
        }
        while (v52);
      }
      __int16 v57 = C3DMeshSourceGetSemantic(a2);
      uint64_t v58 = C3DSizeOfBaseType(BYTE4(v5));
      uint64_t v41 = C3DMeshSourceCreateWithData(v57, v60, BYTE4(v5), 1, v5, v58, 0);
      CFDataRef v42 = v60;
    }
    CFRelease(v42);
    return v41;
  }
  int8x16_t v43 = scn_default_log();
  if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
    C3DMeshSourceCreateDeltaSource_cold_3(v8, v5, v43);
  }
  return 0;
}

uint64_t C3DMeshSourceCreateAbsoluteSource(uint64_t a1, uint64_t a2)
{
  uint64_t Content = C3DMeshSourceGetContent(a1);
  uint64_t v5 = v4;
  if (!Content)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateDeltaSource_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DMeshSourceGetContent(a2);
  unint64_t v16 = v15;
  if (!v14)
  {
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateAbsoluteSource_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    }
  }
  if (v5 != v16) {
    return 0;
  }
  if ((v16 & 0xFF000000000000) == 0x1000000000000 && (v5 & 0xFF000000000000) == 0x1000000000000)
  {
    if (HIBYTE(v16) >= 3) {
      uint64_t v25 = 3;
    }
    else {
      uint64_t v25 = HIBYTE(v16);
    }
    uint64_t v26 = (const UInt8 *)malloc_type_malloc((4 * v25) * (unint64_t)v5, 0xA7422CCAuLL);
    CFDataRef v27 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v26, (4 * v25) * (unint64_t)v5, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
    if (v5)
    {
      unsigned int v28 = 0;
      unsigned int v29 = 0;
      uint64_t v30 = 0;
      do
      {
        if (v25)
        {
          uint64_t v31 = (float *)(Content + v29);
          uint64_t v32 = v25;
          uint64_t v33 = (float *)v26;
          int32x2_t v34 = (float *)(v14 + v28);
          do
          {
            float v35 = *v31++;
            float v36 = v35;
            float v37 = *v34++;
            *v33++ = v36 + v37;
            --v32;
          }
          while (v32);
        }
        ++v30;
        v29 += BYTE5(v5);
        v28 += BYTE5(v16);
        v26 += 4 * v25;
      }
      while (v30 != v5);
    }
    __int16 Semantic = C3DMeshSourceGetSemantic(a2);
    uint64_t v39 = C3DSizeOfBaseType(1) * v25;
    __int16 v40 = Semantic;
    CFDataRef v41 = v27;
    int v42 = 1;
    uint64_t v43 = v25;
    uint64_t v44 = v5;
  }
  else
  {
    uint64_t v62 = C3DSizeOfBaseType(BYTE4(v5));
    float v46 = (const UInt8 *)malloc_type_malloc(v62 * v5, 0x6631CBEFuLL);
    CFDataRef v61 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v46, v62 * v5, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
    if (v5)
    {
      uint64_t v50 = v14;
      uint64_t v51 = Content;
      unsigned int v52 = 0;
      unsigned int v53 = 0;
      uint64_t v54 = v5;
      do
      {
        *(double *)v55.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v5), (float *)(v51 + v52), v47, v48, v49);
        float32x4_t v63 = v55;
        *(double *)v58.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v16), (float *)(v50 + v53), v55, v56, v57);
        C3DConvertFloatingTypeFromFloat4(BYTE4(v5), (uint64_t)v46, vaddq_f32(v63, v58));
        v53 += BYTE5(v16);
        v52 += BYTE5(v5);
        v46 += v62;
        --v54;
      }
      while (v54);
    }
    __int16 v59 = C3DMeshSourceGetSemantic(a2);
    uint64_t v39 = C3DSizeOfBaseType(BYTE4(v5));
    __int16 v40 = v59;
    CFDataRef v27 = v61;
    CFDataRef v41 = v61;
    int v42 = BYTE4(v5);
    uint64_t v43 = 1;
    uint64_t v44 = v5;
  }
  uint64_t v45 = C3DMeshSourceCreateWithData(v40, v41, v42, v43, v44, v39, 0);
  CFRelease(v27);
  return v45;
}

uint64_t C3DMeshSourceGetValueType(uint64_t a1)
{
  return C3DSourceAccessorGetComponentsValueType(*(void *)(a1 + 64));
}

uint64_t C3DMeshSourceCreatePackedCopy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DMeshSourceCreatePackedCopy_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DMeshSourceCreatePackedCopy_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  C3DMeshElementGetContent(a2, a3, (uint64_t)&v49);
  if (DWORD2(v49))
  {
    unint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 1;
    do
    {
      int v25 = BYTE11(v50);
      switch(BYTE11(v50))
      {
        case 4u:
          int v26 = *(_DWORD *)(v49 + 4 * (*((void *)&v51 + 1) + v52 * (v24 - 1)));
          int v27 = *(_DWORD *)(v49 + 4 * (*((void *)&v51 + 1) + v52 * v24));
          break;
        case 2u:
          int v26 = *(unsigned __int16 *)(v49 + 2 * (*((void *)&v51 + 1) + v52 * (v24 - 1)));
          int v27 = *(unsigned __int16 *)(v49 + 2 * (*((void *)&v51 + 1) + v52 * v24));
          break;
        case 1u:
          int v26 = *(unsigned __int8 *)(v49 + *((void *)&v51 + 1) + v52 * (v24 - 1));
          int v27 = *(unsigned __int8 *)(v49 + *((void *)&v51 + 1) + v52 * v24);
          break;
        default:
          unsigned int v28 = scn_default_log();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v54 = v25;
            _os_log_error_impl(&dword_20B249000, v28, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
          }
          int v27 = 0;
          int v26 = 0;
          break;
      }
      v23 += (v27 - v26);
      ++v22;
      v24 += 2;
    }
    while (v22 < DWORD2(v49));
  }
  else
  {
    uint64_t v23 = 0;
  }
  uint64_t Content = C3DMeshSourceGetContent(a1);
  unint64_t v31 = v30;
  uint64_t v32 = BYTE5(v30);
  if (BYTE5(v30) != C3DSizeOfBaseType(BYTE4(v30)))
  {
    int v42 = scn_default_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      C3DMeshSourceCreatePackedCopy_cold_1();
    }
    return 0;
  }
  if (!(v32 * v23)) {
    return 0;
  }
  CFIndex length = v32 * v23;
  uint64_t v33 = (const UInt8 *)malloc_type_malloc(v32 * v23, 0xB5DC1C45uLL);
  if (DWORD2(v49))
  {
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 1;
    do
    {
      int v37 = BYTE11(v50);
      switch(BYTE11(v50))
      {
        case 4u:
          int v38 = *(_DWORD *)(v49 + 4 * (*((void *)&v51 + 1) + v52 * (v36 - 1)));
          int v39 = *(_DWORD *)(v49 + 4 * (*((void *)&v51 + 1) + v52 * v36));
          break;
        case 2u:
          int v38 = *(unsigned __int16 *)(v49 + 2 * (*((void *)&v51 + 1) + v52 * (v36 - 1)));
          int v39 = *(unsigned __int16 *)(v49 + 2 * (*((void *)&v51 + 1) + v52 * v36));
          break;
        case 1u:
          int v38 = *(unsigned __int8 *)(v49 + *((void *)&v51 + 1) + v52 * (v36 - 1));
          int v39 = *(unsigned __int8 *)(v49 + *((void *)&v51 + 1) + v52 * v36);
          break;
        default:
          __int16 v40 = scn_default_log();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v54 = v37;
            _os_log_error_impl(&dword_20B249000, v40, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
          }
          int v39 = 0;
          int v38 = 0;
          break;
      }
      size_t v41 = (v39 - v38) * BYTE5(v31);
      memcpy((void *)&v33[v35], (const void *)(Content + v38 * BYTE5(v31)), v41);
      v35 += v41;
      ++v34;
      v36 += 2;
    }
    while (v34 < DWORD2(v49));
  }
  CFDataRef v44 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v33, length, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  __int16 Semantic = C3DMeshSourceGetSemantic(a1);
  uint64_t v46 = C3DSizeOfBaseType(BYTE6(v31));
  uint64_t v43 = C3DMeshSourceCreateWithData(Semantic, v44, BYTE6(v31), HIBYTE(v31), v23, v46 * HIBYTE(v31), 0);
  CFRelease(v44);
  return v43;
}

double C3DMeshSourceGetAbsoluteMaxValue(uint64_t a1)
{
  uint64_t Content = C3DMeshSourceGetContent(a1);
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t v8 = (float *)Content;
    int v9 = v2;
    uint64_t v10 = v3;
    float32x4_t v11 = 0uLL;
    do
    {
      float32x4_t v14 = v11;
      v12.i64[0] = COERCE_UNSIGNED_INT64(C3DConvertFloatingTypeToFloat4(v9, v8, v11, v4.f32[0], v5)) & 0x7FFFFFFF7FFFFFFFLL;
      v12.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
      float32x4_t v4 = vmaxnmq_f32(v14, v12);
      float32x4_t v11 = v4;
      uint64_t v8 = (float *)((char *)v8 + v10);
      --v7;
    }
    while (v7);
  }
  else
  {
    v11.i64[0] = 0;
  }
  return *(double *)v11.i64;
}

uint64_t C3DMeshSourceHasNonOpaqueColors(uint64_t a1)
{
  uint64_t result = C3DMeshSourceGetContent(a1);
  if (result)
  {
    if (v2)
    {
      uint64_t v8 = (float *)result;
      int v9 = v3;
      uint64_t v10 = v4;
      uint64_t v11 = v2 - 1;
      do
      {
        *(double *)v5.i64 = C3DConvertFloatingTypeToFloat4(v9, v8, v5, v6, v7);
        v5.i32[0] = v5.i32[3];
        uint64_t result = v5.f32[3] < 1.0;
        BOOL v12 = v5.f32[3] < 1.0 || v11-- == 0;
        uint64_t v8 = (float *)((char *)v8 + v10);
      }
      while (!v12);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t C3DMeshSourceCreateUnpackedCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreatePackedCopy_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  uint64_t Content = C3DMeshSourceGetContent(a1);
  if (!Content) {
    return 0;
  }
  uint64_t v18 = (char *)Content;
  unint64_t v19 = v17;
  uint64_t v54 = a1;
  uint64_t v60 = 0;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  C3DMeshElementGetContent(a2, a4, (uint64_t)&v57);
  if (BYTE10(v58) != 2)
  {
    uint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateUnpackedCopy_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    }
  }
  size_t v28 = C3DSizeOfBaseType(BYTE4(v19));
  uint64_t v55 = a3;
  CFIndex v51 = v28 * a3;
  float v56 = (const UInt8 *)malloc_type_malloc(v28 * a3, 0xB4EECD59uLL);
  uint64_t v52 = &v50;
  MEMORY[0x270FA5388](v56);
  bzero((char *)&v50 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0), v28);
  unint64_t v53 = v19;
  if (DWORD2(v57))
  {
    unint64_t v30 = 0;
    unsigned int v31 = 0;
    *(void *)&long long v29 = 67109120;
    long long v50 = v29;
    do
    {
      int v32 = BYTE11(v58);
      switch(BYTE11(v58))
      {
        case 4u:
          unsigned int v33 = *(_DWORD *)(v57 + 4 * (*((void *)&v59 + 1) + v60 * 2 * v30));
          unsigned int v34 = *(_DWORD *)(v57 + 4 * (*((void *)&v59 + 1) + v60 * ((2 * v30) | 1)));
          break;
        case 2u:
          unsigned int v33 = *(unsigned __int16 *)(v57 + 2 * (*((void *)&v59 + 1) + v60 * 2 * v30));
          unsigned int v34 = *(unsigned __int16 *)(v57 + 2 * (*((void *)&v59 + 1) + v60 * ((2 * v30) | 1)));
          break;
        case 1u:
          unsigned int v33 = *(unsigned __int8 *)(v57 + *((void *)&v59 + 1) + v60 * 2 * v30);
          unsigned int v34 = *(unsigned __int8 *)(v57 + *((void *)&v59 + 1) + v60 * ((2 * v30) | 1));
          break;
        default:
          uint64_t v35 = scn_default_log();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v50;
            int v62 = v32;
            _os_log_error_impl(&dword_20B249000, v35, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
          }
          unsigned int v34 = 0;
          unsigned int v33 = 0;
          break;
      }
      unsigned int v36 = v33 - v31;
      if (v33 > v31)
      {
        int v37 = (UInt8 *)&v56[v28 * v31];
        do
        {
          memcpy(v37, (char *)&v50 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0), v28);
          v37 += v28;
          --v36;
        }
        while (v36);
      }
      unsigned int v38 = v34 - v33;
      if (v34 > v33)
      {
        int v39 = (UInt8 *)&v56[v28 * v33];
        do
        {
          memcpy(v39, v18, v28);
          v18 += BYTE5(v19);
          v39 += v28;
          --v38;
        }
        while (v38);
      }
      ++v30;
      unsigned int v31 = v34;
    }
    while (v30 < DWORD2(v57));
  }
  else
  {
    unsigned int v34 = 0;
  }
  uint64_t v41 = v55;
  if (v55 > v34)
  {
    uint64_t v42 = v55 - v34;
    uint64_t v43 = (UInt8 *)&v56[v28 * v34];
    do
    {
      memcpy(v43, (char *)&v50 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0), v28);
      v43 += v28;
      --v42;
    }
    while (v42);
  }
  CFDataRef v44 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v56, v51, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  __int16 Semantic = C3DMeshSourceGetSemantic(v54);
  uint64_t v46 = HIBYTE(v53);
  int v47 = BYTE6(v53);
  uint64_t v48 = C3DSizeOfBaseType(BYTE6(v53));
  uint64_t v40 = C3DMeshSourceCreateWithData(Semantic, v44, v47, v46, v41, v48 * v46, 0);
  CFRelease(v44);
  return v40;
}

uint64_t C3DMeshSourceCreateCopy(uint64_t a1)
{
  uint64_t v2 = _C3DMeshSourceCreate();
  Copy = (const void *)C3DSourceAccessorCreateCopy(*(void *)(a1 + 64));
  C3DGenericSourceInit(v2, Copy);
  C3DSourceAccessorSetSource((uint64_t)Copy, v2);
  CFRelease(Copy);
  unsigned __int8 v4 = *(const void **)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5) {
    C3DGenericSourceSetMTLBuffer(v2, (uint64_t)v4, v5);
  }
  else {
    C3DGenericSourceSetData(v2, v4);
  }
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

uint64_t C3DMeshSourceCreateDeepCopy(uint64_t a1)
{
  uint64_t v2 = _C3DMeshSourceCreate();
  C3DGenericSourceInitDeepCopy(a1, v2);
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

uint64_t C3DMeshSourceCreateMutableCopy(uint64_t a1)
{
  uint64_t v2 = _C3DMeshSourceCreate();
  C3DGenericSourceInitMutableCopy(a1, v2);
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

double C3DMeshSourceGetValueAtIndexAsVector3(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    unsigned __int8 v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void **)(a1 + 64);
  ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(v12, a2);
  if (!ValuePtrAtIndex) {
    return 0.0;
  }
  uint64_t v14 = (float *)ValuePtrAtIndex;
  Vectorint Type = C3DSourceAccessorGetVectorType((uint64_t)v12);
  return C3DConvertFloatingTypeToFloat4(VectorType, v14, v16, v17, v18);
}

double C3DMeshSourceGetValueAtIndexAsVector2(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    unsigned __int8 v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void **)(a1 + 64);
  ValuePtrAtuint64_t Index = (float *)C3DSourceAccessorGetValuePtrAtIndex(v12, a2);
  Vectorint Type = C3DSourceAccessorGetVectorType((uint64_t)v12);
  return C3DConvertFloatingTypeToFloat4(VectorType, ValuePtrAtIndex, v15, v16, v17);
}

uint64_t C3DMeshSourceGetComponentsCountPerValue(uint64_t a1)
{
  return C3DSourceAccessorGetComponentsCountPerValue(*(void *)(a1 + 64));
}

uint64_t C3DMeshSourceCreateCopyWithComponentsBaseType(uint64_t a1, int a2)
{
  Accessor = (void *)C3DGenericSourceGetAccessor(a1);
  if (C3DSourceAccessorGetComponentsValueType((uint64_t)Accessor) != 1)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      C3DMeshSourceCreateCopyWithComponentsBaseType_cold_3();
    }
    return 0;
  }
  if (C3DSourceAccessorIsInterleaved((uint64_t)Accessor))
  {
    unsigned __int8 v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      C3DMeshSourceCreateCopyWithComponentsBaseType_cold_1();
    }
    return 0;
  }
  uint64_t v7 = C3DSizeOfBaseType(a2);
  uint64_t ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor);
  uint64_t v9 = ComponentsCountPerValue * v7;
  if (((ComponentsCountPerValue * v7) & 3) != 0) {
    uint64_t v10 = -(ComponentsCountPerValue * v7) & 3;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = v10 + v9;
  uint64_t v12 = (v10 + v9) * C3DSourceAccessorGetCount((uint64_t)Accessor);
  uint64_t v13 = (char *)C3DMalloc(v12);
  bzero(v13, v12);
  CFDataRef v14 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v13, v12, 0);
  LOWORD(v12) = C3DMeshSourceGetSemantic(a1);
  uint64_t v15 = C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor);
  uint64_t Count = C3DSourceAccessorGetCount((uint64_t)Accessor);
  uint64_t v31 = C3DMeshSourceCreateWithData(v12, v14, a2, v15, Count, v11, 0);
  uint64_t v17 = C3DGenericSourceGetAccessor(v31);
  C3DSourceAccessorSetPadding(v17, v10);
  if (C3DMeshSourceGetCount(a1) >= 1)
  {
    uint64_t v18 = 0;
    while (1)
    {
      ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(Accessor, v18);
      if (C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor) >= 1) {
        break;
      }
LABEL_35:
      ++v18;
      v13 += v11;
      if (v18 >= C3DMeshSourceGetCount(a1)) {
        goto LABEL_36;
      }
    }
    uint64_t v20 = 0;
    while (1)
    {
      if (a2 > 14)
      {
        if (a2 == 15)
        {
          int v24 = HIWORD(*(_DWORD *)ValuePtrAtIndex) & 0x8000;
          unsigned int v25 = (*(_DWORD *)ValuePtrAtIndex >> 23);
          unsigned int v26 = v25 - 112;
          unsigned int v27 = v25 - 113;
          __int16 v28 = v24 | 0x7BFF;
          if (v25 == 255) {
            __int16 v28 = v24 | ((*(_DWORD *)ValuePtrAtIndex & 0x7FFFFF) != 0) | 0x7C00;
          }
          if (v25 >= 0x71) {
            __int16 v29 = v28;
          }
          else {
            __int16 v29 = HIWORD(*(_DWORD *)ValuePtrAtIndex) & 0x8000;
          }
          int v21 = HIWORD(*(_DWORD *)ValuePtrAtIndex) & 0x8000 | (*(_DWORD *)ValuePtrAtIndex >> 13) & 0x3FF | (v26 << 10);
          if (v27 > 0x1D) {
            LOWORD(v21) = v29;
          }
LABEL_31:
          *(_WORD *)&v13[2 * v20] = v21;
          goto LABEL_34;
        }
        if (a2 != 16)
        {
LABEL_32:
          unint64_t v30 = scn_default_log();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            C3DMeshSourceCreateCopyWithComponentsBaseType_cold_2(&buf, v34, v30);
          }
          goto LABEL_34;
        }
        float v22 = *(float *)ValuePtrAtIndex;
        float v23 = 255.0;
      }
      else
      {
        if (a2 != 4)
        {
          if (a2 != 14) {
            goto LABEL_32;
          }
          int v21 = (int)(float)(*(float *)ValuePtrAtIndex * 32767.0);
          goto LABEL_31;
        }
        float v22 = *(float *)ValuePtrAtIndex;
        float v23 = 127.0;
      }
      v13[v20] = (int)(float)(v22 * v23);
LABEL_34:
      ++v20;
      ValuePtrAtIndex += 4;
      if (C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor) <= v20) {
        goto LABEL_35;
      }
    }
  }
LABEL_36:
  CFRelease(v14);
  return v31;
}

uint64_t C3DMeshSourceCreateCopyWithBaseType(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t Content = C3DMeshSourceGetContent(a1);
  unint64_t v8 = v7;
  Compoundint Type = C3DBaseTypeGetCompoundType(BYTE6(v7), HIBYTE(v7));
  if (CompoundType != a2)
  {
    unsigned int v11 = CompoundType;
    uint64_t v12 = C3DSizeOfBaseType(a2);
    uint64_t v13 = v12;
    if ((v12 & 3) != 0) {
      uint64_t v14 = -(int)v12 & 3;
    }
    else {
      uint64_t v14 = 0;
    }
    if (C3DConvertIsConvertible(a2, v11))
    {
      uint64_t v15 = v14 + v13;
      if (a3)
      {
        Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], v15 * v8);
        CFDataSetLength(Mutable, v15 * v8);
      }
      else
      {
        unint64_t v19 = (const UInt8 *)malloc_type_calloc(v15 * v8, 1uLL, 0xCFEB594AuLL);
        Mutable = CFDataCreateWithBytesNoCopy(0, v19, v15 * v8, 0);
      }
      BytePtr = CFDataGetBytePtr(Mutable);
      C3DConvertBatch((uint64_t)BytePtr, (unsigned __int16)(v14 + v13) | ((unsigned __int16)a2 << 16) | ((unint64_t)v8 << 32), Content, (v8 >> 16) & 0xFF0000 | BYTE5(v8) | ((unint64_t)v8 << 32));
      __int16 Semantic = C3DMeshSourceGetSemantic(a1);
      if (a3) {
        uint64_t MutableWithMutableData = C3DMeshSourceCreateMutableWithMutableData(Semantic, Mutable, a2, 1, v8, v15, 0);
      }
      else {
        uint64_t MutableWithMutableData = C3DMeshSourceCreateWithData(Semantic, Mutable, a2, 1, v8, v15, 0);
      }
      uint64_t v10 = MutableWithMutableData;
      CFRelease(Mutable);
      uint64_t Accessor = C3DGenericSourceGetAccessor(v10);
      C3DSourceAccessorSetPadding(Accessor, v14);
    }
    else
    {
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        C3DMeshSourceCreateCopyWithBaseType_cold_1(v11, a2, v18);
      }
      return 0;
    }
    return v10;
  }
  if (a3)
  {
    uint64_t v10 = _C3DMeshSourceCreate();
    C3DGenericSourceInitMutableCopy(a1, v10);
    *(_WORD *)(v10 + 96) = *(_WORD *)(a1 + 96);
    return v10;
  }

  return C3DMeshSourceCreateCopy(a1);
}

size_t C3DMeshSourcePrintData(uint64_t a1, uint64_t a2)
{
  size_t result = C3DMeshSourceGetContent(a1);
  if (result)
  {
    size_t v6 = result;
    uint64_t v7 = v5;
    int Semantic = C3DMeshSourceGetSemantic(a1);
    uint64_t v9 = C3DMeshSourceSemanticToSemanticString(Semantic);
    uint64_t v10 = (FILE **)MEMORY[0x263EF8358];
    unsigned int v11 = (FILE *)*MEMORY[0x263EF8358];
    CStringPtr = CFStringGetCStringPtr(v9, 0x600u);
    size_t result = fprintf(v11, "%s\n", CStringPtr);
    uint64_t v13 = v7 >= a2 ? a2 : v7;
    if (v13 >= 1)
    {
      uint64_t v14 = 0;
      while (1)
      {
        if (BYTE4(v7) <= 0x18u)
        {
          switch(BYTE4(v7))
          {
            case 8u:
              float v16 = *v10;
              goto LABEL_24;
            case 9u:
              uint64_t v17 = *v10;
              goto LABEL_25;
            case 0xAu:
              uint64_t v15 = *v10;
LABEL_26:
              size_t result = fprintf(v15, "%4d : %+.2f %+.2f %+.2f %+.2f\n");
              goto LABEL_27;
          }
          goto LABEL_22;
        }
        if (BYTE4(v7) > 0x2Bu) {
          break;
        }
        if (BYTE4(v7) != 25)
        {
          if (BYTE4(v7) == 43)
          {
            float v16 = *v10;
LABEL_24:
            size_t result = fprintf(v16, "%4d : %+.2f %+.2f\n");
            goto LABEL_27;
          }
          goto LABEL_22;
        }
        size_t result = fprintf(*v10, "%4d : %3d %3d %3d %3d\n");
LABEL_27:
        ++v14;
        v6 += BYTE5(v7);
        if (v13 == v14) {
          return result;
        }
      }
      if (BYTE4(v7) == 44)
      {
        uint64_t v17 = *v10;
LABEL_25:
        size_t result = fprintf(v17, "%4d : %+.2f %+.2f %+.2f\n");
        goto LABEL_27;
      }
      if (BYTE4(v7) == 45)
      {
        uint64_t v15 = *v10;
        goto LABEL_26;
      }
LABEL_22:
      size_t result = fwrite("type debugging not implemented\n", 0x1FuLL, 1uLL, *v10);
      goto LABEL_27;
    }
  }
  return result;
}

uint64_t C3DMeshSourceGetModelKitSemantic(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 99);
}

id _C3DMeshSourceCFFinalize(const void *a1)
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationMeshSourceWillDie", a1, 0, 1u);

  return _C3DGenericSourceCFFinalize((uint64_t)a1);
}

__CFString *_C3DMeshSourceCFCopyDebugDescription(uint64_t a1)
{
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  ComponentsValueint Type = C3DSourceAccessorGetComponentsValueType(*(void *)(a1 + 64));
  int ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue(*(void *)(a1 + 64));
  uint64_t Count = C3DMeshSourceGetCount(a1);
  uint64_t MTLBuffer = C3DGenericSourceGetMTLBuffer(a1);
  unsigned int IsMutable = C3DGenericSourceIsMutable(a1);
  uint64_t v8 = *(void *)(a1 + 64);
  if (MTLBuffer) {
    uint64_t Data = C3DGenericSourceGetMTLBuffer(a1);
  }
  else {
    uint64_t Data = (uint64_t)C3DGenericSourceGetData((void *)a1);
  }
  uint64_t v10 = Data;
  Compoundint Type = C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue);
  uint64_t v12 = C3DMeshSourceSemanticToSemanticString(*(char *)(a1 + 96));
  uint64_t v13 = C3DBaseTypeStringDescription(CompoundType);
  CFStringAppendFormat(Mutable, 0, @"<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%zu stride:%zu", a1, v12, v10, IsMutable, Count, v13, *(unsigned __int8 *)(a1 + 98), MTLBuffer != 0, *(void *)(v8 + 48), *(void *)(v8 + 40));
  CFStringAppend(Mutable, @">");
  return Mutable;
}

BOOL _C3DMeshSourceInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  BOOL result = _C3DGenericSourceInitWithPropertyList(a1, a2, (uint64_t)a4, a4);
  if (result)
  {
    if (!a2) {
      return 1;
    }
    if ((C3DCFTypeIsDictionary() & 1) == 0)
    {
      uint64_t v12 = scn_default_log();
      BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _C3DMeshSourceInitWithPropertyList_cold_2(v12);
      return 0;
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"semantic");
    if (Value)
    {
      int SemanticFromSerializedSemanticString = __GetSemanticFromSerializedSemanticString(Value);
      *(_WORD *)(a1 + 96) = SemanticFromSerializedSemanticString;
      if (SemanticFromSerializedSemanticString == 5)
      {
        uint64_t Accessor = C3DGenericSourceGetAccessor(a1);
        if (*(_WORD *)(Accessor + 24) == 26) {
          *(_WORD *)(Accessor + 24) = 25;
        }
      }
      CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(a2, @"mkSemantic");
      if (v11)
      {
        int valuePtr = 0;
        CFNumberGetValue(v11, kCFNumberIntType, &valuePtr);
        C3DMeshSourceSetModelKitSemantic(a1, valuePtr);
      }
      return 1;
    }
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      _C3DMeshSourceInitWithPropertyList_cold_1();
      if (a4)
      {
LABEL_15:
        if (!*a4)
        {
          CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
          BOOL result = 0;
          *a4 = MalformedDocumentError;
          return result;
        }
      }
    }
    else if (a4)
    {
      goto LABEL_15;
    }
    return 0;
  }
  return result;
}

__CFDictionary *_C3DMeshSourceCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = _C3DGenericSourceCopyPropertyList(a1, a2, a4, a4);
  if (!v5) {
    return v5;
  }
  __int16 v6 = *(_WORD *)(a1 + 96);
  if (!(_BYTE)v6)
  {
    uint64_t v7 = @"vertex";
    if (@"vertex") {
      goto LABEL_4;
    }
LABEL_6:
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      _C3DMeshSourceCopyPropertyList_cold_1();
    }
    goto LABEL_8;
  }
  uint64_t v7 = C3DMeshSourceSemanticToSemanticString((char)v6);
  if (!v7) {
    goto LABEL_6;
  }
LABEL_4:
  CFDictionarySetValue(v5, @"semantic", v7);
LABEL_8:
  if (*(unsigned char *)(a1 + 99))
  {
    int valuePtr = *(unsigned __int8 *)(a1 + 99);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(v5, @"mkSemantic", v9);
    CFRelease(v9);
  }
  return v5;
}

__CFArray *_C3DMeshSourceCopyInstanceVariables(uint64_t a1)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v17 = 2;
  int valuePtr = 5;
  uint64_t v16 = a1 + 64;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v3, @"name", @"accessor");
  CFDictionarySetValue(v3, @"type", v4);
  CFDictionarySetValue(v3, @"address", v6);
  CFDictionarySetValue(v3, @"semantic", v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  uint64_t v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v17 = 2;
  int valuePtr = 5;
  uint64_t v16 = a1 + 72;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v7, @"name", @"data");
  CFDictionarySetValue(v7, @"type", v8);
  CFDictionarySetValue(v7, @"address", v10);
  CFDictionarySetValue(v7, @"semantic", v9);
  CFArrayAppendValue(Mutable, v7);
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v10);
  CFRelease(v8);
  CFNumberRef v11 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v17 = 0;
  int valuePtr = 2;
  uint64_t v16 = a1 + 96;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v11, @"name", @"semantic");
  CFDictionarySetValue(v11, @"type", v12);
  CFDictionarySetValue(v11, @"address", v14);
  CFDictionarySetValue(v11, @"semantic", v13);
  CFArrayAppendValue(Mutable, v11);
  CFRelease(v13);
  CFRelease(v11);
  CFRelease(v14);
  CFRelease(v12);
  return Mutable;
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOne(SCNMTLComputeCommandEncoder *this, MTLComputePipelineState *a2)
{
  if (this->_computePipelineState != a2)
  {
    this->_computePipelineState = a2;
    [(MTLComputeCommandEncoder *)this->_encoder setComputePipelineState:a2];
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  encoder = this->_encoder;
  int64x2_t v7 = vdupq_n_s64(1uLL);
  uint64_t v8 = 1;
  int64x2_t v5 = v7;
  uint64_t v6 = 1;
  return [(MTLComputeCommandEncoder *)encoder dispatchThreadgroups:&v7 threadsPerThreadgroup:&v5];
}

void C3D::CopyProbeFromOldTextureToNewTexture(C3D::Pass *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, C3D::RefCountedResource *a6, int a7)
{
  uint64_t v45 = a1;
  uint64_t v12 = *((void *)a1 + 3);
  uint64_t v13 = a5 + 48;
  uint64_t v14 = [(id)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(a5 + 48) textureType];
  BOOL IsCube = SCNMTLTextureTypeIsCube(v14);
  uint64_t v16 = a3 + 48;
  uint64_t v17 = [(id)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v16) textureType];
  int v18 = SCNMTLTextureTypeIsCube(v17);
  uint64_t v19 = [(id)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v13) textureType];
  int v20 = SCNMTLTextureTypeIsCube(v19);
  if (v18 == v20)
  {
    if (IsCube) {
      int v28 = 6;
    }
    else {
      int v28 = 1;
    }
    LODWORD(v42) = v28 * a4;
    DWORD1(v42) = v28;
    *((void *)&v42 + 1) = 0x500000000;
    int v43 = v28 * a7;
    int v44 = 0;
    unsigned int v27 = C3D::RenderGraph::createPass<C3D::CopyTextureComputePass,C3D::Pass *&,C3D::CopyTextureComputePass::Parameters>(v12, &v45, (const Parameters *)&v42);
  }
  else
  {
    int v21 = v20;
    if (a7 | a4)
    {
      float v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
        C3D::CopyProbeFromOldTextureToNewTexture(v22, v23, v24);
      }
    }
    if (v18) {
      char v25 = 0;
    }
    else {
      char v25 = 2;
    }
    LOBYTE(v42) = v25;
    if (v21) {
      char v26 = 0;
    }
    else {
      char v26 = 2;
    }
    BYTE1(v42) = v26;
    unsigned int v27 = C3D::RenderGraph::createPass<C3D::ConvertCubePass,C3D::Pass *&,C3D::ConvertCubePass::Parameters>(v12, &v45, (const Parameters *)&v42);
    *(_WORD *)(C3D::Pass::descriptor(v27) + 10) = 5;
  }
  __int16 v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v27);
  uint64_t v30 = C3D::PassDescriptor::inputAtIndex(v29, 0);
  *(_WORD *)(v30 + 66) |= 0x100u;
  uint64_t v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v27);
  uint64_t v32 = C3D::PassDescriptor::outputAtIndex(v31, 0);
  *(_WORD *)(v32 + 66) |= 0x100u;
  unsigned int v33 = (void *)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v13);
  SCNMTLTextureDescFromMTLTexture(v33, (uint64_t)&v42);
  unsigned int v34 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v27);
  uint64_t v35 = C3D::PassDescriptor::outputAtIndex(v34, 0);
  *(_OWORD *)(v35 + 16) = v42;
  *(_DWORD *)(v35 + 32) = v43;
  id v36 = (id)C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v16);
  PersistentResource = (C3D::RefCountedResource *)C3D::RenderGraph::createPersistentResource(v12, (uint64_t)v36);
  unsigned int v38 = (C3D::PassResource *)C3D::Pass::resource(v27);
  C3D::PassResource::setInputAtIndex(v38, PersistentResource, 0);
  int v39 = (C3D::PassResource *)C3D::Pass::resource(v27);
  C3D::PassResource::setOutputAtIndex(v39, a6, 0);
  uint64_t v40 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v27);
  uint64_t v41 = C3D::PassDescriptor::outputAtIndex(v40, 0);
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(a2, v41);
  C3D::Pass::addDependency(v45, v27);
}

C3D::CopyTextureComputePass *C3D::RenderGraph::createPass<C3D::CopyTextureComputePass,C3D::Pass *&,C3D::CopyTextureComputePass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::CopyTextureComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 144, 8, 0);
  C3D::CopyTextureComputePass::CopyTextureComputePass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::CopyTextureComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ConvertCubePass *C3D::RenderGraph::createPass<C3D::ConvertCubePass,C3D::Pass *&,C3D::ConvertCubePass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::ConvertCubePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 320, 16, 0);
  C3D::ConvertCubePass::ConvertCubePass(Aligned, (C3D::RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ConvertCubePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

double C3D::ComputeProbeFromTextureOrPreviousPass(C3D::Pass *a1, uint64_t a2, C3D::RefCountedResource *a3, __int16 a4, void **a5, C3D::Pass *a6, unsigned __int16 a7, uint64_t a8)
{
  uint64_t v116 = *MEMORY[0x263EF8340];
  float32x4_t v112 = a1;
  uint64_t v15 = *((void *)a1 + 3);
  uint64_t v16 = *(void **)a3;
  long long v110 = 0uLL;
  int v111 = 0;
  SCNMTLTextureDescFromMTLTexture(v16, (uint64_t)&v110);
  BOOL IsCube = SCNMTLTextureTypeIsCube([v16 textureType]);
  C3D::PassIODescriptor::PassIODescriptor((uint64_t)v113, 0);
  long long v114 = v110;
  int v115 = v111;
  ArrayElementint Type = SCNMTLTextureTypeGetArrayElementType(BYTE8(v110));
  char v19 = 0;
  BYTE8(v114) = ArrayElementType;
  WORD3(v114) = 1;
  *(unsigned char *)(a8 + 16) = 0;
  unsigned int v20 = *(_DWORD *)(a8 + 20);
  if (v20 != 1)
  {
    if (IsCube) {
      char v19 = 1;
    }
    else {
      char v19 = 2;
    }
    *(unsigned char *)(a8 + 16) = v19;
  }
  LOBYTE(v10_Block_object_dispose(&STACK[0x2A0], 8) = v19;
  *(void *)((char *)&v108 + 4) = __PAIR64__(*(_DWORD *)a8, v20);
  int v21 = C3D::RenderGraph::createPass<C3D::ComputeRadiancePass,C3D::Pass *&,C3D::ComputeRadiancePass::Parameters>(v15, &v112, (const Parameters *)&v108);
  if (a6)
  {
    float v22 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a6);
    uint64_t v23 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v22, a7);
    uint64_t v24 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
    char v25 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v24, 0);
    *char v25 = *v23;
    long long v26 = v23[4];
    long long v28 = v23[1];
    long long v27 = v23[2];
    v25[3] = v23[3];
    v25[4] = v26;
    v25[1] = v28;
    v25[2] = v27;
    C3D::Pass::addDependency(v21, a6);
  }
  else
  {
    if (!a5)
    {
      __int16 v29 = scn_default_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        C3D::ComputeProbeFromTextureOrPreviousPass(v29, v30, v31);
      }
    }
    SCNMTLTextureDescFromMTLTexture(*a5, (uint64_t)&v108);
    uint64_t v32 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
    uint64_t v33 = C3D::PassDescriptor::inputAtIndex(v32, 0);
    *(_OWORD *)(v33 + 16) = v108;
    *(_DWORD *)(v33 + 32) = v109;
    unsigned int v34 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
    uint64_t v35 = C3D::PassDescriptor::inputAtIndex(v34, 0);
    *(_WORD *)(v35 + 66) |= 0x100u;
    id v36 = (C3D::PassResource *)C3D::Pass::resource(v21);
    C3D::PassResource::setInputAtIndex(v36, (C3D::RefCountedResource *)a5, 0);
  }
  if (*(_DWORD *)(a8 + 20) != 1)
  {
    if (!*(unsigned char *)(a8 + 16))
    {
      LODWORD(v10_Block_object_dispose(&STACK[0x2A0], 8) = 1082130432;
      *(void *)((char *)&v108 + 4) = 0x400000001;
      int v37 = C3D::RenderGraph::createPass<C3D::CubeBlurPass,C3D::Pass *&,C3D::CubeBlurPass::Parameters>(v15, &v112, (const Parameters *)&v108);
      unsigned __int32 v70 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      BOOL v71 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v70, 0);
      unint64_t v72 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      float32x4_t v73 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v72, 0);
      *float32x4_t v73 = *v71;
      long long v74 = v71[4];
      long long v76 = v71[1];
      long long v75 = v71[2];
      v73[3] = v71[3];
      v73[4] = v74;
      v73[1] = v76;
      v73[2] = v75;
      float32x4_t v77 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      uint64_t v78 = C3D::PassDescriptor::inputAtIndex(v77, 0);
      *(_WORD *)(v78 + 66) |= 0x80u;
      int8x16_t v79 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      int v80 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v79, 0);
      int v81 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      int32x4_t v82 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v81, 0);
      *int32x4_t v82 = *v80;
      long long v83 = v80[4];
      long long v85 = v80[1];
      long long v84 = v80[2];
      v82[3] = v80[3];
      v82[4] = v83;
      v82[1] = v85;
      v82[2] = v84;
      char v86 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      float32x4_t v87 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v86, 0);
      unsigned int v88 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      unint64_t v89 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v88, 1u);
      *unint64_t v89 = *v87;
      long long v90 = v87[4];
      long long v92 = v87[1];
      long long v91 = v87[2];
      v89[3] = v87[3];
      v89[4] = v90;
      v89[1] = v92;
      v89[2] = v91;
      float32x4_t v93 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      uint64_t v94 = C3D::PassDescriptor::outputAtIndex(v93, 1u);
      *(_WORD *)(v94 + 66) |= 8u;
      goto LABEL_19;
    }
    *(void *)&long long v108 = 0x4000100000005;
    int v37 = C3D::RenderGraph::createPass<C3D::BoxBlurPass,C3D::Pass *&,C3D::BoxBlurPass::Parameters>(v15, &v112, (const Parameters *)&v108);
    int v47 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
    uint64_t v48 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v47, 0);
    long long v49 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
    long long v50 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v49, 0);
    *long long v50 = *v48;
    long long v51 = v48[4];
    long long v53 = v48[1];
    long long v52 = v48[2];
    v50[3] = v48[3];
    float32x4_t v50[4] = v51;
    v50[1] = v53;
    v50[2] = v52;
    uint64_t v54 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
    *(unsigned char *)(C3D::PassDescriptor::inputAtIndex(v54, 0) + 26) = 1;
    if (IsCube)
    {
      uint64_t v55 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      float v56 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v55, 0);
      long long v57 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      long long v58 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v57, 0);
      *long long v58 = *v56;
      long long v59 = v56[4];
      long long v61 = v56[1];
      long long v60 = v56[2];
      v58[3] = v56[3];
      v58[4] = v59;
      v58[1] = v61;
      __n128 v58[2] = v60;
      int v62 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      *(unsigned char *)(C3D::PassDescriptor::outputAtIndex(v62, 0) + 26) = 4;
      C3D::Pass::addDependency(v37, v21);
      LOWORD(v10_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned __int8 *)(a8 + 16);
      int v21 = C3D::RenderGraph::createPass<C3D::ConvertCubeComputePass,C3D::Pass *&,C3D::ConvertCubeComputePass::Parameters>(v15, &v112, (const Parameters *)&v108);
      uint64_t v63 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      uint64_t v64 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v63, 0);
      int v65 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      unsigned int v66 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v65, 0);
      *unsigned int v66 = *v64;
      long long v67 = v64[4];
      long long v69 = v64[1];
      long long v68 = v64[2];
      v66[3] = v64[3];
      v66[4] = v67;
      v66[1] = v69;
      v66[2] = v68;
      a4 *= 6;
    }
    else
    {
      *(_WORD *)(C3D::Pass::descriptor(v37) + 4) = a4;
      C3D::Pass::addDependency(v37, v21);
      if (*(unsigned char *)(a8 + 16) == 2) {
        goto LABEL_24;
      }
      LOBYTE(v10_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned char *)(a8 + 16);
      BYTE1(v10_Block_object_dispose(&STACK[0x2A0], 8) = 2;
      int v21 = C3D::RenderGraph::createPass<C3D::ConvertCubePass,C3D::Pass *&,C3D::ConvertCubePass::Parameters>(v15, &v112, (const Parameters *)&v108);
      __int16 v95 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
      unsigned int v96 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v95, 0);
      uint64_t v97 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      float v98 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v97, 0);
      *float v98 = *v96;
      long long v99 = v96[4];
      long long v101 = v96[1];
      long long v100 = v96[2];
      v98[3] = v96[3];
      v98[4] = v99;
      v98[1] = v101;
      v98[2] = v100;
      *(_WORD *)(C3D::Pass::descriptor(v21) + 10) = 5;
      uint64_t v102 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
      uint64_t v103 = C3D::PassDescriptor::outputAtIndex(v102, 0);
      *(_WORD *)(v103 + 66) &= 0xFFFCu;
    }
    *(_WORD *)(C3D::Pass::descriptor(v21) + 4) = a4;
    C3D::Pass::addDependency(v21, v37);
LABEL_23:
    int v37 = v21;
    goto LABEL_24;
  }
  if (IsCube) {
    goto LABEL_23;
  }
  LOBYTE(v10_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned char *)(a8 + 16);
  BYTE1(v10_Block_object_dispose(&STACK[0x2A0], 8) = 2;
  int v37 = C3D::RenderGraph::createPass<C3D::ConvertCubePass,C3D::Pass *&,C3D::ConvertCubePass::Parameters>(v15, &v112, (const Parameters *)&v108);
  unsigned int v38 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v21);
  int v39 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v38, 0);
  uint64_t v40 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
  uint64_t v41 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v40, 0);
  *uint64_t v41 = *v39;
  long long v42 = v39[4];
  long long v44 = v39[1];
  long long v43 = v39[2];
  v41[3] = v39[3];
  v41[4] = v42;
  v41[1] = v44;
  v41[2] = v43;
  *(_WORD *)(C3D::Pass::descriptor(v37) + 10) = 5;
  uint64_t v45 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
  uint64_t v46 = C3D::PassDescriptor::outputAtIndex(v45, 0);
  *(_WORD *)(v46 + 66) &= 0xFFFCu;
  *(_WORD *)(C3D::Pass::descriptor(v37) + 4) = a4;
LABEL_19:
  C3D::Pass::addDependency(v37, v21);
LABEL_24:
  C3D::Pass::addDependency(v112, v37);
  long long v104 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v37);
  uint64_t v105 = C3D::PassDescriptor::outputAtIndex(v104, 0);
  *(_OWORD *)(v105 + 16) = v110;
  *(_DWORD *)(v105 + 32) = v111;
  *(_WORD *)(v105 + 66) |= 0x100u;
  long long v106 = (C3D::PassResource *)C3D::Pass::resource(v37);
  C3D::PassResource::setOutputAtIndex(v106, a3, 0);
  *(void *)&double result = C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(a2, v105).n128_u64[0];
  return result;
}

C3D::ComputeRadiancePass *C3D::RenderGraph::createPass<C3D::ComputeRadiancePass,C3D::Pass *&,C3D::ComputeRadiancePass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::ComputeRadiancePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::ComputeRadiancePass::ComputeRadiancePass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ComputeRadiancePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::BoxBlurPass *C3D::RenderGraph::createPass<C3D::BoxBlurPass,C3D::Pass *&,C3D::BoxBlurPass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::BoxBlurPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::BoxBlurPass::BoxBlurPass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::BoxBlurPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::ConvertCubeComputePass *C3D::RenderGraph::createPass<C3D::ConvertCubeComputePass,C3D::Pass *&,C3D::ConvertCubeComputePass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::ConvertCubeComputePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 184, 8, 0);
  C3D::ConvertCubeComputePass::ConvertCubeComputePass(Aligned, (C3D::RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::ConvertCubeComputePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::CubeBlurPass *C3D::RenderGraph::createPass<C3D::CubeBlurPass,C3D::Pass *&,C3D::CubeBlurPass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::CubeBlurPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 128, 8, 0);
  C3D::CubeBlurPass::CubeBlurPass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::CubeBlurPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

double C3D::ComputeProbeFromEnvironmentTexture(C3D::Pass *a1, uint64_t a2, C3D::RefCountedResource *a3, unsigned int a4, uint64_t a5, long long *a6)
{
  long long v69 = a1;
  uint64_t v12 = *((void *)a1 + 3);
  uint64_t v13 = *(void **)a3;
  long long v67 = 0uLL;
  int v68 = 0;
  SCNMTLTextureDescFromMTLTexture(v13, (uint64_t)&v67);
  uint64_t v14 = *((void *)a1 + 2);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v14);
  uint64_t v16 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  if (!a5
    || (uint64_t v17 = (void *)[v16 renderResourceForEffectSlot:a5 withEngineContext:v14 didFallbackToDefaultTexture:0]) == 0|| (v18 = (uint64_t)v17, objc_msgSend(v17, "textureType") != 5))
  {
    if (SCNMTLTextureTypeIsCube(BYTE8(v67))) {
      __int16 v27 = 6;
    }
    else {
      __int16 v27 = 1;
    }
    long long v65 = xmmword_20B5CB530;
    long long v28 = C3D::RenderGraph::createPass<C3D::FillTexturePass,C3D::Pass *&,C3D::FillTexturePass::Parameters>(v12, &v69, (const Parameters *)&v65);
    __int16 v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v28);
    uint64_t v30 = C3D::PassDescriptor::outputAtIndex(v29, 0);
    *(_OWORD *)(v30 + 16) = v67;
    *(_DWORD *)(v30 + 32) = v68;
    uint64_t v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v28);
    uint64_t v32 = C3D::PassDescriptor::outputAtIndex(v31, 0);
    *(_WORD *)(v32 + 66) |= 0x100u;
    *(_WORD *)(C3D::Pass::descriptor(v28) + 4) = v27 * a4;
    *(_WORD *)(C3D::Pass::descriptor(v28) + 6) = v27;
    __int16 v33 = BYTE14(v67);
    *(_WORD *)(C3D::Pass::descriptor(v28) + 10) = v33;
    unsigned int v34 = (C3D::PassResource *)C3D::Pass::resource(v28);
    C3D::PassResource::setOutputAtIndex(v34, a3, 0);
    C3D::Pass::addDependency(v69, v28);
    uint64_t v35 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v28);
    uint64_t v36 = C3D::PassDescriptor::outputAtIndex(v35, 0);
    uint64_t v37 = a2;
LABEL_12:
    *(void *)&double result = C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(v37, v36).n128_u64[0];
    return result;
  }
  PersistentResource = (id *)C3D::RenderGraph::createPersistentResource(v12, v18);
  if ([*PersistentResource mipmapLevelCount] == 5 && objc_msgSend(*PersistentResource, "width") != 16)
  {
    if (SCNMTLTextureTypeIsCube([v13 textureType])) {
      a4 *= 6;
    }
    [*PersistentResource height];
    [*PersistentResource pixelFormat];
    long long v65 = 0uLL;
    uint64_t v66 = a4;
    long long v52 = C3D::RenderGraph::createPass<C3D::CopyTextureComputePass,C3D::Pass *&,C3D::CopyTextureComputePass::Parameters>(v12, &v69, (const Parameters *)&v65);
    SCNMTLTextureDescFromMTLTexture(*PersistentResource, (uint64_t)&v65);
    long long v53 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v52);
    uint64_t v54 = C3D::PassDescriptor::inputAtIndex(v53, 0);
    *(_OWORD *)(v54 + 16) = v65;
    *(_DWORD *)(v54 + 32) = v66;
    uint64_t v55 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v52);
    uint64_t v56 = C3D::PassDescriptor::inputAtIndex(v55, 0);
    *(_WORD *)(v56 + 66) |= 0x100u;
    long long v57 = (C3D::PassResource *)C3D::Pass::resource(v52);
    C3D::PassResource::setInputAtIndex(v57, (C3D::RefCountedResource *)PersistentResource, 0);
    long long v58 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v52);
    uint64_t v59 = C3D::PassDescriptor::outputAtIndex(v58, 0);
    *(_OWORD *)(v59 + 16) = v67;
    *(_DWORD *)(v59 + 32) = v68;
    *(_WORD *)(v59 + 66) |= 0x100u;
    long long v60 = (C3D::PassResource *)C3D::Pass::resource(v52);
    C3D::PassResource::setOutputAtIndex(v60, a3, 0);
    C3D::Pass::addDependency(v69, v52);
    uint64_t v37 = a2;
    uint64_t v36 = v59;
    goto LABEL_12;
  }
  if ((unint64_t)[*PersistentResource mipmapLevelCount] < 5)
  {
    LOBYTE(v65) = 1;
    int v39 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::Pass *&,C3D::GenerateMipmapPass::Parameters>(v12, &v69, (unsigned __int8 *)&v65);
    SCNMTLTextureDescFromMTLTexture(*PersistentResource, (uint64_t)&v65);
    uint64_t v40 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    uint64_t v41 = C3D::PassDescriptor::inputAtIndex(v40, 0);
    *(_OWORD *)(v41 + 16) = v65;
    *(_DWORD *)(v41 + 32) = v66;
    long long v42 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    uint64_t v43 = C3D::PassDescriptor::inputAtIndex(v42, 0);
    *(_WORD *)(v43 + 66) |= 0x100u;
    long long v44 = (C3D::PassResource *)C3D::Pass::resource(v39);
    C3D::PassResource::setInputAtIndex(v44, (C3D::RefCountedResource *)PersistentResource, 0);
    SCNMTLTextureDescFromMTLTexture(*PersistentResource, (uint64_t)&v65);
    uint64_t v45 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    uint64_t v46 = C3D::PassDescriptor::outputAtIndex(v45, 0);
    *(_OWORD *)(v46 + 16) = v65;
    *(_DWORD *)(v46 + 32) = v66;
    int v47 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    uint64_t v48 = C3D::PassDescriptor::outputAtIndex(v47, 0);
    unsigned int v49 = *(unsigned __int16 *)(v48 + 16);
    if (v49 <= *(unsigned __int16 *)(v48 + 18)) {
      unsigned int v49 = *(unsigned __int16 *)(v48 + 18);
    }
    int v50 = (int)(float)(floorf(log2f((float)v49)) + 1.0);
    long long v51 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    *(unsigned char *)(C3D::PassDescriptor::outputAtIndex(v51, 0) + 30) = v50;
    unsigned int v20 = v69;
    long long v61 = *a6;
    uint64_t v62 = *((void *)a6 + 2);
    int v21 = &v61;
    uint64_t v22 = a2;
    uint64_t v23 = a3;
    __int16 v24 = a4;
    char v25 = 0;
    long long v26 = v39;
  }
  else
  {
    unsigned int v20 = v69;
    long long v63 = *a6;
    uint64_t v64 = *((void *)a6 + 2);
    int v21 = &v63;
    uint64_t v22 = a2;
    uint64_t v23 = a3;
    __int16 v24 = a4;
    char v25 = PersistentResource;
    long long v26 = 0;
  }
  return C3D::ComputeProbeFromTextureOrPreviousPass(v20, v22, v23, v24, v25, v26, 0, (uint64_t)v21);
}

C3D::FillTexturePass *C3D::RenderGraph::createPass<C3D::FillTexturePass,C3D::Pass *&,C3D::FillTexturePass::Parameters>(uint64_t a1, C3D::Pass **a2, const Parameters *a3)
{
  Aligned = (C3D::FillTexturePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 256, 16, 0);
  C3D::FillTexturePass::FillTexturePass(Aligned, (RenderGraph *)a1, *a2, a3);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::FillTexturePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

C3D::GenerateMipmapPass *C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::Pass *&,C3D::GenerateMipmapPass::Parameters>(uint64_t a1, C3D::Pass **a2, unsigned __int8 *a3)
{
  Aligned = (C3D::GenerateMipmapPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 112, 8, 0);
  *(void *)&v8.var0 = *a3;
  C3D::GenerateMipmapPass::GenerateMipmapPass(Aligned, (RenderGraph *)a1, *a2, v8);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::GenerateMipmapPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

double C3D::ComputeProbeFromProbeNode(C3D::Pass *a1, uint64_t a2, C3D::RefCountedResource *a3, __int16 a4, __C3DNode *a5, long long *a6)
{
  unsigned int v34 = a5;
  uint64_t v35 = a1;
  uint64_t v10 = *((void *)a1 + 3);
  CFNumberRef v11 = C3D::RenderGraph::createPass<C3D::RenderProbePass,C3D::Pass *&,__C3DNode *&,unsigned int &,MTLPixelFormat &>(v10, &v35, &v34, (unsigned int *)a6, (MTLPixelFormat *)a6 + 1);
  uint64_t v12 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>(v10, &v35);
  uint64_t v13 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v11);
  uint64_t v14 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v13, 0);
  uint64_t v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
  uint64_t v16 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v15, 0);
  *uint64_t v16 = *v14;
  long long v17 = v14[4];
  long long v19 = v14[1];
  long long v18 = v14[2];
  v16[3] = v14[3];
  v16[4] = v17;
  v16[1] = v19;
  _OWORD v16[2] = v18;
  unsigned int v20 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v11);
  int v21 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v20, 0);
  uint64_t v22 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
  uint64_t v23 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v22, 0);
  *uint64_t v23 = *v21;
  long long v24 = v21[4];
  long long v26 = v21[1];
  long long v25 = v21[2];
  v23[3] = v21[3];
  v23[4] = v24;
  v23[1] = v26;
  v23[2] = v25;
  __int16 v27 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
  uint64_t v28 = C3D::PassDescriptor::inputAtIndex(v27, 0);
  *(_WORD *)(v28 + 66) |= 4u;
  __int16 v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
  uint64_t v30 = C3D::PassDescriptor::inputAtIndex(v29, 0);
  *(_WORD *)(v30 + 66) |= 0x80u;
  C3D::Pass::addDependency(v12, v11);
  *((_DWORD *)a6 + 5) = 0;
  long long v32 = *a6;
  uint64_t v33 = *((void *)a6 + 2);
  return C3D::ComputeProbeFromTextureOrPreviousPass(v35, a2, a3, a4, 0, v12, 0, (uint64_t)&v32);
}

C3D::RenderProbePass *C3D::RenderGraph::createPass<C3D::RenderProbePass,C3D::Pass *&,__C3DNode *&,unsigned int &,MTLPixelFormat &>(uint64_t a1, C3D::Pass **a2, __C3DNode **a3, unsigned int *a4, MTLPixelFormat *a5)
{
  Aligned = (C3D::RenderProbePass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5376, 16, 0);
  C3D::RenderProbePass::RenderProbePass(Aligned, (C3D::RenderGraph *)a1, *a2, *a3, *a4, *a5);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::RenderProbePass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

void __CreateProbeArrayResourceIfNeeded_block_invoke(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  long long v40 = *(_OWORD *)(a1 + 32);
  int v41 = *(_DWORD *)(a1 + 48);
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a2;
    do
    {
      uint64_t v9 = *(void *)(a4 + 8 * v7);
      if (C3DLightGetProbeType(v9) != 1)
      {
        uint64_t v10 = scn_default_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          __CreateProbeArrayResourceIfNeeded_block_invoke_cold_2(v38, &v39, v10);
        }
      }
      RadianceProbeuint64_t Index = C3DLightGetRadianceProbeIndex(v9);
      if (RadianceProbeIndex == -1)
      {
        uint64_t v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          __CreateProbeArrayResourceIfNeeded_block_invoke_cold_1(v36, &v37, v12);
        }
      }
      int ProbeEnvironmentTimeStamp = C3DLightGetProbeEnvironmentTimeStamp(v9);
      ProbeUpdateint Type = C3DLightGetProbeUpdateType(v9);
      if (ProbeUpdateType == 1)
      {
        unsigned int v20 = *(C3D::Pass **)(a1 + 64);
        uint64_t v21 = *(void *)(a1 + 72);
        uint64_t v22 = *(__C3DNode **)(a3 + 8 * v7);
        uint64_t v23 = *(C3D::RefCountedResource **)(a1 + 88);
        long long v30 = v40;
        int v31 = v41;
        int v32 = 0;
        C3D::ComputeProbeFromProbeNode(v20, v21, v23, RadianceProbeIndex, v22, &v30);
      }
      else if (!ProbeUpdateType)
      {
        if (!*(unsigned char *)(a1 + 96)) {
          goto LABEL_24;
        }
        uint64_t v15 = *(void *)(a1 + 56);
        uint64_t v16 = *(void *)(v15 + 40);
        uint64_t v17 = *(unsigned int *)(v15 + 32);
        if (v17)
        {
          uint64_t v18 = 8 * v17;
          long long v19 = *(void **)(v15 + 40);
          while (*v19 != v9)
          {
            ++v19;
            v18 -= 8;
            if (!v18)
            {
              long long v19 = (void *)(v16 + 8 * v17);
              break;
            }
          }
        }
        else
        {
          long long v19 = *(void **)(v15 + 40);
        }
        unint64_t v24 = (unint64_t)v19 - v16;
        if (v17 == (uint64_t)v24 >> 3
          || (unint64_t v25 = v24 >> 3, (v24 >> 3) == -1)
          || *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](v15 + 16, v24 >> 3) != ProbeEnvironmentTimeStamp)
        {
LABEL_24:
          if (*(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 16, RadianceProbeIndex) != ProbeEnvironmentTimeStamp|| *(void *)C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 32, RadianceProbeIndex) != v9)
          {
            *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 16, RadianceProbeIndex) = ProbeEnvironmentTimeStamp;
            *(void *)C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 32, RadianceProbeIndex) = v9;
            long long v26 = *(C3D::Pass **)(a1 + 64);
            uint64_t v27 = *(void *)(a1 + 72);
            uint64_t v28 = *(C3D::RefCountedResource **)(a1 + 88);
            uint64_t ProbeEnvironment = C3DLightGetProbeEnvironment(v9, 0);
            long long v33 = v40;
            int v34 = v41;
            int v35 = 0;
            C3D::ComputeProbeFromEnvironmentTexture(v26, v27, v28, RadianceProbeIndex, ProbeEnvironment, &v33);
          }
        }
        else
        {
          C3D::CopyProbeFromOldTextureToNewTexture(*(C3D::Pass **)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 56), v25, *(void *)(a1 + 80), *(C3D::RefCountedResource **)(a1 + 88), RadianceProbeIndex);
          *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 16, RadianceProbeIndex) = ProbeEnvironmentTimeStamp;
          *(void *)C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](*(void *)(a1 + 80) + 32, RadianceProbeIndex) = v9;
        }
      }
      ++v7;
    }
    while (v7 != v8);
  }
}

void OUTLINED_FUNCTION_2_2(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x22u);
}

uint64_t C3DFXPassSetup2PassesBlurCallbacks(uint64_t a1, int a2)
{
  BOOL v3 = a2 == 0;
  if (a2) {
    uint64_t v4 = _initializeHorizontalBlur;
  }
  else {
    uint64_t v4 = _initializeVerticalBlur;
  }
  if (v3) {
    int64x2_t v5 = _executeVerticalBlur;
  }
  else {
    int64x2_t v5 = _executeHorizontalBlur;
  }
  C3DFXPassSetInitializeCallback(a1, (uint64_t)v4);

  return C3DFXPassSetWillExecuteCallback(a1, (uint64_t)v5);
}

void _initializeHorizontalBlur(uint64_t *a1, int a2)
{
}

void _executeHorizontalBlur(uint64_t a1)
{
}

void _initializeVerticalBlur(uint64_t *a1, int a2)
{
}

void _executeVerticalBlur(uint64_t a1)
{
}

void __initialize2PassesBlur(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"GaussianBlur_vert", @"GaussianBlur_frag");
    C3DFXProgramSetClientProgram((uint64_t)BuiltInProgramWithName, *(unsigned __int8 *)(a1 + 80));
LABEL_7:
    C3DFXPassSetProgram(a1, BuiltInProgramWithName);
    if (BuiltInProgramWithName)
    {
      CFRelease(BuiltInProgramWithName);
    }
    return;
  }
  if (a3 == 1)
  {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-GaussianBlur");
    uint64_t Shader = C3DFXGLSLProgramGetShader(BuiltInProgramWithName, 1);
    uint64_t Source = C3DFXShaderGetSource(Shader);
    uint64_t v8 = _create2PassesBlurProgramWithSampleCount_k++;
    uint64_t v9 = 120;
    if (!a2) {
      uint64_t v9 = 121;
    }
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"#define unshareIndex %d\n#define MAX_SAMPLE %d\n#define COMPONENT %c\n%@", v8, 31, v9, Source);
    C3DFXShaderSetSource(Shader, v10);
    CFRelease(v10);
    goto LABEL_7;
  }

  C3DFXPassSetProgram(a1, 0);
}

void _execute2PassesBlur(uint64_t a1, uint64_t a2, __n128 *a3, unsigned int a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (a4) {
    uint64_t v8 = @"C3D-blur-radiusH";
  }
  else {
    uint64_t v8 = @"C3D-blur-radiusV";
  }
  ValueForSymbol = (float *)C3DFXTechniqueGetValueForSymbol(a2, v8, 0);
  float v10 = *ValueForSymbol;
  double v11 = ceilf(*ValueForSymbol * 0.5) * 4.0;
  double v12 = v11 + 1.0;
  BOOL v13 = v11 <= 30.0;
  double v14 = 31.0;
  if (v13) {
    double v14 = v12;
  }
  uint64_t v15 = (int)v14;
  int v45 = (int)v14;
  uint64_t v47 = 0;
  float v16 = fminf(v10, 14.0);
  memset(&v46[1], 0, 112);
  MEMORY[0x270FA5388](ValueForSymbol);
  uint64_t v18 = (float32x2_t *)((char *)&v43 - v17);
  __n128 Viewport = C3DEngineContextGetViewport(a3);
  float64x2_t v43 = *(float64x2_t *)(a1 + 376);
  float v19 = v16 * 6.28318531 * v16;
  float v20 = 1.0 / sqrtf(v19);
  float v21 = v16 * (float)(v16 + v16);
  float v23 = expf(-0.0 / v21) * v20;
  v46[0] = v23;
  *uint64_t v18 = 0;
  if ((int)v15 > 1)
  {
    uint64_t v24 = 0;
    __asm { FMOV            V2.2S, #1.0 }
    int8x8_t v30 = (int8x8_t)vdiv_f32(_D2, vmaxnm_f32(vcvt_f32_f64(vmulq_f64(v43, vcvt_hight_f64_f32((float32x4_t)Viewport))), _D2));
    _D2.i32[0] = v30.i32[0];
    v30.i32[0] = 0;
    v22.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a4), 0x1FuLL)), (int8x8_t)_D2.u32[0], v30);
    float32x2_t v31 = vneg_f32((float32x2_t)v22.n128_u64[0]);
    __n128 Viewport = v22;
    float v32 = v22.n128_f32[1];
    long long v33 = v18 + 2;
    int v34 = &v46[2];
    do
    {
      float v35 = (float)(v24 + 1);
      v24 += 2;
      float v36 = v20 * expf((float)-(float)(v35 * v35) / v21);
      float v37 = v20 * expf((float)-(float)((float)(int)v24 * (float)(int)v24) / v21);
      float v38 = v36 + v37;
      float v39 = (float)((float)(v37 * (float)(int)v24) + (float)(v35 * v36)) / (float)(v36 + v37);
      *(v34 - 1) = v38;
      float *v34 = v38;
      float v23 = v23 + (float)(v38 * 2.0);
      v40.f32[0] = Viewport.n128_f32[0] * v39;
      v40.f32[1] = v32 * v39;
      v33[-1] = v40;
      *long long v33 = vmul_n_f32(v31, v39);
      v33 += 2;
      v34 += 2;
    }
    while ((v15 & 0xFFFFFFFE) != v24);
  }
  if ((int)v15 >= 1)
  {
    int v41 = v46;
    uint64_t v42 = v15;
    do
    {
      *int v41 = *v41 / v23;
      ++v41;
      --v42;
    }
    while (v42);
  }
  C3DFXTechniqueSetValueForSymbolWithCount(a2, @"C3D-blur-offsets", v18, v15);
  C3DFXTechniqueSetValueForSymbolWithCount(a2, @"C3D-blur-weights", v46, v15);
  C3DFXTechniqueSetValueForSymbol(a2, @"C3D-blur-samples", &v45);
}

void _C3DConvexPolyhedronCFFinalize(void *a1)
{
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }
  BOOL v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  int64x2_t v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[5];
  if (v6)
  {
    a1[6] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)a1[2];
  if (v7)
  {
    a1[3] = v7;
    operator delete(v7);
  }
}

CFStringRef _C3DConvexPolyhedronCFCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v3, 0, @"<C3DConvexPolyhedron %p>", a1);
}

CFStringRef _C3DConvexPolyhedronCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DConvexPolyhedron %p>", a1);
}

uint64_t C3DConvexPolyhedronGetVerticesCount(uint64_t a1)
{
  return (*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 4;
}

uint64_t C3DConvexPolyhedronGetEdgeCount(uint64_t a1)
{
  return ((int)((*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 2) / 2);
}

void _C3DConvexPolyhedronSet(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v9 = (char **)(a1 + 16);
  _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm(a1 + 16, 0);
  if (a3 >= 1)
  {
    uint64_t v10 = 0;
    double v11 = (void *)(a1 + 32);
    double v12 = *(char **)(a1 + 24);
    do
    {
      if ((unint64_t)v12 >= *v11)
      {
        uint64_t v13 = (v12 - *v9) >> 4;
        if ((unint64_t)(v13 + 1) >> 60) {
LABEL_56:
        }
          abort();
        uint64_t v14 = *v11 - (void)*v9;
        uint64_t v15 = v14 >> 3;
        if (v14 >> 3 <= (unint64_t)(v13 + 1)) {
          uint64_t v15 = v13 + 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16) {
          uint64_t v17 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(a1 + 32, v16);
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v18 = &v17[16 * v13];
        *(_OWORD *)uint64_t v18 = *(_OWORD *)(a2 + 16 * v10);
        double v12 = v18 + 16;
        float v20 = *(char **)(a1 + 16);
        float v19 = *(char **)(a1 + 24);
        if (v19 != v20)
        {
          do
          {
            long long v21 = *((_OWORD *)v19 - 1);
            v19 -= 16;
            *((_OWORD *)v18 - 1) = v21;
            v18 -= 16;
          }
          while (v19 != v20);
          float v19 = *v9;
        }
        *(void *)(a1 + 16) = v18;
        *(void *)(a1 + 24) = v12;
        *(void *)(a1 + 32) = &v17[16 * v16];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *(_OWORD *)double v12 = *(_OWORD *)(a2 + 16 * v10);
        v12 += 16;
      }
      *(void *)(a1 + 24) = v12;
      ++v10;
    }
    while (v10 != a3);
  }
  __n128 v22 = (void **)(a1 + 40);
  std::vector<int>::resize((std::vector<unsigned int> *)(a1 + 40), 0);
  if (a5 >= 1)
  {
    uint64_t v23 = 0;
    uint64_t v24 = (char **)(a1 + 56);
    unint64_t v25 = *(char **)(a1 + 48);
    do
    {
      long long v26 = *v24;
      if (v25 >= *v24)
      {
        uint64_t v28 = (char *)*v22;
        uint64_t v29 = (v25 - (unsigned char *)*v22) >> 2;
        unint64_t v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 62) {
          goto LABEL_56;
        }
        uint64_t v31 = v26 - v28;
        if (v31 >> 1 > v30) {
          unint64_t v30 = v31 >> 1;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32)
        {
          long long v33 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 56, v32);
          uint64_t v28 = *(char **)(a1 + 40);
          unint64_t v25 = *(char **)(a1 + 48);
        }
        else
        {
          long long v33 = 0;
        }
        int v34 = &v33[4 * v29];
        *(_DWORD *)int v34 = *(_DWORD *)(a4 + 8 * v23);
        uint64_t v27 = v34 + 4;
        while (v25 != v28)
        {
          int v35 = *((_DWORD *)v25 - 1);
          v25 -= 4;
          *((_DWORD *)v34 - 1) = v35;
          v34 -= 4;
        }
        long long v26 = &v33[4 * v32];
        *(void *)(a1 + 40) = v34;
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v27;
        *(void *)(a1 + 56) = v26;
        if (v28)
        {
          operator delete(v28);
          long long v26 = *v24;
        }
      }
      else
      {
        *(_DWORD *)unint64_t v25 = *(_DWORD *)(a4 + 8 * v23);
        uint64_t v27 = v25 + 4;
      }
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v27;
      uint64_t v36 = (2 * v23) | 1;
      if (v27 >= v26)
      {
        float v37 = (char *)*v22;
        uint64_t v38 = (v27 - (unsigned char *)*v22) >> 2;
        unint64_t v39 = v38 + 1;
        if ((unint64_t)(v38 + 1) >> 62) {
          goto LABEL_56;
        }
        uint64_t v40 = v26 - v37;
        if (v40 >> 1 > v39) {
          unint64_t v39 = v40 >> 1;
        }
        if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v41 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v41 = v39;
        }
        if (v41)
        {
          uint64_t v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 56, v41);
          float v37 = *(char **)(a1 + 40);
          uint64_t v27 = *(char **)(a1 + 48);
        }
        else
        {
          uint64_t v42 = 0;
        }
        float64x2_t v43 = &v42[4 * v38];
        *(_DWORD *)float64x2_t v43 = *(_DWORD *)(a4 + 4 * v36);
        unint64_t v25 = v43 + 4;
        while (v27 != v37)
        {
          int v44 = *((_DWORD *)v27 - 1);
          v27 -= 4;
          *((_DWORD *)v43 - 1) = v44;
          v43 -= 4;
        }
        *(void *)(a1 + 40) = v43;
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v25;
        *(void *)(a1 + 56) = &v42[4 * v41];
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v27 = *(_DWORD *)(a4 + 4 * v36);
        unint64_t v25 = v27 + 4;
      }
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v25;
      ++v23;
    }
    while (v23 != a5);
  }
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void std::vector<int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

__n128 C3DConvexPolyhedronSetAABB(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  float32x4_t v3 = vsubq_f32(a2, a3);
  int32x4_t v4 = (int32x4_t)vaddq_f32(a3, a3);
  float32x4_t v5 = (float32x4_t)vdupq_laneq_s32(v4, 3);
  v5.i32[0] = v4.i32[0];
  float32x4_t v9 = v3;
  float32x4_t v10 = vaddq_f32(v3, v5);
  float32x4_t v11 = vaddq_f32(v3, (float32x4_t)vextq_s8((int8x16_t)v4, (int8x16_t)vuzp2q_s32(v4, v4), 0xCuLL));
  float32x4_t v12 = vaddq_f32(v5, v11);
  int8x16_t v6 = (int8x16_t)vzip2q_s32(v4, v4);
  float32x4_t v7 = (float32x4_t)vextq_s8(v6, v6, 8uLL);
  float32x4_t v13 = vaddq_f32(v3, v7);
  float32x4_t v14 = vaddq_f32(v7, v10);
  float32x4_t v15 = vaddq_f32(v7, v11);
  float32x4_t v16 = vaddq_f32(v7, v12);
  _C3DConvexPolyhedronSet(a1, (uint64_t)&v9, 8, (uint64_t)&kBoxEdges, 12);
  return result;
}

void C3DConvexPolyhedronSetFrustum(uint64_t a1, uint64_t *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  scn_plane_intersect_3_planes(a2[10], a2[11], a2[4], a2[5], a2[2], a2[3], &v4);
  scn_plane_intersect_3_planes(a2[10], a2[11], *a2, a2[1], a2[4], a2[5], &v5);
  scn_plane_intersect_3_planes(a2[10], a2[11], a2[2], a2[3], a2[6], a2[7], &v6);
  scn_plane_intersect_3_planes(a2[10], a2[11], a2[6], a2[7], *a2, a2[1], &v7);
  scn_plane_intersect_3_planes(a2[8], a2[9], a2[4], a2[5], a2[2], a2[3], &v8);
  scn_plane_intersect_3_planes(a2[8], a2[9], *a2, a2[1], a2[4], a2[5], &v9);
  scn_plane_intersect_3_planes(a2[8], a2[9], a2[2], a2[3], a2[6], a2[7], &v10);
  scn_plane_intersect_3_planes(a2[8], a2[9], a2[6], a2[7], *a2, a2[1], &v11);
  _C3DConvexPolyhedronSet(a1, (uint64_t)&v4, 8, (uint64_t)&kBoxEdges, 12);
}

void C3DConvexPolyhedronClipPlane(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4.i64[0] = a2;
  v4.i64[1] = a3;
  float32x4_t v271 = v4;
  int32x4_t v5 = (int32x4_t)vmulq_f32(v4, v4);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  LODWORD(v269) = vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).u32[0];
  float32x4_t v8 = (std::vector<unsigned int> *)(a1 + 112);
  std::vector<int>::resize((std::vector<unsigned int> *)(a1 + 112), (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 4);
  unint64_t v9 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
  if ((int)(v9 >> 4) >= 1) {
    memset(v8->__begin_, 255, (v9 >> 2) & 0x3FFFFFFFCLL);
  }
  int8x16_t v272 = (int8x16_t)vmulq_n_f32(v271, v269);
  v270 = (char **)(a1 + 136);
  std::vector<ClippedCorner>::resize(a1 + 136, 0);
  unint64_t v10 = *(void *)(a1 + 48) - *(void *)(a1 + 40);
  if ((int)(v10 >> 2) > 1)
  {
    uint64_t v11 = 0;
    uint64_t v262 = a1 + 80;
    uint64_t v12 = (void *)(a1 + 104);
    uint64_t v259 = a1 + 152;
    uint64_t v13 = (v10 >> 3) & 0x7FFFFFFF;
    do
    {
      float32x4_t v14 = (int *)(*(void *)(a1 + 40) + 8 * v11);
      uint64_t v15 = *v14;
      uint64_t v16 = v14[1];
      uint64_t v17 = *(void *)(a1 + 16);
      float32x4_t v18 = *(float32x4_t *)(v17 + 16 * v15);
      float32x4_t v19 = *(float32x4_t *)(v17 + 16 * v16);
      float32x4_t v20 = vmulq_f32((float32x4_t)v272, v18);
      float v21 = *(float *)&v272.i32[3]
          + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
      float32x4_t v22 = vmulq_f32((float32x4_t)v272, v19);
      float v23 = *(float *)&v272.i32[3]
          + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
      if (v21 > 0.0 || v23 > 0.0)
      {
        if (v21 <= 0.0 || v23 > 0.0)
        {
          if (v21 <= 0.0 && v23 > 0.0)
          {
            unsigned int v31 = v8->__begin_[v15];
            if (v31 == -1)
            {
              long long v33 = *(float32x4_t **)(a1 + 72);
              unint64_t v32 = *(void *)(a1 + 80);
              if ((unint64_t)v33 >= v32)
              {
                uint64_t v125 = *(void *)(a1 + 64);
                uint64_t v126 = ((uint64_t)v33 - v125) >> 4;
                if ((unint64_t)(v126 + 1) >> 60) {
                  goto LABEL_301;
                }
                float32x4_t v260 = *(float32x4_t *)(v17 + 16 * v16);
                uint64_t v127 = v32 - v125;
                uint64_t v128 = v127 >> 3;
                if (v127 >> 3 <= (unint64_t)(v126 + 1)) {
                  uint64_t v128 = v126 + 1;
                }
                if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v129 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v129 = v128;
                }
                float32x4_t v265 = *(float32x4_t *)(v17 + 16 * v15);
                if (v129)
                {
                  char v130 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v129);
                  float32x4_t v18 = v265;
                }
                else
                {
                  char v130 = 0;
                }
                uint64_t v146 = &v130[16 * v126];
                *(_OWORD *)uint64_t v146 = *(_OWORD *)(v17 + 16 * v15);
                f32 = v146 + 16;
                long long v148 = *(char **)(a1 + 64);
                uint64_t v147 = *(char **)(a1 + 72);
                if (v147 != v148)
                {
                  do
                  {
                    long long v149 = *((_OWORD *)v147 - 1);
                    v147 -= 16;
                    *((_OWORD *)v146 - 1) = v149;
                    v146 -= 16;
                  }
                  while (v147 != v148);
                  uint64_t v147 = *(char **)(a1 + 64);
                }
                *(void *)(a1 + 64) = v146;
                *(void *)(a1 + 72) = f32;
                *(void *)(a1 + 80) = &v130[16 * v129];
                if (v147)
                {
                  operator delete(v147);
                  float32x4_t v18 = v265;
                }
                float32x4_t v19 = v260;
              }
              else
              {
                *long long v33 = v18;
                f32 = (_OWORD *)v33[1].f32;
              }
              *(void *)(a1 + 72) = f32;
              unsigned int v31 = (((unint64_t)f32 - *(void *)(a1 + 64)) >> 4) - 1;
              *(_DWORD *)(*(void *)(a1 + 112) + 4 * v15) = v31;
            }
            int8x16_t v151 = *(char **)(a1 + 96);
            unint64_t v150 = *(void *)(a1 + 104);
            if ((unint64_t)v151 >= v150)
            {
              uint64_t v153 = *(char **)(a1 + 88);
              uint64_t v154 = (v151 - v153) >> 2;
              unint64_t v155 = v154 + 1;
              if ((unint64_t)(v154 + 1) >> 62) {
                goto LABEL_301;
              }
              float32x4_t v261 = v19;
              float32x4_t v266 = v18;
              uint64_t v156 = v150 - (void)v153;
              if (v156 >> 1 > v155) {
                unint64_t v155 = v156 >> 1;
              }
              if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v157 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v155;
              }
              if (v157)
              {
                long long v158 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v157);
                uint64_t v153 = *(char **)(a1 + 88);
                int8x16_t v151 = *(char **)(a1 + 96);
              }
              else
              {
                long long v158 = 0;
              }
              long long v159 = (unsigned int *)&v158[4 * v154];
              *long long v159 = v31;
              float v152 = v159 + 1;
              while (v151 != v153)
              {
                unsigned int v160 = *((_DWORD *)v151 - 1);
                v151 -= 4;
                *--long long v159 = v160;
              }
              *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v159;
              *(void *)(a1 + 96) = v152;
              *(void *)(a1 + 104) = &v158[4 * v157];
              if (v153) {
                operator delete(v153);
              }
              float32x4_t v18 = v266;
              float32x4_t v19 = v261;
            }
            else
            {
              *(_DWORD *)int8x16_t v151 = v31;
              float v152 = v151 + 4;
            }
            *(void *)(a1 + 96) = v152;
            if ((float)(v23 - v21) != 0.0) {
              float32x4_t v18 = vmlaq_n_f32(v18, vsubq_f32(v19, v18), (float)-v21 / (float)(v23 - v21));
            }
            v162 = *(float32x4_t **)(a1 + 72);
            unint64_t v161 = *(void *)(a1 + 80);
            if ((unint64_t)v162 >= v161)
            {
              uint64_t v164 = *(void *)(a1 + 64);
              uint64_t v165 = ((uint64_t)v162 - v164) >> 4;
              if ((unint64_t)(v165 + 1) >> 60) {
                goto LABEL_301;
              }
              uint64_t v166 = v161 - v164;
              uint64_t v167 = v166 >> 3;
              if (v166 >> 3 <= (unint64_t)(v165 + 1)) {
                uint64_t v167 = v165 + 1;
              }
              if ((unint64_t)v166 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v168 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v168 = v167;
              }
              if (v168)
              {
                float32x4_t v267 = v18;
                float32x2_t v169 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v168);
                float32x4_t v18 = v267;
              }
              else
              {
                float32x2_t v169 = 0;
              }
              v170 = (float32x4_t *)&v169[16 * v165];
              float32x4_t *v170 = v18;
              BOOL v163 = (_OWORD *)v170[1].f32;
              uint64_t v172 = *(float32x4_t **)(a1 + 64);
              v171 = *(float32x4_t **)(a1 + 72);
              if (v171 != v172)
              {
                do
                {
                  float32x4_t v173 = v171[-1];
                  --v171;
                  v170[-1] = v173;
                  --v170;
                }
                while (v171 != v172);
                v171 = *(float32x4_t **)(a1 + 64);
              }
              *(void *)(a1 + 64) = v170;
              *(void *)(a1 + 72) = v163;
              *(void *)(a1 + 80) = &v169[16 * v168];
              if (v171) {
                operator delete(v171);
              }
            }
            else
            {
              float32x4_t *v162 = v18;
              BOOL v163 = (_OWORD *)v162[1].f32;
            }
            *(void *)(a1 + 72) = v163;
            uint64_t v174 = (((unint64_t)v163 - *(void *)(a1 + 64)) >> 4) - 1;
            int8x16_t v176 = *(char **)(a1 + 96);
            unint64_t v175 = *(void *)(a1 + 104);
            if ((unint64_t)v176 >= v175)
            {
              int v178 = *(char **)(a1 + 88);
              uint64_t v179 = (v176 - v178) >> 2;
              unint64_t v180 = v179 + 1;
              if ((unint64_t)(v179 + 1) >> 62) {
                goto LABEL_301;
              }
              uint64_t v181 = v175 - (void)v178;
              if (v181 >> 1 > v180) {
                unint64_t v180 = v181 >> 1;
              }
              if ((unint64_t)v181 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v182 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v182 = v180;
              }
              if (v182)
              {
                v183 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v182);
                int v178 = *(char **)(a1 + 88);
                int8x16_t v176 = *(char **)(a1 + 96);
              }
              else
              {
                v183 = 0;
              }
              char v184 = &v183[4 * v179];
              *(_DWORD *)char v184 = v174;
              unsigned int v177 = v184 + 4;
              while (v176 != v178)
              {
                int v185 = *((_DWORD *)v176 - 1);
                v176 -= 4;
                *((_DWORD *)v184 - 1) = v185;
                v184 -= 4;
              }
              *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v184;
              *(void *)(a1 + 96) = v177;
              *(void *)(a1 + 104) = &v183[4 * v182];
              if (v178) {
                operator delete(v178);
              }
            }
            else
            {
              *(_DWORD *)int8x16_t v176 = v174;
              unsigned int v177 = v176 + 4;
            }
            *(void *)(a1 + 96) = v177;
            char v187 = *(void **)(a1 + 144);
            unint64_t v186 = *(void *)(a1 + 152);
            if ((unint64_t)v187 >= v186)
            {
              uint64_t v189 = ((char *)v187 - *v270) >> 3;
              if ((unint64_t)(v189 + 1) >> 61) {
LABEL_301:
              }
                abort();
              uint64_t v190 = v186 - (void)*v270;
              uint64_t v191 = v190 >> 2;
              if (v190 >> 2 <= (unint64_t)(v189 + 1)) {
                uint64_t v191 = v189 + 1;
              }
              if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v192 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v192 = v191;
              }
              if (v192) {
                long long v193 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(v259, v192);
              }
              else {
                long long v193 = 0;
              }
              long long v194 = &v193[8 * v189];
              *(void *)long long v194 = v174 << 32;
              v188 = v194 + 8;
              uint64_t v196 = *(char **)(a1 + 136);
              long long v195 = *(char **)(a1 + 144);
              if (v195 != v196)
              {
                do
                {
                  uint64_t v197 = *((void *)v195 - 1);
                  v195 -= 8;
                  *((void *)v194 - 1) = v197;
                  v194 -= 8;
                }
                while (v195 != v196);
                long long v195 = *v270;
              }
              *(void *)(a1 + 136) = v194;
              *(void *)(a1 + 144) = v188;
              *(void *)(a1 + 152) = &v193[8 * v192];
              if (v195) {
                operator delete(v195);
              }
            }
            else
            {
              *char v187 = v174 << 32;
              v188 = v187 + 1;
            }
            *(void *)(a1 + 144) = v188;
          }
        }
        else
        {
          if ((float)(v23 - v21) != 0.0) {
            float32x4_t v18 = vmlaq_n_f32(v18, vsubq_f32(v19, v18), (float)-v21 / (float)(v23 - v21));
          }
          uint64_t v29 = *(float32x4_t **)(a1 + 72);
          unint64_t v28 = *(void *)(a1 + 80);
          if ((unint64_t)v29 >= v28)
          {
            uint64_t v35 = *(void *)(a1 + 64);
            uint64_t v36 = ((uint64_t)v29 - v35) >> 4;
            if ((unint64_t)(v36 + 1) >> 60) {
              goto LABEL_301;
            }
            uint64_t v37 = v28 - v35;
            uint64_t v38 = v37 >> 3;
            if (v37 >> 3 <= (unint64_t)(v36 + 1)) {
              uint64_t v38 = v36 + 1;
            }
            if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v39 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v39 = v38;
            }
            if (v39)
            {
              float32x4_t v264 = v18;
              uint64_t v40 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v39);
              float32x4_t v18 = v264;
            }
            else
            {
              uint64_t v40 = 0;
            }
            uint64_t v47 = (float32x4_t *)&v40[16 * v36];
            *uint64_t v47 = v18;
            unint64_t v30 = (_OWORD *)v47[1].f32;
            unsigned int v49 = *(float32x4_t **)(a1 + 64);
            uint64_t v48 = *(float32x4_t **)(a1 + 72);
            if (v48 != v49)
            {
              do
              {
                float32x4_t v50 = v48[-1];
                --v48;
                v47[-1] = v50;
                --v47;
              }
              while (v48 != v49);
              uint64_t v48 = *(float32x4_t **)(a1 + 64);
            }
            *(void *)(a1 + 64) = v47;
            *(void *)(a1 + 72) = v30;
            *(void *)(a1 + 80) = &v40[16 * v39];
            if (v48) {
              operator delete(v48);
            }
          }
          else
          {
            *uint64_t v29 = v18;
            unint64_t v30 = (_OWORD *)v29[1].f32;
          }
          *(void *)(a1 + 72) = v30;
          uint64_t v51 = (((unint64_t)v30 - *(void *)(a1 + 64)) >> 4) - 1;
          long long v53 = *(char **)(a1 + 96);
          unint64_t v52 = *(void *)(a1 + 104);
          if ((unint64_t)v53 >= v52)
          {
            uint64_t v55 = *(char **)(a1 + 88);
            uint64_t v56 = (v53 - v55) >> 2;
            unint64_t v57 = v56 + 1;
            if ((unint64_t)(v56 + 1) >> 62) {
              goto LABEL_301;
            }
            uint64_t v58 = v52 - (void)v55;
            if (v58 >> 1 > v57) {
              unint64_t v57 = v58 >> 1;
            }
            if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v59 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v59 = v57;
            }
            if (v59)
            {
              long long v60 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v59);
              uint64_t v55 = *(char **)(a1 + 88);
              long long v53 = *(char **)(a1 + 96);
            }
            else
            {
              long long v60 = 0;
            }
            long long v61 = &v60[4 * v56];
            *(_DWORD *)long long v61 = v51;
            uint64_t v54 = v61 + 4;
            while (v53 != v55)
            {
              int v62 = *((_DWORD *)v53 - 1);
              v53 -= 4;
              *((_DWORD *)v61 - 1) = v62;
              v61 -= 4;
            }
            *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v61;
            *(void *)(a1 + 96) = v54;
            *(void *)(a1 + 104) = &v60[4 * v59];
            if (v55) {
              operator delete(v55);
            }
          }
          else
          {
            *(_DWORD *)long long v53 = v51;
            uint64_t v54 = v53 + 4;
          }
          *(void *)(a1 + 96) = v54;
          uint64_t v64 = *(void **)(a1 + 144);
          unint64_t v63 = *(void *)(a1 + 152);
          if ((unint64_t)v64 >= v63)
          {
            uint64_t v66 = ((char *)v64 - *v270) >> 3;
            if ((unint64_t)(v66 + 1) >> 61) {
              goto LABEL_301;
            }
            uint64_t v67 = v63 - (void)*v270;
            uint64_t v68 = v67 >> 2;
            if (v67 >> 2 <= (unint64_t)(v66 + 1)) {
              uint64_t v68 = v66 + 1;
            }
            if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v69 = v68;
            }
            if (v69) {
              unsigned __int32 v70 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(v259, v69);
            }
            else {
              unsigned __int32 v70 = 0;
            }
            BOOL v71 = &v70[8 * v66];
            *(void *)BOOL v71 = v51 << 32;
            long long v65 = v71 + 8;
            float32x4_t v73 = *(char **)(a1 + 136);
            unint64_t v72 = *(char **)(a1 + 144);
            if (v72 != v73)
            {
              do
              {
                uint64_t v74 = *((void *)v72 - 1);
                v72 -= 8;
                *((void *)v71 - 1) = v74;
                v71 -= 8;
              }
              while (v72 != v73);
              unint64_t v72 = *v270;
            }
            *(void *)(a1 + 136) = v71;
            *(void *)(a1 + 144) = v65;
            *(void *)(a1 + 152) = &v70[8 * v69];
            if (v72) {
              operator delete(v72);
            }
          }
          else
          {
            *uint64_t v64 = v51 << 32;
            long long v65 = v64 + 1;
          }
          *(void *)(a1 + 144) = v65;
          int v75 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * v16);
          if (v75 == -1)
          {
            uint64_t v76 = *(void *)(a1 + 16);
            uint64_t v78 = *(_OWORD **)(a1 + 72);
            unint64_t v77 = *(void *)(a1 + 80);
            if ((unint64_t)v78 >= v77)
            {
              uint64_t v80 = *(void *)(a1 + 64);
              uint64_t v81 = ((uint64_t)v78 - v80) >> 4;
              if ((unint64_t)(v81 + 1) >> 60) {
                goto LABEL_301;
              }
              uint64_t v82 = v77 - v80;
              uint64_t v83 = v82 >> 3;
              if (v82 >> 3 <= (unint64_t)(v81 + 1)) {
                uint64_t v83 = v81 + 1;
              }
              if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v84 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v84 = v83;
              }
              if (v84) {
                long long v85 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v84);
              }
              else {
                long long v85 = 0;
              }
              float32x4_t v131 = &v85[16 * v81];
              *(_OWORD *)float32x4_t v131 = *(_OWORD *)(v76 + 16 * v16);
              int8x16_t v79 = v131 + 16;
              unsigned int v133 = *(char **)(a1 + 64);
              float32x4_t v132 = *(char **)(a1 + 72);
              if (v132 != v133)
              {
                do
                {
                  long long v134 = *((_OWORD *)v132 - 1);
                  v132 -= 16;
                  *((_OWORD *)v131 - 1) = v134;
                  v131 -= 16;
                }
                while (v132 != v133);
                float32x4_t v132 = *(char **)(a1 + 64);
              }
              *(void *)(a1 + 64) = v131;
              *(void *)(a1 + 72) = v79;
              *(void *)(a1 + 80) = &v85[16 * v84];
              if (v132) {
                operator delete(v132);
              }
            }
            else
            {
              *uint64_t v78 = *(_OWORD *)(v76 + 16 * v16);
              int8x16_t v79 = v78 + 1;
            }
            *(void *)(a1 + 72) = v79;
            int v75 = (((unint64_t)v79 - *(void *)(a1 + 64)) >> 4) - 1;
            *(_DWORD *)(*(void *)(a1 + 112) + 4 * v16) = v75;
          }
          v136 = *(char **)(a1 + 96);
          unint64_t v135 = *(void *)(a1 + 104);
          if ((unint64_t)v136 >= v135)
          {
            uint64_t v138 = *(char **)(a1 + 88);
            uint64_t v139 = (v136 - v138) >> 2;
            unint64_t v140 = v139 + 1;
            if ((unint64_t)(v139 + 1) >> 62) {
              goto LABEL_301;
            }
            uint64_t v141 = v135 - (void)v138;
            if (v141 >> 1 > v140) {
              unint64_t v140 = v141 >> 1;
            }
            if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v142 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v142 = v140;
            }
            if (v142)
            {
              unsigned int v143 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v142);
              uint64_t v138 = *(char **)(a1 + 88);
              v136 = *(char **)(a1 + 96);
            }
            else
            {
              unsigned int v143 = 0;
            }
            float32x2_t v144 = &v143[4 * v139];
            *(_DWORD *)float32x2_t v144 = v75;
            uint64_t v137 = v144 + 4;
            while (v136 != v138)
            {
              int v145 = *((_DWORD *)v136 - 1);
              v136 -= 4;
              *((_DWORD *)v144 - 1) = v145;
              v144 -= 4;
            }
            *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v144;
            *(void *)(a1 + 96) = v137;
            *(void *)(a1 + 104) = &v143[4 * v142];
            if (v138) {
              operator delete(v138);
            }
          }
          else
          {
            *(_DWORD *)v136 = v75;
            uint64_t v137 = v136 + 4;
          }
          *(void *)(a1 + 96) = v137;
        }
      }
      else
      {
        unsigned int v24 = v8->__begin_[v15];
        if (v24 == -1)
        {
          long long v26 = *(float32x4_t **)(a1 + 72);
          unint64_t v25 = *(void *)(a1 + 80);
          if ((unint64_t)v26 >= v25)
          {
            uint64_t v41 = *(void *)(a1 + 64);
            uint64_t v42 = ((uint64_t)v26 - v41) >> 4;
            if ((unint64_t)(v42 + 1) >> 60) {
              goto LABEL_301;
            }
            uint64_t v43 = v25 - v41;
            uint64_t v44 = v43 >> 3;
            if (v43 >> 3 <= (unint64_t)(v42 + 1)) {
              uint64_t v44 = v42 + 1;
            }
            if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v45 = v44;
            }
            if (v45)
            {
              uint64_t v46 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v45);
              float32x4_t v18 = *(float32x4_t *)(v17 + 16 * v15);
            }
            else
            {
              uint64_t v46 = 0;
            }
            char v86 = (float32x4_t *)&v46[16 * v42];
            *char v86 = v18;
            uint64_t v27 = (_OWORD *)v86[1].f32;
            unsigned int v88 = *(float32x4_t **)(a1 + 64);
            float32x4_t v87 = *(float32x4_t **)(a1 + 72);
            if (v87 != v88)
            {
              do
              {
                float32x4_t v89 = v87[-1];
                --v87;
                v86[-1] = v89;
                --v86;
              }
              while (v87 != v88);
              float32x4_t v87 = *(float32x4_t **)(a1 + 64);
            }
            *(void *)(a1 + 64) = v86;
            *(void *)(a1 + 72) = v27;
            *(void *)(a1 + 80) = &v46[16 * v45];
            if (v87) {
              operator delete(v87);
            }
          }
          else
          {
            float32x4_t *v26 = v18;
            uint64_t v27 = (_OWORD *)v26[1].f32;
          }
          *(void *)(a1 + 72) = v27;
          unsigned int v24 = (((unint64_t)v27 - *(void *)(a1 + 64)) >> 4) - 1;
          *(_DWORD *)(*(void *)(a1 + 112) + 4 * v15) = v24;
        }
        long long v91 = *(char **)(a1 + 96);
        unint64_t v90 = *(void *)(a1 + 104);
        if ((unint64_t)v91 >= v90)
        {
          float32x4_t v93 = *(unsigned char **)(a1 + 88);
          uint64_t v94 = (v91 - v93) >> 2;
          unint64_t v95 = v94 + 1;
          if ((unint64_t)(v94 + 1) >> 62) {
            goto LABEL_301;
          }
          uint64_t v96 = v90 - (void)v93;
          if (v96 >> 1 > v95) {
            unint64_t v95 = v96 >> 1;
          }
          if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v97 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v97 = v95;
          }
          if (v97)
          {
            float v98 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v97);
            float32x4_t v93 = *(unsigned char **)(a1 + 88);
            long long v91 = *(char **)(a1 + 96);
          }
          else
          {
            float v98 = 0;
          }
          long long v99 = (unsigned int *)&v98[4 * v94];
          *long long v99 = v24;
          long long v92 = (char *)(v99 + 1);
          while (v91 != v93)
          {
            unsigned int v100 = *((_DWORD *)v91 - 1);
            v91 -= 4;
            *--long long v99 = v100;
          }
          *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v99;
          *(void *)(a1 + 96) = v92;
          *(void *)(a1 + 104) = &v98[4 * v97];
          if (v93) {
            operator delete(v93);
          }
        }
        else
        {
          *(_DWORD *)long long v91 = v24;
          long long v92 = v91 + 4;
        }
        *(void *)(a1 + 96) = v92;
        int v101 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * v16);
        if (v101 == -1)
        {
          uint64_t v102 = *(void *)(a1 + 16);
          long long v104 = *(_OWORD **)(a1 + 72);
          unint64_t v103 = *(void *)(a1 + 80);
          if ((unint64_t)v104 >= v103)
          {
            uint64_t v106 = *(void *)(a1 + 64);
            uint64_t v107 = ((uint64_t)v104 - v106) >> 4;
            if ((unint64_t)(v107 + 1) >> 60) {
              goto LABEL_301;
            }
            uint64_t v108 = v103 - v106;
            uint64_t v109 = v108 >> 3;
            if (v108 >> 3 <= (unint64_t)(v107 + 1)) {
              uint64_t v109 = v107 + 1;
            }
            if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v110 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v110 = v109;
            }
            if (v110) {
              int v111 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v262, v110);
            }
            else {
              int v111 = 0;
            }
            float32x4_t v112 = &v111[16 * v107];
            *(_OWORD *)float32x4_t v112 = *(_OWORD *)(v102 + 16 * v16);
            uint64_t v105 = v112 + 16;
            long long v114 = *(char **)(a1 + 64);
            unsigned int v113 = *(char **)(a1 + 72);
            if (v113 != v114)
            {
              do
              {
                long long v115 = *((_OWORD *)v113 - 1);
                v113 -= 16;
                *((_OWORD *)v112 - 1) = v115;
                v112 -= 16;
              }
              while (v113 != v114);
              unsigned int v113 = *(char **)(a1 + 64);
            }
            *(void *)(a1 + 64) = v112;
            *(void *)(a1 + 72) = v105;
            *(void *)(a1 + 80) = &v111[16 * v110];
            if (v113) {
              operator delete(v113);
            }
          }
          else
          {
            *long long v104 = *(_OWORD *)(v102 + 16 * v16);
            uint64_t v105 = v104 + 1;
          }
          *(void *)(a1 + 72) = v105;
          int v101 = (((unint64_t)v105 - *(void *)(a1 + 64)) >> 4) - 1;
          *(_DWORD *)(*(void *)(a1 + 112) + 4 * v16) = v101;
          long long v92 = *(char **)(a1 + 96);
        }
        if ((unint64_t)v92 >= *v12)
        {
          int32x4_t v117 = *(char **)(a1 + 88);
          uint64_t v118 = (v92 - v117) >> 2;
          unint64_t v119 = v118 + 1;
          if ((unint64_t)(v118 + 1) >> 62) {
            goto LABEL_301;
          }
          uint64_t v120 = *v12 - (void)v117;
          if (v120 >> 1 > v119) {
            unint64_t v119 = v120 >> 1;
          }
          if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v121 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v121 = v119;
          }
          if (v121)
          {
            float32x4_t v122 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v121);
            int32x4_t v117 = *(char **)(a1 + 88);
            long long v92 = *(char **)(a1 + 96);
          }
          else
          {
            float32x4_t v122 = 0;
          }
          float32x4_t v123 = &v122[4 * v118];
          *(_DWORD *)float32x4_t v123 = v101;
          uint64_t v116 = v123 + 4;
          while (v92 != v117)
          {
            int v124 = *((_DWORD *)v92 - 1);
            v92 -= 4;
            *((_DWORD *)v123 - 1) = v124;
            v123 -= 4;
          }
          *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v123;
          *(void *)(a1 + 96) = v116;
          *(void *)(a1 + 104) = &v122[4 * v121];
          if (v117) {
            operator delete(v117);
          }
        }
        else
        {
          *(_DWORD *)long long v92 = v101;
          uint64_t v116 = v92 + 4;
        }
        *(void *)(a1 + 96) = v116;
      }
      ++v11;
    }
    while (v11 != v13);
  }
  uint64_t v199 = *(void *)(a1 + 136);
  long long v198 = *(float **)(a1 + 144);
  unint64_t v200 = (unint64_t)v198 - v199;
  if ((unint64_t)v198 - v199 > 0x10)
  {
    if (v200 >= 0x19)
    {
      uint64_t v201 = *(void *)(a1 + 64);
      float32x4_t v202 = *(float32x4_t *)(v201 + 16 * *(int *)(v199 + 4));
      uint64_t v203 = (v200 >> 3);
      if ((int)(v200 >> 3) > 1)
      {
        float32x4_t v204 = (int *)(v199 + 12);
        uint64_t v205 = v203 - 1;
        do
        {
          uint64_t v206 = *v204;
          v204 += 2;
          float32x4_t v202 = vaddq_f32(v202, *(float32x4_t *)(v201 + 16 * v206));
          --v205;
        }
        while (v205);
      }
      unint64_t v207 = (uint64_t)v200 >> 3;
      if ((int)(v200 >> 3) >= 1)
      {
        float32x4_t v208 = vmulq_f32((float32x4_t)v272, (float32x4_t)xmmword_20B5CB520);
        float32x4_t v209 = vaddq_f32(v208, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v208.f32, 1));
        float32x4_t v210 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v208, 2), v209);
        v210.f32[0] = fabsf(v210.f32[0]);
        v209.i32[0] = 1064514355;
        float32x4_t v211 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v210, v209), 0), (int8x16_t)xmmword_20B5CB7D0, (int8x16_t)xmmword_20B5CB520);
        float32x4_t v212 = vnegq_f32((float32x4_t)v272);
        float32x4_t v213 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v272, (int32x4_t)v272), v272, 0xCuLL);
        int32x4_t v214 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v211, (int32x4_t)v211), (int8x16_t)v211, 0xCuLL), v212), v211, v213);
        float32x4_t v215 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v214, v214), (int8x16_t)v214, 0xCuLL);
        float32x4_t v216 = vmulq_f32((float32x4_t)v272, v215);
        float32x4_t v217 = vmlsq_lane_f32(v215, (float32x4_t)v272, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v216, 2), vaddq_f32(v216, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v216.f32, 1))), 0);
        int32x4_t v218 = (int32x4_t)vmulq_f32(v217, v217);
        v218.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v218, 2), vadd_f32(*(float32x2_t *)v218.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v218.i8, 1))).u32[0];
        float32x2_t v219 = vrsqrte_f32((float32x2_t)v218.u32[0]);
        float32x2_t v220 = vmul_f32(v219, vrsqrts_f32((float32x2_t)v218.u32[0], vmul_f32(v219, v219)));
        float32x4_t v273 = vmulq_n_f32(v217, vmul_f32(v220, vrsqrts_f32((float32x2_t)v218.u32[0], vmul_f32(v220, v220))).f32[0]);
        int32x4_t v221 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v273, (int32x4_t)v273), (int8x16_t)v273, 0xCuLL), v212), v273, v213);
        int8x16_t v222 = vextq_s8((int8x16_t)vuzp1q_s32(v221, v221), (int8x16_t)v221, 0xCuLL);
        *(float *)v221.i32 = (float)v207;
        float32x4_t v263 = vdivq_f32(v202, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v221.i8, 0));
        float32x4_t v268 = (float32x4_t)v222;
        uint64_t v223 = (float *)(v199 + 4);
        do
        {
          float32x4_t v224 = vsubq_f32(*(float32x4_t *)(v201 + 16 * *(int *)v223), v263);
          float32x4_t v225 = vmulq_f32(v273, v224);
          float32x4_t v226 = vmulq_f32(v268, v224);
          *(v223 - 1) = atan2f(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v225, 2), vaddq_f32(v225, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v225.f32, 1))).f32[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v226, 2), vaddq_f32(v226, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v226.f32, 1))).f32[0]);
          v223 += 2;
          --v203;
        }
        while (v203);
      }
      unint64_t v227 = 126 - 2 * __clz(v207);
      if (v198 == (float *)v199) {
        uint64_t v228 = 0;
      }
      else {
        uint64_t v228 = v227;
      }
      std::__introsort<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *,false>(v199, v198, (uint64_t)&v274, v228, 1);
      uint64_t v199 = *(void *)(a1 + 136);
      unint64_t v200 = *(void *)(a1 + 144) - v199;
    }
    if ((int)(v200 >> 3) >= 1)
    {
      uint64_t v229 = 0;
      float32x4_t v230 = (char **)(a1 + 104);
      float32x4_t v231 = *(char **)(a1 + 96);
      do
      {
        float32x4_t v232 = (_DWORD *)(v199 + 8 * v229 + 4);
        float32x4_t v233 = *v230;
        if (v231 >= *v230)
        {
          float32x4_t v235 = *(unsigned char **)(a1 + 88);
          uint64_t v236 = (v231 - v235) >> 2;
          unint64_t v237 = v236 + 1;
          if ((unint64_t)(v236 + 1) >> 62) {
            goto LABEL_301;
          }
          uint64_t v238 = v233 - v235;
          if (v238 >> 1 > v237) {
            unint64_t v237 = v238 >> 1;
          }
          if ((unint64_t)v238 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v239 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v239 = v237;
          }
          if (v239)
          {
            uint64_t v240 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v239);
            float32x4_t v235 = *(unsigned char **)(a1 + 88);
            float32x4_t v231 = *(char **)(a1 + 96);
          }
          else
          {
            uint64_t v240 = 0;
          }
          unsigned int v241 = &v240[4 * v236];
          *(_DWORD *)unsigned int v241 = *v232;
          float32x4_t v234 = v241 + 4;
          while (v231 != v235)
          {
            int v242 = *((_DWORD *)v231 - 1);
            v231 -= 4;
            *((_DWORD *)v241 - 1) = v242;
            v241 -= 4;
          }
          float32x4_t v233 = &v240[4 * v239];
          *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v241;
          *(void *)(a1 + 96) = v234;
          *(void *)(a1 + 104) = v233;
          if (v235)
          {
            operator delete(v235);
            float32x4_t v233 = *v230;
          }
        }
        else
        {
          *(_DWORD *)float32x4_t v231 = *v232;
          float32x4_t v234 = v231 + 4;
        }
        *(void *)(a1 + 96) = v234;
        float32x4_t v243 = (_DWORD *)(*(void *)(a1 + 136)
                        + 8
                        * (++v229 % (unint64_t)((uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 136)) >> 3))
                        + 4);
        if (v234 >= v233)
        {
          long long v244 = *(unsigned char **)(a1 + 88);
          uint64_t v245 = (v234 - v244) >> 2;
          unint64_t v246 = v245 + 1;
          if ((unint64_t)(v245 + 1) >> 62) {
            goto LABEL_301;
          }
          uint64_t v247 = v233 - v244;
          if (v247 >> 1 > v246) {
            unint64_t v246 = v247 >> 1;
          }
          if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v248 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v248 = v246;
          }
          if (v248)
          {
            long long v249 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 104, v248);
            long long v244 = *(unsigned char **)(a1 + 88);
            float32x4_t v234 = *(char **)(a1 + 96);
          }
          else
          {
            long long v249 = 0;
          }
          int32x4_t v250 = &v249[4 * v245];
          *(_DWORD *)int32x4_t v250 = *v243;
          float32x4_t v231 = v250 + 4;
          while (v234 != v244)
          {
            int v251 = *((_DWORD *)v234 - 1);
            v234 -= 4;
            *((_DWORD *)v250 - 1) = v251;
            v250 -= 4;
          }
          *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v250;
          *(void *)(a1 + 96) = v231;
          *(void *)(a1 + 104) = &v249[4 * v248];
          if (v244) {
            operator delete(v244);
          }
        }
        else
        {
          *(_DWORD *)float32x4_t v234 = *v243;
          float32x4_t v231 = v234 + 4;
        }
        *(void *)(a1 + 96) = v231;
        uint64_t v199 = *(void *)(a1 + 136);
      }
      while (v229 < (int)((unint64_t)(*(void *)(a1 + 144) - v199) >> 3));
    }
  }
  long long v253 = *(_OWORD *)(a1 + 64);
  uint64_t v252 = a1 + 64;
  long long v254 = *(_OWORD *)(v252 - 16);
  long long v255 = *(_OWORD *)(v252 + 16);
  long long v256 = *(_OWORD *)(v252 + 32);
  long long v257 = *(_OWORD *)(v252 - 48);
  long long v258 = *(_OWORD *)(v252 - 32);
  *(_OWORD *)(v252 - 4_Block_object_dispose(&STACK[0x2A0], 8) = v253;
  *(_OWORD *)(v252 - 32) = v255;
  *(_OWORD *)(v252 - 16) = v256;
  *(_OWORD *)uint64_t v252 = v257;
  *(_OWORD *)(v252 + 16) = v258;
  *(_OWORD *)(v252 + 32) = v254;
  std::vector<int>::resize((std::vector<unsigned int> *)(v252 + 24), 0);
  _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm(v252, 0);
  std::vector<int>::resize(v8, 0);
  std::vector<ClippedCorner>::resize((uint64_t)v270, 0);
}

void std::vector<ClippedCorner>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<ClippedCorner>::__append((void **)a1, a2 - v2);
  }
}

BOOL C3DConvexPolyhedronClipAABB(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v19 = vaddq_f32(a2, a3);
  LODWORD(v4) = 1.0;
  *((float *)&v4 + 1) = -v19.f32[2];
  C3DConvexPolyhedronClipPlane(a1, 0, v4);
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    return 0;
  }
  __asm { FMOV            V0.4S, #1.0 }
  DWORD2(_Q0) = 0;
  *((float *)&_Q0 + 3) = -v19.f32[0];
  C3DConvexPolyhedronClipPlane(a1, _Q0, *((uint64_t *)&_Q0 + 1));
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    return 0;
  }
  LODWORD(v10) = 0;
  float32x4_t v18 = vsubq_f32(a2, a3);
  HIDWORD(v10) = v18.i32[0];
  C3DConvexPolyhedronClipPlane(a1, 3212836864, v10);
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    return 0;
  }
  LODWORD(v11) = 0;
  HIDWORD(v11) = 1.0;
  LODWORD(v12) = 0;
  *((float *)&v12 + 1) = -v19.f32[1];
  C3DConvexPolyhedronClipPlane(a1, v11, v12);
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    return 0;
  }
  LODWORD(v13) = 0;
  HIDWORD(v13) = v18.i32[1];
  C3DConvexPolyhedronClipPlane(a1, 0xBF80000000000000, v13);
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    return 0;
  }
  LODWORD(v14) = -1082130432;
  HIDWORD(v14) = v18.i32[2];
  C3DConvexPolyhedronClipPlane(a1, 0, v14);
  return *(void *)(a1 + 40) != *(void *)(a1 + 48);
}

float32x4_t C3DConvexPolyhedronTransform(uint64_t a1, float32x4_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
  if ((int)(v2 >> 4) >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = v2 & 0xFFFFFFFF0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      float32x4_t result = vaddq_f32(a2[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a2[1], *(float32x2_t *)(v5 + v3), 1), *a2, COERCE_FLOAT(*(_OWORD *)(v5 + v3))), a2[2], *(float32x4_t *)(v5 + v3), 2));
      *(float32x4_t *)(v5 + v3) = result;
      v3 += 16;
    }
    while (v4 != v3);
  }
  return result;
}

float32x4_t C3DConvexPolyhedronComputeBoxInSpace(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t result = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  float32x2_t v7 = *(float32x4_t **)(a1 + 16);
  unint64_t v8 = *(void *)(a1 + 24) - (void)v7;
  float32x4_t v9 = (float32x4_t)xmmword_20B5CB570;
  if ((int)(v8 >> 4) >= 1)
  {
    uint64_t v10 = (v8 >> 4);
    v11.i64[0] = 0x3F0000003F000000;
    v11.i64[1] = 0x3F0000003F000000;
    do
    {
      float32x4_t v12 = *v7++;
      float32x4_t v13 = vaddq_f32(a5, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a3, *(float32x2_t *)v12.f32, 1), a2, v12.f32[0]), a4, v12, 2));
      float32x4_t v14 = vsubq_f32(result, v9);
      v14.i32[3] = 0;
      v13.i32[3] = 0;
      float32x4_t v15 = vminnmq_f32(v14, v13);
      float32x4_t v16 = vaddq_f32(result, v9);
      v16.i32[3] = 0;
      float32x4_t v17 = vmaxnmq_f32(v16, v13);
      float32x4_t result = vmulq_f32(vaddq_f32(v15, v17), v11);
      float32x4_t v9 = vmulq_f32(vsubq_f32(v17, v15), v11);
      result.i32[3] = 1.0;
      v9.i32[3] = 0;
      --v10;
    }
    while (v10);
  }
  return result;
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  float32x2_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  float32x2_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float32x4_t v13 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v4, v12);
    }
    else {
      float32x4_t v13 = 0;
    }
    float32x4_t v14 = &v13[16 * v10];
    float32x4_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    float32x4_t v16 = &v14[16 * a2];
    float32x4_t v18 = (char *)*a1;
    float32x4_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      float32x4_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void std::vector<int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  uint64_t v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<unsigned int>::pointer begin = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      float32x4_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      std::vector<unsigned int>::pointer begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      float32x4_t v14 = 0;
    }
    float32x4_t v15 = &v14[4 * v11];
    float32x4_t v16 = (unsigned int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    float32x4_t v17 = (unsigned int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void std::vector<ClippedCorner>::__append(void **a1, unint64_t a2)
{
  float32x2_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  float32x2_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    float32x4_t v14 = &v13[8 * v10];
    float32x4_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    float32x4_t v16 = &v14[8 * a2];
    int v18 = (char *)*a1;
    float32x4_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      float32x4_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *,false>(uint64_t result, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (uint64_t)a2 - v11;
    unint64_t v15 = ((uint64_t)a2 - v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          if (*(a2 - 2) < *(float *)v11)
          {
            uint64_t v22 = *(void *)v11;
            *(void *)uint64_t v11 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v22;
          }
          break;
        case 3uLL:
          float32x4_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)v11, (float *)(v11 + 8), a2 - 2);
          break;
        case 4uLL:
          float32x4_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)v11, (float *)(v11 + 8), (float *)(v11 + 16), (void *)a2 - 1);
          break;
        case 5uLL:
          float32x4_t result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)v11, (float *)(v11 + 8), (float *)(v11 + 16), (uint64_t *)(v11 + 24), (uint64_t *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if ((float *)v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *,ClippedCorner *>((float *)v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    float32x4_t v17 = (float *)(v11 + 8 * (v15 >> 1));
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)v11, (float *)(v11 + 8 * (v15 >> 1)), a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)(v11 + 8), v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)(v11 + 16), (float *)(v11 + 8 + 8 * v16), a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(v17 - 2, v17, (float *)(v11 + 8 + 8 * v16));
      uint64_t v18 = *(void *)v11;
      *(void *)uint64_t v11 = *(void *)v17;
      *(void *)float32x4_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)(v11 + 8 * (v15 >> 1)), (float *)v11, a2 - 2);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(v11 - 8) >= *(float *)v11)
    {
      float32x4_t result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,ClippedCorner *,CompareCornerAngle &>((float *)v11, a2);
      uint64_t v11 = result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,ClippedCorner *,CompareCornerAngle &>((float *)v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(v11, (uint64_t)v19);
    uint64_t v11 = (uint64_t)(v19 + 2);
    float32x4_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((uint64_t)(v19 + 2), (uint64_t)a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      float32x4_t result = std::__introsort<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *,false>(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = (uint64_t)(v19 + 2);
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(v11, (uint64_t)a2);
  }
  else if ((float *)v11 != a2)
  {
    float v23 = (float *)(v11 + 8);
    while (v23 != a2)
    {
      unsigned int v24 = v23;
      float v25 = *(float *)(v10 + 8);
      if (v25 < *(float *)v10)
      {
        int v26 = *(_DWORD *)(v10 + 12);
        uint64_t v27 = v24;
        do
        {
          unint64_t v28 = v27;
          uint64_t v29 = *((void *)v27 - 1);
          v27 -= 2;
          *(void *)unint64_t v28 = v29;
        }
        while (*(v28 - 4) > v25);
        *uint64_t v27 = v25;
        *((_DWORD *)v27 + 1) = v26;
      }
      float v23 = v24 + 2;
      uint64_t v10 = (uint64_t)v24;
    }
  }
  return result;
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 8;
    if (result + 8 != a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        uint64_t v5 = v2;
        float v6 = *(float *)(v4 + 8);
        if (v6 < *(float *)v4)
        {
          int v7 = *(_DWORD *)(v4 + 12);
          uint64_t v8 = v3;
          while (1)
          {
            *(void *)(result + v8 + _Block_object_dispose(&STACK[0x2A0], 8) = *(void *)(result + v8);
            if (!v8) {
              break;
            }
            float v9 = *(float *)(result + v8 - 8);
            v8 -= 8;
            if (v9 <= v6)
            {
              uint64_t v10 = result + v8 + 8;
              goto LABEL_10;
            }
          }
          uint64_t v10 = result;
LABEL_10:
          *(float *)uint64_t v10 = v6;
          *(_DWORD *)(v10 + 4) = v7;
        }
        uint64_t v2 = v5 + 8;
        v3 += 8;
        uint64_t v4 = v5;
      }
      while (v5 + 8 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(float *a1, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a3;
  if (*a2 < *a1)
  {
    uint64_t v5 = *(void *)a1;
    if (v4 < v3)
    {
      *(void *)a1 = *(void *)a3;
      *(void *)a3 = v5;
      return 1;
    }
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = v5;
    if (*a3 >= *(float *)&v5) {
      return 1;
    }
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v5;
    return 2;
  }
  if (v4 < v3)
  {
    uint64_t v6 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v6;
    if (*a2 >= *a1) {
      return 1;
    }
    uint64_t v7 = *(void *)a1;
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = v7;
    return 2;
  }
  return 0;
}

float *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,ClippedCorner *,CompareCornerAngle &>(float *a1, float *a2)
{
  uint64_t v2 = *(void *)a1;
  if (*(a2 - 2) <= COERCE_FLOAT(*(void *)a1))
  {
    uint64_t v5 = a1 + 2;
    do
    {
      float v3 = v5;
      if (v5 >= a2) {
        break;
      }
      v5 += 2;
    }
    while (*v3 <= *(float *)&v2);
  }
  else
  {
    float v3 = a1;
    do
    {
      float v4 = v3[2];
      v3 += 2;
    }
    while (v4 <= *(float *)&v2);
  }
  if (v3 < a2)
  {
    do
    {
      float v6 = *(a2 - 2);
      a2 -= 2;
    }
    while (v6 > *(float *)&v2);
  }
  while (v3 < a2)
  {
    uint64_t v7 = *(void *)v3;
    *(void *)float v3 = *(void *)a2;
    *(void *)a2 = v7;
    do
    {
      float v8 = v3[2];
      v3 += 2;
    }
    while (v8 <= *(float *)&v2);
    do
    {
      float v9 = *(a2 - 2);
      a2 -= 2;
    }
    while (v9 > *(float *)&v2);
  }
  if (v3 - 2 != a1) {
    *(void *)a1 = *((void *)v3 - 1);
  }
  *((void *)v3 - 1) = v2;
  return v3;
}

float *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,ClippedCorner *,CompareCornerAngle &>(float *a1, float *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)a1;
  do
  {
    float v4 = a1[v2 + 2];
    v2 += 2;
  }
  while (v4 < *(float *)&v3);
  uint64_t v5 = &a1[v2];
  float v6 = &a1[v2 - 2];
  if (v2 == 2)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      float v8 = *(a2 - 2);
      a2 -= 2;
    }
    while (v8 >= *(float *)&v3);
  }
  else
  {
    do
    {
      float v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v7 >= *(float *)&v3);
  }
  if (v5 < a2)
  {
    float v9 = &a1[v2];
    uint64_t v10 = a2;
    do
    {
      uint64_t v11 = *(void *)v9;
      *(void *)float v9 = *(void *)v10;
      *(void *)uint64_t v10 = v11;
      do
      {
        float v12 = v9[2];
        v9 += 2;
      }
      while (v12 < *(float *)&v3);
      do
      {
        float v13 = *(v10 - 2);
        v10 -= 2;
      }
      while (v13 >= *(float *)&v3);
    }
    while (v9 < v10);
    float v6 = v9 - 2;
  }
  if (v6 != a1) {
    *(void *)a1 = *(void *)v6;
  }
  *(void *)float v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 8) < *(float *)a1)
      {
        uint64_t v6 = *(void *)a1;
        *(void *)a1 = *(void *)(a2 - 8);
        *(void *)(a2 - _Block_object_dispose(&STACK[0x2A0], 8) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)a1, (float *)(a1 + 8), (float *)(a2 - 8));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), (void *)(a2 - 8));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), (uint64_t *)(a1 + 24), (uint64_t *)(a2 - 8));
      return 1;
    default:
      float v7 = (float *)(a1 + 16);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16));
      uint64_t v8 = a1 + 24;
      if (a1 + 24 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    float v11 = *(float *)v8;
    if (*(float *)v8 < *v7)
    {
      int v12 = *(_DWORD *)(v8 + 4);
      uint64_t v13 = v9;
      while (1)
      {
        *(void *)(a1 + v13 + 24) = *(void *)(a1 + v13 + 16);
        if (v13 == -16) {
          break;
        }
        float v14 = *(float *)(a1 + v13 + 8);
        v13 -= 8;
        if (v14 <= v11)
        {
          uint64_t v15 = a1 + v13 + 24;
          goto LABEL_12;
        }
      }
      uint64_t v15 = a1;
LABEL_12:
      *(float *)uint64_t v15 = v11;
      *(_DWORD *)(v15 + 4) = v12;
      if (++v10 == 8) {
        return v8 + 8 == a2;
      }
    }
    float v7 = (float *)v8;
    v9 += 8;
    v8 += 8;
    if (v8 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(float *a1, float *a2, float *a3, void *a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(a1, a2, a3);
  if (*(float *)a4 < *a3)
  {
    uint64_t v9 = *(void *)a3;
    *(void *)a3 = *a4;
    *a4 = v9;
    if (*a3 < *a2)
    {
      uint64_t v10 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v10;
      if (*a2 < *a1)
      {
        uint64_t v11 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(float *a1, float *a2, float *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(a1, a2, a3, a4);
  if (*(float *)a5 < *(float *)a4)
  {
    uint64_t v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    if (*(float *)a4 < *a3)
    {
      uint64_t v12 = *(void *)a3;
      *(void *)a3 = *a4;
      *a4 = v12;
      if (*a3 < *a2)
      {
        uint64_t v13 = *(void *)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v13;
        if (*a2 < *a1)
        {
          uint64_t v14 = *(void *)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v14;
        }
      }
    }
  }
  return result;
}

float *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *,ClippedCorner *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        if (*v14 < *a1)
        {
          uint64_t v15 = *(void *)v14;
          *(void *)uint64_t v14 = *(void *)a1;
          *(void *)a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = a1;
        do
        {
          char v20 = v19;
          v19 += 2 * v17 + 2;
          uint64_t v21 = 2 * v17;
          uint64_t v17 = (2 * v17) | 1;
          uint64_t v22 = v21 + 2;
          if (v22 < v16 && *v19 < v19[2])
          {
            v19 += 2;
            uint64_t v17 = v22;
          }
          *(void *)char v20 = *(void *)v19;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        v6 -= 2;
        if (v19 == v6)
        {
          *(void *)uint64_t v19 = v18;
        }
        else
        {
          *(void *)uint64_t v19 = *(void *)v6;
          *(void *)uint64_t v6 = v18;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>((uint64_t)a1, (uint64_t)(v19 + 2), a4, ((char *)(v19 + 2) - (char *)a1) >> 3);
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (float *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3 && *v8 < v8[2])
      {
        v8 += 2;
        uint64_t v7 = v9;
      }
      float v10 = *a4;
      if (*v8 >= *a4)
      {
        int v11 = *((_DWORD *)a4 + 1);
        do
        {
          uint64_t v12 = a4;
          a4 = v8;
          *(void *)uint64_t v12 = *(void *)v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 8 * v7);
          uint64_t v14 = v13 + 2;
          if (v14 < a3 && *v8 < v8[2])
          {
            v8 += 2;
            uint64_t v7 = v14;
          }
        }
        while (*v8 >= v10);
        *a4 = v10;
        *((_DWORD *)a4 + 1) = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,CompareCornerAngle &,ClippedCorner *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (void *)(result + 8 * (v4 >> 1));
    uint64_t v7 = (void *)(a2 - 8);
    float v8 = *(float *)(a2 - 8);
    if (*(float *)v6 < v8)
    {
      int v9 = *(_DWORD *)(a2 - 4);
      do
      {
        float v10 = v7;
        uint64_t v7 = v6;
        *float v10 = *v6;
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
        uint64_t v6 = (void *)(result + 8 * v5);
      }
      while (*(float *)v6 < v8);
      *(float *)uint64_t v7 = v8;
      *((_DWORD *)v7 + 1) = v9;
    }
  }
  return result;
}

uint64_t _configureStageInputOutputDescriptorWithDeformerFunction(void *a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)a3) {
    _configureStageInputOutputDescriptorWithDeformerFunction();
  }
  uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", a2);
  [v6 setFormat:*(void *)(a3 + 8)];
  [v6 setOffset:*(void *)(a3 + 16)];
  [v6 setBufferIndex:a2 + 10];
  uint64_t v7 = objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", objc_msgSend(v6, "bufferIndex"));
  [v7 setStepFunction:5];
  uint64_t v8 = *(void *)(a3 + 24);

  return [v7 setStride:v8];
}

uint64_t _C3DAnimationManagerAddAnimationNode(uint64_t a1, uint64_t a2, const void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t Animation = C3DAnimationNodeGetAnimation(a2);
  uint64_t v31 = C3DAnimationSetup((CFTypeRef)Animation, (uint64_t)a3);
  if (v31)
  {
    C3DAnimationNodeSetTarget(a2, a3);
    if (_C3DAnimationReadsDestinationBuffer((unsigned char *)Animation)) {
      int v32 = 4096;
    }
    else {
      int v32 = 0;
    }
    *(_DWORD *)(a2 + 121) = *(_DWORD *)(a2 + 121) & 0xFFFFEFFF | v32;
    if ((*(unsigned char *)(Animation + 84) & 4) != 0 && *(float *)(Animation + 76) > 1.0)
    {
      *(void *)(a2 + 112) = malloc_type_calloc(0x20uLL, 1uLL, 0xD89A7E41uLL);
      Baseint Type = C3DModelTargetGetBaseType((uint64_t)a3);
      *(void *)(*(void *)(a2 + 112) + 24) = C3DValueCreate(BaseType, 1);
      uint64_t v34 = C3DValueCreate(BaseType, 1);
      *(void *)(*(void *)(a2 + 112) + 16) = v34;
      Bytes = (void *)C3DValueGetBytes(v34);
      C3DModelTargetGetValue((uint64_t)a3, Bytes);
      C3DAnimationEvaluate(Animation);
    }
    CFTypeID v36 = CFGetTypeID((CFTypeRef)a2);
    if (v36 == C3DAnimationClusterNodeGetTypeID())
    {
      uint64_t v37 = scn_default_log();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerAddAnimationNode_cold_1(v37, v38, v39, v40, v41, v42, v43, v44);
      }
    }
    TargetAddress = (void *)C3DModelTargetGetTargetAddress((uint64_t)a3);
    __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey(a1, (void *)a2, TargetAddress, a3);
  }
  else
  {
    uint64_t v46 = scn_default_log();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v48 = 0;
      _os_log_impl(&dword_20B249000, v46, OS_LOG_TYPE_DEFAULT, "Warning: fail to setup the animation - won't be added to the animation stack", v48, 2u);
    }
  }
  return v31;
}

void __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey(uint64_t a1, void *a2, void *key, const void *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), key);
  if (Value
    && (uint64_t Count = (uint64_t)Value - 1,
        (ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), (uint64_t)Value - 1)) != 0))
  {
    char appended = (void *)ValuePtrAtIndex;
  }
  else
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), key))
    {
      uint64_t v28 = scn_default_log();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
        __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey_cold_3(v28, v29, v30, v31, v32, v33, v34, v35);
      }
    }
    uint64_t Count = C3DArrayGetCount(*(void *)(a1 + 24));
    char appended = C3DArrayAppendValue(*(void *)(a1 + 24), 0);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), key, (const void *)(Count + 1));
    C3DAnimationStackInit(appended);
    appended[5] = key;
    C3DAnimationStackSetTarget((uint64_t)appended, a4);
    uint64_t TypeID = C3DAnimationClusterNodeGetTypeID();
    CFTypeID v37 = CFGetTypeID(a2);
    *((unsigned char *)appended + 4_Block_object_dispose(&STACK[0x2A0], 8) = TypeID == v37;
    if (TypeID != v37)
    {
      uint64_t Target = C3DAnimationStackGetTarget((uint64_t)appended);
      uint64_t v39 = Target;
      if (*(unsigned char *)(Target + 37))
      {
        *((unsigned char *)appended + 12_Block_object_dispose(&STACK[0x2A0], 8) = 1;
        if (!*(unsigned char *)(a2[3] + 34))
        {
          uint64_t v40 = scn_default_log();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
            __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey_cold_2(v40, v41, v42, v43, v44, v45, v46, v47);
          }
        }
        *(_WORD *)(v39 + 32) = 11;
        *(unsigned char *)(v39 + 36) = C3DSizeOfBaseType(11);
        *(_WORD *)(v39 + 34) = 8;
        int v48 = 11;
        Typeint Semantic = 8;
      }
      else
      {
        *((unsigned char *)appended + 12_Block_object_dispose(&STACK[0x2A0], 8) = 0;
        Baseint Type = C3DModelTargetGetBaseType(Target);
        Typeint Semantic = C3DModelTargetGetTypeSemantic(v39);
        int v48 = BaseType;
      }
      appended[31] = C3DKeyFrameInterpolatorForType(v48, TypeSemantic, 0, 0, 1);
      int v51 = C3DModelTargetGetBaseType(v39);
      *((unsigned char *)appended + 242) = C3DSizeOfBaseType(v51);
      uint64_t ModelValueStorage = C3DAnimationManagerGetModelValueStorage(a1);
      if (!ModelValueStorage)
      {
        long long v53 = scn_default_log();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
          __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey_cold_1(v53, v54, v55, v56, v57, v58, v59, v60);
        }
      }
      appended[4] = C3DModelValueStorageAddAndRetainModelValue(ModelValueStorage, (const void *)v39);
    }
  }
  if ((*(_WORD *)(C3DAnimationNodeGetAnimation((uint64_t)a2) + 84) & 8) != 0) {
    ++*(_DWORD *)(a1 + 168);
  }
  else {
    ++*(_DWORD *)(a1 + 164);
  }
  a2[19] = Count;
  a2[20] = key;
  C3DAnimationStackAppendAnimationNode((uint64_t)appended, a2, a1);
}

void C3DAnimationManagerTriggerCallbacks(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (*(unsigned char *)(a1 + 90))
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerTriggerCallbacks_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count >= 1)
  {
    CFIndex v19 = Count;
    CFArrayRef Copy = CFArrayCreateCopy(0, *(CFArrayRef *)(a1 + 80));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
    CFIndex v21 = 0;
    while (1)
    {
      ValueAtuint64_t Index = (const __CFDictionary *)CFArrayGetValueAtIndex(Copy, v21);
      uint64_t Animation = C3DAnimationNodeGetAnimation((uint64_t)ValueAtIndex);
      uint64_t v24 = (void *)Animation;
      int v25 = *(_DWORD *)((char *)ValueAtIndex + 121);
      *(_DWORD *)((char *)ValueAtIndex + 121) = v25 & 0xFFFE1FFF;
      if ((v25 & 0x22000) == 0x2000)
      {
        *(_DWORD *)((char *)ValueAtIndex + 121) = v25 & 0xFFFC1FFF | 0x20000;
        (*(void (**)(const __CFDictionary *))(Animation + 144))(ValueAtIndex);
      }
      if ((v25 & 0x8000) != 0)
      {
        int v26 = *(_DWORD *)((char *)ValueAtIndex + 121);
        if ((v26 & 0x80000) == 0)
        {
          *(_DWORD *)((char *)ValueAtIndex + 121) = v26 | 0x80000;
          uint64_t v27 = (void (*)(const __CFDictionary *))*((void *)ValueAtIndex + 26);
          if (v27) {
            v27(ValueAtIndex);
          }
          if (C3DAnimationGetCommitWhenDone((uint64_t)v24))
          {
            if (!v24[19])
            {
              uint64_t ModelValueStorage = C3DAnimationManagerGetModelValueStorage(a1);
              if (ModelValueStorage)
              {
                uint64_t v29 = *((void *)ValueAtIndex + 19);
                if (v29 != -1)
                {
                  uint64_t v30 = ModelValueStorage;
                  ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), v29);
                  C3DModelValueStorageUpdateModelValueFromPresentationValue(v30, *(void *)(ValuePtrAtIndex + 32));
                }
              }
            }
          }
        }
      }
      if ((v25 & 0x4000) == 0) {
        goto LABEL_34;
      }
      unsigned int v32 = *(_DWORD *)((char *)ValueAtIndex + 121);
      if ((v32 & 0x40000) != 0) {
        goto LABEL_34;
      }
      *(_DWORD *)((char *)ValueAtIndex + 121) = v32 | 0x40000;
      CFRetain(v24);
      uint64_t v33 = (uint64_t (*)(const __CFDictionary *, void, uint64_t, void))v24[19];
      if (v33 && (v33(ValueAtIndex, (v32 >> 10) & 1, a1, *((void *)ValueAtIndex + 17)) & 1) != 0
        || C3DIsRunningInEditor()
        && !C3DAnimationGetIsImplicit(*((void *)ValueAtIndex + 2))
        || *((double *)ValueAtIndex + 11) == 0.0
        && !C3DAnimationNodeGetRemovedOnCompletion((uint64_t)ValueAtIndex))
      {
        goto LABEL_33;
      }
      Owner = (void *)C3DAnimationNodeGetOwner((uint64_t)ValueAtIndex);
      if ((C3DAnimationGetIsImplicit((uint64_t)v24) & 1) == 0
        && Owner
        && _C3DAnimationManagerGetAnimationNodeForKey(a1, Owner, *((const void **)ValueAtIndex + 17)) == ValueAtIndex)
      {
        break;
      }
      _C3DAnimationManagerAppendCallback(a1, (char *)ValueAtIndex, 8);
      CFRelease(v24);
LABEL_37:
      if (v19 == ++v21)
      {
        CFRelease(Copy);
        return;
      }
    }
    _C3DAnimationManagerRemoveAnimationForKey(a1, Owner, *((void **)ValueAtIndex + 17));
LABEL_33:
    CFRelease(v24);
LABEL_34:
    if ((v25 & 0x10000) != 0)
    {
      int v35 = *(_DWORD *)((char *)ValueAtIndex + 121);
      if ((v35 & 0x100000) == 0)
      {
        *(_DWORD *)((char *)ValueAtIndex + 121) = v35 | 0x100000;
        _C3DAnimationManagerDiscardAnimationNodeFromStack(a1, ValueAtIndex);
      }
    }
    goto LABEL_37;
  }
}

uint64_t C3DAnimationManagerGetModelValueStorage(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

CFDictionaryRef _C3DAnimationManagerGetAnimationNodeForKey(uint64_t a1, void *key, const void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFDictionaryRef result = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a3);
  }
  return result;
}

void C3DAnimationManagerRemoveAnimationForKey(uint64_t a1, void *key, void *a3)
{
}

void _C3DAnimationManagerAppendCallback(uint64_t a1, char *value, char a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (value) {
      goto LABEL_6;
    }
  }
  else if (value)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (*(unsigned char *)(a1 + 90))
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerTriggerCallbacks_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  int v30 = *(_DWORD *)(value + 121);
  *(_DWORD *)(value + 121) = v30 | ((a3 & 0xF) << 13);
  if ((v30 & 0x1E000) == 0) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), value);
  }
}

void _C3DAnimationManagerDiscardAnimationNodeFromStack(uint64_t a1, void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t v20 = a2[19];
  if (v20 != -1)
  {
    ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), v20);
    uint64_t Animation = C3DAnimationNodeGetAnimation((uint64_t)a2);
    if ((*(_WORD *)(Animation + 84) & 8) != 0) {
      --*(_DWORD *)(a1 + 168);
    }
    else {
      --*(_DWORD *)(a1 + 164);
    }
    C3DAnimationStackRemoveAnimationNode(ValuePtrAtIndex, a2);
    if (*(unsigned char *)(ValuePtrAtIndex + 48)) {
      C3DAnimationStackDiscardModelValueItemForAnimationClusterNode(ValuePtrAtIndex, (uint64_t)a2, *(void *)(a1 + 16), (*(_WORD *)(Animation + 84) & 0x20) == 0);
    }
    if (C3DAnimationStackIsEmpty(ValuePtrAtIndex))
    {
      uint64_t v23 = (const void *)a2[20];
      uint64_t ModelValueStorage = C3DAnimationManagerGetModelValueStorage(a1);
      if (ModelValueStorage && !*(unsigned char *)(ValuePtrAtIndex + 48))
      {
        uint64_t v25 = ModelValueStorage;
        C3DModelValueStorageUpdatePresentationValueFromModelValue(ModelValueStorage, *(void *)(ValuePtrAtIndex + 32));
        C3DModelValueStorageReleaseModelValue(v25, *(void *)(ValuePtrAtIndex + 32));
      }
      if (*(unsigned char *)(ValuePtrAtIndex + 241)) {
        _C3DAnimationManagerUpdateConstantCount(a1, -1);
      }
      if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v23) != 1)
      {
        uint64_t v26 = scn_default_log();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerDiscardAnimationNodeFromStack_cold_3(v26, v27, v28, v29, v30, v31, v32, v33);
        }
      }
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v23);
      if (!Value)
      {
        int v35 = scn_default_log();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerDiscardAnimationNodeFromStack_cold_2(v35, v36, v37, v38, v39, v40, v41, v42);
        }
      }
      uint64_t v43 = (uint64_t)Value - 1;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v23);
      if (!C3DArrayGetCount(*(void *)(a1 + 24)))
      {
        uint64_t v44 = scn_default_log();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerDiscardAnimationNodeFromStack_cold_1(v44, v45, v46, v47, v48, v49, v50, v51);
        }
      }
      uint64_t v52 = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), v43);
      C3DAnimationStackCleanup(v52, *(void *)(a1 + 16));
      int v53 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v53 + 1;
      if (v53 >= 511)
      {
        uint64_t Count = C3DArrayGetCount(*(void *)(a1 + 24));
        if (Count < 1)
        {
          uint64_t v55 = 0;
        }
        else
        {
          uint64_t v55 = 0;
          for (uint64_t i = 0; i != Count; ++i)
          {
            uint64_t v57 = (long long *)C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), i);
            if (*(unsigned char *)v57)
            {
              if (v55)
              {
                uint64_t v58 = v57;
                uint64_t v59 = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), i - v55);
                long long v60 = v58[3];
                long long v62 = *v58;
                long long v61 = v58[1];
                *(_OWORD *)(v59 + 32) = v58[2];
                *(_OWORD *)(v59 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v60;
                *(_OWORD *)uint64_t v59 = v62;
                *(_OWORD *)(v59 + 16) = v61;
                long long v63 = v58[7];
                long long v65 = v58[4];
                long long v64 = v58[5];
                *(_OWORD *)(v59 + 96) = v58[6];
                *(_OWORD *)(v59 + 112) = v63;
                *(_OWORD *)(v59 + 64) = v65;
                *(_OWORD *)(v59 + 80) = v64;
                long long v66 = v58[11];
                long long v68 = v58[8];
                long long v67 = v58[9];
                *(_OWORD *)(v59 + 160) = v58[10];
                *(_OWORD *)(v59 + 176) = v66;
                *(_OWORD *)(v59 + 12_Block_object_dispose(&STACK[0x2A0], 8) = v68;
                *(_OWORD *)(v59 + 144) = v67;
                long long v69 = v58[15];
                long long v71 = v58[12];
                long long v70 = v58[13];
                *(_OWORD *)(v59 + 224) = v58[14];
                *(_OWORD *)(v59 + 240) = v69;
                *(_OWORD *)(v59 + 192) = v71;
                *(_OWORD *)(v59 + 20_Block_object_dispose(&STACK[0x2A0], 8) = v70;
                v58[14] = 0u;
                v58[15] = 0u;
                v58[12] = 0u;
                v58[13] = 0u;
                v58[10] = 0u;
                v58[11] = 0u;
                v58[8] = 0u;
                v58[9] = 0u;
                v58[6] = 0u;
                v58[7] = 0u;
                v58[4] = 0u;
                v58[5] = 0u;
                __n128 v58[2] = 0u;
                v58[3] = 0u;
                *uint64_t v58 = 0u;
                v58[1] = 0u;
                *(unsigned char *)uint64_t v58 = 0;
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), *(const void **)(v59 + 40), (const void *)(i - v55 + 1));
                for (uint64_t j = *(void *)(v59 + 8); j; uint64_t j = *(void *)(j + 176))
                  *(void *)(j + 152) = i - v55;
              }
            }
            else
            {
              ++v55;
            }
          }
        }
        uint64_t v73 = Count - v55;
        C3DArraySetCount(*(_DWORD **)(a1 + 24), v73);
        if (v73 <= 64) {
          int v74 = 64;
        }
        else {
          int v74 = v73;
        }
        C3DArraySetCapacity(*(void *)(a1 + 24), v74);
        *(_DWORD *)(a1 + 40) = 0;
      }
    }
  }
  if (!C3DAnimationNodeGetParent((uint64_t)a2))
  {
    uint64_t Player = C3DAnimationNodeGetPlayer((uint64_t)a2);
    if (Player) {
      C3DAnimationPlayerRemoveAnimationNode(Player, a2);
    }
    C3DAnimationNodeSetAnimationManager((uint64_t)a2, 0);
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 56), a2);
  }
}

uint64_t C3DAnimationManagerPushEvent(void *a1, uint64_t a2, uint64_t a3, char a4)
{
  Owner = (id *)C3DAnimationNodeGetOwner(a3);
  ObjCWrapper = Owner;
  if (Owner)
  {
    if (CFTypeIsC3DEntity(Owner)) {
      ObjCWrapper = C3DEntityGetObjCWrapper(ObjCWrapper);
    }
    else {
      ObjCWrapper = 0;
    }
  }
  uint64_t Animation = (id *)C3DAnimationNodeGetAnimation(a3);
  uint64_t v11 = C3DEntityGetObjCWrapper(Animation);
  uint64_t v12 = C3DAllocatorNew(a1[14]);
  uint64_t result = [v11 userAnimation];
  *((void *)v12 + 1) = result;
  *((void *)v12 + 2) = ObjCWrapper;
  v12[24] = a4;
  *(void *)uint64_t v12 = a2;
  *((void *)v12 + 4) = 0;
  uint64_t v14 = a1[13];
  if (v14) {
    uint64_t v15 = (char **)(v14 + 32);
  }
  else {
    uint64_t v15 = (char **)(a1 + 12);
  }
  *uint64_t v15 = v12;
  a1[13] = v12;
  return result;
}

double C3DAnimationManagerGetSystemTime(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 144);
}

void C3DAnimationManagerSetSystemTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerSetSystemTime_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 144) = a2;
}

void _C3DAnimationManagerUpdateConstantCount(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  int v12 = *(_DWORD *)(a1 + 172) + a2;
  *(_DWORD *)(a1 + 172) = v12;
  if (v12 < 0)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerUpdateConstantCount_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
}

uint64_t C3DAnimationManagerSetPausedForEditing(uint64_t result, char a2)
{
  *(unsigned char *)(result + 91) = a2;
  return result;
}

void C3DAnimationManagerApplyAnimations(uint64_t a1, double a2, double a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  *(double *)(a1 + 136) = a3;
  *(double *)(a1 + 144) = a2;
  uint64_t v14 = *(void *)(a1 + 24);
  v17[0] = MEMORY[0x263EF8330];
  v17[1] = 3221225472;
  v17[2] = __C3DAnimationManagerApplyAnimations_block_invoke;
  v17[3] = &__block_descriptor_40_e13_v24__0q8r_v16l;
  v17[4] = a1;
  C3DArrayApply(v14, (uint64_t)v17);
  CFSetApplyFunction(*(CFSetRef *)(a1 + 56), (CFSetApplierFunction)_updateTopLevelAnimationTiming, (void *)a1);
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  uint64_t v15 = *(void **)(a1 + 96);
  if (v15)
  {
    do
    {
      uint64_t v16 = (void *)v15[4];
      (*(void (**)(void))(*v15 + 16))();
      void v15[4] = 0;
      C3DAllocatorDelete(*(void *)(a1 + 112), (unint64_t)v15);
      *(void *)(a1 + 96) = v16;
      uint64_t v15 = v16;
    }
    while (v16);
  }
  *(void *)(a1 + 104) = 0;
  C3DAnimationManagerTriggerCallbacks(a1);
}

void __C3DAnimationManagerApplyAnimations_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (*a3) {
    _C3DAnimationManagerApplyStack(*(void *)(a1 + 32), (uint64_t)a3);
  }
}

void _C3DAnimationManagerApplyStack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (__n128 *)a2;
  uint64_t v3 = a1;
  *(void *)((char *)&v77[1] + 4) = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 48))
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      int v5 = 1;
      do
      {
        if ((*(_WORD *)(v4 + 121) & 0x804) != 0)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v7 = *(void *)(v4 + 16);
          BOOL v6 = !_C3DAnimationManagerUpdateRelativeTimeOfAnimation(v3, v4);
          if ((*(unsigned char *)(v4 + 121) & 0x20) != 0)
          {
            float WeightAtTime = C3DAnimationNodeGetWeightAtTime(v4, *(float *)(v4 + 60));
            *(float *)(v4 + 56) = WeightAtTime;
            if (WeightAtTime != 0.0)
            {
              uint64_t v9 = *(void *)(v7 + 168);
              *(float *)uint8_t buf = *(float *)(v4 + 72) * *(float *)(v7 + 72);
              uint64_t v61 = *(unsigned int *)(v9 + 20);
              unsigned int v10 = C3DPreviousKeyFrameIndexForTime(*(float **)(v9 + 56), *(_DWORD *)(v9 + 16), (float *)buf);
              if (v10 + 1 < *(_DWORD *)(v9 + 16) - 1) {
                unsigned int v11 = v10 + 1;
              }
              else {
                unsigned int v11 = *(_DWORD *)(v9 + 16) - 1;
              }
              uint64_t v62 = v9;
              uint64_t v12 = *(void *)(v9 + 56);
              float v13 = *(float *)(v12 + 4 * v10);
              float v14 = *(float *)(v12 + 4 * v11) - v13;
              BOOL v58 = v6;
              if (v14 == 0.0) {
                float v15 = 0.0;
              }
              else {
                float v15 = (float)(*(float *)buf - v13) / v14;
              }
              *(float *)uint8_t buf = v15;
              uint64_t v16 = *(void *)(v9 + 64);
              int v17 = *(_DWORD *)(v9 + 24);
              long long v74 = 0u;
              long long v75 = 0u;
              long long v72 = 0u;
              long long v73 = 0u;
              if (v61)
              {
                uint64_t v18 = 0;
                uint64_t v19 = v16 + v17 * v11;
                uint64_t v20 = v16 + v17 * v10;
                do
                {
                  uint64_t v21 = *(int *)(*(void *)(v4 + 224) + 4 * v18);
                  uint64_t v22 = *(unsigned __int8 *)(*(void *)(v62 + 40) + v18);
                  if (v21 != -1)
                  {
                    ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(v2[3].n128_i64[1], v21);
                    if (!*(void *)ValuePtrAtIndex)
                    {
                      uint64_t v24 = scn_default_log();
                      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
                        _C3DAnimationManagerApplyStack_cold_2(v64, &v64[4], v24);
                      }
                    }
                    (*(void (**)(uint64_t, uint64_t, void, void, void, void, long long *, double))(*(void *)(v62 + 48) + 8 * v18))(v20, v19, 0, 0, 0, 0, &v72, *(float *)buf);
                    if (*(float *)(v4 + 56) < 1.0)
                    {
                      long long v70 = 0u;
                      long long v71 = 0u;
                      long long v68 = 0u;
                      long long v69 = 0u;
                      uint64_t v25 = *(void *)ValuePtrAtIndex;
                      C3DModelValueStorageUpdatePresentationValueInNeeded(*(void *)(v3 + 16), *(void *)ValuePtrAtIndex);
                      uint64_t v26 = *(void (**)(uint64_t, uint64_t, long long *, uint64_t, void, void))(v25 + 136);
                      uint64_t Target = C3DModelTargetGetTarget(*(void *)(v25 + 24));
                      uint64_t TargetAddress = C3DModelTargetGetTargetAddress(*(void *)(v25 + 24));
                      uint64_t v29 = Target;
                      uint64_t v2 = (__n128 *)a2;
                      v26(v29, TargetAddress, &v68, v22, *(char *)(ValuePtrAtIndex + 8), *(unsigned __int8 *)(ValuePtrAtIndex + 9));
                      uint64_t v3 = a1;
                      (*(void (**)(long long *, long long *, void, void, void, void, long long *, double))(ValuePtrAtIndex + 16))(&v68, &v72, 0, 0, 0, 0, &v72, *(float *)(v4 + 56));
                    }
                    C3DModelValueStorageUpdatePresentationValueWithBytes(*(void *)(v3 + 16), *(uint64_t **)ValuePtrAtIndex, *(char *)(ValuePtrAtIndex + 8), *(unsigned __int8 *)(ValuePtrAtIndex + 9), (uint64_t)&v72, v22);
                  }
                  unsigned __int8 v30 = (v22 + 15) & 0xF0;
                  v19 += v30;
                  v20 += v30;
                  ++v18;
                }
                while (v61 != v18);
              }
              BOOL v6 = v58;
            }
          }
        }
        v5 &= v6;
        uint64_t v4 = *(void *)(v4 + 176);
      }
      while (v4);
    }
    else
    {
      int v5 = 1;
    }
    if (v2[15].n128_u8[1] != v5)
    {
      v2[15].n128_u8[1] = v5;
      BOOL v38 = v5 == 0;
      goto LABEL_74;
    }
    return;
  }
  *(unsigned char *)(a2 + 240) = 0;
  uint64_t v31 = (_OWORD *)(a2 + 64);
  uint64_t v32 = *(_OWORD **)(a2 + 32);
  BOOL v33 = *(unsigned char *)(a2 + 128) != 0;
  if (*(unsigned char *)(a2 + 128))
  {
    long long v34 = v32[3];
    *(_OWORD *)(a2 + 144) = v32[2];
    *(_OWORD *)(a2 + 160) = v34;
    long long v35 = v32[4];
    long long v36 = v32[5];
    long long v37 = v32[7];
    *(_OWORD *)(a2 + 20_Block_object_dispose(&STACK[0x2A0], 8) = v32[6];
    *(_OWORD *)(a2 + 224) = v37;
    *(_OWORD *)(a2 + 176) = v35;
    *(_OWORD *)(a2 + 192) = v36;
  }
  else
  {
    memcpy((void *)(a2 + 64), v32 + 2, *((__int16 *)v32 + 65));
  }
  uint64_t v39 = v2->n128_i64[1];
  if (!v39)
  {
    LOBYTE(v41) = 1;
    goto LABEL_71;
  }
  char v40 = 0;
  long long v63 = v2 + 9;
  int v41 = 1;
  do
  {
    if ((*(_WORD *)(v39 + 121) & 0x804) == 0)
    {
      v41 &= !_C3DAnimationManagerUpdateRelativeTimeOfAnimation(v3, v39);
      if ((*(unsigned char *)(v39 + 121) & 0x20) != 0)
      {
        float v42 = C3DAnimationNodeGetWeightAtTime(v39, *(float *)(v39 + 60));
        *(float *)(v39 + 56) = v42;
        if (v42 != 0.0)
        {
          v43.n128_u64[1] = 0;
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          v43.n128_u64[0] = *(unsigned int *)(v39 + 56);
          if (v43.n128_f32[0] >= 1.0)
          {
            uint64_t v46 = a2;
          }
          else
          {
            if (v33)
            {
              C3DTransformGetMatrix((uint64_t)v63, (uint64_t)v64);
              long long v44 = v65;
              *uint64_t v31 = *(_OWORD *)v64;
              v31[1] = v44;
              long long v45 = v67;
              v31[2] = v66;
              v31[3] = v45;
            }
            uint64_t v46 = a2;
            __memcpy_chk();
            BOOL v33 = 0;
          }
          if (*(unsigned char *)(v46 + 128)
            && ((*(_WORD *)(*(void *)(v39 + 16) + 84) & 2) != 0 || (*(unsigned char *)(v39 + 122) & 0x10) != 0))
          {
            C3DTransformGetValue((uint64_t)v63, v31, *(unsigned __int8 *)(*(void *)(v39 + 24) + 36), *(char *)(*(void *)(v39 + 24) + 34), *(unsigned __int8 *)(*(void *)(v39 + 24) + 35));
          }
          if (!v3)
          {
            uint64_t v47 = scn_default_log();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
              _C3DAnimationManagerApplyStack_cold_1(buf, v77, v47);
            }
          }
          if ((*(unsigned char *)(v39 + 121) & 0x20) != 0)
          {
            uint64_t Animation = C3DAnimationNodeGetAnimation(v39);
            uint64_t v50 = Animation;
            uint64_t v51 = *(void *)(v39 + 112);
            if (v51 && *(_DWORD *)v51)
            {
              C3DValueInitFrom(*(void *)(v51 + 24), v31);
              C3DValueGetBytes(*(void *)(*(void *)(v39 + 112) + 24));
              char v48 = C3DAnimationEvaluate(v50);
              C3DValueConcat(*(void *)(*(void *)(v39 + 112) + 8), *(void *)(*(void *)(v39 + 112) + 24), *(void *)(*(void *)(v39 + 112) + 24));
              C3DValueCopyTo(*(void *)(*(void *)(v39 + 112) + 24), v31);
            }
            else
            {
              char v48 = C3DAnimationEvaluate(Animation);
            }
          }
          else
          {
            char v48 = 0;
          }
          v40 |= v48;
          if (v40)
          {
            if (*(unsigned char *)(a2 + 128))
            {
              *(unsigned char *)(a2 + 240) |= *(unsigned char *)(v39 + 120);
              C3DTransformSetValue(v63, v31, *(unsigned __int8 *)(*(void *)(v39 + 24) + 36), *(char *)(*(void *)(v39 + 24) + 34), *(unsigned __int8 *)(*(void *)(v39 + 24) + 35), v43);
              if (*(float *)(v39 + 56) >= 1.0)
              {
                BOOL v33 = 1;
                goto LABEL_66;
              }
            }
            else
            {
              if (*(float *)(v39 + 56) >= 1.0) {
                goto LABEL_66;
              }
              if (!v33) {
                goto LABEL_63;
              }
            }
            C3DTransformGetMatrix((uint64_t)v63, (uint64_t)v64);
            long long v52 = v65;
            *uint64_t v31 = *(_OWORD *)v64;
            v31[1] = v52;
            long long v53 = v67;
            v31[2] = v66;
            v31[3] = v53;
LABEL_63:
            __memcpy_chk();
            (*(void (**)(long long *, long long *, void, void, void, void, _OWORD *, double))(a2 + 248))(&v72, &v68, 0, 0, 0, 0, v31, *(float *)(v39 + 56));
            if (*(unsigned char *)(a2 + 128)) {
              C3DTransformSetValue(v63, v31, *(unsigned __int8 *)(*(void *)(a2 + 24) + 36), *(char *)(*(void *)(a2 + 24) + 34), *(unsigned __int8 *)(*(void *)(a2 + 24) + 35), v54);
            }
            BOOL v33 = 0;
          }
        }
      }
    }
LABEL_66:
    uint64_t v39 = *(void *)(v39 + 176);
  }
  while (v39);
  uint64_t v2 = (__n128 *)a2;
  uint64_t v32 = *(_OWORD **)(a2 + 32);
  if ((v40 & 1) == 0)
  {
LABEL_71:
    C3DModelValueStorageUpdatePresentationValueFromModelValue(*(void *)(v3 + 16), (uint64_t)v32);
    goto LABEL_72;
  }
  uint64_t v55 = *(void *)(v3 + 16);
  if (*(unsigned char *)(a2 + 128)) {
    C3DModelValueStorageUpdatePresentationValueWithTransform(v55, *(uint64_t **)(a2 + 32), v63, *(char *)(a2 + 240));
  }
  else {
    C3DModelValueStorageUpdatePresentationValueWithBytes(v55, *(uint64_t **)(a2 + 32), 0, 0, (uint64_t)v31, *(unsigned __int8 *)(a2 + 242));
  }
LABEL_72:
  int v56 = v41 & 1;
  if (v2[15].n128_u8[1] != v56)
  {
    v2[15].n128_u8[1] = v56;
    BOOL v38 = v56 == 0;
LABEL_74:
    if (v38) {
      int v57 = -1;
    }
    else {
      int v57 = 1;
    }
    _C3DAnimationManagerUpdateConstantCount(v3, v57);
  }
}

uint64_t _updateTopLevelAnimationTiming(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 152) == -1) {
    return _C3DAnimationManagerUpdateRelativeTimeOfAnimation(a2, result);
  }
  return result;
}

void C3DAnimationManagerApplyAnimationsForTarget(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_4;
    }
  }
  else if (a2)
  {
LABEL_4:
    *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
    uint64_t v12 = (unsigned char *)(a1 + 88);
    *(unsigned char *)(a1 + 90) = 1;
    float v13 = (unsigned char *)(a1 + 90);
    goto LABEL_10;
  }
  float v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  uint64_t v12 = (unsigned char *)(a1 + 88);
  *(unsigned char *)(a1 + 90) = 1;
  float v13 = (unsigned char *)(a1 + 90);
  uint64_t v22 = scn_default_log();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
  }
LABEL_10:
  uint64_t TargetAddress = (const void *)C3DModelTargetGetTargetAddress(a2);
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), TargetAddress);
  if (Value)
  {
    ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), (uint64_t)Value - 1);
    if (ValuePtrAtIndex)
    {
      *(void *)(*(void *)(ValuePtrAtIndex + 32) + 152) = 0;
      _C3DAnimationManagerApplyStack(a1, ValuePtrAtIndex);
    }
  }
  *uint64_t v12 = 0;
  *float v13 = 0;
}

BOOL C3DAnimationManagerIsEmpty(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerSetSystemTime_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(void *)(a1 + 24);
  return !v10 || C3DArrayGetCount(v10) <= *(int *)(a1 + 40);
}

BOOL C3DAnimationManagerNeedsRedraw(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerSetSystemTime_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(int *)(a1 + 160) < 1 || (int v12 = C3DIsRunningInEditor(), result = 1, v12) && a2)
  {
    uint64_t v14 = *(void *)(a1 + 24);
    if (v14) {
      uint64_t v15 = C3DArrayGetCount(v14) - *(int *)(a1 + 40);
    }
    else {
      uint64_t v15 = 0;
    }
    if (v15 < *(int *)(a1 + 172))
    {
      uint64_t v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        C3DAnimationManagerNeedsRedraw_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    return v15 > *(int *)(a1 + 172);
  }
  return result;
}

BOOL C3DAnimationManagerContainsAnimationForObject(uint64_t a1, const void *a2)
{
  return a2 && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), a2) != 0;
}

void C3DAnimationManagerAddAnimationPlayerForKey(uint64_t a1, uint64_t a2, float32x4_t *a3, void *a4)
{
  uint64_t Animation = (const void *)C3DAnimationPlayerGetAnimation(a2);
  if (!Animation) {
    return;
  }
  uint64_t v9 = Animation;
  CFTypeID v10 = CFGetTypeID(Animation);
  if (C3DAnimationGroupGetTypeID() == v10)
  {
    if (!a1 && (uint64_t v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
    {
      _C3DAnimationManagerAddAnimationNode_cold_4(v11, v12, v13, v14, v15, v16, v17, v18);
      if (a3) {
        goto LABEL_8;
      }
    }
    else if (a3)
    {
      goto LABEL_8;
    }
    uint64_t v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
    }
LABEL_8:
    if (!a4)
    {
      uint64_t v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
      }
    }
    _C3DAnimationManagerRemoveAnimationForKey(a1, a3, a4);
    uint64_t v35 = C3DAnimationNodeCreateWithAnimationGroupAndAddToAnimationManager(a1, v9, a3, a4);
    if (v35)
    {
      long long v36 = (void *)v35;
      C3DAnimationNodeSetOwner(v35, (uint64_t)a3);
      C3DAnimationNodeSetAnimationManager((uint64_t)v36, a1);
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), v36);
LABEL_24:
      AnimationPerKeyDictionaryForObject = (__CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, a3, 1);
      CFDictionarySetValue(AnimationPerKeyDictionaryForObject, a4, v36);
      if ((C3DAnimationGetIsSceneTimeBased((uint64_t)v9) & 1) == 0) {
        C3DTransactionAddAnimationNode(v36);
      }
      CFRelease(v36);
      goto LABEL_27;
    }
    return;
  }
  if (C3DAnimationClusterGetTypeID() != v10)
  {
    long long v63 = C3DAnimationCopyTarget((uint64_t)v9, a3);
    if (v63)
    {
      long long v64 = v63;
      long long v36 = _C3DAnimationManagerAddAnimationForKey(a1, v9, v63, a3, a4);
      CFRelease(v64);
      if (v36)
      {
LABEL_27:
        C3DAnimationPlayerAddAnimationNode(a2, v36);
        if ((C3DAnimationPlayerGetPaused(a2) & 1) == 0) {
          C3DAnimationManagerPlayAnimationNode(a1, (uint64_t)v36);
        }
        return;
      }
    }
    return;
  }
  if (!a1 && (long long v37 = scn_default_log(), os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v37, v38, v39, v40, v41, v42, v43, v44);
    if (a3) {
      goto LABEL_19;
    }
  }
  else if (a3)
  {
    goto LABEL_19;
  }
  long long v45 = scn_default_log();
  if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v45, v46, v47, v48, v49, v50, v51, v52);
  }
LABEL_19:
  if (!a4)
  {
    long long v53 = scn_default_log();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v53, v54, v55, v56, v57, v58, v59, v60);
    }
  }
  _C3DAnimationManagerRemoveAnimationForKey(a1, a3, a4);
  uint64_t v61 = C3DAnimationNodeCreateWithAnimationCluster(a1, v9, (uint64_t)a3, a4);
  if (v61)
  {
    long long v36 = (void *)v61;
    C3DAnimationNodeSetOwner(v61, (uint64_t)a3);
    C3DAnimationNodeSetAnimationManager((uint64_t)v36, a1);
    __C3DAnimationManagerAddAnimationNodeToAnimationStackWithKey(a1, v36, a3, 0);
    goto LABEL_24;
  }
}

void *_C3DAnimationManagerAddAnimationForKey(uint64_t a1, const void *a2, const void *a3, void *key, void *a5)
{
  if (!a1 && (CFTypeID v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationForKey_cold_4(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (!a3 && (uint64_t v26 = scn_default_log(), os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
    if (key) {
      goto LABEL_11;
    }
  }
  else if (key)
  {
    goto LABEL_11;
  }
  uint64_t v34 = scn_default_log();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v34, v35, v36, v37, v38, v39, v40, v41);
  }
LABEL_11:
  if (!a5)
  {
    uint64_t v42 = scn_default_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v42, v43, v44, v45, v46, v47, v48, v49);
    }
  }
  _C3DAnimationManagerRemoveAnimationForKey(a1, key, a5);
  uint64_t v50 = C3DAnimationNodeCreateWithAnimationAndAddToAnimationManager(a1, a2, a3, a5);
  uint64_t v51 = (void *)v50;
  if (v50)
  {
    C3DAnimationNodeSetOwner(v50, (uint64_t)key);
    C3DAnimationNodeSetAnimationManager((uint64_t)v51, a1);
    AnimationPerKeyDictionaryForObject = (__CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 1);
    CFDictionarySetValue(AnimationPerKeyDictionaryForObject, a5, v51);
    if ((C3DAnimationGetIsSceneTimeBased((uint64_t)a2) & 1) == 0) {
      C3DTransactionAddAnimationNode(v51);
    }
    CFRelease(v51);
  }
  return v51;
}

uint64_t C3DAnimationManagerPlayAnimationNode(uint64_t a1, uint64_t a2)
{
  if (!a2 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_4(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  int v20 = *(_DWORD *)(a2 + 121);
  *(_DWORD *)(a2 + 121) = v20 & 0xFFFBFFFF;
  C3DAnimationNodeSetPaused(a2, 0);
  uint64_t Animation = C3DAnimationNodeGetAnimation(a2);
  C3DTransactionGetAtomicTime();
  double v23 = v22;
  double PauseTime = C3DAnimationNodeGetPauseTime(Animation);
  if (C3DAnimationGetIsSceneTimeBased(Animation))
  {
    *(double *)(a2 + 80) = C3DAnimationNodeGetPauseTime(Animation);
  }
  else
  {
    double v25 = v23 + PauseTime;
    if ((v20 & 0x200000) == 0 || *(double *)(a2 + 128) == 0.0)
    {
      C3DAnimationNodeSetStartTime(a2, v25);
      if ((C3DAnimationGetIsSceneTimeBased(Animation) & 1) == 0 && (C3DAnimationGetIsImplicit(Animation) & 1) == 0) {
        C3DAnimationNodeRestart(a2);
      }
    }
    else
    {
      double v26 = C3DAnimationNodeGetPauseTime(a2);
      C3DAnimationNodeTimeJump(a2, v25 - v26);
      *(void *)(a2 + 12_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
  }
  *(void *)(a2 + 104) = 0;
  *(_DWORD *)(a2 + 121) &= 0xFFFFFFF3;
  *(_DWORD *)(a2 + 72) = -1082130432;
  uint64_t v27 = *(void *)(a2 + 152);
  if (v27 != -1)
  {
    ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), v27);
    C3DAnimationStackSetConstant(ValuePtrAtIndex, 0, a1);
  }
  uint64_t result = (uint64_t)C3DAnimationNodeGetChildCount(a2);
  if (result >= 1)
  {
    uint64_t v30 = result;
    for (CFIndex i = 0; i != v30; ++i)
    {
      ChildAtuint64_t Index = C3DAnimationNodeGetChildAtIndex(a2, i);
      uint64_t result = C3DAnimationManagerPlayAnimationNode(a1, ChildAtIndex);
    }
  }
  return result;
}

void *C3DAnimationManagerAddAnimationForKey(uint64_t a1, const void *a2, const void *a3, void *a4, void *a5)
{
  uint64_t result = _C3DAnimationManagerAddAnimationForKey(a1, a2, a3, a4, a5);
  if (result)
  {
    return (void *)C3DAnimationManagerPlayAnimationNode(a1, (uint64_t)result);
  }
  return result;
}

const void *_resolveAnimationGroupTargets(uint64_t a1, const void *a2, uint64_t a3, const __CFArray *a4)
{
  uint64_t v6 = a1;
  Animationuint64_t Count = C3DAnimationGroupGetAnimationCount(a1);
  if (AnimationCount < 1) {
    return 0;
  }
  uint64_t v7 = 0;
  CFIndex v8 = 0;
  int v9 = 1;
  char v10 = 1;
  uint64_t v39 = v6;
  do
  {
    AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex(v6, v8);
    if (C3DAnimationIsGroup(AnimationAtIndex))
    {
      uint64_t v12 = (const void *)_resolveAnimationGroupTargets(AnimationAtIndex, a2, a3, a4);
      uint64_t v13 = (uint64_t)v12;
      if (v12)
      {
        if (v10)
        {
          CFTypeID v14 = CFGetTypeID(v12);
          if (v14 == C3DNodeGetTypeID())
          {
            uint64_t v7 = (const void *)_commonAncessor(a4, v7, v13);
            char v10 = 1;
            goto LABEL_45;
          }
        }
      }
      else if ((C3DWasLinkedBeforeMajorOSYear2018() & 1) == 0)
      {
        goto LABEL_45;
      }
      char v10 = 0;
      if (v7) {
        BOOL v34 = v7 == (const void *)v13;
      }
      else {
        BOOL v34 = 1;
      }
      int v35 = v34;
      v9 &= v35;
      uint64_t v7 = (const void *)v13;
    }
    else
    {
      CFArrayRef KeyPath = (const __CFArray *)C3DAnimationGetKeyPath((uint64_t)AnimationAtIndex);
      uint64_t v16 = (uint64_t)a2;
      uint64_t v17 = a2;
      uint64_t v18 = a3;
      uint64_t v19 = (const void *)C3DModelDescriptionResolveRootComponentInPath(KeyPath, v17, a3, 0);
      if (KeyPath)
      {
        if (CFArrayGetCount(KeyPath) >= 1)
        {
          if (v19)
          {
            uint64_t TypeID = C3DNodeGetTypeID();
            if (TypeID == CFGetTypeID(v19))
            {
              uint64_t Name = C3DNodeGetName((uint64_t)v19);
              if (Name)
              {
                uint64_t v38 = Name;
                double v22 = (const void *)[@"/" stringByAppendingString:Name];
                ValueAtuint64_t Index = CFArrayGetValueAtIndex(KeyPath, 0);
                if (!CFEqual(v22, ValueAtIndex))
                {
                  uint64_t v37 = v22;
                  uint64_t v43 = 0;
                  uint64_t v44 = (int *)&v43;
                  uint64_t v45 = 0x2020000000;
                  int v46 = 0;
                  uint64_t RootNode = C3DSceneGetRootNode(v16);
                  if (RootNode)
                  {
                    v42[0] = MEMORY[0x263EF8330];
                    v42[1] = 3221225472;
                    v42[2] = ___resolveAnimationGroupTargets_block_invoke;
                    _OWORD v42[3] = &unk_264005EF8;
                    v42[4] = &v43;
                    v42[5] = v38;
                    C3DNodeApplyHierarchy(RootNode, (uint64_t)v42);
                  }
                  if (v44[6] <= 1)
                  {
                    double v25 = (void *)[(__CFArray *)KeyPath mutableCopy];
                    [v25 replaceObjectAtIndex:0 withObject:v37];
                    C3DAnimationSetKeyPath((uint64_t)AnimationAtIndex, v25);
                  }
                  _Block_object_dispose(&v43, 8);
                }
              }
            }
          }
        }
      }
      CFArrayRef v26 = (const __CFArray *)C3DAnimationGetKeyPath((uint64_t)AnimationAtIndex);
      if (v26)
      {
        if (CFArrayGetCount(v26) >= 1)
        {
          if (v19)
          {
            uint64_t v27 = C3DGenericSourceGetTypeID();
            if (v27 == CFGetTypeID(v19))
            {
              uint64_t Listener = C3DGenericSourceGetListener((uint64_t)v19);
              if (Listener)
              {
                uint64_t v29 = (const void *)Listener;
                uint64_t v30 = C3DMorphGetTypeID();
                if (v30 == CFGetTypeID(v29)) {
                  uint64_t v19 = v29;
                }
              }
            }
          }
        }
      }
      if (((v19 != 0) & v10) == 1 && (CFTypeID v31 = CFGetTypeID(v19), v31 == C3DNodeGetTypeID()))
      {
        uint64_t v7 = (const void *)_commonAncessor(a4, v7, (uint64_t)v19);
        char v10 = 1;
      }
      else
      {
        char v10 = 0;
        if (v7) {
          BOOL v32 = v7 == v19;
        }
        else {
          BOOL v32 = 1;
        }
        int v33 = v32;
        v9 &= v33;
        uint64_t v7 = v19;
      }
      a3 = v18;
      a2 = (const void *)v16;
      uint64_t v6 = v39;
    }
LABEL_45:
    ++v8;
  }
  while (AnimationCount != v8);
  if ((v9 & 1) == 0) {
    return 0;
  }
  return v7;
}

void sub_20B31B0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const void *_resolveAnimationClusterTargets(uint64_t a1, const void *a2, uint64_t a3, const __CFArray *a4)
{
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 168) + 20);
  if (!v4) {
    return 0;
  }
  uint64_t v7 = 0;
  CFIndex v8 = 0;
  uint64_t v27 = v32;
  uint64_t v29 = 8 * v4;
  char v9 = 1;
  char v10 = 1;
  do
  {
    CFArrayRef v11 = *(const __CFArray **)(*(void *)(*(void *)(a1 + 168) + 72) + v7);
    uint64_t v12 = (const void *)C3DModelDescriptionResolveRootComponentInPath(v11, a2, a3, 0);
    if (v11)
    {
      if (CFArrayGetCount(v11) >= 1 && v12 != 0)
      {
        uint64_t TypeID = C3DNodeGetTypeID();
        if (TypeID == CFGetTypeID(v12))
        {
          uint64_t Name = C3DNodeGetName((uint64_t)v12);
          if (Name)
          {
            uint64_t v16 = Name;
            uint64_t v17 = (const void *)objc_msgSend(@"/", "stringByAppendingString:", Name, v27);
            ValueAtuint64_t Index = CFArrayGetValueAtIndex(v11, 0);
            if (!CFEqual(v17, ValueAtIndex))
            {
              uint64_t v33 = 0;
              BOOL v34 = (int *)&v33;
              uint64_t v35 = 0x2020000000;
              int v36 = 0;
              uint64_t RootNode = C3DSceneGetRootNode((uint64_t)a2);
              if (RootNode)
              {
                v31[0] = MEMORY[0x263EF8330];
                v31[1] = 3221225472;
                v32[0] = ___resolveAnimationClusterTargets_block_invoke;
                v32[1] = &unk_264005EF8;
                v32[2] = &v33;
                v32[3] = v16;
                C3DNodeApplyHierarchy(RootNode, (uint64_t)v31);
              }
              if (v34[6] <= 1)
              {
                int v20 = (void *)[(__CFArray *)v11 mutableCopy];
                [v20 replaceObjectAtIndex:0 withObject:v17];
                uint64_t v21 = *(const void **)(*(void *)(*(void *)(a1 + 168) + 72) + v7);
                if (v21 != v20)
                {
                  if (v21)
                  {
                    CFRelease(v21);
                    *(void *)(*(void *)(*(void *)(a1 + 168) + 72) + v7) = 0;
                  }
                  if (v20) {
                    CFTypeRef v22 = CFRetain(v20);
                  }
                  else {
                    CFTypeRef v22 = 0;
                  }
                  *(void *)(*(void *)(*(void *)(a1 + 168) + 72) + v7) = v22;
                }
              }
              _Block_object_dispose(&v33, 8);
            }
          }
        }
      }
    }
    if (v12 == 0 || (v10 & 1) == 0 || (CFTypeID v23 = CFGetTypeID(v12), v23 != C3DNodeGetTypeID()))
    {
      char v10 = 0;
      if (v8) {
        BOOL v24 = v8 == v12;
      }
      else {
        BOOL v24 = 1;
      }
      char v25 = v24;
      v9 &= v25;
      CFIndex v8 = v12;
    }
    else
    {
      CFIndex v8 = (const void *)_commonAncessor(a4, v8, (uint64_t)v12);
      char v10 = 1;
    }
    v7 += 8;
  }
  while (v29 != v7);
  if ((v9 & 1) == 0) {
    return 0;
  }
  return v8;
}

void sub_20B31B360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void C3DAnimationManagerAddAnimationToSceneForKey(uint64_t a1, const void *a2, const void *a3, uint64_t a4, void *a5)
{
  if (!a1 && (char v9 = scn_default_log(), os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v9, v10, v11, v12, v13, v14, v15, v16);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v17 = scn_default_log();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v17, v18, v19, v20, v21, v22, v23, v24);
  }
LABEL_6:
  if (!a2 && (char v25 = scn_default_log(), os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationForKey_cold_4(v25, v26, v27, v28, v29, v30, v31, v32);
    if (a5) {
      goto LABEL_11;
    }
  }
  else if (a5)
  {
    goto LABEL_11;
  }
  uint64_t v33 = scn_default_log();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
  }
LABEL_11:
  uint64_t RootNode = C3DSceneGetRootNode((uint64_t)a3);
  if (!RootNode)
  {
    uint64_t v42 = scn_default_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v42, v43, v44, v45, v46, v47, v48, v49);
    }
  }
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
  uint64_t TypeID = C3DAnimationGroupGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    uint64_t v52 = (float32x4_t *)_resolveAnimationGroupTargets((uint64_t)a2, a3, a4, Mutable);
  }
  else
  {
    uint64_t v53 = C3DAnimationClusterGetTypeID();
    if (v53 == CFGetTypeID(a2)) {
      uint64_t v52 = (float32x4_t *)_resolveAnimationClusterTargets((uint64_t)a2, a3, a4, Mutable);
    }
    else {
      uint64_t v52 = 0;
    }
  }
  if (v52) {
    uint64_t v54 = v52;
  }
  else {
    uint64_t v54 = (float32x4_t *)RootNode;
  }
  CFRelease(Mutable);
  uint64_t v55 = (uint64_t *)C3DAnimationPlayerCreateWithAnimation(a2);
  C3DEntityAddAnimationForKey(v54, v55, a5);
  C3DAnimationPlayerPlay((uint64_t)v55);
  if (v55) {
    CFRelease(v55);
  }
}

void C3DAnimationManagerRemoveAllAnimationsForObject(uint64_t a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    CFDictionaryRef v21 = AnimationPerKeyDictionaryForObject;
    CFRetain(AnimationPerKeyDictionaryForObject);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(0, v21);
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    v23[2] = __C3DAnimationManagerRemoveAllAnimationsForObject_block_invoke;
    v23[3] = &__block_descriptor_56_e15_v24__0r_v8r_v16l;
    v23[4] = a1;
    v23[5] = key;
    v23[6] = v21;
    C3DCFDictionaryApplyBlock(Copy, (uint64_t)v23);
    CFRelease(Copy);
    CFRelease(v21);
  }
}

void __C3DAnimationManagerRemoveAllAnimationsForObject_block_invoke(uint64_t a1, void *key)
{
}

void _C3DAnimationManagerRemoveAnimationsForKey(uint64_t a1, const void *a2, void *key, CFDictionaryRef theDict)
{
  CFStringRef Value = CFDictionaryGetValue(theDict, key);
  C3DAnimationManagerRemoveAnimationNode(a1, (uint64_t)Value);
  CFDictionaryRemoveValue(theDict, key);
  if (!CFDictionaryGetCount(theDict))
  {
    uint64_t v9 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryRemoveValue(v9, a2);
  }
}

void C3DAnimationManagerChangeSpeedOfAnimationForKey(uint64_t a1, void *key, const void *a3, float a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a3)
  {
    uint64_t v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    CFStringRef Value = CFDictionaryGetValue(AnimationPerKeyDictionaryForObject, a3);
    if (Value) {
      C3DAnimationNodeChangeSpeed((uint64_t)Value, a4);
    }
  }
}

void C3DAnimationManagerFadeAndRemoveAllAnimationsForObject(uint64_t a1, void *key, double a3)
{
  if (a3 == 0.0)
  {
    C3DAnimationManagerRemoveAllAnimationsForObject(a1, key);
    return;
  }
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (!key)
    {
LABEL_8:
      uint64_t v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerGetAnimationNodeForKey_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
      }
    }
  }
  else if (!key)
  {
    goto LABEL_8;
  }
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    CFDictionaryRef v23 = AnimationPerKeyDictionaryForObject;
    CFRetain(AnimationPerKeyDictionaryForObject);
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __C3DAnimationManagerFadeAndRemoveAllAnimationsForObject_block_invoke;
    v24[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    *(double *)&v24[4] = a3;
    C3DCFDictionaryApplyBlock(v23, (uint64_t)v24);
    CFRelease(v23);
  }
}

void __C3DAnimationManagerFadeAndRemoveAllAnimationsForObject_block_invoke(uint64_t a1, uint64_t a2, CFTimeInterval *a3)
{
  a3[11] = CACurrentMediaTime();
  a3[12] = CACurrentMediaTime();
  double v5 = *(double *)(a1 + 32);
  if (v5 < 0.0001) {
    double v5 = 0.0001;
  }
  a3[13] = v5;
}

void C3DAnimationManagerFadeAndRemoveAnimationForKey(uint64_t a1, void *key, void *a3, double a4)
{
  if (a4 == 0.0)
  {
    _C3DAnimationManagerRemoveAnimationForKey(a1, key, a3);
    return;
  }
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (!key)
    {
LABEL_8:
      uint64_t v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
  }
  else if (!key)
  {
    goto LABEL_8;
  }
  if (!a3)
  {
    uint64_t v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    CFDictionaryRef v33 = AnimationPerKeyDictionaryForObject;
    CFRetain(AnimationPerKeyDictionaryForObject);
    CFStringRef Value = (CFTimeInterval *)CFDictionaryGetValue(v33, a3);
    if (Value)
    {
      uint64_t v35 = Value;
      Value[11] = CACurrentMediaTime();
      double v36 = CACurrentMediaTime();
      double v37 = 0.0001;
      if (a4 >= 0.0001) {
        double v37 = a4;
      }
      v35[12] = v36;
      v35[13] = v37;
    }
    CFRelease(v33);
  }
}

CFDictionaryRef C3DAnimationManagerGetAnimationNodeForKey(uint64_t a1, void *key, const void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  return _C3DAnimationManagerGetAnimationNodeForKey(a1, key, a3);
}

uint64_t C3DAnimationManagerStopAnimationNode(uint64_t a1, uint64_t a2, double a3)
{
  if (!a2 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_4(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  uint64_t Animation = C3DAnimationNodeGetAnimation(a2);
  if ((C3DAnimationGetIsSceneTimeBased(Animation) & 1) == 0) {
    C3DTransactionGetAtomicTime();
  }
  int v23 = *(_DWORD *)(a2 + 121);
  if (a3 == 0.0)
  {
    *(_DWORD *)(a2 + 121) = v23 & 0xFFFFFFDB | 4;
  }
  else
  {
    *(_DWORD *)(a2 + 121) = v23 | 8;
    C3DTransactionGetAtomicTime();
    *(void *)(a2 + 96) = v24;
    *(double *)(a2 + 104) = a3;
  }
  *(void *)(a2 + 12_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  uint64_t result = (uint64_t)C3DAnimationNodeGetChildCount(a2);
  if (result >= 1)
  {
    uint64_t v26 = result;
    for (CFIndex i = 0; i != v26; ++i)
    {
      ChildAtuint64_t Index = C3DAnimationNodeGetChildAtIndex(a2, i);
      uint64_t result = C3DAnimationManagerStopAnimationNode(a1, ChildAtIndex, a3);
    }
  }
  return result;
}

uint64_t C3DAnimationManagerPauseAnimationNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (!a2 && (uint64_t v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_4(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (a4)
  {
    uint64_t result = C3DAnimationNodeGetPausedByScene(a2);
    if (result == a3) {
      return result;
    }
    PausedOrPausedByuint64_t Scene = C3DAnimationNodeGetPausedOrPausedByScene(a2);
    C3DAnimationNodeSetPausedByScene(a2, a3);
  }
  else
  {
    uint64_t result = C3DAnimationNodeGetPaused(a2);
    if (result == a3) {
      return result;
    }
    PausedOrPausedByuint64_t Scene = C3DAnimationNodeGetPausedOrPausedByScene(a2);
    C3DAnimationNodeSetPaused(a2, a3);
  }
  if (C3DAnimationNodeGetPausedOrPausedByScene(a2)) {
    int v28 = 1;
  }
  else {
    int v28 = (*(_DWORD *)(a2 + 121) >> 2) & 1;
  }
  if (v28 != PausedOrPausedByScene)
  {
    uint64_t Animation = C3DAnimationNodeGetAnimation(a2);
    double v30 = a5;
    if (C3DAnimationGetIsSceneTimeBased(Animation)) {
      double v30 = *(double *)(a1 + 136);
    }
    if (C3DAnimationNodeGetPausedOrPausedByScene(a2))
    {
      C3DAnimationNodeSetPauseTime(a2, v30);
    }
    else
    {
      uint64_t v31 = *(void *)(a2 + 152);
      if (v31 != -1)
      {
        ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 24), v31);
        C3DAnimationStackSetConstant(ValuePtrAtIndex, 0, a1);
      }
      if ((*(unsigned char *)(a2 + 121) & 4) != 0)
      {
        C3DAnimationNodeSetStartTime(a2, v30);
      }
      else
      {
        double PauseTime = C3DAnimationNodeGetPauseTime(a2);
        C3DAnimationNodeTimeJump(a2, v30 - PauseTime);
      }
      *(_DWORD *)(a2 + 121) &= ~4u;
    }
  }
  uint64_t result = (uint64_t)C3DAnimationNodeGetChildCount(a2);
  if (result >= 1)
  {
    uint64_t v34 = result;
    for (CFIndex i = 0; i != v34; ++i)
    {
      ChildAtuint64_t Index = C3DAnimationNodeGetChildAtIndex(a2, i);
      uint64_t result = C3DAnimationManagerPauseAnimationNode(a1, ChildAtIndex, a3, a4, a5);
    }
  }
  return result;
}

uint64_t C3DAnimationManagerGetAnimationForKeyIsPaused(uint64_t a1, void *a2, const void *a3)
{
  CFDictionaryRef AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, a2, 0);
  if (!AnimationPerKeyDictionaryForObject) {
    return 0;
  }
  CFStringRef Value = CFDictionaryGetValue(AnimationPerKeyDictionaryForObject, a3);
  if (!Value) {
    return 0;
  }

  return C3DAnimationNodeGetPaused((uint64_t)Value);
}

CFDictionaryRef C3DAnimationManagerPauseAnimationForKey(uint64_t a1, void *key, const void *a3, uint64_t a4, uint64_t a5, double a6)
{
  if (!a1 && (uint64_t v12 = scn_default_log(), os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v12, v13, v14, v15, v16, v17, v18, v19);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v20 = scn_default_log();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
  }
LABEL_6:
  if (!a3)
  {
    int v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }
  CFDictionaryRef result = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, a3);
    if (result) {
      return (const __CFDictionary *)C3DAnimationManagerPauseAnimationNode(a1, (uint64_t)result, a4, a5, a6);
    }
  }
  return result;
}

void C3DAnimationManagerApplyBindings(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v3 = *(void **)(a1 + 72);
  if (v3) {
    [v3 enumerateObjectsUsingBlock:&__block_literal_global_33];
  }

  os_unfair_lock_unlock(v2);
}

void *__C3DAnimationManagerApplyBindings_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(v13, 0, sizeof(v13));
  uint64_t TargetAddress = (_OWORD *)C3DModelTargetGetTargetAddress(a2[2]);
  uint64_t v4 = a2[4];
  if (v4)
  {
    uint64_t v5 = C3DModelTargetGetTargetAddress(a2[3]);
    (*(void (**)(uint64_t, _OWORD *, uint64_t, _OWORD *))(v4 + 16))(v4, TargetAddress, v5, v13);
    uint64_t TargetAddress = v13;
  }
  uint64_t Target = (const void *)C3DModelTargetGetTarget(a2[3]);
  uint64_t v7 = (void *)C3DModelTargetGetTargetAddress(a2[3]);
  Baseint Type = C3DModelTargetGetBaseType(a2[3]);
  size_t v9 = C3DSizeOfBaseType(BaseType);
  Typeint Semantic = C3DModelTargetGetTypeSemantic(a2[3]);
  Componentuint64_t Index = C3DModelTargetGetComponentIndex(a2[3]);
  return C3DSetValue(Target, v7, TargetAddress, v9, TypeSemantic, ComponentIndex);
}

BOOL C3DAnimationManagerAddBinding(uint64_t a1, float32x4_t *a2, CFStringRef theString, float32x4_t *a4, const __CFString *a5, void *a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  CFStringRef v12 = C3DCFTypeCopyModelInfoAtPath(a2, theString, 0);
  if (!v12)
  {
LABEL_9:
    unsigned int v19 = CFTypeIsC3DEntity(a2);
    uint64_t v20 = scn_default_log();
    BOOL result = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (v19)
    {
      if (!result) {
        return result;
      }
      C3DAnimationManagerAddBinding_cold_1((uint64_t)a2, (uint64_t)theString, v20);
    }
    else
    {
      if (!result) {
        return result;
      }
      C3DAnimationManagerAddBinding_cold_2();
    }
    return 0;
  }
  uint64_t v13 = (__C3DModelTarget *)v12;
  if (!C3DModelTargetGetTargetAddress((uint64_t)v12))
  {
    CFRelease(v13);
    goto LABEL_9;
  }
  CFStringRef v14 = C3DCFTypeCopyModelInfoAtPath(a4, a5, 0);
  if (!v14)
  {
    uint64_t v22 = v13;
LABEL_16:
    CFRelease(v22);
    return 0;
  }
  uint64_t v15 = (__C3DModelTarget *)v14;
  if (!C3DModelTargetGetTargetAddress((uint64_t)v14))
  {
    CFRelease(v13);
    uint64_t v22 = v15;
    goto LABEL_16;
  }
  Baseint Type = C3DModelTargetGetBaseType((uint64_t)v13);
  if (BaseType != C3DModelTargetGetBaseType((uint64_t)v15))
  {
    CFRelease(v13);
    CFRelease(v15);
    if (CFTypeIsC3DEntity(a2) && CFTypeIsC3DEntity(a4))
    {
      uint64_t v23 = scn_default_log();
      BOOL result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v26 = 138413058;
      uint64_t Name = C3DEntityGetName((uint64_t)a2);
      __int16 v28 = 2112;
      CFStringRef v29 = theString;
      __int16 v30 = 2112;
      uint64_t v31 = C3DEntityGetName((uint64_t)a4);
      __int16 v32 = 2112;
      CFStringRef v33 = a5;
    }
    else
    {
      uint64_t v23 = scn_default_log();
      BOOL result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v26 = 138413058;
      uint64_t Name = (uint64_t)a2;
      __int16 v28 = 2112;
      CFStringRef v29 = theString;
      __int16 v30 = 2112;
      uint64_t v31 = (uint64_t)a4;
      __int16 v32 = 2112;
      CFStringRef v33 = a5;
    }
    _os_log_error_impl(&dword_20B249000, v23, OS_LOG_TYPE_ERROR, "Error: Binding: Trying to bind two incompatible keypaths: %@(%@) -> %@(%@)", (uint8_t *)&v26, 0x2Au);
    return 0;
  }
  C3DAnimationManagerRemoveBinding(a1, a2, theString);
  uint64_t v17 = objc_alloc_init(C3DAnimationBinding);
  v17->_source = v15;
  v17->_destination = v13;
  if (a2) {
    uint64_t v18 = (void *)CFRetain(a2);
  }
  else {
    uint64_t v18 = 0;
  }
  v17->_owner = v18;
  uint64_t v24 = (const void *)[a6 objectForKeyedSubscript:@"SCNBindingValueTransformerKey"];
  if (v24) {
    v17->_valueTransformer = _Block_copy(v24);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v25 = *(__CFArray **)(a1 + 72);
  if (!v25)
  {
    uint64_t v25 = (__CFArray *)objc_alloc_init(MEMORY[0x263EFF980]);
    *(void *)(a1 + 72) = v25;
  }
  CFArrayAppendValue(v25, v17);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));

  return 1;
}

void C3DAnimationManagerRemoveBinding(uint64_t a1, float32x4_t *a2, const __CFString *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v7 = *(void **)(a1 + 72);
  if (v7)
  {
    CFStringRef v8 = C3DCFTypeCopyModelInfoAtPath(a2, a3, 0);
    uint64_t TargetAddress = C3DModelTargetGetTargetAddress((uint64_t)v8);
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 3221225472;
    v10[2] = __C3DAnimationManagerRemoveBinding_block_invoke;
    v10[3] = &__block_descriptor_48_e15_B32__0_8Q16_B24l;
    v10[4] = a2;
    v10[5] = TargetAddress;
    objc_msgSend(v7, "removeObjectsAtIndexes:", objc_msgSend(v7, "indexesOfObjectsPassingTest:", v10));
    CFRelease(v8);
  }
  os_unfair_lock_unlock(v6);
}

BOOL __C3DAnimationManagerRemoveBinding_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8) == *(void *)(a1 + 32)
      && C3DModelTargetGetTargetAddress(*(void *)(a2 + 24)) == *(void *)(a1 + 40);
}

void C3DAnimationManagerRemoveAllBindings(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v5 = *(void **)(a1 + 72);
  if (v5)
  {
    v6[0] = MEMORY[0x263EF8330];
    v6[1] = 3221225472;
    void v6[2] = __C3DAnimationManagerRemoveAllBindings_block_invoke;
    v6[3] = &__block_descriptor_40_e15_B32__0_8Q16_B24l;
    v6[4] = a2;
    objc_msgSend(v5, "removeObjectsAtIndexes:", objc_msgSend(v5, "indexesOfObjectsPassingTest:", v6));
  }
  os_unfair_lock_unlock(v4);
}

BOOL __C3DAnimationManagerRemoveAllBindings_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8) == *(void *)(a1 + 32);
}

void _C3DAnimationManagerCFFinalize(void *a1)
{
  uint64_t v2 = a1[3];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = ___C3DAnimationManagerCFFinalize_block_invoke;
  v13[3] = &__block_descriptor_40_e13_v24__0q8r_v16l;
  _OWORD v13[4] = a1;
  C3DArrayApply(v2, (uint64_t)v13);
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  uint64_t v5 = (const void *)a1[10];
  if (v5)
  {
    CFRelease(v5);
    a1[10] = 0;
  }
  uint64_t v6 = (const void *)a1[6];
  if (v6)
  {
    CFRelease(v6);
    a1[6] = 0;
  }
  uint64_t v7 = (const void *)a1[7];
  if (v7)
  {
    CFRelease(v7);
    a1[7] = 0;
  }
  CFStringRef v8 = (const void *)a1[2];
  if (v8)
  {
    CFRelease(v8);
    a1[2] = 0;
  }
  size_t v9 = (const void *)a1[14];
  if (v9)
  {
    CFRelease(v9);
    a1[14] = 0;
  }
  uint64_t v10 = (const void *)a1[15];
  if (v10)
  {
    CFRelease(v10);
    a1[15] = 0;
  }
  uint64_t v11 = (const void *)a1[16];
  if (v11)
  {
    CFRelease(v11);
    a1[16] = 0;
  }
  CFStringRef v12 = (const void *)a1[9];
  if (v12)
  {
    CFRelease(v12);
    a1[9] = 0;
  }
}

CFStringRef _C3DAnimationManagerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationManager %p>", a1);
}

CFStringRef _C3DAnimationManagerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationManager %p>", a1);
}

uint64_t _C3DAnimationManagerInitWithPropertyList()
{
  return 1;
}

uint64_t _C3DAnimationManagerCopyPropertyList()
{
  return 0;
}

uint64_t _C3DAnimationManagerFinalizeDeserialization()
{
  return 1;
}

void _C3DAnimationManagerFillLibraryForSerialization(uint64_t a1, void *context)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerSetSystemTime_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef v12 = *(const __CFDictionary **)(a1 + 48);
  if (v12) {
    CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)__fillLibraryWithAnimationPerObject, context);
  }
}

void __fillLibraryWithAnimationPerObject(int a1, CFDictionaryRef theDict, void *a3)
{
  if (theDict) {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__fillLibraryWithAnimationPerKey, a3);
  }
}

void __fillLibraryWithAnimationPerKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return;
  }
  uint64_t Animation = (void *)C3DAnimationNodeGetAnimation(a2);
  if (!Animation) {
    return;
  }
  uint64_t v5 = Animation;
  CFTypeID v6 = CFGetTypeID(Animation);
  if (v6 == C3DKeyframedAnimationGetTypeID())
  {
    uint64_t v7 = (__n128 *)C3DAnimationGroupCreate();
    C3DAnimationGroupAddAnimation((uint64_t)v7, v5);
    C3DLibraryAddEntry(a3, v7);
    uint64_t v8 = v7;
LABEL_8:
    CFRelease(v8);
    return;
  }
  CFTypeID v9 = CFGetTypeID(v5);
  if (v9 == C3DAnimationClusterGetTypeID())
  {
    uint64_t v10 = C3DAnimationGroupCreateWithAnimationCluster((uint64_t)v5);
    C3DLibraryAddEntry(a3, v10);
    uint64_t v8 = v10;
    goto LABEL_8;
  }

  C3DLibraryAddEntry(a3, v5);
}

BOOL _C3DAnimationManagerUpdateRelativeTimeOfAnimation(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  CFDictionaryRef v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t v20 = *(void *)(a2 + 16);
  if (C3DAnimationNodeGetPausedOrPausedByScene(a2)) {
    return 0;
  }
  int v21 = *(_DWORD *)(a2 + 121);
  if ((v21 & 4) != 0) {
    return 0;
  }
  __int16 v22 = *(_WORD *)(v20 + 84);
  if ((v22 & 8) != 0)
  {
    BOOL v23 = 1;
    if ((v21 & 2) == 0) {
      goto LABEL_20;
    }
  }
  else if (*(unsigned char *)(a1 + 91))
  {
    BOOL v23 = (v22 & 0x200) == 0;
    if ((v21 & 2) == 0) {
      goto LABEL_20;
    }
  }
  else
  {
    BOOL v23 = 0;
    if ((v21 & 2) == 0) {
      goto LABEL_20;
    }
  }
  *(_DWORD *)(a2 + 121) = v21 & 0xFFFFFFFD;
  double PauseTime = C3DAnimationNodeGetPauseTime(v20);
  if (!v23)
  {
    if (PauseTime == 0.0) {
      double PauseTime = 0.0;
    }
    double PauseTime = PauseTime + *(double *)(a1 + 144);
  }
  *(double *)(a2 + 80) = PauseTime;
LABEL_20:
  __int16 v43 = 0;
  BOOL v42 = 0;
  int v25 = *(_DWORD *)(a2 + 121);
  uint64_t v26 = 144;
  if (v23) {
    uint64_t v26 = 136;
  }
  double ContentTimeForTime = C3DAnimationNodeGetContentTimeForTime(a2, (BOOL *)&v43 + 1, &v43, &v42, *(double *)(a1 + v26));
  unsigned int v28 = *(_DWORD *)(a2 + 121);
  int v29 = HIBYTE(v43);
  BOOL v30 = v42;
  *(_DWORD *)(a2 + 121) = v28 & 0xFFFFFFCF | (16 * HIBYTE(v43)) | (32 * v42);
  if (v28 & 0x20 | v30)
  {
    float v31 = *(float *)(v20 + 72);
    double v32 = v31;
    BOOL v33 = v31 == 0.0;
    double v34 = 1.0;
    if (!v33) {
      double v34 = v32;
    }
    double v35 = ContentTimeForTime / v34;
    float v36 = *(float *)(a2 + 72);
    float v37 = v35;
    *(float *)(a2 + 72) = v37;
    uint64_t v38 = *(void *)(v20 + 96);
    if (v38) {
      C3DAnimationEventsTriggerEventsWithTimeChanges((void *)a1, v38, (v28 >> 4) & 1, v29 != 0, a2, v36, v35);
    }
  }
  if (!*(unsigned char *)(a1 + 90))
  {
    int v39 = *(_DWORD *)(a2 + 121);
    if ((v39 & 1) == 0)
    {
      *(_DWORD *)(a2 + 121) = v39 | 1;
      if (*(void *)(v20 + 144)) {
        _C3DAnimationManagerAppendCallback(a1, (char *)a2, 1);
      }
    }
    if ((_BYTE)v43 && ((*(_WORD *)(v20 + 84) & 8) == 0 || *(double *)(a2 + 88) != 0.0))
    {
      *(_DWORD *)(a2 + 121) |= 0x400u;
      _animationNodeCompleted(a1, a2);
    }
  }
  if (v23) {
    return 0;
  }
  BOOL result = 1;
  if ((v25 & 0x100) != 0 && (_BYTE)v43)
  {
    uint64_t v41 = *(void *)(a2 + 40);
    if (v41) {
      return (*(unsigned char *)(v41 + 122) & 1) == 0;
    }
    return 0;
  }
  return result;
}

void _animationNodeCompleted(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 90))
  {
    int v2 = *(_DWORD *)(a2 + 121);
    if ((v2 & 0x40) == 0)
    {
      *(_DWORD *)(a2 + 121) = v2 | 0x40;
      _C3DAnimationManagerAppendCallback(a1, (char *)a2, 6);
    }
  }
}

uint64_t _commonAncessor(const __CFArray *a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2 != (const void *)a3)
  {
    uint64_t Parent = a3;
    CFIndex Count = CFArrayGetCount(a1);
    if (Count)
    {
      if (!Parent)
      {
LABEL_11:
        CFDictionaryRef v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          _commonAncessor_cold_1(v12);
        }
        return 0;
      }
      CFIndex v7 = Count;
      while (2)
      {
        if ((const void *)Parent != v3)
        {
          char v8 = 0;
          CFIndex v9 = v7;
          while (v9-- >= 1)
          {
            ValueAtuint64_t Index = CFArrayGetValueAtIndex(a1, v9);
            v8 |= ValueAtIndex == v3;
            if (ValueAtIndex == (const void *)Parent)
            {
              if ((v8 & 1) == 0) {
                return Parent;
              }
              return (uint64_t)v3;
            }
          }
          uint64_t Parent = C3DNodeGetParent(Parent);
          if (Parent) {
            continue;
          }
          goto LABEL_11;
        }
        break;
      }
    }
    else
    {
      if (!Parent) {
        return 0;
      }
      uint64_t v13 = (const void *)Parent;
      do
      {
        CFArrayAppendValue(a1, v13);
        uint64_t v13 = (const void *)C3DNodeGetParent((uint64_t)v13);
      }
      while (v13);
      return Parent;
    }
  }
  return (uint64_t)v3;
}

uint64_t ___resolveAnimationGroupTargets_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Name = (const void *)C3DNodeGetName(a2);
  if (Name
    && CFEqual(Name, *(CFTypeRef *)(a1 + 40))
    && (++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24),
        *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) > 1))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

uint64_t ___resolveAnimationClusterTargets_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Name = (const void *)C3DNodeGetName(a2);
  if (Name
    && CFEqual(Name, *(CFTypeRef *)(a1 + 40))
    && (++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24),
        *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) > 1))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

void C3DAnimationManagerRemoveAnimationNode(uint64_t a1, uint64_t a2)
{
  if (!a2 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a1) {
      goto LABEL_6;
    }
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  CFDictionaryRef v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_4(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFRetain((CFTypeRef)a2);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerRemoveAnimationNode_cold_2(v20, v21, v22, v23, v24, v25, v26, v27);
    }
  }
  _animationNodeCompleted(a1, a2);
  if (*(unsigned char *)(a1 + 88))
  {
    unsigned int v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerRemoveAnimationNode_cold_1(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }
  _C3DAnimationManagerDiscardAnimationNodeFromStack(a1, (void *)a2);
  *(_DWORD *)(a2 + 121) |= 0x800u;
  C3DAnimationNodeSetOwner(a2, 0);
  uint64_t v36 = *(void *)(a2 + 192);
  if (v36) {
    C3DAnimationPlayerRemoveAnimationNode(v36, (const void *)a2);
  }
  ChildCFIndex Count = C3DAnimationNodeGetChildCount(a2);
  if ((uint64_t)ChildCount >= 1)
  {
    CFArrayRef v38 = ChildCount;
    for (CFIndex i = 0; (const __CFArray *)i != v38; ++i)
    {
      ChildAtuint64_t Index = C3DAnimationNodeGetChildAtIndex(a2, i);
      C3DAnimationManagerRemoveAnimationNode(a1, ChildAtIndex);
    }
  }
  CFRelease((CFTypeRef)a2);
}

double __C3DKeyframeControllerGetTypeID_block_invoke()
{
  C3DKeyframeControllerGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DKeyframeControllerContextClassSerializable;
  unk_26B467290 = kC3DC3DKeyframeControllerContextClassSerializable;
  unk_26B4672A0 = *(_OWORD *)&off_26BF712C8;
  return result;
}

uint64_t C3DPreviousKeyFrameIndexForTime(float *a1, int a2, float *a3)
{
  *(void *)&v14[5] = *MEMORY[0x263EF8340];
  int v5 = a2 - 1;
  float v6 = *a3;
  if (a2 - 1 >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      int v8 = v5 + v7;
      if (v5 + (int)v7 < 0 != __OFADD__(v5, v7)) {
        int v9 = v8 + 1;
      }
      else {
        int v9 = v5 + v7;
      }
      if (v8 <= -2)
      {
        uint64_t v10 = scn_default_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          C3DPreviousKeyFrameIndexForTime_cold_1(v13, v14, v10);
        }
      }
      int v11 = v9 >> 1;
      if (a1[v9 >> 1] >= v6)
      {
        int v5 = v11 - 1;
      }
      else
      {
        if (v7 == v11)
        {
          if (a1[v5] <= v6) {
            return v5;
          }
          else {
            return v7;
          }
        }
        uint64_t v7 = (v9 >> 1);
      }
    }
    while (v5 > (int)v7);
    if (v7) {
      return v7;
    }
  }
  uint64_t v7 = 0;
  if (*a1 > v6) {
    *a3 = *a1;
  }
  return v7;
}

uint64_t _C3DKeyframeControllerCreate()
{
  if (C3DKeyframeControllerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DKeyframeControllerGetTypeID_onceToken, &__block_literal_global_20);
  }
  CFTypeID v0 = C3DKeyframeControllerGetTypeID_typeID;

  return C3DTypeCreateInstance_(v0, 0x68uLL);
}

const void *C3DKeyframeControllerCreateWithPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v6 = (const void *)_C3DKeyframeControllerCreate();
  uint64_t v7 = v6;
  if (v6 && (C3DInitWithPropertyList(v6, a1, a2, a3) & 1) == 0)
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t C3DKeyframeControllerCreateWithCapacity(unsigned int a1, unsigned int a2, char a3, int a4, int a5, int a6, int a7)
{
  uint64_t v14 = _C3DKeyframeControllerCreate();
  uint64_t v15 = v14;
  if (v14) {
    _C3DKeyframeControllerSetupWithCapacity(v14, a1, a2, a3, a4, a5, a6, a7);
  }
  return v15;
}

uint64_t (*_C3DKeyframeControllerSetupWithCapacity(uint64_t a1, unsigned int a2, unsigned int a3, char a4, int a5, int a6, int a7, int a8))()
{
  if (!a1 && (uint64_t v16 = scn_default_log(), os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)))
  {
    _C3DKeyframeControllerSetupWithCapacity_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
    _C3DKeyframeControllerSetupWithCapacity_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
  }
LABEL_6:
  *(void *)(a1 + 40) = C3DMalloc(4 * a2);
  *(_DWORD *)(a1 + 24) = a2;
  unsigned __int8 v32 = C3DSizeOfBaseType(a3);
  *(unsigned char *)(a1 + 30) = v32;
  *(_WORD *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = a3;
  *(unsigned char *)(a1 + 115) = a4;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = C3DMalloc(v32 * a2);
  if (a5) {
    *(void *)(a1 + 64) = C3DMalloc(a2);
  }
  if (a7)
  {
    *(void *)(a1 + 72) = C3DMalloc(4 * a2);
    *(void *)(a1 + 80) = C3DMalloc(4 * a2);
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = C3DMalloc(4 * a2);
  }
  *(unsigned char *)(a1 + 114) = a8;
  if (a8)
  {
    ComponentCFIndex Count = C3DBaseTypeGetComponentCount(a3);
    *(unsigned char *)(a1 + 113) = ComponentCount;
    *(void *)(a1 + 96) = C3DMalloc(ComponentCount * 8 * a2);
    *(void *)(a1 + 104) = C3DMalloc(8 * a2 * *(unsigned __int8 *)(a1 + 113));
  }
  if (a6) {
    *(void *)(a1 + 56) = C3DMalloc(16 * a2);
  }
  double result = C3DKeyFrameInterpolatorForType(*(__int16 *)(a1 + 28), *(char *)(a1 + 115), 0, *(char *)(a1 + 31), *(void *)(a1 + 64) == 0);
  *(void *)(a1 + 32) = result;
  return result;
}

BOOL C3DKeyframeControllerSetKeyframeAtIndex(uint64_t a1, unsigned int a2, void *__src, char a4, uint64_t a5, const void *a6, const void *a7, double a8, float a9, float a10, float a11)
{
  if (!a1)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  unsigned int v30 = *(_DWORD *)(a1 + 24);
  if (v30 <= a2)
  {
    uint64_t v44 = scn_default_log();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_1();
    }
  }
  else
  {
    float v31 = a8;
    *(float *)(*(void *)(a1 + 40) + 4 * a2) = v31;
    double v32 = *(double *)(a1 + 16);
    if (v32 <= a8) {
      double v32 = a8;
    }
    *(double *)(a1 + 16) = v32;
    memcpy((void *)(*(void *)(a1 + 48) + *(unsigned __int8 *)(a1 + 30) * a2), __src, *(unsigned __int8 *)(a1 + 30));
    uint64_t v33 = *(void *)(a1 + 64);
    if (v33 && *(_DWORD *)(a1 + 24) > a2) {
      *(unsigned char *)(v33 + a2) = a4;
    }
    uint64_t v34 = *(void *)(a1 + 72);
    if (v34) {
      *(float *)(v34 + 4 * a2) = a9;
    }
    uint64_t v35 = *(void *)(a1 + 80);
    if (v35) {
      *(float *)(v35 + 4 * a2) = a10;
    }
    uint64_t v36 = *(void *)(a1 + 88);
    if (v36) {
      *(float *)(v36 + 4 * a2) = a11;
    }
    if (a6)
    {
      uint64_t v37 = *(void *)(a1 + 96);
      if (v37)
      {
        *(unsigned char *)(a1 + 114) = 0;
        memcpy((void *)(v37 + 8 * *(unsigned __int8 *)(a1 + 113) * a2), a6, 8 * *(unsigned __int8 *)(a1 + 113));
      }
    }
    if (a7)
    {
      uint64_t v38 = *(void *)(a1 + 104);
      if (v38)
      {
        *(unsigned char *)(a1 + 114) = 0;
        memcpy((void *)(v38 + 8 * *(unsigned __int8 *)(a1 + 113) * a2), a7, 8 * *(unsigned __int8 *)(a1 + 113));
      }
    }
    uint64_t v39 = *(void *)(a1 + 56);
    if (v39)
    {
      uint64_t v40 = 4 * a2;
      if (a5)
      {
        ControlPoints = (long long *)C3DTimingFunctionGetControlPoints(a5);
        uint64_t v39 = *(void *)(a1 + 56);
        uint64_t v42 = 4 * v40;
        long long v43 = *ControlPoints;
      }
      else
      {
        uint64_t v42 = 4 * v40;
        long long v43 = 0uLL;
      }
      *(_OWORD *)(v39 + v42) = v43;
    }
  }
  return v30 > a2;
}

double C3DKeyframeControllerGetDuration(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 16);
}

uint64_t C3DKeyframeControllerEvaluateAtTime(uint64_t a1, int a2, uint64_t a3, uint64_t a4, double a5)
{
  if (!a1)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  if (!*(void *)(a1 + 48))
  {
    uint64_t v18 = scn_default_log();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerEvaluateAtTime_cold_3(v18, v19, v20, v21, v22, v23, v24, v25);
    }
  }
  if (!*(void *)(a1 + 32))
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerEvaluateAtTime_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
    }
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    uint64_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerEvaluateAtTime_cold_1(v34, v35, v36, v37, v38, v39, v40, v41);
    }
  }
  int v42 = *(unsigned __int8 *)(a1 + 31);
  float v43 = a5;
  float v63 = v43;
  unsigned int v44 = C3DPreviousKeyFrameIndexForTime(*(float **)(a1 + 40), *(_DWORD *)(a1 + 24), &v63);
  unsigned int v46 = v44;
  unsigned int v47 = *(_DWORD *)(a1 + 24) - 1;
  if (v44 + 1 < v47) {
    unsigned int v48 = v44 + 1;
  }
  else {
    unsigned int v48 = *(_DWORD *)(a1 + 24) - 1;
  }
  uint64_t v49 = *(void *)(a1 + 48);
  int v50 = *(unsigned __int8 *)(a1 + 30);
  uint64_t v51 = *(void *)(a1 + 64);
  if (v51)
  {
    if (v44 < v47) {
      unsigned int v47 = v44;
    }
    int v42 = *(unsigned __int8 *)(v51 + v47);
  }
  uint64_t v52 = v49 + v44 * v50;
  uint64_t v53 = v49 + v48 * v50;
  if (v42 == 1 || *(_WORD *)(a1 + 28) == 3)
  {
    uint64_t v54 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, __n128))(a1 + 32);
    v45.n128_f64[0] = v63;
    if (a2) {
      uint64_t v55 = v53;
    }
    else {
      uint64_t v55 = v52;
    }
    uint64_t v56 = (char)v42;
    uint64_t v57 = v55;
  }
  else
  {
    uint64_t v59 = *(void *)(a1 + 40);
    float v60 = *(float *)(v59 + 4 * v44);
    float v61 = *(float *)(v59 + 4 * v48) - v60;
    if (v61 == 0.0) {
      v45.n128_u32[0] = 0;
    }
    else {
      v45.n128_f32[0] = (float)(v63 - v60) / v61;
    }
    uint64_t v62 = *(void *)(a1 + 56);
    if (v62) {
      v45.n128_f32[0] = C3DTimingFunctionSolveCurve((float *)(v62 + 16 * v44), v45.n128_f32[0]);
    }
    if (v42)
    {
      v45.n128_f64[0] = v45.n128_f32[0];
      (*(void (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, __n128))(a1 + 32))(v52, v53, (char)v42, *(void *)(a1 + 104) + 8 * v46 * *(unsigned __int8 *)(a1 + 113), *(void *)(a1 + 96) + 8 * v48 * *(unsigned __int8 *)(a1 + 113), a3, a4, v45);
      return 1;
    }
    uint64_t v54 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, __n128))(a1 + 32);
    v45.n128_f64[0] = v45.n128_f32[0];
    uint64_t v55 = v52;
    uint64_t v57 = v53;
    uint64_t v56 = 0;
  }
  v54(v55, v57, v56, 0, 0, a3, a4, v45);
  return 1;
}

uint64_t C3DKeyframeControllerGetKeyCount(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t C3DKeyframeControllerGetValueType(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(__int16 *)(a1 + 28);
}

uint64_t C3DKeyframeControllerGetKeyframeSemantic(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DKeyFrameInterpolatorGetSemantic(*(double (**)(float32x4_t *, float32x4_t *, double, double, double, double, double, double, float32x4_t, uint64_t, uint64_t, uint64_t, int, float32x4_t *))(a1 + 32));
}

double C3DKeyframeControllerGetKeyTimeAtIndex(uint64_t a1, unsigned int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 40);
  double result = 0.0;
  if (v12)
  {
    if (*(_DWORD *)(a1 + 24) > a2) {
      return *(float *)(v12 + 4 * a2);
    }
  }
  return result;
}

uint64_t C3DKeyframeControllerGetValueAtIndex(uint64_t a1, int a2, void *__dst)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 48);
  if (!v14) {
    return 0;
  }
  memcpy(__dst, (const void *)(v14 + *(unsigned __int8 *)(a1 + 30) * a2), *(unsigned __int8 *)(a1 + 30));
  return *(unsigned __int8 *)(a1 + 30);
}

void C3DKeyframeControllerSetupKeyTimesForPacedMode(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!*(void *)(a1 + 48))
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerEvaluateAtTime_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t v20 = *(unsigned int *)(a1 + 24);
  if (v20 >= 2)
  {
    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = C3DMalloc(4 * v20);
    }
    uint64_t v21 = (v20 - 1);
    uint64_t v22 = *(float32x2_t **)(a1 + 48);
    int v23 = *(__int16 *)(a1 + 28);
    double v24 = 0.0;
    uint64_t v25 = 1;
    do
    {
      uint64_t v26 = v22;
      uint64_t v27 = *(void *)(a1 + 48);
      uint64_t v28 = v25 * *(unsigned __int8 *)(a1 + 30);
      uint64_t v22 = (float32x2_t *)(v27 + v28);
      switch(v23)
      {
        case 1:
        case 7:
          a2.f32[0] = vabds_f32(v26->f32[0], v22->f32[0]);
          goto LABEL_18;
        case 2:
          float v30 = v26->f32[0];
          float v31 = v22->f32[0];
          goto LABEL_28;
        case 3:
        case 16:
          LODWORD(v30) = v26->u8[0];
          LODWORD(v31) = v22->u8[0];
          goto LABEL_28;
        case 4:
          LODWORD(v30) = v26->i8[0];
          LODWORD(v31) = v22->i8[0];
          goto LABEL_28;
        case 6:
          double v35 = vabdd_f64(*(double *)v26, *(double *)v22);
          break;
        case 8:
        case 18:
          float32x2_t v29 = vsub_f32(*v26, *v22);
          *(float32x2_t *)a2.f32 = vmul_f32(v29, v29);
          goto LABEL_17;
        case 9:
        case 19:
          *(float32x2_t *)a2.f32 = *v26;
          a2.i32[2] = v26[1].i32[0];
          *(float32x2_t *)a3.f32 = *v22;
          a3.i32[2] = v22[1].i32[0];
          float32x4_t v32 = vsubq_f32(a2, a3);
          float32x4_t v33 = vmulq_f32(v32, v32);
          a3 = vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1));
          a2 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), a3);
          a2.f32[0] = sqrtf(a2.f32[0]);
          goto LABEL_18;
        case 10:
        case 20:
          float32x4_t v34 = vsubq_f32(*(float32x4_t *)v26->f32, *(float32x4_t *)v22->f32);
          a2 = vmulq_f32(v34, v34);
          a3 = (float32x4_t)vextq_s8((int8x16_t)a2, (int8x16_t)a2, 8uLL);
          *(float32x2_t *)a2.f32 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)a3.f32);
LABEL_17:
          a2.f32[0] = sqrtf(vaddv_f32(*(float32x2_t *)a2.f32));
          goto LABEL_18;
        case 11:
          a2.f32[0] = C3DMatrix4x4Distance((float32x4_t *)v26);
          goto LABEL_18;
        case 13:
          a2.f32[0] = C3DColor4Distance((float *)v26, (float *)(v27 + v28));
LABEL_18:
          double v35 = a2.f32[0];
          break;
        case 14:
          LODWORD(v30) = v26->i16[0];
          LODWORD(v31) = v22->i16[0];
          goto LABEL_28;
        case 17:
          LODWORD(v30) = v26->u16[0];
          LODWORD(v31) = v22->u16[0];
LABEL_28:
          double v35 = fabs((double)(LODWORD(v30) - LODWORD(v31)));
          break;
        default:
          uint64_t v36 = scn_default_log();
          double v35 = 0.0;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint8_t buf = 67109120;
            int v43 = v23;
            _os_log_impl(&dword_20B249000, v36, OS_LOG_TYPE_DEFAULT, "Warning: _C3DKeyDistance - can't compute key distance for type %d", buf, 8u);
          }
          break;
      }
      double v24 = v24 + v35;
      float v37 = v24;
      uint64_t v38 = *(_DWORD **)(a1 + 40);
      *(float *)&v38[v25++] = v37;
      uint64_t v39 = v25 - v21;
    }
    while (v25 - v21 != 1);
    *uint64_t v38 = 0;
    do
    {
      if (v24 == 0.0) {
        double v40 = (float)((float)v39 / (float)v20) + -1.0;
      }
      else {
        double v40 = *(float *)&v38[v39] / v24;
      }
      float v41 = v40;
      *(float *)&v38[v39++] = v41;
    }
    while (v20 != v39);
    *(double *)(a1 + 16) = *(float *)&v38[v21];
  }
}

void C3DKeyframeControllerSetCalculationMode(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 112) = a2;
}

uint64_t C3DKeyframeControllerGetCalculationMode(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(char *)(a1 + 112);
}

uint64_t (*C3DKeyframeControllerSetDefaultInterpolationMode(uint64_t a1, unsigned int a2))()
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 31) = a2;
  double result = C3DKeyFrameInterpolatorForType(*(__int16 *)(a1 + 28), *(char *)(a1 + 115), 0, a2, *(void *)(a1 + 64) == 0);
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t C3DKeyframeControllerGetDefaultInterpolationMode(uint64_t a1)
{
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(char *)(a1 + 31);
}

void _C3DKeyframeControllerRemoveUselessKeys(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  int v10 = *(unsigned __int8 *)(a1 + 31);
  if (*(void *)(a1 + 96))
  {
    if (v10 == 2)
    {
LABEL_6:
      uint64_t v11 = scn_default_log();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)uint8_t buf = 0;
      uint64_t v12 = "Warning: can't simplify keyframes because of cubic interpolation";
      goto LABEL_17;
    }
  }
  else
  {
    if (*(void *)(a1 + 104)) {
      BOOL v13 = v10 == 2;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13) {
      goto LABEL_6;
    }
  }
  if (*(void *)(a1 + 72) || *(void *)(a1 + 88) || *(void *)(a1 + 80))
  {
    uint64_t v11 = scn_default_log();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint8_t buf = 0;
    uint64_t v12 = "Warning: can't simplify keyframes because of tcb values";
    goto LABEL_17;
  }
  if (*(void *)(a1 + 56) || *(void *)(a1 + 64))
  {
    uint64_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint8_t buf = 0;
      uint64_t v12 = "Warning: can't simplify keyframes because of timing functions";
LABEL_17:
      _os_log_impl(&dword_20B249000, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
    }
  }
  else
  {
    uint64_t v14 = *(unsigned int *)(a1 + 24);
    if (v14 >= 3)
    {
      long long v41 = 0u;
      long long v42 = 0u;
      *(_OWORD *)uint8_t buf = 0u;
      long long v40 = 0u;
      memset(v38, 0, sizeof(v38));
      memset(__dst, 0, sizeof(__dst));
      memset(v36, 0, sizeof(v36));
      CFArrayRef Mutable = (const void *)C3DIndexSetCreateMutable();
      uint64_t v16 = 0;
      unsigned int v17 = 0;
      int v18 = *(unsigned __int16 *)(a1 + 28);
      BOOL v20 = v10 == 1 || v18 == 3;
      uint64_t v35 = v14;
      uint64_t v21 = (v14 - 1) - 1;
      uint64_t v22 = (char)v10;
      int v23 = (__int16)v18;
      do
      {
        C3DKeyframeControllerGetValueAtIndex(a1, v16 + 1, buf);
        C3DKeyframeControllerGetValueAtIndex(a1, v17, __dst);
        if (v20)
        {
          v24.n128_u64[0] = 0;
          (*(void (**)(_OWORD *, _OWORD *, uint64_t, void, void, void, _OWORD *, __n128))(a1 + 32))(__dst, __dst, v22, 0, 0, 0, v38, v24);
        }
        else
        {
          C3DKeyframeControllerGetValueAtIndex(a1, v16 + 2, v36);
          KeyTimeAtuint64_t Index = C3DKeyframeControllerGetKeyTimeAtIndex(a1, (int)v16 + 1);
          double v26 = C3DKeyframeControllerGetKeyTimeAtIndex(a1, v17);
          v27.n128_f64[0] = (KeyTimeAtIndex - v26) / (C3DKeyframeControllerGetKeyTimeAtIndex(a1, (int)v16 + 2) - v26);
          (*(void (**)(_OWORD *, _OWORD *, uint64_t, void, void, void, _OWORD *, __n128))(a1 + 32))(__dst, v36, v22, 0, 0, 0, v38, v27);
        }
        if (_compareValuesWithAccuracy((float *)buf, (float *)v38, v23)) {
          unsigned int v17 = v16 + 1;
        }
        else {
          C3DIndexSetAddIndex((uint64_t)Mutable, v16 + 1);
        }
        ++v16;
      }
      while (v21 != v16);
      uint64_t Count = C3DIndexSetGetCount((uint64_t)Mutable);
      if (Count >= 1)
      {
        int v29 = v35 - Count;
        float v31 = *(float **)(a1 + 40);
        float v30 = *(char **)(a1 + 48);
        *(_DWORD *)(a1 + 24) = v35 - Count;
        *(void *)(a1 + 40) = C3DMalloc(4 * (v35 - Count));
        float32x4_t v32 = C3DMalloc(v29 * *(unsigned __int8 *)(a1 + 30));
        uint64_t v33 = 0;
        unsigned int v34 = 0;
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v32;
        do
        {
          if ((C3DIndexSetContainsIndex((uint64_t)Mutable, v33) & 1) == 0) {
            C3DKeyframeControllerSetKeyframeAtIndex(a1, v34++, &v30[v33 * *(unsigned __int8 *)(a1 + 30)], v22, 0, 0, 0, v31[v33], 0.0, 0.0, 0.0);
          }
          ++v33;
        }
        while (v35 != v33);
        if (v31) {
          free(v31);
        }
        if (v30) {
          free(v30);
        }
      }
      CFRelease(Mutable);
    }
  }
}

BOOL _compareValuesWithAccuracy(float *a1, float *a2, int a3)
{
  switch(a3)
  {
    case 1:
    case 13:
      unint64_t v12 = C3DSizeOfBaseType(a3);
      if (v12 < 4) {
        return 0;
      }
      if (vabds_f32(*a1, *a2) > 0.000001) {
        return 1;
      }
      unint64_t v8 = v12 >> 2;
      uint64_t v13 = 1;
      do
      {
        unint64_t v10 = v13;
        if (v8 == v13) {
          break;
        }
        double v14 = vabds_f32(a1[v13], a2[v13]);
        ++v13;
      }
      while (v14 <= 0.000001);
      return v10 < v8;
    case 2:
    case 3:
    case 4:
    case 5:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      size_t v5 = C3DSizeOfBaseType(a3);
      return memcmp(a1, a2, v5) != 0;
    case 6:
      unint64_t v15 = C3DSizeOfBaseType(a3);
      if (v15 < 8) {
        return 0;
      }
      if (vabdd_f64(*(double *)a1, *(double *)a2) > 0.000001) {
        return 1;
      }
      unint64_t v8 = v15 >> 3;
      uint64_t v16 = 1;
      do
      {
        unint64_t v10 = v16;
        if (v8 == v16) {
          break;
        }
        double v17 = vabdd_f64(*(double *)&a1[2 * v16], *(double *)&a2[2 * v16]);
        ++v16;
      }
      while (v17 <= 0.000001);
      return v10 < v8;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      unint64_t v7 = C3DSizeOfBaseType(a3);
      if (v7 < 4) {
        return 0;
      }
      if (vabds_f32(*a1, *a2) > 0.000001) {
        return 1;
      }
      unint64_t v8 = v7 >> 2;
      uint64_t v9 = 1;
      do
      {
        unint64_t v10 = v9;
        if (v8 == v9) {
          break;
        }
        double v11 = vabds_f32(a1[v9], a2[v9]);
        ++v9;
      }
      while (v11 <= 0.000001);
      return v10 < v8;
    default:
      return 1;
  }
}

void C3DKeyframeControllerRemoveUselessKeys(uint64_t a1, unsigned char *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  _C3DKeyframeControllerRemoveUselessKeys(a1);
  if (a1 || (uint64_t v4 = scn_default_log(), !os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    if (!a2) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
  if (a2) {
LABEL_4:
  }
    *a2 = 0;
LABEL_5:
  if ((!*(void *)(a1 + 96) && !*(void *)(a1 + 104) || *(unsigned char *)(a1 + 31) != 2)
    && !*(void *)(a1 + 72)
    && !*(void *)(a1 + 88)
    && !*(void *)(a1 + 80)
    && !*(void *)(a1 + 56)
    && !*(void *)(a1 + 64)
    && C3DKeyframeControllerGetKeyCount(a1) == 2)
  {
    memset(__dst, 0, sizeof(__dst));
    memset(v14, 0, sizeof(v14));
    __int16 v12 = *(_WORD *)(a1 + 28);
    if (C3DKeyframeControllerGetValueAtIndex(a1, 0, __dst))
    {
      if (C3DKeyframeControllerGetValueAtIndex(a1, 1, v14))
      {
        BOOL v13 = _compareValuesWithAccuracy((float *)__dst, (float *)v14, v12);
        if (a2)
        {
          if (!v13) {
            *a2 = 1;
          }
        }
      }
    }
  }
}

uint64_t C3DKeyframeControllerGetValueComponentCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 113);
}

BOOL C3DKeyframeControllerHasTCB(uint64_t a1)
{
  return *(void *)(a1 + 72) && *(void *)(a1 + 88) != 0;
}

BOOL C3DKeyframeControllerHasTimingFunctions(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0;
}

float C3DKeyframeControllerGetTensionAtIndex(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 72) + 4 * a2);
}

float C3DKeyframeControllerGetContinuityAtIndex(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 80) + 4 * a2);
}

float C3DKeyframeControllerGetBiasAtIndex(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 88) + 4 * a2);
}

uint64_t C3DKeyframeControllerGetTimingFunctionAtIndex(uint64_t a1, int a2)
{
  return *(void *)(a1 + 56) + 4 * (4 * a2);
}

uint64_t C3DKeyframeControllerGetOutTangentsAtIndex(uint64_t a1, int a2)
{
  return *(void *)(a1 + 104) + 8 * *(unsigned __int8 *)(a1 + 113) * a2;
}

uint64_t C3DKeyframeControllerGetInTangentsAtIndex(uint64_t a1, int a2)
{
  return *(void *)(a1 + 96) + 8 * *(unsigned __int8 *)(a1 + 113) * a2;
}

uint64_t __C3DKeyframeControllerCopyGenericSource(uint64_t a1, const UInt8 *a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v8 = a4;
  CFIndex v9 = a4 * a3 * *(unsigned int *)(a1 + 24);
  if (a6) {
    CFDataRef v10 = CFDataCreate(0, a2, v9);
  }
  else {
    CFDataRef v10 = CFDataCreateWithBytesNoCopy(0, a2, v9, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  }
  CFDataRef v11 = v10;
  __int16 v12 = (const void *)C3DSourceAccessorCreate(a5, v8, *(unsigned int *)(a1 + 24), 0, 0);
  uint64_t Mutable = C3DGenericSourceCreateMutable(v12, 0);
  C3DGenericSourceSetData(Mutable, v11);
  C3DSourceAccessorSetSource((uint64_t)v12, Mutable);
  CFRelease(v11);
  CFRelease(v12);
  return Mutable;
}

uint64_t C3DKeyframeControllerCopyValuesAsGenericSource(uint64_t a1)
{
  unsigned int v1 = *(const UInt8 **)(a1 + 48);
  if (v1) {
    return __C3DKeyframeControllerCopyGenericSource(a1, v1, *(unsigned __int8 *)(a1 + 30), 1u, *(__int16 *)(a1 + 28), 0);
  }
  else {
    return 0;
  }
}

void _C3DKeyframeControllerCFFinalize(void *a1)
{
  int v2 = (void *)a1[5];
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[6];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[7];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[9];
  if (v6) {
    free(v6);
  }
  uint64_t v7 = (void *)a1[10];
  if (v7) {
    free(v7);
  }
  uint64_t v8 = (void *)a1[11];
  if (v8) {
    free(v8);
  }
  CFIndex v9 = (void *)a1[12];
  if (v9) {
    free(v9);
  }
  CFDataRef v10 = (void *)a1[13];
  if (v10)
  {
    free(v10);
  }
}

CFStringRef _C3DKeyframeControllerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DKeyframeController %p>", a1);
}

CFStringRef _C3DKeyframeControllerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DKeyframeController %p>", a1);
}

uint64_t _C3DKeyframeControllerInitWithPropertyList(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  values[2] = *(void **)MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"keyframeVersion");
  if (!Value)
  {
    double v17 = 0.04;
    goto LABEL_9;
  }
  double v17 = C3DParseVersionNumber(Value);
  if (v17 <= 0.11)
  {
LABEL_9:
    CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"keyframeType");
    if (v21 && (CFNumberRef v22 = v21, v23 = CFGetTypeID(v21), v23 == CFNumberGetTypeID()))
    {
      LODWORD(valuePtr) = 0;
      CFNumberGetValue(v22, kCFNumberIntType, &valuePtr);
      int v24 = valuePtr;
    }
    else
    {
      int v24 = 0;
    }
    if (v17 < 0.05)
    {
      if ((v24 - 3) > 2)
      {
        if ((v24 - 6) < 3) {
          LOWORD(v24) = v24 - 3;
        }
      }
      else
      {
        LOWORD(v24) = v24 + 5;
      }
    }
    CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"keyCount");
    if (v25)
    {
      CFNumberRef v26 = v25;
      CFTypeID v27 = CFGetTypeID(v25);
      if (v27 == CFNumberGetTypeID())
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
      }
    }
    CFDataRef v28 = (const __CFData *)CFDictionaryGetValue(theDict, @"data");
    if (v28)
    {
      CFDataRef v29 = v28;
      CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"keyCount");
      if (v30 && (CFNumberRef v31 = v30, v32 = CFGetTypeID(v30), v32 == CFNumberGetTypeID()))
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v31, kCFNumberIntType, &valuePtr);
        int v33 = valuePtr;
      }
      else
      {
        int v33 = 0;
      }
      unint64_t Length = CFDataGetLength(v29);
      unint64_t v35 = C3DSizeOfBaseType((__int16)v24) + 8;
      BytePtr = CFDataGetBytePtr(v29);
      if (v33 != (Length / v35))
      {
        float v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          _C3DKeyframeControllerInitWithPropertyList_cold_9(v37, v38, v39, v40, v41, v42, v43, v44);
        }
      }
      unint64_t v45 = (int)Length / v35;
      _C3DKeyframeControllerSetupWithCapacity(v7, v45, (__int16)v24, 0, 0, 0, 0, 0);
      if (v45)
      {
        uint64_t v46 = 0;
        unsigned int v47 = (char *)(BytePtr + 8);
        do
        {
          C3DKeyframeControllerSetKeyframeAtIndex(v7, v46++, v47, 0, 0, 0, 0, *((double *)v47 - 1), 0.0, 0.0, 0.0);
          v47 += v35;
        }
        while (v45 != v46);
      }
    }
    else
    {
      CFArrayRef v48 = (const __CFArray *)CFDictionaryGetValue(theDict, @"keyframes");
      if (v48)
      {
        CFArrayRef v49 = v48;
        unsigned int Count = CFArrayGetCount(v48);
        _C3DKeyframeControllerSetupWithCapacity(v7, Count, (__int16)v24, 0, 0, 0, 0, 0);
        unsigned int v51 = CFArrayGetCount(v49);
        if (v51 >= 2)
        {
          double v211 = 0.0;
          long long valuePtr = 0u;
          long long v213 = 0u;
          long long v214 = 0u;
          long long v215 = 0u;
          for (unsigned int i = 1; i < v51; i += 2)
          {
            ValueAtuint64_t Index = CFArrayGetValueAtIndex(v49, i - 1);
            CFTypeID v54 = CFGetTypeID(ValueAtIndex);
            if (v54 == CFNumberGetTypeID())
            {
              CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberDoubleType, &v211);
              CFBooleanRef v55 = (const __CFBoolean *)CFArrayGetValueAtIndex(v49, i);
              CFBooleanRef v56 = v55;
              switch((__int16)v24)
              {
                case 1:
                  CFTypeID v62 = CFGetTypeID(v55);
                  if (v62 != CFNumberGetTypeID())
                  {
                    float v63 = scn_default_log();
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_2((uint8_t *)values, (void **)((char *)values + 4), v63);
                    }
                  }
                  CFNumberRef v60 = v56;
                  CFNumberType v61 = kCFNumberFloatType;
                  goto LABEL_65;
                case 2:
                  CFTypeID v64 = CFGetTypeID(v55);
                  if (v64 != CFNumberGetTypeID())
                  {
                    long long v65 = scn_default_log();
                    if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_2(v225, &v226, v65);
                    }
                  }
                  CFNumberRef v60 = v56;
                  CFNumberType v61 = kCFNumberIntType;
                  goto LABEL_65;
                case 3:
                  CFTypeID v66 = CFGetTypeID(v55);
                  if (v66 != CFBooleanGetTypeID())
                  {
                    long long v67 = scn_default_log();
                    if (os_log_type_enabled(v67, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_4(v223, &v224, v67);
                    }
                  }
                  LOBYTE(valuePtr) = CFBooleanGetValue(v56) != 0;
                  break;
                case 4:
                case 16:
                  CFTypeID v58 = CFGetTypeID(v55);
                  if (v58 != CFNumberGetTypeID())
                  {
                    uint64_t v59 = scn_default_log();
                    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_2(v221, &v222, v59);
                    }
                  }
                  CFNumberRef v60 = v56;
                  CFNumberType v61 = kCFNumberCharType;
                  goto LABEL_65;
                case 5:
                  CFTypeID v68 = CFGetTypeID(v55);
                  if (v68 != CFNumberGetTypeID())
                  {
                    long long v69 = scn_default_log();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_2(v219, &v220, v69);
                    }
                  }
                  CFNumberRef v60 = v56;
                  CFNumberType v61 = kCFNumberLongType;
                  goto LABEL_65;
                case 6:
                  CFTypeID v70 = CFGetTypeID(v55);
                  if (v70 != CFNumberGetTypeID())
                  {
                    long long v71 = scn_default_log();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
                      _C3DKeyframeControllerInitWithPropertyList_cold_2(v217, &v218, v71);
                    }
                  }
                  CFNumberRef v60 = v56;
                  CFNumberType v61 = kCFNumberDoubleType;
LABEL_65:
                  CFNumberGetValue(v60, v61, &valuePtr);
                  break;
                case 8:
                case 9:
                case 10:
                case 11:
                case 13:
                  C3DInitC3DFloatArrayWithPropertyList(v55, &valuePtr, 0);
                  break;
                default:
                  long long v72 = scn_default_log();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
                    _C3DKeyframeControllerInitWithPropertyList_cold_1(&buf, v208, v72);
                  }
                  break;
              }
              C3DKeyframeControllerSetKeyframeAtIndex(v7, i - 1, &valuePtr, 0, 0, 0, 0, v211, 0.0, 0.0, 0.0);
            }
            else
            {
              uint64_t v57 = scn_default_log();
              if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
                _C3DKeyframeControllerInitWithPropertyList_cold_8(&v209, v210, v57);
              }
            }
          }
        }
      }
    }
    *(void *)(v7 + 32) = C3DKeyFrameInterpolatorForType((__int16)v24, 0, 0, *(char *)(v7 + 31), *(void *)(v7 + 64) == 0);
LABEL_72:
    Keyunsigned int Count = C3DKeyframeControllerGetKeyCount(v7);
    if (KeyCount) {
      KeyTimeAtuint64_t Index = C3DKeyframeControllerGetKeyTimeAtIndex(v7, KeyCount - 1);
    }
    else {
      KeyTimeAtuint64_t Index = 0.0;
    }
    *(double *)(v7 + 16) = KeyTimeAtIndex;
    return 1;
  }
  float32x4_t v216 = 0;
  long long v214 = 0u;
  long long v215 = 0u;
  long long valuePtr = 0u;
  long long v213 = 0u;
  int v18 = CFDictionaryGetValue(theDict, @"keytimes");
  if (v18)
  {
    uint64_t v19 = (uint64_t)v18;
    Empty = (const void *)C3DGenericSourceCreateEmpty();
    *(void *)&long long valuePtr = Empty;
    C3DInitWithPropertyList(Empty, v19, a3, a4);
  }
  else
  {
    Empty = 0;
  }
  CFDataRef v76 = (const __CFData *)CFDictionaryGetValue(theDict, @"keytimes-data");
  if (v76 && Empty)
  {
    CFDataRef v77 = v76;
    values[0] = (void *)C3DGenericSourceGetAccessor((uint64_t)Empty);
    CFArrayRef v78 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    DeserializedDataWithAccessors = C3DGenericSourceCreateDeserializedDataWithAccessors((uint64_t)Empty, v77, v78);
    C3DSourceAccessorsConvertToCurrentPlatform(v78);
    CFRelease(v78);
    if (DeserializedDataWithAccessors)
    {
      C3DGenericSourceSetData((uint64_t)Empty, DeserializedDataWithAccessors);
      CFRelease(DeserializedDataWithAccessors);
    }
    else
    {
      uint64_t v80 = scn_default_log();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  uint64_t v81 = CFDictionaryGetValue(theDict, @"values");
  if (v81)
  {
    uint64_t v82 = (uint64_t)v81;
    uint64_t v83 = (const void *)C3DGenericSourceCreateEmpty();
    *((void *)&valuePtr + 1) = v83;
    C3DInitWithPropertyList(v83, v82, a3, a4);
  }
  else
  {
    uint64_t v83 = 0;
  }
  CFDataRef v84 = (const __CFData *)CFDictionaryGetValue(theDict, @"values-data");
  if (v84 && v83)
  {
    CFDataRef v85 = v84;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor((uint64_t)v83);
    CFArrayRef v86 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    float32x4_t v87 = C3DGenericSourceCreateDeserializedDataWithAccessors((uint64_t)v83, v85, v86);
    C3DSourceAccessorsConvertToCurrentPlatform(v86);
    CFRelease(v86);
    if (v87)
    {
      C3DGenericSourceSetData((uint64_t)v83, v87);
      CFRelease(v87);
    }
    else
    {
      unsigned int v88 = scn_default_log();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  float32x4_t v89 = CFDictionaryGetValue(theDict, @"timingFunctions");
  if (v89)
  {
    uint64_t v90 = (uint64_t)v89;
    long long v91 = (const void *)C3DGenericSourceCreateEmpty();
    *(void *)&long long v213 = v91;
    C3DInitWithPropertyList(v91, v90, a3, a4);
  }
  else
  {
    long long v91 = 0;
  }
  CFDataRef v92 = (const __CFData *)CFDictionaryGetValue(theDict, @"timingFunctions-data");
  if (v92 && v91)
  {
    CFDataRef v93 = v92;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor((uint64_t)v91);
    CFArrayRef v94 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    unint64_t v95 = C3DGenericSourceCreateDeserializedDataWithAccessors((uint64_t)v91, v93, v94);
    C3DSourceAccessorsConvertToCurrentPlatform(v94);
    CFRelease(v94);
    if (v95)
    {
      C3DGenericSourceSetData((uint64_t)v91, v95);
      CFRelease(v95);
    }
    else
    {
      uint64_t v96 = scn_default_log();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  unint64_t v97 = CFDictionaryGetValue(theDict, @"interpolationModes");
  if (v97)
  {
    uint64_t v98 = (uint64_t)v97;
    *((void *)&v213 + 1) = C3DGenericSourceCreateEmpty();
    uint64_t v206 = *((void *)&v213 + 1);
    C3DInitWithPropertyList(*((const void **)&v213 + 1), v98, a3, a4);
  }
  else
  {
    uint64_t v206 = 0;
  }
  CFDataRef v99 = (const __CFData *)CFDictionaryGetValue(theDict, @"interpolationModes-data");
  if (v99 && v206)
  {
    CFDataRef v100 = v99;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor(v206);
    CFArrayRef v101 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    uint64_t v102 = C3DGenericSourceCreateDeserializedDataWithAccessors(v206, v100, v101);
    C3DSourceAccessorsConvertToCurrentPlatform(v101);
    CFRelease(v101);
    if (v102)
    {
      C3DGenericSourceSetData(v206, v102);
      CFRelease(v102);
    }
    else
    {
      unint64_t v103 = scn_default_log();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  long long v104 = CFDictionaryGetValue(theDict, @"tensionValues");
  if (v104)
  {
    uint64_t v105 = (uint64_t)v104;
    *(void *)&long long v214 = C3DGenericSourceCreateEmpty();
    uint64_t v205 = v214;
    C3DInitWithPropertyList((const void *)v214, v105, a3, a4);
  }
  else
  {
    uint64_t v205 = 0;
  }
  CFDataRef v106 = (const __CFData *)CFDictionaryGetValue(theDict, @"tensionValues-data");
  if (v106 && v205)
  {
    CFDataRef v107 = v106;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor(v205);
    CFArrayRef v108 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    uint64_t v109 = C3DGenericSourceCreateDeserializedDataWithAccessors(v205, v107, v108);
    C3DSourceAccessorsConvertToCurrentPlatform(v108);
    CFRelease(v108);
    if (v109)
    {
      C3DGenericSourceSetData(v205, v109);
      CFRelease(v109);
    }
    else
    {
      unint64_t v110 = scn_default_log();
      if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  int v111 = CFDictionaryGetValue(theDict, @"continuityValues");
  if (v111)
  {
    uint64_t v112 = (uint64_t)v111;
    *((void *)&v214 + 1) = C3DGenericSourceCreateEmpty();
    uint64_t v204 = *((void *)&v214 + 1);
    C3DInitWithPropertyList(*((const void **)&v214 + 1), v112, a3, a4);
  }
  else
  {
    uint64_t v204 = 0;
  }
  CFDataRef v113 = (const __CFData *)CFDictionaryGetValue(theDict, @"continuityValues-data");
  if (v113 && v204)
  {
    CFDataRef v114 = v113;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor(v204);
    CFArrayRef v115 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    uint64_t v116 = C3DGenericSourceCreateDeserializedDataWithAccessors(v204, v114, v115);
    C3DSourceAccessorsConvertToCurrentPlatform(v115);
    CFRelease(v115);
    if (v116)
    {
      C3DGenericSourceSetData(v204, v116);
      CFRelease(v116);
    }
    else
    {
      int32x4_t v117 = scn_default_log();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  uint64_t v118 = CFDictionaryGetValue(theDict, @"biasValues");
  if (v118)
  {
    uint64_t v119 = (uint64_t)v118;
    *(void *)&long long v215 = C3DGenericSourceCreateEmpty();
    uint64_t v203 = v215;
    C3DInitWithPropertyList((const void *)v215, v119, a3, a4);
  }
  else
  {
    uint64_t v203 = 0;
  }
  CFDataRef v120 = (const __CFData *)CFDictionaryGetValue(theDict, @"biasValues-data");
  if (v120 && v203)
  {
    CFDataRef v121 = v120;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor(v203);
    CFArrayRef v122 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    float32x4_t v123 = C3DGenericSourceCreateDeserializedDataWithAccessors(v203, v121, v122);
    C3DSourceAccessorsConvertToCurrentPlatform(v122);
    CFRelease(v122);
    if (v123)
    {
      C3DGenericSourceSetData(v203, v123);
      CFRelease(v123);
    }
    else
    {
      int v124 = scn_default_log();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  uint64_t v125 = CFDictionaryGetValue(theDict, @"inTangents");
  if (v125)
  {
    uint64_t v126 = (uint64_t)v125;
    uint64_t v127 = (const void *)C3DGenericSourceCreateEmpty();
    *((void *)&v215 + 1) = v127;
    C3DInitWithPropertyList(v127, v126, a3, a4);
  }
  else
  {
    uint64_t v127 = 0;
  }
  CFDataRef v128 = (const __CFData *)CFDictionaryGetValue(theDict, @"inTangents-data");
  if (v128 && v127)
  {
    CFDataRef v129 = v128;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor((uint64_t)v127);
    CFArrayRef v130 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    float32x4_t v131 = C3DGenericSourceCreateDeserializedDataWithAccessors((uint64_t)v127, v129, v130);
    C3DSourceAccessorsConvertToCurrentPlatform(v130);
    CFRelease(v130);
    if (v131)
    {
      C3DGenericSourceSetData((uint64_t)v127, v131);
      CFRelease(v131);
    }
    else
    {
      float32x4_t v132 = scn_default_log();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  uint64_t v202 = v7;
  unsigned int v133 = CFDictionaryGetValue(theDict, @"outTangents");
  if (v133)
  {
    uint64_t v134 = (uint64_t)v133;
    unint64_t v135 = (const void *)C3DGenericSourceCreateEmpty();
    float32x4_t v216 = v135;
    C3DInitWithPropertyList(v135, v134, a3, a4);
  }
  else
  {
    unint64_t v135 = 0;
  }
  uint64_t v136 = v206;
  CFDataRef v137 = (const __CFData *)CFDictionaryGetValue(theDict, @"outTangents-data");
  if (v137 && v135)
  {
    CFDataRef v138 = v137;
    values[0] = 0;
    values[0] = (void *)C3DGenericSourceGetAccessor((uint64_t)v135);
    CFArrayRef v139 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x263EFFF70]);
    unint64_t v140 = C3DGenericSourceCreateDeserializedDataWithAccessors((uint64_t)v135, v138, v139);
    C3DSourceAccessorsConvertToCurrentPlatform(v139);
    CFRelease(v139);
    if (v140)
    {
      C3DGenericSourceSetData((uint64_t)v135, v140);
      CFRelease(v140);
    }
    else
    {
      uint64_t v141 = scn_default_log();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframeControllerInitWithPropertyList_cold_12();
      }
    }
  }
  uint64_t Accessor = C3DGenericSourceGetAccessor((uint64_t)Empty);
  unint64_t v200 = (void *)C3DGenericSourceGetAccessor((uint64_t)v83);
  ComponentsValueint Type = C3DSourceAccessorGetComponentsValueType((uint64_t)v200);
  uint64_t v201 = (void *)Accessor;
  unsigned int v144 = C3DSourceAccessorGetCount(Accessor);
  if (v144)
  {
    if (ComponentsValueType)
    {
      CFDictionaryRef v199 = theDict;
      CFNumberRef v145 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"semantic");
      if (v145 && (CFNumberRef v146 = v145, v147 = CFGetTypeID(v145), v147 == CFNumberGetTypeID()))
      {
        LODWORD(values[0]) = 0;
        CFNumberGetValue(v146, kCFNumberIntType, values);
        char v148 = (char)values[0];
      }
      else
      {
        char v148 = 0;
      }
      int v197 = v148;
      int v198 = ComponentsValueType;
      _C3DKeyframeControllerSetupWithCapacity(v202, v144, ComponentsValueType, v148, v206 != 0, v91 != 0, v205 != 0, v127 != 0);
      uint64_t v159 = 0;
      unsigned int v160 = v144 - 2;
      uint64_t v161 = v144;
      v162 = v91;
      while (1)
      {
        ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(v201, v159);
        uint64_t v164 = (UInt8 *)C3DSourceAccessorGetValuePtrAtIndex(v200, v159);
        if (v91)
        {
          uint64_t v165 = (void *)C3DGenericSourceGetAccessor((uint64_t)v91);
          uint64_t v166 = (float *)C3DSourceAccessorGetValuePtrAtIndex(v165, v159);
          if (!v166)
          {
            long long v91 = 0;
            if (!v136) {
              goto LABEL_181;
            }
            goto LABEL_173;
          }
          long long v91 = (const void *)C3DTimingFunctionCreateWithControlPoints(*v166, v166[1], v166[2], v166[3]);
        }
        if (!v136) {
          goto LABEL_181;
        }
LABEL_173:
        uint64_t v167 = (void *)C3DGenericSourceGetAccessor(v136);
        if (v159 >= v160) {
          uint64_t v168 = v160;
        }
        else {
          uint64_t v168 = v159;
        }
        float32x2_t v169 = C3DSourceAccessorGetValuePtrAtIndex(v167, v168);
        if (v169) {
          LOBYTE(v136) = *v169;
        }
        else {
          LOBYTE(v136) = 0;
        }
LABEL_181:
        double v170 = *(double *)ValuePtrAtIndex;
        float v171 = 0.0;
        float v172 = 0.0;
        if (v205)
        {
          float32x4_t v173 = (void *)C3DGenericSourceGetAccessor(v205);
          float v172 = *(float *)C3DSourceAccessorGetValuePtrAtIndex(v173, v159);
        }
        if (v204)
        {
          uint64_t v174 = (void *)C3DGenericSourceGetAccessor(v204);
          float v171 = *(float *)C3DSourceAccessorGetValuePtrAtIndex(v174, v159);
        }
        if (v203)
        {
          unint64_t v175 = (void *)C3DGenericSourceGetAccessor(v203);
          float v176 = *(float *)C3DSourceAccessorGetValuePtrAtIndex(v175, v159);
          if (v127) {
            goto LABEL_187;
          }
        }
        else
        {
          float v176 = 0.0;
          if (v127)
          {
LABEL_187:
            unsigned int v177 = (void *)C3DGenericSourceGetAccessor((uint64_t)v127);
            int v178 = C3DSourceAccessorGetValuePtrAtIndex(v177, v159);
            if (!v135) {
              goto LABEL_191;
            }
            goto LABEL_188;
          }
        }
        int v178 = 0;
        if (!v135)
        {
LABEL_191:
          unint64_t v180 = 0;
          goto LABEL_192;
        }
LABEL_188:
        uint64_t v179 = (void *)C3DGenericSourceGetAccessor((uint64_t)v135);
        unint64_t v180 = C3DSourceAccessorGetValuePtrAtIndex(v179, v159);
LABEL_192:
        C3DKeyframeControllerSetKeyframeAtIndex(v202, v159, v164, v136, (uint64_t)v91, v178, v180, v170, v172, v171, v176);
        if (v91) {
          CFRelease(v91);
        }
        ++v159;
        long long v91 = v162;
        uint64_t v136 = v206;
        if (v161 == v159)
        {
          uint64_t v181 = 0;
          uint64_t v7 = v202;
          do
          {
            unint64_t v182 = *(const void **)((char *)&valuePtr + v181);
            if (v182)
            {
              CFRelease(v182);
              *(void *)((char *)&valuePtr + v181) = 0;
            }
            v181 += 8;
          }
          while (v181 != 72);
          *(void *)(v202 + 32) = C3DKeyFrameInterpolatorForType(v198, v197, 0, *(char *)(v202 + 31), *(void *)(v202 + 64) == 0);
          CFNumberRef v183 = (const __CFNumber *)CFDictionaryGetValue(v199, @"interpolationMode");
          if (v183)
          {
            CFNumberRef v184 = v183;
            CFTypeID v185 = CFGetTypeID(v183);
            if (v185 == CFNumberGetTypeID())
            {
              LODWORD(values[0]) = 0;
              CFNumberGetValue(v184, kCFNumberIntType, values);
              *(unsigned char *)(v202 + 31) = values[0];
            }
          }
          CFNumberRef v186 = (const __CFNumber *)CFDictionaryGetValue(v199, @"calculationMode");
          if (v186 && (CFNumberRef v187 = v186, v188 = CFGetTypeID(v186), v188 == CFNumberGetTypeID()))
          {
            LODWORD(values[0]) = 0;
            CFNumberGetValue(v187, kCFNumberIntType, values);
            *(unsigned char *)(v202 + 112) = values[0];
          }
          else if (!v202)
          {
            uint64_t v189 = scn_default_log();
            if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT)) {
              C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v189, v190, v191, v192, v193, v194, v195, v196);
            }
          }
          goto LABEL_72;
        }
      }
    }
  }
  else
  {
    long long v149 = scn_default_log();
    if (os_log_type_enabled(v149, OS_LOG_TYPE_FAULT)) {
      _C3DKeyframeControllerInitWithPropertyList_cold_10(v149, v150, v151, v152, v153, v154, v155, v156);
    }
  }
  for (uint64_t j = 0; j != 72; j += 8)
  {
    long long v158 = *(const void **)((char *)&valuePtr + j);
    if (v158)
    {
      CFRelease(v158);
      *(void *)((char *)&valuePtr + j) = 0;
    }
  }
  return 0;
}

__CFDictionary *_C3DKeyframeControllerCopyPropertyList(char *cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!cf)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFAllocatorRef v16 = CFGetAllocator(cf);
  uint64_t Mutable = CFDictionaryCreateMutable(v16, 15, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryAddValue(Mutable, @"keyframeVersion", @"0.12");
  LODWORD(valuePtr) = cf[31];
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"interpolationMode", v18);
  CFRelease(v18);
  LODWORD(valuePtr) = cf[112];
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"calculationMode", v19);
  CFRelease(v19);
  if (*((void *)cf + 5))
  {
    BOOL v20 = (const UInt8 *)C3DMalloc(8 * *((unsigned int *)cf + 6));
    CFNumberRef v21 = (UInt8 *)v20;
    uint64_t v22 = *((unsigned int *)cf + 6);
    if (v22)
    {
      CFTypeID v23 = (float *)*((void *)cf + 5);
      int v24 = (double *)v20;
      do
      {
        float v25 = *v23++;
        *v24++ = v25;
        --v22;
      }
      while (v22);
    }
    CFNumberRef v26 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v20, 8, 1u, 6, 1);
    free(v21);
    if (v26)
    {
      CFTypeID v27 = (const void *)C3DCopyPropertyList(v26, a2, a3, a4);
      if (v27)
      {
        CFDataRef v28 = v27;
        CFDictionaryAddValue(Mutable, @"keytimes", v27);
        CFRelease(v28);
      }
      if (Mutable)
      {
        uint64_t valuePtr = 0;
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v26);
        CFArrayRef v29 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef SerializedDataWithAccessors = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v26, v29);
        CFRelease(v29);
        CFDictionaryAddValue(Mutable, @"keytimes-data", SerializedDataWithAccessors);
        CFRelease(SerializedDataWithAccessors);
      }
      CFRelease(v26);
    }
  }
  CFNumberRef v31 = (const void *)C3DKeyframeControllerCopyValuesAsGenericSource((uint64_t)cf);
  if (v31)
  {
    CFTypeID v32 = v31;
    int v33 = (const void *)C3DCopyPropertyList(v31, a2, a3, a4);
    if (v33)
    {
      unsigned int v34 = v33;
      CFDictionaryAddValue(Mutable, @"values", v33);
      CFRelease(v34);
    }
    if (Mutable)
    {
      uint64_t valuePtr = 0;
      uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v32);
      CFArrayRef v35 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
      CFDataRef v36 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v32, v35);
      CFRelease(v35);
      CFDictionaryAddValue(Mutable, @"values-data", v36);
      CFRelease(v36);
    }
    CFRelease(v32);
  }
  float v37 = (const UInt8 *)*((void *)cf + 7);
  if (v37)
  {
    uint64_t v38 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v37, 4, 4u, 7, 0);
    if (v38)
    {
      uint64_t v39 = v38;
      uint64_t v40 = (const void *)C3DCopyPropertyList(v38, a2, a3, a4);
      if (v40)
      {
        uint64_t v41 = v40;
        CFDictionaryAddValue(Mutable, @"timingFunctions", v40);
        CFRelease(v41);
      }
      if (Mutable)
      {
        uint64_t valuePtr = 0;
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v39);
        CFArrayRef v42 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v43 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v39, v42);
        CFRelease(v42);
        CFDictionaryAddValue(Mutable, @"timingFunctions-data", v43);
        CFRelease(v43);
      }
      CFRelease(v39);
    }
  }
  uint64_t v44 = (const UInt8 *)*((void *)cf + 8);
  if (v44)
  {
    unint64_t v45 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v44, 1, 1u, 4, 0);
    if (v45)
    {
      uint64_t v46 = v45;
      unsigned int v47 = (const void *)C3DCopyPropertyList(v45, a2, a3, a4);
      if (v47)
      {
        CFArrayRef v48 = v47;
        CFDictionaryAddValue(Mutable, @"interpolationModes", v47);
        CFRelease(v48);
      }
      if (Mutable)
      {
        uint64_t valuePtr = 0;
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v46);
        CFArrayRef v49 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v50 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v46, v49);
        CFRelease(v49);
        CFDictionaryAddValue(Mutable, @"interpolationModes-data", v50);
        CFRelease(v50);
      }
      CFRelease(v46);
    }
  }
  unsigned int v51 = (const UInt8 *)*((void *)cf + 9);
  if (v51)
  {
    uint64_t v52 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v51, 4, 1u, 1, 0);
    if (v52)
    {
      uint64_t v53 = v52;
      CFTypeID v54 = (const void *)C3DCopyPropertyList(v52, a2, a3, a4);
      if (v54)
      {
        CFBooleanRef v55 = v54;
        CFDictionaryAddValue(Mutable, @"tensionValues", v54);
        CFRelease(v55);
      }
      if (Mutable)
      {
        uint64_t valuePtr = 0;
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v53);
        CFArrayRef v56 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v57 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v53, v56);
        CFRelease(v56);
        CFDictionaryAddValue(Mutable, @"tensionValues-data", v57);
        CFRelease(v57);
      }
      CFRelease(v53);
    }
  }
  CFTypeID v58 = (const UInt8 *)*((void *)cf + 10);
  if (v58)
  {
    uint64_t v59 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v58, 4, 1u, 1, 0);
    if (v59)
    {
      CFNumberRef v60 = v59;
      CFNumberType v61 = (const void *)C3DCopyPropertyList(v59, a2, a3, a4);
      if (v61)
      {
        CFTypeID v62 = v61;
        CFDictionaryAddValue(Mutable, @"continuityValues", v61);
        CFRelease(v62);
      }
      if (Mutable)
      {
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v60);
        CFArrayRef v63 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v64 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v60, v63);
        CFRelease(v63);
        CFDictionaryAddValue(Mutable, @"continuityValues-data", v64);
        CFRelease(v64);
      }
      CFRelease(v60);
    }
  }
  long long v65 = (const UInt8 *)*((void *)cf + 11);
  if (v65)
  {
    CFTypeID v66 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v65, 4, 1u, 1, 0);
    if (v66)
    {
      long long v67 = v66;
      CFTypeID v68 = (const void *)C3DCopyPropertyList(v66, a2, a3, a4);
      if (v68)
      {
        long long v69 = v68;
        CFDictionaryAddValue(Mutable, @"biasValues", v68);
        CFRelease(v69);
      }
      if (Mutable)
      {
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v67);
        CFArrayRef v70 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v71 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v67, v70);
        CFRelease(v70);
        CFDictionaryAddValue(Mutable, @"biasValues-data", v71);
        CFRelease(v71);
      }
      CFRelease(v67);
    }
  }
  long long v72 = (const UInt8 *)*((void *)cf + 12);
  if (v72)
  {
    long long v73 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v72, 8, cf[113], 8, 0);
    if (v73)
    {
      long long v74 = v73;
      long long v75 = (const void *)C3DCopyPropertyList(v73, a2, a3, a4);
      if (v75)
      {
        CFDataRef v76 = v75;
        CFDictionaryAddValue(Mutable, @"inTangents", v75);
        CFRelease(v76);
      }
      if (Mutable)
      {
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v74);
        CFArrayRef v77 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v78 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v74, v77);
        CFRelease(v77);
        CFDictionaryAddValue(Mutable, @"inTangents-data", v78);
        CFRelease(v78);
      }
      CFRelease(v74);
    }
  }
  int8x16_t v79 = (const UInt8 *)*((void *)cf + 13);
  if (v79)
  {
    uint64_t v80 = (const void *)__C3DKeyframeControllerCopyGenericSource((uint64_t)cf, v79, 8, cf[113], 8, 0);
    if (v80)
    {
      uint64_t v81 = v80;
      uint64_t v82 = (const void *)C3DCopyPropertyList(v80, a2, a3, a4);
      if (v82)
      {
        uint64_t v83 = v82;
        CFDictionaryAddValue(Mutable, @"outTangents", v82);
        CFRelease(v83);
      }
      if (Mutable)
      {
        uint64_t valuePtr = C3DGenericSourceGetAccessor((uint64_t)v81);
        CFArrayRef v84 = CFArrayCreate(0, (const void **)&valuePtr, 1, MEMORY[0x263EFFF70]);
        CFDataRef v85 = C3DGenericSourceCreateSerializedDataWithAccessors((uint64_t)v81, v84);
        CFRelease(v84);
        CFDictionaryAddValue(Mutable, @"outTangents-data", v85);
        CFRelease(v85);
      }
      CFRelease(v81);
    }
  }
  Keyframeint Semantic = C3DKeyframeControllerGetKeyframeSemantic((uint64_t)cf);
  if (KeyframeSemantic)
  {
    LODWORD(valuePtr) = KeyframeSemantic;
    CFNumberRef v87 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(Mutable, @"semantic", v87);
    CFRelease(v87);
  }
  return Mutable;
}

uint64_t _C3DKeyframeControllerFinalizeDeserialization()
{
  return 1;
}

MTLTexture *C3D::CreateSharedTexture(MTLTexture *a1, long long *a2, void *a3, void *a4)
{
  if (([(MTLTexture *)a1 isFramebufferOnly] & 1) != 0
    || [(MTLTexture *)a1 textureType] != 2
    || [(MTLTexture *)a1 sampleCount] != 1)
  {
    return 0;
  }
  long long v17 = *a2;
  int v18 = *((_DWORD *)a2 + 4);
  uint64_t v8 = SCNMTLTextureDescToMTLTextureDescriptor((unsigned __int16 *)&v17);
  int IsUnsignedInt = SCNMTLPixelFormatIsUnsignedInt([v8 pixelFormat]);
  objc_msgSend(v8, "setTextureType:", -[MTLTexture textureType](a1, "textureType"));
  [v8 setSampleCount:1];
  [v8 setPixelFormat:70];
  [v8 setStorageMode:0];
  uint64_t v10 = (MTLTexture *)[a4 newTextureWithDescriptor:v8];
  uint64_t v11 = @"copy_no_alpha_texture";
  if (IsUnsignedInt) {
    uint64_t v11 = @"copy_no_alpha_uint_texture";
  }
  if (*((_WORD *)a2 + 6) == 252) {
    uint64_t v12 = @"copy_no_alpha_depth_texture";
  }
  else {
    uint64_t v12 = v11;
  }
  uint64_t v13 = (void *)[a4 newComputePipelineStateWithFunctionName:v12];
  v16._encoder = 0;
  v16._bufferPool = 0;
  SCNMTLComputeCommandEncoder::beginEncoding(&v16, a3, 0, 0, 0);
  if (v16._textures[0] != v10)
  {
    v16._textures[0] = v10;
    v16._texturesToBind[0] |= 1uLL;
  }
  if (v16._textures[1] != a1)
  {
    v16._textures[1] = a1;
    v16._texturesToBind[0] |= 2uLL;
  }
  uint64_t v14 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator]((uint64_t)v13);
  SCNMTLComputeCommandEncoder::dispatchOnTexture2D(&v16, v10, v14);
  SCNMTLComputeCommandEncoder::endEncoding(&v16);

  return v10;
}

uint64_t C3D::SetupDefaultRenderPassDescriptor(C3D *this, __C3DEngineContext *a2, MTLRenderPassDescriptor *a3)
{
  char v3 = (char)a3;
  uint64_t RenderContext = (void *)C3DEngineContextGetRenderContext((uint64_t)this);
  for (uint64_t i = 0; i != 8; ++i)
  {
    objc_msgSend((id)objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", i), "setTexture:", 0);
    objc_msgSend((id)objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", i), "setResolveTexture:", 0);
  }
  objc_msgSend((id)-[__C3DEngineContext depthAttachment](a2, "depthAttachment"), "setTexture:", 0);
  objc_msgSend((id)-[__C3DEngineContext depthAttachment](a2, "depthAttachment"), "setResolveTexture:", 0);
  objc_msgSend((id)-[__C3DEngineContext stencilAttachment](a2, "stencilAttachment"), "setTexture:", 0);
  [(__C3DEngineContext *)a2 setRenderTargetArrayLength:0];
  objc_msgSend((id)objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", -[SCNMTLRenderContext _finalRenderTexture](RenderContext));
  uint64_t result = objc_msgSend((id)objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setStoreAction:", 1);
  if (v3)
  {
    objc_msgSend((id)objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 2);
    __n128 ViewBackgroundColor = C3DEngineContextGetViewBackgroundColor((uint64_t)this);
    double v10 = ViewBackgroundColor.n128_f32[0];
    double v11 = ViewBackgroundColor.n128_f32[1];
    double v12 = ViewBackgroundColor.n128_f32[2];
    double v13 = ViewBackgroundColor.n128_f32[3];
    uint64_t v14 = objc_msgSend((id)-[__C3DEngineContext colorAttachments](a2, "colorAttachments"), "objectAtIndexedSubscript:", 0);
    return objc_msgSend(v14, "setClearColor:", v10, v11, v12, v13);
  }
  return result;
}

void *C3D::RenderGraph::GraphNode::predecessorsAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(a4, a3);
  uint64_t v8 = *(unsigned int *)(a1 + 16);
  if (v8)
  {
    uint64_t v9 = *(int **)(a1 + 24);
    uint64_t v10 = 4 * v8;
    do
    {
      int v11 = *v9;
      if (a2 == BYTE2(v11)) {
        uint64_t result = C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(a4, &v11);
      }
      ++v9;
      v10 -= 4;
    }
    while (v10);
  }
  return result;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::Pass *a3, uint64_t a4, uint64_t a5)
{
  if (C3DMeshElementGetPrimitiveCount((uint64_t)a2) == -1) {
    C3D::RenderGraph::addDependency();
  }
  if (C3DMeshElementGetPrimitiveCount((uint64_t)a3) == -1) {
    C3D::RenderGraph::addDependency();
  }
  Primitiveunsigned int Count = C3DMeshElementGetPrimitiveCount((uint64_t)a2);
  unsigned int v11 = C3DMeshElementGetPrimitiveCount((uint64_t)a3);

  C3D::RenderGraph::addDependency(this, PrimitiveCount, v11, a4, a5);
}

void C3D::RenderGraph::removeDependency(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::Pass *a3)
{
  Primitiveunsigned int Count = C3DMeshElementGetPrimitiveCount((uint64_t)a2);
  unsigned __int16 v6 = C3DMeshElementGetPrimitiveCount((uint64_t)a3);
  uint64_t v7 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), PrimitiveCount);
  uint64_t v8 = *((void *)this + 3);
  int v9 = v6;
  uint64_t v10 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v8, v6);
  if (*(_DWORD *)(v10 + 40))
  {
    uint64_t v11 = v10;
    unsigned int v12 = 0;
    uint64_t v13 = v10 + 32;
    do
    {
      if ((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v13, v12) & 0x7FFF) == PrimitiveCount)
      {
        unsigned int v14 = *(_DWORD *)(v11 + 40) - 1;
        uint64_t v15 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v13, v12);
        SCNMTLComputeCommandEncoder v16 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v13, v14);
        int v17 = *v15;
        *uint64_t v15 = *v16;
        *SCNMTLComputeCommandEncoder v16 = v17;
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(v13, v14);
      }
      else
      {
        ++v12;
      }
    }
    while (v12 < *(_DWORD *)(v11 + 40));
  }
  if (*(_DWORD *)(v7 + 16))
  {
    unsigned int v18 = 0;
    do
    {
      if ((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v7 + 8, v18) & 0x7FFF) == v9)
      {
        unsigned int v19 = *(_DWORD *)(v7 + 16) - 1;
        BOOL v20 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v7 + 8, v18);
        CFNumberRef v21 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v7 + 8, v19);
        int v22 = *v20;
        *BOOL v20 = *v21;
        *CFNumberRef v21 = v22;
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(v7 + 8, v19);
      }
      else
      {
        ++v18;
      }
    }
    while (v18 < *(_DWORD *)(v7 + 16));
  }
}

void C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      uint64_t v5 = *(char **)(a1 + 16);
      if (*(_DWORD *)(a1 + 12) < a2)
      {
        unsigned int v6 = ((double)a2 * 1.5);
        Aligned = (char *)C3DScratchAllocatorAllocateAligned(*(void *)a1, 4 * v6, 4, 0);
        memcpy(Aligned, v5, 4 * *(unsigned int *)(a1 + 8));
        *(void *)(a1 + 16) = Aligned;
        *(_DWORD *)(a1 + 12) = v6;
        uint64_t v5 = Aligned;
        unsigned int v2 = *(_DWORD *)(a1 + 8);
      }
      bzero(&v5[4 * v2], 4 * (a2 - v2));
    }
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = a2;
  }
}

void C3D::RenderGraph::setCustomTechnique(C3D::RenderGraph *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 24);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 24) = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *((void *)this + 24) = v5;
    *((unsigned char *)this + 20_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    unsigned int v6 = (const void *)*((void *)this + 25);
    if (v6)
    {
      CFRelease(v6);
      *((void *)this + 25) = 0;
    }
  }
}

void ___ZN3C3D11RenderGraph14finalTechniqueEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Technique = C3DLightGetTechnique(a2);
  if (Technique)
  {
    uint64_t v4 = (const void *)Technique;
    CFTypeRef v5 = *(__CFArray **)(a1 + 32);
    CFArrayAppendValue(v5, v4);
  }
}

uint64_t C3D::__nextPassInStage(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned __int16 *)(a2 + 8) - 1 == a3)
  {
    uint64_t result = *(void *)(a2 + 24);
    if (!result) {
      return result;
    }
    unsigned int v5 = 0;
  }
  else
  {
    uint64_t result = a2;
    unsigned int v5 = a3 + 1;
  }
  unsigned int v6 = *(unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](result, v5);
  if (v6 == 0xFFFF) {
    return 0;
  }
  else {
    return *(void *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1, v6);
  }
}

uint64_t SCNMTLRenderCommandEncoder::setVertexAmplificationCount(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (*(unsigned __int8 *)(result + 72) == a2) {
    return result;
  }
  uint64_t v4 = result;
  *(unsigned char *)(result + 72) = a2;
  if (a2 > 1)
  {
    if (a3 == 2)
    {
      long long v6 = xmmword_20B5CC140;
    }
    else
    {
      if (a3 != 1)
      {
        uint64_t v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          SCNMTLRenderCommandEncoder::setVertexAmplificationCount();
        }
        return [*(id *)(v4 + 3392) setVertexAmplificationCount:a2 viewMappings:&v8];
      }
      long long v6 = xmmword_20B5CC150;
    }
    long long v8 = v6;
    return [*(id *)(v4 + 3392) setVertexAmplificationCount:a2 viewMappings:&v8];
  }
  unsigned int v5 = *(void **)(result + 3392);

  return [v5 setVertexAmplificationCount:1 viewMappings:0];
}

double SCNMTLRenderCommandEncoder::useCommandEncoder(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2 && (long long v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    SCNMTLRenderCommandEncoder::useCommandEncoder(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  SCNMTLComputeCommandEncoder v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    SCNMTLRenderCommandEncoder::useCommandEncoder(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  bzero(a1, 0xD70uLL);
  *((_DWORD *)a1 + 16) = 1;
  a1[72] = 1;
  *((_WORD *)a1 + 20) = 257;
  a1[42] = 1;
  double result = 0.0;
  *(_OWORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *((void *)a1 + 423) = a2;
  *((void *)a1 + 424) = a3;
  *((void *)a1 + 425) = a4;
  return result;
}

id C3D::RenderGraph::graphDescription(C3D::RenderGraph *this)
{
  unint64_t v2 = 0x263EFF000uLL;
  id v3 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  uint64_t v46 = this;
  uint64_t v4 = *((void *)this + 12);
  id v5 = objc_alloc_init(MEMORY[0x263EFF980]);
  id v43 = v3;
  [v3 setValue:v5 forKey:@"stages"];
  uint64_t v44 = v5;

  if (v4)
  {
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    do
    {
      uint64_t v6 = *(unsigned int *)(v4 + 8);
      uint64_t v7 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:v6];
      [v44 addObject:v7];
      CFArrayRef v48 = v7;

      int v49 = v6;
      if (v6)
      {
        unsigned int v8 = 0;
        uint64_t v47 = v4;
        do
        {
          unsigned int v51 = v8;
          uint64_t v9 = *(unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v4, v8);
          uint64_t v50 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)v46 + 3), v9);
          uint64_t v10 = *(C3D::Pass **)v50;
          id v11 = objc_alloc_init(*(Class *)(v2 + 2464));
          uint64_t v12 = (const char *)(**(uint64_t (***)(C3D::Pass *))v10)(v10);
          CFStringRef v13 = CFStringCreateWithCString(alloc, v12, 0x8000100u);
          [v11 setValue:v13 forKey:@"name"];
          CFRelease(v13);
          objc_msgSend(v11, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", v9), @"id");
          objc_msgSend(v11, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", 0), @"type");
          objc_msgSend(v11, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithBool:", 1), @"enabled");
          uint64_t v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
          unsigned int v15 = C3D::PassDescriptor::inputCount(v14);
          SCNMTLComputeCommandEncoder v16 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:v15];
          uint64_t v52 = v11;
          [v11 setValue:v16 forKey:@"inputs"];

          if (v15)
          {
            for (uint64_t i = 0; i != v15; ++i)
            {
              id v18 = objc_alloc_init(*(Class *)(v2 + 2464));
              [v18 setValue:objc_msgSend(NSString, "stringWithFormat:", @"%d-i-%d", C3DMeshElementGetPrimitiveCount((uint64_t)v10), i), @"id" forKey];
              uint64_t v19 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
              uint64_t v20 = *(void *)(C3D::PassDescriptor::inputAtIndex(v19, i) + 8);
              if (v20) {
                [v18 setValue:objc_msgSend(NSString, "stringWithFormat:", @"%s", v20), @"name" forKey];
              }
              uint64_t v21 = NSNumber;
              uint64_t v22 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
              objc_msgSend(v18, "setValue:forKey:", objc_msgSend(v21, "numberWithInteger:", *(unsigned __int8 *)C3D::PassDescriptor::inputAtIndex(v22, i)), @"type");
              [v16 addObject:v18];
            }
          }
          uint64_t v23 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
          unsigned int v24 = C3D::PassDescriptor::outputCount(v23);
          float v25 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:v24];
          [v52 setValue:v25 forKey:@"outputs"];

          if (v24)
          {
            for (uint64_t j = 0; j != v24; ++j)
            {
              id v27 = objc_alloc_init(*(Class *)(v2 + 2464));
              [v27 setValue:objc_msgSend(NSString, "stringWithFormat:", @"%d-o-%d", C3DMeshElementGetPrimitiveCount((uint64_t)v10), j), @"id" forKey];
              CFDataRef v28 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
              uint64_t v29 = *(void *)(C3D::PassDescriptor::outputAtIndex(v28, j) + 8);
              if (v29) {
                [v27 setValue:objc_msgSend(NSString, "stringWithFormat:", @"%s", v29), @"name" forKey];
              }
              CFNumberRef v30 = NSNumber;
              CFNumberRef v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
              objc_msgSend(v27, "setValue:forKey:", objc_msgSend(v30, "numberWithInteger:", *(unsigned __int8 *)C3D::PassDescriptor::outputAtIndex(v31, j)), @"type");
              [v25 addObject:v27];
            }
          }
          uint64_t v32 = *(unsigned int *)(v50 + 40);
          int v33 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:v32];
          [v52 setValue:v33 forKey:@"links"];

          unint64_t v34 = 0x263EFF000uLL;
          if (v32)
          {
            uint64_t v35 = 0;
            uint64_t v36 = v50 + 32;
            do
            {
              float v37 = *(void **)(v34 + 2240);
              uint64_t v38 = objc_msgSend(NSNumber, "numberWithInt:", *(unsigned __int8 *)(C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v36, v35)+ 2));
              uint64_t v39 = objc_msgSend(NSNumber, "numberWithInt:", *(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v36, v35) & 0x7FFF);
              uint64_t v42 = objc_msgSend(NSNumber, "numberWithInt:", *(unsigned __int8 *)(C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v36, v35)+ 3));
              uint64_t v40 = v37;
              unint64_t v34 = 0x263EFF000;
              objc_msgSend(v33, "addObject:", objc_msgSend(v40, "arrayWithObjects:", v38, v39, v42, 0));
              ++v35;
            }
            while (v32 != v35);
          }
          [v48 addObject:v52];
          unsigned int v8 = v51 + 1;
          unint64_t v2 = 0x263EFF000;
          uint64_t v4 = v47;
        }
        while (v51 + 1 != v49);
      }
      uint64_t v4 = *(void *)(v4 + 24);
    }
    while (v4);
  }
  return v43;
}

void C3D::RenderGraph::logFrame(C3D::RenderGraph *this)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  unint64_t v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    LOWORD(v86[0]) = 0;
    _os_log_impl(&dword_20B249000, v2, OS_LOG_TYPE_INFO, "Info: ###########################################################################################################", (uint8_t *)v86, 2u);
  }
  id v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    LOWORD(v86[0]) = 0;
    _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_INFO, "Info: ################################################ NEW FRAME ################################################", (uint8_t *)v86, 2u);
  }
  uint64_t v4 = scn_default_log();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    LOWORD(v86[0]) = 0;
    _os_log_impl(&dword_20B249000, v4, OS_LOG_TYPE_INFO, "Info: ###########################################################################################################\n", (uint8_t *)v86, 2u);
  }
  uint64_t v6 = *((void *)this + 12);
  if (v6)
  {
    int v7 = 0;
    *(void *)&long long v5 = 67109120;
    long long v78 = v5;
    *(void *)&long long v5 = 136315138;
    long long v79 = v5;
    *(void *)&long long v5 = 136315394;
    long long v83 = v5;
    do
    {
      int v81 = *(unsigned __int16 *)(v6 + 8);
      unsigned int v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        v86[0] = v78;
        v86[1] = (unsigned __int16)v7;
        _os_log_impl(&dword_20B249000, v8, OS_LOG_TYPE_INFO, "Info: ######################################## STAGE %d ########################################", (uint8_t *)v86, 8u);
      }
      int v77 = v7;
      if (v81)
      {
        unsigned int v9 = 0;
        uint64_t v80 = v6;
        do
        {
          unsigned int v82 = v9;
          uint64_t v10 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v6, v9);
          uint64_t v11 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((void *)this + 3), *v10);
          uint64_t v12 = *(C3D::Pass **)v11;
          CFStringRef v13 = scn_default_log();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
          {
            LOWORD(v86[0]) = 0;
            _os_log_impl(&dword_20B249000, v13, OS_LOG_TYPE_INFO, "Info: ", (uint8_t *)v86, 2u);
          }
          uint64_t v14 = scn_default_log();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            uint64_t v15 = (**(uint64_t (***)(C3D::Pass *))v12)(v12);
            v86[0] = v79;
            *(void *)&v86[1] = v15;
            _os_log_impl(&dword_20B249000, v14, OS_LOG_TYPE_INFO, "Info: |---------------------------  %s ---------------------------", (uint8_t *)v86, 0xCu);
          }
          SCNMTLComputeCommandEncoder v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
          int v17 = C3D::PassDescriptor::inputCount(v16);
          CFDataRef v85 = v12;
          if (v17)
          {
            int v18 = v17;
            uint64_t v19 = scn_default_log();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
            {
              v86[0] = v78;
              v86[1] = v18;
              _os_log_impl(&dword_20B249000, v19, OS_LOG_TYPE_INFO, "Info: |---- %d INPUTS ---- \n", (uint8_t *)v86, 8u);
            }
            for (int i = 0; i != v18; ++i)
            {
              if (*(_DWORD *)(v11 + 16))
              {
                unsigned int v21 = 0;
                int v22 = 0;
                while (*(unsigned __int8 *)(C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 8, v21)+ 2) != i)
                {
                  unsigned int v21 = (unsigned __int16)++v22;
                  if (*(_DWORD *)(v11 + 16) <= (unsigned __int16)v22) {
                    goto LABEL_27;
                  }
                }
                uint64_t v23 = *((void *)this + 3);
                unsigned int v24 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 8, v21);
                float v25 = **(uint64_t (****)(void))C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v23, *v24 & 0x7FFF);
                CFNumberRef v26 = (const char *)(*v25)();
                uint64_t v27 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 8, v21);
                uint64_t v28 = *((void *)this + 3);
                int v29 = *(unsigned __int8 *)(v27 + 3);
                CFNumberRef v30 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 8, v21);
                CFNumberRef v31 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v28, *v30 & 0x7FFF);
                uint64_t v32 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v31);
                uint64_t v33 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 8, v21);
                uint64_t v34 = C3D::PassDescriptor::outputAtIndex(v32, *(unsigned __int8 *)(v33 + 3));
                uint64_t v12 = v85;
                snprintf((char *)v86, 0x200uLL, "linked to : %s slot %d (%s)", v26, v29, *(const char **)(v34 + 8));
              }
LABEL_27:
              uint64_t v35 = scn_default_log();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
              {
                uint64_t v36 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
                uint64_t v37 = *(void *)(C3D::PassDescriptor::inputAtIndex(v36, (unsigned __int16)i) + 8);
                *(_DWORD *)uint8_t buf = v83;
                uint64_t v88 = v37;
                __int16 v89 = 2080;
                uint64_t v90 = v86;
                _os_log_impl(&dword_20B249000, v35, OS_LOG_TYPE_INFO, "Info: |-> %s(%s)", buf, 0x16u);
              }
              uint64_t v38 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
              uint64_t v39 = (C3D::RenderGraph *)C3D::PassDescriptor::inputAtIndex(v38, (unsigned __int16)i);
              C3D::RenderGraph::logPassIODescriptor(v39, v39, "  ");
            }
            uint64_t v40 = scn_default_log();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
            {
              LOWORD(v86[0]) = 0;
              _os_log_impl(&dword_20B249000, v40, OS_LOG_TYPE_INFO, "Info: |", (uint8_t *)v86, 2u);
            }
          }
          uint64_t v41 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
          int v84 = C3D::PassDescriptor::outputCount(v41);
          if (v84)
          {
            uint64_t v42 = scn_default_log();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
            {
              v86[0] = v78;
              v86[1] = v84;
              _os_log_impl(&dword_20B249000, v42, OS_LOG_TYPE_INFO, "Info: |---- %d OUTPUTS ---- \n", (uint8_t *)v86, 8u);
            }
            int v43 = 0;
            do
            {
              strcpy((char *)v86, "linked to : ");
              if (*(_DWORD *)(v11 + 40))
              {
                unsigned int v44 = 0;
                int v45 = 0;
                do
                {
                  if (*(unsigned __int8 *)(C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 32, v44)+ 2) == v43)
                  {
                    uint64_t v46 = *((void *)this + 3);
                    uint64_t v47 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 32, v44);
                    CFArrayRef v48 = **(uint64_t (****)(void))C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v46, *v47 & 0x7FFF);
                    int v49 = (const char *)(*v48)();
                    uint64_t v50 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 32, v44);
                    uint64_t v51 = *((void *)this + 3);
                    int v52 = *(unsigned __int8 *)(v50 + 3);
                    uint64_t v53 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 32, v44);
                    CFTypeID v54 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v51, *v53 & 0x7FFF);
                    CFBooleanRef v55 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v54);
                    uint64_t v56 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v11 + 32, v44);
                    uint64_t v57 = C3D::PassDescriptor::inputAtIndex(v55, *(unsigned __int8 *)(v56 + 3));
                    snprintf((char *)v86, 0x800uLL, "%s %s slot %d (%s)", (const char *)v86, v49, v52, *(const char **)(v57 + 8));
                  }
                  unsigned int v44 = (unsigned __int16)++v45;
                }
                while (*(_DWORD *)(v11 + 40) > (unsigned __int16)v45);
              }
              CFTypeID v58 = scn_default_log();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
              {
                uint64_t v12 = v85;
                uint64_t v59 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v85);
                uint64_t v60 = *(void *)(C3D::PassDescriptor::outputAtIndex(v59, (unsigned __int16)v43) + 8);
                *(_DWORD *)uint8_t buf = v83;
                uint64_t v88 = v60;
                __int16 v89 = 2080;
                uint64_t v90 = v86;
                _os_log_impl(&dword_20B249000, v58, OS_LOG_TYPE_INFO, "Info: |-> %s(%s)", buf, 0x16u);
              }
              else
              {
                uint64_t v12 = v85;
              }
              CFNumberType v61 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v12);
              CFTypeID v62 = (C3D::RenderGraph *)C3D::PassDescriptor::outputAtIndex(v61, (unsigned __int16)v43);
              C3D::RenderGraph::logPassIODescriptor(v62, v62, "  ");
              ++v43;
            }
            while (v43 != v84);
          }
          CFArrayRef v63 = (const char *)(**(uint64_t (***)(C3D::Pass *))v12)(v12);
          size_t v64 = strlen(v63);
          unsigned __int16 v65 = v64;
          MEMORY[0x270FA5388](v64);
          long long v67 = &v76[-v66];
          if (v68) {
            memset(&v76[-v66], 45, v65);
          }
          v67[v65] = 0;
          long long v69 = scn_default_log();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
          {
            v86[0] = v79;
            *(void *)&v86[1] = v67;
            _os_log_impl(&dword_20B249000, v69, OS_LOG_TYPE_INFO, "Info: |----------------------------%s----------------------------", (uint8_t *)v86, 0xCu);
          }
          CFArrayRef v70 = scn_default_log();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
          {
            LOWORD(v86[0]) = 0;
            _os_log_impl(&dword_20B249000, v70, OS_LOG_TYPE_INFO, "Info: ", (uint8_t *)v86, 2u);
          }
          unsigned int v9 = v82 + 1;
          uint64_t v6 = v80;
        }
        while (v82 + 1 != v81);
      }
      uint64_t v6 = *(void *)(v6 + 24);
      CFDataRef v71 = scn_default_log();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
      {
        LOWORD(v86[0]) = 0;
        _os_log_impl(&dword_20B249000, v71, OS_LOG_TYPE_INFO, "Info: ", (uint8_t *)v86, 2u);
      }
      long long v72 = scn_default_log();
      BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_INFO);
      int v74 = v77;
      if (v73)
      {
        LOWORD(v86[0]) = 0;
        _os_log_impl(&dword_20B249000, v72, OS_LOG_TYPE_INFO, "Info: ", (uint8_t *)v86, 2u);
      }
      int v7 = v74 + 1;
    }
    while (v6);
  }
  long long v75 = scn_default_log();
  if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
  {
    LOWORD(v86[0]) = 0;
    _os_log_impl(&dword_20B249000, v75, OS_LOG_TYPE_INFO, "Info: \n\n\n", (uint8_t *)v86, 2u);
  }
}

uint64_t ___ZN3C3D11RenderGraph7executeEv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    unint64_t v2 = *(void **)(v1 + 8);
    if (v2 != (void *)(v1 + 16)) {
      free(v2);
    }
    JUMPOUT(0x210534FE0);
  }
  return result;
}

uint64_t C3D::RenderGraph::getPredecessors@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array((void *)a4, a3);
  Primitiveunsigned int Count = C3DMeshElementGetPrimitiveCount(a2);
  uint64_t result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), PrimitiveCount);
  uint64_t v9 = *(unsigned int *)(result + 16);
  if (v9)
  {
    uint64_t v10 = *(_DWORD **)(result + 24);
    uint64_t v11 = &v10[v9];
    do
    {
      uint64_t result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *v10 & 0x7FFF);
      uint64_t v12 = *(void *)(a4 + 16);
      uint64_t v13 = *(unsigned int *)(a4 + 8);
      if (v13)
      {
        uint64_t v14 = 8 * v13;
        uint64_t v15 = *(void **)(a4 + 16);
        while (*v15 != *(void *)result)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            uint64_t v15 = (void *)(v12 + 8 * v13);
            break;
          }
        }
      }
      else
      {
        uint64_t v15 = *(void **)(a4 + 16);
      }
      if (v13 == ((uint64_t)v15 - v12) >> 3) {
        uint64_t result = (uint64_t)C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>((_DWORD *)a4, (void *)result);
      }
      ++v10;
    }
    while (v10 != v11);
  }
  return result;
}

uint64_t C3D::RenderGraph::getTextureNamed(C3D::RenderGraph *this, const char *__s)
{
  if (!__s) {
    return 0;
  }
  unint64_t v2 = __s;
  uint64_t v3 = *((void *)this + 17);
  unsigned int v4 = strlen(__s);
  unint64_t v5 = 0xC6A4A7935BD1E995 * v4;
  if (v4 >= 8)
  {
    uint64_t v6 = v4 >> 3;
    int v7 = &v2[8 * v6];
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *(void *)v2;
      v2 += 8;
      unint64_t v5 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v9) ^ ((0xC6A4A7935BD1E995 * v9) >> 47))) ^ v5);
      v8 -= 8;
    }
    while (v8);
    unint64_t v2 = v7;
  }
  switch(v4 & 7)
  {
    case 1u:
      goto LABEL_13;
    case 2u:
      goto LABEL_12;
    case 3u:
      goto LABEL_11;
    case 4u:
      goto LABEL_10;
    case 5u:
      goto LABEL_9;
    case 6u:
      goto LABEL_8;
    case 7u:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 6) << 48;
LABEL_8:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 5) << 40;
LABEL_9:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 4) << 32;
LABEL_10:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 3) << 24;
LABEL_11:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 2) << 16;
LABEL_12:
      v5 ^= (unint64_t)*((unsigned __int8 *)v2 + 1) << 8;
LABEL_13:
      unint64_t v5 = 0xC6A4A7935BD1E995 * (v5 ^ *(unsigned __int8 *)v2);
      break;
    default:
      break;
  }
  unint64_t v10 = (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
  unsigned int v11 = (*(_DWORD *)(v3 + 36) - 1) & v10;
  unsigned int v12 = *(unsigned __int16 *)(*(void *)(v3 + 24) + 2 * v11);
  if (v12 < 2) {
    return 0;
  }
  while ((v12 & 2) == 0 || v10 != *(void *)(*(void *)(v3 + 8) + 8 * v11))
  {
    ++v11;
    BOOL v13 = v12 >= 4;
    v12 >>= 1;
    if (!v13) {
      return 0;
    }
  }
  uint64_t v15 = *(void *)(v3 + 16);
  if (v15) {
    return *(void *)(v15 + 8 * v11);
  }
  else {
    return 0;
  }
}

void *C3D::RenderGraph::requestFrameRecording(void *result, void *a2, void *a3)
{
  if (!result[21])
  {
    unsigned int v4 = result;
    result[21] = [a3 copy];
    uint64_t result = (void *)v4[22];
    if (result != a2)
    {
      if (result)
      {
        CFRelease(result);
        v4[22] = 0;
      }
      if (a2) {
        uint64_t result = CFRetain(a2);
      }
      else {
        uint64_t result = 0;
      }
      v4[22] = result;
    }
  }
  return result;
}

uint64_t C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      uint64_t v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          *(void *)(v26 + 8 * v15) = *(void *)(v26 + 8 * v21);
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      *(void *)(*(void *)(a1 + 16) + 8 * v21) = *a3;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v28 = *(void *)(a1 + 24);
      *(_WORD *)(v28 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v28 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 8 * v10) = *a3;
  return result;
}

_DWORD *C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::push_back<C3D::Pass *&>(_DWORD *result, void *a2)
{
  uint64_t v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  unsigned int v6 = v4 + 1;
  uint64_t v7 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v8 = ((double)(v5 + 1) * 1.5);
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(void *)result, 8 * v8, 8, 0);
    uint64_t result = memcpy(Aligned, v7, 8 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v8;
    unsigned int v4 = v3[2];
    unsigned int v6 = v4 + 1;
    uint64_t v7 = Aligned;
  }
  *((void *)v7 + v4) = *a2;
  v3[2] = v6;
  return result;
}

_DWORD *C3D::Array<unsigned char,16u,C3D::StackAllocator>::push_back<unsigned char>(_DWORD *result, unsigned char *a2)
{
  uint64_t v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  unsigned int v6 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v7 = ((double)(v5 + 1) * 1.5);
    Aligned = C3DStackAllocatorAllocateAligned(*(void *)result, v7, 1, 0);
    uint64_t result = memcpy(Aligned, v6, v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v7;
    unsigned int v6 = Aligned;
    unsigned int v4 = v3[2];
  }
  *((unsigned char *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

uint64_t C3D::RenderGraph::propagateReadWriteResources(uint64_t a1, C3D::Pass **a2, unsigned int a3, unsigned __int8 a4, C3D::RefCountedResource *a5)
{
  unsigned int v9 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), a3);
  uint64_t result = C3DEngineContextGetStackAllocator(*(void *)(a1 + 8));
  if (v9 != a2)
  {
    uint64_t v11 = result;
    do
    {
      uint64_t result = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v9 + 32), a4);
      if ((*(_WORD *)(result + 66) & 0x80) == 0) {
        break;
      }
      unsigned int v12 = (C3D::PassResource *)C3D::Pass::resource(*v9);
      C3D::PassResource::setInputAtIndex(v12, a5, a4);
      ++*((unsigned char *)a5 + 33);
      C3D::RenderGraph::GraphNode::successorsAtIndex((uint64_t)v9, a4, v11, v14);
      a4 = *(unsigned char *)(C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v14, 0) + 3);
      unsigned int v13 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v14, 0);
      uint64_t result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *v13 & 0x7FFF);
      unsigned int v9 = (C3D::Pass **)result;
    }
    while ((C3D::Pass **)result != a2);
  }
  return result;
}

double C3D::RenderGraph::clearDrawable(C3D::RenderGraph *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 1));
  if (-[SCNMTLRenderContext layerTarget](RenderContext))
  {
    C3D::SetupDefaultRenderPassDescriptor(*((C3D **)this + 1), *((__C3DEngineContext **)this + 19), (MTLRenderPassDescriptor *)1);
    unsigned int v4 = (void *)-[SCNMTLRenderContext currentCommandBuffer](RenderContext);
    uint64_t v5 = -[SCNMTLRenderContext frameConstantBufferPool](RenderContext);
    uint64_t v6 = *((void *)this + 19);
    bzero(&v7, 0xD70uLL);
    LODWORD(v7.var14[0].var1) = 1;
    LOBYTE(v7.var14[1].var0) = 1;
    v7.var24[0] = (unint64_t)v4;
    v7.var24[1] = [v4 renderCommandEncoderWithDescriptor:v6];
    v7.var25[0] = v5;
    [(id)v7.var24[1] setLabel:@"Clear drawable"];
    memset(&v7.var1, 0, 32);
    return SCNMTLRenderCommandEncoder::endEncoding(&v7);
  }
  return result;
}

void C3D::RenderGraph::spriteKitTransitionBegin(C3D::RenderGraph *this, MTLRenderPassDescriptor *a2)
{
  C3D::SetupDefaultRenderPassDescriptor(*((C3D **)this + 1), *((__C3DEngineContext **)this + 19), a2);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 1));
  -[SCNMTLRenderContext currentCommandBuffer](RenderContext);
  -[SCNMTLRenderContext frameConstantBufferPool](RenderContext);
  operator new();
}

void C3D::RenderGraph::spriteKitTransitionEnd(C3D::RenderGraph *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 1));
  unint64_t v2 = (SCNMTLRenderCommandEncoder *)-[SCNMTLRenderContext renderEncoder](RenderContext);
  if (v2)
  {
    SCNMTLRenderCommandEncoder::endEncoding(v2);
    -[SCNMTLRenderContext endRenderPass](RenderContext);
    JUMPOUT(0x210534FE0);
  }
  uint64_t v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
    C3D::RenderGraph::spriteKitTransitionEnd(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  SCNMTLRenderCommandEncoder::endEncoding(0);
  -[SCNMTLRenderContext endRenderPass](RenderContext);
}

void C3D::RenderGraph::logDependencyInputMismatch(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(a1 + 8));
  if (a4 == 255 && a5 != 255)
  {
    uint64_t v9 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a3 + 32), a5);
    C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(buf, StackAllocator);
    uint64_t v10 = *(unsigned int *)(a2 + 16);
    if (v10)
    {
      uint64_t v11 = *(_DWORD **)(a2 + 24);
      uint64_t v12 = 4 * v10;
      do
      {
        if ((~*v11 & 0xFF0000) != 0)
        {
          char v73 = BYTE2(*v11);
          C3D::Array<unsigned char,16u,C3D::StackAllocator>::push_back<unsigned char>(buf, &v73);
        }
        ++v11;
        v12 -= 4;
      }
      while (v12);
    }
    LOBYTE(a4) = 0;
    while (C3D::PassDescriptor::inputCount((C3D::PassDescriptor *)(*(void *)a2 + 32)) > a4)
    {
      int v13 = *(unsigned __int8 *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)a2 + 32), a4)+ 64);
      int v14 = *(unsigned __int8 *)(v9 + 64);
      uint64_t v15 = *(void *)&__n_6[2];
      __int16 v16 = (char *)HIDWORD(v75);
      unsigned int v17 = (char *)(*(void *)&__n_6[2] + HIDWORD(v75));
      unsigned int v18 = (char *)memchr(*(void **)&__n_6[2], (char)a4, HIDWORD(v75));
      if (v18) {
        unsigned int v19 = v18;
      }
      else {
        unsigned int v19 = v17;
      }
      char v20 = &v19[-v15];
      if (v13 == v14 && v20 == v16) {
        goto LABEL_19;
      }
      LOBYTE(a4) = a4 + 1;
    }
    LOBYTE(a4) = -1;
  }
LABEL_19:
  int v22 = a4;
  if (a5 == 255 && (_BYTE)a4 != 0xFF)
  {
    uint64_t v23 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)a2 + 32), a4);
    C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(buf, StackAllocator);
    uint64_t v24 = *(unsigned int *)(a3 + 40);
    if (v24)
    {
      unsigned int v25 = *(_DWORD **)(a3 + 48);
      uint64_t v26 = 4 * v24;
      do
      {
        if ((~*v25 & 0xFF0000) != 0)
        {
          char v73 = BYTE2(*v25);
          C3D::Array<unsigned char,16u,C3D::StackAllocator>::push_back<unsigned char>(buf, &v73);
        }
        ++v25;
        v26 -= 4;
      }
      while (v26);
    }
    LOBYTE(a5) = 0;
    while (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(void *)a3 + 32)) > a5)
    {
      int v27 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a3 + 32), a5)+ 64);
      int v28 = *(unsigned __int8 *)(v23 + 64);
      uint64_t v29 = *(void *)&__n_6[2];
      CFNumberRef v30 = (char *)HIDWORD(v75);
      CFNumberRef v31 = (char *)(*(void *)&__n_6[2] + HIDWORD(v75));
      uint64_t v32 = (char *)memchr(*(void **)&__n_6[2], (char)a5, HIDWORD(v75));
      if (v32) {
        uint64_t v33 = v32;
      }
      else {
        uint64_t v33 = v31;
      }
      uint64_t v34 = &v33[-v29];
      if (v27 == v28 && v34 == v30) {
        goto LABEL_37;
      }
      LOBYTE(a5) = a5 + 1;
    }
    LOBYTE(a5) = -1;
  }
LABEL_37:
  if (v22 != 255 && (_BYTE)a5 != 0xFF)
  {
    uint64_t v36 = (unsigned __int8 *)C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(void *)a2 + 32), v22);
    int v37 = a5;
    uint64_t v38 = (unsigned __int8 *)C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(void *)a3 + 32), a5);
    if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v38, (const PassIODescriptor *)v36))
    {
      if ((C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
      {
        C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
        uint64_t v39 = scn_default_log();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          uint64_t v68 = (***(uint64_t (****)(void))a3)();
          if (*((void *)v38 + 1)) {
            long long v69 = (const char *)*((void *)v38 + 1);
          }
          else {
            long long v69 = "";
          }
          uint64_t v70 = (***(uint64_t (****)(void))a2)();
          CFDataRef v71 = (const char *)*((void *)v36 + 1);
          if (!v71) {
            CFDataRef v71 = "";
          }
          *(_DWORD *)uint8_t buf = 136316418;
          uint64_t v75 = v68;
          __int16 __n_4 = 1024;
          *(_DWORD *)__n_6 = v37;
          *(_WORD *)&__n_6[4] = 2080;
          *(void *)&__n_6[6] = v69;
          __int16 v78 = 2080;
          uint64_t v79 = v70;
          __int16 v80 = 1024;
          int v81 = v22;
          __int16 v82 = 2080;
          long long v83 = v71;
          _os_log_error_impl(&dword_20B249000, v39, OS_LOG_TYPE_ERROR, "Error: Dependency issue between source %s[%d]:%s and destination %s[%d]:%s", buf, 0x36u);
        }
      }
      int v40 = *v36;
      if (v40 != *v38
        && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
      {
        C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
        uint64_t v41 = scn_default_log();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          C3D::RenderGraph::logDependencyInputMismatch();
        }
        int v40 = *v36;
      }
      if (v40 == 1)
      {
        int v42 = *((unsigned __int16 *)v38 + 8);
        int v43 = *((unsigned __int16 *)v36 + 8);
        if (v42 != v43
          && (v43 + v42) >= 2
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          unsigned int v44 = scn_default_log();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        int v45 = *((unsigned __int16 *)v38 + 9);
        int v46 = *((unsigned __int16 *)v36 + 9);
        if (v45 != v46
          && (v46 + v45) >= 2
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          uint64_t v47 = scn_default_log();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        int v48 = *((unsigned __int16 *)v38 + 10);
        int v49 = *((unsigned __int16 *)v36 + 10);
        if (v48 != v49
          && (v49 + v48) >= 2
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          uint64_t v50 = scn_default_log();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        uint64_t v51 = v38[24];
        uint64_t v52 = v36[24];
        if (SCNMTLTextureTypeIsMultisampled(v51))
        {
          uint64_t v53 = SCNMTLTextureTypeNonMultisampledEquivalent(v51);
          if (v53 != SCNMTLTextureTypeNonMultisampledEquivalent(v52)
            && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
          {
            C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
            CFTypeID v54 = scn_default_log();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
              C3D::RenderGraph::logDependencyInputMismatch();
            }
          }
        }
        else if (v51 != v52 {
               && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        }
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          CFBooleanRef v55 = scn_default_log();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        if (v38[25] != v36[25]
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          uint64_t v56 = scn_default_log();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        if (v38[27] != v36[27]
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          uint64_t v57 = scn_default_log();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        if (*((unsigned __int16 *)v38 + 14) != *((unsigned __int16 *)v36 + 14)
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          CFTypeID v58 = scn_default_log();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
        int v59 = v38[30];
        int v60 = v36[30];
        if (v59 != v60
          && (v60 + v59) >= 2
          && (C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done & 1) == 0)
        {
          C3D::RenderGraph::logDependencyInputMismatch(C3D::RenderGraph::GraphNode const&,C3D::RenderGraph::GraphNode const&,unsigned char,unsigned char)::done = 1;
          CFNumberType v61 = scn_default_log();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch();
          }
        }
      }
      if (*v36 == 2)
      {
        uint64_t v64 = *((void *)v38 + 2);
        CFArrayRef v63 = (uint64_t *)(v38 + 16);
        uint64_t v62 = v64;
        uint64_t v66 = *((void *)v36 + 2);
        unsigned __int16 v65 = (uint64_t *)(v36 + 16);
        if (v62 != v66
          && (_ZZN3C3D11RenderGraph26logDependencyInputMismatchERKNS0_9GraphNodeES3_hhE4done__10_ & 1) == 0)
        {
          _ZZN3C3D11RenderGraph26logDependencyInputMismatchERKNS0_9GraphNodeES3_hhE4done__10_ = 1;
          long long v67 = scn_default_log();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
            C3D::RenderGraph::logDependencyInputMismatch(v63, v65, v67);
          }
        }
      }
    }
  }
}

uint64_t C3D::RenderGraph::getCurrentFrameCachedPass(C3D::RenderGraph *this, uint64_t a2)
{
  unsigned int v2 = (*((_DWORD *)this + 23) - 1) & a2;
  unsigned int v3 = *(unsigned __int16 *)(*((void *)this + 10) + 2 * v2);
  if (v3 < 2) {
    return 0;
  }
  while ((v3 & 2) == 0 || *(void *)(*((void *)this + 8) + 8 * v2) != a2)
  {
    ++v2;
    BOOL v4 = v3 >= 4;
    v3 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  uint64_t v6 = *((void *)this + 9);
  if (v6) {
    return *(void *)(v6 + 8 * v2);
  }
  else {
    return 0;
  }
}

uint64_t C3D::RenderGraph::cachePassForCurrentFrame(C3D::RenderGraph *this, uint64_t a2, C3D::Pass *a3)
{
  BOOL v4 = a3;
  return C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::insert((uint64_t)this + 56, a2, &v4);
}

C3D::Pass *C3D::RenderGraph::search(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2 || !*(_DWORD *)(v2 + 8)) {
    return 0;
  }
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(a1 + 8));
  C3DStackAllocatorPushFrame(StackAllocator);
  if (*(_DWORD *)(a2 + 40)) {
    int v6 = 1;
  }
  else {
    int v6 = 2;
  }
  C3D::RenderGraph::clearAllDirtyBits(a1, v6);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v37, StackAllocator);
  uint64_t v7 = *(void *)(a2 + 32);
  if (v7) {
    Primitiveunsigned int Count = C3DMeshElementGetPrimitiveCount(v7);
  }
  else {
    Primitiveunsigned int Count = 0;
  }
  uint64_t v36 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), PrimitiveCount);
  C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v37, &v36);
  while (1)
  {
    if (!v38)
    {
      uint64_t v9 = 0;
      goto LABEL_57;
    }
    uint64_t v10 = *(C3D::Pass ***)C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::back((uint64_t)&v37);
    C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back((uint64_t)&v37);
    if (!*(unsigned char *)(a2 + 44) || *v10 != *(C3D::Pass **)(a2 + 32)) {
      break;
    }
LABEL_47:
    CFNumberRef v31 = v10 + 4;
    if (*(_DWORD *)(a2 + 40)) {
      CFNumberRef v31 = v10 + 1;
    }
    uint64_t v32 = *((unsigned int *)v31 + 2);
    if (v32)
    {
      uint64_t v33 = v31[2];
      uint64_t v34 = 4 * v32;
      do
      {
        if ((*(_DWORD *)v33 & 0x8000) == 0)
        {
          uint64_t v36 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(void *)(a1 + 24), *(_DWORD *)v33 & 0x7FFF);
          C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v37, &v36);
          *(_DWORD *)v33 |= 0x8000u;
        }
        uint64_t v33 = (C3D::Pass *)((char *)v33 + 4);
        v34 -= 4;
      }
      while (v34);
    }
  }
  if (*(void *)a2)
  {
    if ((**(uint64_t (***)(void))*v10)())
    {
      uint64_t v11 = (const char *)(**(uint64_t (***)(void))*v10)();
      BOOL v12 = strcmp(v11, *(const char **)a2) == 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
  else
  {
    BOOL v12 = 1;
  }
  int v13 = *(unsigned char *)(a2 + 24) == 0;
  uint64_t v14 = *(void *)(a2 + 8);
  BOOL v15 = v14 == 0;
  if (*(unsigned char *)(a2 + 24) || v14)
  {
    __int16 v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
    if (!C3D::PassDescriptor::inputCount(v16)) {
      goto LABEL_32;
    }
    unsigned int v17 = 0;
    while (1)
    {
      unsigned int v18 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
      uint64_t v19 = C3D::PassDescriptor::inputAtIndex(v18, (unsigned __int16)v17);
      v13 |= *(unsigned __int8 *)(v19 + 64) == *(unsigned __int8 *)(a2 + 24);
      if (v15) {
        break;
      }
      char v20 = *(const char **)(v19 + 8);
      if (v20)
      {
        BOOL v15 = strcmp(v20, *(const char **)(a2 + 8)) == 0;
LABEL_28:
        if (v15 & v13) {
          goto LABEL_21;
        }
        goto LABEL_29;
      }
      BOOL v15 = 0;
LABEL_29:
      ++v17;
      uint64_t v21 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
      if (v17 >= C3D::PassDescriptor::inputCount(v21)) {
        goto LABEL_32;
      }
    }
    BOOL v15 = 1;
    goto LABEL_28;
  }
LABEL_21:
  int v13 = 1;
  BOOL v15 = 1;
LABEL_32:
  int v22 = *(unsigned char *)(a2 + 25) == 0;
  uint64_t v23 = *(void *)(a2 + 16);
  BOOL v24 = v23 == 0;
  if (*(unsigned char *)(a2 + 25) || v23)
  {
    unsigned int v25 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
    if (!C3D::PassDescriptor::outputCount(v25)) {
      goto LABEL_45;
    }
    unsigned int v26 = 0;
    while (1)
    {
      int v27 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
      uint64_t v28 = C3D::PassDescriptor::outputAtIndex(v27, (unsigned __int16)v26);
      v22 |= *(unsigned __int8 *)(v28 + 64) == *(unsigned __int8 *)(a2 + 25);
      if (v24) {
        break;
      }
      uint64_t v29 = *(const char **)(v28 + 8);
      if (v29)
      {
        BOOL v24 = strcmp(v29, *(const char **)(a2 + 16)) == 0;
LABEL_41:
        if (v24 & v22) {
          goto LABEL_34;
        }
        goto LABEL_42;
      }
      BOOL v24 = 0;
LABEL_42:
      ++v26;
      CFNumberRef v30 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v10);
      if (v26 >= C3D::PassDescriptor::outputCount(v30)) {
        goto LABEL_45;
      }
    }
    BOOL v24 = 1;
    goto LABEL_41;
  }
LABEL_34:
  int v22 = 1;
  BOOL v24 = 1;
LABEL_45:
  if ((v12 & v13 & v22 & v15) != 1 || !v24) {
    goto LABEL_47;
  }
  uint64_t v9 = *v10;
LABEL_57:
  C3DStackAllocatorPopFrame(StackAllocator);
  return v9;
}

void C3D::RenderGraph::logPassIODescriptor(C3D::RenderGraph *this, C3D::PassIODescriptor *a2, const char *a3)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  int v5 = *(unsigned __int8 *)a2;
  if (v5 == 2)
  {
    BOOL v24 = scn_default_log();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_INFO)) {
      goto LABEL_14;
    }
    uint64_t v25 = *((void *)a2 + 2);
    int v37 = 136315650;
    int v38 = a3;
    __int16 v39 = 2080;
    int v40 = a3;
    __int16 v41 = 2048;
    *(void *)&long long v42 = v25;
    uint64_t v21 = "Info: |%s%slength : %lu";
    int v22 = v24;
    uint32_t v23 = 32;
    goto LABEL_13;
  }
  if (v5 != 1)
  {
    unsigned int v26 = scn_default_log();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_INFO)) {
      goto LABEL_14;
    }
    int v37 = 136315138;
    int v38 = a3;
    uint64_t v21 = "Info: |%stype : INVALID";
    int v22 = v26;
    uint32_t v23 = 12;
    goto LABEL_13;
  }
  uint64_t v6 = -[__CFString cStringUsingEncoding:](SCNMTLTextureTypeToString(*((unsigned __int8 *)a2 + 24)), "cStringUsingEncoding:", [NSString defaultCStringEncoding]);
  uint64_t v7 = -[__CFString cStringUsingEncoding:](SCNMTLPixelFormatToString(*((unsigned __int16 *)a2 + 14)), "cStringUsingEncoding:", [NSString defaultCStringEncoding]);
  uint64_t v8 = scn_default_log();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    int v37 = 136315394;
    int v38 = a3;
    __int16 v39 = 2080;
    int v40 = a3;
    _os_log_impl(&dword_20B249000, v8, OS_LOG_TYPE_INFO, "Info: |%s%s|width|height|depth|        pixelFormat      |arrayLength|storageMode|usage|cpuCacheMo|mipmapCount|sampleCount|usedForRes|         textureType      |", (uint8_t *)&v37, 0x16u);
  }
  uint64_t v9 = scn_default_log();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v10 = *((unsigned __int16 *)a2 + 8);
    int v11 = *((unsigned __int16 *)a2 + 9);
    int v12 = *((unsigned __int16 *)a2 + 10);
    int v13 = *((unsigned __int16 *)a2 + 11);
    int v14 = *((unsigned __int8 *)a2 + 25);
    int v15 = *((unsigned __int8 *)a2 + 26);
    int v16 = *((unsigned __int8 *)a2 + 27);
    int v17 = *((unsigned __int8 *)a2 + 30);
    int v18 = *((unsigned __int8 *)a2 + 31);
    int v19 = *((_DWORD *)a2 + 8);
    int v37 = 136318466;
    int v38 = a3;
    __int16 v39 = 2080;
    int v40 = a3;
    __int16 v41 = 1024;
    LODWORD(v42) = v10;
    WORD2(v42) = 1024;
    *(_DWORD *)((char *)&v42 + 6) = v11;
    WORD5(v42) = 1024;
    HIDWORD(v42) = v12;
    *(_WORD *)int v43 = 2080;
    *(void *)&v43[2] = v7;
    LOWORD(v44) = 1024;
    *(_DWORD *)((char *)&v44 + 2) = v13;
    HIWORD(v44) = 1024;
    *(_DWORD *)int v45 = v14;
    *(_WORD *)&v45[4] = 1024;
    *(_DWORD *)&v45[6] = v15;
    __int16 v46 = 1024;
    int v47 = v16;
    __int16 v48 = 1024;
    int v49 = v17;
    __int16 v50 = 1024;
    int v51 = v18;
    __int16 v52 = 1024;
    int v53 = v19;
    __int16 v54 = 2080;
    *(void *)CFBooleanRef v55 = v6;
    _os_log_impl(&dword_20B249000, v9, OS_LOG_TYPE_INFO, "Info: |%s%s|%5d|%6d|%5d|%25s|%11d|%11d|%5d|%10d|%11d|%11d|%10d|%26s|", (uint8_t *)&v37, 0x66u);
  }
  char v20 = scn_default_log();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    LOWORD(v37) = 0;
    uint64_t v21 = "Info: |";
    int v22 = v20;
    uint32_t v23 = 2;
LABEL_13:
    _os_log_impl(&dword_20B249000, v22, OS_LOG_TYPE_INFO, v21, (uint8_t *)&v37, v23);
  }
LABEL_14:
  int v27 = scn_default_log();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
  {
    int v37 = 136315394;
    int v38 = a3;
    __int16 v39 = 2080;
    int v40 = a3;
    _os_log_impl(&dword_20B249000, v27, OS_LOG_TYPE_INFO, "Info: |%s%s|type|clearColor R|   G|   B|   A|attachmentType|loadMode|dispatchToOutput|usedInternally|registerTexture|registerResolveT|specificClearCol|readWrite|persistent|", (uint8_t *)&v37, 0x16u);
  }
  uint64_t v28 = scn_default_log();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
  {
    int v29 = *(unsigned __int8 *)a2;
    double v30 = *((float *)a2 + 12);
    double v31 = *((float *)a2 + 13);
    double v32 = *((float *)a2 + 14);
    double v33 = *((float *)a2 + 15);
    int v34 = *((unsigned __int8 *)a2 + 64);
    unsigned int v35 = *((unsigned __int16 *)a2 + 33);
    int v37 = 136318978;
    int v38 = a3;
    __int16 v39 = 2080;
    int v40 = a3;
    __int16 v41 = 1024;
    LODWORD(v42) = v29;
    WORD2(v42) = 2048;
    *(double *)((char *)&v42 + 6) = v30;
    HIWORD(v42) = 2048;
    *(double *)int v43 = v31;
    *(_WORD *)&v43[8] = 2048;
    double v44 = v32;
    *(_WORD *)int v45 = 2048;
    *(double *)&v45[2] = v33;
    __int16 v46 = 1024;
    int v47 = v34;
    __int16 v48 = 1024;
    int v49 = v35 & 3;
    __int16 v50 = 1024;
    int v51 = (v35 >> 2) & 1;
    __int16 v52 = 1024;
    int v53 = (v35 >> 3) & 1;
    __int16 v54 = 1024;
    *(_DWORD *)CFBooleanRef v55 = (v35 >> 4) & 1;
    *(_WORD *)&v55[4] = 1024;
    *(_DWORD *)&v55[6] = (v35 >> 5) & 1;
    __int16 v56 = 1024;
    int v57 = (v35 >> 6) & 1;
    __int16 v58 = 1024;
    int v59 = (v35 >> 7) & 1;
    __int16 v60 = 1024;
    int v61 = (v35 >> 8) & 1;
    _os_log_impl(&dword_20B249000, v28, OS_LOG_TYPE_INFO, "Info: |%s%s|%4hhu|%12.1f|%4.1f|%4.1f|%4.1f|%14hhu|%8hhu|%16d|%14d|%15d|%16d|%16d|%9d|%10d|", (uint8_t *)&v37, 0x7Au);
  }
  uint64_t v36 = scn_default_log();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    LOWORD(v37) = 0;
    _os_log_impl(&dword_20B249000, v36, OS_LOG_TYPE_INFO, "Info: |", (uint8_t *)&v37, 2u);
  }
}

void C3DRenderGraphClearRenderGraphResources(uint64_t a1)
{
}

void C3DRenderGraphInvalidateTechniques(uint64_t a1)
{
  *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  uint64_t v2 = *(const void **)(a1 + 200);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 200) = 0;
  }
}

uint64_t C3DRenderGraphIsRecordingWithoutExecute(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 210);
}

uint64_t C3DRenderGraphSetRecordWithoutExecute(uint64_t result, char a2)
{
  *(unsigned char *)(result + 210) = a2;
  return result;
}

void C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::clear(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
}

void C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::_grow(uint64_t a1)
{
  unsigned int v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  BOOL v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate((void *)a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 8;
      --v6;
    }
    while (v6);
  }
}

void C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_grow(uint64_t a1)
{
  unsigned int v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  BOOL v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<C3D::Pass *,C3D::StackAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 8;
      --v6;
    }
    while (v6);
  }
}

unsigned __int8 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(unsigned __int8 *result, unsigned __int8 *a2, _WORD *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *(unsigned __int8 *)a3;
  if (v3 >= *result)
  {
    if (v4 < v3)
    {
      __int16 v6 = *(_WORD *)a2;
      *(_WORD *)a2 = *a3;
      *a3 = v6;
      if (*a2 < *result)
      {
        __int16 v7 = *(_WORD *)result;
        *(_WORD *)double result = *(_WORD *)a2;
        *(_WORD *)a2 = v7;
      }
    }
  }
  else
  {
    __int16 v5 = *(_WORD *)result;
    if (v4 >= v3)
    {
      *(_WORD *)double result = *(_WORD *)a2;
      *(_WORD *)a2 = v5;
      if (*(unsigned __int8 *)a3 >= v5) {
        return result;
      }
      *(_WORD *)a2 = *a3;
    }
    else
    {
      *(_WORD *)double result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v4 = (a2 - a1) >> 1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 2) < *a1)
      {
        __int16 v6 = *(_WORD *)a1;
        *(_WORD *)a1 = *((_WORD *)a2 - 1);
        *((_WORD *)a2 - 1) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(a1, a1 + 2, (_WORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(a1, a1 + 2, (__int16 *)a1 + 2, (__int16 *)a2 - 1);
      return 1;
    case 5:
      int v15 = a1 + 4;
      int v16 = a1 + 6;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(a1, a1 + 2, (__int16 *)a1 + 2, (__int16 *)a1 + 3);
      if (*(a2 - 2) < a1[6])
      {
        __int16 v17 = *(_WORD *)v16;
        *(_WORD *)int v16 = *((_WORD *)a2 - 1);
        *((_WORD *)a2 - 1) = v17;
        if (*v16 < *v15)
        {
          __int16 v18 = *(_WORD *)v15;
          __int16 v19 = *(_WORD *)v16;
          *(_WORD *)int v15 = *(_WORD *)v16;
          *(_WORD *)int v16 = v18;
          if (a1[2] > v19)
          {
            __int16 v20 = *((_WORD *)a1 + 1);
            *((_WORD *)a1 + 1) = v19;
            *((_WORD *)a1 + 2) = v20;
            if (*a1 > v19)
            {
              __int16 v21 = *(_WORD *)a1;
              *(_WORD *)a1 = v19;
              *((_WORD *)a1 + 1) = v21;
            }
          }
        }
      }
      return 1;
    default:
      __int16 v7 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(a1, a1 + 2, (_WORD *)a1 + 2);
      uint64_t v8 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    if (*v8 < *v7)
    {
      __int16 v11 = *(_WORD *)v8;
      uint64_t v12 = v9;
      while (1)
      {
        *(_WORD *)&a1[v12 + 6] = *(_WORD *)&a1[v12 + 4];
        if (v12 == -4) {
          break;
        }
        unsigned int v13 = a1[v12 + 2];
        v12 -= 2;
        if (v13 <= v11)
        {
          int v14 = &a1[v12 + 6];
          goto LABEL_13;
        }
      }
      int v14 = a1;
LABEL_13:
      *(_WORD *)int v14 = v11;
      if (++v10 == 8) {
        return v8 + 2 == a2;
      }
    }
    __int16 v7 = v8;
    v9 += 2;
    v8 += 2;
    if (v8 == a2) {
      return 1;
    }
  }
}

unsigned __int8 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(unsigned __int8 *a1, unsigned __int8 *a2, __int16 *a3, __int16 *a4)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(a1, a2, a3);
  if (*(unsigned __int8 *)a4 < *(unsigned __int8 *)a3)
  {
    __int16 v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    if (*(unsigned __int8 *)a3 < *a2)
    {
      __int16 v10 = *(_WORD *)a2;
      *(_WORD *)a2 = *a3;
      *a3 = v10;
      if (*a2 < *a1)
      {
        __int16 v11 = *(_WORD *)a1;
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_WORD *)a2 = v11;
      }
    }
  }
  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *,false>(unint64_t result, int *a2, uint64_t a3, char a4)
{
  __int16 v9 = (int *)result;
  while (2)
  {
    __int16 v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          __int16 v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                int v40 = *v10;
                if ((*(a2 - 1) & 0x7FFFu) < (*v10 & 0x7FFFu))
                {
                  *__int16 v10 = *(a2 - 1);
                  *(a2 - 1) = v40;
                }
                break;
              case 3uLL:
                BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                BOOL result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                __int16 v41 = v10 + 2;
                long long v42 = v10 + 3;
                BOOL result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v10, v10 + 1, v10 + 2, v10 + 3);
                int v43 = v10[3];
                if ((*(a2 - 1) & 0x7FFFu) < (v43 & 0x7FFFu))
                {
                  *long long v42 = *(a2 - 1);
                  *(a2 - 1) = v43;
                  int v44 = *v42;
                  unsigned int v45 = *v42 & 0x7FFF;
                  int v46 = *v41;
                  if (v45 < (*v41 & 0x7FFFu))
                  {
                    *__int16 v41 = v44;
                    *long long v42 = v46;
                    int v47 = v10[1];
                    if (v45 < (v47 & 0x7FFFu))
                    {
                      v10[1] = v44;
                      v10[2] = v47;
                      int v48 = *v10;
                      if (v45 < (*v10 & 0x7FFFu))
                      {
                        *__int16 v10 = v44;
                        v10[1] = v48;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 95)
          {
            int v49 = v10 + 1;
            BOOL v51 = v10 == a2 || v49 == a2;
            if (a4)
            {
              if (!v51)
              {
                uint64_t v52 = 0;
                int v53 = v10;
                do
                {
                  int v55 = *v53;
                  int v54 = v53[1];
                  int v53 = v49;
                  if ((v54 & 0x7FFFu) < (v55 & 0x7FFFu))
                  {
                    uint64_t v56 = v52;
                    while (1)
                    {
                      *(int *)((char *)v10 + v56 + 4) = v55;
                      if (!v56) {
                        break;
                      }
                      int v55 = *(int *)((char *)v10 + v56 - 4);
                      v56 -= 4;
                      if ((v54 & 0x7FFFu) >= (v55 & 0x7FFFu))
                      {
                        int v57 = (int *)((char *)v10 + v56 + 4);
                        goto LABEL_85;
                      }
                    }
                    int v57 = v10;
LABEL_85:
                    *int v57 = v54;
                  }
                  int v49 = v53 + 1;
                  v52 += 4;
                }
                while (v53 + 1 != a2);
              }
            }
            else if (!v51)
            {
              do
              {
                int v83 = *v9;
                int v82 = v9[1];
                __int16 v9 = v49;
                if ((v82 & 0x7FFFu) < (v83 & 0x7FFFu))
                {
                  do
                  {
                    *int v49 = v83;
                    int v83 = *(v49 - 2);
                    --v49;
                  }
                  while ((v82 & 0x7FFFu) < (v83 & 0x7FFFu));
                  *int v49 = v82;
                }
                int v49 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v58 = (v12 - 2) >> 1;
              int64_t v59 = v58;
              do
              {
                int64_t v60 = v59;
                if (v58 >= v59)
                {
                  uint64_t v61 = (2 * v59) | 1;
                  uint64_t v62 = &v10[v61];
                  if (2 * v60 + 2 < (uint64_t)v12)
                  {
                    int v63 = v62[1];
                    if ((*v62 & 0x7FFFu) < (v63 & 0x7FFFu))
                    {
                      ++v62;
                      uint64_t v61 = 2 * v60 + 2;
                    }
                    else
                    {
                      int v63 = *v62;
                    }
                  }
                  else
                  {
                    int v63 = *v62;
                  }
                  uint64_t v64 = &v10[v60];
                  BOOL result = v63 & 0x7FFF;
                  int v65 = *v64;
                  unsigned int v66 = *v64 & 0x7FFF;
                  if (result >= v66)
                  {
                    do
                    {
                      *uint64_t v64 = v63;
                      uint64_t v64 = v62;
                      if (v58 < v61) {
                        break;
                      }
                      uint64_t v67 = (2 * v61) | 1;
                      uint64_t v62 = &v10[v67];
                      uint64_t v61 = 2 * v61 + 2;
                      if (v61 < (uint64_t)v12)
                      {
                        int v63 = *v62;
                        if ((*v62 & 0x7FFFu) >= (v62[1] & 0x7FFFu))
                        {
                          uint64_t v61 = v67;
                        }
                        else
                        {
                          int v63 = v62[1];
                          ++v62;
                        }
                      }
                      else
                      {
                        int v63 = *v62;
                        uint64_t v61 = v67;
                      }
                      BOOL result = v63 & 0x7FFF;
                    }
                    while (result >= v66);
                    *uint64_t v64 = v65;
                  }
                }
                int64_t v59 = v60 - 1;
              }
              while (v60);
              uint64_t v68 = (unint64_t)v11 >> 2;
              do
              {
                uint64_t v69 = 0;
                int v70 = *v10;
                CFDataRef v71 = v10;
                do
                {
                  long long v72 = &v71[v69 + 1];
                  uint64_t v73 = (2 * v69) | 1;
                  uint64_t v69 = 2 * v69 + 2;
                  if (v69 < v68)
                  {
                    int v74 = *v72;
                    BOOL result = *v72 & 0x7FFF;
                    if (result >= (v72[1] & 0x7FFFu))
                    {
                      uint64_t v69 = v73;
                    }
                    else
                    {
                      int v74 = v72[1];
                      ++v72;
                    }
                  }
                  else
                  {
                    int v74 = *v72;
                    uint64_t v69 = v73;
                  }
                  *CFDataRef v71 = v74;
                  CFDataRef v71 = v72;
                }
                while (v69 <= (uint64_t)((unint64_t)(v68 - 2) >> 1));
                if (v72 == --a2)
                {
                  *long long v72 = v70;
                }
                else
                {
                  *long long v72 = *a2;
                  *a2 = v70;
                  uint64_t v75 = (char *)v72 - (char *)v10 + 4;
                  if (v75 >= 5)
                  {
                    unint64_t v76 = (((unint64_t)v75 >> 2) - 2) >> 1;
                    int v77 = &v10[v76];
                    int v78 = *v77;
                    int v79 = *v72;
                    unsigned int v80 = *v72 & 0x7FFF;
                    if ((*v77 & 0x7FFFu) < v80)
                    {
                      do
                      {
                        *long long v72 = v78;
                        long long v72 = v77;
                        if (!v76) {
                          break;
                        }
                        unint64_t v76 = (v76 - 1) >> 1;
                        int v77 = &v10[v76];
                        int v78 = *v77;
                      }
                      while ((*v77 & 0x7FFFu) < v80);
                      *long long v72 = v79;
                    }
                  }
                }
              }
              while (v68-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          int v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x201)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v9 + 2, &v9[v13 + 1], a2 - 3);
            BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v14 - 1, v14, &v9[v13 + 1]);
            int v15 = *v9;
            int *v9 = *v14;
            *int v14 = v15;
          }
          else
          {
            BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          int v16 = *v9;
          if (a4) {
            break;
          }
          unsigned int v17 = *v9 & 0x7FFF;
          if ((*(v9 - 1) & 0x7FFFu) < v17) {
            goto LABEL_13;
          }
          if (v17 >= (*(a2 - 1) & 0x7FFFu))
          {
            double v32 = v9 + 1;
            do
            {
              __int16 v10 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 >= (*v10 & 0x7FFFu));
          }
          else
          {
            __int16 v10 = v9;
            do
            {
              int v31 = v10[1];
              ++v10;
            }
            while (v17 >= (v31 & 0x7FFFu));
          }
          double v33 = a2;
          if (v10 < a2)
          {
            double v33 = a2;
            do
              int v34 = *--v33;
            while (v17 < (v34 & 0x7FFFu));
          }
          if (v10 < v33)
          {
            int v35 = *v10;
            int v36 = *v33;
            do
            {
              *__int16 v10 = v36;
              *double v33 = v35;
              do
              {
                int v37 = v10[1];
                ++v10;
                int v35 = v37;
              }
              while (v17 >= (v37 & 0x7FFFu));
              do
              {
                int v38 = *--v33;
                int v36 = v38;
              }
              while (v17 < (v38 & 0x7FFFu));
            }
            while (v10 < v33);
          }
          __int16 v39 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            int *v9 = *v39;
          }
          a4 = 0;
          *__int16 v39 = v16;
        }
        unsigned int v17 = *v9 & 0x7FFF;
LABEL_13:
        uint64_t v18 = 0;
        do
          int v19 = v9[++v18];
        while ((v19 & 0x7FFFu) < v17);
        __int16 v20 = &v9[v18];
        __int16 v21 = a2;
        if (v18 == 1)
        {
          __int16 v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            int v23 = *--v21;
          }
          while ((v23 & 0x7FFFu) >= v17);
        }
        else
        {
          do
            int v22 = *--v21;
          while ((v22 & 0x7FFFu) >= v17);
        }
        if (v20 >= v21)
        {
          int v29 = v20 - 1;
        }
        else
        {
          int v24 = *v21;
          uint64_t v25 = &v9[v18];
          unsigned int v26 = v21;
          do
          {
            *uint64_t v25 = v24;
            int *v26 = v19;
            do
            {
              int v27 = v25[1];
              ++v25;
              int v19 = v27;
            }
            while ((v27 & 0x7FFFu) < v17);
            do
            {
              int v28 = *--v26;
              int v24 = v28;
            }
            while ((v28 & 0x7FFFu) >= v17);
          }
          while (v25 < v26);
          int v29 = v25 - 1;
        }
        if (v29 != v9) {
          int *v9 = *v29;
        }
        *int v29 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_34:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *,false>(v9, v29, a3, a4 & 1);
        a4 = 0;
        __int16 v10 = v29 + 1;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v9, v29);
      __int16 v10 = v29 + 1;
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(v29 + 1, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_34;
      }
    }
    a2 = v29;
    if (!v30) {
      continue;
    }
    return result;
  }
}

int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(int *result, int *a2, int *a3)
{
  int v3 = *a2;
  unsigned int v4 = *a2 & 0x7FFF;
  int v5 = *result;
  unsigned int v6 = *result & 0x7FFF;
  int v7 = *a3;
  unsigned int v8 = *a3 & 0x7FFF;
  if (v4 >= v6)
  {
    if (v8 < v4)
    {
      *a2 = v7;
      *a3 = v3;
      int v9 = *result;
      if ((*a2 & 0x7FFFu) < (*result & 0x7FFFu))
      {
        *BOOL result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v4)
    {
      *BOOL result = v3;
      *a2 = v5;
      if ((*a3 & 0x7FFFu) >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *BOOL result = v7;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(int *a1, int *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *a1;
      if ((*(a2 - 1) & 0x7FFFu) < (*a1 & 0x7FFFu))
      {
        *a1 = *(a2 - 1);
        *(a2 - 1) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      unsigned int v17 = a1 + 2;
      uint64_t v18 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(a1, a1 + 1, a1 + 2, a1 + 3);
      int v19 = a1[3];
      if ((*(a2 - 1) & 0x7FFFu) < (v19 & 0x7FFFu))
      {
        *uint64_t v18 = *(a2 - 1);
        *(a2 - 1) = v19;
        int v20 = *v18;
        unsigned int v21 = *v18 & 0x7FFF;
        int v22 = *v17;
        if (v21 < (*v17 & 0x7FFFu))
        {
          *unsigned int v17 = v20;
          *uint64_t v18 = v22;
          int v23 = a1[1];
          if (v21 < (v23 & 0x7FFFu))
          {
            a1[1] = v20;
            a1[2] = v23;
            int v24 = *a1;
            if (v21 < (*a1 & 0x7FFFu))
            {
              *a1 = v20;
              a1[1] = v24;
            }
          }
        }
      }
      return 1;
    default:
      int v7 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(a1, a1 + 1, a1 + 2);
      unsigned int v8 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v9 = 0;
      uint64_t v10 = 12;
      break;
  }
  while (1)
  {
    int v11 = *v8;
    unsigned int v12 = *v8 & 0x7FFF;
    int v13 = *v7;
    if (v12 < (*v7 & 0x7FFFu))
    {
      uint64_t v14 = v10;
      while (1)
      {
        *(int *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 4;
        if (v14 == 4) {
          break;
        }
        int v13 = *(int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= (v13 & 0x7FFFu))
        {
          int v16 = (int *)((char *)a1 + v15);
          goto LABEL_13;
        }
      }
      int v16 = a1;
LABEL_13:
      *int v16 = v11;
      if (++v9 == 8) {
        return v8 + 1 == a2;
      }
    }
    int v7 = v8;
    v10 += 4;
    if (++v8 == a2) {
      return 1;
    }
  }
}

int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(int *a1, int *a2, int *a3, int *a4)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *>(a1, a2, a3);
  int v9 = *a3;
  if ((*a4 & 0x7FFFu) < (*a3 & 0x7FFFu))
  {
    *a3 = *a4;
    *a4 = v9;
    int v10 = *a2;
    if ((*a3 & 0x7FFFu) < (*a2 & 0x7FFFu))
    {
      *a2 = *a3;
      *a3 = v10;
      int v11 = *a1;
      if ((*a2 & 0x7FFFu) < (*a1 & 0x7FFFu))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::insert(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 36);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      uint64_t v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v17 = v15 - 14;
          }
          else {
            unsigned int v17 = 0;
          }
          unsigned int v18 = v17 - 1;
          if (v17 <= v15) {
            unsigned int v19 = v15;
          }
          else {
            unsigned int v19 = v17;
          }
          char v20 = 1;
          while (1)
          {
            uint64_t v21 = v18 + 1;
            if (v17 <= v21) {
              break;
            }
LABEL_27:
            ++v20;
            unsigned int v18 = v21;
            if (v21 == v19) {
              goto LABEL_32;
            }
          }
          int v22 = 1 << (v18 - v17 + 2);
          char v23 = v20;
          unsigned int v24 = v17;
          while (1)
          {
            unsigned int v25 = v24;
            if (((unsigned __int16)v22 & *(_WORD *)(v8 + 2 * v24)) != 0) {
              break;
            }
            ++v24;
            LOWORD(v22) = (unsigned __int16)v22 >> 1;
            --v23;
            if (v25 + 1 > v21) {
              goto LABEL_27;
            }
          }
          if (v21 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v26 = *(void *)(a1 + 16);
          *(void *)(*(void *)(a1 + 8) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v21);
          *(void *)(v26 + 8 * v15) = *(void *)(v26 + 8 * v21);
          uint64_t v8 = *(void *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          unsigned int v15 = v21;
          if (v21 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        LOBYTE(v15) = v21;
      }
      *(void *)(*(void *)(a1 + 16) + 8 * v21) = *a3;
      *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
      uint64_t v28 = *(void *)(a1 + 24);
      *(_WORD *)(v28 + 2 * v21) |= 1u;
      uint64_t result = 1;
      *(_WORD *)(v28 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_grow(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)(a1 + 8) + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 8 * v10) = *a3;
  return result;
}

void C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_grow(uint64_t a1)
{
  int v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v4 = *(__int16 **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 36);
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate((void *)a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v6)
  {
    do
    {
      __int16 v7 = *v4++;
      if (v7) {
        C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::insert(a1, *v3, v2);
      }
      ++v3;
      v2 += 8;
      --v6;
    }
    while (v6);
  }
}

uint64_t OUTLINED_FUNCTION_2_3(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

void OUTLINED_FUNCTION_3_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void OUTLINED_FUNCTION_5(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_error_impl(a1, v4, OS_LOG_TYPE_ERROR, a4, v5, 0xCu);
}

void OUTLINED_FUNCTION_6(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

uint64_t OUTLINED_FUNCTION_11(uint64_t result, float a2)
{
  *int v3 = a2;
  *uint64_t v2 = result;
  return result;
}

void OUTLINED_FUNCTION_13(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x2A0], 8) = a1;
}

void OUTLINED_FUNCTION_14(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_fault_impl(a1, v5, OS_LOG_TYPE_FAULT, a4, v4, 0x16u);
}

C3D::RenderPass *C3D::GaussianBlurPass::GaussianBlurPass(C3D::GaussianBlurPass *this, RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  uint64_t result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)uint64_t result = &unk_26BF6D770;
  *((_OWORD *)result + 15) = *(_OWORD *)&a4->var0;
  *((_WORD *)result + 20) = *(_WORD *)&a4[1].var0;
  unsigned int v6 = *(unsigned __int16 *)&a4[1].var2;
  if (v6 <= 1) {
    LOWORD(v6) = 1;
  }
  *((_WORD *)result + 21) = v6;
  return result;
}

const char *C3D::GaussianBlurPass::name(C3D::GaussianBlurPass *this)
{
  if (*((unsigned char *)this + 244)) {
    return "GaussianBlurPass-Y";
  }
  else {
    return "GaussianBlurPass-X";
  }
}

void C3D::GaussianBlurPass::setup(C3D::GaussianBlurPass *this)
{
  C3D::Pass::setInputCount(this, 1u);

  C3D::Pass::setOutputCount(this, 1u);
}

uint64_t C3D::GaussianBlurPass::compile(C3D::GaussianBlurPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  uint64_t v3 = -[SCNMTLRenderContext resourceManager](RenderContext);
  [(id)-[SCNMTLResourceManager libraryManager](v3) frameworkLibrary];
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::GaussianBlurPass *))(*(void *)this + 64))(this) ^ ((unint64_t)*((unsigned __int8 *)this + 249) << 24) ^ ((unint64_t)*((unsigned __int8 *)this + 248) << 16) ^ ((unint64_t)*((unsigned __int8 *)this + 247) << 8) ^ *((unsigned __int8 *)this + 246) ^ 0x1A929E4D6F47A654);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) >> 47));
  *((void *)this + 32) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::GaussianBlurPass::execute(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(a1 + 16));
  unsigned int v6 = (SCNMTLBufferPool *)-[SCNMTLRenderContext frameConstantBufferPool](RenderContext);
  __int16 v7 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  uint64_t v8 = v7;
  if (*(_WORD *)(a2 + 18)) {
    uint64_t v8 = (void **)(id)objc_msgSend(v7, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v7, "pixelFormat"), objc_msgSend(v7, "textureType"), *(unsigned __int16 *)(a2 + 18), 1, 0, 1);
  }
  SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v8, 0);
  if (*(_WORD *)(a1 + 246) || *(_WORD *)(a1 + 248))
  {
    uint64_t v9 = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*(void *)(a1 + 256) + 136);
    if (*(void *)(v4 + 3248) != v9)
    {
      *(void *)(v4 + 324_Block_object_dispose(&STACK[0x2A0], 8) = v9;
      [*(id *)(v4 + 3392) setFragmentSamplerState:v9 atIndex:0];
    }
  }
  float v33 = (float)(unint64_t)[v8 width];
  unint64_t v10 = [v8 height];
  v11.f32[0] = v33;
  v11.f32[1] = (float)v10;
  float v12 = *(float *)(a1 + 240);
  unsigned int v13 = *(unsigned char *)(a1 + 244) == 0;
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v34 = vdiv_f32(_D0, vmaxnm_f32(v11, _D0));
  *(float *)&long long v19 = C3DComputeGaussianProbability(0.0, v12);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  *(void *)&long long v22 = 0;
  *((void *)&v22 + 1) = v19;
  v39[0] = v22;
  DWORD1(v22) = v34.i32[1];
  float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v13), 0x1FuLL)), *(int8x8_t *)&v22, (int8x8_t)v34.u32[0]);
  unsigned int v24 = 1;
  while (1)
  {
    long long v35 = v19;
    float v25 = (float)(v24 + 1);
    float v26 = C3DComputeGaussianProbability((float)v24, v12);
    float v27 = C3DComputeGaussianProbability(v25, v12);
    float v29 = v26 + v27;
    if ((float)(v26 + v27) <= 0.002) {
      break;
    }
    *(float32x2_t *)&long long v28 = vmul_n_f32(v23, (float)((float)(v27 * v25) + (float)((float)v24 * v26)) / v29);
    *((float *)&v28 + 2) = v26 + v27;
    ++v21;
    long long v19 = v35;
    *(float *)&long long v19 = *(float *)&v35 + (float)(v29 * 2.0);
    v39[++v20] = v28;
    v24 += 2;
    if (v21 == 15) {
      goto LABEL_14;
    }
  }
  if (v21 < 0xF) {
    bzero(&v39[v20 + 1], ((224 - v20 * 16) & 0xFFFFFFFF0) + 16);
  }
  LODWORD(v19) = v35;
LABEL_14:
  unint64_t v30 = 0;
  do
  {
    *((float *)&v39[v30 / 0x10] + 2) = *((float *)&v39[v30 / 0x10] + 2) / *(float *)&v19;
    v30 += 16;
  }
  while (16 * v21 + 16 != v30);
  if (v21 >= 0xE) {
    LODWORD(v21) = 14;
  }
  int v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  SCNMTLBufferPool::allocateAndCopy(v6, v39, 0x100uLL, &v36);
  uint64_t v31 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*(void *)(a1 + 256) + 8 * v21 + 16) state];
  if (*(void *)(v4 + 3376) != v31)
  {
    *(void *)(v4 + 3376) = v31;
    [*(id *)(v4 + 3392) setRenderPipelineState:v31];
  }
  SCNMTLRenderCommandEncoder::setFragmentBuffer(v4, v37, v38, 0);
  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v4);
}

void C3D::GaussianBlurPass::Resource::~Resource(C3D::GaussianBlurPass::Resource *this)
{
  *(void *)this = &unk_26BF6D750;
  uint64_t v2 = (void *)*((void *)this + 17);
  if (v2) {

  }
  for (uint64_t i = 128; i != 8; i -= 8)
  {
    uint64_t v4 = *(void **)((char *)this + i);
    if (v4) {
  }
    }
}

{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_26BF6D750;
  uint64_t v2 = (void *)*((void *)this + 17);
  if (v2) {

  }
  uint64_t v3 = 128;
  while (1)
  {
    uint64_t v4 = *(void **)((char *)this + v3);
    if (v4) {

    }
    v3 -= 8;
    if (v3 == 8)
    {
      JUMPOUT(0x210534FE0);
    }
  }
}

void C3D::ComputePass::ComputePass(C3D::ComputePass *this, RenderGraph *a2, C3D::Pass *a3)
{
  C3D::Pass::Pass(this, a2, a3);
  *(void *)uint64_t v3 = &unk_26BF6CAF0;
  *(_DWORD *)(v3 + 32) = 3;
}

uint64_t C3DScratchAllocatorAllocate(void *a1, uint64_t a2)
{
  return C3DScratchAllocator::Allocate(a1, a2, 8);
}

uint64_t _rasterizerStateDidDie(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return [a2 _rasterizerStateDidDie:a4];
}

void sub_20B326F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20B3271D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t (*C3DKeyFrameInterpolatorForType(int a1, int a2, int a3, unsigned int a4, int a5))()
{
  int v5 = (uint64_t (*)())_C3DKeyFrameBoolInterpolator;
  switch(a1)
  {
    case 1:
    case 7:
      int v5 = (uint64_t (*)())_C3DKeyFrameFloatInterpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71B38;
        goto LABEL_43;
      }
      break;
    case 2:
      int v5 = (uint64_t (*)())_C3DKeyFrameIntInterpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71B68;
        goto LABEL_43;
      }
      break;
    case 3:
      return v5;
    case 4:
    case 16:
      int v5 = (uint64_t (*)())_C3DKeyFrameCharInterpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71C40;
        goto LABEL_43;
      }
      break;
    case 6:
      int v5 = (uint64_t (*)())_C3DKeyFrameDoubleInterpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71B50;
        goto LABEL_43;
      }
      break;
    case 8:
    case 18:
      int v5 = (uint64_t (*)())_C3DKeyFrameVector2Interpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71BF8;
        goto LABEL_43;
      }
      break;
    case 9:
    case 19:
      int v5 = (uint64_t (*)())_C3DKeyFrameVector3Interpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71BE0;
        goto LABEL_43;
      }
      break;
    case 10:
    case 20:
      if (a2 == 3)
      {
        int v5 = (uint64_t (*)())_C3DKeyFrameQuaternionInterpolator;
        if (a5 && a4 < 3)
        {
          unsigned int v6 = &off_26BF71B98;
          goto LABEL_43;
        }
      }
      else if (a2 == 4)
      {
        int v5 = (uint64_t (*)())_C3DKeyFrameAxisAngleInterpolator;
        if (a5 && a4 < 3)
        {
          unsigned int v6 = &off_26BF71B80;
          goto LABEL_43;
        }
      }
      else
      {
        int v5 = (uint64_t (*)())_C3DKeyFrameVector4Interpolator;
        if (a5 && a4 < 3)
        {
          unsigned int v6 = &off_26BF71BB0;
          goto LABEL_43;
        }
      }
      break;
    case 11:
      if (a4 < 3) {
        char v7 = a5;
      }
      else {
        char v7 = 0;
      }
      if (a3)
      {
        uint64_t v8 = _C3DKeyFrameMatrix4x4FastInterpolator;
        if (v7)
        {
          unsigned int v6 = &off_26BF71C10;
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v8 = _C3DKeyFrameMatrix4x4Interpolator;
        if (v7)
        {
          unsigned int v6 = &off_26BF71C28;
          goto LABEL_43;
        }
      }
      int v5 = (uint64_t (*)())v8;
      break;
    case 13:
      int v5 = (uint64_t (*)())_C3DKeyFrameColor4Interpolator;
      if (a5 && a4 < 3)
      {
        unsigned int v6 = &off_26BF71BC8;
LABEL_43:
        int v5 = v6[a4];
      }
      break;
    default:
      int v5 = 0;
      break;
  }
  return v5;
}

float _C3DKeyFrameFloatInterpolator_linear(float *a1, float *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float *a8)
{
  double v8 = *a1 + (float)(*a2 - *a1) * a3;
  if (a7) {
    double v8 = v8 + *a8;
  }
  float result = v8;
  *a8 = result;
  return result;
}

float *_C3DKeyFrameFloatInterpolator_discrete(float *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  float v7 = *result;
  if (a6) {
    float v7 = v7 + *a7;
  }
  *a7 = v7;
  return result;
}

float _C3DKeyFrameFloatInterpolator_cubic(float *a1, float *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float *a8)
{
  double v8 = a3 * a3 * a3;
  double v9 = (v8 + a3 * a3 * -2.0 + a3) * *(float *)(a5 + 4)
     + (1.0 - (a3 * a3 * 3.0 - v8 * 2.0)) * *a1
     + (a3 * a3 * 3.0 + v8 * -2.0) * *a2
     + (v8 - a3 * a3) * *(float *)(a6 + 4);
  if (a7) {
    double v9 = v9 + *a8;
  }
  float result = v9;
  *a8 = result;
  return result;
}

float _C3DKeyFrameFloatInterpolator(float *a1, float *a2, int a3, uint64_t a4, uint64_t a5, int a6, float *a7, double a8)
{
  if (!a3)
  {
    double v9 = *a1 + (float)(*a2 - *a1) * a8;
    if (a6) {
      double v9 = v9 + *a7;
    }
    float result = v9;
    goto LABEL_8;
  }
  if (a3 == 1)
  {
    float result = *a1;
    if (a6) {
      float result = result + *a7;
    }
LABEL_8:
    *a7 = result;
    return result;
  }
  return _C3DKeyFrameFloatInterpolator_cubic(a1, a2, a8, 0, a4, a5, a6, a7);
}

double *_C3DKeyFrameDoubleInterpolator_linear(double *result, double *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, double *a8)
{
  double v8 = *result + (*a2 - *result) * a3;
  if (a7) {
    double v8 = *a8 + v8;
  }
  *a8 = v8;
  return result;
}

double *_C3DKeyFrameDoubleInterpolator_discrete(double *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, double *a7)
{
  double v7 = *result;
  if (a6) {
    double v7 = v7 + *a7;
  }
  *a7 = v7;
  return result;
}

double *_C3DKeyFrameDoubleInterpolator_cubic(double *result, double *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, double *a8)
{
  double v8 = a3 * a3 * a3;
  double v9 = (v8 + a3 * a3 * -2.0 + a3) * *(float *)(a5 + 4)
     + (1.0 - (a3 * a3 * 3.0 - v8 * 2.0)) * *result
     + (a3 * a3 * 3.0 + v8 * -2.0) * *a2
     + (v8 - a3 * a3) * *(float *)(a6 + 4);
  if (a7) {
    double v9 = *a8 + v9;
  }
  *a8 = v9;
  return result;
}

double *_C3DKeyFrameDoubleInterpolator(double *result, double *a2, int a3, uint64_t a4, uint64_t a5, int a6, double *a7, double a8)
{
  if (!a3)
  {
    double v8 = *result + (*a2 - *result) * a8;
    if (!a6) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (a3 == 1)
  {
    double v8 = *result;
    if (!a6)
    {
LABEL_5:
      *a7 = v8;
      return result;
    }
LABEL_4:
    double v8 = v8 + *a7;
    goto LABEL_5;
  }
  return _C3DKeyFrameDoubleInterpolator_cubic(result, a2, a8, 0, a4, a5, a6, a7);
}

int *_C3DKeyFrameIntInterpolator_linear(int *result, _DWORD *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int *a8)
{
  double v8 = (double)*result + (double)(*a2 - *result) * a3;
  if (a7) {
    double v8 = v8 + (double)*a8;
  }
  *a8 = (int)v8;
  return result;
}

int *_C3DKeyFrameIntInterpolator_discrete(int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, _DWORD *a7)
{
  int v7 = *result;
  if (a6) {
    v7 += *a7;
  }
  *a7 = v7;
  return result;
}

int *_C3DKeyFrameIntInterpolator_cubic(int *result, int *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int *a8)
{
  double v8 = a3 * a3 * a3;
  double v9 = (v8 + a3 * a3 * -2.0 + a3) * *(float *)(a5 + 4)
     + (1.0 - (a3 * a3 * 3.0 - v8 * 2.0)) * (double)*result
     + (a3 * a3 * 3.0 + v8 * -2.0) * (double)*a2
     + (v8 - a3 * a3) * *(float *)(a6 + 4);
  if (a7) {
    double v9 = v9 + (double)*a8;
  }
  *a8 = (int)v9;
  return result;
}

int *_C3DKeyFrameIntInterpolator(int *result, int *a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, int *a7, double a8)
{
  if (a3 > 1) {
    return _C3DKeyFrameIntInterpolator_cubic(result, a2, a8, 0, a4, a5, a6, a7);
  }
  int v8 = *result;
  if (a6) {
    v8 += *a7;
  }
  *a7 = v8;
  return result;
}

float32x4_t *_C3DKeyFrameAxisAngleInterpolator_linear(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float32x4_t v8 = *result;
  uint32x4_t v9 = (uint32x4_t)vceqzq_f32(*result);
  v9.i32[3] = v9.i32[2];
  unsigned int v10 = vminvq_u32(v9);
  float32x4_t v11 = *a2;
  if ((v10 & 0x80000000) != 0)
  {
    float32x4_t v8 = *a2;
    v8.i32[3] = 0;
    float32x4_t v15 = v8;
    float result = &v15;
  }
  uint32x4_t v12 = (uint32x4_t)vceqzq_f32(v11);
  v12.i32[3] = v12.i32[2];
  if ((vminvq_u32(v12) & 0x80000000) != 0)
  {
    v8.i32[3] = 0;
    float32x4_t v15 = v8;
    float32x4_t v11 = v8;
  }
  float v13 = a3;
  float32x4_t v14 = vmlaq_n_f32(*result, vsubq_f32(v11, *result), v13);
  if (a7) {
    float32x4_t v14 = vaddq_f32(*a8, v14);
  }
  *a8 = v14;
  return result;
}

float32x4_t *_C3DKeyFrameAxisAngleInterpolator_discrete(float32x4_t *result, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  float32x4_t v7 = *result;
  uint32x4_t v8 = (uint32x4_t)vceqzq_f32(*result);
  v8.i32[3] = v8.i32[2];
  if ((vminvq_u32(v8) & 0x80000000) != 0)
  {
    float32x4_t v7 = *a2;
    v7.i32[3] = 0;
    if (a6) {
      goto LABEL_3;
    }
LABEL_5:
    float32x4_t v9 = *result;
    goto LABEL_6;
  }
  if (!a6) {
    goto LABEL_5;
  }
LABEL_3:
  float32x4_t v9 = vaddq_f32(v7, *a7);
LABEL_6:
  *a7 = v9;
  return result;
}

float32x4_t *_C3DKeyFrameAxisAngleInterpolator(float32x4_t *result, float32x4_t *a2, int a3, double a4, int32x4_t a5, double a6, int32x4_t a7, uint64_t a8, uint64_t a9, int a10, float32x4_t *a11)
{
  if (a3 == 1)
  {
    float32x4_t v11 = *result;
    uint32x4_t v12 = (uint32x4_t)vceqzq_f32(*result);
    v12.i32[3] = v12.i32[2];
    if ((vminvq_u32(v12) & 0x80000000) != 0)
    {
      float32x4_t v11 = *a2;
      v11.i32[3] = 0;
      if (a10) {
        goto LABEL_4;
      }
    }
    else if (a10)
    {
LABEL_4:
      float32x4_t v13 = vaddq_f32(v11, *a11);
LABEL_14:
      *a11 = v13;
      return result;
    }
    float32x4_t v13 = *result;
    goto LABEL_14;
  }
  a5.i32[0] = 0;
  uint32x4_t v14 = (uint32x4_t)vceqzq_f32(*result);
  v14.i32[3] = v14.i32[2];
  a7.i32[0] = vminvq_u32(v14);
  float32x4_t v15 = *a2;
  int8x16_t v16 = *(int8x16_t *)a2;
  v16.i32[3] = 0;
  float32x4_t v17 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a7), 0), v16, *(int8x16_t *)result);
  uint32x4_t v18 = (uint32x4_t)vceqzq_f32(*a2);
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) != 0)
  {
    long long v19 = &v22;
    if (a7.i32[0] >= 0) {
      long long v19 = result;
    }
    float32x4_t v15 = v17;
    v15.i32[3] = 0;
    float32x4_t v22 = v15;
    float32x4_t v17 = *v19;
  }
  float v20 = a4;
  float32x4_t v21 = vmlaq_n_f32(v17, vsubq_f32(v15, v17), v20);
  if (a10) {
    float32x4_t v21 = vaddq_f32(v21, *a11);
  }
  *a11 = v21;
  return result;
}

double _C3DKeyFrameQuaternionInterpolator_linear(float32x4_t *a1, float32x4_t *a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, float32x4_t *a14)
{
  if (a13)
  {
    float32x4_t v18 = 0uLL;
    float v15 = a3;
    C3DQuaternionSlerp(a1, a2, &v18, v15, a4, a5, a6, a7, a8, a9);
    *(void *)&double result = C3DQuaternionAdd(&v18, a14, a14).u64[0];
  }
  else
  {
    float v17 = a3;
    *(void *)&double result = C3DQuaternionSlerp(a1, a2, a14, v17, a4, a5, a6, a7, a8, a9).u64[0];
  }
  return result;
}

float32x4_t _C3DKeyFrameQuaternionInterpolator_discrete(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    result.i64[0] = C3DQuaternionAdd(a1, a7, a7).u64[0];
  }
  else
  {
    float32x4_t result = *a1;
    *a7 = *a1;
  }
  return result;
}

float32x4_t _C3DKeyFrameQuaternionInterpolator(float32x4_t *a1, float32x4_t *a2, int a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7, double a8, double a9, double a10, double a11, double a12, double a13, float32x4_t a14)
{
  if (a3 == 1)
  {
    if (a6)
    {
      result.i64[0] = C3DQuaternionAdd(a1, a7, a7).u64[0];
    }
    else
    {
      float32x4_t result = *a1;
      *a7 = *a1;
    }
  }
  else
  {
    *(double *)result.i64 = _C3DKeyFrameQuaternionInterpolator_linear(a1, a2, a8, a9, a10, a11, a12, a13, a14, 0, a4, a5, a6, a7);
  }
  return result;
}

float32x4_t *_C3DKeyFrameVector4Interpolator_linear(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v8);
  if (a7) {
    float32x4_t v9 = vaddq_f32(*a8, v9);
  }
  *a8 = v9;
  return result;
}

float32x4_t _C3DKeyFrameVector4Interpolator_discrete(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    float32x4_t result = vaddq_f32(*a1, *a7);
    *a7 = result;
  }
  else
  {
    float32x4_t result = *a1;
    *a7 = *a1;
  }
  return result;
}

float32x4_t *_C3DKeyFrameVector4Interpolator_cubic(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v8);
  if (a7) {
    float32x4_t v9 = vaddq_f32(*a8, v9);
  }
  *a8 = v9;
  return result;
}

float32x4_t *_C3DKeyFrameVector4Interpolator(float32x4_t *result, float32x4_t *a2, int a3, double a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a3 == 1)
  {
    if (a7) {
      float32x4_t v8 = vaddq_f32(*result, *a8);
    }
    else {
      float32x4_t v8 = *result;
    }
    *a8 = v8;
  }
  else
  {
    float v9 = a4;
    float32x4_t v10 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v9);
    if (a7) {
      float32x4_t v10 = vaddq_f32(v10, *a8);
    }
    *a8 = v10;
  }
  return result;
}

float _C3DKeyFrameColor4Interpolator_linear(float *a1, float *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float *a8)
{
  if (a7)
  {
    v12[0] = 0;
    v12[1] = 0;
    float v9 = a3;
    C3DColor4Lerp(a1, a2, (float *)v12, v9);
    return C3DColor4Add((float *)v12, a8, a8);
  }
  else
  {
    float v11 = a3;
    return C3DColor4Lerp(a1, a2, a8, v11);
  }
}

__n128 _C3DKeyFrameColor4Interpolator_discrete(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  if (a6)
  {
    result.n128_f32[0] = C3DColor4Add(a1, a7, a7);
  }
  else
  {
    __n128 result = *(__n128 *)a1;
    *(_OWORD *)a7 = *(_OWORD *)a1;
  }
  return result;
}

__n128 _C3DKeyFrameColor4Interpolator(float *a1, float *a2, int a3, uint64_t a4, uint64_t a5, int a6, float *a7, double a8)
{
  if (a3 == 1)
  {
    if (a6)
    {
      result.n128_f32[0] = C3DColor4Add(a1, a7, a7);
    }
    else
    {
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a7 = *(_OWORD *)a1;
    }
  }
  else
  {
    result.n128_f32[0] = _C3DKeyFrameColor4Interpolator_linear(a1, a2, a8, 0, a4, a5, a6, a7);
  }
  return result;
}

uint64_t _C3DKeyFrameVector3Interpolator_linear(uint64_t result, uint64_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10)
{
  a4.i64[0] = *(void *)result;
  a4.i32[2] = *(_DWORD *)(result + 8);
  a5.i64[0] = *(void *)a2;
  a5.i32[2] = *(_DWORD *)(a2 + 8);
  float v10 = *(double *)a3.i64;
  float32x4_t v11 = vmlaq_n_f32(a4, vsubq_f32(a5, a4), v10);
  if (a9)
  {
    a3.i64[0] = *(void *)a10;
    a3.i32[2] = *(_DWORD *)(a10 + 8);
    float32x4_t v11 = vaddq_f32(v11, a3);
  }
  *(void *)a10 = v11.i64[0];
  *(_DWORD *)(a10 + _Block_object_dispose(&STACK[0x2A0], 8) = v11.i32[2];
  return result;
}

float *_C3DKeyFrameVector3Interpolator_discrete(float *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  if (a6)
  {
    float v7 = a7[1];
    *a7 = *result + *a7;
    a7[1] = result[1] + v7;
    a7[2] = result[2] + a7[2];
  }
  else
  {
    uint64_t v8 = *(void *)result;
    a7[2] = result[2];
    *(void *)a7 = v8;
  }
  return result;
}

uint64_t _C3DKeyFrameVector3Interpolator_cubic(uint64_t result, uint64_t a2, double a3, float32x4_t a4, float32x4_t a5, uint64_t a6, int32x2_t *a7, int32x2_t *a8, int a9, uint64_t a10)
{
  a4.i64[0] = *(void *)result;
  a4.i32[2] = *(_DWORD *)(result + 8);
  a5.i64[0] = *(void *)a2;
  a5.i32[2] = *(_DWORD *)(a2 + 8);
  double v10 = a3 * a3;
  double v11 = a3 * a3 * a3;
  double v12 = a3 * a3 * 3.0;
  float v13 = 1.0 - (v12 - v11 * 2.0);
  float v14 = v11 + a3 * a3 * -2.0 + a3;
  *(float *)&double v12 = v12 + v11 * -2.0;
  *(float *)&double v10 = v11 - v10;
  *(int32x2_t *)v15.f32 = vzip2_s32(*a7, a7[1]);
  *(int32x2_t *)&v15.u32[2] = vdup_lane_s32(a7[2], 1);
  *(int32x2_t *)v16.f32 = vzip2_s32(*a8, a8[1]);
  *(int32x2_t *)&v16.u32[2] = vdup_lane_s32(a8[2], 1);
  float32x4_t v17 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v15, v14), a4, v13), a5, *(float *)&v12), v16, *(float *)&v10);
  if (a9)
  {
    a4.i64[0] = *(void *)a10;
    a4.i32[2] = *(_DWORD *)(a10 + 8);
    float32x4_t v17 = vaddq_f32(v17, a4);
  }
  *(void *)a10 = v17.i64[0];
  *(_DWORD *)(a10 + _Block_object_dispose(&STACK[0x2A0], 8) = v17.i32[2];
  return result;
}

float *_C3DKeyFrameVector3Interpolator(float *result, uint64_t a2, int a3, int32x2_t *a4, int32x2_t *a5, int a6, float *a7, float32x4_t a8, float32x4_t a9, float32x4_t a10)
{
  if (a3)
  {
    if (a3 == 1)
    {
      if (a6)
      {
        float v10 = a7[1];
        *a7 = *result + *a7;
        a7[1] = result[1] + v10;
        a7[2] = result[2] + a7[2];
      }
      else
      {
        uint64_t v13 = *(void *)result;
        a7[2] = result[2];
        *(void *)a7 = v13;
      }
    }
    else
    {
      return (float *)_C3DKeyFrameVector3Interpolator_cubic((uint64_t)result, a2, *(double *)a8.i64, a9, a10, 0, a4, a5, a6, (uint64_t)a7);
    }
  }
  else
  {
    a9.i64[0] = *(void *)result;
    a9.f32[2] = result[2];
    a10.i64[0] = *(void *)a2;
    a10.i32[2] = *(_DWORD *)(a2 + 8);
    float v11 = *(double *)a8.i64;
    float32x4_t v12 = vmlaq_n_f32(a9, vsubq_f32(a10, a9), v11);
    if (a6)
    {
      a8.i64[0] = *(void *)a7;
      a8.f32[2] = a7[2];
      float32x4_t v12 = vaddq_f32(v12, a8);
    }
    *(void *)a7 = v12.i64[0];
    a7[2] = v12.f32[2];
  }
  return result;
}

float32x2_t *_C3DKeyFrameVector2Interpolator_linear(float32x2_t *result, float32x2_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x2_t *a8)
{
  float v8 = a3;
  float32x2_t v9 = vmla_n_f32(*result, vsub_f32(*a2, *result), v8);
  if (a7) {
    float32x2_t v9 = vadd_f32(v9, *a8);
  }
  *a8 = v9;
  return result;
}

float32x2_t *_C3DKeyFrameVector2Interpolator_discrete(float32x2_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x2_t *a7)
{
  float32x2_t v7 = *result;
  if (a6) {
    float32x2_t v7 = vadd_f32(v7, *a7);
  }
  *a7 = v7;
  return result;
}

float32x2_t *_C3DKeyFrameVector2Interpolator_cubic(float32x2_t *result, float32x2_t *a2, double a3, uint64_t a4, int32x2_t *a5, int32x2_t *a6, int a7, float32x2_t *a8)
{
  double v8 = a3 * a3;
  double v9 = a3 * a3 * a3;
  double v10 = a3 * a3 * 3.0;
  float v11 = 1.0 - (v10 - v9 * 2.0);
  float v12 = v9 + a3 * a3 * -2.0 + a3;
  float v13 = v10 + v9 * -2.0;
  float32x2_t v14 = vmla_n_f32(vmla_n_f32(vmul_n_f32((float32x2_t)vzip2_s32(*a5, a5[1]), v12), *result, v11), *a2, v13);
  float v15 = v9 - v8;
  float32x2_t v16 = vmla_n_f32(v14, (float32x2_t)vzip2_s32(*a6, a6[1]), v15);
  if (a7) {
    float32x2_t v16 = vadd_f32(v16, *a8);
  }
  *a8 = v16;
  return result;
}

float32x2_t *_C3DKeyFrameVector2Interpolator(float32x2_t *result, float32x2_t *a2, int a3, int32x2_t *a4, int32x2_t *a5, int a6, float32x2_t *a7, double a8)
{
  if (a3)
  {
    if (a3 == 1)
    {
      float32x2_t v8 = *result;
      if ((a6 & 1) == 0) {
        goto LABEL_7;
      }
    }
    else
    {
      double v10 = a8 * a8;
      double v11 = a8 * a8 * a8;
      double v12 = a8 * a8 * 3.0;
      double v13 = 1.0 - (v12 - v11 * 2.0);
      double v14 = v11 + a8 * a8 * -2.0 + a8;
      double v15 = v12 + v11 * -2.0;
      double v16 = v11 - v10;
      *(float *)&double v13 = v13;
      *(float *)&double v14 = v14;
      float32x2_t v17 = vmla_n_f32(vmul_n_f32((float32x2_t)vzip2_s32(*a4, a4[1]), *(float *)&v14), *result, *(float *)&v13);
      *(float *)&double v14 = v15;
      float32x2_t v18 = vmla_n_f32(v17, *a2, *(float *)&v14);
      *(float *)&double v14 = v16;
      float32x2_t v8 = vmla_n_f32(v18, (float32x2_t)vzip2_s32(*a5, a5[1]), *(float *)&v14);
      if (!a6) {
        goto LABEL_7;
      }
    }
    goto LABEL_6;
  }
  float v9 = a8;
  float32x2_t v8 = vmla_n_f32(*result, vsub_f32(*a2, *result), v9);
  if (a6) {
LABEL_6:
  }
    float32x2_t v8 = vadd_f32(v8, *a7);
LABEL_7:
  *a7 = v8;
  return result;
}

double _C3DKeyFrameMatrix4x4FastInterpolator_linear(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a7)
  {
    memset(v12, 0, sizeof(v12));
    float v9 = a3;
    C3DMatrix4x4Lerp(a1, a2, v12, v9);
    return C3DMatrix4x4Mult((uint64_t)v12, a8, a8);
  }
  else
  {
    float v11 = a3;
    *(void *)&double result = C3DMatrix4x4Lerp(a1, a2, a8, v11).u64[0];
  }
  return result;
}

__n128 _C3DKeyFrameMatrix4x4FastInterpolator_discrete(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  if (a6)
  {
    result.n128_f64[0] = C3DMatrix4x4Mult(a1, (float32x4_t *)a7, (_OWORD *)a7);
  }
  else
  {
    __n128 result = *(__n128 *)a1;
    long long v8 = *(_OWORD *)(a1 + 16);
    long long v9 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)(a7 + 32) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v9;
    *(__n128 *)a7 = result;
    *(_OWORD *)(a7 + 16) = v8;
  }
  return result;
}

double _C3DKeyFrameMatrix4x4FastInterpolator_cubic(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a7)
  {
    memset(v12, 0, sizeof(v12));
    float v9 = a3;
    C3DMatrix4x4Lerp(a1, a2, v12, v9);
    return C3DMatrix4x4Mult((uint64_t)v12, a8, a8);
  }
  else
  {
    float v11 = a3;
    *(void *)&double result = C3DMatrix4x4Lerp(a1, a2, a8, v11).u64[0];
  }
  return result;
}

__n128 _C3DKeyFrameMatrix4x4FastInterpolator(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, double a8)
{
  if (a3)
  {
    if (a3 == 1)
    {
      if (a6)
      {
        result.n128_f64[0] = C3DMatrix4x4Mult(a1, (float32x4_t *)a7, (_OWORD *)a7);
      }
      else
      {
        __n128 result = *(__n128 *)a1;
        long long v9 = *(_OWORD *)(a1 + 16);
        long long v10 = *(_OWORD *)(a1 + 48);
        *(_OWORD *)(a7 + 32) = *(_OWORD *)(a1 + 32);
        *(_OWORD *)(a7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v10;
        *(__n128 *)a7 = result;
        *(_OWORD *)(a7 + 16) = v9;
      }
    }
    else
    {
      result.n128_f64[0] = _C3DKeyFrameMatrix4x4FastInterpolator_cubic((float32x4_t *)a1, a2, a8, 0, a4, a5, a6, (float32x4_t *)a7);
    }
  }
  else
  {
    result.n128_f64[0] = _C3DKeyFrameMatrix4x4FastInterpolator_linear((float32x4_t *)a1, a2, a8, a3, a4, a5, a6, (float32x4_t *)a7);
  }
  return result;
}

void _C3DKeyFrameMatrix4x4Interpolator_linear(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a7)
  {
    memset(v11, 0, sizeof(v11));
    float v9 = a3;
    C3DMatrix4x4Interpolate(a1, a2, v11, v9);
    C3DMatrix4x4Mult((uint64_t)v11, a8, a8);
  }
  else
  {
    float v10 = a3;
    C3DMatrix4x4Interpolate(a1, a2, a8, v10);
  }
}

__n128 _C3DKeyFrameMatrix4x4Interpolator_discrete(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  if (a6)
  {
    result.n128_f64[0] = C3DMatrix4x4Mult(a1, (float32x4_t *)a7, (_OWORD *)a7);
  }
  else
  {
    __n128 result = *(__n128 *)a1;
    long long v8 = *(_OWORD *)(a1 + 16);
    long long v9 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)(a7 + 32) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v9;
    *(__n128 *)a7 = result;
    *(_OWORD *)(a7 + 16) = v8;
  }
  return result;
}

void _C3DKeyFrameMatrix4x4Interpolator_cubic(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a7)
  {
    memset(v11, 0, sizeof(v11));
    float v9 = a3;
    C3DMatrix4x4Interpolate(a1, a2, v11, v9);
    C3DMatrix4x4Mult((uint64_t)v11, a8, a8);
  }
  else
  {
    float v10 = a3;
    C3DMatrix4x4Interpolate(a1, a2, a8, v10);
  }
}

__n128 _C3DKeyFrameMatrix4x4Interpolator(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, double a8)
{
  if (a3)
  {
    if (a3 == 1)
    {
      if (a6)
      {
        result.n128_f64[0] = C3DMatrix4x4Mult(a1, (float32x4_t *)a7, (_OWORD *)a7);
      }
      else
      {
        __n128 result = *(__n128 *)a1;
        long long v9 = *(_OWORD *)(a1 + 16);
        long long v10 = *(_OWORD *)(a1 + 48);
        *(_OWORD *)(a7 + 32) = *(_OWORD *)(a1 + 32);
        *(_OWORD *)(a7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v10;
        *(__n128 *)a7 = result;
        *(_OWORD *)(a7 + 16) = v9;
      }
    }
    else
    {
      _C3DKeyFrameMatrix4x4Interpolator_cubic((float32x4_t *)a1, a2, a8, 0, a4, a5, a6, (float32x4_t *)a7);
    }
  }
  else
  {
    _C3DKeyFrameMatrix4x4Interpolator_linear((float32x4_t *)a1, a2, a8, a3, a4, a5, a6, (float32x4_t *)a7);
  }
  return result;
}

unsigned char *_C3DKeyFrameBoolInterpolator(unsigned char *result, unsigned char *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  if (a3 < 1.0) {
    a2 = result;
  }
  *a8 = *a2;
  return result;
}

unsigned __int8 *_C3DKeyFrameCharInterpolator_linear(unsigned __int8 *result, unsigned __int8 *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned char *a8)
{
  unsigned int v8 = *result;
  double v9 = (double)v8;
  double v10 = (double)v8 + (double)(int)(*a2 - v8) * a3;
  if (a7)
  {
    LOBYTE(v9) = *a8;
    double v10 = v10 + (double)*(unint64_t *)&v9;
  }
  *a8 = (int)v10;
  return result;
}

char *_C3DKeyFrameCharInterpolator_discrete(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned char *a7)
{
  char v7 = *result;
  if (a6) {
    v7 += *a7;
  }
  *a7 = v7;
  return result;
}

unsigned char *_C3DKeyFrameCharInterpolator_cubic(unsigned char *result, unsigned char *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned char *a8)
{
  *(double *)&unint64_t v8 = a3 * a3 * a3;
  double v9 = a3 * a3 * 3.0;
  double v10 = 1.0 - (v9 - *(double *)&v8 * 2.0);
  double v11 = *(double *)&v8 + a3 * a3 * -2.0;
  double v12 = v9 + *(double *)&v8 * -2.0;
  double v13 = *(double *)&v8 - a3 * a3;
  LOBYTE(v_Block_object_dispose(&STACK[0x2A0], 8) = *result;
  *(double *)&unint64_t v14 = (double)v8;
  double v15 = (v11 + a3) * *(float *)(a5 + 4) + v10 * *(double *)&v14;
  LOBYTE(v14) = *a2;
  double v16 = v15 + v12 * (double)v14 + v13 * *(float *)(a6 + 4);
  if (a7)
  {
    LOBYTE(v13) = *a8;
    double v16 = v16 + (double)*(unint64_t *)&v13;
  }
  *a8 = (int)v16;
  return result;
}

unsigned __int8 *_C3DKeyFrameCharInterpolator(unsigned __int8 *result, unsigned char *a2, int a3, uint64_t a4, uint64_t a5, int a6, unsigned char *a7, double a8)
{
  if (!a3)
  {
    unsigned int v9 = *result;
    double v10 = (double)v9;
    double v11 = (double)v9 + (double)(int)(*a2 - v9) * a8;
    if (a6)
    {
      LOBYTE(v10) = *a7;
      double v11 = v11 + (double)*(unint64_t *)&v10;
    }
    int v8 = (int)v11;
    goto LABEL_8;
  }
  if (a3 == 1)
  {
    LOBYTE(v_Block_object_dispose(&STACK[0x2A0], 8) = *result;
    if (a6) {
      LOBYTE(v_Block_object_dispose(&STACK[0x2A0], 8) = *a7 + v8;
    }
LABEL_8:
    *a7 = v8;
    return result;
  }
  return _C3DKeyFrameCharInterpolator_cubic(result, a2, a8, 0, a4, a5, a6, a7);
}

uint64_t C3DKeyFrameInterpolatorGetSemantic(double (*a1)(float32x4_t *a1, float32x4_t *a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, float32x4_t *a14))
{
  if (a1 == _C3DKeyFrameQuaternionInterpolator_linear
    || (char *)a1 == (char *)_C3DKeyFrameQuaternionInterpolator
    || (char *)a1 == (char *)_C3DKeyFrameQuaternionInterpolator_discrete)
  {
    return 3;
  }
  else
  {
    return 0;
  }
}

double C3DTimingFunctionSpring(float *a1, double a2, float a3)
{
  double v4 = a3 * a2;
  float v5 = a1[6];
  if (v5 >= 1.0)
  {
    double v6 = a1[8] + a1[10] * v4;
    double v9 = exp(-(v4 * a1[7]));
  }
  else
  {
    double v6 = exp(-(v4 * v5) * a1[7]);
    double v7 = a1[8];
    __double2 v8 = __sincos_stret(v4 * a1[9]);
    double v9 = v8.__sinval * a1[10] + v7 * v8.__cosval;
  }
  return 1.0 - v6 * v9;
}

double C3DTimingFunctionSolveCurve(float *a1, double a2)
{
  float v2 = a1[1];
  double v3 = *a1 * 3.0;
  double v4 = -(v3 - (float)(a1[2] - *a1) * 3.0);
  double v5 = 1.0 - v3 - v4;
  int v6 = 8;
  double v7 = a2;
  do
  {
    double v8 = v7 * (v3 + (v5 * v7 - (v3 - (float)(a1[2] - *a1) * 3.0)) * v7);
    if (vabdd_f64(v8, a2) < 0.001) {
      goto LABEL_13;
    }
    double v9 = v3 + (v4 + v4 + v5 * 3.0 * v7) * v7;
    if (fabs(v9) < 0.000001) {
      break;
    }
    double v7 = v7 - (v8 - a2) / v9;
    --v6;
  }
  while (v6);
  float v10 = 0.0;
  if (a2 >= 0.0)
  {
    float v10 = 1.0;
    double v11 = 1.0;
    if (a2 <= 1.0)
    {
      double v12 = 0.0;
      double v7 = a2;
      do
      {
        double v13 = v7 * (v3 + (v5 * v7 - (v3 - (float)(a1[2] - *a1) * 3.0)) * v7);
        if (vabdd_f64(v13, a2) < 0.001) {
          break;
        }
        if (v13 >= a2) {
          double v11 = v7;
        }
        else {
          double v12 = v7;
        }
        double v7 = v12 + (v11 - v12) * 0.5;
      }
      while (v12 < v11);
LABEL_13:
      float v10 = v7;
    }
  }
  double v14 = v2 * 3.0;
  double v15 = -(v14 - (float)(a1[3] - v2) * 3.0);
  return (v14 + (v15 + (1.0 - v14 - v15) * v10) * v10) * v10;
}

double C3DTimingFunctionCurve(uint64_t a1, double a2)
{
  return C3DTimingFunctionSolveCurve((float *)(a1 + 24), a2);
}

BOOL _C3DTimingFunctionInitWithPropertyList(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    double v5 = (double (*)(uint64_t, double))C3DTimingFunctionLinear;
LABEL_19:
    *(void *)(a1 + 16) = v5;
    return 1;
  }
  if (C3DCFTypeIsDictionary())
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"c0");
    if (Value)
    {
      CFNumberRef v8 = Value;
      CFTypeID v9 = CFGetTypeID(Value);
      if (v9 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v8, kCFNumberCGFloatType, &valuePtr);
        float v10 = valuePtr;
        *(float *)(a1 + 24) = v10;
      }
    }
    CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"c1");
    if (v11)
    {
      CFNumberRef v12 = v11;
      CFTypeID v13 = CFGetTypeID(v11);
      if (v13 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v12, kCFNumberCGFloatType, &valuePtr);
        float v14 = valuePtr;
        *(float *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = v14;
      }
    }
    CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"c2");
    if (v15)
    {
      CFNumberRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v16, kCFNumberCGFloatType, &valuePtr);
        float v18 = valuePtr;
        *(float *)(a1 + 32) = v18;
      }
    }
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"c3");
    if (v19)
    {
      CFNumberRef v20 = v19;
      CFTypeID v21 = CFGetTypeID(v19);
      if (v21 == CFNumberGetTypeID())
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v20, kCFNumberCGFloatType, &valuePtr);
        float v22 = valuePtr;
        *(float *)(a1 + 36) = v22;
      }
    }
    double v5 = C3DTimingFunctionCurve;
    goto LABEL_19;
  }
  float32x2_t v23 = scn_default_log();
  BOOL result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  if (result)
  {
    _C3DTimingFunctionInitWithPropertyList_cold_1(v23);
    return 0;
  }
  return result;
}

__CFString *_C3DTimingFunctionCopyPropertyList(uint64_t (**cf)())
{
  if (!cf)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DTimingFunctionCopyPropertyList_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (cf[2] == C3DTimingFunctionLinear) {
    return @"linear";
  }
  CFAllocatorRef v10 = CFGetAllocator(cf);
  uint64_t Mutable = CFDictionaryCreateMutable(v10, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  double valuePtr = *((float *)cf + 6);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"c0", v12);
  CFRelease(v12);
  double valuePtr = *((float *)cf + 7);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"c1", v13);
  CFRelease(v13);
  double valuePtr = *((float *)cf + 8);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"c2", v14);
  CFRelease(v14);
  double valuePtr = *((float *)cf + 9);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"c3", v15);
  CFRelease(v15);
  return (__CFString *)Mutable;
}

uint64_t _C3DTimingFunctionFinalizeDeserialization()
{
  return 1;
}

uint64_t C3DTimingFunctionCreateSpring(float a1, float a2, float a3, float a4)
{
  if (C3DTimingFunctionGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTimingFunctionGetTypeID_onceToken, &__block_literal_global_22);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DTimingFunctionGetTypeID_typeID, 0x20uLL);
  float v9 = sqrtf(a2 / a1);
  float v10 = sqrtf(a1 * a2);
  float v11 = a3 / (float)(v10 + v10);
  if (v11 >= 1.0)
  {
    float v13 = v9 - a4;
    float v12 = 0.0;
  }
  else
  {
    float v12 = v9 * sqrtf(1.0 - (float)(v11 * v11));
    float v13 = (float)-(float)(a4 - (float)(v11 * v9)) / v12;
  }
  *(float *)(result + 24) = v11;
  *(float *)(result + 2_Block_object_dispose(&STACK[0x2A0], 8) = v9;
  *(_DWORD *)(result + 32) = 1065353216;
  *(float *)(result + 36) = v12;
  *(float *)(result + 40) = v13;
  *(void *)(result + 16) = C3DTimingFunctionSpring;
  return result;
}

uint64_t C3DTimingFunctionCreateWithControlPoints(float a1, float a2, float a3, float a4)
{
  if (C3DTimingFunctionGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTimingFunctionGetTypeID_onceToken, &__block_literal_global_22);
  }
  uint64_t result = C3DTypeCreateInstance_(C3DTimingFunctionGetTypeID_typeID, 0x20uLL);
  *(float *)(result + 24) = a1;
  *(float *)(result + 2_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  *(float *)(result + 32) = a3;
  *(float *)(result + 36) = a4;
  *(void *)(result + 16) = C3DTimingFunctionCurve;
  return result;
}

uint64_t C3DTimingFunctionCreateWithPropertyList(const void *a1)
{
  if (C3DTimingFunctionGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTimingFunctionGetTypeID_onceToken, &__block_literal_global_22);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTimingFunctionGetTypeID_typeID, 0x20uLL);
  _C3DTimingFunctionInitWithPropertyList(Instance, a1);
  return Instance;
}

uint64_t C3DTimingFunctionGetControlPoints(uint64_t a1)
{
  if (!a1)
  {
    float v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTimingFunctionGetControlPoints_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 24;
}

uint64_t C3DTimingFunctionSolve(uint64_t a1, double a2, float a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DTimingFunctionGetControlPoints_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  return (*(uint64_t (**)(uint64_t, double, float))(a1 + 16))(a1, a2, a3);
}

CFStringRef _C3DTimingFunctionCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTimingFunction>");
}

CFStringRef _C3DTimingFunctionCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTimingFunction>");
}

void C3D::SSRDownSampleColorDepthPass::SSRDownSampleColorDepthPass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *uint64_t v5 = &unk_26BF6E5D0;
  v5[15] = a4;
}

const char *C3D::SSRDownSampleColorDepthPass::name(C3D::SSRDownSampleColorDepthPass *this)
{
  return "SSRDownSampleColorDepthPass";
}

uint64_t C3D::SSRDownSampleColorDepthPass::setup(C3D::SSRDownSampleColorDepthPass *this)
{
  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(this, 2u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 1u) + 64) = 2;
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 2u) + 64) = 2;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 2u) + _Block_object_dispose(&STACK[0x2A0], 8) = "BackDepth";
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 0);
  *(_WORD *)(v2 + 16) = **((_WORD **)this + 15);
  *(_WORD *)(v2 + 1_Block_object_dispose(&STACK[0x2A0], 8) = *(_WORD *)(*((void *)this + 15) + 2);
  C3D::Pass::parentColorDesc(this, (uint64_t)v7);
  if (v8 == 81)
  {
    __int16 v3 = 80;
  }
  else
  {
    C3D::Pass::parentColorDesc(this, (uint64_t)v5);
    __int16 v3 = v6;
  }
  *(_WORD *)(v2 + 2_Block_object_dispose(&STACK[0x2A0], 8) = v3;
  *(void *)(v2 + _Block_object_dispose(&STACK[0x2A0], 8) = "ColorDownSampled";
  *(unsigned char *)(v2 + 26) = 3;
  uint64_t result = C3D::PassDescriptor::outputAtIndex((C3D::SSRDownSampleColorDepthPass *)((char *)this + 32), 1u);
  *(_WORD *)(result + 16) = **((_WORD **)this + 15);
  *(_WORD *)(result + 1_Block_object_dispose(&STACK[0x2A0], 8) = *(_WORD *)(*((void *)this + 15) + 2);
  *(_WORD *)(result + 2_Block_object_dispose(&STACK[0x2A0], 8) = 65;
  *(void *)(result + _Block_object_dispose(&STACK[0x2A0], 8) = "DepthDownSampled";
  *(unsigned char *)(result + 26) = 3;
  return result;
}

uint64_t C3D::SSRDownSampleColorDepthPass::compile(C3D::SSRDownSampleColorDepthPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  int v3 = -[SCNMTLRenderContext reverseZ](RenderContext);
  char v7 = v3;
  uint64_t v4 = v3 | (2 * *(_DWORD *)(*((void *)this + 15) + 4));
  unint64_t v5 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::SSRDownSampleColorDepthPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v4) ^ ((0xC6A4A7935BD1E995 * v4) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47));
  *((void *)this + 14) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::SSRDownSampleColorDepthPass::execute(uint64_t *a1, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a1[2]);
  unint64_t v5 = *a2;
  __int16 v6 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  if ((void **)v5->_textures[0] != v6)
  {
    v5->_textures[0] = (MTLTexture *)v6;
    v5->_texturesToBind[0] |= 1uLL;
  }
  char v7 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
  if ((void **)v5->_textures[1] != v7)
  {
    v5->_textures[1] = (MTLTexture *)v7;
    v5->_texturesToBind[0] |= 2uLL;
  }
  __int16 v8 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 2u);
  if ((void **)v5->_textures[2] != v8)
  {
    v5->_textures[2] = (MTLTexture *)v8;
    v5->_texturesToBind[0] |= 4uLL;
  }
  uint64_t v9 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  if (v5->_textures[3] != v9)
  {
    v5->_textures[3] = v9;
    v5->_texturesToBind[0] |= 8uLL;
  }
  uint64_t v10 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 1u);
  if (v5->_textures[4] != v10)
  {
    v5->_textures[4] = v10;
    v5->_texturesToBind[0] |= 0x10uLL;
  }
  float32x2_t v24 = *(float32x2_t *)(a1[15] + 8);
  int v11 = -[SCNMTLRenderContext reverseZ](RenderContext);
  v12.f32[0] = vmuls_lane_f32(v24.f32[0], v24, 1);
  float v13 = v24.f32[0] - v24.f32[1];
  if (v11)
  {
    float v13 = v24.f32[1] - v24.f32[0];
    float v14 = v24.f32[1];
  }
  else
  {
    float v14 = v24.f32[0];
  }
  __asm { FMOV            V3.2S, #1.0 }
  _D3.f32[0] = v13;
  v12.f32[1] = v14;
  float32x2_t v25 = vdiv_f32(_D3, v12);
  SCNMTLComputeCommandEncoder::setBytes(v5, &v25, 8uLL, 0);
  CFNumberRef v20 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  uint64_t v21 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(a1[14] + 16);
  float v22 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v21);
  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v5, v20, v22);
}

void C3D::SSRDownSampleColorDepthPassResource::~SSRDownSampleColorDepthPassResource(C3D::SSRDownSampleColorDepthPassResource *this)
{
  *(void *)this = &unk_26BF6E6E0;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E6E0;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

void _C3DFXTechniqueCFFinalize(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(a1 + 80);
      *(void *)(*(void *)(v3 + 8 * v2) + 40) = 0;
      CFRelease(*(CFTypeRef *)(v3 + 8 * v2++));
    }
    while (v2 < *(void *)(a1 + 72));
  }
  uint64_t v4 = *(void **)(a1 + 80);
  if (v4) {
    free(v4);
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 120);
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), i) + 16) = 0;
    }
  }
  if ((*(unsigned char *)(a1 + 88) & 0x10) != 0) {
    _freeStorage(a1);
  }
  uint64_t v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 104);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 104) = 0;
  }
  int v11 = *(const void **)(a1 + 144);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 144) = 0;
  }
  float32x2_t v12 = *(const void **)(a1 + 152);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 152) = 0;
  }
  float v13 = *(void **)(a1 + 136);
}

void _freeStorage(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    if (*(void *)v2)
    {
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 16), (CFDictionaryApplierFunction)_releaseCFTypeParameters, *(void **)v2);
      uint64_t v2 = *(void *)(a1 + 96);
    }
    if (*(void *)(v2 + 16))
    {
      CFRelease(*(CFTypeRef *)(v2 + 16));
      uint64_t v2 = *(void *)(a1 + 96);
      *(void *)(v2 + 16) = 0;
    }
    if (*(void *)v2)
    {
      free(*(void **)v2);
      uint64_t v2 = *(void *)(a1 + 96);
    }
    free((void *)v2);
    *(void *)(a1 + 96) = 0;
  }
}

uint64_t C3DFXTechniqueCreateWithDescription(const void *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueCreateWithDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (C3DFXTechniqueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXTechniqueGetTypeID_onceToken, &__block_literal_global_23);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFXTechniqueGetTypeID_typeID, 0x90uLL);
  C3DFXTechniqueSetDescription(Instance, a1);
  C3DFXTechniqueSetOwner(Instance, a2);
  C3DFXTechniqueCompile(Instance);
  *(_DWORD *)(Instance + 92) = -1;
  return Instance;
}

CFTypeRef C3DFXTechniqueSetDescription(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueSetDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 104);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 104) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 104) = result;
  }
  return result;
}

void C3DFXTechniqueSetOwner(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueSetDescription_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 112) = a2;
}

uint64_t C3DFXTechniqueCompile(uint64_t a1)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueCompile_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 88) |= 1u;
  CFTypeRef cf = (CFTypeRef)C3DFXTechniqueGetOwner(a1);
  Description = (void *)C3DFXTechniqueGetDescription(a1);
  *(void *)(a1 + 144) = (id)[Description valueForKey:@"bundle"];
  *(void *)(a1 + 152) = (id)[Description valueForKey:@"metalLibraryName"];
  obuint64_t j = (id)[Description valueForKey:@"sequence"];
  CFDataRef v93 = (void *)[Description valueForKey:@"passes"];
  uint64_t size = [obj count];
  CFDictionaryRef v94 = (const __CFDictionary *)Description;
  uint64_t v11 = (void *)[Description valueForKey:@"symbols"];
  if (!*(void *)(a1 + 96))
  {
    *(void *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0x156481A9uLL);
    *(unsigned char *)(a1 + 88) |= 0x10u;
  }
  CFIndex v12 = objc_msgSend(v11, "count", cf);
  *(void *)(*(void *)(a1 + 96) + 16) = CFDictionaryCreateMutable(0, v12, MEMORY[0x263EFFF88], 0);
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  uint64_t v13 = [v11 countByEnumeratingWithState:&v100 objects:v107 count:16];
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = *(void *)v101;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v101 != v15) {
          objc_enumerationMutation(v11);
        }
        CFTypeID v17 = *(void **)(*((void *)&v100 + 1) + 8 * i);
        float v18 = (void *)[v11 valueForKey:v17];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if (![v18 valueForKey:@"semantic"])
          {
            CFNumberRef v19 = (__CFString *)[v18 valueForKey:@"type"];
            if (([(__CFString *)v19 isEqualToString:@"color"] & 1) == 0
              && ([(__CFString *)v19 isEqualToString:@"depth"] & 1) == 0)
            {
              unsigned __int8 v20 = C3DBaseTypeArraySizeFromString(v19);
              int v21 = C3DBaseTypeFromMetalOrGLSLString(v19);
              if (v21) {
                C3DFXTechniqueDeclareSymbol(a1, v17, v21, v20);
              }
            }
          }
        }
        else
        {
          float v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint8_t buf = 138412290;
            uint64_t v106 = (uint64_t)v17;
            _os_log_error_impl(&dword_20B249000, v22, OS_LOG_TYPE_ERROR, "Error: invalue description for input named %@ - expect a dictionary", buf, 0xCu);
          }
        }
      }
      uint64_t v14 = [v11 countByEnumeratingWithState:&v100 objects:v107 count:16];
    }
    while (v14);
  }
  if (!size)
  {
    if ([v93 count])
    {
      float32x2_t v25 = scn_default_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        C3DFXTechniqueCompile_cold_1();
      }
    }
    return 1;
  }
  *(void *)(a1 + 80) = malloc_type_calloc(8uLL, size, 0x2684F385uLL);
  *(void *)(a1 + 64) = size;
  if (cfa)
  {
    CFTypeID v23 = CFGetTypeID(cfa);
    if (v23 == C3DSceneGetTypeID())
    {
      uint64_t RootNode = C3DSceneGetRootNode((uint64_t)cfa);
    }
    else
    {
      CFTypeID v26 = CFGetTypeID(cfa);
      if (v26 == C3DNodeGetTypeID()) {
        uint64_t RootNode = (uint64_t)cfa;
      }
      else {
        uint64_t RootNode = 0;
      }
    }
  }
  else
  {
    uint64_t RootNode = 0;
  }
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  uint64_t v27 = [obj countByEnumeratingWithState:&v96 objects:v104 count:16];
  if (v27)
  {
    uint64_t v28 = v27;
    uint64_t v29 = 0;
    uint64_t v30 = *(void *)v97;
    do
    {
      for (uint64_t j = 0; j != v28; ++j)
      {
        if (*(void *)v97 != v30) {
          objc_enumerationMutation(obj);
        }
        CFStringRef v32 = *(const __CFString **)(*((void *)&v96 + 1) + 8 * j);
        uint64_t v33 = C3DFXPassCreate();
        C3DFXPassSetName(v33, v32);
        float32x2_t v34 = (void *)[v93 valueForKey:v32];
        C3DFXPassSetupWithPropertyList(v33, v34, v94);
        if (!C3DFXPassGetProgram(v33))
        {
          C3DFXPassSetProgramName(v33, (CFTypeRef)[v34 objectForKey:@"program"]);
          long long v35 = (const void *)[v34 objectForKey:@"metalLibraryFile"];
          if (v35) {
            C3DFXPassSetMetalLibraryName(v33, v35);
          }
          C3DFXPassSetMetalVertexShaderFunction(v33, (CFTypeRef)[v34 objectForKey:@"metalVertexShader"]);
          C3DFXPassSetMetalFragmentShaderFunction(v33, (CFTypeRef)[v34 objectForKey:@"metalFragmentShader"]);
          int v36 = (void *)[v34 objectForKey:@"clientProgram"];
          if (v36) {
            char v37 = [v36 BOOLValue];
          }
          else {
            char v37 = 1;
          }
          C3DFXPassSetClientProgram(v33, v37);
        }
        int v38 = *(_DWORD *)(v33 + 24);
        if (v38 == 6 || v38 == 3)
        {
          uint64_t v39 = *(void *)(v33 + 96);
          if (v39)
          {
            uint64_t Technique = C3DMaterialGetTechnique(v39);
            if (Technique)
            {
              uint64_t v41 = Technique;
              PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(Technique, 0);
              if (PassAtIndex) {
                C3DFXPassAddInputsWithDescription(PassAtIndex, (CFDictionaryRef)[v34 valueForKey:@"inputs"], v41);
              }
            }
          }
        }
        C3DFXPassAddInputsWithDescription(v33, (CFDictionaryRef)[v34 valueForKey:@"inputs"], a1);
        uint64_t v43 = objc_msgSend((id)-[__CFDictionary valueForKey:](v94, "valueForKey:", @"owners"), "objectAtIndex:", v29 + j);
        uint64_t NodeReference = _loadNodeReference(@"pointOfView", v34, a1, v43, RootNode, (const void **)(v33 + 504));
        if (NodeReference) {
          C3DFXPassSetPointOfView(v33, NodeReference);
        }
        unsigned int v45 = (const void *)_loadNodeReference(@"mirrorNode", v34, a1, v43, RootNode, (const void **)(v33 + 496));
        if (v45) {
          C3DFXPassSetMirrorNode(v33, v45);
        }
        int v46 = (const void *)_loadNodeReference(@"node", v34, a1, v43, RootNode, (const void **)(v33 + 488));
        if (v46) {
          C3DFXPassSetRootNode(v33, v46);
        }
        C3DFXPassAddOutputsWithDescription(v33, (CFDictionaryRef)[v34 valueForKey:@"outputs"], a1);
        C3DFXTechniqueAppendPass((void *)a1, (CFTypeRef)v33);
        CFRelease((CFTypeRef)v33);
      }
      uint64_t v28 = [obj countByEnumeratingWithState:&v96 objects:v104 count:16];
      v29 += j;
    }
    while (v28);
  }
  PassCFIndex Count = C3DFXTechniqueGetPassCount(a1);
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x263EFFFA0]);
  int v49 = Mutable;
  if (PassCount < 1)
  {
    CFRelease(Mutable);
    char v84 = *(unsigned char *)(a1 + 88);
    goto LABEL_130;
  }
  uint64_t v50 = 0;
  int v95 = 0;
  char v51 = 0;
  do
  {
    uint64_t v52 = C3DFXTechniqueGetPassAtIndex(a1, v50);
    uint64_t v53 = v52;
    if ((v51 & 1) == 0 && (v95 & 1) == 0)
    {
      uint64_t v54 = *(void *)(v52 + 520);
      if (v54 < 1) {
        goto LABEL_67;
      }
      char v51 = 0;
      int v55 = *(uint64_t **)(v52 + 512);
      do
      {
        uint64_t v56 = *v55++;
        v51 |= *(unsigned char *)(v56 + 80);
        --v54;
      }
      while (v54);
    }
    if (v51)
    {
      char v51 = 1;
      goto LABEL_68;
    }
LABEL_67:
    char v51 = 0;
    v95 |= *(unsigned __int8 *)(v52 + 186) >> 7;
LABEL_68:
    if (*(_DWORD *)(v52 + 440))
    {
      unint64_t v57 = 0;
      do
      {
        buf[0] = 0;
        unint64_t v58 = *(void *)(v53 + 432) + (v57 << 6);
        unsigned int v61 = *(_DWORD *)(v58 + 20);
        int64_t v60 = (_DWORD *)(v58 + 20);
        unsigned int v59 = v61;
        uint64_t v62 = *(const void **)(v60 - 3);
        if (v62)
        {
          if (v59 > 0x7FFFFFFD)
          {
            if (v59 == 0x7FFFFFFF) {
              unsigned int v63 = 0x7FFFFFFF;
            }
            else {
              unsigned int v63 = 2147483646;
            }
          }
          else
          {
            unsigned int v63 = _computeInputCountForOutputNamed(a1, v62, v50, buf, 0);
          }
          if ((C3DMetalIsUsed() & 1) == 0 && !*(_DWORD *)(*(void *)(v53 + 432) + (v57 << 6) + 16) && v63 >= 2)
          {
            *(unsigned char *)(v53 + 176) = 1;
            buf[0] = 0;
          }
          if (!CFSetContainsValue(v49, v62))
          {
            CFSetAddValue(v49, v62);
            *(_DWORD *)(*(void *)(v53 + 432) + (v57 << 6) + 20) = v63;
          }
          if (buf[0]) {
            *(_DWORD *)(v53 + 184) |= 0x10u;
          }
          if (v63 >= 2) {
            *(_DWORD *)(v53 + 184) |= 0x400000u;
          }
        }
        else
        {
          *int64_t v60 = v59 + 1;
          uint64_t v64 = v50 + 1;
          if (v50 + 1 < PassCount)
          {
            do
            {
              uint64_t v65 = C3DFXTechniqueGetPassAtIndex(a1, v64);
              uint64_t v66 = *(void *)(v65 + 520);
              if (v66 >= 1)
              {
                uint64_t v67 = *(void *)(v65 + 512);
                do
                {
                  if ((*(unsigned char *)(*(void *)v67 + 80) & 3) != 0) {
                    ++*(_DWORD *)(*(void *)(v53 + 432) + (v57 << 6) + 20);
                  }
                  v67 += 8;
                  --v66;
                }
                while (v66);
              }
              uint64_t v68 = *(unsigned int *)(v65 + 440);
              if (v68)
              {
                uint64_t v69 = (uint64_t *)(*(void *)(v65 + 432) + 8);
                LOBYTE(v70) = 1;
                do
                {
                  uint64_t v71 = *v69;
                  v69 += 8;
                  int v70 = (v71 != 0) & v70;
                  --v68;
                }
                while (v68);
              }
              else
              {
                int v70 = 1;
              }
              ++v64;
            }
            while (v64 < PassCount && v70);
          }
        }
        ++v57;
      }
      while (v57 < *(unsigned int *)(v53 + 440));
    }
    unsigned int v73 = *(_DWORD *)(v53 + 184);
    if ((v73 & 0x800010) == 0x800000)
    {
      buf[0] = 0;
      _computeInputCountForOutputNamed(a1, @"COLOR", v50, buf, 1);
      unsigned int v73 = *(_DWORD *)(v53 + 184) & 0xFFFFFFEF | (16 * buf[0]);
      *(_DWORD *)(v53 + 184) = v73;
    }
    if ((v73 & 0x400000) == 0)
    {
      if ((v73 & 0x800000) == 0) {
        goto LABEL_116;
      }
      uint64_t v74 = C3DFXTechniqueGetPassCount(a1);
      uint64_t v75 = v50 + 1;
      if (v50 + 1 >= v74)
      {
        unsigned int v73 = *(_DWORD *)(v53 + 184);
        if ((v73 & 0x1000000) == 0) {
          goto LABEL_121;
        }
      }
      else
      {
        uint64_t v76 = v74;
        BOOL v77 = 1;
        while (1)
        {
          uint64_t v78 = C3DFXTechniqueGetPassAtIndex(a1, v75);
          uint64_t v79 = *(void *)(v78 + 520);
          if (v79 >= 1) {
            break;
          }
LABEL_114:
          BOOL v77 = ++v75 < v76;
          if (v75 == v76) {
            goto LABEL_115;
          }
        }
        uint64_t v80 = *(void *)(v78 + 512);
        while ((*(unsigned char *)(*(void *)v80 + 80) & 1) == 0)
        {
          v80 += 8;
          if (!--v79) {
            goto LABEL_114;
          }
        }
LABEL_115:
        unsigned int v73 = *(_DWORD *)(v53 + 184);
        if (v77)
        {
LABEL_120:
          *(_DWORD *)(v53 + 184) = v73 | 0x400000;
          goto LABEL_125;
        }
LABEL_116:
        if ((v73 & 0x1000000) == 0)
        {
LABEL_121:
          if ((v73 & 0x1A00000) == 0x200000)
          {
            int v82 = scn_default_log();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
            {
              uint64_t Name = C3DFXPassGetName(v53);
              *(_DWORD *)uint8_t buf = 138412290;
              uint64_t v106 = Name;
              _os_log_impl(&dword_20B249000, v82, OS_LOG_TYPE_INFO, "Info: pass named %@ appears to be useless - skipping", buf, 0xCu);
            }
            C3DFXPassSetEnabled(v53, 0);
          }
          goto LABEL_125;
        }
      }
      BOOL IsConsumed = _depthIsConsumed(a1, v50);
      unsigned int v73 = *(_DWORD *)(v53 + 184);
      if (IsConsumed) {
        goto LABEL_120;
      }
      goto LABEL_121;
    }
LABEL_125:
    ++v50;
  }
  while (v50 != PassCount);
  CFRelease(v49);
  char v84 = *(unsigned char *)(a1 + 88);
  if (v95) {
    v84 |= 8u;
  }
LABEL_130:
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v84 | 4;
  if (size >= 1)
  {
    uint64_t v85 = C3DFXTechniqueGetPassAtIndex(a1, size - 1);
    if (v85)
    {
      if (*(unsigned char *)(v85 + 185))
      {
        if (C3DFXPassGetProgramIsOpaque(v85)) {
          char v87 = 4;
        }
        else {
          char v87 = 0;
        }
        char v86 = *(unsigned char *)(a1 + 88) & 0xFB | v87;
      }
      else
      {
        char v86 = *(unsigned char *)(a1 + 88) & 0xFB;
      }
      *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v86;
    }
  }
  return 1;
}

uint64_t C3DFXTechniqueCreateWithCapacity(size_t a1)
{
  if (C3DFXTechniqueGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXTechniqueGetTypeID_onceToken, &__block_literal_global_23);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFXTechniqueGetTypeID_typeID, 0x90uLL);
  if (a1) {
    uint64_t v3 = malloc_type_calloc(8uLL, a1, 0x1E39D3BEuLL);
  }
  else {
    uint64_t v3 = 0;
  }
  *(void *)(Instance + 80) = v3;
  *(void *)(Instance + 64) = a1;
  *(_DWORD *)(Instance + 92) = -1;
  return Instance;
}

uint64_t C3DFXTechniqueGetNullTechnique()
{
  uint64_t result = C3DFXTechniqueGetNullTechnique_nullT;
  if (!C3DFXTechniqueGetNullTechnique_nullT)
  {
    uint64_t result = C3DFXTechniqueCreateWithCapacity(0);
    C3DFXTechniqueGetNullTechnique_nullT = result;
  }
  return result;
}

void C3DFXTechniqueAppendPass(void *a1, CFTypeRef cf)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  CFIndex v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueAppendPass_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  if (a1[9] >= a1[8])
  {
    CFTypeID v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      C3DFXTechniqueAppendPass_cold_1(v23);
    }
  }
  else
  {
    CFTypeRef v20 = CFRetain(cf);
    uint64_t v22 = a1[9];
    uint64_t v21 = a1[10];
    a1[9] = v22 + 1;
    *(void *)(v21 + 8 * v22) = v20;
    *((void *)cf + 5) = a1;
  }
}

uint64_t C3DFXTechniqueGetPassCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 72);
}

uint64_t C3DFXTechniqueGetPassNamed(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 80) + 8 * v5) + 16);
    if (v6) {
      break;
    }
LABEL_6:
    if (++v5 >= v2) {
      return 0;
    }
  }
  if (!CFEqual(cf1, v6))
  {
    uint64_t v2 = *(void *)(a1 + 72);
    goto LABEL_6;
  }
  return *(void *)(*(void *)(a1 + 80) + 8 * v5);
}

uint64_t C3DFXTechniqueGetOwner(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueSetDescription_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 112);
}

uint64_t C3DFXTechniqueGetPassAtIndex(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 72) <= a2)
  {
    CFIndex v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueGetPassAtIndex_cold_1((uint64_t *)(a1 + 72), a2, v12);
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 8 * a2);
}

uint64_t C3DFXTechniqueGetDescription(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 104);
}

void C3DFXTechniqueDeclareSymbol(uint64_t a1, void *key, int a3, unsigned int a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueDeclareSymbol_cold_3(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  float32x2_t v24 = *(void **)(a1 + 96);
  if (!v24) {
    goto LABEL_11;
  }
  if (*v24)
  {
    float32x2_t v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueDeclareSymbol_cold_2(v25, v26, v27, v28, v29, v30, v31, v32);
    }
    float32x2_t v24 = *(void **)(a1 + 96);
    if (!v24)
    {
LABEL_11:
      float32x2_t v24 = malloc_type_calloc(0x18uLL, 1uLL, 0x156481A9uLL);
      *(void *)(a1 + 96) = v24;
      *(unsigned char *)(a1 + 88) |= 0x10u;
    }
  }
  CFDictionaryRef Mutable = (const __CFDictionary *)v24[2];
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], 0);
    *(void *)(*(void *)(a1 + 96) + 16) = Mutable;
  }
  if (CFDictionaryGetValue(Mutable, key))
  {
    float32x2_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueDeclareSymbol_cold_1((uint64_t)key, v34);
    }
  }
  long long v35 = *(uint64_t **)(a1 + 96);
  if (a3 == 5)
  {
    uint64_t v37 = *v35;
    uint64_t v36 = v35[1];
    unint64_t v38 = ((v37 + v36 + 7) & 0xFFFFFFFFFFFFFFF8) - (v37 + v36);
  }
  else
  {
    unint64_t v38 = 0;
    uint64_t v36 = v35[1];
  }
  uint64_t v39 = a4;
  int v40 = (const void *)(((v36 + v38) << 16) | ((unint64_t)a4 << 8) | a3 & 0x3F);
  unint64_t v41 = v38 + C3DSizeOfBaseType(a3) * v39;
  uint64_t v42 = *(void *)(a1 + 96);
  uint64_t v43 = *(__CFDictionary **)(v42 + 16);
  *(void *)(v42 + 8) += v41;
  CFDictionarySetValue(v43, key, v40);
}

void C3DFXTechniqueSetValueForSymbolWithCount(uint64_t a1, void *a2, const void *a3, int a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueSetValueForSymbolWithCount_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!*(void *)(a1 + 96))
  {
    *(void *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0x156481A9uLL);
    *(unsigned char *)(a1 + 88) |= 0x10u;
  }
  __CheckParametersStorage((void *)a1);
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 96) + 16), a2);
  if (Value)
  {
    uint64_t v25 = WORD1(Value);
    if ((Value & 0x3F) == 5)
    {
      if (a4 != 1 && (uint64_t v26 = scn_default_log(), os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)))
      {
        C3DFXTechniqueSetValueForSymbolWithCount_cold_3(v26, v27, v28, v29, v30, v31, v32, v33);
        if (a3)
        {
LABEL_13:
          CFTypeID v34 = CFGetTypeID(a3);
          if (v34 == C3DImageGetTypeID())
          {
            uint64_t TypeID = C3DImageGetTypeID();
            if (TypeID == CFGetTypeID(a3))
            {
              ValueForSymbol = (const void *)C3DFXTechniqueGetValueForSymbol(a1, a2, 0);
              if (!ValueForSymbol)
              {
                ValueForSymbol = (const void *)C3DFXSamplerCreate();
                C3DFXTechniqueSetValueForSymbolWithCount(a1, a2, ValueForSymbol, 1);
                CFRelease(ValueForSymbol);
              }
              C3DFXSamplerSetImage((uint64_t)ValueForSymbol, a3);
            }
            else
            {
              uint64_t v43 = scn_default_log();
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
                C3DFXTechniqueSetValueForSymbolWithCount_cold_2();
              }
            }
          }
          else
          {
            int v40 = *(uint64_t **)(a1 + 96);
            uint64_t v41 = *v40;
            uint64_t v42 = *(const void **)(*v40 + v25);
            if (v42 != a3)
            {
              if (v42)
              {
                CFRelease(v42);
                *(void *)(v41 + v25) = 0;
              }
              *(void *)(v41 + v25) = CFRetain(a3);
            }
          }
          return;
        }
      }
      else if (a3)
      {
        goto LABEL_13;
      }
      int v44 = *(uint64_t **)(a1 + 96);
      uint64_t v45 = *v44;
      int v46 = *(const void **)(*v44 + v25);
      if (v46)
      {
        CFRelease(v46);
        *(void *)(v45 + v25) = 0;
      }
    }
    else if (a3)
    {
      if (BYTE1(Value) >= a4) {
        int v38 = a4;
      }
      else {
        int v38 = BYTE1(Value);
      }
      uint64_t v39 = C3DSizeOfBaseType(Value & 0x3F);
      memcpy((void *)(**(void **)(a1 + 96) + v25), a3, v39 * v38);
    }
  }
  else
  {
    uint64_t v37 = scn_default_log();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      C3DFXTechniqueSetValueForSymbolWithCount_cold_1();
    }
  }
}

void *__CheckParametersStorage(void *result)
{
  CFAllocatorRef v1 = (void *)result[12];
  if (v1 && !*v1)
  {
    uint64_t v2 = result;
    uint64_t result = (void *)v1[1];
    if (result)
    {
      uint64_t result = malloc_type_calloc((size_t)result, 1uLL, 0x7DF6CA8DuLL);
      *(void *)v2[12] = result;
    }
  }
  return result;
}

uint64_t C3DFXTechniqueGetValueForSymbol(uint64_t a1, void *a2, _WORD *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueSetValueForSymbolWithCount_cold_4(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  __CheckParametersStorage((void *)a1);
  __int16 v25 = 0;
  uint64_t ValueOffsetForSymbol = C3DFXTechniqueGetValueOffsetForSymbol(a1, a2, &v25, 0);
  if (ValueOffsetForSymbol == -1) {
    return 0;
  }
  uint64_t v23 = ValueOffsetForSymbol;
  if (a3) {
    *a3 = v25;
  }
  __CheckParametersStorage((void *)a1);
  uint64_t result = **(void **)(a1 + 96) + v23;
  if (v25 == 5) {
    return *(void *)result;
  }
  return result;
}

void C3DFXTechniqueSetValueForSymbol(uint64_t a1, void *a2, const void *a3)
{
}

uint64_t C3DFXTechniqueGetValueOffsetForSymbol(uint64_t a1, void *key, _WORD *a3, BOOL *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueSetValueForSymbolWithCount_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t v24 = *(void *)(a1 + 96);
  if (v24
    && (CFDictionaryRef v25 = *(const __CFDictionary **)(v24 + 16)) != 0
    && (unint64_t Value = (unint64_t)CFDictionaryGetValue(v25, key),
        Value & 0xFFFFFFFF0000FFFFLL | ((unint64_t)WORD1(Value) << 16)))
  {
    char v27 = Value;
    uint64_t result = WORD1(Value);
    if (a3) {
      *a3 = v27 & 0x3F;
    }
    if (a4) {
      *a4 = (v27 & 0x40) != 0;
    }
  }
  else
  {
    uint64_t v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      C3DFXTechniqueGetValueOffsetForSymbol_cold_1();
    }
    return -1;
  }
  return result;
}

uint64_t C3DFXTechniqueGetValueAnimatableAddressForSymbol(uint64_t a1, void *a2, _WORD *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueSetValueForSymbolWithCount_cold_4(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  __CheckParametersStorage((void *)a1);
  __int16 v25 = 0;
  uint64_t ValueOffsetForSymbol = C3DFXTechniqueGetValueOffsetForSymbol(a1, a2, &v25, 0);
  if (ValueOffsetForSymbol == -1) {
    return 0;
  }
  uint64_t v23 = ValueOffsetForSymbol;
  if (a3) {
    *a3 = v25;
  }
  __CheckParametersStorage((void *)a1);
  return **(void **)(a1 + 96) + v23;
}

CFTypeRef C3DFXTechniqueCreateBySequencingTechniques(void *a1, uint64_t a2)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  uint64_t v50 = (void *)[MEMORY[0x263EFF980] array];
  int v49 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  uint64_t v3 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  uint64_t v4 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  uint64_t v5 = (void *)[MEMORY[0x263EFF980] array];
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  obuint64_t j = a1;
  uint64_t v6 = [a1 countByEnumeratingWithState:&v62 objects:v76 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)v63;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v63 != v9) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(void *)(*((void *)&v62 + 1) + 8 * i);
        if (*(void *)(v11 + 136)) {
          uint64_t v8 = *(const void **)(v11 + 136);
        }
        Descriptiouint64_t n = (void *)C3DFXTechniqueGetDescription(*(void *)(*((void *)&v62 + 1) + 8 * i));
        uint64_t v13 = (void *)[Description valueForKey:@"sequence"];
        [v50 addObjectsFromArray:v13];
        objc_msgSend(v49, "addEntriesFromDictionary:", objc_msgSend(Description, "valueForKey:", @"passes"));
        objc_msgSend(v3, "addEntriesFromDictionary:", objc_msgSend(Description, "valueForKey:", @"targets"));
        objc_msgSend(v4, "addEntriesFromDictionary:", objc_msgSend(Description, "valueForKey:", @"symbols"));
        uint64_t Owner = C3DFXTechniqueGetOwner(v11);
        if (!Owner) {
          uint64_t Owner = [MEMORY[0x263EFF9D0] null];
        }
        for (uint64_t j = [v13 count]; j; --j)
          [v5 addObject:Owner];
      }
      uint64_t v7 = [obj countByEnumeratingWithState:&v62 objects:v76 count:16];
    }
    while (v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  v74[0] = @"sequence";
  v74[1] = @"passes";
  v75[1] = v49;
  v75[2] = v3;
  v74[2] = @"targets";
  v74[3] = @"symbols";
  v74[4] = @"owners";
  v75[0] = v50;
  v75[3] = v4;
  v75[4] = v5;
  uint64_t v16 = (void *)C3DFXTechniqueCreateWithDescription((const void *)[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:5], a2);
  uint64_t v17 = (const void *)v16[17];
  if (v17 != v8)
  {
    if (v17)
    {
      CFRelease(v17);
      v16[17] = 0;
    }
    if (v8) {
      CFTypeRef v18 = CFRetain(v8);
    }
    else {
      CFTypeRef v18 = 0;
    }
    v16[17] = v18;
  }
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  uint64_t v19 = [obj countByEnumeratingWithState:&v58 objects:v73 count:16];
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = 0;
    uint64_t v51 = *(void *)v59;
    int v47 = &v72;
    do
    {
      for (uint64_t k = 0; k != v20; ++k)
      {
        if (*(void *)v59 != v51) {
          objc_enumerationMutation(obj);
        }
        uint64_t v23 = *(void **)(*((void *)&v58 + 1) + 8 * k);
        if ((uint64_t)v23[9] >= 1)
        {
          uint64_t v24 = 0;
          do
          {
            uint64_t v25 = *(void *)(v23[10] + 8 * v24);
            uint64_t v26 = *(void *)(v16[10] + 8 * v21);
            uint64_t v27 = *(void *)(v25 + 520);
            if (v27 != *(void *)(v26 + 520))
            {
              uint64_t v28 = scn_default_log();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
                C3DFXTechniqueCreateBySequencingTechniques_cold_3(v71, v47, v28);
              }
              uint64_t v27 = *(void *)(v25 + 520);
            }
            if (v27 >= 1)
            {
              for (uint64_t m = 0; m < v27; ++m)
              {
                uint64_t v30 = *(void *)(*(void *)(v25 + 512) + 8 * m);
                if (*(_DWORD *)(v30 + 16) == 3)
                {
                  uint64_t v31 = *(void **)(v30 + 96);
                  if (v31)
                  {
                    C3DFXPassInputSetBindingBlock(*(void *)(*(void *)(v26 + 512) + 8 * m), v31);
                    uint64_t v27 = *(void *)(v25 + 520);
                  }
                }
              }
            }
            if (*(void *)(v26 + 544))
            {
              uint64_t v32 = scn_default_log();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
                C3DFXTechniqueCreateBySequencingTechniques_cold_2(v69, &v70, v32);
              }
            }
            C3DFXPassSetInitializeBlock(v26, *(void **)(v25 + 544));
            if (*(void *)(v26 + 552))
            {
              uint64_t v33 = scn_default_log();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
                C3DFXTechniqueCreateBySequencingTechniques_cold_1(v67, &v68, v33);
              }
            }
            C3DFXPassSetExecuteBlock(v26, *(void **)(v25 + 552));
            *(_OWORD *)(v26 + 216) = *(_OWORD *)(v25 + 216);
            long long v34 = *(_OWORD *)(v25 + 232);
            long long v35 = *(_OWORD *)(v25 + 248);
            long long v36 = *(_OWORD *)(v25 + 264);
            *(void *)(v26 + 280) = *(void *)(v25 + 280);
            *(_OWORD *)(v26 + 264) = v36;
            *(_OWORD *)(v26 + 24_Block_object_dispose(&STACK[0x2A0], 8) = v35;
            *(_OWORD *)(v26 + 232) = v34;
            long long v37 = *(_OWORD *)(v25 + 392);
            long long v38 = *(_OWORD *)(v25 + 408);
            *(_DWORD *)(v26 + 424) = *(_DWORD *)(v25 + 424);
            *(_OWORD *)(v26 + 392) = v37;
            *(_OWORD *)(v26 + 40_Block_object_dispose(&STACK[0x2A0], 8) = v38;
            *(_OWORD *)(v26 + 200) = *(_OWORD *)(v25 + 200);
            ++v24;
            ++v21;
          }
          while (v24 < v23[9]);
        }
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        uint64_t v39 = *(void **)(v23[12] + 16);
        uint64_t v40 = objc_msgSend(v39, "countByEnumeratingWithState:objects:count:", &v54, v66, 16, v47);
        if (v40)
        {
          uint64_t v41 = v40;
          uint64_t v42 = *(void *)v55;
          do
          {
            for (uint64_t n = 0; n != v41; ++n)
            {
              if (*(void *)v55 != v42) {
                objc_enumerationMutation(v39);
              }
              int v44 = *(void **)(*((void *)&v54 + 1) + 8 * n);
              __int16 v53 = 0;
              ValueForSymbol = (const void *)C3DFXTechniqueGetValueForSymbol((uint64_t)v23, v44, &v53);
              if (ValueForSymbol) {
                C3DFXTechniqueSetValueForSymbolWithCount((uint64_t)v16, v44, ValueForSymbol, 1);
              }
            }
            uint64_t v41 = [v39 countByEnumeratingWithState:&v54 objects:v66 count:16];
          }
          while (v41);
        }
      }
      uint64_t v20 = [obj countByEnumeratingWithState:&v58 objects:v73 count:16];
    }
    while (v20);
  }
  return CFRetain(v16);
}

BOOL C3DFXTechniqueConsumesMainDepth(uint64_t a1)
{
  return _depthIsConsumed(a1, -1);
}

BOOL _depthIsConsumed(uint64_t a1, uint64_t a2)
{
  PassCFIndex Count = C3DFXTechniqueGetPassCount(a1);
  uint64_t v5 = a2 + 1;
  if (v5 >= PassCount)
  {
    return 0;
  }
  else
  {
    uint64_t v6 = PassCount;
    BOOL v7 = 1;
    while (1)
    {
      PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(a1, v5);
      uint64_t v9 = *(void *)(PassAtIndex + 520);
      if (v9 >= 1) {
        break;
      }
LABEL_7:
      BOOL v7 = ++v5 < v6;
      if (v5 == v6) {
        return v7;
      }
    }
    uint64_t v10 = *(void *)(PassAtIndex + 512);
    while ((*(unsigned char *)(*(void *)v10 + 80) & 2) == 0)
    {
      v10 += 8;
      if (!--v9) {
        goto LABEL_7;
      }
    }
  }
  return v7;
}

uint64_t _loadNodeReference(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t v10 = (void *)[a2 objectForKey:a1];
  if (!v10) {
    return 0;
  }
  uint64_t v11 = v10;
  if ([v10 isEqualToString:@"self"])
  {
    if (!a4)
    {
      return C3DFXTechniqueGetOwner(a3);
    }
    return a4;
  }
  if (!a5)
  {
    uint64_t v13 = *a6;
    if (*a6 != v11)
    {
      if (v13)
      {
        CFRelease(v13);
        *a6 = 0;
      }
      a4 = 0;
      *a6 = CFRetain(v11);
      return a4;
    }
    return 0;
  }

  return C3DNodeGetNodeWithName(a5, (uint64_t)v11);
}

uint64_t _computeInputCountForOutputNamed(uint64_t a1, const void *a2, uint64_t a3, unsigned char *a4, int a5)
{
  PassCFIndex Count = C3DFXTechniqueGetPassCount(a1);
  uint64_t v8 = a3 + 1;
  if (a3 + 1 >= PassCount)
  {
    LOBYTE(v11) = 0;
    LOBYTE(v10) = 0;
    uint64_t v12 = 1;
  }
  else
  {
    uint64_t v9 = PassCount;
    int v10 = 0;
    int v11 = 0;
    uint64_t v12 = 1;
    do
    {
      PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(a1, v8);
      if (*(uint64_t *)(PassAtIndex + 520) >= 1)
      {
        uint64_t v14 = 0;
        do
        {
          uint64_t v15 = *(const void **)(*(void *)(*(void *)(PassAtIndex + 512) + 8 * v14) + 56);
          if (v15 && CFEqual(v15, a2))
          {
            ++v12;
            v11 |= v10 ^ 1;
          }
          ++v14;
        }
        while (v14 < *(void *)(PassAtIndex + 520));
      }
      if (*(_DWORD *)(PassAtIndex + 440))
      {
        unint64_t v16 = 0;
        uint64_t v17 = 8;
        do
        {
          CFTypeRef v18 = *(const void **)(*(void *)(PassAtIndex + 432) + v17);
          if (v18 && CFEqual(v18, a2))
          {
            v10 |= v11 ^ 1;
            ++v12;
          }
          ++v16;
          v17 += 64;
        }
        while (v16 < *(unsigned int *)(PassAtIndex + 440));
      }
      ++v8;
    }
    while (v8 != v9);
  }
  if (a4)
  {
    if (a5) {
      char v19 = ~(_BYTE)v10;
    }
    else {
      char v19 = v11;
    }
    *a4 = v19 & 1;
  }
  return v12;
}

uint64_t C3DFXTechniqueIsBeingRendered(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 88) >> 1) & 1;
}

uint64_t C3DFXTechniqueIsOpaque(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

void C3DFXTechniqueSetIsOpaque(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 4;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned char *)(a1 + 88) & 0xFB | v12;
}

void C3DFXTechniqueAddSubTechnique(uint64_t a1, void *value)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (value) {
      goto LABEL_6;
    }
  }
  else if (value)
  {
    goto LABEL_6;
  }
  char v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DFXTechniqueAddSubTechnique_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef Mutable = *(__CFArray **)(a1 + 120);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    *(void *)(a1 + 120) = Mutable;
  }
  value[16] = a1;
  CFArrayAppendValue(Mutable, value);
}

uint64_t C3DFXTechniqueGetParentTechnique(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 128);
}

void C3DFXTechniqueAddSymbolWithBindingBlock(uint64_t a1, const void *a2, void *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)(*(void *)(a1 + 80) + 8 * v14);
      if (*(uint64_t *)(v15 + 520) >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          uint64_t v17 = *(void *)(*(void *)(v15 + 512) + 8 * v16);
          Symboluint64_t Name = (const void *)C3DFXPassInputGetSymbolName(v17);
          if (CFEqual(a2, SymbolName)) {
            C3DFXPassInputSetBindingBlock(v17, a3);
          }
          ++v16;
        }
        while (v16 < *(void *)(v15 + 520));
      }
      uint64_t Material = C3DFXPassGetMaterial(v15);
      if (Material)
      {
        uint64_t Technique = C3DMaterialGetTechnique(Material);
        if (Technique) {
          C3DFXTechniqueAddSymbolWithBindingBlock(Technique, a2, a3);
        }
      }
      ++v14;
    }
    while (v14 < *(void *)(a1 + 72));
  }
}

uint64_t C3DFXTechniqueCreateDefault(int a1, int a2)
{
  if (a2) {
    uint64_t v3 = @"C3DFXDefault_velocity.plist";
  }
  else {
    uint64_t v3 = @"C3DFXDefaultPass.plist";
  }
  uint64_t v4 = (const void *)C3DDictionaryNamed(v3);
  uint64_t v5 = C3DFXTechniqueCreateWithDescription(v4, 0);
  PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(v5, 0);
  if (a1) {
    *(unsigned char *)(PassAtIndex + 296) = 36;
  }
  return v5;
}

uint64_t C3DFXTechniqueEnsureThatPassesShouldExecute(uint64_t a1)
{
  uint64_t result = C3DFXTechniqueGetPassCount(a1);
  if (result >= 1)
  {
    uint64_t v3 = result;
    for (uint64_t i = 0; i != v3; ++i)
    {
      uint64_t result = C3DFXTechniqueGetPassAtIndex(a1, i);
      uint64_t v5 = *(uint64_t (**)(void))(result + 232);
      if (v5) {
        uint64_t result = v5();
      }
    }
  }
  return result;
}

BOOL C3DFXTechniqueMarkAsUsed(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL result = *(_DWORD *)(a1 + 92) != a2;
  *(_DWORD *)(a1 + 92) = a2;
  return result;
}

uint64_t C3DFXTechniqueGetSingleProgram(uint64_t result)
{
  if (result)
  {
    PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(result, 0);
    return C3DFXPassGetProgram(PassAtIndex);
  }
  return result;
}

void *C3DFXTechniqueSetParentTechnique(uint64_t a1, uint64_t a2)
{
  uint64_t Owner = C3DFXTechniqueGetOwner(a2);
  C3DFXTechniqueSetOwner(a1, Owner);
  C3DFXTechniqueCompile(a1);
  _freeStorage(a1);
  BOOL result = *(void **)(a2 + 96);
  if (!result)
  {
    BOOL result = malloc_type_calloc(0x18uLL, 1uLL, 0x156481A9uLL);
    *(void *)(a2 + 96) = result;
    *(unsigned char *)(a2 + 88) |= 0x10u;
  }
  *(void *)(a1 + 96) = result;
  *(unsigned char *)(a1 + 88) &= ~0x10u;
  return result;
}

void C3DFXTechniqueSetLibrary(uint64_t a1, void *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXTechniqueAppendPass_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void **)(a1 + 136);
  if (v12 != a2)
  {

    *(void *)(a1 + 136) = a2;
  }
}

void _releaseCFTypeParameters(uint64_t a1, int a2, uint64_t a3)
{
  if ((a2 & 0x3F) == 5)
  {
    uint64_t v3 = *(const void **)(a3 + HIWORD(a2));
    if (v3) {
      CFRelease(v3);
    }
  }
}

CFStringRef _C3DFXTechniqueCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFXTechnique>");
}

CFStringRef _C3DFXTechniqueCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DFXTechnique>");
}

__CFArray *_C3DFXTechniqueCopyInstanceVariables(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"pass %d", v4);
      uint64_t v6 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      int v16 = 2;
      int valuePtr = 5;
      uint64_t v15 = *(void *)(a1 + 80) + v3;
      CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
      CFNumberRef v9 = CFNumberCreate(0, kCFNumberLongType, &v15);
      CFDictionarySetValue(v6, @"name", v5);
      CFDictionarySetValue(v6, @"type", v7);
      CFDictionarySetValue(v6, @"address", v9);
      CFDictionarySetValue(v6, @"semantic", v8);
      CFArrayAppendValue(Mutable, v6);
      CFRelease(v8);
      CFRelease(v6);
      CFRelease(v9);
      CFRelease(v7);
      CFRelease(v5);
      ++v4;
      v3 += 8;
    }
    while (v4 < *(void *)(a1 + 72));
  }
  uint64_t v10 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v16 = 2;
  int valuePtr = 5;
  uint64_t v15 = a1 + 104;
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberLongType, &v15);
  CFDictionarySetValue(v10, @"name", @"plist");
  CFDictionarySetValue(v10, @"type", v11);
  CFDictionarySetValue(v10, @"address", v13);
  CFDictionarySetValue(v10, @"semantic", v12);
  CFArrayAppendValue(Mutable, v10);
  CFRelease(v12);
  CFRelease(v10);
  CFRelease(v13);
  CFRelease(v11);
  return Mutable;
}

void OUTLINED_FUNCTION_1_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void C3DAnimationStackInit(unsigned char *a1)
{
  if (*a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationStackInit_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *a1 = 1;
}

void C3DAnimationStackDiscardModelValueItemForAnimationClusterNode(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)&v18[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(*(void *)(*(void *)(a2 + 16) + 168) + 20);
  if (v4)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(a2 + 224);
    uint64_t v11 = 4 * v4;
    do
    {
      uint64_t v12 = *(int *)(v10 + v9);
      if (v12 != -1)
      {
        ValuePtrAtuint64_t Index = (uint64_t *)C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 56), v12);
        uint64_t v14 = *ValuePtrAtIndex;
        if (*ValuePtrAtIndex) {
          goto LABEL_8;
        }
        uint64_t v15 = scn_default_log();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerApplyStack_cold_2(v17, v18, v15);
        }
        uint64_t v14 = *ValuePtrAtIndex;
        if (*ValuePtrAtIndex)
        {
LABEL_8:
          int v16 = *(unsigned __int16 *)(v14 + 16);
          if (a4) {
            C3DModelValueStorageReleaseModelValueAndRestorePresentationValueIfNeeded(a3, v14);
          }
          else {
            C3DModelValueStorageReleaseModelValue(a3, v14);
          }
          if (v16 == 1) {
            *ValuePtrAtuint64_t Index = 0;
          }
        }
        uint64_t v10 = *(void *)(a2 + 224);
        *(_DWORD *)(v10 + v9) = -1;
      }
      v9 += 4;
    }
    while (v11 != v9);
  }
}

void C3DAnimationStackCleanup(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    *(unsigned char *)a1 = 0;
    for (uint64_t i = *(void **)(a1 + 8); i; uint64_t i = (void *)i[22])
    {
      if (*(unsigned char *)(a1 + 48))
      {
        uint64_t v5 = i[2];
        if (v5) {
          BOOL v6 = (*(_WORD *)(v5 + 84) & 0x20) == 0;
        }
        else {
          BOOL v6 = 1;
        }
        C3DAnimationStackDiscardModelValueItemForAnimationClusterNode(a1, (uint64_t)i, a2, v6);
      }
      i[19] = -1;
    }
    uint64_t v7 = *(const void **)(a1 + 56);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 56) = 0;
    }
    uint64_t v8 = *(const void **)(a1 + 8);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
    uint64_t v9 = *(const void **)(a1 + 24);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 24) = 0;
    }
  }
}

void C3DAnimationStackSetTarget(uint64_t a1, CFTypeRef cf)
{
  if (a1 || (uint64_t v4 = scn_default_log(), !os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    if (!cf) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  C3DAnimationStackSetTarget_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  if (cf) {
LABEL_4:
  }
    CFTypeRef cf = (CFTypeRef)C3DModelTargetCreateCopy((uint64_t)cf);
LABEL_5:
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 24);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 24) = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    *(void *)(a1 + 24) = v13;
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t C3DAnimationStackGetTarget(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationStackSetTarget_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void C3DAnimationStackAppendAnimationNode(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  *(void *)&v76[5] = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DAnimationStackSetTarget_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!*(unsigned char *)a1)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DAnimationStackAppendAnimationNode_cold_4(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  if (*(void *)(a1 + 8))
  {
    if (cf) {
      CFTypeRef v30 = CFRetain(cf);
    }
    else {
      CFTypeRef v30 = 0;
    }
    uint64_t v32 = *(void *)(a1 + 16);
    *(void *)(v32 + 176) = v30;
    *((void *)cf + 21) = v32;
  }
  else
  {
    if (cf) {
      CFTypeRef v31 = CFRetain(cf);
    }
    else {
      CFTypeRef v31 = 0;
    }
    *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = v31;
  }
  *(void *)(a1 + 16) = cf;
  C3DAnimationStackSetConstant(a1, 0, a3);
  if (*(unsigned char *)(a1 + 128))
  {
    unsigned int v33 = *(char *)(*((void *)cf + 3) + 34) - 3;
    if (v33 <= 5) {
      *((unsigned char *)cf + 120) = 0x70401020202uLL >> (8 * v33);
    }
  }
  if (*(unsigned char *)(a1 + 48))
  {
    CFTypeID v34 = CFGetTypeID(cf);
    if (v34 != C3DAnimationClusterNodeGetTypeID())
    {
      long long v35 = scn_default_log();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
        C3DAnimationStackAppendAnimationNode_cold_3(v35, v36, v37, v38, v39, v40, v41, v42);
      }
    }
    uint64_t ModelValueStorage = C3DAnimationManagerGetModelValueStorage(a3);
    if (!ModelValueStorage)
    {
      uint64_t v43 = scn_default_log();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
        C3DAnimationStackAppendAnimationNode_cold_2(v43, v44, v45, v46, v47, v48, v49, v50);
      }
    }
    uint64_t v51 = *((void *)cf + 2);
    uint64_t v52 = *(unsigned int *)(*(void *)(v51 + 168) + 20);
    if (!*(void *)(a1 + 56)) {
      *(void *)(a1 + 56) = C3DArrayCreate(24, *(_DWORD *)(*(void *)(v51 + 168) + 20));
    }
    *((void *)cf + 2_Block_object_dispose(&STACK[0x2A0], 8) = malloc_type_malloc(4 * v52, 0x100004052888210uLL);
    uint64_t Count = C3DArrayGetCount(*(void *)(a1 + 56));
    uint64_t Owner = (float32x4_t *)C3DAnimationNodeGetOwner((uint64_t)cf);
    if (v52)
    {
      uint64_t v54 = 0;
      uint64_t v70 = cf;
      uint64_t v71 = v52;
      uint64_t v72 = v51;
      do
      {
        long long v55 = (__int16 *)C3DCFTypeCopyModelInfoAtSplittedPath(Owner, *(const __CFArray **)(*(void *)(*(void *)(v51 + 168) + 72) + 8 * v54), 0, 0);
        if (!C3DModelTargetGetTargetAddress((uint64_t)v55))
        {
          *(_DWORD *)(*((void *)cf + 28) + 4 * v54) = -1;
          if (!v55) {
            goto LABEL_55;
          }
          goto LABEL_54;
        }
        uint64_t v56 = C3DModelValueStorageAddAndRetainModelValue(ModelValueStorage, v55);
        if (Count < 1) {
          goto LABEL_49;
        }
        uint64_t v57 = 0;
        uint64_t v58 = -1;
        uint64_t v59 = -1;
        do
        {
          ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 56), v57);
          if (*(void *)ValuePtrAtIndex)
          {
            if (v56 == *(void *)ValuePtrAtIndex)
            {
              uint64_t v61 = ValuePtrAtIndex;
              int v62 = *(unsigned __int8 *)(ValuePtrAtIndex + 8);
              if (v62 == C3DModelTargetGetTypeSemantic((uint64_t)v55))
              {
                int v63 = *(unsigned __int8 *)(v61 + 9);
                if (v63 == C3DModelTargetGetComponentIndex((uint64_t)v55))
                {
                  uint64_t v59 = v57;
                  uint64_t v57 = Count;
                }
              }
            }
          }
          else
          {
            uint64_t v58 = v57;
          }
          ++v57;
        }
        while (v57 < Count);
        if (v59 != -1)
        {
          CFTypeRef cf = v70;
          *(_DWORD *)(v70[28] + 4 * v54) = v59;
          goto LABEL_51;
        }
        CFTypeRef cf = v70;
        if (v58 == -1)
        {
LABEL_49:
          C3DArrayAppendValue(*(void *)(a1 + 56), 0);
          uint64_t v64 = Count + 1;
        }
        else
        {
          uint64_t v64 = Count;
          uint64_t Count = v58;
        }
        *(_DWORD *)(*((void *)cf + 28) + 4 * v54) = Count;
        uint64_t v65 = C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 56), Count);
        *(void *)uint64_t v65 = v56;
        *(unsigned char *)(v65 + _Block_object_dispose(&STACK[0x2A0], 8) = C3DModelTargetGetTypeSemantic((uint64_t)v55);
        *(unsigned char *)(v65 + 9) = C3DModelTargetGetComponentIndex((uint64_t)v55);
        Baseint Type = C3DModelTargetGetBaseType((uint64_t)v55);
        *(void *)(v65 + 16) = C3DKeyFrameInterpolatorForType(BaseType, *(char *)(v65 + 8), 0, 0, 1);
        uint64_t Count = v64;
LABEL_51:
        uint64_t v51 = v72;
        uint64_t v67 = *(unsigned __int8 *)(*(void *)(*(void *)(v72 + 168) + 40) + v54);
        BOOL v68 = C3DSizeOfBaseType(v55[16]) == v67;
        uint64_t v52 = v71;
        if (!v68)
        {
          uint64_t v69 = scn_default_log();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT)) {
            C3DAnimationStackAppendAnimationNode_cold_1(buf, v76, v69);
          }
        }
LABEL_54:
        CFRelease(v55);
LABEL_55:
        ++v54;
      }
      while (v54 != v52);
    }
  }
}

void C3DAnimationStackSetConstant(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DStackCFFinalize_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_4(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (*(unsigned __int8 *)(a1 + 241) != a2)
  {
    if (a2) {
      int v22 = 1;
    }
    else {
      int v22 = -1;
    }
    _C3DAnimationManagerUpdateConstantCount(a3, v22);
    *(unsigned char *)(a1 + 241) = a2;
  }
}

void C3DAnimationStackRemoveAnimationNode(uint64_t a1, void *cf)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DAnimationStackSetTarget_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t v20 = cf + 21;
  uint64_t v21 = cf[21];
  cf[19] = -1;
  if (v21) {
    *(void *)(v21 + 176) = cf[22];
  }
  uint64_t v22 = cf[22];
  if (v22) {
    *(void *)(v22 + 16_Block_object_dispose(&STACK[0x2A0], 8) = v21;
  }
  if (*(void **)(a1 + 8) == cf) {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = v22;
  }
  if (*(void **)(a1 + 16) == cf) {
    *(void *)(a1 + 16) = *v20;
  }
  *uint64_t v20 = 0;
  cf[22] = 0;
  CFRelease(cf);
}

BOOL C3DAnimationStackIsEmpty(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 8) == 0;
}

void C3DRendererContextSetPlatformSpecificImplementations_ES2(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v12 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 776) = C3DES2BindVertexArray;
  *(void *)(a1 + 784) = C3DES2GenVertexArrays;
  *(void *)(a1 + 792) = C3DES2DeleteVertexArrays;
  *(void *)(a1 + 80_Block_object_dispose(&STACK[0x2A0], 8) = C3DES2MapBufferRange;
  *(void *)(a1 + 816) = C3DES2FlushMappedBufferRange;
  *(void *)(a1 + 824) = C3DES2UnmapBufferRange;
  *(void *)(a1 + 832) = C3DES2RenderbufferStorageMultisample;
  *(void *)(a1 + 800) = C3DES2BlitFramebuffer;
  *(void *)(a1 + 76_Block_object_dispose(&STACK[0x2A0], 8) = C3DES2SlotToAttachmentID;
  *(_OWORD *)a1 = xmmword_20B5CC1C0;
  *(void *)(a1 + 16) = 0xFFFF0000800BLL;
  *(_DWORD *)(a1 + 24) = 0xFFFF;
  uint64_t v2 = (int32x2_t *)(a1 + 36);
  uint64_t v3 = a1 + 580;
  int32x2_t v4 = vdup_n_s32(0x1908u);
  int32x2_t v5 = vdup_n_s32(0x1907u);
  int32x2_t v6 = vdup_n_s32(0x1902u);
  int32x2_t v7 = vdup_n_s32(0x84F9u);
  do
  {
    if (v1 > 0x12u)
    {
      switch((char)v1)
      {
        case '$':
        case '\'':
          v2->i32[0] = 36193;
          v2[-1] = v4;
          *(_DWORD *)(v3 + 4 * v1) = 36193;
          goto LABEL_20;
        case '%':
        case '&':
        case '(':
        case '*':
        case '+':
          goto LABEL_16;
        case ')':
          v2->i32[0] = 5125;
          v2[-1] = v6;
          int v8 = 33190;
          goto LABEL_19;
        case ',':
          v2->i32[0] = 34042;
          v2[-1] = v7;
          *(_DWORD *)(v3 + 4 * v1) = 35056;
          goto LABEL_20;
        default:
          if (v1 == 55)
          {
            v2->i32[0] = 5123;
            v2[-1] = (int32x2_t)0x822700001907;
            int v8 = 33319;
          }
          else
          {
            if (v1 != 59)
            {
LABEL_16:
              v2->i32[0] = 0;
              v2[-1] = 0;
              *(_DWORD *)(v3 + 4 * v1) = 0;
              uint64_t v9 = scn_default_log();
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint8_t buf = 67109120;
                int v11 = v1;
                _os_log_impl(&dword_20B249000, v9, OS_LOG_TYPE_DEFAULT, "Warning: Unknown render buffer format %hhu", buf, 8u);
              }
              goto LABEL_20;
            }
            v2->i32[0] = 36193;
            v2[-1] = (int32x2_t)0x822700001907;
            int v8 = 33327;
          }
LABEL_19:
          *(_DWORD *)(v3 + 4 * v1) = v8;
          goto LABEL_20;
      }
    }
    switch((char)v1)
    {
      case 0:
        v2->i32[0] = 0xFFFF;
        v2[-1] = (int32x2_t)0xFFFF0000FFFFLL;
        *(_DWORD *)(v3 + 4 * v1) = 0xFFFF;
        break;
      case 1:
      case 2:
        v2->i32[0] = 5121;
        v2[-1] = v4;
        *(_DWORD *)(v3 + 4 * v1) = 32856;
        break;
      case 3:
        v2->i32[0] = 5121;
        v2[-1] = v5;
        int v8 = 33321;
        goto LABEL_19;
      case 11:
        v2->i32[0] = 36193;
        v2[-1] = (int32x2_t)0x190300001907;
        int v8 = 33325;
        goto LABEL_19;
      case 14:
        v2->i32[0] = 5126;
        v2[-1] = (int32x2_t)0x190300001907;
        int v8 = 33326;
        goto LABEL_19;
      default:
        goto LABEL_16;
    }
LABEL_20:
    ++v1;
    uint64_t v2 = (int32x2_t *)((char *)v2 + 12);
  }
  while (v1 != 46);
}

uint64_t C3DES2BindVertexArray()
{
  return MEMORY[0x270EF97E0]();
}

uint64_t C3DES2GenVertexArrays()
{
  return MEMORY[0x270EF9960]();
}

uint64_t C3DES2DeleteVertexArrays()
{
  return MEMORY[0x270EF98B8]();
}

uint64_t C3DES2MapBufferRange()
{
  return MEMORY[0x270EF9A18]();
}

uint64_t C3DES2FlushMappedBufferRange()
{
  return MEMORY[0x270EF9920]();
}

uint64_t C3DES2UnmapBufferRange()
{
  return MEMORY[0x270EF9B60]();
}

uint64_t C3DES2RenderbufferStorageMultisample()
{
  return MEMORY[0x270EF9A50]();
}

uint64_t C3DES2BlitFramebuffer()
{
  return glDiscardFramebufferEXT();
}

uint64_t C3DES2SlotToAttachmentID(int a1)
{
  switch(a1)
  {
    case 0:
      return 36064;
    case 5:
      return 36128;
    case 4:
      return 36096;
  }
  uint64_t v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    C3DES2SlotToAttachmentID_cold_1(v2);
  }
  return 0xFFFFLL;
}

void sub_20B32D3DC(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C4096E98722);
  _Unwind_Resume(a1);
}

void sub_20B32D56C(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C4096E98722);
  _Unwind_Resume(a1);
}

void SCNCPlaySound::SCNCPlaySound(SCNCPlaySound *this, SCNCAction *a2)
{
  SCNCAction::SCNCAction((SCNCAction *)this);
  *(void *)uint64_t v3 = &unk_26BF69660;
  *(void *)(v3 + 24) = a2->var3;
  *(double *)(v3 + 56) = a2->var7;
  *(_OWORD *)(v3 + 40) = *(_OWORD *)&a2->var5;
  *(_WORD *)(v3 + 80) = *(_WORD *)&a2->var10;
  *(double *)(v3 + 64) = a2->var8;
  *(void *)(v3 + 104) = a2->var14;
  *(unsigned char *)(v3 + 32) = 1;
  *(unsigned char *)(v3 + 144) = 0;
}

void SCNCPlaySound::~SCNCPlaySound(SCNCPlaySound *this)
{
  SCNCPlaySound::~SCNCPlaySound(this);

  JUMPOUT(0x210534FE0);
}

{
  uint64_t vars8;

  this->var0 = (void **)&unk_26BF69660;

  SCNCAction::~SCNCAction((SCNCAction *)this);
}

void SCNCPlaySound::cpp_updateWithTargetForTime(SCNCPlaySound *this, SCNNode *a2, double a3)
{
  SCNCAction::cpp_updateWithTargetForTime((SCNCAction *)this, a2, a3);
  if (!this->var19 && this->var21)
  {
    this->var19 = 1;
    [(SCNNode *)a2 addAudioPlayer:+[SCNAudioPlayer audioPlayerWithSource:](SCNAudioPlayer, "audioPlayerWithSource:")];
  }
  v6.n128_f32[0] = SCNCAction::cpp_ratioForTime((SCNCAction *)this, a3);
  if ((COERCE_UNSIGNED_INT(v6.n128_f32[0] + -1.0) & 0x60000000) == 0 || !this->var21)
  {
    v6.n128_f64[0] = a3;
    SCNCAction::didFinishWithTargetAtTime((SCNCAction *)this, a2, v6);
  }
}

SCNCAction *SCNCPlaySound::cpp_wasRemovedFromTargetAtTime(SCNCPlaySound *this, SCNNode *a2, double a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  BOOL result = SCNCAction::cpp_wasRemovedFromTargetAtTime((SCNCAction *)this, a2, a3);
  if (this->var20 && this->var19)
  {
    if (this->var21)
    {
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      __n128 v6 = [(SCNNode *)a2 audioPlayers];
      BOOL result = (SCNCAction *)[(NSArray *)v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (result)
      {
        int32x2_t v7 = result;
        uint64_t v8 = *(void *)v12;
        while (2)
        {
          uint64_t v9 = 0;
          do
          {
            if (*(void *)v12 != v8) {
              objc_enumerationMutation(v6);
            }
            uint64_t v10 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v9);
            if ((id)[v10 audioSource] == this->var21) {
              return (SCNCAction *)[(SCNNode *)a2 removeAudioPlayer:v10];
            }
            uint64_t v9 = (SCNCAction *)((char *)v9 + 1);
          }
          while (v7 != v9);
          BOOL result = (SCNCAction *)[(NSArray *)v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
          int32x2_t v7 = result;
          if (result) {
            continue;
          }
          break;
        }
      }
    }
  }
  return result;
}

SCNCAction *SCNCPlaySound::cpp_willStartWithTargetAtTime(SCNCPlaySound *this, SCNNode *a2, double a3)
{
  BOOL result = SCNCAction::cpp_willStartWithTargetAtTime((SCNCAction *)this, a2, a3);
  this->var19 = 0;
  return result;
}

uint64_t SCNCPlaySound::cpp_didFinishWithTargetAtTime(SCNCPlaySound *this, SCNNode *a2, double a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = SCNCAction::cpp_didFinishWithTargetAtTime((SCNCAction *)this, a2, a3);
  if (this->var20 && this->var19)
  {
    if (this->var21)
    {
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      __n128 v6 = [(SCNNode *)a2 audioPlayers];
      uint64_t result = [(NSArray *)v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (result)
      {
        uint64_t v7 = result;
        uint64_t v8 = *(void *)v12;
        while (2)
        {
          uint64_t v9 = 0;
          do
          {
            if (*(void *)v12 != v8) {
              objc_enumerationMutation(v6);
            }
            uint64_t v10 = *(void **)(*((void *)&v11 + 1) + 8 * v9);
            if ((id)[v10 audioSource] == this->var21) {
              return [(SCNNode *)a2 removeAudioPlayer:v10];
            }
            ++v9;
          }
          while (v7 != v9);
          uint64_t result = [(NSArray *)v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
          uint64_t v7 = result;
          if (result) {
            continue;
          }
          break;
        }
      }
    }
  }
  return result;
}

void sub_20B32DC68(_Unwind_Exception *a1)
{
  SCNCAction::~SCNCAction(v1);
  _Unwind_Resume(a1);
}

double scn_matrix_compute_normal(double _D0, __n128 _Q1, __n128 a3)
{
  _S7 = a3.n128_u32[2];
  _S3 = _Q1.n128_u32[2];
  __asm
  {
    FMLA            S5, S7, V1.S[1]
    FMLA            S17, S7, V0.S[1]
    FMLA            S16, S3, V0.S[1]
  }
  float v12 = vmlas_n_f32(vmlas_n_f32(-(float)(_Q1.n128_f32[0] * _S17), _S5, *(float *)&_D0), _S16, a3.n128_f32[0]);
  if (v12 == 0.0)
  {
    long long v13 = *MEMORY[0x263EF89A8];
  }
  else
  {
    float v14 = 1.0 / v12;
    *(float *)&long long v13 = _S5 * v14;
    *((float *)&v13 + 1) = -(float)((float)((float)(a3.n128_f32[0] * (float)-_Q1.n128_f32[2])
                                          + (float)(_Q1.n128_f32[0] * a3.n128_f32[2]))
                                  * v14);
  }
  return *(double *)&v13;
}

double scn_matrix_fast_invert(int32x4_t a1, int32x4_t a2, int32x4_t a3, int32x4_t a4)
{
  int32x4_t v4 = vzip1q_s32(a1, a3);
  int32x4_t v5 = vzip2q_s32(a1, a3);
  int32x4_t v6 = vzip1q_s32(a2, a4);
  int32x4_t v7 = vzip2q_s32(a2, a4);
  float32x4_t v8 = (float32x4_t)vzip1q_s32(v4, v6);
  float32x4_t v9 = (float32x4_t)vzip2q_s32(v4, v6);
  float32x4_t v10 = (float32x4_t)vzip1q_s32(v5, v7);
  int8x16_t v11 = (int8x16_t)vzip2q_s32(v5, v7);
  _Q3 = (float32x4_t)vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL);
  _Q4 = (float32x4_t)vextq_s8(v11, v11, 8uLL);
  float32x4_t v14 = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v10, _Q4));
  float32x4_t v15 = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v10, _Q3));
  float32x4_t v16 = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v9, _Q4));
  float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL);
  float32x4_t v18 = vmlsq_f32(vmlaq_f32(vmlsq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v14, vnegq_f32(_Q3)), (float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), _Q3), v15, _Q4), (float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), _Q4), v16, v17), (float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), v17);
  _Q2 = (int8x16_t)vmulq_f32(v8, v18);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, (float32x2_t)*(_OWORD *)&vextq_s8(_Q2, _Q2, 8uLL));
  _Q3.i32[0] = vadd_f32(*(float32x2_t *)_Q2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q2.i8, 1)).u32[0];
  *(float *)_Q2.i32 = vaddv_f32(*(float32x2_t *)_Q2.i8);
  *(float32x2_t *)_Q4.f32 = vrecpe_f32((float32x2_t)_Q3.u32[0]);
  *(float32x2_t *)_Q4.f32 = vmul_f32(*(float32x2_t *)_Q4.f32, vrecps_f32((float32x2_t)_Q3.u32[0], *(float32x2_t *)_Q4.f32));
  *(float32x2_t *)_Q3.f32 = vmul_f32(*(float32x2_t *)_Q4.f32, vrecps_f32((float32x2_t)_Q3.u32[0], *(float32x2_t *)_Q4.f32));
  _Q3.i32[0] = vmul_f32(*(float32x2_t *)_Q3.f32, *(float32x2_t *)_Q3.f32).u32[0];
  __asm { FMLS            S4, S2, V3.S[0] }
  *(void *)&double result = vmulq_n_f32(v18, _Q4.f32[0]).u64[0];
  return result;
}

simd_float4 scn_matrix_multiply_batch(simd_float4x4 *a1, const simd_float4x4 *a2, const simd_float4x4 *a3, unsigned int a4)
{
  if (a4)
  {
    int32x4_t v4 = &a3->columns[2];
    int32x4_t v5 = &a2->columns[2];
    int32x4_t v6 = &a1->columns[2];
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = (float32x4_t)v5[-2];
      float32x4_t v9 = (float32x4_t)v5[-1];
      float32x4_t v10 = *(float32x4_t *)v5;
      float32x4_t v11 = (float32x4_t)v5[1];
      v5 += 4;
      float32x4_t v12 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v4[-2].f32[0]), v9, v4[-2].f32[1]), v10, v4[-2].f32[2]), v11, v4[-2].f32[3]);
      float32x4_t v13 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v4[-1].f32[0]), v9, v4[-1].f32[1]), v10, v4[-1].f32[2]), v11, v4[-1].f32[3]);
      float32x4_t v14 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v4->f32[0]), v9, v4->f32[1]), v10, v4->f32[2]), v11, v4->f32[3]);
      simd_float4 result = (simd_float4)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v4[1].f32[0]), v9, v4[1].f32[1]), v10, v4[1].f32[2]), v11, v4[1].f32[3]);
      v6[-2] = (simd_float4)v12;
      v6[-1] = (simd_float4)v13;
      simd_float4 *v6 = (simd_float4)v14;
      v6[1] = result;
      v6 += 4;
      v4 += 4;
      --v7;
    }
    while (v7);
  }
  return result;
}

float32x4_t *scn_matrix_multiply_batch(float32x4_t *result, simd_float4x4 a2, const simd_float4x4 *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    int32x4_t v5 = &a3->columns[2];
    int32x4_t v6 = result + 2;
    do
    {
      v6[-2] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a2.columns[0], v5[-2].f32[0]), (float32x4_t)a2.columns[1], v5[-2].f32[1]), (float32x4_t)a2.columns[2], v5[-2].f32[2]), (float32x4_t)a2.columns[3], v5[-2].f32[3]);
      v6[-1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a2.columns[0], v5[-1].f32[0]), (float32x4_t)a2.columns[1], v5[-1].f32[1]), (float32x4_t)a2.columns[2], v5[-1].f32[2]), (float32x4_t)a2.columns[3], v5[-1].f32[3]);
      float32x4_t *v6 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a2.columns[0], v5->f32[0]), (float32x4_t)a2.columns[1], v5->f32[1]), (float32x4_t)a2.columns[2], v5->f32[2]), (float32x4_t)a2.columns[3], v5->f32[3]);
      v6[1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a2.columns[0], v5[1].f32[0]), (float32x4_t)a2.columns[1], v5[1].f32[1]), (float32x4_t)a2.columns[2], v5[1].f32[2]), (float32x4_t)a2.columns[3], v5[1].f32[3]);
      v5 += 4;
      v6 += 4;
      --v4;
    }
    while (v4);
  }
  return result;
}

int32x4_t scn_matrix_transpose_batch(uint64_t a1, int32x4_t *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v4 = (float *)(a1 + 32);
    int32x4_t v5 = a2 + 2;
    do
    {
      int32x4_t v6 = v5[-2];
      int32x4_t v7 = v5[-1];
      int32x4_t v8 = *v5;
      int32x4_t v9 = v5[1];
      v5 += 4;
      float32x4_t v10 = v4 - 8;
      float32x2x2_t v11 = (float32x2x2_t)vzip1q_s32(v6, v8);
      v14.val[0] = (float32x2_t)vzip2q_s32(v6, v8).u64[0];
      int32x4_t v12 = vzip1q_s32(v7, v9);
      v14.val[1] = (float32x2_t)vzip2q_s32(v7, v9).u64[0];
      int32x4_t result = vzip2q_s32((int32x4_t)v11, v12);
      vst2_f32(v10, v11);
      *((int32x4_t *)v4 - 1) = result;
      vst2_f32(v4, v14);
      v4 += 12;
      --v3;
    }
    while (v3);
  }
  return result;
}

float32_t scn_triangle_point_distance_squared(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a4, a1);
  float32x4_t v6 = vsubq_f32(a3, a2);
  float32x4_t v7 = vsubq_f32(a4, a2);
  float32x4_t v8 = vsubq_f32(a1, a3);
  float32x4_t v9 = vsubq_f32(a4, a3);
  float32x4_t v10 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL);
  float32x4_t v12 = vnegq_f32(v4);
  float32x4_t v13 = vmlaq_f32(vmulq_f32(v11, v12), v8, v10);
  float32x4_t v14 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL);
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL);
  int32x4_t v16 = (int32x4_t)vmlaq_f32(vmulq_f32(v15, v12), v14, v10);
  int32x4_t v17 = (int32x4_t)vmlaq_f32(vmulq_f32(v15, vnegq_f32(v6)), v14, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL));
  int32x4_t v18 = (int32x4_t)vmlaq_f32(vmulq_f32(v15, vnegq_f32(v8)), v14, v11);
  int32x4_t v19 = (int32x4_t)vmulq_f32(v5, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL));
  int32x4_t v20 = (int32x4_t)vmulq_f32(v7, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v17, v17), (int8x16_t)v17, 0xCuLL));
  int32x4_t v21 = (int32x4_t)vmulq_f32(v9, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL));
  int32x4_t v22 = (int32x4_t)vmulq_f32(v5, v14);
  int32x4_t v23 = vzip1q_s32(v19, v21);
  int32x4_t v24 = vzip2q_s32(v19, v21);
  int32x4_t v25 = vzip1q_s32(v20, v22);
  float32x4_t v26 = vaddq_f32((float32x4_t)vzip1q_s32(v24, vzip2q_s32(v20, v22)), vaddq_f32((float32x4_t)vzip1q_s32(v23, v25), (float32x4_t)vzip2q_s32(v23, v25)));
  int32x4_t v27 = (int32x4_t)vmulq_f32(v4, v4);
  int32x4_t v28 = (int32x4_t)vmulq_f32(v6, v6);
  int32x4_t v29 = (int32x4_t)vmulq_f32(v8, v8);
  int32x4_t v30 = (int32x4_t)vmulq_f32(v13, v13);
  int32x4_t v31 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v30, v30), (int8x16_t)v30, 0xCuLL);
  int32x4_t v32 = vzip1q_s32(v27, v29);
  int32x4_t v33 = vzip2q_s32(v27, v29);
  int32x4_t v34 = vzip1q_s32(v28, v31);
  float32x4_t v35 = vaddq_f32((float32x4_t)vzip1q_s32(v33, vzip2q_s32(v28, v31)), vaddq_f32((float32x4_t)vzip1q_s32(v32, v34), (float32x4_t)vzip2q_s32(v32, v34)));
  v28.i64[0] = 0x8000000080000000;
  v28.i64[1] = 0x8000000080000000;
  int8x16_t v36 = vandq_s8((int8x16_t)v26, (int8x16_t)v28);
  __asm { FMOV            V16.4S, #1.0 }
  float32x4_t v42 = (float32x4_t)vandq_s8(vorrq_s8(v36, (int8x16_t)_Q16), vorrq_s8((int8x16_t)vcltzq_f32(v26), (int8x16_t)vcgtzq_f32(v26)));
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0] >= 2.0)
  {
    v60.i32[0] = vdivq_f32(vmulq_f32(v26, v26), v35).i32[3];
  }
  else
  {
    int32x4_t v43 = (int32x4_t)vmulq_f32(v4, v5);
    int32x4_t v44 = (int32x4_t)vmulq_f32(v6, v7);
    int32x4_t v45 = (int32x4_t)vmulq_f32(v8, v9);
    int32x4_t v46 = vzip2q_s32(v43, v45);
    float32x4_t v47 = (float32x4_t)vzip1q_s32(vzip1q_s32(v43, v45), v44);
    float32x4_t v48 = (float32x4_t)vtrn2q_s32(v43, v44);
    v48.i32[2] = v45.i32[1];
    float32x4_t v49 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v46, vdupq_laneq_s32(v44, 2)), vaddq_f32(v47, v48)), v35);
    v49.i32[3] = v49.i32[2];
    float32x4_t v50 = vminq_f32(vmaxq_f32(v49, (float32x4_t)0), _Q16);
    float32x4_t v51 = vmlaq_n_f32(vnegq_f32(v5), v4, v50.f32[0]);
    float32x4_t v52 = vmlaq_lane_f32(vnegq_f32(v7), v6, *(float32x2_t *)v50.f32, 1);
    float32x4_t v53 = vmlaq_laneq_f32(vnegq_f32(v9), v8, v50, 2);
    int32x4_t v54 = (int32x4_t)vmulq_f32(v51, v51);
    int32x4_t v55 = (int32x4_t)vmulq_f32(v52, v52);
    int32x4_t v56 = (int32x4_t)vmulq_f32(v53, v53);
    int32x4_t v57 = vzip2q_s32(v54, v56);
    float32x4_t v58 = (float32x4_t)vzip1q_s32(vzip1q_s32(v54, v56), v55);
    float32x4_t v59 = (float32x4_t)vtrn2q_s32(v54, v55);
    v59.i32[2] = v56.i32[1];
    float32x4_t v60 = vaddq_f32((float32x4_t)vzip1q_s32(v57, vdupq_laneq_s32(v55, 2)), vaddq_f32(v58, v59));
    float v61 = v60.f32[1];
    if (v60.f32[0] <= v60.f32[1]) {
      float v61 = v60.f32[0];
    }
    v60.i32[0] = v60.i32[2];
    if (v61 <= v60.f32[2]) {
      v60.f32[0] = v61;
    }
  }
  return v60.f32[0];
}

BOOL scn_plane_intersect_3_planes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7)
{
  v7.i64[0] = a1;
  v7.i64[1] = a2;
  v8.i64[0] = a3;
  v8.i64[1] = a4;
  v9.i64[0] = a5;
  v9.i64[1] = a6;
  float32x4_t v10 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL)));
  int32x2_t v11 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u64[0];
  if (*(float *)v11.i32 != 0.0)
  {
    float32x4_t v12 = v7;
    v12.f32[0] = -*((float *)&a2 + 1);
    int32x4_t v13 = v8;
    *(float *)v13.i32 = -*((float *)&a4 + 1);
    int32x4_t v14 = v9;
    *(float *)v14.i32 = -*((float *)&a6 + 1);
    float32x4_t v15 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), (int8x16_t)v14, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v13, v13), (int8x16_t)v13, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL), (int8x16_t)v13, 8uLL));
    float32x4_t v16 = v7;
    v16.f32[1] = -*((float *)&a2 + 1);
    int32x4_t v17 = v8;
    *(float *)&v17.i32[1] = -*((float *)&a4 + 1);
    int32x4_t v18 = v9;
    *(float *)&v18.i32[1] = -*((float *)&a6 + 1);
    int32x4_t v19 = (int32x4_t)vmulq_f32(v12, v15);
    int32x4_t v20 = (int32x4_t)vmulq_f32(v16, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v18, (int8x16_t)v18, 0xCuLL), (int8x16_t)v18, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v17, v17), (int8x16_t)v17, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v17, (int8x16_t)v17, 0xCuLL), (int8x16_t)v17, 8uLL)));
    *(float32x2_t *)v16.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v19.i8, *(int32x2_t *)v20.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v19.i8, *(int32x2_t *)v20.i8));
    float32x4_t v21 = (float32x4_t)vzip2q_s32(v19, v20);
    *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)v21.f32, *(float32x2_t *)v16.f32);
    v7.f32[2] = -*((float *)&a2 + 1);
    *(float *)&v8.i32[2] = -*((float *)&a4 + 1);
    *(float *)&v9.i32[2] = -*((float *)&a6 + 1);
    float32x4_t v22 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL)));
    v21.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).u32[0];
    *a7 = vdivq_f32(v21, (float32x4_t)vdupq_lane_s32(v11, 0));
  }
  return *(float *)v11.i32 != 0.0;
}

uint64_t scn_frustum_classify_aabb(float32x4_t *a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3 = a1[1];
  float32x4_t v4 = a1[2];
  float32x4_t v5 = a1[3];
  int32x4_t v6 = (int32x4_t)vmulq_f32(a2, *a1);
  int32x4_t v7 = (int32x4_t)vmulq_f32(a2, v3);
  int32x4_t v8 = (int32x4_t)vmulq_f32(a2, v4);
  int32x4_t v9 = (int32x4_t)vmulq_f32(a2, v5);
  int32x4_t v10 = vzip1q_s32(v6, v8);
  int32x4_t v11 = vzip2q_s32(v6, v8);
  int32x4_t v12 = vzip1q_s32(v7, v9);
  int32x4_t v13 = vzip2q_s32(v7, v9);
  float32x4_t v14 = vaddq_f32((float32x4_t)vzip2q_s32(v11, v13), vaddq_f32((float32x4_t)vzip1q_s32(v11, v13), vaddq_f32((float32x4_t)vzip1q_s32(v10, v12), (float32x4_t)vzip2q_s32(v10, v12))));
  int32x4_t v15 = (int32x4_t)vmulq_f32(a3, vabsq_f32(*a1));
  int32x4_t v16 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v3));
  int32x4_t v17 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v4));
  int32x4_t v18 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v5));
  int32x4_t v19 = vzip1q_s32(v15, v17);
  int32x4_t v20 = vzip2q_s32(v15, v17);
  int32x4_t v21 = vzip1q_s32(v16, v18);
  int32x4_t v22 = vzip2q_s32(v16, v18);
  int8x16_t v23 = (int8x16_t)vmaxnmq_f32(vsubq_f32(vabsq_f32(v14), vaddq_f32((float32x4_t)vzip2q_s32(v20, v22), vaddq_f32((float32x4_t)vzip1q_s32(v20, v22), vaddq_f32((float32x4_t)vzip1q_s32(v19, v21), (float32x4_t)vzip2q_s32(v19, v21))))), (float32x4_t)0);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  float32x4_t v24 = (float32x4_t)vbslq_s8((int8x16_t)v22, (int8x16_t)v14, v23);
  if ((vmaxvq_u32((uint32x4_t)vcltzq_f32(v24)) & 0x80000000) != 0) {
    return 1;
  }
  float32x4_t v26 = a1[4];
  float32x4_t v25 = a1[5];
  int32x4_t v27 = (int32x4_t)vmulq_f32(a2, v26);
  int32x4_t v28 = (int32x4_t)vmulq_f32(a2, v25);
  int8x16_t v29 = (int8x16_t)vzip1q_s32(v27, v28);
  int8x16_t v30 = (int8x16_t)vzip2q_s32(v27, v28);
  *(float32x2_t *)v30.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), vadd_f32(*(float32x2_t *)v30.i8, vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL))));
  int32x4_t v31 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v26));
  int32x4_t v32 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v25));
  int8x16_t v33 = (int8x16_t)vzip1q_s32(v31, v32);
  int8x16_t v34 = (int8x16_t)vzip2q_s32(v31, v32);
  float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)0x8000000080000000, *(int8x8_t *)v30.i8, (int8x8_t)vmaxnm_f32(vsub_f32(vabs_f32(*(float32x2_t *)v30.i8), vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), vadd_f32(*(float32x2_t *)v34.i8, vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL))))), 0));
  *(int32x2_t *)v34.i8 = vcltz_f32(v35);
  if ((vpmax_u32(*(uint32x2_t *)v34.i8, *(uint32x2_t *)v34.i8).u32[0] & 0x80000000) != 0) {
    return 1;
  }
  *(float32x2_t *)v36.f32 = vmul_f32(*(float32x2_t *)v24.f32, v35);
  v36.i64[1] = vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL).u64[0];
  return (vmaxvq_u32((uint32x4_t)vceqzq_f32(v36)) >> 30) & 2;
}

double scn_triangle_barycentric_coordinates(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a3, a1);
  float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v5, (int8x16_t)v5, 0xCuLL), (int8x16_t)v5, 8uLL), vnegq_f32(v4)), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL), (int8x16_t)v4, 8uLL), v5);
  float32x4_t v7 = vmulq_f32(v6, v6);
  int32x2_t v8 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u64[0];
  if (fabsf(*(float *)v8.i32) >= 1.1755e-38)
  {
    float32x4_t v14 = vsubq_f32(a3, a4);
    float32x4_t v15 = vsubq_f32(a2, a4);
    float32x4_t v16 = vsubq_f32(a1, a4);
    float32x4_t v17 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v15, (int8x16_t)v15, 0xCuLL), (int8x16_t)v15, 8uLL);
    float32x4_t v18 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), (int8x16_t)v14, 8uLL);
    float32x4_t v19 = vmlaq_f32(vmulq_f32(v18, vnegq_f32(v15)), v17, v14);
    float32x4_t v20 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v16, (int8x16_t)v16, 0xCuLL), (int8x16_t)v16, 8uLL);
    float32x4_t v21 = vmlaq_f32(vmulq_f32(v20, vnegq_f32(v14)), v18, v16);
    float32x4_t v22 = vmlaq_f32(vmulq_f32(v17, vnegq_f32(v16)), v20, v15);
    int32x4_t v23 = (int32x4_t)vmulq_f32(v6, v19);
    int32x4_t v24 = (int32x4_t)vmulq_f32(v6, v21);
    _Q0 = (int32x4_t)vmulq_f32(v6, v22);
    int32x4_t v25 = vzip2q_s32(v23, _Q0);
    float32x4_t v26 = (float32x4_t)vzip1q_s32(vzip1q_s32(v23, _Q0), v24);
    float32x4_t v27 = (float32x4_t)vtrn2q_s32(v23, v24);
    v27.i32[2] = _Q0.i32[1];
    _Q0.i64[0] = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v25, vdupq_laneq_s32(v24, 2)), vaddq_f32(v26, v27)), (float32x4_t)vdupq_lane_s32(v8, 0)).u64[0];
  }
  else
  {
    __asm { FMOV            V0.4S, #-1.0 }
  }
  return *(double *)_Q0.i64;
}

uint64_t C3DKeyframedAnimationCreate()
{
  if (C3DKeyframedAnimationGetTypeID_onceToken != -1) {
    dispatch_once(&C3DKeyframedAnimationGetTypeID_onceToken, &__block_literal_global_24);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DKeyframedAnimationGetTypeID_typeID, 0xA0uLL);
  C3DAnimationCommonInit(Instance);
  return Instance;
}

float C3DKeyframedAnimationSetController(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    float32x4_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 168);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 16_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
    if (cf) {
      CFTypeRef cf = CFRetain(cf);
    }
    *(void *)(a1 + 16_Block_object_dispose(&STACK[0x2A0], 8) = cf;
  }
  float result = *(float *)(a1 + 72);
  if (result == 0.0 && cf != 0)
  {
    float Duration = C3DKeyframeControllerGetDuration((uint64_t)cf);
    C3DAnimationSetDuration(a1, Duration);
  }
  return result;
}

uint64_t C3DKeyframedAnimationGetController(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 168);
}

uint64_t C3DKeyframedAnimationEvaluate(uint64_t a1, int a2, uint64_t a3, double a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DKeyframedAnimationEvaluate_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  float32x4_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationEvaluate_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t result = *(void *)(a1 + 168);
  if (result)
  {
    double v25 = C3DKeyframeControllerGetDuration(result) * a4;
    uint64_t v26 = *(void *)(a1 + 168);
    uint64_t Additive = C3DAnimationGetAdditive(a1);
    return C3DKeyframeControllerEvaluateAtTime(v26, a2, Additive, a3, v25);
  }
  return result;
}

uint64_t C3DKeyframedAnimationSetup(uint64_t a1)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Controller = C3DKeyframedAnimationGetController(a1);
  if (Controller)
  {
    uint64_t v11 = Controller;
    if (C3DKeyframeControllerGetCalculationMode(Controller) == 1
      || C3DKeyframeControllerGetDuration(v11) == 0.0)
    {
      *(double *)v12.i64 = C3DAnimationGetDuration(a1);
      C3DKeyframeControllerSetupKeyTimesForPacedMode(v11, v12, v13);
    }
    Keyuint64_t Count = C3DKeyframeControllerGetKeyCount(v11);
    if (*(unsigned char *)(v11 + 114))
    {
      unsigned int v15 = KeyCount;
      ValueComponentuint64_t Count = C3DKeyframeControllerGetValueComponentCount(v11);
      memset(__dst, 0, sizeof(__dst));
      if (v15)
      {
        unsigned int v16 = 0;
        do
        {
          unsigned int v17 = v16;
          KeyTimeAtuint64_t Index = C3DKeyframeControllerGetKeyTimeAtIndex(v11, v16++);
          if (v16 >= v15)
          {
            double v19 = KeyTimeAtIndex + KeyTimeAtIndex - C3DKeyframeControllerGetKeyTimeAtIndex(v11, v17 - 1);
            if (!v17)
            {
LABEL_15:
              double v20 = KeyTimeAtIndex - (C3DKeyframeControllerGetKeyTimeAtIndex(v11, v16) - KeyTimeAtIndex);
              goto LABEL_16;
            }
          }
          else
          {
            double v19 = C3DKeyframeControllerGetKeyTimeAtIndex(v11, v16);
            if (!v17) {
              goto LABEL_15;
            }
          }
          double v20 = C3DKeyframeControllerGetKeyTimeAtIndex(v11, v17 - 1);
LABEL_16:
          TensionAtuint64_t Index = C3DKeyframeControllerGetTensionAtIndex(v11, v17);
          ContinuityAtuint64_t Index = C3DKeyframeControllerGetContinuityAtIndex(v11, v17);
          BiasAtuint64_t Index = C3DKeyframeControllerGetBiasAtIndex(v11, v17);
          OutTangentsAtuint64_t Index = C3DKeyframeControllerGetOutTangentsAtIndex(v11, v17);
          uint64_t v25 = C3DKeyframeControllerGetInTangentsAtIndex(v11, v17);
          if (ValueComponentCount)
          {
            uint64_t v26 = v25;
            uint64_t v27 = 0;
            double v28 = KeyTimeAtIndex - v20;
            double v29 = v19 - KeyTimeAtIndex;
            double v30 = v19 - KeyTimeAtIndex + KeyTimeAtIndex - v20;
            double v31 = (v19 - KeyTimeAtIndex) / v30;
            double v32 = (KeyTimeAtIndex - v20) / v30;
            float v33 = (float)(1.0 - TensionAtIndex) * (float)(ContinuityAtIndex + 1.0);
            double v34 = v31 * (float)(v33 * (float)(BiasAtIndex + 1.0));
            float v35 = (float)(1.0 - TensionAtIndex) * (float)(1.0 - ContinuityAtIndex);
            double v36 = v31 * (float)(v35 * (float)(1.0 - BiasAtIndex));
            double v37 = v32 * (float)(v35 * (float)(BiasAtIndex + 1.0));
            double v38 = v32 * (float)(v33 * (float)(1.0 - BiasAtIndex));
            *(float *)&double v32 = v29 * v36 + v34 * v28;
            *(float *)&double v28 = v29 * v38 + v37 * v28;
            unsigned int v47 = LODWORD(v28);
            unsigned int v48 = LODWORD(v32);
            do
            {
              C3DKeyframeControllerGetValueAtIndex(v11, v17, __dst);
              float v39 = *((float *)__dst + v27);
              if (v16 >= v15)
              {
                C3DKeyframeControllerGetValueAtIndex(v11, v17 - 1, __dst);
                float v40 = v39 + (float)(v39 - *((float *)__dst + v27));
              }
              else
              {
                C3DKeyframeControllerGetValueAtIndex(v11, v16, __dst);
                float v40 = *((float *)__dst + v27);
              }
              if (v17)
              {
                C3DKeyframeControllerGetValueAtIndex(v11, v17 - 1, __dst);
                float v41 = *((float *)__dst + v27);
              }
              else
              {
                C3DKeyframeControllerGetValueAtIndex(v11, v16, __dst);
                float v41 = v39 - (float)(*((float *)__dst + v27) - v39);
              }
              double v42 = (float)(v39 - v41);
              double v43 = (float)(v40 - v39);
              *(float *)&unsigned int v44 = v36 * v43 + v34 * v42;
              *(void *)(OutTangentsAtIndex + 8 * v27) = __PAIR64__(v44, v48);
              *(float *)&double v42 = v38 * v43 + v37 * v42;
              *(void *)(v26 + 8 * v27++) = __PAIR64__(LODWORD(v42), v47);
            }
            while (ValueComponentCount != v27);
          }
        }
        while (v16 != v15);
      }
    }
  }
  else
  {
    C3DKeyframeControllerGetKeyCount(0);
  }
  return 1;
}

float C3DKeyframedAnimationCopy(uint64_t a1, uint64_t a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DKeyframedAnimationCopy_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float32x4_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DKeyframedAnimationCopy_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t Controller = (const void *)C3DKeyframedAnimationGetController(a1);
  return C3DKeyframedAnimationSetController(a2, Controller);
}

id _C3DKeyframedAnimationCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[21];
  if (v2)
  {
    CFRelease(v2);
    a1[21] = 0;
  }

  return _C3DAnimationCFFinalize(a1);
}

CFStringRef _C3DKeyframedAnimationCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DKeyframedAnimation %p>", a1);
}

CFStringRef _C3DKeyframedAnimationCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DKeyframedAnimation %p>", a1);
}

uint64_t _C3DKeyframedAnimationInitWithPropertyList(uint64_t a1, CFTypeRef cf, const __CFDictionary *a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFTypeID v16 = CFGetTypeID(cf);
  if (v16 == CFDictionaryGetTypeID())
  {
    unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"keyframeController");
    if (Value)
    {
      uint64_t result = (uint64_t)C3DKeyframeControllerCreateWithPropertyList((uint64_t)Value, (uint64_t)a3, a4);
      if (!result) {
        return result;
      }
      uint64_t v19 = (const void *)result;
      C3DKeyframedAnimationSetController(a1, (CFTypeRef)result);
      CFRelease(v19);
    }
    else
    {
      uint64_t v21 = scn_default_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        _C3DKeyframedAnimationInitWithPropertyList_cold_1(v21);
      }
    }
    _C3DAnimationInitWithPropertyList(a1, (const __CFDictionary *)cf, a3);
    return 1;
  }
  else
  {
    double v20 = scn_default_log();
    uint64_t result = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (result)
    {
      _C3DKeyframedAnimationInitWithPropertyList_cold_2(v20);
      return 0;
    }
  }
  return result;
}

__CFDictionary *_C3DKeyframedAnimationCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  CFTypeID v16 = _C3DAnimationCopyPropertyList(a1, a2, a3, a4);
  CFDictionaryAddValue(v16, @"type", @"keyframedAnimation");
  uint64_t v17 = *(const void **)(a1 + 168);
  if (v17)
  {
    uint64_t v18 = (const void *)C3DCopyPropertyList(v17, a2, a3, a4);
    CFDictionaryAddValue(v16, @"keyframeController", v18);
    CFRelease(v18);
  }
  return v16;
}

uint64_t SCNPassInitialize(uint64_t *a1)
{
  if (!gPassContext) {
    gPassContext = objc_alloc_init(SCNPassContext);
  }
  InitializeBlocuint64_t k = C3DFXPassGetInitializeBlock(*a1);
  *(void *)(gPassContext + _Block_object_dispose(&STACK[0x2A0], 8) = a1;
  uint64_t v3 = *(uint64_t (**)(void))(InitializeBlock + 16);

  return v3();
}

uint64_t SCNPassExecute(uint64_t *a1)
{
  if (!gPassContext) {
    gPassContext = objc_alloc_init(SCNPassContext);
  }
  ExecuteBlocuint64_t k = C3DFXPassGetExecuteBlock(*a1);
  *(void *)(gPassContext + _Block_object_dispose(&STACK[0x2A0], 8) = a1;
  uint64_t v3 = *(uint64_t (**)(void))(ExecuteBlock + 16);

  return v3();
}

uint64_t C3DAnimationPlayerCreateWithAnimation(const void *a1)
{
  if (C3DAnimationPlayerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationPlayerGetTypeID_onceToken, &__block_literal_global_25);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DAnimationPlayerGetTypeID_typeID, 0x50uLL);
  if (Instance)
  {
    *(void *)(Instance + 72) = CFArrayCreateMutable(0, 1, MEMORY[0x263EFFF70]);
    uint64_t v3 = *(const void **)(Instance + 64);
    if (v3 != a1)
    {
      if (v3)
      {
        CFRelease(v3);
        *(void *)(Instance + 64) = 0;
      }
      if (a1) {
        CFTypeRef v4 = CFRetain(a1);
      }
      else {
        CFTypeRef v4 = 0;
      }
      *(void *)(Instance + 64) = v4;
    }
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)(Instance + 80) = _D0;
    *(unsigned char *)(Instance + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  }
  return Instance;
}

CFTypeRef C3DAnimationPlayerSetAnimation(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    CFTypeRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 64);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 64) = result;
  }
  return result;
}

uint64_t C3DAnimationPlayerGetAnimation(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 64);
}

void C3DAnimationPlayerRemoveAnimationNode(uint64_t a1, const void *a2)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationNode_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFArrayRef v20 = *(const __CFArray **)(a1 + 72);
  v23.CFIndex length = CFArrayGetCount(v20);
  v23.locatiouint64_t n = 0;
  FirstIndexOfunint64_t Value = CFArrayGetFirstIndexOfValue(v20, v23, a2);
  if (FirstIndexOfValue != -1)
  {
    CFIndex v22 = FirstIndexOfValue;
    C3DAnimationNodeSetPlayer((uint64_t)a2, 0);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 72), v22);
  }
}

double C3DAnimationPlayerAddAnimationNode(uint64_t a1, void *value)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), value);
  C3DAnimationNodeSetPlayer((uint64_t)value, a1);
  uint64_t AnimationManager = C3DAnimationNodeGetAnimationManager((uint64_t)value);
  if (!AnimationManager)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      C3DAnimationManagerSetSystemTime_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  if (!*(unsigned char *)(a1 + 88)) {
    C3DAnimationManagerPlayAnimationNode(AnimationManager, (uint64_t)value);
  }
  double result = *(double *)(a1 + 80);
  *((double *)value + 6) = result;
  return result;
}

void C3DAnimationPlayerSetSpeed(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 84) != a2)
  {
    *(float *)(a1 + 84) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
        C3DAnimationNodeChangeSpeed((uint64_t)ValueAtIndex, a2);
      }
    }
  }
}

float C3DAnimationPlayerGetSpeed(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 84);
}

void C3DAnimationPlayerSetWeight(uint64_t a1, float a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(float *)(a1 + 80) != a2)
  {
    *(float *)(a1 + 80) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
        *((float *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i) + 12) = a2;
    }
  }
}

float C3DAnimationPlayerGetWeight(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(float *)(a1 + 80);
}

void C3DAnimationPlayerSetPaused(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(unsigned __int8 *)(a1 + 88) != a2)
  {
    *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
        uint64_t AnimationManager = C3DAnimationNodeGetAnimationManager((uint64_t)ValueAtIndex);
        if (AnimationManager)
        {
          uint64_t v17 = AnimationManager;
          C3DTransactionGetAtomicTime();
          C3DAnimationManagerPauseAnimationNode(v17, (uint64_t)ValueAtIndex, a2, 0, v18);
        }
      }
    }
  }
}

uint64_t C3DAnimationPlayerGetPaused(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 88);
}

CFIndex C3DAnimationPlayerPlay(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v11 = result;
    for (CFIndex i = 0; i != v11; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = C3DAnimationNodeGetAnimationManager((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = C3DAnimationManagerPlayAnimationNode(result, (uint64_t)ValueAtIndex);
      }
    }
  }
  return result;
}

CFIndex C3DAnimationPlayerStop(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v11 = result;
    for (CFIndex i = 0; i != v11; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = C3DAnimationNodeGetAnimationManager((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = C3DAnimationManagerStopAnimationNode(result, (uint64_t)ValueAtIndex, 0.0);
      }
    }
  }
  return result;
}

CFIndex C3DAnimationPlayerStopWithDuration(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationPlayerSetAnimation_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v13 = result;
    for (CFIndex i = 0; i != v13; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = C3DAnimationNodeGetAnimationManager((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = C3DAnimationManagerStopAnimationNode(result, (uint64_t)ValueAtIndex, a2);
      }
    }
  }
  return result;
}

void _C3DAnimationPlayerCFFinalize(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      C3DAnimationNodeSetPlayer((uint64_t)ValueAtIndex, 0);
    }
  }
  uint64_t v6 = *(const void **)(a1 + 64);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 72);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 72) = 0;
  }
}

CFStringRef _C3DAnimationPlayerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationPlayer %p>", a1);
}

CFStringRef _C3DAnimationPlayerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationPlayer %p>", a1);
}

void _C3DAnimationPlayerSetValue(uint64_t a1, uint64_t a2, float *a3)
{
  if (a1 + 84 == a2)
  {
    C3DAnimationPlayerSetSpeed(a1, *a3);
  }
  else if (a1 + 80 == a2)
  {
    C3DAnimationPlayerSetWeight(a1, *a3);
  }
}

double __C3DAnimationNodeGetTypeID_block_invoke()
{
  C3DAnimationNodeGetTypeID_typeID = _CFRuntimeRegisterClass();
  unk_26B4671A8 = kC3DC3DAnimationNodeContextClassSerializable;
  unk_26B4671B8 = *(_OWORD *)&off_26BF710E0;
  double result = *(double *)&kC3DC3DAnimationNodeContextClassAnimatable;
  xmmword_26B467150 = kC3DC3DAnimationNodeContextClassAnimatable;
  return result;
}

uint64_t C3DAnimationNodeCreateWithAnimation(const void *a1)
{
  if (C3DAnimationNodeGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationNodeGetTypeID_onceToken, &__block_literal_global_26);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DAnimationNodeGetTypeID_typeID, 0xD0uLL);
  uint64_t v3 = Instance;
  if (Instance) {
    _C3DAnimationNodeInitializeWithAnimation(Instance, a1);
  }
  return v3;
}

float _C3DAnimationNodeInitializeWithAnimation(uint64_t a1, const void *a2)
{
  *(_DWORD *)(a1 + 60) = 2139095039;
  *(_DWORD *)(a1 + 72) = -1082130432;
  int v4 = *(_DWORD *)(a1 + 121);
  *(void *)(a1 + 152) = -1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = _D0;
  *(_DWORD *)(a1 + 121) = v4 | 0x24;
  C3DAnimationNodeSetAnimation(a1, a2);
  float Duration = C3DAnimationGetDuration((uint64_t)a2);
  if (Duration == 0.0)
  {
    double v11 = C3DTransactionGetDuration();
    if (v11 == 0.0) {
      double v11 = 0.25;
    }
  }
  else
  {
    double v11 = Duration;
  }
  float result = v11;
  *(float *)(a1 + 76) = result;
  return result;
}

CFTypeRef C3DAnimationNodeSetAnimation(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t C3DAnimationNodeGetAnimation(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 16);
}

uint64_t C3DAnimationNodeGetOwner(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 144);
}

void C3DAnimationNodeSetOwner(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 144) = a2;
}

void C3DAnimationNodeSetStartTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 80) = a2;
}

void C3DAnimationNodeRestart(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(_DWORD *)(a1 + 121) |= 2u;
}

double C3DAnimationNodeGetStartTime(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 80);
}

void C3DAnimationNodeTimeJump(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if ((*(unsigned char *)(a1 + 121) & 1) != 0 && (*(_WORD *)(*(void *)(a1 + 16) + 84) & 8) == 0) {
    *(double *)(a1 + 80) = *(double *)(a1 + 80) + a2;
  }
}

uint64_t C3DAnimationNodeSetAnimationManager(uint64_t result, uint64_t a2)
{
  *(void *)(result + 184) = a2;
  return result;
}

uint64_t C3DAnimationNodeGetAnimationManager(uint64_t a1)
{
  return *(void *)(a1 + 184);
}

uint64_t C3DAnimationNodeSetPlayer(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = a2;
  return result;
}

uint64_t C3DAnimationNodeGetPlayer(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

CFTypeRef C3DAnimationNodeSetKey(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 136);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 136) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 136) = result;
  }
  return result;
}

uint64_t C3DAnimationNodeGetCompletionCallbacks(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 208;
}

CFTypeRef C3DAnimationNodeSetCompletionItem(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 200);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 200) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 200) = result;
  }
  return result;
}

uint64_t C3DAnimationNodeGetCompletionItem(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 200);
}

uint64_t C3DAnimationNodeGetParent(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

void C3DAnimationNodeAddChild(uint64_t a1, void *value)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (value) {
      goto LABEL_6;
    }
  }
  else if (value)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DAnimationNodeAddChild_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef Mutable = *(__CFArray **)(a1 + 32);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
    *(void *)(a1 + 32) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
  *((void *)value + 5) = a1;
}

CFArrayRef C3DAnimationNodeGetChildCount(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 32);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

CFArrayRef C3DAnimationNodeGetChildAtIndex(uint64_t a1, CFIndex idx)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 32);
  if (result) {
    return (const __CFArray *)CFArrayGetValueAtIndex(result, idx);
  }
  return result;
}

void C3DAnimationNodeSetRepeatStep(uint64_t a1, unsigned int a2)
{
  if (!*(void *)(a1 + 112))
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DAnimationNodeSetRepeatStep_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 112);
  unsigned int v13 = *(_DWORD *)v12;
  if (*(_DWORD *)v12 != a2)
  {
    uint64_t v14 = *(void *)(v12 + 8);
    if (!v14)
    {
      int Type = C3DValueGetType(*(void *)(v12 + 16));
      uint64_t v14 = C3DValueCreate(Type, 1);
      uint64_t v16 = *(void *)(a1 + 112);
      *(void *)(v16 + _Block_object_dispose(&STACK[0x2A0], 8) = v14;
      unsigned int v13 = *(_DWORD *)v16;
    }
    if (v13 - 1 >= a2)
    {
      Bytes = (void *)C3DValueGetBytes(v14);
      C3DValueCopyTo(*(void *)(*(void *)(a1 + 112) + 16), Bytes);
      unsigned int v13 = 1;
    }
    unsigned int v18 = a2 - v13;
    if (a2 > v13)
    {
      do
      {
        C3DValueConcat(*(void *)(*(void *)(a1 + 112) + 8), *(void *)(*(void *)(a1 + 112) + 16), *(void *)(*(void *)(a1 + 112) + 8));
        --v18;
      }
      while (v18);
    }
    **(_DWORD **)(a1 + 112) = a2;
  }
}

double C3DAnimationNodeGetContentTimeForTime(uint64_t a1, BOOL *a2, unsigned char *a3, BOOL *a4, double a5)
{
  if (!a1)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  if ((*(unsigned char *)(a1 + 123) & 0x60) != 0) {
    a5 = *(double *)(a1 + 128);
  }
  if (a5 != *(float *)(a1 + 60))
  {
    float v18 = a5;
    *(float *)(a1 + 60) = v18;
    __int16 v64 = 0;
    unsigned __int8 v63 = 1;
    uint64_t v19 = *(void *)(a1 + 40);
    if (v19)
    {
      C3DAnimationNodeGetContentTimeForTime(v19, (char *)&v64 + 1, &v64, &v63, a5);
      int v21 = v63;
      if (!v63)
      {
        unsigned int v31 = 0;
        int v32 = 0;
        double v30 = 0.0;
        double v33 = 0.0;
        goto LABEL_99;
      }
      a5 = v20;
    }
    uint64_t Animation = C3DAnimationNodeGetAnimation(a1);
    float Duration = C3DAnimationGetDuration(Animation);
    double v24 = Duration;
    if (*(void *)(a1 + 40) || (*(_WORD *)(Animation + 84) & 8) != 0) {
      double PauseTime = C3DAnimationNodeGetPauseTime(Animation);
    }
    else {
      double PauseTime = C3DAnimationNodeGetStartTime(a1);
    }
    double v26 = PauseTime;
    float v27 = *(float *)(a1 + 52);
    float v28 = v27 * C3DAnimationGetSpeed(Animation);
    double TimeOffset = C3DAnimationGetTimeOffset(Animation);
    if (Duration <= 0.0) {
      double v24 = 1.0;
    }
    if (v28 < 0.0) {
      HIBYTE(v64) ^= 1u;
    }
    double v30 = a5 - v26;
    if (Duration == 0.0)
    {
      unsigned int v31 = 0;
      int v32 = 0;
      double v33 = 0.0;
    }
    else
    {
      if (v28 == 0.0) {
        double v33 = *(float *)(a1 + 64);
      }
      else {
        double v33 = v30 * fabsf(v28) / v24;
      }
      double v30 = v33;
      if (v33 < 0.0)
      {
        FillModeMasuint64_t k = C3DAnimationGetFillModeMask(Animation);
        double v30 = 0.0;
        if ((FillModeMask & 2) == 0)
        {
          unsigned int v31 = 0;
          int v32 = 0;
          int v21 = 0;
          goto LABEL_99;
        }
      }
      float v35 = *(float *)(Animation + 76);
      BOOL v36 = v35 == 3.4028e38 || v35 == INFINITY;
      __int16 v37 = *(_WORD *)(Animation + 84);
      if ((v37 & 1) != 0 || (unsigned int v31 = 0, v38 = 1.0, v35 != 0.0) && v35 != 1.0)
      {
        if (v35 == 0.0) {
          float v38 = 1.0;
        }
        else {
          float v38 = *(float *)(Animation + 76);
        }
        if (v36)
        {
          double v39 = v33 * 0.5;
          if ((v37 & 1) == 0) {
            double v39 = v33;
          }
          unsigned int v31 = (int)v39;
        }
        else
        {
          if (v37) {
            float v38 = v38 + v38;
          }
          double v40 = v33 * 0.5;
          if ((v37 & 1) == 0) {
            double v40 = v33;
          }
          unsigned int v31 = (int)v40;
          double v33 = v33 / v38;
        }
      }
      int v41 = !v36;
      if (v33 < 1.0) {
        int v41 = 0;
      }
      if ((_BYTE)v64) {
        int v32 = 1;
      }
      else {
        int v32 = v41;
      }
      double v42 = *(double *)(a1 + 88);
      if (v42 != 0.0 && v42 + *(double *)(a1 + 104) < a5) {
        int v32 = 1;
      }
      if (v33 > 1.0 && v32 != 0)
      {
        if (((v37 & 0x20) == 0 || (*(unsigned char *)(a1 + 121) & 0x40) != 0 || *(void *)(a1 + 40))
          && (C3DAnimationGetFillModeMask(Animation) & 1) == 0)
        {
          int v21 = 0;
          int v32 = 1;
          double v30 = 0.0;
          goto LABEL_99;
        }
        double v30 = v38;
        double v33 = 1.0;
        if (v36) {
          double v30 = 1.0;
        }
      }
      double v44 = TimeOffset / v24;
      if (v28 < 0.0) {
        double v44 = -(TimeOffset / v24);
      }
      if (TimeOffset == 0.0) {
        double v45 = v30;
      }
      else {
        double v45 = v44 + v30;
      }
      if (TimeOffset == 0.0) {
        double v46 = 0.0;
      }
      else {
        double v46 = v44;
      }
      if (v45 <= 1.0)
      {
        double v47 = v45;
        if (v45 < 0.0) {
          double v47 = fmod(v45, 1.0) + 1.0;
        }
      }
      else
      {
        double v47 = fmod(v45, 1.0);
      }
      if (*(_WORD *)(Animation + 84))
      {
        if (v33 < 1.0 || v36)
        {
          BOOL v49 = v45 < 0.0;
          double v50 = (double)(int)v45;
          double v51 = 1.0 - v45;
        }
        else
        {
          double v52 = v46 + v38;
          BOOL v49 = v52 > 0.0;
          double v51 = (double)(int)v52;
          double v50 = 1.0 - v52;
        }
        double v53 = v49 ? v51 : v50;
        if (v28 < 0.0 == (((int)v53 & 1) == 0))
        {
          HIBYTE(v64) ^= 1u;
          double v47 = 1.0 - v47;
        }
      }
      if (v28 >= 0.0) {
        double v54 = v47;
      }
      else {
        double v54 = 1.0 - v47;
      }
      TimingFunctiouint64_t n = C3DAnimationGetTimingFunction(Animation);
      if (TimingFunction)
      {
        if (v54 >= 0.0 && v54 <= 1.0)
        {
          C3DTimingFunctionSolve(TimingFunction, v54, Duration);
          double v54 = v57;
        }
      }
      double v30 = v24 * v54;
    }
    int v21 = 128;
LABEL_99:
    float v58 = v33;
    unsigned int v59 = *(_DWORD *)(a1 + 121) & 0xFFFFFC7F | (HIBYTE(v64) << 9);
    float v60 = v30;
    *(float *)(a1 + 64) = v58;
    *(float *)(a1 + 6_Block_object_dispose(&STACK[0x2A0], 8) = v60;
    if (v32)
    {
      if (*(void *)(a1 + 40)) {
        int v61 = v64 << 8;
      }
      else {
        int v61 = 256;
      }
    }
    else
    {
      int v61 = 0;
    }
    *(_DWORD *)(a1 + 121) = v59 | v21 | v61;
    if (*(void *)(a1 + 112)) {
      C3DAnimationNodeSetRepeatStep(a1, v31);
    }
  }
  if (a2) {
    *a2 = (*(_DWORD *)(a1 + 121) & 0x200) != 0;
  }
  if (a3) {
    *a3 = *(unsigned char *)(a1 + 122) & 1;
  }
  if (a4) {
    *a4 = (*(_DWORD *)(a1 + 121) & 0x80) != 0;
  }
  return *(float *)(a1 + 68);
}

float C3DAnimationNodeGetWeightAtTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (*(void *)(a1 + 40)) {
    double WeightAtTime = C3DAnimationNodeGetWeightAtTime(a2);
  }
  else {
    double WeightAtTime = 1.0;
  }
  uint64_t Animation = (float *)C3DAnimationNodeGetAnimation(a1);
  uint64_t v14 = Animation;
  double v15 = WeightAtTime * (float)(Animation[26] * *(float *)(a1 + 48));
  if (Animation[27] != 0.0 || Animation[28] != 0.0)
  {
    float v16 = *(float *)(a1 + 64);
    if (v16 < 0.0) {
      float v16 = 0.0;
    }
    float v17 = fminf(v16, 1.0);
    float v18 = Animation[19];
    if (v18 == INFINITY || v18 == 3.4028e38) {
      float Duration = C3DAnimationGetDuration((uint64_t)Animation);
    }
    else {
      float Duration = C3DAnimationGetTotalDuration((uint64_t)Animation);
    }
    float v21 = v14[27];
    float v22 = v17 * Duration;
    if (v21 != 0.0 && v22 < v21) {
      double v15 = v15 * (v22 / v21);
    }
    float v24 = v14[28];
    if (v24 != 0.0)
    {
      float v25 = v14[19];
      BOOL v26 = v25 == INFINITY || v25 == 3.4028e38;
      if (!v26 && ((_WORD)v14[21] & 0x50) != 0x40)
      {
        float v27 = (float)(1.0 - v17) * Duration;
        if (v27 >= 0.0 && v27 < v24) {
          double v15 = v15 * (v27 / v24);
        }
      }
    }
  }
  double v29 = *(double *)(a1 + 104);
  if (v29 != 0.0)
  {
    double v30 = 1.0 - (a2 - *(double *)(a1 + 96)) / v29;
    if (v30 <= 0.0) {
      double v30 = 0.0;
    }
    float v31 = v30;
    double v15 = v15 * v31;
    if (v31 == 0.0)
    {
      int v32 = *(_DWORD *)(a1 + 121);
      if ((v32 & 8) != 0) {
        *(_DWORD *)(a1 + 121) = v32 & 0xFFFFFFD3 | 4;
      }
    }
  }
  return v15;
}

uint64_t C3DAnimationNodeGetRemovedOnCompletion(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t result = C3DAnimationGetRemoveOnCompletion(*(void *)(a1 + 16));
  if (result)
  {
    if (C3DAnimationNodeGetParent(a1)) {
      return C3DAnimationNodeGetRemovedOnCompletion();
    }
    else {
      return 1;
    }
  }
  return result;
}

void C3DAnimationNodeChangeSpeed(uint64_t a1, float a2)
{
  float v3 = *(float *)(a1 + 52);
  if (v3 != a2)
  {
    if (*(unsigned char *)(a1 + 121))
    {
      uint64_t v5 = *(void *)(a1 + 16);
      float v6 = *(float *)(v5 + 80);
      float v7 = v3 * v6;
      if (C3DAnimationGetIsSceneTimeBased(v5)) {
        double v8 = *(float *)(a1 + 60);
      }
      else {
        C3DTransactionGetAtomicTime();
      }
      float v9 = v6 * a2;
      if (v7 == 0.0) {
        double v10 = (float)(*(float *)(a1 + 64) * *(float *)(a1 + 76));
      }
      else {
        double v10 = (v8 - *(double *)(a1 + 80)) * v7;
      }
      if (v9 != 0.0) {
        *(double *)(a1 + 80) = -(v10 / v9 - v8);
      }
    }
    *(float *)(a1 + 52) = a2;
  }
}

CFTypeRef C3DAnimationNodeSetTarget(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 24) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 24) = result;
  }
  return result;
}

BOOL C3DAnimationNodeGetPausedOrPausedByScene(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 123) & 0x60) != 0;
}

uint64_t C3DAnimationNodeGetPaused(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 123) >> 5) & 1;
}

void C3DAnimationNodeSetPaused(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    int v12 = 0x200000;
  }
  else {
    int v12 = 0;
  }
  *(_DWORD *)(a1 + 121) = *(_DWORD *)(a1 + 121) & 0xFFDFFFFF | v12;
}

void C3DAnimationNodeSetPausedByScene(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    int v12 = 0x400000;
  }
  else {
    int v12 = 0;
  }
  *(_DWORD *)(a1 + 121) = *(_DWORD *)(a1 + 121) & 0xFFBFFFFF | v12;
}

uint64_t C3DAnimationNodeGetPausedByScene(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 123) >> 6) & 1;
}

double C3DAnimationNodeGetPauseTime(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 128);
}

void C3DAnimationNodeSetPauseTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationForKey_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 12_Block_object_dispose(&STACK[0x2A0], 8) = a2;
}

uint64_t C3DAnimationNodeCreateWithAnimationGroupAndAddToAnimationManager(uint64_t a1, const void *a2, float32x4_t *a3, const void *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  float v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DAnimationNodeCreateWithAnimationGroupAndAddToAnimationManager_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  uint64_t IsSceneTimeBased = C3DAnimationGetIsSceneTimeBased((uint64_t)a2);
  uint64_t SubAnimationNodes = _createSubAnimationNodes(a1, a2, a3, IsSceneTimeBased);
  C3DAnimationNodeSetKey(SubAnimationNodes, a4);
  return SubAnimationNodes;
}

uint64_t _createSubAnimationNodes(uint64_t a1, const void *a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v8 = C3DAnimationNodeCreateWithAnimation(a2);
  AnimationCFIndex Count = C3DAnimationGroupGetAnimationCount((uint64_t)a2);
  if (AnimationCount >= 1)
  {
    CFIndex v10 = AnimationCount;
    for (CFIndex i = 0; v10 != i; ++i)
    {
      AnimationAtuint64_t Index = C3DAnimationGroupGetAnimationAtIndex((uint64_t)a2, i);
      if (C3DAnimationIsGroup(AnimationAtIndex))
      {
        uint64_t SubAnimationNodes = (void *)_createSubAnimationNodes(a1, AnimationAtIndex, a3, a4);
        if (SubAnimationNodes)
        {
          uint64_t v14 = SubAnimationNodes;
          C3DAnimationNodeAddChild(v8, SubAnimationNodes);
LABEL_10:
          CFRelease(v14);
        }
      }
      else
      {
        uint64_t v15 = C3DAnimationCopyTarget((uint64_t)AnimationAtIndex, a3);
        uint64_t v14 = v15;
        if (AnimationAtIndex)
        {
          float v16 = (void *)C3DAnimationNodeCreateWithAnimation(AnimationAtIndex);
          C3DAnimationSetIsSceneTimeBased((uint64_t)AnimationAtIndex, a4);
          C3DAnimationNodeAddChild(v8, v16);
          CFRelease(v16);
          if (v14)
          {
            _C3DAnimationManagerAddAnimationNode(a1, (uint64_t)v16, v14);
            goto LABEL_10;
          }
        }
        else if (v15)
        {
          goto LABEL_10;
        }
      }
    }
  }
  return v8;
}

uint64_t C3DAnimationNodeCreateWithAnimationCluster(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DAnimationNodeCreateWithAnimationCluster_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  uint64_t v22 = C3DAnimationClusterNodeCreateWithAnimation(a2);
  C3DAnimationNodeSetKey(v22, a4);
  return v22;
}

uint64_t C3DAnimationClusterNodeCreateWithAnimation(const void *a1)
{
  if (C3DAnimationClusterNodeGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterNodeGetTypeID_onceToken, &__block_literal_global_11);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DAnimationClusterNodeGetTypeID_typeID, 0xD8uLL);
  _C3DAnimationNodeInitializeWithAnimation(Instance, a1);
  return Instance;
}

uint64_t C3DAnimationNodeCreateWithAnimationAndAddToAnimationManager(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerAddAnimationForKey_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a3)
  {
    float v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerAddAnimationNode_cold_2(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  uint64_t v32 = C3DAnimationNodeCreateWithAnimation(a2);
  C3DAnimationNodeSetKey(v32, a4);
  _C3DAnimationManagerAddAnimationNode(a1, v32, a3);
  return v32;
}

uint64_t C3DAnimationClusterNodeGetTypeID()
{
  if (C3DAnimationClusterNodeGetTypeID_onceToken != -1) {
    dispatch_once(&C3DAnimationClusterNodeGetTypeID_onceToken, &__block_literal_global_11);
  }
  return C3DAnimationClusterNodeGetTypeID_typeID;
}

double __C3DAnimationClusterNodeGetTypeID_block_invoke()
{
  C3DAnimationClusterNodeGetTypeID_typeID = _CFRuntimeRegisterClass();
  double result = *(double *)&kC3DC3DAnimationClusterNodeContextClassAnimatable;
  xmmword_26B467068 = kC3DC3DAnimationClusterNodeContextClassAnimatable;
  return result;
}

void _C3DAnimationNodeCFFinalize(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 32);
  if (v2)
  {
    CFIndex Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      CFIndex v4 = Count;
      for (CFIndex i = 0; i != v4; ++i)
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i) + 5) = 0;
    }
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }
  if (*(void *)(a1 + 200))
  {
    uint64_t v6 = *(void (**)(uint64_t))(a1 + 216);
    if (!v6 || (v6(a1), *(void *)(a1 + 200)))
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        _C3DAnimationNodeCFFinalize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      }
      uint64_t v15 = *(const void **)(a1 + 200);
      if (v15)
      {
        CFRelease(v15);
        *(void *)(a1 + 200) = 0;
      }
    }
  }
  uint64_t v16 = *(const void **)(a1 + 16);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v17 = *(const void **)(a1 + 136);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v18 = *(const void **)(a1 + 24);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v19 = *(CFTypeRef **)(a1 + 112);
  if (v19)
  {
    if (v19[1])
    {
      CFRelease(v19[1]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 112);
      v19[1] = 0;
    }
    if (v19[3])
    {
      CFRelease(v19[3]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 112);
      v19[3] = 0;
    }
    if (v19[2])
    {
      CFRelease(v19[2]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 112);
      v19[2] = 0;
    }
  }
  free(v19);
  uint64_t v20 = *(const void **)(a1 + 176);
  if (v20)
  {
    CFRelease(v20);
    *(void *)(a1 + 176) = 0;
  }
}

CFStringRef _C3DAnimationNodeCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationNode %p>", a1);
}

CFStringRef _C3DAnimationNodeCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationNode %p>", a1);
}

uint64_t _C3DAnimationNodeInitWithPropertyList()
{
  return 1;
}

const void *_C3DAnimationNodeCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result = (const void *)C3DAnimationNodeGetAnimation(a1);
  if (result)
  {
    return (const void *)C3DCopyPropertyList(result, a2, a3, a4);
  }
  return result;
}

uint64_t _C3DAnimationNodeFinalizeDeserialization()
{
  return 1;
}

void _C3DAnimationNodeSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 52) == __dst) {
    C3DAnimationNodeChangeSpeed(a1, *__src);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

void _C3DAnimationClusterNodeCFFinalize(uint64_t a1)
{
  _C3DAnimationNodeCFFinalize(a1);
  CFAllocatorRef v2 = *(void **)(a1 + 224);

  free(v2);
}

CFStringRef _C3DAnimationClusterNodeCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationClusterNode %p>", a1);
}

CFStringRef _C3DAnimationClusterNodeCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DAnimationClusterNode %p>", a1);
}

void _C3DAnimationClusterNodeSetValue(uint64_t a1, void *__dst, float *__src, size_t __n)
{
  if ((void *)(a1 + 52) == __dst) {
    C3DAnimationNodeChangeSpeed(a1, *__src);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

id C3DFXContextGetCIContext(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a1 + 264);
  if (!result)
  {
    uint64_t RenderContext = C3DEngineContextGetRenderContext(a2);
    if (RenderContext)
    {
      uint64_t v6 = (void *)[MEMORY[0x263F00628] contextWithMTLDevice:-[SCNMTLRenderContext device](RenderContext)];
    }
    else
    {
      uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
      uint64_t v6 = (void *)[MEMORY[0x263F00628] contextWithEAGLContext:C3DRendererContextGetGLContext(RendererContextGL)];
    }
    id result = v6;
    *(void *)(a1 + 264) = result;
  }
  return result;
}

uint64_t _getCIFilterParameterType(void *a1, CFStringRef theString, void *a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v7 = (__CFString *)C3DCreatePathComponentsFromString(theString);
  if ([a1 count] && -[__CFString count](v7, "count"))
  {
    if ([(__CFString *)v7 count] == 2)
    {
      uint64_t v8 = [(__CFString *)v7 objectAtIndex:0];
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      uint64_t v9 = [a1 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)v28;
LABEL_6:
        uint64_t v12 = 0;
        while (1)
        {
          if (*(void *)v28 != v11) {
            objc_enumerationMutation(a1);
          }
          uint64_t v13 = *(void **)(*((void *)&v27 + 1) + 8 * v12);
          if (objc_msgSend((id)objc_msgSend(v13, "name"), "isEqualToString:", v8)) {
            break;
          }
          if (v10 == ++v12)
          {
            uint64_t v10 = [a1 countByEnumeratingWithState:&v27 objects:v31 count:16];
            if (v10) {
              goto LABEL_6;
            }
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v13 = 0;
      }
      uint64_t v14 = v7;
      uint64_t v15 = 1;
    }
    else
    {
      uint64_t v13 = (void *)[a1 objectAtIndex:0];
      uint64_t v14 = v7;
      uint64_t v15 = 0;
    }
    uint64_t v17 = (const void *)[(__CFString *)v14 objectAtIndex:v15];
    uint64_t v18 = v17;
    if (v17) {
      CFTypeRef v19 = CFRetain(v17);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *a4 = v19;
    if (v13) {
      CFTypeRef v20 = CFRetain(v13);
    }
    else {
      CFTypeRef v20 = 0;
    }
    *a3 = v20;
    CFRelease(v7);
    uint64_t result = [v13 attributes];
    if (result)
    {
      uint64_t result = objc_msgSend((id)objc_msgSend(v13, "attributes"), "objectForKey:", v18);
      if (result)
      {
        uint64_t v21 = (void *)result;
        uint64_t v22 = (void *)[(id)result objectForKey:*MEMORY[0x263F006F0]];
        if (v22)
        {
          uint64_t v23 = v22;
          if (([v22 isEqualToString:*MEMORY[0x263F00758]] & 1) != 0
            || ([v23 isEqualToString:*MEMORY[0x263F00750]] & 1) != 0
            || ([v23 isEqualToString:*MEMORY[0x263F00718]] & 1) != 0
            || ([v23 isEqualToString:*MEMORY[0x263F006F8]] & 1) != 0)
          {
            return 6;
          }
          if ([v23 isEqualToString:*MEMORY[0x263F00700]]) {
            return 3;
          }
          if (([v23 isEqualToString:*MEMORY[0x263F00728]] & 1) != 0
            || ([v23 isEqualToString:*MEMORY[0x263F00710]] & 1) != 0)
          {
            return 2;
          }
          if (([v23 isEqualToString:*MEMORY[0x263F00738]] & 1) != 0
            || ([v23 isEqualToString:*MEMORY[0x263F00730]] & 1) != 0)
          {
            return 8;
          }
          uint64_t v26 = *MEMORY[0x263F00740];
          if (([v23 isEqualToString:*MEMORY[0x263F00740]] & 1) != 0
            || ([v23 isEqualToString:v26] & 1) != 0)
          {
            return 9;
          }
          BOOL v24 = [v23 isEqualToString:*MEMORY[0x263F00748]] == 0;
          unsigned int v25 = 10;
        }
        else
        {
          BOOL v24 = objc_msgSend((id)objc_msgSend(v21, "objectForKey:", *MEMORY[0x263F00690]), "isEqualToString:", @"NSNumber") == 0;
          unsigned int v25 = 6;
        }
        if (v24) {
          return 0;
        }
        else {
          return v25;
        }
      }
    }
  }
  else
  {
    CFRelease(v7);
    return 0;
  }
  return result;
}

float32x4_t _getCIFilterParameterValue(void *a1, uint64_t a2, _DWORD *a3, int a4)
{
  uint64_t v6 = (void *)[a1 valueForKey:a2];
  uint64_t v7 = v6;
  switch(a4)
  {
    case 2:
      *a3 = [v6 intValue];
      break;
    case 3:
      *(unsigned char *)a3 = [v6 BOOLValue];
      break;
    case 6:
      [v6 doubleValue];
      goto LABEL_8;
    case 8:
      [v6 X];
      float64_t v32 = v17;
      [v7 Y];
      v18.f64[0] = v32;
      *(void *)&v18.f64[1] = result.i64[0];
      *(float32x2_t *)result.f32 = vcvt_f32_f64(v18);
LABEL_8:
      *(void *)a3 = result.i64[0];
      break;
    case 9:
      [v6 X];
      float64_t v33 = v19;
      [v7 Y];
      v20.f64[0] = v33;
      v20.f64[1] = v21;
      *(float32x2_t *)&long long v22 = vcvt_f32_f64(v20);
      long long v34 = v22;
      [v7 Z];
      result.f32[0] = *(double *)result.i64;
      long long v23 = v34;
      DWORD2(v23) = result.i32[0];
      *(_OWORD *)a3 = v23;
      break;
    case 10:
      [v6 X];
      float64_t v35 = v24;
      [v7 Y];
      float64_t v31 = v25;
      [v7 Z];
      float64_t v30 = v26;
      [v7 W];
      v27.f64[0] = v30;
      v27.f64[1] = v28;
      v29.f64[0] = v35;
      v29.f64[1] = v31;
      float32x4_t result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v29), v27);
      *(float32x4_t *)a3 = result;
      break;
    default:
      uint64_t v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        _getCIFilterParameterValue_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
      }
      break;
  }
  return result;
}

void _setCIFilterParameterValue(void *a1, uint64_t a2, float32x2_t *a3, int a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  switch(a4)
  {
    case 2:
      uint64_t v6 = [NSNumber numberWithInt:a3->u32[0]];
      goto LABEL_7;
    case 3:
      uint64_t v6 = [NSNumber numberWithBool:a3->u8[0]];
      goto LABEL_7;
    case 6:
      uint64_t v6 = [NSNumber numberWithDouble:*(double *)a3];
LABEL_7:
      [a1 setValue:v6 forKey:a2];
      return;
    case 8:
      float64x2_t v18 = vcvtq_f64_f32(*a3);
      uint64_t v15 = (void *)MEMORY[0x263F00680];
      uint64_t v16 = 2;
      goto LABEL_13;
    case 9:
      float64x2_t v18 = vcvtq_f64_f32(*a3);
      v19.f64[0] = a3[1].f32[0];
      uint64_t v15 = (void *)MEMORY[0x263F00680];
      uint64_t v16 = 3;
      goto LABEL_13;
    case 10:
      float64x2_t v17 = vcvtq_f64_f32(a3[1]);
      float64x2_t v18 = vcvtq_f64_f32(*a3);
      float64x2_t v19 = v17;
      uint64_t v15 = (void *)MEMORY[0x263F00680];
      uint64_t v16 = 4;
LABEL_13:
      objc_msgSend(a1, "setValue:forKey:", objc_msgSend(v15, "vectorWithValues:count:", &v18, v16, *(_OWORD *)&v18, *(_OWORD *)&v19), a2);
      break;
    default:
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        _getCIFilterParameterValue_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      }
      break;
  }
}

uint64_t C3DFXTechniqueCreateCIFilter(uint64_t a1, uint64_t a2)
{
  BOOL IsClusteredShadingEnabled = C3DEngineContextIsClusteredShadingEnabled(a2);
  uint64_t v4 = objc_msgSend(@"SceneKit-CI-nodetree-color-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1), "stringValue"));
  uint64_t v5 = (const void *)objc_msgSend(@"SceneKit_renderCINodeTree-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1), "stringValue"));
  uint64_t v6 = objc_msgSend(@"SceneKit-CI-effect-color-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1), "stringValue"));
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __C3DFXTechniqueCreateCIFilter_block_invoke;
  v15[3] = &unk_264006210;
  v15[7] = v5;
  v15[8] = a1;
  void v15[4] = &unk_26BFC1750;
  v15[5] = v4;
  v15[6] = v6;
  if (IsClusteredShadingEnabled) {
    uint64_t v7 = @"C3DFXCIFilterPassMetal.json";
  }
  else {
    uint64_t v7 = @"C3DFXCIFilterPass.json";
  }
  uint64_t v8 = (const void *)C3DJsonNamed(v7, (uint64_t)v15);
  uint64_t v9 = C3DFXTechniqueCreateWithDescription(v8, a1);
  uint64_t PassNamed = C3DFXTechniqueGetPassNamed(v9, v5);
  C3DFXPassSetWillExecuteCallback(PassNamed, (uint64_t)_willRenderNodeForCIFilter);
  uint64_t v11 = C3DFXTechniqueGetPassNamed(v9, (CFTypeRef)objc_msgSend(@"SceneKit_ApplyCIFilter", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1), "stringValue")));
  uint64_t v12 = v11;
  if (IsClusteredShadingEnabled) {
    C3DFXPassSetDrawInstruction(v11, 7);
  }
  C3DFloorSetReflectionCategoryBitMask(v12, (uint64_t)_applyCIFilter);
  uint64_t v13 = C3DFXTechniqueGetPassNamed(v9, (CFTypeRef)objc_msgSend(@"SceneKit_renderCIQuad", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1), "stringValue")));
  C3DFXPassSetInitializeCallback(v13, (uint64_t)_initializeRenderFilteredBuffer);
  C3DFXPassSetWillExecuteCallback(v13, (uint64_t)_willRenderFilteredBuffer);
  C3DFloorSetReflectionCategoryBitMask(v13, (uint64_t)_blendFilteredBuffer);
  return v9;
}

uint64_t __C3DFXTechniqueCreateCIFilter_block_invoke(void *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        a2 = objc_msgSend(a2, "stringByReplacingOccurrencesOfString:withString:", *(void *)(*((void *)&v10 + 1) + 8 * i), objc_msgSend(*(id *)(*((void *)&v10 + 1) + 8 * i), "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", a1[8]), "stringValue")));
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v6);
  }
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "stringByReplacingOccurrencesOfString:withString:", @"SceneKit-CI-nodetree-color", a1[5]), "stringByReplacingOccurrencesOfString:withString:", @"SceneKit-CI-effect-color", a1[6]), "stringByReplacingOccurrencesOfString:withString:", @"SceneKit_renderCINodeTree", a1[7]);
}

void _willRenderNodeForCIFilter(uint64_t a1)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(*(void *)(a1 + 24));
  if (RendererContextGL)
  {
    float32x4_t v2 = 0uLL;
    C3DRendererContextClear(RendererContextGL, 0x4500u, &v2);
  }
}

void _applyCIFilter(uint64_t a1)
{
  uint64_t v137 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v2);
  uint64_t Stats = C3DEngineContextGetStats(v2);
  double v5 = CACurrentMediaTime();
  uint64_t FXContext = C3DEngineContextGetFXContext(*(void *)(a1 + 24));
  __n128 Viewport = C3DEngineContextGetViewport((__n128 *)*(void *)(a1 + 24));
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(v2);
  long long v103 = (void *)FXContext;
  uint64_t v104 = RenderContext;
  if (RenderContext)
  {
LABEL_2:
    CIImage = 0;
    goto LABEL_3;
  }
  uint64_t FramebufferRegistry = C3DFXContextGetFramebufferRegistry(FXContext);
  RenderTargetWithuint64_t Name = C3DFramebufferRegistryGetRenderTargetWithName(FramebufferRegistry, (__CFString *)objc_msgSend(@"SceneKit-CI-nodetree-color-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7), "stringValue")));
  if (!RenderTargetWithName)
  {
    uint64_t v91 = scn_default_log();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
      _applyCIFilter_cold_1(v91, v92, v93, v94, v95, v96, v97, v98);
    }
    goto LABEL_2;
  }
  uint64_t v42 = (uint64_t)RenderTargetWithName;
  CIImage = (void *)C3DRenderTargetGetCIImage((uint64_t)RenderTargetWithName);
  if (!CIImage)
  {
    uint64_t Texture = C3DRenderTargetGetTexture(v42);
    if (!Texture)
    {
      double v44 = scn_default_log();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
        _applyCIFilter_cold_3(v44);
      }
    }
    glFlush();
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    double Size = C3DTextureGetSize(Texture);
    CIImage = (void *)[objc_alloc(MEMORY[0x263F00650]) initWithTexture:C3DTextureGetID(Texture) size:0 flipped:DeviceRGB colorSpace:vcvtq_f64_f32(*(float32x2_t *)&Size)];
    CGColorSpaceRelease(DeviceRGB);
    if (!CIImage)
    {
      double v47 = scn_default_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
        _applyCIFilter_cold_2(v47);
      }
    }
    C3DRenderTargetSetCIImage(v42, CIImage);
  }
LABEL_3:
  uint64_t v9 = *(__n128 **)(a1 + 24);
  long long v10 = (void *)C3DEngineContextGetFXContext((uint64_t)v9);
  __n128 v107 = C3DEngineContextGetViewport(v9);
  CurrentPassInstanceAncestor = (float32x4_t *)C3DFXContextGetCurrentPassInstanceAncestor(v10);
  if (CurrentPassInstanceAncestor)
  {
    memset(v120, 0, sizeof(v120));
    WorldMatrix = C3DNodeGetWorldMatrix(v7);
    C3DMatrix4x4Mult((uint64_t)WorldMatrix, CurrentPassInstanceAncestor + 246, v120);
    float32x4_t v118 = 0u;
    long long v119 = 0u;
    C3DNodeComputeHierarchicalBoundingBox(v7, 1, &v118);
    uint64_t v13 = 0;
    char v14 = 0;
    *(float *)&uint64_t v15 = v118.f32[0] + *(float *)&v119;
    *(float *)&uint64_t v16 = v118.f32[0] + *(float *)&v119;
    *((float *)&v16 + 1) = v118.f32[1] + *((float *)&v119 + 1);
    buf.f32[2] = v118.f32[2] + *((float *)&v119 + 2);
    buf.i64[0] = v16;
    float v124 = v118.f32[2] - *((float *)&v119 + 2);
    uint64_t v123 = v16;
    *((float *)&v15 + 1) = v118.f32[1] - *((float *)&v119 + 1);
    float v126 = v118.f32[2] + *((float *)&v119 + 2);
    uint64_t v125 = v15;
    float v128 = v118.f32[2] - *((float *)&v119 + 2);
    uint64_t v127 = v15;
    *(float *)&uint64_t v17 = v118.f32[0] - *(float *)&v119;
    *(float *)&uint64_t v18 = v118.f32[0] - *(float *)&v119;
    *((float *)&v18 + 1) = v118.f32[1] + *((float *)&v119 + 1);
    float v130 = v118.f32[2] + *((float *)&v119 + 2);
    uint64_t v129 = v18;
    float v132 = v118.f32[2] - *((float *)&v119 + 2);
    uint64_t v131 = v18;
    *((float *)&v17 + 1) = v118.f32[1] - *((float *)&v119 + 1);
    float v134 = v118.f32[2] + *((float *)&v119 + 2);
    uint64_t v133 = v17;
    float v136 = v118.f32[2] - *((float *)&v119 + 2);
    uint64_t v135 = v17;
    float32x4_t v111 = (float32x4_t)xmmword_20B5CC1F0;
    float v19 = 1.0;
    float32x4_t v109 = (float32x4_t)xmmword_20B5CBCA0;
    while (2)
    {
      uint64_t v20 = 16 * v13++;
      while (1)
      {
        float32x4_t v21 = *(float32x4_t *)((char *)&buf + v20);
        v21.f32[3] = v19;
        *(double *)v22.i64 = C3DVector4MultMatrix4x4(v120, v21);
        LODWORD(v24) = v22.i32[3];
        if (v22.f32[3] <= 0.0) {
          break;
        }
        float v19 = 1.0;
        v23.f32[0] = (float)(1.0 / v22.f32[3]) * v22.f32[0];
        v22.f32[0] = vmuls_lane_f32(1.0 / v22.f32[3], *(float32x2_t *)v22.f32, 1);
        int8x16_t v25 = (int8x16_t)v111;
        v25.i32[0] = v23.i32[0];
        int8x16_t v26 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v111, v23), 0), v25, (int8x16_t)v111);
        int8x16_t v27 = v26;
        v27.i32[1] = v22.i32[0];
        int32x4_t v28 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), v22), 0), v27, v26);
        int8x16_t v29 = (int8x16_t)v28;
        v29.i32[2] = v23.i32[0];
        int32x4_t v30 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v23, (float32x4_t)vdupq_laneq_s32(v28, 2)), 0), v29, (int8x16_t)v28);
        int8x16_t v31 = (int8x16_t)v30;
        v31.i32[3] = v22.i32[0];
        float32x4_t v111 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v22, (float32x4_t)vdupq_laneq_s32(v30, 3)), 0), v31, (int8x16_t)v30);
        ++v13;
        v20 += 16;
        if (v13 == 9)
        {
          v32.i64[0] = 0x3F0000003F000000;
          v32.i64[1] = 0x3F0000003F000000;
          int8x16_t v33 = (int8x16_t)vmlaq_f32(v32, v32, v111);
          double v24 = 0.0;
          if (v14) {
            unsigned int v34 = -1;
          }
          else {
            unsigned int v34 = 0;
          }
          float32x4_t v22 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v34), (int8x16_t)xmmword_20B5CBCA0, v33);
          float32x4_t v109 = v22;
          goto LABEL_15;
        }
      }
      char v14 = 1;
      float v19 = 1.0;
      if (v13 != 8) {
        continue;
      }
      break;
    }
LABEL_15:
    FirstPassInstanceWithuint64_t Name = C3DFXContextGetFirstPassInstanceWithName((uint64_t)v10, (CFTypeRef)objc_msgSend(@"SceneKit_renderCINodeTree-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7, *(double *)v22.i64, v24), "stringValue")));
    float32x4_t v36 = vmulq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v107, 1), v109);
    if (FirstPassInstanceWithName)
    {
      float32x4_t v37 = *(float32x4_t *)(FirstPassInstanceWithName + 5120);
      if ((vminvq_u32((uint32x4_t)vceqzq_f32(v37)) & 0x80000000) == 0)
      {
        int8x16_t v38 = (int8x16_t)vcgtq_f32(v36, v37);
        v39.i64[0] = *(void *)(FirstPassInstanceWithName + 5120);
        v39.i64[1] = v36.i64[1];
        v36.i64[1] = *(void *)(FirstPassInstanceWithName + 5128);
        float32x4_t v36 = (float32x4_t)vbslq_s8(v38, v39, (int8x16_t)v36);
      }
    }
  }
  else
  {
    float32x4_t v36 = 0uLL;
  }
  float v48 = v36.f32[2];
  if (v36.f32[2] <= v36.f32[0] || (v49 = v36.f32[3], float v50 = v36.f32[1], v36.f32[3] <= v36.f32[1]))
  {
    __int16 v89 = scn_default_log();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    buf.i16[0] = 0;
    uint64_t v90 = "Warning: CIFilter should have been clipped by the culling";
LABEL_68:
    _os_log_impl(&dword_20B249000, v89, OS_LOG_TYPE_DEFAULT, v90, (uint8_t *)&buf, 2u);
    goto LABEL_69;
  }
  float v112 = v36.f32[0];
  if (v36.f32[3] < Viewport.n128_f32[0]
    || v36.f32[3] < Viewport.n128_f32[1]
    || (float v51 = Viewport.n128_f32[2], v36.f32[0] >= Viewport.n128_f32[2])
    || (float v52 = Viewport.n128_f32[3], v36.f32[1] >= Viewport.n128_f32[3]))
  {
    __int16 v89 = scn_default_log();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    buf.i16[0] = 0;
    uint64_t v90 = "Warning: CIFilter should have been clipped by the culling (2)";
    goto LABEL_68;
  }
  double v53 = objc_msgSend(MEMORY[0x263F00640], "filterWithName:", @"CICrop", *(double *)v36.i64);
  [v53 setDefaults];
  double v54 = (float)(v49 - v50);
  if (v104) {
    float v50 = Viewport.n128_f32[3] - (v50 + v54);
  }
  objc_msgSend(v53, "setValue:forKey:", objc_msgSend(MEMORY[0x263F00680], "vectorWithX:Y:Z:W:", v112, v50, (float)(v48 - v112), v54), @"inputRectangle");
  uint64_t v55 = *MEMORY[0x263F00968];
  [v53 setValue:CIImage forKey:*MEMORY[0x263F00968]];
  uint64_t v56 = *MEMORY[0x263F009D0];
  double v57 = (void *)[v53 valueForKey:*MEMORY[0x263F009D0]];
  id CIContext = C3DFXContextGetCIContext(FXContext, *(void *)(a1 + 24));
  CFDictionaryRef Filters = C3DNodeGetFilters((uint64_t)v7);
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  uint64_t v59 = [(__CFDictionary *)Filters countByEnumeratingWithState:&v114 objects:v121 count:16];
  if (v59)
  {
    uint64_t v60 = *(void *)v115;
    do
    {
      for (uint64_t i = 0; i != v59; ++i)
      {
        if (*(void *)v115 != v60) {
          objc_enumerationMutation(Filters);
        }
        int v62 = *(void **)(*((void *)&v114 + 1) + 8 * i);
        [v62 setValue:v57 forKey:v55];
        double v57 = (void *)[v62 valueForKey:v56];
      }
      uint64_t v59 = [(__CFDictionary *)Filters countByEnumeratingWithState:&v114 objects:v121 count:16];
    }
    while (v59);
  }
  [v57 extent];
  double v67 = Viewport.n128_f32[3];
  if (v104) {
    double v64 = Viewport.n128_f32[3] - (v64 + v66);
  }
  if (v63 >= 0.0) {
    double v68 = -0.0;
  }
  else {
    double v68 = v63;
  }
  double v69 = v65 + v68;
  v70.f64[0] = Viewport.n128_f32[2];
  if (v63 >= 0.0) {
    double v71 = v63;
  }
  else {
    double v71 = 0.0;
  }
  *(double *)&unint64_t v72 = v71 + v69;
  v73.i64[1] = 0;
  double v113 = v71;
  double v74 = v70.f64[0] - v71;
  v70.f64[1] = v64;
  int64x2_t v75 = vcgtq_f64((float64x2_t)v72, v70);
  if ((vmovn_s64(v75).i32[1] & 1) == 0) {
    double v64 = -0.0;
  }
  double v76 = v66 + v64;
  *(double *)v73.i64 = v74;
  v70.f64[0] = v69;
  int8x16_t v77 = vbslq_s8((int8x16_t)v75, v73, (int8x16_t)v70);
  float64x2_t v110 = (float64x2_t)v77;
  double v78 = *(double *)&v77.i64[1];
  if (*(double *)&v77.i64[1] + v76 <= v67) {
    double v79 = v76;
  }
  else {
    double v79 = v67 - *(double *)&v77.i64[1];
  }
  double v108 = v79;
  uint64_t v80 = C3DFXContextGetFirstPassInstanceWithName((uint64_t)v103, (CFTypeRef)objc_msgSend(@"SceneKit_renderCINodeTree-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7), "stringValue")));
  v81.f64[0] = v113;
  v81.f64[1] = v108;
  float32x2_t v82 = vcvt_f32_f64(v81);
  *(float32x2_t *)v83.f32 = vcvt_f32_f64(v110);
  *(void *)&v81.f64[0] = __PAIR64__(v82.u32[1], v83.u32[0]);
  float32x2_t v99 = *(float32x2_t *)v83.f32;
  float32x2_t v100 = v82;
  v83.i32[0] = v82.i32[0];
  v83.i64[1] = *(void *)&v81.f64[0];
  float32x4_t v106 = v83;
  *(float32x4_t *)(v80 + 5120) = v83;
  uint64_t v84 = C3DFXContextGetCurrentPassInstanceAncestor(v103);
  float32x4_t v85 = v106;
  if (v84 && (vminvq_u32((uint32x4_t)vceqzq_f32(v106)) & 0x80000000) == 0)
  {
    int8x16_t v86 = *(int8x16_t *)(v84 + 5120);
    if (COERCE_FLOAT(*(void *)(v84 + 5128)) != 0.0 && *(float *)&v86.i32[3] != 0.0)
    {
      float32x2_t v87 = vadd_f32(v99, v100);
      float32x2_t v88 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v86, v86, 8uLL), *(float32x2_t *)v86.i8);
      *(int8x8_t *)v85.f32 = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(v99.u32[1], v100.u32[0]), *(float32x2_t *)v86.i8), *(int8x8_t *)v86.i8, (int8x8_t)__PAIR64__(v99.u32[1], v100.u32[0]));
      *(float32x2_t *)&v85.u32[2] = vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v87, v88), (int8x8_t)v87, (int8x8_t)v88), *(float32x2_t *)v85.f32);
    }
    *(float32x4_t *)(v84 + 5120) = v85;
  }
  if (!v104)
  {
    glViewport(0, 0, (int)v51, (int)v52);
    glEnable(0xC11u);
    glScissor((int)v113, (int)v78, (int)v110.f64[0], (int)v108);
    float32x4_t buf = 0uLL;
    C3DRendererContextClear(RendererContextGL, 0x4000u, &buf);
    glDisable(0xC11u);
    glDisable(0xB44u);
    objc_msgSend(CIContext, "drawImage:inRect:fromRect:", v57, v113, v78, v110.f64[0], v108, v113, v78, v110.f64[0], v108);
  }
LABEL_69:
  *(double *)(Stats + 160) = *(double *)(Stats + 160) + CACurrentMediaTime() - v5;
}

void _initializeRenderFilteredBuffer(uint64_t *a1)
{
  Prograuint64_t m = C3DFXPassGetProgram(*a1);

  C3DFXProgramSetOpaque(Program, 0);
}

void _willRenderFilteredBuffer(uint64_t a1)
{
  uint64_t FXContext = (void *)C3DEngineContextGetFXContext(*(void *)(a1 + 24));
  CurrentPassuint64_t Instance = C3DFXContextGetCurrentPassInstance(FXContext);
  long long v35 = 0u;
  long long v36 = 0u;
  float32x4_t v33 = 0u;
  long long v34 = 0u;
  WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(a1 + 16));
  C3DMatrix4x4Mult((uint64_t)WorldMatrix, (float32x4_t *)(CurrentPassInstance + 3168), &v33);
  float32x4_t v29 = v33;
  long long v30 = v34;
  long long v31 = v35;
  long long v32 = v36;
  C3DVector3MultMatrix4x4(&v29, (float32x4_t)0);
  float v6 = fmax(*(double *)(CurrentPassInstance + 4832)/ (*(double *)(CurrentPassInstance + 4832) - *(double *)(CurrentPassInstance + 4824))- *(double *)(CurrentPassInstance + 4832)* *(double *)(CurrentPassInstance + 4824)/ (*(double *)(CurrentPassInstance + 4824) - *(double *)(CurrentPassInstance + 4832))/ v5, 0.0);
  float v28 = v6;
  uint64_t v7 = *(void *)(a1 + 16);
  C3DFXTechniqueSetValueForSymbol(*(void *)(a1 + 8), objc_msgSend(@"C3D-CIFilter_middleZ", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7), "stringValue")), &v28);
  float32x4_t v24 = *(float32x4_t *)(C3DFXContextGetFirstPassInstanceWithName((uint64_t)FXContext, (CFTypeRef)objc_msgSend(@"SceneKit_renderCINodeTree-", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7), "stringValue")))+ 5120);
  float32x4_t v25 = *(float32x4_t *)(CurrentPassInstance + 4720);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*(void *)(a1 + 24));
  v9.f64[0] = v24.f32[0];
  if (RenderContext)
  {
    __asm { FMOV            V3.2D, #0.5 }
    float64x2_t v15 = vmulq_f64(vcvt_hight_f64_f32(v25), _Q3);
    v9.f64[1] = v24.f32[1];
    __asm { FMOV            V1.2D, #-1.0 }
    float32x4_t v29 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vdivq_f64(v9, v15), _Q1)), vdivq_f64(vcvt_hight_f64_f32(v24), v15));
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v18 = (__CFString *)objc_msgSend(@"C3D-CIFilter_extent", "stringByAppendingString:", objc_msgSend((id)objc_msgSend(NSNumber, "numberWithLong:", v7), "stringValue"));
    uint64_t v19 = v17;
  }
  else
  {
    int8x16_t v20 = vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL);
    long long v31 = 0u;
    long long v32 = 0u;
    float32x4_t v29 = 0u;
    long long v30 = 0u;
    *(float32x2_t *)v20.i8 = vdiv_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL));
    v20.i32[2] = 1.0;
    int8x16_t v27 = v20;
    float64x2_t v21 = vcvt_hight_f64_f32(v25);
    v9.f64[1] = v24.f32[1];
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v23 = vdivq_f64(vcvtq_f64_f32(vcvt_f32_f64(vmlaq_f64(v9, _Q1, vsubq_f64(vcvt_hight_f64_f32(v24), v21)))), vmulq_f64(v21, _Q1));
    *(float32x2_t *)&v23.f64[0] = vcvt_f32_f64(v23);
    *(float *)_Q1.f64 = v28 * 2.0 + -1.0;
    LODWORD(v23.f64[1]) = LODWORD(_Q1.f64[0]);
    float32x4_t v26 = (float32x4_t)v23;
    C3DMatrix4x4MakeScale(&v29, &v27);
    C3DMatrix4x4Translate(&v29, &v26);
    uint64_t v19 = *(void *)(a1 + 8);
    uint64_t v18 = @"C3D-CIFilter_modelMatrix";
  }
  C3DFXTechniqueSetValueForSymbol(v19, v18, &v29);
}

double _blendFilteredBuffer(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t Stats = C3DEngineContextGetStats(v2);
  double v4 = CACurrentMediaTime();
  Quaduint64_t Mesh = (void *)C3DEngineContextGetQuadMesh(a1[3]);
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(v2);
  if (RendererContextGL)
  {
    uint64_t v7 = RendererContextGL;
    uint64_t ResourceManager = C3DEngineContextGetResourceManager(v2);
    C3DRendererContextSetEnable(v7, 2, 0);
    C3DRendererContextSetEnable(v7, 1, 1);
    C3DRendererContextSetEnableWriteToDepth(v7, 0);
    C3DRendererContextBindMesh(v7, ResourceManager, QuadMesh);
    ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)QuadMesh, 0, 1);
    C3DRendererContextBindMeshElement(v7, ResourceManager, ElementAtIndex);
    C3DRendererContextRenderResidentMeshElement(v7);
    C3DRendererContextSetEnable(v7, 2, 1);
    C3DRendererContextSetEnableWriteToDepth(v7, 1);
  }
  else
  {
    uint64_t RenderContext = C3DEngineContextGetRenderContext(v2);
    *(void *)(a1[8] + 24) = QuadMesh;
    *(void *)(a1[8] + 4_Block_object_dispose(&STACK[0x2A0], 8) = C3DMeshGetElementAtIndex((uint64_t)QuadMesh, 0, 1);
    -[SCNMTLRenderContext drawRenderElement:withPass:](RenderContext, a1[8], *a1);
    uint64_t v11 = a1[8];
    *(void *)(v11 + 24) = 0;
    *(void *)(v11 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
  double result = *(double *)(Stats + 160) + CACurrentMediaTime() - v4;
  *(double *)(Stats + 160) = result;
  return result;
}

void WireframeMesh::WireframeMesh(WireframeMesh *this, __C3DMesh *a2)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  WireframeMesh::Prepare(this, a2);
}

void sub_20B334F48(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x2A0], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void WireframeMesh::Prepare(WireframeMesh *this, __C3DMesh *a2)
{
  Positionuint64_t Source = C3DMeshGetPositionSource((uint64_t)a2, 1);
  float v50 = a2;
  CFArrayRef ElementsCount = C3DMeshGetElementsCount((uint64_t)a2);
  if ((uint64_t)ElementsCount >= 1)
  {
    CFIndex v4 = 0;
    double v46 = (char *)this + 16;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    float v48 = this;
    while (1)
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)v50, v4, 1);
      unsigned int Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      if (Type > 5 || ((1 << Type) & 0x23) == 0 || PrimitiveCount == 0) {
        return;
      }
      uint64_t v10 = PrimitiveCount;
      uint64_t v11 = 3 * PrimitiveCount;
      uint64_t v12 = 12 * PrimitiveCount;
      uint64_t v60 = (UInt8 *)malloc_type_malloc(12 * PrimitiveCount, 0xFD6D76EAuLL);
      uint64_t v13 = 16 * v11;
      bytes = (UInt8 *)malloc_type_malloc(v13, 0x4CE48766uLL);
      v63[0] = 0;
      CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, v63);
      CFIndex v51 = v4;
      CFIndex v52 = v12;
      if (v63[0] == 4)
      {
        BytePtr = CFDataGetBytePtr(Indexes);
        double v54 = 0;
        uint64_t v55 = 0;
      }
      else if (v63[0] == 2)
      {
        double v54 = CFDataGetBytePtr(Indexes);
        uint64_t v55 = 0;
        BytePtr = 0;
      }
      else
      {
        uint64_t v55 = v63[0] == 1 ? CFDataGetBytePtr(Indexes) : 0;
        BytePtr = 0;
        double v54 = 0;
      }
      if (v10 >= 1) {
        break;
      }
LABEL_39:
      uint64_t v28 = C3DMeshCreate();
      CFDataRef v29 = CFDataCreate(allocator, bytes, v13);
      long long v30 = (const void *)C3DMeshSourceCreate(v29, 0, 3 * v10, 4, 1);
      CFRelease(v29);
      C3DMeshAddSource(v28, v30, 0, 0);
      CFRelease(v30);
      uint64_t v31 = C3DMeshElementCreate();
      C3DMeshElementSetType(v31, 0);
      CFDataRef v32 = CFDataCreate(allocator, v60, v52);
      C3DMeshElementSetPrimitives(v31, v10, v32, 4);
      CFRelease(v32);
      long long v34 = (uint64_t *)*((void *)v48 + 1);
      unint64_t v33 = *((void *)v48 + 2);
      if ((unint64_t)v34 >= v33)
      {
        uint64_t v37 = ((uint64_t)v34 - *(void *)v48) >> 4;
        unint64_t v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) >> 60) {
          abort();
        }
        uint64_t v39 = v33 - *(void *)v48;
        if (v39 >> 3 > v38) {
          unint64_t v38 = v39 >> 3;
        }
        if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v40 = v38;
        }
        if (v40) {
          int v41 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)v46, v40);
        }
        else {
          int v41 = 0;
        }
        uint64_t v42 = (uint64_t *)&v41[16 * v37];
        *uint64_t v42 = v28;
        v42[1] = v31;
        double v44 = *(char **)v48;
        double v43 = (char *)*((void *)v48 + 1);
        double v45 = v42;
        if (v43 == *(char **)v48)
        {
          CFIndex v36 = v51;
        }
        else
        {
          CFIndex v36 = v51;
          do
          {
            *((_OWORD *)v45 - 1) = *((_OWORD *)v43 - 1);
            v45 -= 2;
            v43 -= 16;
          }
          while (v43 != v44);
          double v43 = *(char **)v48;
        }
        long long v35 = v42 + 2;
        *(void *)float v48 = v45;
        *((void *)v48 + 1) = v42 + 2;
        *((void *)v48 + 2) = &v41[16 * v40];
        if (v43) {
          operator delete(v43);
        }
      }
      else
      {
        uint64_t *v34 = v28;
        v34[1] = v31;
        long long v35 = v34 + 2;
        CFIndex v36 = v51;
      }
      *((void *)v48 + 1) = v35;
      free(v60);
      free(bytes);
      CFIndex v4 = v36 + 1;
      if ((const __CFArray *)v4 == ElementsCount) {
        return;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unsigned int v17 = 6;
    unsigned int v18 = 1;
    unsigned int v19 = 2;
    uint64_t v58 = v10;
    unsigned int v57 = Type;
    while (1)
    {
      if (Type == 5)
      {
        uint64_t v20 = 0;
        uint64_t v21 = (2 * v16) | 1;
        uint64_t v22 = 2 * v16 + 2;
      }
      else if (Type == 1)
      {
        uint64_t v23 = 2 * v16;
        if (v16)
        {
          uint64_t v21 = v23 | 1;
          uint64_t v22 = v23 + 2;
        }
        else
        {
          uint64_t v21 = v23 + 2;
          uint64_t v22 = v23 | 1;
        }
        uint64_t v20 = v16;
      }
      else if (Type)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v20 = 3 * v16;
        uint64_t v21 = v15 + 1;
        uint64_t v22 = v15 + 2;
      }
      switch(v63[0])
      {
        case 4:
          uint64_t v20 = *(unsigned int *)&BytePtr[4 * v20];
          uint64_t v61 = *(unsigned int *)&BytePtr[4 * v21];
          uint64_t v24 = *(unsigned int *)&BytePtr[4 * v22];
          break;
        case 2:
          uint64_t v20 = *(unsigned __int16 *)&v54[2 * v20];
          uint64_t v61 = *(unsigned __int16 *)&v54[2 * v21];
          uint64_t v24 = *(unsigned __int16 *)&v54[2 * v22];
          break;
        case 1:
          uint64_t v20 = v55[v20];
          uint64_t v61 = v55[v21];
          uint64_t v24 = v55[v22];
          break;
        default:
          uint64_t v62 = v22;
          uint64_t v61 = v21;
          goto LABEL_38;
      }
      uint64_t v62 = v24;
LABEL_38:
      *(double *)&bytes[4 * v17 - 24] = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)PositionSource, v20);
      *(_DWORD *)&bytes[4 * v17 - 16] = v25;
      *(float *)&bytes[4 * v17 - 12] = (float)(v15 % 3);
      *(_DWORD *)&v60[4 * v15] = v15;
      *(double *)&bytes[4 * v17 - 8] = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)PositionSource, v61);
      *(_DWORD *)&bytes[4 * v17] = v26;
      *(float *)&bytes[4 * v17 + 4] = (float)(v15 + 1 - 3 * (v18 / 3));
      *(_DWORD *)&v60[4 * (v15 + 1)] = v15 + 1;
      *(double *)&bytes[4 * v17 + 8] = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)PositionSource, v62);
      *(_DWORD *)&bytes[4 * v17 + 16] = v27;
      *(float *)&bytes[4 * v17 + 20] = (float)(v15 + 2 - 3 * (v19 / 3));
      *(_DWORD *)&v60[4 * (v15 + 2)] = v15 + 2;
      ++v16;
      v17 += 12;
      v18 += 3;
      v19 += 3;
      v15 += 3;
      uint64_t v10 = v58;
      unsigned int Type = v57;
      if (v58 == v16) {
        goto LABEL_39;
      }
    }
  }
}

void WireframeMesh::~WireframeMesh(WireframeMesh *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  if (*(void *)this != v3)
  {
    do
    {
      CFIndex v4 = *(const void **)(v2 + 8);
      CFRelease(*(CFTypeRef *)v2);
      CFRelease(v4);
      v2 += 16;
    }
    while (v2 != v3);
    uint64_t v2 = *(void *)this;
  }
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete((void *)v2);
  }
}

void sub_20B3354EC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x2A0], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t WireframeMesh::Draw(WireframeMesh *this, __C3DEngineContext *a2, __C3DFXProgram *a3, const C3DMatrix4x4 *a4, float32x4_t *a5, uint64_t a6)
{
  *((void *)this + 3) = a6;
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a2);
  if (RendererContextGL)
  {
    uint64_t v12 = RendererContextGL;
    glPushGroupMarkerEXT(0, "SceneKit - Draw wireframe");
    uint64_t ResourceManager = C3DEngineContextGetResourceManager((uint64_t)a2);
    ProgramResident = C3DResourceManagerMakeProgramResident(ResourceManager, a3, v12);
    C3DRendererContextBindProgramObject(v12, ProgramResident);
    uint64_t v15 = C3DBlendStatesDefaultOver();
    C3DRendererContextSetBlendStates(v12, v15);
    C3DRendererContextSetEnableReadsFromDepth(v12, 1);
    uint64_t UniformLocationOfSymbolNamed = C3DFXGLSLProgramObjectGetUniformLocationOfSymbolNamed((uint64_t)ProgramResident, @"u_modelViewProjectionTransform");
    C3DRendererContextSetMatrix4x4UniformAtLocation(v12, UniformLocationOfSymbolNamed, a4->components, 1);
    C3DRendererContextSetEnable(v12, 2, 1);
    C3DRendererContextSetEnable(v12, 1, 1);
    glEnable(0x8037u);
    glPolygonOffset(-2.0, -2.0);
    uint64_t v17 = C3DFXGLSLProgramObjectGetUniformLocationOfSymbolNamed((uint64_t)ProgramResident, @"u_color");
    C3DRendererContextSetColor4UniformAtLocation(v12, v17, a5, 1);
    uint64_t v18 = C3DFXGLSLProgramObjectGetUniformLocationOfSymbolNamed((uint64_t)ProgramResident, @"u_transform");
    C3DRendererContextSetMatrix4x4UniformAtLocation(v12, v18, a4->components, 1);
    uint64_t v19 = *(void *)this;
    uint64_t v20 = *((void *)this + 1);
    while (v19 != v20)
    {
      uint64_t v21 = *(void **)v19;
      uint64_t v22 = *(const void **)(v19 + 8);
      v19 += 16;
      C3DRendererContextBindMesh(v12, ResourceManager, v21);
      C3DRendererContextBindMeshElement(v12, ResourceManager, v22);
      C3DRendererContextRenderResidentMeshElement(v12);
    }
    C3DRendererContextUnbindProgramObject(v12);
    glDisable(0x8037u);
    glPopGroupMarkerEXT();
  }
  uint64_t result = C3DEngineContextGetRenderContext((uint64_t)a2);
  if (result)
  {
    uint64_t v24 = result;
    -[SCNMTLRenderContext pushDebugGroup:](result, @"SceneKit - Draw wireframe");
    int v25 = *(uint64_t **)this;
    int v26 = (uint64_t *)*((void *)this + 1);
    if (*(uint64_t **)this != v26)
    {
      do
      {
        uint64_t v27 = *v25;
        uint64_t v28 = v25[1];
        v25 += 2;
        long long v29 = *(_OWORD *)&a4->components[4];
        long long v30 = *(_OWORD *)&a4->components[8];
        long long v31 = *(_OWORD *)&a4->components[12];
        v33[0] = *(_OWORD *)a4->components;
        v33[1] = v29;
        v33[2] = v30;
        v33[3] = v31;
        v33[4] = *a5;
        uint64_t v32 = C3DBlendStatesDefaultOver();
        -[SCNMTLRenderContext authoring_renderMesh:meshElement:withProgram:uniforms:uniformsLength:rasterizerStates:blendStates:texture:depthBias:](v24, v27, v28, (uint64_t)a3, v33, 0x50uLL, 0, v32, 0, 1);
      }
      while (v25 != v26);
    }
    return -[SCNMTLRenderContext popDebugGroup](v24);
  }
  return result;
}

void WireframeMeshRenderer::AddInstance(WireframeMeshRenderer *this, __C3DMesh *a2, C3DColor4 a3, C3DMatrix4x4 *a4)
{
}

uint64_t WireframeMeshRenderer::GetWireframeMesh(WireframeMeshRenderer *this, __C3DMesh *a2)
{
  uint64_t v8 = a2;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (!v2) {
    goto LABEL_12;
  }
  uint64_t v3 = (void *)((char *)this + 32);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= (unint64_t)a2;
    if (v4 >= (unint64_t)a2) {
      float v6 = v2;
    }
    else {
      float v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (void *)((char *)this + 32) || v3[4] > (unint64_t)a2) {
LABEL_12:
  }
    operator new();
  return v3[5];
}

void sub_20B335930(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x1020C4016EE4530);
  _Unwind_Resume(a1);
}

uint64_t WireframeMeshRenderer::DrawInstances(WireframeMeshRenderer *this, __C3DEngineContext *a2, __C3DFXProgram *a3)
{
  unint64_t v4 = *(uint64_t **)this;
  BOOL v5 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v5)
  {
    do
    {
      uint64_t v8 = *v4++;
      WireframeMesh::Draw(*(WireframeMesh **)v8, a2, a3, (const C3DMatrix4x4 *)(v8 + 32), (float32x4_t *)(v8 + 16), *((void *)this + 6));
      MEMORY[0x210534FE0](v8, 0x1020C406DF670C8);
    }
    while (v4 != v5);
    unint64_t v4 = *(uint64_t **)this;
  }
  *((void *)this + 1) = v4;
  ++*((void *)this + 6);

  return WireframeMeshRenderer::Purge((uint64_t)this);
}

uint64_t WireframeMeshRenderer::Purge(uint64_t this)
{
  uint64_t v1 = (uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 24);
  uint64_t v3 = (uint64_t *)(this + 32);
  if (v2 != (uint64_t *)(this + 32))
  {
    uint64_t v4 = this;
    do
    {
      BOOL v5 = (WireframeMesh *)v2[5];
      if (*((void *)v5 + 3) >= *(void *)(v4 + 48) - 100)
      {
        uint64_t v7 = (uint64_t *)v2[1];
        if (v7)
        {
          do
          {
            float v6 = v7;
            uint64_t v7 = (uint64_t *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            float v6 = (uint64_t *)v2[2];
            BOOL v8 = *v6 == (void)v2;
            uint64_t v2 = v6;
          }
          while (!v8);
        }
      }
      else
      {
        float v6 = std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer(v1, v2);
        operator delete(v2);
        WireframeMesh::~WireframeMesh(v5);
        this = MEMORY[0x210534FE0]();
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
  }
  return this;
}

void C3DWireframeAddInstance(WireframeMeshRenderer *a1, __C3DMesh *a2, C3DColor4 a3, _OWORD *a4)
{
  long long v4 = a4[1];
  *(_OWORD *)v6.components = *a4;
  *(_OWORD *)&v6.components[4] = v4;
  long long v5 = a4[3];
  *(_OWORD *)&v6.components[8] = a4[2];
  *(_OWORD *)&v6.components[12] = v5;
  WireframeMeshRenderer::AddInstance(a1, a2, a3, &v6);
}

void C3DWireframeDrawInstances(WireframeMeshRenderer *a1, __C3DEngineContext *a2, __C3DFXProgram *a3)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a2);
  if (RendererContextGL)
  {
    uint64_t v7 = RendererContextGL;
    C3DRendererContextResetToDefaultStates(RendererContextGL);
    WireframeMeshRenderer::DrawInstances(a1, a2, a3);
    C3DRendererContextResetToDefaultStates(v7);
    C3DRendererContextSetEnable(v7, 1, 1);
  }
  else
  {
    WireframeMeshRenderer::DrawInstances(a1, a2, a3);
  }
}

void C3DWireframeRendererCreate()
{
}

WireframeMeshRenderer *C3DWireframeRendererDestroy(WireframeMeshRenderer *result)
{
  if (result)
  {
    WireframeMeshRenderer::~WireframeMeshRenderer(result);
    JUMPOUT(0x210534FE0);
  }
  return result;
}

void WireframeMeshRenderer::~WireframeMeshRenderer(WireframeMeshRenderer *this)
{
  std::__tree<char>::destroy((uint64_t)this + 24, *((void **)this + 4));
  uint64_t v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t SCNPhysicsShapeDestroyShape(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = (void *)result;
  int v2 = *(_DWORD *)(result + 8);
  if (v2 == 21)
  {
    uint64_t v7 = *(void *)(result + 80);
    if (!v7) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (v2 != 22)
  {
    if (v2 == 31)
    {
      uint64_t v3 = *(unsigned int *)(result + 28);
      if ((int)v3 >= 1)
      {
        uint64_t v4 = 0;
        uint64_t v5 = 96 * v3;
        do
        {
          uint64_t v6 = v1[5] + v4;
          if (*(unsigned char *)(v6 + 88)) {
            SCNPhysicsShapeDestroyShape(*(btCollisionShape **)(v6 + 64));
          }
          v4 += 96;
        }
        while (v5 != v4);
      }
    }
    goto LABEL_16;
  }
  uint64_t v7 = *(void *)(*(void *)(result + 48) + 80);
  if (v7) {
LABEL_15:
  }
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
LABEL_16:
  BOOL v8 = *(uint64_t (**)(void *))(*v1 + 8);

  return v8(v1);
}

btStridingMeshInterface *_createShapeForGeometry(__C3DGeometry *a1, NSDictionary *a2)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == C3DParametricGeometryGetTypeID()
    && ![(NSDictionary *)a2 objectForKey:@"SCNPhysicsShapeTypeKey"])
  {
    memset(&__s1, 0, 48);
    C3DParametricGeometryGetCallbacks((uint64_t)a1, (uint64_t)&__s1);
    if (!memcmp(&__s1, &kC3DBoxCallBacks, 0x30uLL))
    {
      Floatunint64_t Value = C3DParametricGeometryGetFloatValue((uint64_t)a1, 0);
      double v55 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      double v9 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 2);
      uint64_t v8 = btAlignedAllocInternal(80, 16);
      float v10 = v9;
      v11.f64[0] = FloatValue;
      v11.f64[1] = v55;
      *(float32x2_t *)v61.var0.var0 = vmul_f32(vcvt_f32_f64(v11), (float32x2_t)0x3F0000003F000000);
      *(void *)&v61.var0.var0[2] = COERCE_UNSIGNED_INT(v10 * 0.5);
      btBoxShape::btBoxShape((btBoxShape *)v8, &v61);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DPyramidCallBacks, 0x30uLL))
    {
      double v12 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 0);
      double v13 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      double v14 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 2);
      float v15 = v12;
      v61.var0.var0[0] = 0.0;
      float v16 = v13;
      *(float *)&double v14 = v14;
      v61.var0.var0[1] = v16;
      *(void *)&v61.var0.var0[2] = 0;
      float v62 = v15 * -0.5;
      int v63 = 0;
      float v64 = *(float *)&v14 * -0.5;
      int v65 = 0;
      float v66 = v15 * -0.5;
      int v67 = 0;
      float v68 = *(float *)&v14 * 0.5;
      int v69 = 0;
      float v70 = v15 * 0.5;
      int v71 = 0;
      float v72 = *(float *)&v14 * -0.5;
      int v73 = 0;
      float v74 = v15 * 0.5;
      int v75 = 0;
      float v76 = *(float *)&v14 * 0.5;
      int v77 = 0;
      uint64_t v8 = btAlignedAllocInternal(192, 16);
      btConvexHullShape::btConvexHullShape((btConvexHullShape *)v8, v61.var0.var0, 5, 16, 0, 0);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DCylinderCallBacks, 0x30uLL))
    {
      double v17 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 4);
      double v18 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      uint64_t v8 = btAlignedAllocInternal(80, 16);
      *(float *)&unsigned int v19 = v17;
      float v20 = v18;
      LODWORD(v61.var0.var0[0]) = v19;
      v61.var0.var0[1] = v20 * 0.5;
      *(void *)&v61.var0.var0[2] = v19;
      btCylinderShape::btCylinderShape((btCylinderShape *)v8, &v61);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DConeCallBacks, 0x30uLL))
    {
      float v21 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 5);
      if (v21 != 0.0 && (_createShapeForGeometry(__C3DGeometry *,NSDictionary *)::done & 1) == 0)
      {
        _createShapeForGeometry(__C3DGeometry *,NSDictionary *)::done = 1;
        uint64_t v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          _createShapeForGeometry();
        }
      }
      double v23 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 6);
      double v24 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      uint64_t v8 = btAlignedAllocInternal(96, 16);
      float v25 = v23;
      float v26 = v24;
      btConeShape::btConeShape((btConeShape *)v8, v25, v26);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DTubeCallBacks, 0x30uLL))
    {
      double v27 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 8);
      double v28 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      uint64_t v8 = btAlignedAllocInternal(80, 16);
      *(float *)&unsigned int v29 = v27;
      float v30 = v28;
      LODWORD(v61.var0.var0[0]) = v29;
      v61.var0.var0[1] = v30 * 0.5;
      *(void *)&v61.var0.var0[2] = v29;
      btCylinderShape::btCylinderShape((btCylinderShape *)v8, &v61);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DCapsuleCallBacks, 0x30uLL))
    {
      double v31 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 4);
      double v32 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      uint64_t v8 = btAlignedAllocInternal(80, 16);
      float v33 = v31;
      float v34 = v32;
      btCapsuleShape::btCapsuleShape((btCapsuleShape *)v8, v33, v34 + (float)(v33 * -2.0));
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DTorusCallBacks, 0x30uLL))
    {
      double v35 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 9);
      double v36 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 10);
      uint64_t v37 = 0;
      *(float *)&double v36 = v36;
      float v38 = v35;
      float v53 = v38;
      int32x2_t v39 = vdup_lane_s32(*(int32x2_t *)&v36, 0);
      int32x2_t v40 = (int32x2_t)0x100000000;
      int v41 = &v61;
      float64x2_t v52 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
      uint64_t v42 = 0;
      do
      {
        float64x2_t v43 = vmulq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_s32(v40), (float32x2_t)0x3E0000003E000000)), v52);
        *(float32x2_t *)&v43.f64[0] = vcvt_f32_f64(vaddq_f64(v43, v43));
        float v54 = *(float *)v43.f64;
        __float2 v44 = __sincosf_stret(*((float *)v43.f64 + 1));
        __float2 v45 = __sincosf_stret(v54);
        float32x2_t v46 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v44.__sinval), LODWORD(v45.__sinval)), v53);
        float32x2_t v47 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v44.__cosval), LODWORD(v45.__cosval)), v53);
        uint64_t v48 = 0;
        vst4_f32(v41->var0.var0, *(float32x2x4_t *)(&v42 - 1));
        v41 += 2;
        *(int32x2_t *)&v60[v37] = v39;
        int32x2_t v40 = vadd_s32(v40, (int32x2_t)0x200000002);
        v37 += 2;
      }
      while (v37 != 8);
      uint64_t v8 = btAlignedAllocInternal(192, 16);
      btMultiSphereShape::btMultiSphereShape((btMultiSphereShape *)v8, &v61, v60, 8);
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DSphereCallBacks, 0x30uLL))
    {
      double v49 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 4);
      uint64_t v8 = btAlignedAllocInternal(80, 16);
      btConvexInternalShape::btConvexInternalShape((btConvexInternalShape *)v8);
      *(void *)uint64_t v8 = &unk_26BF69840;
      *(_DWORD *)(v8 + _Block_object_dispose(&STACK[0x2A0], 8) = 8;
      float v50 = v49;
      *(float *)(v8 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v50;
      *(float *)(v8 + 64) = v50;
      return (btStridingMeshInterface *)v8;
    }
    if (!memcmp(&__s1, kC3DPlaneCallBacks, 0x30uLL))
    {
      double v58 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 0);
      double v56 = C3DParametricGeometryGetFloatValue((uint64_t)a1, 1);
      uint64_t v8 = btAlignedAllocInternal(224, 16);
      v51.f64[0] = v58;
      v51.f64[1] = v56;
      btVector3 v61 = (btVector3)*(unint64_t *)&vmul_f32(vcvt_f32_f64(v51), (float32x2_t)0x3F0000003F000000);
      btBox2dShape::btBox2dShape((btBox2dShape *)v8, (float32x4_t *)&v61);
      return (btStridingMeshInterface *)v8;
    }
    return 0;
  }
  if (v4 == C3DFloorGetTypeID())
  {
    uint64_t v5 = (__n128 *)C3DGetScene(a1);
    v61.var0.var0[2] = 0.0;
    *(void *)v61.var0.var0 = 0;
    if (v5) {
      C3DSceneGetUpAxis(v5, (__n128 *)&v61);
    }
    else {
      btVector3 v61 = (btVector3)xmmword_20B5CB7D0;
    }
    uint64_t v8 = btAlignedAllocInternal(112, 16);
    __s1.i64[0] = *(void *)v61.var0.var0;
    __s1.i64[1] = LODWORD(v61.var0.var0[2]);
    btStaticPlaneShape::btStaticPlaneShape((btStaticPlaneShape *)v8, &__s1, 0.0);
    return (btStridingMeshInterface *)v8;
  }
  uint64_t Mesh = (__C3DMesh *)C3DGeometryGetMesh((uint64_t)a1);
  if (!Mesh) {
    return 0;
  }

  return _createShapeForEntity(Mesh, a2);
}

void sub_20B336900(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

btStridingMeshInterface *_createShapeForNode(__C3DMesh *a1, NSDictionary *a2)
{
  id v4 = [(NSDictionary *)a2 valueForKey:@"SCNPhysicsShapeKeepAsCompoundKey"];
  if (v4 && ![v4 BOOLValue]) {
    return _createShapeForEntity(a1, a2);
  }
  v14.columns[0].i64[0] = 0;
  v14.columns[0].i64[1] = (uint64_t)&v14;
  v14.columns[1].i64[0] = 0x2020000000;
  v14.columns[1].i32[2] = 0;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = ___Z19_createShapeForNodeP9__C3DNodeP12NSDictionary_block_invoke;
  v15[3] = &unk_2640062A0;
  void v15[4] = &v14;
  C3DNodeApplyHierarchy((uint64_t)a1, (uint64_t)v15);
  int v5 = *(_DWORD *)(v14.columns[0].i64[1] + 24);
  _Block_object_dispose(&v14, 8);
  if (v5 < 2) {
    return _createShapeForEntity(a1, a2);
  }
  uint64_t v6 = (btCompoundShape *)btAlignedAllocInternal(128, 16);
  btCompoundShape::btCompoundShape(v6, 1);
  WorldMatrix = (simd_float4x4 *)C3DNodeGetWorldMatrix((float32x4_t *)a1);
  C3DMatrix4x4Invert(WorldMatrix, &v14);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = ___Z19_createShapeForNodeP9__C3DNodeP12NSDictionary_block_invoke_2;
  v10[3] = &unk_2640062C8;
  simd_float4x4 v11 = v14;
  double v12 = a2;
  double v13 = v6;
  C3DNodeApplyHierarchy((uint64_t)a1, (uint64_t)v10);
  if (*((_DWORD *)v6 + 7))
  {
    btCompoundShape::createAabbTreeFromChildren(v6);
  }
  else
  {
    (*(void (**)(btCompoundShape *))(*(void *)v6 + 8))(v6);
    double v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      _createShapeForNode();
    }
    return 0;
  }
  return v6;
}

void sub_20B336B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  btAlignedFreeInternal(v23);
  _Unwind_Resume(a1);
}

btCompoundShape *_createShapeForArrayOfShapes(NSArray *a1, NSArray *a2)
{
  id v4 = (btCompoundShape *)btAlignedAllocInternal(128, 16);
  btCompoundShape::btCompoundShape(v4, 0);
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  void v7[2] = ___Z28_createShapeForArrayOfShapesP7NSArrayS0__block_invoke;
  v7[3] = &unk_264006278;
  v7[4] = a2;
  v7[5] = v4;
  [(NSArray *)a1 enumerateObjectsUsingBlock:v7];
  if (*((_DWORD *)v4 + 7))
  {
    btCompoundShape::createAabbTreeFromChildren(v4);
  }
  else
  {
    (*(void (**)(btCompoundShape *))(*(void *)v4 + 8))(v4);
    int v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      _createShapeForNode();
    }
    return 0;
  }
  return v4;
}

void sub_20B336C48(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

BOOL __fillMeshElementInfo(uint64_t a1, const UInt8 **a2, _DWORD *a3, int *a4, int *a5)
{
  if (C3DMeshElementGetType(a1))
  {
    float v10 = scn_default_log();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    *(_WORD *)double v18 = 0;
    _os_log_impl(&dword_20B249000, v10, OS_LOG_TYPE_INFO, "Info: Non triangle list element type not yet supported in physics shape generation", v18, 2u);
    return 0;
  }
  int v19 = 0;
  uint64_t Indexes = C3DMeshElementGetIndexes(a1, &v19);
  if (Indexes)
  {
    CFDataRef v13 = (const __CFData *)Indexes;
    IndexCFIndex Count = C3DMeshElementGetIndexCount(a1);
    *a2 = CFDataGetBytePtr(v13);
    int v15 = v19;
    *a3 = 3 * v19;
    *a4 = IndexCount / 3;
    switch(v15)
    {
      case 1:
        int v16 = 5;
        goto LABEL_11;
      case 4:
        int v16 = 2;
        goto LABEL_11;
      case 2:
        int v16 = 3;
LABEL_11:
        *a5 = v16;
        return 1;
    }
    double v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      __fillMeshElementInfo(v17);
    }
  }
  return 0;
}

uint64_t _createMeshInterfaceForMesh(__C3DMesh *a1)
{
  SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a1, 0, 0, 1);
  if (!SourceWithSemanticAtIndex) {
    return 0;
  }
  uint64_t v3 = (uint64_t)SourceWithSemanticAtIndex;
  uint64_t Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  int Library = C3DSceneSourceGetLibrary(Accessor);
  int Count = C3DMeshSourceGetCount(v3);
  CFDataRef Data = (const __CFData *)C3DMeshSourceGetData(v3);
  BytePtr = CFDataGetBytePtr(Data);
  ComponentsValueunsigned int Type = C3DSourceAccessorGetComponentsValueType(Accessor);
  if (ComponentsValueType != 1)
  {
    if (ComponentsValueType == 6)
    {
      int v9 = 1;
      goto LABEL_7;
    }
    return 0;
  }
  int v9 = 0;
LABEL_7:
  uint64_t v10 = btAlignedAllocInternal(112, 16);
  *(_OWORD *)(v10 + 16) = xmmword_20B5CC200;
  *(void *)uint64_t v10 = &unk_26BF6BDE8;
  *(unsigned char *)(v10 + 56) = 1;
  *(void *)(v10 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(_DWORD *)(v10 + 36) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(_DWORD *)(v10 + 72) = 0;
  CFArrayRef ElementsCount = C3DMeshGetElementsCount((uint64_t)a1);
  if ((uint64_t)ElementsCount >= 1)
  {
    CFArrayRef v12 = ElementsCount;
    for (CFIndex i = 0; (const __CFArray *)i != v12; ++i)
    {
      ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)a1, i, 1);
      float v21 = BytePtr;
      int v22 = Library;
      int v23 = 2;
      int v24 = v9;
      v20[1] = Count;
      int v17 = 0;
      if (__fillMeshElementInfo((uint64_t)ElementAtIndex, &v19, v20, &v18, &v17)) {
        btTriangleIndexVertexArray::addIndexedMesh(v10, (uint64_t)&v18, v17);
      }
    }
  }
  return v10;
}

__n128 btTriangleIndexVertexArray::addIndexedMesh(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 == *(_DWORD *)(a1 + 40))
  {
    int v7 = v6 ? 2 * v6 : 1;
    if (v6 < v7)
    {
      if (v7)
      {
        uint64_t v8 = btAlignedAllocInternal(48 * v7, 16);
        int v6 = *(_DWORD *)(a1 + 36);
      }
      else
      {
        uint64_t v8 = 0;
      }
      if (v6 >= 1)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 48 * v6;
        do
        {
          simd_float4x4 v11 = (_OWORD *)(v8 + v9);
          CFArrayRef v12 = (long long *)(*(void *)(a1 + 48) + v9);
          long long v13 = *v12;
          long long v14 = v12[2];
          v11[1] = v12[1];
          v11[2] = v14;
          *simd_float4x4 v11 = v13;
          v9 += 48;
        }
        while (v10 != v9);
      }
      int v15 = *(void ***)(a1 + 48);
      if (v15 && *(unsigned char *)(a1 + 56)) {
        btAlignedFreeInternal(v15);
      }
      *(unsigned char *)(a1 + 56) = 1;
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v8;
      *(_DWORD *)(a1 + 40) = v7;
      int v6 = *(_DWORD *)(a1 + 36);
    }
  }
  uint64_t v16 = *(void *)(a1 + 48) + 48 * v6;
  __n128 result = *(__n128 *)a2;
  long long v18 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v16 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v16 + 32) = v18;
  *(__n128 *)uint64_t v16 = result;
  LODWORD(v16) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = v16 + 1;
  *(_DWORD *)(*(void *)(a1 + 48) + 48 * (int)v16 + 36) = a3;
  return result;
}

btC3DMultiMeshInterface *_createMeshInterfaceForEntity(__C3DMesh *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == C3DMeshGetTypeID())
  {
    return (btC3DMultiMeshInterface *)_createMeshInterfaceForMesh(a1);
  }
  else
  {
    if (v2 != C3DNodeGetTypeID()) {
      return 0;
    }
    id v4 = (btC3DMultiMeshInterface *)btAlignedAllocInternal(96, 16);
    btC3DMultiMeshInterface::btC3DMultiMeshInterface(v4, (float32x4_t *)a1);
    return v4;
  }
}

void sub_20B3371DC(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

btStridingMeshInterface *_createConvexHullForEntity(__C3DMesh *a1)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  MeshInterfaceForEntity = _createMeshInterfaceForEntity(a1);
  if (!MeshInterfaceForEntity) {
    return MeshInterfaceForEntity;
  }
  double v31 = (id *)a1;
  int v3 = 0;
  int v4 = 0;
  uint64_t v5 = 0;
  for (int i = 0; ; ++i)
  {
    int v7 = (void **)v5;
    int v8 = v4;
    if (i >= (*(int (**)(btStridingMeshInterface *))(*(void *)MeshInterfaceForEntity + 56))(MeshInterfaceForEntity)) {
      break;
    }
    uint64_t v36 = 0;
    *(void *)uint64_t v37 = 0;
    int v35 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    int v32 = 0;
    (*(void (**)(btStridingMeshInterface *, uint8_t *, char *, uint64_t *, int *, uint64_t *, char *, uint64_t *, int *, int))(*(void *)MeshInterfaceForEntity + 32))(MeshInterfaceForEntity, v37, (char *)&v36 + 4, &v36, &v35, &v34, (char *)&v33 + 4, &v33, &v32, i);
    v4 += HIDWORD(v36);
    if ((v36 & 0x8000000000000000) == 0 && HIDWORD(v36) && v3 < v4)
    {
      if (v4) {
        uint64_t v5 = btAlignedAllocInternal(16 * v4, 16);
      }
      else {
        uint64_t v5 = 0;
      }
      if (v8 >= 1)
      {
        uint64_t v9 = v8;
        uint64_t v10 = (_OWORD *)v5;
        simd_float4x4 v11 = v7;
        do
        {
          long long v12 = *(_OWORD *)v11;
          v11 += 2;
          *v10++ = v12;
          --v9;
        }
        while (v9);
LABEL_16:
        btAlignedFreeInternal(v7);
        int v3 = v4;
        goto LABEL_17;
      }
      if (v7) {
        goto LABEL_16;
      }
      int v3 = v4;
    }
LABEL_17:
    if (v36)
    {
      if ((_createConvexHullForEntity(__C3DEntity *)::done & 1) == 0)
      {
        _createConvexHullForEntity(__C3DEntity *)::done = 1;
        long long v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float32x4_t buf = 67109120;
          int v39 = v36;
          _os_log_error_impl(&dword_20B249000, v13, OS_LOG_TYPE_ERROR, "Error: vertex format not supported for physics shape creation (%d)", buf, 8u);
        }
      }
    }
    else
    {
      uint64_t v14 = HIDWORD(v36);
      if (SHIDWORD(v36) >= 1)
      {
        uint64_t v15 = v35;
        uint64_t v16 = (_OWORD *)(v5 + 16 * v8);
        int v17 = (_DWORD *)(*(void *)v37 + 8);
        do
        {
          *(void *)&long long v18 = *((void *)v17 - 1);
          DWORD2(v1_Block_object_dispose(&STACK[0x2A0], 8) = *v17;
          int v17 = (_DWORD *)((char *)v17 + v15);
          *((void *)&v18 + 1) = DWORD2(v18);
          *v16++ = v18;
          --v14;
        }
        while (v14);
      }
    }
  }
  int v19 = (btConvexTriangleMeshShape *)btAlignedAllocInternal(128, 16);
  btConvexTriangleMeshShape::btConvexTriangleMeshShape(v19, MeshInterfaceForEntity, 1);
  float v20 = (btShapeHull *)btAlignedAllocInternal(80, 16);
  btShapeHull::btShapeHull(v20, v19);
  float v21 = (*(float (**)(btConvexTriangleMeshShape *))(*(void *)v19 + 96))(v19);
  btShapeHull::buildHull(v20, v21);
  (*(void (**)(btConvexTriangleMeshShape *))(*(void *)v19 + 8))(v19);
  (*(void (**)(btStridingMeshInterface *))(*(void *)MeshInterfaceForEntity + 8))(MeshInterfaceForEntity);
  int v22 = (const float *)*((void *)v20 + 2);
  int v23 = btShapeHull::numVertices(v20);
  int v24 = (const unsigned int *)*((void *)v20 + 6);
  int v25 = btShapeHull::numTriangles(v20);
  if (v23 && v22)
  {
    int v26 = v25;
    MeshInterfaceForEntity = (btStridingMeshInterface *)btAlignedAllocInternal(192, 16);
    btConvexHullShape::btConvexHullShape(MeshInterfaceForEntity, v22, v23, 16, v24, v26);
  }
  else
  {
    double v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      ObjCWrapper = C3DEntityGetObjCWrapper(v31);
      *(_DWORD *)uint64_t v37 = 138412290;
      *(void *)&v37[4] = ObjCWrapper;
      _os_log_impl(&dword_20B249000, v27, OS_LOG_TYPE_DEFAULT, "Warning: Cannot create convex hull for entity %@", v37, 0xCu);
    }
    MeshInterfaceForEntity = 0;
  }
  btShapeHull::~btShapeHull(v20);
  btAlignedFreeInternal(v29);
  if (v7) {
    btAlignedFreeInternal(v7);
  }
  return MeshInterfaceForEntity;
}

void sub_20B3375C0(_Unwind_Exception *exception_object)
{
  if (v1) {
    btAlignedFreeInternal(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _createConcaveTriMeshForEntity(__C3DMesh *a1)
{
  MeshInterfaceForEntity = _createMeshInterfaceForEntity(a1);
  if (MeshInterfaceForEntity)
  {
    CFTypeID v2 = MeshInterfaceForEntity;
    int v3 = (btBvhTriangleMeshShape *)btAlignedAllocInternal(112, 16);
    btBvhTriangleMeshShape::btBvhTriangleMeshShape(v3, v2, 1, 1);
    operator new();
  }
  return 0;
}

void sub_20B3376B4(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;
  MEMORY[0x210534FE0](v2, 0x10B1C403C62072ELL);
  _Unwind_Resume(a1);
}

double ___Z28_createShapeForArrayOfShapesP7NSArrayS0__block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = [a2 _handle];
  if (v5)
  {
    int v7 = (btCollisionShape *)v5;
    uint64_t v8 = [*(id *)(a1 + 32) objectAtIndex:a3];
    if (v8 && (uint64_t v9 = (void *)v8, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      [v9 SCNMatrix4Value];
      *(void *)v10.var0.var0 = v23;
      *(void *)v11.var0.var0 = __PAIR64__(v17, v14);
      *(void *)&v11.var0.var0[2] = v20;
      *(void *)v12.var0.var0 = __PAIR64__(v18, v15);
      v12.var0.var0[2] = v21;
      *(void *)v13.var0.var0 = __PAIR64__(v19, v16);
      v13.var0.var0[2] = v22;
      *(void *)&v10.var0.var0[2] = v24;
      v25.var0.var0[0] = v11;
      v25.var0.var0[1] = v12;
      v25.var0.var0[2] = v13;
      v25.var1 = v10;
    }
    else
    {
      v25.var0.var0[0] = (btVector3)xmmword_20B5CB820;
      v25.var0.var0[1] = (btVector3)xmmword_20B5CB7D0;
      v25.var0.var0[2] = (btVector3)xmmword_20B5CB520;
      v25.var1 = 0uLL;
    }
    *(void *)&double result = btCompoundShape::addChildShape((btCompoundShape *)*(void *)(a1 + 40), &v25, v7, 0).n128_u64[0];
  }
  return result;
}

btStridingMeshInterface *_createShapeForEntity(__C3DMesh *a1, NSDictionary *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v3 = [(NSDictionary *)a2 valueForKey:@"SCNPhysicsShapeTypeKey"];
  if ([v3 isEqualToString:@"boundingBox"])
  {
    v15.i32[2] = 0;
    v15.i64[0] = 0;
    v14.i32[2] = 0;
    v14.i64[0] = 0;
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == C3DMeshGetTypeID()) {
      C3DMeshGetBoundingBox((uint64_t)a1, &v15, &v14);
    }
    else {
      C3DGetBoundingBox(a1, 1, (uint64_t)&v15, (uint64_t)&v14);
    }
    int8x16_t v6 = (int8x16_t)vrev64q_s32(v15);
    int8x16_t v7 = vextq_s8(v14, (int8x16_t)v15, 4uLL);
    int8x16_t v8 = vextq_s8(v7, v7, 8uLL);
    v8.i32[0] = v15.i32[2];
    *(void *)&long long v9 = v14.i64[0];
    *((void *)&v9 + 1) = __PAIR64__(v14.u32[0], v15.u32[2]);
    int32x4_t v10 = v15;
    v10.i32[3] = v15.i32[0];
    int8x16_t v11 = vextq_s8((int8x16_t)v15, v6, 4uLL);
    int32x4_t v12 = vzip1q_s32((int32x4_t)v6, (int32x4_t)v14);
    v12.i32[1] = v14.i32[2];
    v25[0] = v10;
    v25[1] = v12;
    v25[2] = v8;
    __int32 v26 = v14.i32[0];
    v11.i32[2] = v14.i32[0];
    int8x16_t v27 = v11;
    __int32 v28 = v14.i32[2];
    long long v29 = v9;
    int8x8_t v30 = vext_s8(*(int8x8_t *)v14.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL), 4uLL);
    long long v22 = xmmword_20B5CC2B4;
    long long v23 = unk_20B5CC2C4;
    long long v24 = xmmword_20B5CC2D4;
    long long v18 = xmmword_20B5CC274;
    long long v19 = unk_20B5CC284;
    long long v20 = xmmword_20B5CC294;
    long long v21 = unk_20B5CC2A4;
    *(_OWORD *)unsigned int v16 = xmmword_20B5CC254;
    long long v17 = unk_20B5CC264;
    uint64_t v5 = (btConvexHullShape *)btAlignedAllocInternal(192, 16);
    btConvexHullShape::btConvexHullShape(v5, (const float *)v25, 8, 12, v16, 12);
    return v5;
  }
  if ([v3 isEqualToString:@"convexDecomposition"]) {
    return 0;
  }
  if ([v3 isEqualToString:@"concaveMesh"])
  {
    return (btStridingMeshInterface *)_createConcaveTriMeshForEntity(a1);
  }
  else
  {
    return _createConvexHullForEntity(a1);
  }
}

void sub_20B337A4C(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

uint64_t ___Z19_createShapeForNodeP9__C3DNodeP12NSDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Geometry = C3DNodeGetGeometry(a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  int v5 = *(_DWORD *)(v4 + 24);
  if (Geometry) {
    ++v5;
  }
  *(_DWORD *)(v4 + 24) = v5;
  return 2 * (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) > 1);
}

uint64_t ___Z19_createShapeForNodeP9__C3DNodeP12NSDictionary_block_invoke_2(uint64_t a1, float32x4_t *a2)
{
  uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry((uint64_t)a2);
  if (Geometry)
  {
    ShapeForuint64_t Geometry = _createShapeForGeometry(Geometry, *(NSDictionary **)(a1 + 96));
    if (ShapeForGeometry)
    {
      int8x16_t v6 = (btCollisionShape *)ShapeForGeometry;
      WorldMatrix = C3DNodeGetWorldMatrix(a2);
      C3DMatrix4x4Mult((uint64_t)WorldMatrix, (float32x4_t *)(a1 + 32), &v10);
      *(void *)v9.var0.var0[0].var0.var0 = __PAIR64__(v11, v10);
      *(void *)&v9.var0.var0[0].var0.var0[2] = v14;
      *(void *)v9.var0.var0[1].var0.var0 = __PAIR64__(v12, DWORD1(v10));
      *(void *)&v9.var0.var0[1].var0.var0[2] = v15;
      *(void *)v9.var0.var0[2].var0.var0 = __PAIR64__(v13, DWORD2(v10));
      *(void *)&v9.var0.var0[2].var0.var0[2] = v16;
      *(void *)v9.var1.var0.var0 = v17;
      *(void *)&v9.var1.var0.var0[2] = v18;
      btCompoundShape::addChildShape(*(btCompoundShape **)(a1 + 104), &v9, v6, 1);
    }
  }
  return 0;
}

void sub_20B337CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

btCollisionShape *C3DPhysicsShapeGetDefaultShapeForEntity(CFTypeRef *a1, SCNVector3 a2)
{
  float x = a2.x;
  if (a2.x == 1.0 && a2.y == 1.0 && a2.z == 1.0)
  {
    CFDictionaryRef Copy = (__CFString *)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], @"physicsShape");
    Attribute = (SCNPhysicsShape *)C3DEntityGetAttribute((uint64_t)a1, Copy);
    if (Attribute) {
      goto LABEL_14;
    }
  }
  else
  {
    float z = a2.z;
    float y = a2.y;
    CFDictionaryRef Copy = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"physicsShape[%f,%f,%f]", a2.x, a2.y, a2.z);
    CFDictionaryRef v9 = C3DEntityGetAttribute((uint64_t)a1, Copy);
    if (v9)
    {
      Attribute = (SCNPhysicsShape *)v9;
      goto LABEL_14;
    }
    *(float *)&double v10 = x;
    *(float *)&double v11 = y;
    *(float *)&double v12 = z;
    Attribute = (SCNPhysicsShape *)objc_msgSend(NSDictionary, "dictionaryWithObject:forKey:", objc_msgSend(MEMORY[0x263F08D40], "valueWithSCNVector3:", v10, v11, v12), @"SCNPhysicsShapeScaleKey");
  }
  Attribute = [[SCNPhysicsShape alloc] initWithCachedObject:a1 options:Attribute];
  C3DEntitySetAttribute(a1, Copy, (const __CFDictionary *)Attribute);

LABEL_14:
  CFRelease(Copy);

  return [(SCNPhysicsShape *)Attribute _handle];
}

btCollisionShape *C3DPhysicsShapeGetDefaultShapeForNode(float32x4_t *a1)
{
  v9.i32[2] = 0;
  v9.i64[0] = 0;
  WorldMatrifloat x = C3DNodeGetWorldMatrix(a1);
  C3DMatrix4x4GetScale(WorldMatrix, &v9);
  uint64_t Geometry = (CFTypeRef *)C3DNodeGetGeometry((uint64_t)a1);
  if (Geometry)
  {
    __int32 v5 = v9.i32[1];
    __int32 v4 = v9.i32[0];
    __int32 v6 = v9.i32[2];
    return C3DPhysicsShapeGetDefaultShapeForEntity(Geometry, *(SCNVector3 *)&v4);
  }
  if (C3DNodeComputeHierarchicalBoundingBox(a1, 1, v8))
  {
    __int32 v5 = v9.i32[1];
    __int32 v4 = v9.i32[0];
    __int32 v6 = v9.i32[2];
    uint64_t Geometry = (CFTypeRef *)a1;
    return C3DPhysicsShapeGetDefaultShapeForEntity(Geometry, *(SCNVector3 *)&v4);
  }
  return 0;
}

void btC3DMultiMeshInterface::btC3DMultiMeshInterface(btC3DMultiMeshInterface *this, float32x4_t *a2)
{
  *((_OWORD *)this + 1) = xmmword_20B5CC200;
  *(void *)this = &unk_26BF6B510;
  *((unsigned char *)this + 56) = 1;
  *((void *)this + 6) = 0;
  *(void *)((char *)this + 36) = 0;
  *((unsigned char *)this + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  *((void *)this + 10) = 0;
  *(void *)((char *)this + 6_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  WorldMatrifloat x = (simd_float4x4 *)C3DNodeGetWorldMatrix(a2);
  C3DMatrix4x4Invert(WorldMatrix, &v8);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  v5[2] = ___ZN23btC3DMultiMeshInterfaceC2EP9__C3DNode_block_invoke;
  v5[3] = &__block_descriptor_104_e20_q16__0____C3DNode__8l;
  int8x16_t v7 = this;
  simd_float4x4 v6 = v8;
  C3DNodeApplyHierarchy((uint64_t)a2, (uint64_t)v5);
}

void sub_20B338318(_Unwind_Exception *a1)
{
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray(v1 + 64);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray(v1 + 32);
  C3DSceneSourcePerformConsistencyCheck(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23btC3DMultiMeshInterfaceC2EP9__C3DNode_block_invoke(float32x4_t *a1, float32x4_t *a2)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1[6].i64[0];
  uint64_t Geometry = C3DNodeGetGeometry((uint64_t)a2);
  if (Geometry)
  {
    uint64_t Mesh = C3DGeometryGetMesh(Geometry);
    if (Mesh)
    {
      int8x16_t v7 = (const void *)Mesh;
      WorldMatrifloat x = C3DNodeGetWorldMatrix(a2);
      C3DMatrix4x4Mult((uint64_t)WorldMatrix, a1 + 2, v44);
      SourceWithSemanticAtuint64_t Index = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v7, 0, 0, 1);
      uint64_t v10 = (uint64_t)SourceWithSemanticAtIndex;
      if (SourceWithSemanticAtIndex)
      {
        uint64_t Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
        uint64_t Library = C3DSceneSourceGetLibrary(Accessor);
        uint64_t Count = C3DMeshSourceGetCount(v10);
        CFDataRef Data = (const __CFData *)C3DMeshSourceGetData(v10);
        BytePtr = CFDataGetBytePtr(Data);
        int v16 = *(_DWORD *)(v4 + 68);
        int v17 = v16 + Count;
        if ((int)Count >= 1 && *(_DWORD *)(v4 + 72) < v17)
        {
          if (v17) {
            uint64_t v18 = btAlignedAllocInternal(16 * v17, 16);
          }
          else {
            uint64_t v18 = 0;
          }
          if (*(int *)(v4 + 68) >= 1)
          {
            uint64_t v19 = 0;
            uint64_t v20 = 16 * *(unsigned int *)(v4 + 68);
            do
            {
              *(_OWORD *)(v18 + v19) = *(_OWORD *)(*(void *)(v4 + 80) + v19);
              v19 += 16;
            }
            while (v20 != v19);
          }
          long long v21 = *(void ***)(v4 + 80);
          if (v21 && *(unsigned char *)(v4 + 88)) {
            btAlignedFreeInternal(v21);
          }
          *(unsigned char *)(v4 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 1;
          *(void *)(v4 + 80) = v18;
          *(_DWORD *)(v4 + 72) = v17;
        }
        *(_DWORD *)(v4 + 6_Block_object_dispose(&STACK[0x2A0], 8) = v17;
        ComponentsValueunsigned int Type = C3DSourceAccessorGetComponentsValueType(Accessor);
        int v24 = ComponentsValueType;
        if (ComponentsValueType == 6 || (unsigned __int16)ComponentsValueType == 1)
        {
          if (Count >= 1)
          {
            int v25 = v16;
            uint64_t v26 = Count;
            do
            {
              if (v24 == 1)
              {
                v23.i64[0] = *(void *)BytePtr;
                v23.i32[2] = *((_DWORD *)BytePtr + 2);
              }
              else
              {
                float32x4_t v23 = *(float32x4_t *)BytePtr;
                *(float32x2_t *)v23.f32 = vcvt_f32_f64(*(float64x2_t *)BytePtr);
                float32_t v27 = *((double *)BytePtr + 2);
                v23.f32[2] = v27;
              }
              int32x4_t v28 = (int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v23), (int8x16_t)vcgezq_f32(v23)));
              v28.i32[3] = 0;
              v43[0] = (float32x4_t)v44[0];
              v43[1] = (float32x4_t)v44[1];
              v43[2] = (float32x4_t)v44[2];
              v43[3] = (float32x4_t)v44[3];
              *(double *)v23.i64 = C3DVector3MultMatrix4x4(v43, (float32x4_t)vbicq_s8((int8x16_t)v23, (int8x16_t)vcltzq_s32(v28)));
              v23.i32[3] = 0;
              *(float32x4_t *)(*(void *)(v4 + 80) + 16 * v25++) = v23;
              BytePtr += Library;
              --v26;
            }
            while (v26);
          }
        }
        else
        {
          long long v29 = scn_default_log();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)float32x4_t buf = 67109120;
            int v46 = v24;
            _os_log_impl(&dword_20B249000, v29, OS_LOG_TYPE_DEFAULT, "Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)", buf, 8u);
          }
        }
        CFArrayRef ElementsCount = C3DMeshGetElementsCount((uint64_t)v7);
        if ((uint64_t)ElementsCount >= 1)
        {
          for (CFArrayRef i = 0; i != ElementsCount; CFArrayRef i = (const __CFArray *)((char *)i + 1))
          {
            CFRetain(v7);
            int v32 = *(_DWORD *)(v4 + 36);
            if (v32 == *(_DWORD *)(v4 + 40))
            {
              int v33 = v32 ? 2 * v32 : 1;
              if (v32 < v33)
              {
                if (v33)
                {
                  uint64_t v34 = btAlignedAllocInternal(32 * v33, 16);
                  int v32 = *(_DWORD *)(v4 + 36);
                }
                else
                {
                  uint64_t v34 = 0;
                }
                if (v32 >= 1)
                {
                  uint64_t v35 = 0;
                  uint64_t v36 = 32 * v32;
                  do
                  {
                    uint64_t v37 = (_OWORD *)(v34 + v35);
                    float v38 = (_OWORD *)(*(void *)(v4 + 48) + v35);
                    long long v39 = v38[1];
                    *uint64_t v37 = *v38;
                    v37[1] = v39;
                    v35 += 32;
                  }
                  while (v36 != v35);
                }
                uint64_t v40 = *(void ***)(v4 + 48);
                if (v40 && *(unsigned char *)(v4 + 56)) {
                  btAlignedFreeInternal(v40);
                }
                *(unsigned char *)(v4 + 56) = 1;
                *(void *)(v4 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v34;
                *(_DWORD *)(v4 + 40) = v33;
                int v32 = *(_DWORD *)(v4 + 36);
              }
            }
            uint64_t v41 = *(void *)(v4 + 48) + 32 * v32;
            *(void *)uint64_t v41 = v7;
            *(void *)(v41 + _Block_object_dispose(&STACK[0x2A0], 8) = i;
            *(_DWORD *)(v41 + 16) = v16;
            *(_DWORD *)(v41 + 20) = Count;
            ++*(_DWORD *)(v4 + 36);
          }
        }
      }
    }
  }
  return 0;
}

void btC3DMultiMeshInterface::~btC3DMultiMeshInterface(btC3DMultiMeshInterface *this)
{
  btC3DMultiMeshInterface::~btC3DMultiMeshInterface(this);

  btAlignedFreeInternal(v1);
}

{
  int v2;
  uint64_t v3;
  uint64_t i;
  const void *v5;
  uint64_t vars8;

  *(void *)this = &unk_26BF6B510;
  uint64_t v2 = *((_DWORD *)this + 9);
  if (v2 >= 1)
  {
    id v3 = 0;
    for (CFArrayRef i = 0; i < v2; ++i)
    {
      __int32 v5 = *(const void **)(*((void *)this + 6) + v3);
      if (v5)
      {
        CFRelease(v5);
        uint64_t v2 = *((_DWORD *)this + 9);
      }
      v3 += 32;
    }
  }
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 64);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 32);

  C3DSceneSourcePerformConsistencyCheck(this);
}

void btC3DMultiMeshInterface::getLockedVertexIndexBase()
{
  CFTypeID v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    btC3DMultiMeshInterface::getLockedVertexIndexBase();
  }
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_3(&dword_20B249000, v0, v1, "Unreachable code: This is not yet implemented", v2, v3, v4, v5, v6);
}

const void *btC3DMultiMeshInterface::getLockedReadOnlyVertexIndexBase(uint64_t a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, const UInt8 **a6, _DWORD *a7, int *a8, int *a9, int a10)
{
  uint64_t v13 = *(void *)(a1 + 48) + 32 * a10;
  *a3 = *(_DWORD *)(v13 + 20);
  *a2 = *(void *)(a1 + 80) + 16 * *(int *)(v13 + 16);
  *a4 = 0;
  *a5 = 16;
  double result = C3DMeshGetElementAtIndex(*(void *)v13, *(void *)(v13 + 8), 1);
  if (result)
  {
    return (const void *)__fillMeshElementInfo((uint64_t)result, a6, a7, a8, a9);
  }
  return result;
}

uint64_t btC3DMultiMeshInterface::getNumSubParts(btC3DMultiMeshInterface *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t btStridingMeshInterface::hasPremadeAabb(btStridingMeshInterface *this)
{
  return 0;
}

uint64_t btStridingMeshInterface::calculateSerializeBufferSize(btStridingMeshInterface *this)
{
  return 32;
}

uint64_t btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 && *(unsigned char *)(a1 + 24)) {
    btAlignedFreeInternal(v2);
  }
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
  return a1;
}

void sub_20B3388D0(_Unwind_Exception *a1)
{
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray(v1 + 64);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray(v1 + 32);
  C3DSceneSourcePerformConsistencyCheck(v1);
  _Unwind_Resume(a1);
}

void btTriangleInfoMap::btTriangleInfoMap(btTriangleInfoMap *this)
{
  *((unsigned char *)this + 32) = 1;
  *((void *)this + 3) = 0;
  *(void *)((char *)this + 12) = 0;
  *((unsigned char *)this + 64) = 1;
  *((void *)this + 7) = 0;
  *(void *)((char *)this + 44) = 0;
  *((unsigned char *)this + 96) = 1;
  *((void *)this + 11) = 0;
  *(void *)((char *)this + 76) = 0;
  *((unsigned char *)this + 12_Block_object_dispose(&STACK[0x2A0], 8) = 1;
  *((void *)this + 15) = 0;
  *(void *)((char *)this + 10_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(void *)this = &unk_26BF6AA08;
  *(_OWORD *)((char *)this + 136) = xmmword_20B5CC210;
  *((void *)this + 19) = 0x322BCC7640C90FDBLL;
}

void btTriangleInfoMap::~btTriangleInfoMap(btTriangleInfoMap *this)
{
  btTriangleInfoMap::~btTriangleInfoMap(this);

  JUMPOUT(0x210534FE0);
}

{
  char *v2;

  uint64_t v2 = (char *)this + 8;
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 104);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 72);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)this + 40);
  btAlignedObjectArray<btC3DIndexedMesh>::~btAlignedObjectArray((uint64_t)v2);
}

uint64_t btTriangleInfoMap::calculateSerializeBufferSize(btTriangleInfoMap *this)
{
  return 72;
}

const char *btTriangleInfoMap::serialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 4_Block_object_dispose(&STACK[0x2A0], 8) = *(_DWORD *)(a1 + 156);
  int v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 56) = v6;
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 24));
    *(void *)a2 = v7;
    if (v7)
    {
      uint64_t v8 = *(unsigned int *)(a2 + 56);
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v8);
      uint64_t v10 = *(void *)(a1 + 24);
      if ((int)v8 >= 1)
      {
        double v11 = *(_DWORD **)(v9 + 8);
        double v12 = *(int **)(a1 + 24);
        do
        {
          int v13 = *v12++;
          *v11++ = v13;
          --v8;
        }
        while (v8);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v9, "int", 1497453121, v10);
    }
  }
  else
  {
    *(void *)a2 = 0;
  }
  int v14 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 52) = v14;
  if (v14)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 56));
    *(void *)(a2 + _Block_object_dispose(&STACK[0x2A0], 8) = v15;
    if (v15)
    {
      uint64_t v16 = *(unsigned int *)(a2 + 52);
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v16);
      uint64_t v18 = *(void *)(a1 + 56);
      if ((int)v16 >= 1)
      {
        uint64_t v19 = *(_DWORD **)(v17 + 8);
        uint64_t v20 = *(int **)(a1 + 56);
        do
        {
          int v21 = *v20++;
          *v19++ = v21;
          --v16;
        }
        while (v16);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v17, "int", 1497453121, v18);
    }
  }
  else
  {
    *(void *)(a2 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
  int v22 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 60) = v22;
  if (v22)
  {
    uint64_t v23 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 88));
    *(void *)(a2 + 16) = v23;
    if (v23)
    {
      uint64_t v24 = *(unsigned int *)(a2 + 60);
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 16, v24);
      uint64_t v26 = *(void *)(a1 + 88);
      if ((int)v24 >= 1)
      {
        uint64_t v27 = *(void *)(v25 + 8);
        int32x4_t v28 = *(int **)(a1 + 88);
        do
        {
          *(void *)(v27 + 4) = *(void *)(v28 + 1);
          *(_DWORD *)(v27 + 12) = v28[3];
          int v29 = *v28;
          v28 += 4;
          *(_DWORD *)uint64_t v27 = v29;
          v27 += 16;
          --v24;
        }
        while (v24);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v25, "btTriangleInfoData", 1497453121, v26);
    }
  }
  else
  {
    *(void *)(a2 + 16) = 0;
  }
  int v30 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a2 + 64) = v30;
  if (v30)
  {
    uint64_t v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 120));
    *(void *)(a2 + 24) = v31;
    if (v31)
    {
      uint64_t v32 = *(unsigned int *)(a2 + 60);
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v32);
      uint64_t v34 = *(void *)(a1 + 120);
      if ((int)v32 >= 1)
      {
        uint64_t v35 = *(_DWORD **)(v33 + 8);
        uint64_t v36 = *(int **)(a1 + 120);
        do
        {
          int v37 = *v36++;
          *v35++ = v37;
          --v32;
        }
        while (v32);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v33, "int", 1497453121, v34);
    }
  }
  else
  {
    *(void *)(a2 + 24) = 0;
  }
  return "btTriangleInfoMapData";
}

void btBox2dShape::btBox2dShape(btBox2dShape *this, float32x4_t *a2)
{
  btPolyhedralConvexShape::btPolyhedralConvexShape(this);
  *(void *)uint64_t v4 = &unk_26BF69520;
  *(void *)(v4 + 80) = 0;
  *(void *)(v4 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(float32x2_t *)(v4 + 96) = vneg_f32(*(float32x2_t *)a2->f32);
  *(void *)(v4 + 104) = 0;
  float v5 = -a2->f32[1];
  *(_DWORD *)(v4 + 112) = a2->i32[0];
  *(float *)(v4 + 116) = v5;
  *(void *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 12_Block_object_dispose(&STACK[0x2A0], 8) = a2->i32[0];
  *(_DWORD *)(v4 + 132) = a2->i32[1];
  *(void *)(v4 + 136) = 0;
  *(float *)(v4 + 144) = -a2->f32[0];
  *(_DWORD *)(v4 + 14_Block_object_dispose(&STACK[0x2A0], 8) = a2->i32[1];
  *(_OWORD *)(v4 + 152) = xmmword_20B5CC220;
  *(void *)(v4 + 16_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(_DWORD *)(v4 + 176) = 1065353216;
  *(void *)(v4 + 18_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(void *)(v4 + 180) = 0;
  *(_OWORD *)(v4 + 196) = xmmword_20B5CC230;
  *(void *)(v4 + 212) = 0;
  *(_DWORD *)(v4 + 220) = 0;
  if (a2->f32[0] <= a2->f32[1]) {
    float v6 = a2->f32[0];
  }
  else {
    float v6 = a2->f32[1];
  }
  float v7 = off_26BF69580((btConvexInternalShape *)v4);
  v8.n128_f32[0] = v6 * 0.1;
  if ((float)(v6 * 0.1) < v7) {
    (*(void (**)(btBox2dShape *, float))(*(void *)this + 88))(this, v8.n128_f32[0]);
  }
  *((_DWORD *)this + 2) = 17;
  v13.i64[0] = (*(double (**)(btBox2dShape *, __n128))(*(void *)this + 96))(this, v8);
  __int32 v12 = COERCE_UNSIGNED_INT64((*(double (**)(btBox2dShape *))(*(void *)this + 96))(this));
  float v9 = (*(float (**)(btBox2dShape *))(*(void *)this + 96))(this);
  float32x4_t v10 = v13;
  v10.i32[1] = v12;
  v10.f32[2] = v9;
  float32x4_t v11 = vsubq_f32(vmulq_f32(*a2, *((float32x4_t *)this + 2)), v10);
  v11.i32[3] = 0;
  *((float32x4_t *)this + 3) = v11;
}

void sub_20B338FA4(_Unwind_Exception *a1)
{
  btPolyhedralConvexShape::~btPolyhedralConvexShape(v1);
  _Unwind_Resume(a1);
}

uint64_t scn_cone_x4_fill(uint64_t result, int32x4_t *a2, unsigned int a3)
{
  if (a3 + 3 >= 4)
  {
    unint64_t v3 = 0;
    uint64_t v4 = a2 + 6;
    uint64_t v5 = result + 64;
    int32x4_t v6 = vdupq_n_s32(0x7F800000u);
    do
    {
      int32x4_t v7 = 0uLL;
      int32x2_t v8 = 0;
      __int32 v9 = 0;
      int32x4_t v10 = v6;
      int32x4_t v11 = 0uLL;
      if (v3 < a3)
      {
        int32x4_t v10 = v4[-6];
        int32x4_t v11 = v4[-5];
        v8.i32[0] = v4[-4].i32[0];
        __int32 v9 = v4[-4].i32[1];
      }
      uint64_t v12 = 0;
      int32x4_t v13 = v6;
      int32x2_t v14 = 0;
      if (v3 + 1 < a3)
      {
        int32x4_t v13 = v4[-3];
        int32x4_t v7 = v4[-2];
        int32x2_t v14 = *(int32x2_t *)v4[-1].i8;
      }
      int32x4_t v15 = 0uLL;
      int32x4_t v16 = 0uLL;
      int32x4_t v17 = v6;
      if (v3 + 2 < a3)
      {
        int32x4_t v17 = *v4;
        int32x4_t v16 = v4[1];
        uint64_t v12 = v4[2].i64[0];
      }
      uint64_t v18 = 0;
      int32x4_t v19 = v6;
      if (v3 + 3 < a3)
      {
        int32x4_t v19 = v4[3];
        int32x4_t v15 = v4[4];
        uint64_t v18 = v4[5].i64[0];
      }
      float32x2x2_t v20 = (float32x2x2_t)vzip1q_s32(v10, v17);
      v31.val[0] = (float32x2_t)vzip2q_s32(v10, v17).u64[0];
      int32x4_t v21 = vzip1q_s32(v13, v19);
      v31.val[1] = (float32x2_t)vzip2q_s32(v13, v19).u64[0];
      *(void *)&long long v22 = __PAIR64__(v14.u32[1], v9);
      *((void *)&v22 + 1) = __PAIR64__(HIDWORD(v18), HIDWORD(v12));
      float32x2x2_t v23 = (float32x2x2_t)vzip1q_s32(v11, v16);
      *(int32x2_t *)&long long v24 = vzip1_s32(v8, v14);
      *((void *)&v24 + 1) = __PAIR64__(v18, v12);
      uint64_t v25 = (float *)(v5 - 64);
      vst2_f32(v25, v20);
      uint64_t v26 = (float *)(v5 - 32);
      vst2_f32(v26, v31);
      v30.val[0] = (float32x2_t)vzip2q_s32(v11, v16).u64[0];
      int32x4_t v27 = vzip1q_s32(v7, v15);
      v30.val[1] = (float32x2_t)vzip2q_s32(v7, v15).u64[0];
      int32x4_t v28 = (float *)(v5 - 16);
      vst2_f32(v28, v23);
      *(int32x4_t *)(v5 - 4_Block_object_dispose(&STACK[0x2A0], 8) = vzip2q_s32((int32x4_t)v20, v21);
      *(int32x4_t *)uint64_t v5 = vzip2q_s32((int32x4_t)v23, v27);
      int v29 = (float *)(v5 + 16);
      vst2_f32(v29, v30);
      *(_OWORD *)(v5 + 32) = v24;
      *(_OWORD *)(v5 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v22;
      v3 += 4;
      v4 += 12;
      v5 += 128;
    }
    while (((a3 + 3) & 0xFFFFFFFC) != v3);
  }
  return result;
}

float32x4_t *scn_cone_x4_filter(float32x4_t *result, int a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = *a3;
    float32x4_t v7 = a3[1];
    float32x4_t v8 = a3[2];
    float32x4_t v9 = a3[3];
    float32x4_t v10 = *a4;
    float32x4_t v11 = a4[1];
    float32x4_t v12 = a4[2];
    float32x4_t v13 = a4[3];
    float32x4_t v14 = vnegq_f32(v8);
    float32x4_t v15 = vnegq_f32(*a3);
    float32x4_t v16 = vnegq_f32(v7);
    float32x4_t v17 = vnegq_f32(v12);
    float32x4_t v18 = vnegq_f32(*a4);
    float32x4_t v19 = vnegq_f32(v11);
    float32x2x2_t v20 = result + 4;
    do
    {
      float32x4_t v21 = v20[-4];
      float32x4_t v22 = v20[-3];
      float32x4_t v23 = v20[-2];
      float32x4_t v24 = v20[2];
      float32x4_t v25 = vnegq_f32(v24);
      float32x4_t v26 = vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, v22), v21, v6), v23, v8));
      float32x4_t v27 = vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, v22), v21, v10), v23, v12));
      if ((vminvq_u32((uint32x4_t)vornq_s8(vmvnq_s8((int8x16_t)vcgeq_f32(v26, v25)), (int8x16_t)vcgeq_f32(v27, v25))) & 0x80000000) != 0)
      {
        if ((v5 & 1) == 0) {
          *(unsigned char *)(a5 + (v5 >> 1)) = 0;
        }
      }
      else
      {
        float32x4_t v28 = v20[3];
        float32x4_t v29 = v20[1];
        float32x4_t v30 = v20[-1];
        float32x4_t v31 = vmlaq_f32(vmulq_f32(*v20, v14), v29, v7);
        float32x4_t v32 = vmlaq_f32(vmulq_f32(v29, v15), v30, v8);
        float32x4_t v33 = vmlaq_f32(vmulq_f32(v30, v16), *v20, v6);
        float32x4_t v34 = vmlaq_f32(vmulq_f32(*v20, vnegq_f32(v33)), v29, v32);
        float32x4_t v35 = vmlaq_f32(vmulq_f32(v29, vnegq_f32(v31)), v30, v33);
        float32x4_t v36 = vmlaq_f32(vmulq_f32(v30, vnegq_f32(v32)), *v20, v31);
        float32x4_t v37 = vmlaq_f32(vmlaq_f32(vmulq_f32(v35, v35), v34, v34), v36, v36);
        float32x4_t v38 = vrsqrteq_f32(v37);
        float32x4_t v39 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
        float32x4_t v40 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v39, vrsqrtsq_f32(v37, vmulq_f32(v39, v39))), (int8x16_t)vceqzq_f32(v37));
        float32x4_t v41 = vmlaq_f32(v21, v24, v30);
        float32x4_t v42 = vmlaq_f32(v22, v24, *v20);
        float32x4_t v43 = vmlaq_f32(v23, v24, v29);
        float32x4_t v44 = vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, vmlaq_f32(v42, v28, vmulq_f32(v40, vnegq_f32(v35)))), vmlaq_f32(v41, v28, vmulq_f32(v40, vnegq_f32(v34))), v6), vmlaq_f32(v43, v28, vmulq_f32(v40, vnegq_f32(v36))), v8));
        float32x4_t v45 = vmlaq_f32(vmulq_f32(*v20, v17), v29, v11);
        float32x4_t v46 = vmlaq_f32(vmulq_f32(v29, v18), v30, v12);
        float32x4_t v47 = vmlaq_f32(vmulq_f32(v30, v19), *v20, v10);
        float32x4_t v48 = vmlaq_f32(vmulq_f32(*v20, vnegq_f32(v47)), v29, v46);
        float32x4_t v49 = vmlaq_f32(vmulq_f32(v29, vnegq_f32(v45)), v30, v47);
        float32x4_t v50 = vmlaq_f32(vmulq_f32(v30, vnegq_f32(v46)), *v20, v45);
        float32x4_t v51 = vmlaq_f32(vmlaq_f32(vmulq_f32(v49, v49), v48, v48), v50, v50);
        float32x4_t v52 = vrsqrteq_f32(v51);
        float32x4_t v53 = vmulq_f32(v52, vrsqrtsq_f32(v51, vmulq_f32(v52, v52)));
        float32x4_t v54 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v53, vrsqrtsq_f32(v51, vmulq_f32(v53, v53))), (int8x16_t)vceqzq_f32(v51));
        float32x4_t v55 = vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, vmlaq_f32(v42, v28, vmulq_f32(v54, vnegq_f32(v49)))), vmlaq_f32(v41, v28, vmulq_f32(v54, vnegq_f32(v48))), v10), vmlaq_f32(v43, v28, vmulq_f32(v54, vnegq_f32(v50))), v12));
        int8x16_t v56 = vandq_s8(vandq_s8(vorrq_s8((int8x16_t)vcltzq_f32(vmulq_f32(v26, v44)), (int8x16_t)vcgezq_f32(vminnmq_f32(v26, v44))), vorrq_s8((int8x16_t)vcltzq_f32(vmulq_f32(v27, v55)), (int8x16_t)vcgezq_f32(vminnmq_f32(v27, v55)))), (int8x16_t)xmmword_20B5CBD00);
        *(int8x8_t *)v56.i8 = vorr_s8(*(int8x8_t *)v56.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL));
        unsigned __int8 v57 = vadd_s32(*(int32x2_t *)v56.i8, vdup_lane_s32(*(int32x2_t *)v56.i8, 1)).u8[0];
        uint64_t v58 = v5 >> 1;
        if (v5) {
          unsigned __int8 v57 = *(unsigned char *)(a5 + v58) | (16 * v57);
        }
        *(unsigned char *)(a5 + v5_Block_object_dispose(&STACK[0x2A0], 8) = v57;
      }
      ++v5;
      v20 += 8;
    }
    while (a2 != v5);
  }
  return result;
}

uint64_t scn_sphere_x4_fill(uint64_t result, int32x4_t *a2, unsigned int a3)
{
  if (a3 + 3 >= 4)
  {
    unint64_t v3 = 0;
    uint64_t v4 = (float *)(result + 32);
    uint64_t v5 = a2 + 2;
    do
    {
      int32x4_t v6 = (int32x4_t)xmmword_20B5CC2F0;
      if (v3 < a3) {
        int32x4_t v6 = v5[-2];
      }
      int32x4_t v7 = (int32x4_t)xmmword_20B5CC2F0;
      if (v3 + 1 < a3) {
        int32x4_t v7 = v5[-1];
      }
      int32x4_t v8 = (int32x4_t)xmmword_20B5CC2F0;
      if (v3 + 2 < a3) {
        int32x4_t v8 = *v5;
      }
      int32x4_t v9 = (int32x4_t)xmmword_20B5CC2F0;
      if (v3 + 3 < a3) {
        int32x4_t v9 = v5[1];
      }
      float32x2x2_t v10 = (float32x2x2_t)vzip1q_s32(v6, v8);
      v16.val[0] = (float32x2_t)vzip2q_s32(v6, v8).u64[0];
      int32x4_t v11 = vzip1q_s32(v7, v9);
      *(void *)&long long v12 = vuzp2q_s32(vuzp2q_s32(v6, v7), v6).u64[0];
      *((void *)&v12 + 1) = __PAIR64__(v9.u32[3], v8.u32[3]);
      v16.val[1] = (float32x2_t)vzip2q_s32(v7, v9).u64[0];
      float32x4_t v13 = v4 - 8;
      vst2_f32(v13, v10);
      *((int32x4_t *)v4 - 1) = vzip2q_s32((int32x4_t)v10, v11);
      float32x4_t v14 = v4 + 16;
      vst2_f32(v4, v16);
      float32x4_t v15 = v4 + 4;
      *float32x4_t v15 = v12;
      v3 += 4;
      v5 += 4;
      uint64_t v4 = v14;
    }
    while (((a3 + 3) & 0xFFFFFFFC) != v3);
  }
  return result;
}

float32x4_t *scn_sphere_x4_filter(float32x4_t *result, int a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = *a3;
    float32x4_t v7 = a3[1];
    float32x4_t v8 = a3[2];
    float32x4_t v9 = a3[3];
    float32x4_t v10 = *a4;
    float32x4_t v11 = a4[1];
    float32x4_t v12 = a4[2];
    float32x4_t v13 = a4[3];
    float32x4_t v14 = result + 2;
    do
    {
      float32x4_t v15 = vnegq_f32(v14[1]);
      int8x16_t v16 = vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, v14[-1]), v14[-2], v6), *v14, v8)), v15), (int8x16_t)vcgeq_f32(vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, v14[-1]), v14[-2], v10), *v14, v12)), v15)), (int8x16_t)xmmword_20B5CBD00);
      *(int8x8_t *)v16.i8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
      unsigned __int8 v17 = vadd_s32(*(int32x2_t *)v16.i8, vdup_lane_s32(*(int32x2_t *)v16.i8, 1)).u8[0];
      uint64_t v18 = v5 >> 1;
      if (v5) {
        unsigned __int8 v17 = *(unsigned char *)(a5 + v18) | (16 * v17);
      }
      *(unsigned char *)(a5 + v1_Block_object_dispose(&STACK[0x2A0], 8) = v17;
      ++v5;
      v14 += 4;
    }
    while (a2 != v5);
  }
  return result;
}

uint64_t C3DComparisonFuncToMTLCompareFunction(unsigned int a1)
{
  if (a1 >= 8)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DComparisonFuncToMTLCompareFunction_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_ComparisonFunc[a1];
}

uint64_t C3DStencilOpToMTLStencilOperation(unsigned int a1)
{
  if (a1 >= 8)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DStencilOpToMTLStencilOperation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_StencilOp[a1];
}

uint64_t SCNMTLPixelFormatSRGBVariant(uint64_t result)
{
  if (result > 499)
  {
    if (result > 549)
    {
      switch(result)
      {
        case 550:
          return 551;
        case 552:
          return 553;
        case 554:
          return 555;
      }
    }
    else
    {
      switch(result)
      {
        case 500:
          double result = 520;
          break;
        case 501:
          double result = 521;
          break;
        case 502:
          double result = 522;
          break;
        case 503:
          double result = 523;
          break;
        case 504:
          double result = 524;
          break;
        case 505:
          double result = 525;
          break;
        case 506:
          double result = 526;
          break;
        case 507:
          double result = 527;
          break;
        case 508:
          double result = 528;
          break;
        case 509:
          double result = 529;
          break;
        case 510:
          double result = 530;
          break;
        default:
          return result;
      }
    }
  }
  else if (result <= 177)
  {
    if (result > 79)
    {
      switch(result)
      {
        case 160:
          double result = 161;
          break;
        case 161:
        case 163:
        case 165:
          return result;
        case 162:
          double result = 163;
          break;
        case 164:
          double result = 165;
          break;
        case 166:
          double result = 167;
          break;
        default:
          if (result == 80) {
            double result = 81;
          }
          break;
      }
    }
    else
    {
      switch(result)
      {
        case 10:
          return 11;
        case 30:
          return 31;
        case 70:
          return 71;
      }
    }
  }
  else
  {
    switch(result)
    {
      case 178:
        double result = 179;
        break;
      case 180:
        double result = 181;
        break;
      case 182:
        double result = 183;
        break;
      case 204:
        double result = 186;
        break;
      case 205:
        double result = 187;
        break;
      case 206:
        double result = 188;
        break;
      case 207:
        double result = 189;
        break;
      case 208:
        double result = 190;
        break;
      case 210:
        double result = 192;
        break;
      case 211:
        double result = 193;
        break;
      case 212:
        double result = 194;
        break;
      case 213:
        double result = 195;
        break;
      case 214:
        double result = 196;
        break;
      case 215:
        double result = 197;
        break;
      case 216:
        double result = 198;
        break;
      case 217:
        double result = 199;
        break;
      case 218:
        double result = 200;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t SCNMTLPixelFormatNonSRGBVariant(uint64_t result)
{
  if (result <= 160)
  {
    if (result > 70)
    {
      if (result == 71)
      {
        return 70;
      }
      else if (result == 81)
      {
        return 80;
      }
    }
    else if (result == 11)
    {
      return 10;
    }
    else if (result == 31)
    {
      return 30;
    }
  }
  else if (result > 550)
  {
    switch(result)
    {
      case 551:
        return 550;
      case 553:
        return 552;
      case 555:
        return 554;
    }
  }
  else
  {
    switch(result)
    {
      case 161:
        double result = 160;
        break;
      case 163:
        double result = 162;
        break;
      case 165:
        double result = 164;
        break;
      case 167:
        double result = 166;
        break;
      case 179:
        double result = 178;
        break;
      case 181:
        double result = 180;
        break;
      case 183:
        double result = 182;
        break;
      case 186:
        double result = 204;
        break;
      case 187:
        double result = 205;
        break;
      case 188:
        double result = 206;
        break;
      case 189:
        double result = 207;
        break;
      case 190:
        double result = 208;
        break;
      case 192:
        double result = 210;
        break;
      case 193:
        double result = 211;
        break;
      case 194:
        double result = 212;
        break;
      case 195:
        double result = 213;
        break;
      case 196:
        double result = 214;
        break;
      case 197:
        double result = 215;
        break;
      case 198:
        double result = 216;
        break;
      case 199:
        double result = 217;
        break;
      case 200:
        double result = 218;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t C3DRenderBufferFormatToMTLPixelFormat(int a1, uint64_t a2, char a3)
{
  int v3 = a1 - 1;
  uint64_t result = 80;
  switch(v3)
  {
    case 0:
      uint64_t result = C3DMetalFramebufferPixelFormat(a3);
      break;
    case 1:
    case 26:
      return result;
    case 2:
      uint64_t result = 10;
      break;
    case 3:
      uint64_t result = 12;
      break;
    case 4:
      uint64_t result = 13;
      break;
    case 5:
      uint64_t result = 14;
      break;
    case 6:
      uint64_t result = 20;
      break;
    case 7:
      uint64_t result = 22;
      break;
    case 8:
      uint64_t result = 23;
      break;
    case 9:
      uint64_t result = 24;
      break;
    case 10:
      uint64_t result = 25;
      break;
    case 11:
      uint64_t result = 53;
      break;
    case 12:
      uint64_t result = 54;
      break;
    case 13:
      uint64_t result = 55;
      break;
    case 14:
      uint64_t result = 30;
      break;
    case 15:
      uint64_t result = 32;
      break;
    case 16:
      uint64_t result = 33;
      break;
    case 17:
      uint64_t result = 34;
      break;
    case 18:
      uint64_t result = 60;
      break;
    case 19:
      uint64_t result = 62;
      break;
    case 20:
      uint64_t result = 63;
      break;
    case 21:
      uint64_t result = 64;
      break;
    case 22:
      uint64_t result = 65;
      break;
    case 23:
      uint64_t result = 103;
      break;
    case 24:
      uint64_t result = 104;
      break;
    case 25:
      uint64_t result = 105;
      break;
    case 27:
      uint64_t result = 70;
      break;
    case 28:
      uint64_t result = 72;
      break;
    case 29:
      uint64_t result = 73;
      break;
    case 30:
      uint64_t result = 74;
      break;
    case 31:
      uint64_t result = 110;
      break;
    case 32:
      uint64_t result = 112;
      break;
    case 33:
      uint64_t result = 113;
      break;
    case 34:
      uint64_t result = 114;
      break;
    case 35:
      uint64_t result = 115;
      break;
    case 36:
      uint64_t result = 123;
      break;
    case 37:
      uint64_t result = 124;
      break;
    case 38:
      uint64_t result = 125;
      break;
    case 39:
      uint64_t result = 250;
      break;
    case 40:
    case 41:
      uint64_t result = 252;
      break;
    case 42:
    case 43:
      uint64_t result = 253;
      break;
    case 44:
      uint64_t result = 260;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t SCNMTLVertexFormatToC3DBaseType(unint64_t a1)
{
  if (a1 >= 0x36)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLVertexFormatToC3DBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return __SCNMTLVertexFormatToC3DBaseTypeArray[a1];
}

uint64_t SCNMTLDataTypeFromC3DBaseType(int a1)
{
  if (a1 >= 46)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      SCNMTLDataTypeFromC3DBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return mtl_DataType[a1];
}

uint64_t SCNMTLVertexFormatGetSize(uint64_t a1)
{
  return mtl_vertexFormatSize[a1];
}

uint64_t SCNMTLIndexTypeGetSize(uint64_t a1)
{
  return *((unsigned int *)&mtl_indexTypeSize + a1);
}

uint64_t SCNMTLPixelFormatIsUnsignedInt(uint64_t a1)
{
  uint64_t result = 1;
  if ((unint64_t)(a1 - 13) > 0x3C || ((1 << (a1 - 13)) & 0x1004010000100401) == 0)
  {
    unint64_t v3 = a1 - 91;
    if (v3 > 0x20 || ((1 << v3) & 0x100401001) == 0) {
      return 0;
    }
  }
  return result;
}

__CFString *SCNMTLPixelFormatToString(uint64_t a1)
{
  if (a1 > 102)
  {
    if (a1 > 251)
    {
      switch(a1)
      {
        case 552:
          uint64_t result = @"BGRA10_XR";
          break;
        case 553:
          uint64_t result = @"BGRA10_XR_sRGB";
          break;
        case 554:
          uint64_t result = @"BGR10_XR";
          break;
        case 555:
          uint64_t result = @"BGR10_XR_sRGB";
          break;
        default:
          if (a1 == 252)
          {
            uint64_t result = @"Depth32Float";
          }
          else if (a1 == 253)
          {
            uint64_t result = @"Stencil8";
          }
          else
          {
LABEL_52:
            uint64_t v4 = (void *)[NSString stringWithCString:MTLPixelFormatGetName() encoding:1];
            uint64_t result = (__CFString *)[v4 stringByReplacingOccurrencesOfString:@"MTLPixelFormat" withString:&stru_26BF72F58];
          }
          break;
      }
    }
    else
    {
      switch(a1)
      {
        case 'g':
          uint64_t result = @"RG32Uint";
          break;
        case 'h':
          uint64_t result = @"RG32Sint";
          break;
        case 'i':
          uint64_t result = @"RG32Float";
          break;
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'o':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
          goto LABEL_52;
        case 'n':
          uint64_t result = @"RGBA16Unorm";
          break;
        case 'p':
          uint64_t result = @"RGBA16Snorm";
          break;
        case 'q':
          uint64_t result = @"RGBA16Uint";
          break;
        case 'r':
          uint64_t result = @"RGBA16Sint";
          break;
        case 's':
          uint64_t result = @"RGBA16Float";
          break;
        case '{':
          uint64_t result = @"RGBA32Uint";
          break;
        case '|':
          uint64_t result = @"RGBA32Sint";
          break;
        case '}':
          uint64_t result = @"RGBA32Float";
          break;
        default:
          if (a1 != 250) {
            goto LABEL_52;
          }
          uint64_t result = @"Depth16Unorm";
          break;
      }
    }
  }
  else
  {
    switch(a1)
    {
      case '5':
        uint64_t result = @"R32Uint";
        break;
      case '6':
        uint64_t result = @"R32Sint";
        break;
      case '7':
        uint64_t result = @"R32Float";
        break;
      case '8':
      case '9':
      case ':':
      case ';':
      case '=':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case '\\':
      case ']':
        goto LABEL_52;
      case '<':
        uint64_t result = @"RG16Unorm";
        break;
      case '>':
        uint64_t result = @"RG16Snorm";
        break;
      case '?':
        uint64_t result = @"RG16Uint";
        break;
      case '@':
        uint64_t result = @"RG16Sint";
        break;
      case 'A':
        uint64_t result = @"RG16Float";
        break;
      case 'F':
        uint64_t result = @"RGBA8Unorm";
        break;
      case 'G':
        uint64_t result = @"RGBA8Unorm_sRGB";
        break;
      case 'H':
        uint64_t result = @"RGBA8Snorm";
        break;
      case 'I':
        uint64_t result = @"RGBA8Uint";
        break;
      case 'J':
        uint64_t result = @"RGBA8Sint";
        break;
      case 'P':
        uint64_t result = @"BGRA8Unorm";
        break;
      case 'Q':
        uint64_t result = @"BGRA8Unorm_sRGB";
        break;
      case 'Z':
        uint64_t result = @"RGB10A2Unorm";
        break;
      case '[':
        uint64_t result = @"RGB10A2Uint";
        break;
      case '^':
        uint64_t result = @"BGR10A2Unorm";
        break;
      default:
        uint64_t result = @"Invalid";
        switch(a1)
        {
          case 0:
            return result;
          case 1:
            uint64_t result = @"A8Unorm";
            break;
          case 10:
            uint64_t result = @"R8Unorm";
            break;
          case 11:
            uint64_t result = @"R8Unorm_sRGB";
            break;
          case 12:
            uint64_t result = @"R8Snorm";
            break;
          case 13:
            uint64_t result = @"R8Uint";
            break;
          case 14:
            uint64_t result = @"R8Sint";
            break;
          case 20:
            uint64_t result = @"R16Unorm";
            break;
          case 22:
            uint64_t result = @"R16Snorm";
            break;
          case 23:
            uint64_t result = @"R16Uint";
            break;
          case 24:
            uint64_t result = @"R16Sint";
            break;
          case 25:
            uint64_t result = @"R16Float";
            break;
          case 30:
            uint64_t result = @"RG8Unorm";
            break;
          case 31:
            uint64_t result = @"RG8Unorm_sRGB";
            break;
          case 32:
            uint64_t result = @"RG8Snorm";
            break;
          case 33:
            uint64_t result = @"RG8Uint";
            break;
          case 34:
            uint64_t result = @"RG8Sint";
            break;
          default:
            goto LABEL_52;
        }
        break;
    }
  }
  return result;
}

__CFString *SCNMTLStorageModeToString(unint64_t a1)
{
  if (a1 > 3) {
    return @"Unkown";
  }
  else {
    return off_264006398[a1];
  }
}

__CFString *SCNMTLCPUCacheModeToString(uint64_t a1)
{
  if (a1) {
    return @"MTLCPUCacheModeWriteCombined";
  }
  else {
    return @"MTLCPUCacheModeDefaultCache";
  }
}

uint64_t SCNMTLTextureTypeGetArrayElementType(uint64_t a1)
{
  uint64_t v1 = 5;
  uint64_t v2 = 2;
  if (a1 != 3) {
    uint64_t v2 = a1;
  }
  if (a1 != 6) {
    uint64_t v1 = v2;
  }
  if (a1 == 1) {
    return 0;
  }
  else {
    return v1;
  }
}

uint64_t SCNMTLTextureTypeNonMultisampledEquivalent(uint64_t a1)
{
  uint64_t v1 = 2;
  if (a1 != 4) {
    uint64_t v1 = a1;
  }
  if (a1 == 8) {
    return 3;
  }
  else {
    return v1;
  }
}

__CFString *SCNMTLTextureTypeToString(unint64_t a1)
{
  if (a1 > 9) {
    return @"Unkown";
  }
  else {
    return off_2640063B8[a1];
  }
}

uint64_t SCNMTLTextureToC3DTextureType(void *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  unint64_t v2 = [a1 textureType];
  if (v2 < 8 && ((0xA5u >> v2) & 1) != 0) {
    return dword_20B5CCA6C[v2];
  }
  unint64_t v3 = scn_default_log();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v4)
  {
    v6[0] = 67109120;
    v6[1] = [a1 textureType];
    _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: unsupported texture type %d", (uint8_t *)v6, 8u);
    return 0;
  }
  return result;
}

uint64_t C3DValueWriteToMTLData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  int Type = C3DValueGetType(a1);
  Bytes = (__int16 *)C3DValueGetBytes(a1);
  float32x4_t v11 = Bytes;
  switch(a2)
  {
    case 3:
      uint64_t result = 0;
      switch((__int16)Type)
      {
        case 1:
        case 7:
          v8.i32[0] = *(_DWORD *)v11;
          goto LABEL_127;
        case 2:
          v8.f32[0] = (float)*(int *)v11;
          goto LABEL_127;
        case 3:
          v8.i32[0] = 0;
          if (*(unsigned char *)v11) {
            v8.f32[0] = 1.0;
          }
          goto LABEL_127;
        case 6:
          v8.f32[0] = *(double *)v11;
          goto LABEL_127;
        case 14:
          v8.f32[0] = (float)*v11;
          goto LABEL_127;
        case 15:
          v8.f32[0] = __from_half((unsigned __int16)*v11);
          goto LABEL_127;
        case 17:
          v8.i16[0] = *v11;
          v8.f32[0] = (float)v8.u32[0];
LABEL_127:
          *(_DWORD *)a3 = v8.i32[0];
          return 1;
        default:
          return result;
      }
    case 4:
      uint64_t result = 0;
      if ((unsigned __int16)Type > 0x1Cu)
      {
        switch((unsigned __int16)Type)
        {
          case 0x1Du:
            v8.i16[0] = *v11;
            v8.f32[0] = (float)v8.u32[0];
            LOWORD(v9) = v11[1];
            float v34 = (float)v9;
            break;
          case 0x20u:
            v8.f32[0] = (float)*v11;
            float v34 = (float)v11[1];
            break;
          case 0x2Bu:
            float v51 = __from_half((unsigned __int16)*v11);
            *(void *)a3 = __PAIR64__(COERCE_UNSIGNED_INT(__from_half((unsigned __int16)v11[1])), LODWORD(v51));
            return 1;
          default:
            return result;
        }
        v8.f32[1] = v34;
        goto LABEL_118;
      }
      if ((unsigned __int16)Type == 8) {
        goto LABEL_81;
      }
      if ((unsigned __int16)Type == 18)
      {
        float32x2_t v26 = vcvt_f32_s32(*(int32x2_t *)v11);
        goto LABEL_82;
      }
      return result;
    case 5:
      uint64_t result = 0;
      if ((unsigned __int16)Type <= 0x1Du)
      {
        if ((unsigned __int16)Type == 9 || (unsigned __int16)Type == 10)
        {
LABEL_86:
          float32x4_t v8 = *(float32x4_t *)v11;
        }
        else
        {
          if ((unsigned __int16)Type != 19) {
            return result;
          }
          *(float32x2_t *)v8.f32 = vcvt_f32_s32(*(int32x2_t *)v11);
          v8.f32[2] = (float)*((int *)v11 + 2);
        }
LABEL_87:
        *(float32x4_t *)a3 = v8;
        return 1;
      }
      switch((unsigned __int16)Type)
      {
        case 0x1Eu:
          v8.i16[0] = *v11;
          v8.f32[0] = (float)v8.u32[0];
          LOWORD(v9) = v11[1];
          float v42 = (float)v9;
          LOWORD(v10) = v11[2];
          float v43 = (float)v10;
          break;
        case 0x21u:
          v8.f32[0] = (float)*v11;
          float v42 = (float)v11[1];
          float v43 = (float)v11[2];
          break;
        case 0x2Cu:
          *(float *)&uint64_t v24 = __from_half((unsigned __int16)*v11);
          *(void *)&long long v50 = v24;
          float v49 = __from_half((unsigned __int16)v11[1]);
          float v25 = __from_half((unsigned __int16)v11[2]);
          long long v18 = v50;
          *((float *)&v18 + 1) = v49;
          *((float *)&v18 + 2) = v25;
LABEL_73:
          *(_OWORD *)a3 = v18;
          return 1;
        default:
          return result;
      }
      v8.f32[1] = v42;
      v8.f32[2] = v43;
      goto LABEL_87;
    case 6:
      uint64_t result = 0;
      if ((unsigned __int16)Type > 0x1Eu)
      {
        if ((unsigned __int16)Type == 31)
        {
          float32x4_t v8 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11));
          goto LABEL_87;
        }
        if ((unsigned __int16)Type != 34)
        {
          if ((unsigned __int16)Type != 45) {
            return result;
          }
          float v52 = __from_half((unsigned __int16)*v11);
          float v48 = __from_half((unsigned __int16)v11[1]);
          float v47 = __from_half((unsigned __int16)v11[2]);
          float v17 = __from_half((unsigned __int16)v11[3]);
          *(void *)&long long v18 = __PAIR64__(LODWORD(v48), LODWORD(v52));
          *((void *)&v18 + 1) = __PAIR64__(LODWORD(v17), LODWORD(v47));
          goto LABEL_73;
        }
        int32x4_t v27 = vmovl_s16(*(int16x4_t *)v11);
LABEL_102:
        float32x4_t v8 = vcvtq_f32_s32(v27);
        goto LABEL_87;
      }
      if ((unsigned __int16)Type == 10) {
        goto LABEL_86;
      }
      if ((unsigned __int16)Type == 20)
      {
        int32x4_t v27 = *(int32x4_t *)v11;
        goto LABEL_102;
      }
      return result;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      goto LABEL_23;
    case 15:
      if (Type != 11) {
        return 0;
      }
      float32x4_t v8 = *(float32x4_t *)Bytes;
      long long v19 = *((_OWORD *)Bytes + 1);
      long long v20 = *((_OWORD *)Bytes + 3);
      *(_OWORD *)(a3 + 32) = *((_OWORD *)Bytes + 2);
      *(_OWORD *)(a3 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v20;
      *(_OWORD *)(a3 + 16) = v19;
      goto LABEL_87;
    case 16:
      uint64_t result = 0;
      switch((__int16)Type)
      {
        case 1:
        case 7:
          v8.i32[0] = *(_DWORD *)v11;
          goto LABEL_136;
        case 2:
          v8.f32[0] = (float)*(int *)v11;
          goto LABEL_136;
        case 3:
          v8.i32[0] = 0;
          if (*(unsigned char *)v11) {
            v8.f32[0] = 1.0;
          }
          goto LABEL_136;
        case 6:
          v8.f32[0] = *(double *)v11;
          goto LABEL_136;
        case 14:
          v8.f32[0] = (float)*v11;
          goto LABEL_136;
        case 15:
          *(_WORD *)a3 = *v11;
          return 1;
        case 17:
          v8.i16[0] = *v11;
          v8.f32[0] = (float)v8.u32[0];
LABEL_136:
          *(_WORD *)a3 = __to_half(v8.f32[0]);
          return 1;
        default:
          return result;
      }
    case 17:
      uint64_t result = 0;
      if ((unsigned __int16)Type > 0x1Cu)
      {
        switch((unsigned __int16)Type)
        {
          case 0x1Du:
            v8.i16[0] = *v11;
            __int16 v35 = __to_half((float)v8.u32[0]);
            LOWORD(v36) = v11[1];
            float v37 = (float)v36;
            break;
          case 0x20u:
            __int16 v35 = __to_half((float)*v11);
            float v37 = (float)v11[1];
            break;
          case 0x2Bu:
LABEL_51:
            int v13 = *(_DWORD *)v11;
LABEL_65:
            *(_DWORD *)a3 = v13;
            return 1;
          default:
            return result;
        }
        *(_WORD *)(a3 + 2) = __to_half(v37);
        *(_WORD *)a3 = v35;
        return 1;
      }
      if ((unsigned __int16)Type == 8)
      {
        LODWORD(v54) = HIDWORD(*(void *)v11);
        __int16 v28 = __to_half(COERCE_FLOAT(*(void *)v11));
        float v29 = v54;
      }
      else
      {
        if ((unsigned __int16)Type != 18) {
          return result;
        }
        int v53 = HIDWORD(*(void *)v11);
        __int16 v28 = __to_half((float)(int)*(void *)v11);
        float v29 = (float)v53;
      }
      *(_WORD *)(a3 + 2) = __to_half(v29);
      *(_WORD *)a3 = v28;
      return 1;
    case 18:
      uint64_t result = 0;
      if ((unsigned __int16)Type <= 0x1Du)
      {
        if ((unsigned __int16)Type == 9 || (unsigned __int16)Type == 10)
        {
          __int16 v21 = __to_half(*(float *)v11);
          __int16 v22 = __to_half(*((float *)v11 + 1));
          float v23 = *((float *)v11 + 2);
        }
        else
        {
          if ((unsigned __int16)Type != 19) {
            return result;
          }
          __int16 v21 = __to_half((float)*(int *)v11);
          __int16 v22 = __to_half((float)*((int *)v11 + 1));
          float v23 = (float)*((int *)v11 + 2);
        }
        goto LABEL_117;
      }
      switch((unsigned __int16)Type)
      {
        case 0x1Eu:
          v8.i16[0] = *v11;
          __int16 v21 = __to_half((float)v8.u32[0]);
          LOWORD(v44) = v11[1];
          __int16 v22 = __to_half((float)v44);
          LOWORD(v45) = v11[2];
          float v23 = (float)v45;
          break;
        case 0x21u:
          __int16 v21 = __to_half((float)*v11);
          __int16 v22 = __to_half((float)v11[1]);
          float v23 = (float)v11[2];
          break;
        case 0x2Cu:
          goto LABEL_81;
        default:
          return result;
      }
LABEL_117:
      __int16 v46 = __to_half(v23);
      v8.i16[0] = v21;
      v8.i16[1] = v22;
      v8.i16[2] = v46;
      goto LABEL_118;
    case 19:
      uint64_t result = 0;
      if ((unsigned __int16)Type <= 0x1Eu)
      {
        if ((unsigned __int16)Type == 10)
        {
          __int16 v30 = __to_half(*(float *)v11);
          __int16 v31 = __to_half(*((float *)v11 + 1));
          __int16 v32 = __to_half(*((float *)v11 + 2));
          float v33 = *((float *)v11 + 3);
        }
        else
        {
          if ((unsigned __int16)Type != 20) {
            return result;
          }
          __int16 v30 = __to_half((float)*(int *)v11);
          __int16 v31 = __to_half((float)*((int *)v11 + 1));
          __int16 v32 = __to_half((float)*((int *)v11 + 2));
          float v33 = (float)*((int *)v11 + 3);
        }
        goto LABEL_111;
      }
      switch((unsigned __int16)Type)
      {
        case 0x1Fu:
          v8.i16[0] = *v11;
          __int16 v30 = __to_half((float)v8.u32[0]);
          LOWORD(v3_Block_object_dispose(&STACK[0x2A0], 8) = v11[1];
          __int16 v31 = __to_half((float)v38);
          LOWORD(v39) = v11[2];
          __int16 v32 = __to_half((float)v39);
          LOWORD(v40) = v11[3];
          float v33 = (float)v40;
LABEL_111:
          __int16 v41 = __to_half(v33);
          v8.i16[0] = v30;
          v8.i16[1] = v31;
          v8.i16[2] = v32;
          v8.i16[3] = v41;
          goto LABEL_118;
        case 0x22u:
          __int16 v30 = __to_half((float)*v11);
          __int16 v31 = __to_half((float)v11[1]);
          __int16 v32 = __to_half((float)v11[2]);
          float v33 = (float)v11[3];
          goto LABEL_111;
        case 0x2Du:
          goto LABEL_81;
      }
      return result;
    case 29:
    case 33:
      uint64_t result = 0;
      if ((unsigned __int16)Type > 0xDu)
      {
        if ((unsigned __int16)Type == 14 || (unsigned __int16)Type == 17)
        {
          int v13 = *v11;
          goto LABEL_65;
        }
      }
      else
      {
        if ((unsigned __int16)Type == 2) {
          goto LABEL_51;
        }
        if ((unsigned __int16)Type == 3)
        {
          int v13 = *(unsigned __int8 *)v11;
          goto LABEL_65;
        }
      }
      return result;
    case 30:
    case 34:
      if (Type == 32 || (unsigned __int16)Type == 29)
      {
        v8.i32[0] = *Bytes;
        v8.i32[1] = Bytes[1];
LABEL_118:
        *(void *)a3 = v8.i64[0];
      }
      else
      {
        if ((unsigned __int16)Type != 18) {
          return 0;
        }
LABEL_81:
        float32x2_t v26 = *(float32x2_t *)v11;
LABEL_82:
        *(float32x2_t *)a3 = v26;
      }
      return 1;
    case 31:
    case 35:
      if (Type == 33 || (unsigned __int16)Type == 30)
      {
        float32x4_t v8 = (float32x4_t)vmovl_s16(*(int16x4_t *)Bytes);
        v8.i32[2] = 0;
        goto LABEL_87;
      }
      if ((unsigned __int16)Type != 19) {
        return 0;
      }
      goto LABEL_86;
    case 32:
    case 36:
      if (Type == 34 || (unsigned __int16)Type == 31)
      {
        float32x4_t v8 = (float32x4_t)vmovl_s16(*(int16x4_t *)Bytes);
        goto LABEL_87;
      }
      if ((unsigned __int16)Type == 20) {
        goto LABEL_86;
      }
      return 0;
    default:
      if (a2 == 53)
      {
        if (Type == 17 || (unsigned __int16)Type == 14)
        {
          char v14 = *Bytes != 0;
          goto LABEL_95;
        }
        if ((unsigned __int16)Type == 3)
        {
          char v14 = *(unsigned char *)Bytes;
LABEL_95:
          *(unsigned char *)a3 = v14;
          return 1;
        }
      }
      else
      {
LABEL_23:
        float32x4_t v15 = scn_default_log();
        BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (!v16) {
          return result;
        }
        *(_DWORD *)float32x4_t buf = 138412290;
        uint64_t v56 = MTLDataTypeString();
        _os_log_impl(&dword_20B249000, v15, OS_LOG_TYPE_DEFAULT, "Warning: C3DValueWriteToMTLData - Unsupported data type %@", buf, 0xCu);
      }
      return 0;
  }
}

float __from_half(unsigned int a1)
{
  int v1 = (a1 >> 10) & 0x1F;
  if (v1 && v1 != 31)
  {
    int v1 = (v1 << 23) + 939524096;
  }
  else if (v1 == 31)
  {
    int v1 = 2139095040;
  }
  LODWORD(result) = (a1 << 16) & 0x80000000 | (a1 >> 7) & 7 | (8 * (a1 & 0x3FF)) & 0x1FFF | ((a1 & 0x3FF) << 13) | v1;
  return result;
}

uint64_t __to_half(float a1)
{
  int v1 = HIWORD(LODWORD(a1)) & 0x8000;
  unsigned int v2 = (LODWORD(a1) >> 23);
  unsigned int v3 = v2 - 112;
  unsigned int v4 = v2 - 113;
  __int16 v5 = v1 | 0x7BFF;
  if (v2 == 255) {
    __int16 v5 = v1 | ((LODWORD(a1) & 0x7FFFFF) != 0) | 0x7C00;
  }
  if (v2 >= 0x71) {
    __int16 v6 = v5;
  }
  else {
    __int16 v6 = HIWORD(a1) & 0x8000;
  }
  int v7 = HIWORD(LODWORD(a1)) & 0x8000 | (LODWORD(a1) >> 13) & 0x3FF | (v3 << 10);
  if (v4 > 0x1D) {
    LOWORD(v7) = v6;
  }
  return (unsigned __int16)v7;
}

void C3DValueWriteToStructMember(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if ((C3DValueWriteToMTLData(a1, [a2 dataType], a3 + objc_msgSend(a2, "offset")) & 1) == 0)
  {
    __int16 v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = C3DValueGetType(a1);
      __int16 v7 = 2112;
      float32x4_t v8 = a2;
      _os_log_impl(&dword_20B249000, v5, OS_LOG_TYPE_DEFAULT, "Warning: value unsupported %d of member %@", (uint8_t *)v6, 0x12u);
    }
  }
}

CGImageRef C3DCreateImageWithTexture(void *a1)
{
  uint64_t v2 = [a1 pixelFormat];
  if (v2 > 79)
  {
    if ((unint64_t)(v2 - 80) < 2)
    {
      uint32_t v3 = 8194;
      goto LABEL_9;
    }
    if (v2 == 125)
    {
      uint32_t v3 = 16641;
      size_t v4 = 32;
      goto LABEL_10;
    }
    if (v2 == 115)
    {
      uint32_t v3 = 12545;
      size_t v4 = 16;
LABEL_10:
      size_t v5 = ((v4 * [a1 width]) >> 1) & 0xFFFFFFFC;
      __int16 v6 = malloc_type_malloc(v5 * [a1 height], 0x4BFDEC0uLL);
      size_t v7 = [a1 width];
      size_t v8 = [a1 height];
      uint64_t v9 = (CGColorSpace *)C3DColorSpaceSRGB();
      unsigned int v10 = CGBitmapContextCreate(v6, v7, v8, v4, v5, v9, v3);
      memset(v14, 0, 24);
      void v14[3] = [a1 width];
      _OWORD v14[4] = [a1 height];
      v14[5] = 1;
      [a1 getBytes:v6 bytesPerRow:v5 fromRegion:v14 mipmapLevel:0];
      CGImageRef Image = CGBitmapContextCreateImage(v10);
      CGContextRelease(v10);
      free(v6);
      return Image;
    }
  }
  else if ((unint64_t)(v2 - 70) < 5)
  {
    uint32_t v3 = 16385;
LABEL_9:
    size_t v4 = 8;
    goto LABEL_10;
  }
  int v13 = scn_default_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
    C3DCreateImageWithTexture_cold_1(a1, v13);
  }
  return 0;
}

uint64_t SCNTextureUsageFromString(const void *a1)
{
  if (CFEqual(a1, @"shaderRead")) {
    return 1;
  }
  if (CFEqual(a1, @"shaderWrite")) {
    return 2;
  }
  if (CFEqual(a1, @"renderTarget")) {
    return 4;
  }
  return 16 * (CFEqual(a1, @"pixelFormatView") != 0);
}

__CFString *SCNTextureUsageToString(char a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F089D8]);
  uint32_t v3 = v2;
  BOOL v4 = (a1 & 1) == 0;
  if (a1)
  {
    [v2 appendString:@"MTLTextureUsageShaderRead"];
    if ((a1 & 2) == 0)
    {
      if ((a1 & 4) == 0)
      {
        if ((a1 & 0x10) == 0) {
          return (__CFString *)v3;
        }
        goto LABEL_20;
      }
      goto LABEL_15;
    }
    [v3 appendString:@" | "];
  }
  else if ((a1 & 2) == 0)
  {
    if ((a1 & 4) == 0) {
      goto LABEL_4;
    }
    goto LABEL_13;
  }
  [v3 appendString:@"MTLTextureUsageShaderWrite"];
  if ((a1 & 4) == 0)
  {
LABEL_4:
    if ((a1 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_13:
  if ((a1 & 1) == 0)
  {
    BOOL v4 = 1;
    goto LABEL_16;
  }
LABEL_15:
  [v3 appendString:@" | "];
  BOOL v4 = 0;
LABEL_16:
  [v3 appendString:@"MTLTextureUsageRenderTarget"];
  if ((a1 & 0x10) == 0)
  {
LABEL_5:
    if (!v4) {
      return (__CFString *)v3;
    }
    return @"MTLTextureUsageUnknown";
  }
LABEL_17:
  if (!v4)
  {
LABEL_20:
    [v3 appendString:@" | "];
    [v3 appendString:@"MTLTextureUsagePixelFormatView"];
    return (__CFString *)v3;
  }
  [v3 appendString:@"MTLTextureUsagePixelFormatView"];
  return @"MTLTextureUsageUnknown";
}

uint64_t SCNTextureUsageFromStrings(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  uint64_t v5 = 0;
  do
  {
    ValueAtuint64_t Index = CFArrayGetValueAtIndex(a1, v4);
    v5 |= SCNTextureUsageFromString(ValueAtIndex);
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

uint64_t C3DMeshSourceCreateWithMTLBuffer(__int16 a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a2 && (float32x4_t v12 = scn_default_log(), os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    C3DMeshSourceCreateWithMTLBuffer_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  long long v20 = scn_default_log();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
    C3DMeshSourceCreateWithMTLBuffer_cold_2(v20, v21, v22, v23, v24, v25, v26, v27);
  }
LABEL_6:
  unsigned int v28 = SCNMTLVertexFormatToC3DBaseType(a3);
  Componentint Type = C3DBaseTypeGetComponentType(v28);
  ComponentCFIndex Count = C3DBaseTypeGetComponentCount(v28);
  __int16 v31 = (const void *)C3DSourceAccessorCreate(ComponentType, ComponentCount, a4, a5, a6);
  uint64_t v32 = C3DMeshSourceCreateWithAccessor(v31, a1);
  if (!v32)
  {
    float v33 = scn_default_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
    }
  }
  C3DSourceAccessorSetSource((uint64_t)v31, v32);
  if (v31) {
    CFRelease(v31);
  }
  *(void *)(v32 + 72) = CFRetain(a2);
  *(void *)(v32 + 80) = a3;
  return v32;
}

void __SCNMTLEnsureIOSurfaceBackingBufferValidity_block_invoke(uint64_t a1)
{
}

uint64_t SCNMTLDeviceRequiresOffsetAndStrideForStageInAsMultipleOf4Bytes(void *a1)
{
  return [a1 supportsUnalignedVertexFetch] ^ 1;
}

uint64_t C3DImageCreateWithURL(const void *a1)
{
  uint64_t v2 = C3DImageCreate();
  if (v2)
  {
    *(void *)(v2 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 1;
  }
  return v2;
}

uint64_t C3DImageCreateWithData(const void *a1)
{
  uint64_t v2 = C3DImageCreate();
  if (v2)
  {
    *(void *)(v2 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 2;
  }
  return v2;
}

uint64_t C3DImageCreateWithRawData(const void *a1, unsigned __int8 a2, char a3, double a4)
{
  uint64_t v8 = C3DImageCreateWithData(a1);
  _C3DImageCreateTextureRawData(v8, 0, 1, a4);
  TextureRawCFDataRef Data = C3DImageGetTextureRawData(v8);
  *(unsigned char *)(TextureRawData + 4) = a2;
  *(unsigned char *)(TextureRawData + 5) = a3;
  *(unsigned char *)(TextureRawData + 10) = 1;
  if (a3 == 4)
  {
    int v10 = a2;
    if (a2 == 128)
    {
LABEL_16:
      int v12 = 125;
LABEL_22:
      *(_DWORD *)(TextureRawData + 36) = v12;
      goto LABEL_25;
    }
    if (a2 == 64)
    {
LABEL_17:
      int v12 = 110;
      goto LABEL_22;
    }
    goto LABEL_12;
  }
  if (a3 == 2)
  {
    int v10 = a2;
    if (a2 > 0x3Fu) {
      goto LABEL_14;
    }
    if (a2 == 16)
    {
LABEL_21:
      int v12 = 30;
      goto LABEL_22;
    }
LABEL_12:
    if (v10 == 32)
    {
LABEL_13:
      long long v11 = xmmword_20B5CCAB0;
LABEL_24:
      *(_OWORD *)(TextureRawData + 24) = v11;
      goto LABEL_25;
    }
    goto LABEL_25;
  }
  if (a3 != 1) {
    goto LABEL_25;
  }
  int v10 = a2;
  if (a2 <= 0x1Fu)
  {
    if (a2 == 8)
    {
      long long v11 = xmmword_20B5CCAC0;
      goto LABEL_24;
    }
    if (a2 != 16) {
      goto LABEL_25;
    }
    *(int32x2_t *)(TextureRawData + 24) = vdup_n_s32(0x1909u);
    *(_DWORD *)(TextureRawData + 32) = 5123;
    goto LABEL_21;
  }
  if (a2 == 32) {
    goto LABEL_13;
  }
LABEL_14:
  if (v10 == 64) {
    goto LABEL_17;
  }
  if (v10 == 128) {
    goto LABEL_16;
  }
LABEL_25:
  CFArrayAppendValue(*(CFMutableArrayRef *)(TextureRawData + 40), a1);
  return v8;
}

uint64_t _C3DImageCreateTextureRawData(uint64_t a1, int a2, char a3, double a4)
{
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  if (*(void *)(a1 + 72))
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DImageCreateTextureRawData_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  *(void *)(a1 + 72) = malloc_type_calloc(1uLL, 0x30uLL, 0x1020040B13EBABEuLL);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
  uint64_t v17 = *(void *)(a1 + 72);
  *(void *)(v17 + 40) = Mutable;
  *(_DWORD *)uint64_t v17 = a2;
  *(unsigned char *)(a1 + 80) &= ~2u;
  *(double *)(a1 + 104) = a4;
  *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFE | a3 | 0xC;
  return pthread_mutex_unlock(&bitmapAccessSharedMutex);
}

CFURLRef C3DImageCreateWithPath(CFStringRef filePath)
{
  CFURLRef result = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x263EFFB08], filePath, kCFURLPOSIXPathStyle, 0);
  if (result)
  {
    CFURLRef v2 = result;
    uint64_t v3 = C3DImageCreateWithURL(result);
    CFRelease(v2);
    return (CFURLRef)v3;
  }
  return result;
}

uint64_t C3DImageCreateVerticalStripCubemapWithFaceImages(uint64_t *a1)
{
  uint64_t v2 = 0;
  image[7] = *(CGImageRef *)MEMORY[0x263EF8340];
  do
  {
    if (!a1[v2])
    {
      uint64_t v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        C3DImageCreateVerticalStripCubemapWithFaceImages_cold_1(v2, v19);
      }
      return 0;
    }
    ++v2;
  }
  while (v2 != 6);
  uint64_t v3 = 0;
  size_t v4 = 0;
  do
  {
    double Size = C3DImageGetSize(a1[v3]);
    float v6 = *((float *)&Size + 1);
    if (*(float *)&Size != *((float *)&Size + 1))
    {
      float v37 = *(float *)&Size;
      long long v20 = scn_default_log();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      LODWORD(image[0]) = 67109632;
      HIDWORD(image[0]) = v3;
      LOWORD(image[1]) = 2048;
      *(double *)((char *)&image[1] + 2) = v37;
      WORD1(image[2]) = 2048;
      *(double *)((char *)&image[2] + 4) = v6;
      uint64_t v21 = "Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f";
      uint64_t v22 = v20;
      uint32_t v23 = 28;
      goto LABEL_46;
    }
    float v7 = floorf(*(float *)&Size);
    if (v3)
    {
      float v8 = floorf(*((float *)&Size + 1));
      if (v7 != (float)v4 || v8 != (float)v4)
      {
        float v38 = *(float *)&Size;
        uint64_t v24 = scn_default_log();
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        LODWORD(image[0]) = 67110144;
        HIDWORD(image[0]) = v3;
        LOWORD(image[1]) = 2048;
        *(double *)((char *)&image[1] + 2) = v38;
        WORD1(image[2]) = 2048;
        *(double *)((char *)&image[2] + 4) = v6;
        WORD2(image[3]) = 2048;
        *(CGImageRef *)((char *)&image[3] + 6) = (CGImageRef)v4;
        HIWORD(image[4]) = 2048;
        image[5] = (CGImageRef)v4;
        uint64_t v21 = "Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expec"
              "ted size (%zux%zu)";
        uint64_t v22 = v24;
        uint32_t v23 = 48;
LABEL_46:
        _os_log_error_impl(&dword_20B249000, v22, OS_LOG_TYPE_ERROR, v21, (uint8_t *)image, v23);
        return 0;
      }
    }
    else
    {
      size_t v4 = (unint64_t)v7;
    }
    ++v3;
  }
  while (v3 != 6);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  while (1)
  {
    TextureRawCFDataRef Data = C3DImageGetTextureRawData(a1[v10]);
    if (!TextureRawData) {
      break;
    }
    if (v10 * 8)
    {
      if (!C3DTextureRawDataIsEqual(v11, TextureRawData)) {
        break;
      }
    }
    else
    {
      uint64_t v11 = TextureRawData;
    }
    if (++v10 == 6)
    {
      uint64_t v13 = (int *)C3DImageGetTextureRawData(*a1);
      uint64_t v14 = C3DImageCreate();
      *(float *)&double v15 = (float)v4;
      *((float *)&v15 + 1) = (float)(6 * v4);
      _C3DImageCreateTextureRawData(v14, *v13, 0, v15);
      *(unsigned char *)(v14 + 116) |= 0x38u;
      *(_DWORD *)(v14 + 120) = 5;
      uint64_t v16 = C3DImageGetTextureRawData(v14);
      C3DTextureRawDataCopyAttributes(v16, (uint64_t)v13);
      for (uint64_t i = 0; i != 6; ++i)
      {
        uint64_t v18 = C3DImageGetTextureRawData(a1[i]);
        CFArrayAppendValue(*(CFMutableArrayRef *)(v16 + 40), *(const void **)(v18 + 40));
      }
      return v14;
    }
  }
  uint64_t v27 = 0;
  memset(image, 0, 48);
  while (1)
  {
    unsigned int v28 = C3DImageCopyCGImage(a1[v27]);
    if (!v28) {
      break;
    }
    image[v27++] = v28;
    if (v27 == 6)
    {
      ColorSpace = CGImageGetColorSpace(image[0]);
      __int16 v30 = CGBitmapContextCreate(0, v4, 6 * v4, 8uLL, 4 * v4, ColorSpace, 0x4001u);
      double v31 = (double)v4;
      for (uint64_t j = 5; j != -1; --j)
      {
        v40.origin.float x = 0.0;
        v40.origin.float y = 0.0;
        v40.size.width = v31;
        v40.size.height = v31;
        CGContextDrawImage(v30, v40, image[j]);
        CGContextTranslateCTM(v30, 0.0, v31);
      }
      float v33 = CGBitmapContextCreateImage(v30);
      uint64_t v14 = C3DImageCreateWithCGImage(v33);
      *(_DWORD *)(v14 + 120) = 5;
      CGImageRelease(v33);
      CGContextRelease(v30);
      goto LABEL_40;
    }
  }
  uint64_t v34 = scn_default_log();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
    C3DImageCreateVerticalStripCubemapWithFaceImages_cold_2(v27, v34);
  }
  uint64_t v14 = 0;
LABEL_40:
  for (uint64_t k = 0; k != 6; ++k)
  {
    CGImageRef v36 = image[k];
    if (v36)
    {
      CFRelease(v36);
      image[k] = 0;
    }
  }
  return v14;
}

BOOL C3DTextureRawDataIsEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2 || (uint64_t v3 = 0, a1) && a2)
  {
    if (*(unsigned __int8 *)(a1 + 4) == *(unsigned __int8 *)(a2 + 4)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
      && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36))
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
      return Count == CFArrayGetCount(*(CFArrayRef *)(a2 + 40));
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

double C3DTextureRawDataCopyAttributes(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 11) = *(_WORD *)(a2 + 11);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  double result = *(double *)(a2 + 32);
  *(double *)(a1 + 32) = result;
  return result;
}

_DWORD *C3DImageCreateVerticalStripCubemapWithImage(uint64_t a1)
{
  int v1 = (_DWORD *)a1;
  if (!C3DImageIsCubeMap(a1))
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      C3DImageCreateVerticalStripCubemapWithImage_cold_1();
    }
    return 0;
  }
  if (v1[30] != 5) {
    return 0;
  }
  CFRetain(v1);
  return v1;
}

uint64_t C3DImageCreateWithClientImage(const void *a1)
{
  uint64_t v2 = C3DImageCreate();
  if (v2)
  {
    *(void *)(v2 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 4;
  }
  return v2;
}

CFURLRef C3DImageCreateWithName(__CFString *a1)
{
  int v1 = a1;
  uint64_t v2 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F38378], "defaultUICatalogForBundle:", SCNGetResourceBundle()), "namedTextureWithName:scaleFactor:", a1, 1.0);
  if (!v2) {
    goto LABEL_3;
  }
  uint64_t v3 = v2;
  [v2 size];
  float64_t v15 = v5;
  float64_t v16 = v4;
  char v6 = [v3 isOpaque];
  v7.f64[0] = v16;
  v7.f64[1] = v15;
  CFURLRef result = (CFURLRef)C3DImageCreateWithCatalogTextureNameAndSize(v1, v6, COERCE_DOUBLE(vcvt_f32_f64(v7)));
  if (!result)
  {
LABEL_3:
    CFURLRef v9 = C3DCopyURLOfResourceNamed(v1);
    if (v9)
    {
      CFURLRef v10 = v9;
      uint64_t v11 = C3DImageCreateWithURL(v9);
      CFRelease(v10);
      return (CFURLRef)v11;
    }
    else
    {
      if ((unint64_t)[(__CFString *)v1 length] >= 2
        && [(__CFString *)v1 characterAtIndex:0] != 47)
      {
        BOOL v12 = SCNHasSpecialResourceBundle();
        uint64_t v13 = (void *)SCNGetResourceBundle();
        if (v12) {
          uint64_t v14 = (void *)[v13 bundlePath];
        }
        else {
          uint64_t v14 = (void *)[v13 resourcePath];
        }
        int v1 = (__CFString *)[v14 stringByAppendingPathComponent:v1];
      }
      return C3DImageCreateWithPath(v1);
    }
  }
  return result;
}

uint64_t C3DImageCreateWithCatalogTextureNameAndSize(const void *a1, char a2, double a3)
{
  uint64_t v6 = C3DImageCreate();
  if (v6)
  {
    *(void *)(v6 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(a1);
    *(_DWORD *)(v6 + 96) = 5;
    char v7 = *(unsigned char *)(v6 + 116);
    *(double *)(v6 + 104) = a3;
    *(unsigned char *)(v6 + 116) = v7 & 0xFE | a2 ^ 1 | 0x1C;
  }
  return v6;
}

CGContextRef C3DCreateSRGBBitmapContextWithSize(double a1, double a2)
{
  size_t v2 = (unint64_t)a1;
  size_t v3 = (unint64_t)a2;
  size_t v4 = 4 * (unint64_t)a1;
  double v5 = (CGColorSpace *)C3DColorSpaceSRGB();

  return CGBitmapContextCreate(0, v2, v3, 8uLL, v4, v5, 0x4001u);
}

CGContextRef C3DCreateSRGBBitmapContextWithContext(CGContext *a1)
{
  CGColorSpaceRef ColorSpace = CGBitmapContextGetColorSpace(a1);
  if (ColorSpace == (CGColorSpaceRef)C3DColorSpaceSRGB())
  {
    return CGContextRetain(a1);
  }
  else
  {
    double Width = (double)CGBitmapContextGetWidth(a1);
    double Height = (double)CGBitmapContextGetHeight(a1);
    CGFloat v5 = *MEMORY[0x263F00148];
    CGFloat v6 = *(double *)(MEMORY[0x263F00148] + 8);
    char v7 = C3DCreateSRGBBitmapContextWithSize(Width, Height);
    CGImageRef Image = CGBitmapContextCreateImage(a1);
    v11.origin.float x = v5;
    v11.origin.float y = v6;
    v11.size.width = Width;
    v11.size.height = Height;
    CGContextDrawImage(v7, v11, Image);
    CGImageRelease(Image);
    return v7;
  }
}

uint64_t C3DImageCreateWithCGImageAndSize(CGImage *a1, double a2)
{
  uint64_t v3 = C3DImageCreateWithCGImage(a1);
  __ImageResize(v3, a1, *(float *)&a2, *((float *)&a2 + 1));
  *(unsigned char *)(v3 + 116) |= 8u;
  *(double *)(v3 + 104) = a2;
  return v3;
}

void __ImageResize(uint64_t a1, CGImage *a2, unsigned int a3, unsigned int a4)
{
  double Size = C3DImageGetSize(a1);
  float v9 = (float)a3;
  float v10 = (float)a4;
  v11.f32[0] = (float)a3;
  v11.f32[1] = (float)a4;
  uint32x2_t v12 = (uint32x2_t)vceq_f32(*(float32x2_t *)&Size, v11);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) == 0)
  {
    if (a2)
    {
      CGFloat v13 = v9;
      CGFloat v14 = v10;
      float64_t v15 = C3DCreateSRGBBitmapContextWithSize(v9, v10);
      CGContextSetInterpolationQuality(v15, kCGInterpolationHigh);
      v19.origin.float x = 0.0;
      v19.origin.float y = 0.0;
      v19.size.width = v13;
      v19.size.height = v14;
      CGContextDrawImage(v15, v19, a2);
      pthread_mutex_lock(&bitmapAccessSharedMutex);
      float64_t v16 = *(const void **)(a1 + 64);
      if (v16) {
        CFRelease(v16);
      }
      *(void *)(a1 + 64) = v15;
      pthread_mutex_unlock(&bitmapAccessSharedMutex);
      if (*(_DWORD *)(a1 + 96))
      {
        *(_DWORD *)(a1 + 96) = 0;
        uint64_t v17 = *(const void **)(a1 + 88);
        if (v17)
        {
          CFRelease(v17);
          *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 0;
        }
      }
    }
    else
    {
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        __ImageResize_cold_1();
      }
    }
  }
}

uint64_t C3DImageGetCatalogTextureName(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 96) != 5)
  {
    size_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetCatalogTextureName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 88);
}

uint64_t C3DImageCopyUSDZEmbeddedData(uint64_t a1, BOOL *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  URL = (void *)C3DImageGetURL(a1);
  uint64_t v4 = objc_msgSend((id)objc_msgSend(URL, "query"), "length");
  if (a2) {
    *a2 = v4 != 0;
  }
  if (!v4) {
    return 0;
  }
  uint64_t v5 = objc_msgSend((id)objc_msgSend(URL, "path"), "stringByStandardizingPath");
  uint64_t v6 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F08BA0], "componentsWithURL:resolvingAgainstBaseURL:", URL, 0), "queryItems");
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (!v7) {
    goto LABEL_19;
  }
  uint64_t v8 = v7;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = *(void *)v20;
  do
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      if (*(void *)v20 != v11) {
        objc_enumerationMutation(v6);
      }
      CGFloat v13 = *(void **)(*((void *)&v19 + 1) + 8 * i);
      if (objc_msgSend((id)objc_msgSend(v13, "name"), "isEqualToString:", @"offset"))
      {
        uint64_t v9 = (int)objc_msgSend((id)objc_msgSend(v13, "value"), "intValue");
      }
      else if (objc_msgSend((id)objc_msgSend(v13, "name"), "isEqualToString:", @"size"))
      {
        uint64_t v10 = (int)objc_msgSend((id)objc_msgSend(v13, "value"), "intValue");
      }
    }
    uint64_t v8 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
  }
  while (v8);
  if (v10 < 1)
  {
LABEL_19:
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      C3DImageCopyUSDZEmbeddedData_cold_1();
    }
    return 0;
  }
  CGFloat v14 = objc_msgSend(objc_alloc(NSClassFromString(&cfstr_Mdlmemorymappe.isa)), "initWithURL:offset:length:", objc_msgSend(NSURL, "fileURLWithPath:", v5), v9, v10);
  uint64_t v15 = objc_msgSend((id)objc_msgSend(v14, "dataNoCopy"), "copy");

  if (!v15)
  {
    float64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      C3DImageCopyUSDZEmbeddedData_cold_2();
    }
    goto LABEL_19;
  }
  return v15;
}

BOOL C3DImageIsConvertibleToCubeMap(uint64_t a1)
{
  double Size = C3DImageGetSize(a1);
  return (unint64_t)*(float *)&Size == 2 * (unint64_t)*((float *)&Size + 1);
}

void C3DImageSetNeedsUnpremultiply(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFD | v12;
}

void C3DImageSetImageType(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 120) = a2;
}

BOOL C3DImageHasCubeMapComplexLayout(uint64_t a1)
{
  if (!a1)
  {
    size_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(_DWORD *)(a1 + 120) & 0xFFFFFFFC) == 4;
}

void C3DImageChangeImageTypeTo3DIfSuitable(uint64_t a1)
{
  if (!a1)
  {
    size_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DImageGetImageType(a1) != 2)
  {
    uint64x2_t v10 = vcvtq_u64_f64(vcvtq_f64_f32(vrnda_f32(COERCE_FLOAT32X2_T(C3DImageGetSize(a1)))));
    if (v10.i64[1] * v10.i64[0])
    {
      if (!(v10.i64[0] % (unint64_t)v10.i64[1])) {
        *(_DWORD *)(a1 + 120) = 2;
      }
    }
  }
}

void _C3DImageChangeImageTypeToCubeMapIfSuitable(uint64_t a1)
{
  if (!a1)
  {
    size_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (!C3DImageIsCubeMap(a1))
  {
    double Size = C3DImageGetSize(a1);
    unint64_t v11 = vcvtas_u32_f32(*(float *)&Size);
    unint64_t v12 = vcvtas_u32_f32(*((float *)&Size + 1));
    if (*(float *)&Size == (float)v11 && *((float *)&Size + 1) == (float)v12)
    {
      if (6 * v12 == v11)
      {
        int v14 = 4;
      }
      else
      {
        if (6 * v11 != v12) {
          return;
        }
        int v14 = 5;
      }
      *(_DWORD *)(a1 + 120) = v14;
    }
  }
}

void C3DImageEnumerateCubeMapFacePixelBuffers(unsigned int a1, uint64_t a2, uint64_t a3, size_t a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a2;
  if (a1 == 5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3 * a2;
    do
    {
      (*(void (**)(uint64_t, void, uint64_t))(a7 + 16))(a7, v11++, a6);
      a6 += v12;
    }
    while (v11 != 6);
    return;
  }
  unsigned int v15 = a1;
  __dst = (char *)malloc_type_malloc(a4 * a2, 0x20D28490uLL);
  if (v15 <= 7 && ((1 << v15) & 0xD0) != 0)
  {
    unint64_t v16 = 0;
    uint64_t v33 = a6;
    __src = (char *)(a6 + a5 * (v10 - 1 + v10) + a3 * (3 * v10 + v10 - 1));
    uint64_t v32 = a3 * v10;
    uint64_t v37 = v10;
    unsigned int v34 = v15;
    while (1)
    {
      unint64_t v36 = v16;
      if (v15 == 4)
      {
        uint64_t v17 = 0;
        uint64_t v18 = v16;
        if (v10) {
          goto LABEL_20;
        }
      }
      else
      {
        if (v15 == 7)
        {
          uint64_t v17 = 1;
          uint64_t v18 = 2;
          switch(v16)
          {
            case 0uLL:
              goto LABEL_19;
            case 1uLL:
              uint64_t v18 = 0;
              uint64_t v17 = 1;
              if (v10) {
                goto LABEL_20;
              }
              goto LABEL_22;
            case 2uLL:
              uint64_t v17 = 0;
              goto LABEL_27;
            case 3uLL:
              uint64_t v17 = 2;
              goto LABEL_27;
            case 4uLL:
              uint64_t v17 = 1;
LABEL_27:
              uint64_t v18 = 1;
              if (!v10) {
                goto LABEL_22;
              }
              goto LABEL_20;
            case 5uLL:
              if (a5)
              {
                if (v10)
                {
                  uint64_t v22 = 0;
                  uint32_t v23 = __dst;
                  uint64_t v24 = __src;
                  uint64_t v31 = a7;
                  do
                  {
                    uint64_t v25 = v23;
                    uint64_t v26 = v37;
                    uint64_t v27 = v24;
                    do
                    {
                      memcpy(v25, v27, a5);
                      v27 -= a5;
                      v25 += a5;
                      --v26;
                    }
                    while (v26);
                    ++v22;
                    v24 -= a3;
                    v23 += a4;
                    a7 = v31;
                  }
                  while (v22 != v37);
                }
              }
              else
              {
                unsigned int v28 = scn_default_log();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
                  C3DImageEnumerateCubeMapFacePixelBuffers_cold_2(&buf, v39, v28);
                }
              }
              goto LABEL_22;
            default:
              goto LABEL_18;
          }
        }
        if (v16 >= 6)
        {
LABEL_18:
          uint64_t v17 = 0;
          uint64_t v18 = 0;
LABEL_19:
          if (!v10) {
            goto LABEL_22;
          }
LABEL_20:
          long long v19 = (char *)(v33 + v18 * a4 + v32 * v17);
          long long v20 = __dst;
          uint64_t v21 = v37;
          do
          {
            memcpy(v20, v19, a4);
            v20 += a4;
            v19 += a3;
            --v21;
          }
          while (v21);
          goto LABEL_22;
        }
        uint64_t v17 = qword_20B5CCAF8[v16];
        uint64_t v18 = qword_20B5CCB28[v16];
        if (v10) {
          goto LABEL_20;
        }
      }
LABEL_22:
      (*(void (**)(uint64_t, void, char *))(a7 + 16))(a7, v36, __dst);
      unint64_t v16 = v36 + 1;
      uint64_t v10 = v37;
      unsigned int v15 = v34;
      if (v36 == 5) {
        goto LABEL_40;
      }
    }
  }
  float v29 = scn_default_log();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
    C3DImageEnumerateCubeMapFacePixelBuffers_cold_1();
  }
LABEL_40:
  free(__dst);
}

void C3DImageEnumerateTexture3DSlicePixelBuffers(int a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (a1 == 2)
  {
    int v14 = (char *)malloc_type_malloc(a5 * a2, 0x73549360uLL);
    if (a3)
    {
      uint64_t v15 = 0;
      uint64_t v20 = a6 * a2;
      do
      {
        unint64_t v16 = a7;
        uint64_t v17 = v14;
        for (uint64_t i = a2; i; --i)
        {
          memcpy(v17, v16, a5);
          v17 += a5;
          v16 += a4;
        }
        (*(void (**)(uint64_t, void, char *))(a8 + 16))(a8, v15++, v14);
        a7 += v20;
      }
      while (v15 != a3);
    }
    free(v14);
  }
  else
  {
    long long v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      C3DImageEnumerateTexture3DSlicePixelBuffers_cold_1();
    }
  }
}

_DWORD *C3DImageGetDefault()
{
  CFURLRef result = (_DWORD *)kDefaultImage;
  if (!kDefaultImage)
  {
    CFURLRef result = C3DMalloc(4uLL);
    if (result)
    {
      *CFURLRef result = -1;
      int v1 = CGDataProviderCreateWithData(0, result, 4uLL, 0);
      size_t v2 = (CGColorSpace *)C3DColorSpaceLinearSRGB();
      uint64_t v3 = CGImageCreate(1uLL, 1uLL, 8uLL, 0x20uLL, 4uLL, v2, 0x4001u, v1, 0, 0, kCGRenderingIntentDefault);
      CGDataProviderRelease(v1);
      kDefaultCGImageRef Image = C3DImageCreateWithCGImage(v3);
      CFRelease(v3);
      return (_DWORD *)kDefaultImage;
    }
  }
  return result;
}

unsigned int *C3DImageGetTextureRawDataCompression(uint64_t a1)
{
  CFURLRef result = (unsigned int *)C3DImageGetTextureRawData(a1);
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

CFStringRef _C3DImageCFCopyDebugDescription(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 96);
  BOOL v3 = v2 > 4;
  int v4 = (1 << v2) & 0x16;
  if (v3 || v4 == 0)
  {
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
    return CFStringCreateWithFormat(v8, 0, @"<C3DImage %p src:%p [%fx%f]>", a1, *(void *)(a1 + 88), COERCE_FLOAT(*(void *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 104))));
  }
  else
  {
    CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
    return CFStringCreateWithFormat(v6, 0, @"<C3DImage %p src:%@ [%fx%f]>", a1, *(void *)(a1 + 88), COERCE_FLOAT(*(void *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 104))));
  }
}

uint64_t _C3DImageInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  if (!a1)
  {
    CFAllocatorRef v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityInitWithPropertyList(a1, a2);
  if ((v14 & 1) == 0)
  {
    unint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      _C3DImageInitWithPropertyList_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    return v14;
  }
  unint64_t Value = CFDictionaryGetValue(a2, @"imageData");
  if (Value)
  {
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(Value);
    *(_DWORD *)(a1 + 96) = 2;
    C3DImageCacheBitmap(a1);
    return v14;
  }
  CFURLRef v24 = (const __CFURL *)CFDictionaryGetValue(a3, @"kEnclosingFolderURL");
  CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(a2, @"imageRelativePath");
  CFStringRef v26 = (const __CFString *)CFDictionaryGetValue(a2, @"distantImageURL");
  *(_DWORD *)(a1 + 96) = 1;
  CFStringRef Attribute = (const __CFString *)C3DImageGetAttribute(a1, @"runtimePath");
  if (Attribute)
  {
    CFURLRef v28 = CFURLCreateWithFileSystemPath(0, Attribute, kCFURLPOSIXPathStyle, 0);
    if (v28)
    {
      CFURLRef v29 = v28;
      *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = C3DIOCopyResolvedImageURL(v28, a3);
      CFRelease(v29);
    }
  }
  __int16 v30 = *(void **)(a1 + 88);
  if (v30)
  {
LABEL_38:
    v42[0] = MEMORY[0x263EF8330];
    v42[1] = 3221225472;
    v42[2] = ___C3DImageInitWithPropertyList_block_invoke;
    _OWORD v42[3] = &__block_descriptor_40_e217_____C3DImage____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q___CGContext_____C3DTextureRawData_b1b1_______CFString_____CFURL_____CFData___CGImage__v_iSCCb1b1b1b1b1b1i_8__0l;
    v42[4] = a1;
    Shareduint64_t Instance = C3DResourceCacheGetSharedInstance();
    IfNeededForuint64_t Source = (const void *)C3DResourceCacheCopyResourceOrCreateIfNeededForSource(SharedInstance, v30, 1, (uint64_t)v42);
    CFRelease(IfNeededForSource);
    return v14;
  }
  if (v25)
  {
    BOOL v31 = CFStringGetLength(v25) >= 1 && CFStringGetCharacterAtIndex(v25, 0) == 47;
    if (!v24 || v31) {
      CFURLRef v32 = CFURLCreateWithFileSystemPath(0, v25, kCFURLPOSIXPathStyle, 0);
    }
    else {
      CFURLRef v32 = (const __CFURL *)C3DURLCreateCopyAppendingPathComponent(v24, v25);
    }
  }
  else
  {
    if (!v26)
    {
      CFURLRef v33 = 0;
      goto LABEL_29;
    }
    CFURLRef v32 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x263EFFB08], v26, 0);
  }
  CFURLRef v33 = v32;
  if (v32)
  {
    CFURLRef v34 = C3DIOCopyResolvedImageURL(v32, a3);
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v34;
    if (v34) {
      goto LABEL_32;
    }
  }
  else if (*(void *)(a1 + 88))
  {
    goto LABEL_32;
  }
LABEL_29:
  CFStringRef v35 = (const __CFString *)C3DImageGetAttribute(a1, @"relativePath");
  if (v35)
  {
    CFURLRef v36 = CFURLCreateWithFileSystemPath(0, v35, kCFURLPOSIXPathStyle, 0);
    if (v36)
    {
      CFURLRef v37 = v36;
      *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = C3DIOCopyResolvedImageURL(v36, a3);
      CFRelease(v37);
    }
  }
LABEL_32:
  __int16 v30 = *(void **)(a1 + 88);
  if (v33 && !v30)
  {
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = CFRetain(v33);
LABEL_36:
    CFRelease(v33);
    __int16 v30 = *(void **)(a1 + 88);
    goto LABEL_37;
  }
  if (v33) {
    goto LABEL_36;
  }
LABEL_37:
  if (v30) {
    goto LABEL_38;
  }
  __int16 v41 = scn_default_log();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
    _C3DImageInitWithPropertyList_cold_1();
  }
  return v14;
}

__CFDictionary *_C3DImageCopyPropertyList(void *a1, uint64_t a2, const __CFDictionary *a3)
{
  if (!a1)
  {
    CFAllocatorRef v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = C3DEntityCopyPropertyList(a1, a2, (uint64_t)a3);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a3, @"kCreatePropertyListShouldKeepReferencesToFilesOption");
  if (Value) {
    BOOL v16 = CFBooleanGetValue(Value) != 0;
  }
  else {
    BOOL v16 = 1;
  }
  CFBooleanRef v17 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"kSceneSourceSkipImagePathResolution");
  if (v17)
  {
    BOOL v18 = CFBooleanGetValue(v17) != 0;
    if (v16) {
      goto LABEL_9;
    }
LABEL_13:
    CFDataRef Data = (const void *)C3DImageGetData((uint64_t)a1);
    if (Data)
    {
      uint64_t v22 = Data;
      CFRetain(Data);
    }
    else
    {
      uint64_t URL = C3DImageGetURL((uint64_t)a1);
      if (!URL) {
        return v14;
      }
      uint64_t v22 = (const void *)C3DCreateDataWithContentOfURL(URL, 0);
      if (!v22) {
        return v14;
      }
    }
    CFDictionarySetValue(v14, @"imageData", v22);
    uint64_t v23 = v22;
LABEL_35:
    CFRelease(v23);
    return v14;
  }
  BOOL v18 = 0;
  if (!v16) {
    goto LABEL_13;
  }
LABEL_9:
  uint64_t v19 = CFDictionaryGetValue(a3, @"kC3DIOSerializationExportDelegate");
  uint64_t v20 = (void *)CFDictionaryGetValue(a3, @"SCNSceneExportDestinationURL");
  if (v20)
  {
    if (!v19) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v20 = (void *)CFDictionaryGetValue(a3, @"kEnclosingFolderURL");
    if (!v19) {
      goto LABEL_20;
    }
  }
  uint64_t UpdateQueue = C3DParticleManagerGetUpdateQueue();
  if (UpdateQueue)
  {
    CFStringRef v25 = (CFStringRef)UpdateQueue;
    CFStringRef v26 = @"imageRelativePath";
LABEL_19:
    CFDictionarySetValue(v14, v26, v25);
    return v14;
  }
LABEL_20:
  CFURLRef v27 = (const __CFURL *)C3DImageGetURL((uint64_t)a1);
  if (!v27) {
    return v14;
  }
  CFURLRef v28 = v27;
  CFStringRef v29 = CFURLCopyScheme(v27);
  if (v29)
  {
    CFStringRef v30 = v29;
    HasPrefifloat x = CFStringHasPrefix(v29, @"file");
    CFRelease(v30);
    if (!HasPrefix)
    {
      CFStringRef v25 = CFURLGetString(v28);
      CFStringRef v26 = @"distantImageURL";
      goto LABEL_19;
    }
  }
  if (v20) {
    char v32 = v18;
  }
  else {
    char v32 = 1;
  }
  if ((v32 & 1) == 0)
  {
    CFURLRef v33 = C3DCopyRelativeFromFileURL(v20, v28);
    goto LABEL_34;
  }
  CFURLRef v33 = CFURLCopyFileSystemPath(v28, kCFURLPOSIXPathStyle);
  if (v33)
  {
LABEL_34:
    CFURLRef v36 = v33;
    CFDictionarySetValue(v14, @"imageRelativePath", v33);
    uint64_t v23 = v36;
    goto LABEL_35;
  }
  CFURLRef v34 = scn_default_log();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
    _C3DImageCopyPropertyList_cold_1();
  }
  return v14;
}

uint64_t _C3DImageFinalizeDeserialization()
{
  return 1;
}

__CFArray *_C3DImageCopyInstanceVariables(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  int v3 = *(_DWORD *)(a1 + 96);
  if (v3 == 1)
  {
    int v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v41 = 2;
    int valuePtr = 5;
    CGRect v40 = (char *)(a1 + 88);
    CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v4, @"name", @"url");
    CFDictionarySetValue(v4, @"type", v5);
    CFDictionarySetValue(v4, @"address", v7);
    CFDictionarySetValue(v4, @"semantic", v6);
    CFArrayAppendValue(Mutable, v4);
    CFRelease(v6);
    CFRelease(v4);
    CFRelease(v7);
    CFRelease(v5);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 2)
  {
    uint64_t v8 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v41 = 2;
    int valuePtr = 5;
    CGRect v40 = (char *)(a1 + 88);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v8, @"name", @"data");
    CFDictionarySetValue(v8, @"type", v9);
    CFDictionarySetValue(v8, @"address", v11);
    CFDictionarySetValue(v8, @"semantic", v10);
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v10);
    CFRelease(v8);
    CFRelease(v11);
    CFRelease(v9);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 3)
  {
    uint64_t v12 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v41 = 2;
    int valuePtr = 5;
    CGRect v40 = (char *)(a1 + 88);
    CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v12, @"name", @"cgImage");
    CFDictionarySetValue(v12, @"type", v13);
    CFDictionarySetValue(v12, @"address", v15);
    CFDictionarySetValue(v12, @"semantic", v14);
    CFArrayAppendValue(Mutable, v12);
    CFRelease(v14);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v13);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 4)
  {
    BOOL v16 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int v41 = 2;
    int valuePtr = 5;
    CGRect v40 = (char *)(a1 + 88);
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v16, @"name", @"clientImage");
    CFDictionarySetValue(v16, @"type", v17);
    CFDictionarySetValue(v16, @"address", v19);
    CFDictionarySetValue(v16, @"semantic", v18);
    CFArrayAppendValue(Mutable, v16);
    CFRelease(v18);
    CFRelease(v16);
    CFRelease(v19);
    CFRelease(v17);
  }
  uint64_t v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v41 = 2;
  int valuePtr = 5;
  CGRect v40 = (char *)(a1 + 64);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v22, @"name", @"bitmap");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(Mutable, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  char v39 = *(unsigned char *)(a1 + 116) & 1;
  CFStringRef v26 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 3;
  CGRect v40 = &v39;
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v26, @"name", @"hasAlpha");
  CFDictionarySetValue(v26, @"type", v27);
  CFDictionarySetValue(v26, @"address", v29);
  CFDictionarySetValue(v26, @"semantic", v28);
  CFArrayAppendValue(Mutable, v26);
  CFRelease(v28);
  CFRelease(v26);
  CFRelease(v29);
  CFRelease(v27);
  CFStringRef v30 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 8;
  CGRect v40 = (char *)(a1 + 104);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v30, @"name", @"size");
  CFDictionarySetValue(v30, @"type", v31);
  CFDictionarySetValue(v30, @"address", v33);
  CFDictionarySetValue(v30, @"semantic", v32);
  CFArrayAppendValue(Mutable, v30);
  CFRelease(v32);
  CFRelease(v30);
  CFRelease(v33);
  CFRelease(v31);
  CFURLRef v34 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 2;
  CGRect v40 = (char *)(a1 + 120);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v34, @"name", @"type");
  CFDictionarySetValue(v34, @"type", v35);
  CFDictionarySetValue(v34, @"address", v37);
  CFDictionarySetValue(v34, @"semantic", v36);
  CFArrayAppendValue(Mutable, v34);
  CFRelease(v36);
  CFRelease(v34);
  CFRelease(v37);
  CFRelease(v35);
  return Mutable;
}

float srdnoise3(float *a1, float *a2, float *a3, float a4, float a5, float a6, float a7)
{
  __float2 v13 = __sincosf_stret(a7);
  float v14 = (float)((float)(a4 + a5) + a6) * 0.333333333;
  int v15 = (int)(float)(v14 + a4) - ((float)(v14 + a4) <= 0.0);
  int v16 = (int)(float)(v14 + a5) - ((float)(v14 + a5) <= 0.0);
  int v17 = (int)(float)(v14 + a6) - ((float)(v14 + a6) <= 0.0);
  float v18 = (float)(v15 + v16 + v17) * 0.166666667;
  float v19 = a4 - (float)((float)v15 - v18);
  float v20 = a5 - (float)((float)v16 - v18);
  float v21 = a6 - (float)((float)v17 - v18);
  if (v19 >= v20)
  {
    int v23 = 0;
    if (v20 < v21)
    {
      int v26 = 0;
      BOOL v22 = v19 >= v21;
      BOOL v25 = v19 < v21;
      BOOL v24 = 1;
      goto LABEL_6;
    }
    BOOL v25 = 0;
    BOOL v27 = 0;
    BOOL v22 = 1;
    BOOL v24 = 1;
  }
  else
  {
    BOOL v22 = 0;
    if (v20 < v21)
    {
      int v23 = 0;
      BOOL v24 = 0;
      BOOL v25 = 1;
      int v26 = 1;
LABEL_6:
      BOOL v27 = 1;
      goto LABEL_10;
    }
    BOOL v25 = 0;
    BOOL v24 = v19 >= v21;
    BOOL v27 = v19 < v21;
    int v23 = 1;
  }
  int v26 = 1;
LABEL_10:
  float v28 = (float)(v19 - (float)v22) + 0.166666667;
  float v29 = (float)(v20 - (float)v23) + 0.166666667;
  float v30 = (float)(v21 - (float)v25) + 0.166666667;
  float v31 = (float)((float)(0.6 - (float)(v19 * v19)) - (float)(v20 * v20)) - (float)(v21 * v21);
  float v32 = 0.0;
  float v33 = 0.0;
  float v34 = 0.0;
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
  float v39 = 0.0;
  if (v31 >= 0.0)
  {
    CGRect v40 = (float *)((char *)&grad3u
                  + 12
                  * (perm[perm[perm[v17] + (unint64_t)v16]
                        + (unint64_t)v15] & 0xF));
    int v41 = (float *)((char *)&grad3v
                  + 12
                  * (perm[perm[perm[v17] + (unint64_t)v16]
                        + (unint64_t)v15] & 0xF));
    float v33 = (float)(v13.__sinval * *v41) + (float)(v13.__cosval * *v40);
    float v34 = (float)(v13.__sinval * v41[1]) + (float)(v13.__cosval * v40[1]);
    float v35 = (float)(v13.__sinval * v41[2]) + (float)(v13.__cosval * v40[2]);
    float v37 = v31 * v31;
    float v38 = v37 * v37;
    float v39 = (float)(v37 * v37) * (float)((float)((float)(v20 * v34) + (float)(v33 * v19)) + (float)(v35 * v21));
    float v36 = (float)((float)(0.6 - (float)(v19 * v19)) - (float)(v20 * v20)) - (float)(v21 * v21);
  }
  float v85 = v36;
  float v86 = v37;
  float v88 = v33;
  float v89 = v34;
  float v90 = v35;
  float v95 = v39;
  float v42 = (float)(v19 - (float)v24) + 0.333333334;
  float v43 = (float)(v20 - (float)v26) + 0.333333334;
  float v44 = (float)(v21 - (float)v27) + 0.333333334;
  float v45 = (float)((float)(0.6 - (float)(v28 * v28)) - (float)(v29 * v29)) - (float)(v30 * v30);
  float v46 = 0.0;
  float v47 = 0.0;
  float v48 = 0.0;
  float v49 = 0.0;
  float v50 = 0.0;
  float v51 = 0.0;
  if (v45 >= 0.0)
  {
    uint64_t v52 = 3
        * (perm[v22
              + v15
              + (unint64_t)perm[v23
                                     + v16
                                     + (unint64_t)perm[v25 + (unint64_t)v17]]] & 0xF);
    int v53 = (float *)((char *)&grad3u + 4 * v52);
    float v54 = (float *)((char *)&grad3v + 4 * v52);
    float v32 = (float)(v13.__sinval * *v54) + (float)(v13.__cosval * *v53);
    float v46 = (float)(v13.__sinval * v54[1]) + (float)(v13.__cosval * v53[1]);
    float v47 = (float)(v13.__sinval * v54[2]) + (float)(v13.__cosval * v53[2]);
    float v49 = v45 * v45;
    float v50 = v49 * v49;
    float v51 = (float)(v49 * v49) * (float)((float)((float)(v46 * v29) + (float)(v32 * v28)) + (float)(v47 * v30));
    float v48 = (float)((float)(0.6 - (float)(v28 * v28)) - (float)(v29 * v29)) - (float)(v30 * v30);
  }
  float v93 = (float)(v19 - (float)v22) + 0.166666667;
  float v94 = v51;
  float v87 = v32;
  float v91 = v30;
  float v92 = v29;
  float v55 = (float)(v19 + -1.0) + 0.500000001;
  float v56 = (float)(v20 + -1.0) + 0.500000001;
  float v57 = (float)(v21 + -1.0) + 0.500000001;
  float v58 = (float)((float)(0.6 - (float)(v42 * v42)) - (float)(v43 * v43)) - (float)(v44 * v44);
  float v59 = 0.0;
  float v60 = 0.0;
  float v61 = 0.0;
  float v62 = 0.0;
  float v63 = 0.0;
  float v64 = 0.0;
  float v65 = 0.0;
  float v66 = 0.0;
  if (v58 >= 0.0)
  {
    uint64_t v67 = 3
        * (perm[v24
              + v15
              + (unint64_t)perm[v26
                                     + v16
                                     + (unint64_t)perm[v27 + (unint64_t)v17]]] & 0xF);
    float v68 = (float *)((char *)&grad3u + 4 * v67);
    int v69 = (float *)((char *)&grad3v + 4 * v67);
    float v60 = (float)(v13.__sinval * *v69) + (float)(v13.__cosval * *v68);
    float v61 = (float)(v13.__sinval * v69[1]) + (float)(v13.__cosval * v68[1]);
    float v62 = (float)(v13.__sinval * v69[2]) + (float)(v13.__cosval * v68[2]);
    float v64 = v58 * v58;
    float v65 = v64 * v64;
    float v66 = (float)(v64 * v64) * (float)((float)((float)(v61 * v43) + (float)(v60 * v42)) + (float)(v62 * v44));
    float v63 = (float)((float)(0.6 - (float)(v42 * v42)) - (float)(v43 * v43)) - (float)(v44 * v44);
  }
  float v70 = (float)((float)(0.6 - (float)(v55 * v55)) - (float)(v56 * v56)) - (float)(v57 * v57);
  float v71 = 0.0;
  float v72 = 0.0;
  float v73 = 0.0;
  float v74 = 0.0;
  float v75 = 0.0;
  float v76 = 0.0;
  if (v70 >= 0.0)
  {
    uint64_t v77 = perm[v17 + 1];
    uint64_t v78 = (float *)((char *)&grad3u
                  + 12
                  * (perm[v15
                        + 1
                        + (unint64_t)perm[v16 + 1 + v77]] & 0xF));
    double v79 = (float *)((char *)&grad3v
                  + 12
                  * (perm[v15
                        + 1
                        + (unint64_t)perm[v16 + 1 + v77]] & 0xF));
    float v59 = (float)(v13.__sinval * *v79) + (float)(v13.__cosval * *v78);
    float v71 = (float)(v13.__sinval * v79[1]) + (float)(v13.__cosval * v78[1]);
    float v72 = (float)(v13.__sinval * v79[2]) + (float)(v13.__cosval * v78[2]);
    float v74 = v70 * v70;
    float v75 = v74 * v74;
    float v76 = (float)(v74 * v74) * (float)((float)((float)(v71 * v56) + (float)(v59 * v55)) + (float)(v72 * v57));
    float v73 = (float)((float)(0.6 - (float)(v55 * v55)) - (float)(v56 * v56)) - (float)(v57 * v57);
  }
  if (a1 && a2 && a3)
  {
    float v80 = (float)((float)((float)(v20 * v89) + (float)(v88 * v19)) + (float)(v90 * v21)) * (float)(v85 * v86);
    *a1 = v19 * v80;
    *a2 = v20 * v80;
    *a3 = v21 * v80;
    float v81 = (float)((float)((float)(v46 * v92) + (float)(v87 * v93)) + (float)(v47 * v91)) * (float)(v48 * v49);
    *a1 = *a1 + (float)(v81 * v93);
    *a2 = *a2 + (float)(v81 * v92);
    *a3 = *a3 + (float)(v81 * v91);
    float v82 = (float)((float)((float)(v61 * v43) + (float)(v60 * v42)) + (float)(v62 * v44)) * (float)(v63 * v64);
    *a1 = *a1 + (float)(v82 * v42);
    *a2 = *a2 + (float)(v82 * v43);
    *a3 = *a3 + (float)(v82 * v44);
    float v83 = (float)((float)((float)(v71 * v56) + (float)(v59 * v55)) + (float)(v72 * v57)) * (float)(v73 * v74);
    *a1 = *a1 + (float)(v83 * v55);
    *a2 = *a2 + (float)(v83 * v56);
    *a3 = *a3 + (float)(v83 * v57);
    *a1 = *a1 * -8.0;
    *a2 = *a2 * -8.0;
    *a3 = *a3 * -8.0;
    *a1 = (float)((float)((float)((float)(v87 * v50) + (float)(v38 * v88)) + (float)(v65 * v60)) + (float)(v75 * v59))
        + *a1;
    *a2 = (float)((float)((float)((float)(v46 * v50) + (float)(v38 * v89)) + (float)(v65 * v61)) + (float)(v75 * v71))
        + *a2;
    *a3 = (float)((float)((float)((float)(v47 * v50) + (float)(v38 * v90)) + (float)(v65 * v62)) + (float)(v75 * v72))
        + *a3;
    *a1 = *a1 * 28.0;
    *a2 = *a2 * 28.0;
    *a3 = *a3 * 28.0;
  }
  return (float)((float)((float)(v95 + v94) + v66) + v76) * 28.0;
}

id _fillViewsFromCubeMap(void *a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = 0; i != 6; ++i)
  {
    id result = (id)objc_msgSend(a1, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(a1, "pixelFormat"), 2, a2, 1, i, 1);
    *(void *)(a3 + 8 * i) = result;
  }
  return result;
}

uint64_t replaceSlice(void *a1, void *a2, unsigned int a3, unsigned int a4, const __CFData *a5, uint64_t a6)
{
  uint64_t v12 = [a2 width];
  uint64_t v13 = [a2 height];
  uint64_t v14 = [a1 pixelFormat];
  Bitdouble Size = SCNMTLPixelFormatGetBitSize();
  if ((v14 & 0xFFFFFFFFFFFFFFF8) == 0xA0) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = (BitSize >> 3) * v12;
  }
  if (a4)
  {
    uint64_t v17 = a4;
    do
    {
      if (v12 >> 1 <= 1) {
        uint64_t v12 = 1;
      }
      else {
        v12 >>= 1;
      }
      if (v13 >> 1 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        v13 >>= 1;
      }
      if ((v14 & 0xFFFFFFFFFFFFFFF8) != 0xA0)
      {
        if (a6 && *(unsigned char *)(a6 + 7)) {
          unint64_t v16 = ((v12 + (unint64_t)*(unsigned __int8 *)(a6 + 7) - 1)
        }
               / *(unsigned __int8 *)(a6 + 7)
               * *(unsigned __int8 *)(a6 + 4)) >> 3;
        else {
          unint64_t v16 = v12 * (BitSize >> 3);
        }
      }
      --v17;
    }
    while (v17);
  }
  memset(v19, 0, 24);
  v19[3] = v12;
  v19[4] = v13;
  v19[5] = 1;
  return [a1 replaceRegion:v19 mipmapLevel:a4 slice:a3 withBytes:CFDataGetBytePtr(a5) bytesPerRow:v16 bytesPerImage:0];
}

unint64_t replaceRegion(void *a1, void *a2, unsigned int a3, CFArrayRef theArray, uint64_t a5)
{
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v11 = [a2 width];
  uint64_t v12 = [a2 height];
  uint64_t v13 = [a1 pixelFormat];
  unint64_t result = SCNMTLPixelFormatGetBitSize();
  if (Count >= 1)
  {
    CFIndex v15 = 0;
    unint64_t v20 = result >> 3;
    unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      ValueAtuint64_t Index = (const __CFData *)CFArrayGetValueAtIndex(theArray, v15);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      if (v16 == 160)
      {
        unint64_t v19 = 0;
      }
      else if (a5 && *(unsigned char *)(a5 + 7))
      {
        unint64_t v19 = ((v11 + *(unsigned __int8 *)(a5 + 7) - 1)
             / *(unsigned __int8 *)(a5 + 7)
             * (unint64_t)*(unsigned __int8 *)(a5 + 4)) >> 3;
      }
      else
      {
        unint64_t v19 = v11 * v20;
      }
      memset(v21, 0, 24);
      v21[3] = v11;
      v21[4] = v12;
      v21[5] = 1;
      unint64_t result = [a1 replaceRegion:v21 mipmapLevel:v15 slice:a3 withBytes:BytePtr bytesPerRow:v19 bytesPerImage:0];
      if (v11 >> 1 <= 1) {
        uint64_t v11 = 1;
      }
      else {
        v11 >>= 1;
      }
      if (v12 >> 1 <= 1) {
        uint64_t v12 = 1;
      }
      else {
        v12 >>= 1;
      }
      ++v15;
    }
    while (Count != v15);
  }
  return result;
}

void SCNMTLBlitCommandEncoder::copyTextureToTexture(void **a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v10 = [a2 width];
  uint64_t v26 = [a2 height];
  uint64_t v11 = [a2 depth];
  uint64_t v12 = [a2 arrayLength];
  if ((unint64_t)([a2 textureType] - 5) >= 2) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 6 * v12;
  }
  uint64_t v14 = [a4 arrayLength];
  if ((unint64_t)([a4 textureType] - 5) >= 2) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 6 * v14;
  }
  if (v13 != v15)
  {
    unint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::copyTextureToTexture(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  if (v13)
  {
    for (uint64_t i = 0; i != v13; ++i)
    {
      BOOL v25 = *a1;
      v28[2] = v11;
      memset(v29, 0, sizeof(v29));
      v28[0] = v10;
      v28[1] = v26;
      memset(v27, 0, sizeof(v27));
      [v25 copyFromTexture:a2 sourceSlice:i sourceLevel:a3 sourceOrigin:v29 sourceSize:v28 toTexture:a4 destinationSlice:i destinationLevel:a5 destinationOrigin:v27];
    }
  }
}

void SCNMTLBlitCommandEncoder::copyTextureToTexture(void **a1, void *a2, void *a3)
{
  uint64_t v6 = [a2 width];
  if (v6 != [a3 width])
  {
    CFNumberRef v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::copyTextureToTexture(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = [a2 height];
  if (v15 != [a3 height])
  {
    unint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::copyTextureToTexture(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  uint64_t v24 = [a2 depth];
  if (v24 != [a3 depth])
  {
    BOOL v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::copyTextureToTexture(v25, v26, v27, v28, v29, v30, v31, v32);
    }
  }
  float v57 = a1;
  BOOL IsCube = SCNMTLTextureTypeIsCube([a2 textureType]);
  unint64_t v34 = [a2 mipmapLevelCount];
  unint64_t v35 = [a3 mipmapLevelCount];
  if (v34 >= v35) {
    unint64_t v36 = v35;
  }
  else {
    unint64_t v36 = v34;
  }
  uint64_t v37 = [a2 arrayLength];
  if ((unint64_t)([a2 textureType] - 5) >= 2) {
    uint64_t v38 = v37;
  }
  else {
    uint64_t v38 = 6 * v37;
  }
  uint64_t v39 = [a3 arrayLength];
  if ((unint64_t)([a3 textureType] - 5) >= 2) {
    uint64_t v40 = v39;
  }
  else {
    uint64_t v40 = 6 * v39;
  }
  if (v38 != v40)
  {
    int v41 = scn_default_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
      SCNMTLBlitCommandEncoder::copyTextureToTexture(v41, v42, v43, v44, v45, v46, v47, v48);
    }
  }
  if (v38)
  {
    uint64_t v49 = 0;
    char v50 = IsCube;
    do
    {
      unint64_t v51 = [a2 width];
      unint64_t v52 = [a2 height];
      uint64_t v53 = [a2 depth];
      if (v36)
      {
        unint64_t v54 = v53;
        for (uint64_t i = 0; i != v36; ++i)
        {
          float v56 = *v57;
          v59[2] = v54;
          memset(v60, 0, sizeof(v60));
          v59[0] = v51;
          v59[1] = v52;
          memset(v58, 0, sizeof(v58));
          [v56 copyFromTexture:a2 sourceSlice:v49 sourceLevel:i sourceOrigin:v60 sourceSize:v59 toTexture:a3 destinationSlice:v49 destinationLevel:i destinationOrigin:v58];
          v51 >>= 1;
          v52 >>= 1;
          v54 >>= v50;
        }
      }
      ++v49;
    }
    while (v49 != v38);
  }
}

void OUTLINED_FUNCTION_1_5(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_20B33FCAC(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C403A34AA84);
  _Unwind_Resume(a1);
}

void sub_20B33FD8C(_Unwind_Exception *a1)
{
  MEMORY[0x210534FE0](v1, 0x10E1C403A34AA84);
  _Unwind_Resume(a1);
}

void SCNCActionWait::SCNCActionWait(SCNCActionWait *this, SCNCAction *a2)
{
  SCNCAction::SCNCAction((SCNCAction *)this);
  *(void *)uint64_t v3 = &unk_26BF69AD0;
  *(void *)(v3 + 24) = a2->var3;
  *(double *)(v3 + 56) = a2->var7;
  *(_OWORD *)(v3 + 40) = *(_OWORD *)&a2->var5;
  *(_WORD *)(v3 + 80) = *(_WORD *)&a2->var10;
  *(double *)(v3 + 64) = a2->var8;
  *(void *)(v3 + 104) = a2->var14;
  *(unsigned char *)(v3 + 32) = 1;
}

void SCNCActionWait::~SCNCActionWait(SCNCActionWait *this)
{
  SCNCAction::~SCNCAction((SCNCAction *)this);

  JUMPOUT(0x210534FE0);
}

uint64_t _C3DTextureSamplerFinalizeDeserialization()
{
  return 1;
}

_DWORD *C3DTextureSamplerCreateWithPropertyList(const __CFDictionary *a1)
{
  unsigned int v2 = (_DWORD *)C3DTextureSamplerCreate();
  CFBooleanRef Value = CFDictionaryGetValue(a1, @"minificationFilter");
  if (Value) {
    int v4 = _filterFromString(Value);
  }
  else {
    int v4 = 1;
  }
  v2[7] = v4;
  CFNumberRef v5 = CFDictionaryGetValue(a1, @"magnificationFilter");
  if (v5) {
    int v6 = _filterFromString(v5);
  }
  else {
    int v6 = 1;
  }
  v2[8] = v6;
  CFNumberRef v7 = CFDictionaryGetValue(a1, @"mipFilter");
  if (v7) {
    LODWORD(v7) = _filterFromString(v7);
  }
  v2[8] = v7;
  uint64_t v8 = CFDictionaryGetValue(a1, @"wrapS");
  if (v8) {
    int v9 = _wrapModeFromString(v8);
  }
  else {
    int v9 = 1;
  }
  v2[4] = v9;
  uint64_t v10 = CFDictionaryGetValue(a1, @"wrapT");
  if (v10) {
    int v11 = _wrapModeFromString(v10);
  }
  else {
    int v11 = 1;
  }
  v2[5] = v11;
  uint64_t v12 = CFDictionaryGetValue(a1, @"wrapP");
  if (v12) {
    int v13 = _wrapModeFromString(v12);
  }
  else {
    int v13 = 1;
  }
  v2[6] = v13;
  uint64_t v14 = (const char *)CFDictionaryGetValue(a1, @"borderColor");
  if (v14)
  {
    CString = SCNStringGetCString(v14);
    if (CString) {
      sscanf(CString, "%f %f %f %f", v2 + 12, v2 + 13, v2 + 14, v2 + 15);
    }
  }
  CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(a1, @"maxAnisotropy");
  if (v16)
  {
    float valuePtr = 0.0;
    CFNumberGetValue(v16, kCFNumberFloatType, &valuePtr);
    C3DTextureSamplerSetAnisotropy((uint64_t)v2, valuePtr);
  }
  return v2;
}

uint64_t _filterFromString(const void *a1)
{
  if (CFEqual(a1, @"linear")) {
    return 2;
  }
  else {
    return CFEqual(a1, @"nearest") != 0;
  }
}

uint64_t _wrapModeFromString(const void *a1)
{
  if (CFEqual(a1, @"clamp")) {
    return 1;
  }
  if (CFEqual(a1, @"repeat")) {
    return 2;
  }
  if (CFEqual(a1, @"clampToBorder")) {
    return 3;
  }
  return 4;
}

int8x8_t C3DTextureSamplerSetAnisotropy(uint64_t a1, float a2)
{
  if (!a1)
  {
    int v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 64) = a2;
  if (a2 <= 128.0) {
    unsigned int v12 = ((a2 * 65536.0 * 0.0078125) << 19) | 1;
  }
  else {
    unsigned int v12 = 1;
  }
  int8x16_t v13 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(a1 + 16), (uint32x4_t)xmmword_20B5CCF20);
  int8x8_t result = vorr_s8(*(int8x8_t *)v13.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  *(void *)(a1 + 80) = result.i32[0] | result.i32[1] | (*(_DWORD *)(a1 + 32) << 12) | (*(_DWORD *)(a1 + 36) << 14) | (*(unsigned __int8 *)(a1 + 68) << 16) | v12;
  return result;
}

uint64_t C3DTextureSamplerCreateWithOptions(int a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12 = C3DTextureSamplerCreate();
  *(_DWORD *)(v12 + 16) = a4;
  *(_DWORD *)(v12 + 20) = a5;
  *(_DWORD *)(v12 + 24) = a6;
  *(_DWORD *)(v12 + 2_Block_object_dispose(&STACK[0x2A0], 8) = a1;
  *(_DWORD *)(v12 + 32) = a2;
  *(_DWORD *)(v12 + 36) = a3;
  C3DColor4Make((float *)(v12 + 48), 0.0, 0.0, 0.0, 1.0);
  float v13 = *(float *)(v12 + 64);
  unsigned int v14 = 1;
  if (v13 <= 128.0) {
    unsigned int v14 = ((v13 * 65536.0 * 0.0078125) << 19) | 1;
  }
  int8x16_t v15 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(v12 + 16), (uint32x4_t)xmmword_20B5CCF20);
  *(int8x8_t *)v15.i8 = vorr_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
  *(void *)(v12 + 80) = v15.i32[0] | v15.i32[1] | (*(_DWORD *)(v12 + 32) << 12) | (*(_DWORD *)(v12 + 36) << 14) | (*(unsigned __int8 *)(v12 + 68) << 16) | v14;
  return v12;
}

uint64_t C3DTextureSamplerGetComparisonFunc(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 68);
}

BOOL C3DTextureSamplerUseMipmaps(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(_DWORD *)(a1 + 36) != 0;
}

uint64_t C3DTextureSamplerGetDefault()
{
  if (C3DTextureSamplerGetDefault_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerGetDefault_onceToken, &__block_literal_global_27);
  }
  return C3DTextureSamplerGetDefault_states;
}

uint64_t __C3DTextureSamplerGetDefault_block_invoke()
{
  uint64_t result = C3DTextureSamplerCreate();
  C3DTextureSamplerGetDefault_states = result;
  return result;
}

uint64_t C3DTextureSamplerNearest()
{
  if (C3DTextureSamplerNearest_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerNearest_onceToken, &__block_literal_global_30);
  }
  return C3DTextureSamplerNearest_states;
}

double __C3DTextureSamplerNearest_block_invoke()
{
  uint64_t v0 = C3DTextureSamplerCreate();
  C3DTextureSamplerNearest_states = v0;
  *(void *)&double result = 0x100000001;
  *(void *)(v0 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 0x100000001;
  *(_DWORD *)(v0 + 36) = 0;
  *(_DWORD *)(v0 + 72) = 2;
  *(_DWORD *)(v0 + 64) = 1065353216;
  *(void *)(v0 + 80) = (2 * *(_DWORD *)(v0 + 16)) | (16 * *(_DWORD *)(v0 + 20)) | (*(_DWORD *)(v0 + 24) << 7) | (*(unsigned __int8 *)(v0 + 68) << 16) | 0x10001401u;
  return result;
}

uint64_t C3DTextureSamplerBilinearNoAnisotropy()
{
  if (C3DTextureSamplerBilinearNoAnisotropy_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerBilinearNoAnisotropy_onceToken, &__block_literal_global_33_0);
  }
  return C3DTextureSamplerBilinearNoAnisotropy_states;
}

uint64_t __C3DTextureSamplerBilinearNoAnisotropy_block_invoke()
{
  uint64_t result = C3DTextureSamplerCreate();
  C3DTextureSamplerBilinearNoAnisotropy_states = result;
  *(_DWORD *)(result + 72) = 2;
  *(_DWORD *)(result + 64) = 1065353216;
  *(void *)(result + 80) = (2 * *(_DWORD *)(result + 16)) | (16 * *(_DWORD *)(result + 20)) | (*(_DWORD *)(result + 24) << 7) | (*(_DWORD *)(result + 28) << 10) | (*(_DWORD *)(result + 32) << 12) | (*(_DWORD *)(result + 36) << 14) | (*(unsigned __int8 *)(result + 68) << 16) | 0x10000001u;
  return result;
}

uint64_t C3DTextureSamplerTrilinearRepeatNoAnisotropy()
{
  if (C3DTextureSamplerTrilinearRepeatNoAnisotropy_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerTrilinearRepeatNoAnisotropy_onceToken, &__block_literal_global_36);
  }
  return C3DTextureSamplerTrilinearRepeatNoAnisotropy_states;
}

uint64_t C3DTextureSamplerDepthCompare()
{
  if (C3DTextureSamplerDepthCompare_onceToken != -1) {
    dispatch_once(&C3DTextureSamplerDepthCompare_onceToken, &__block_literal_global_45);
  }
  return C3DTextureSamplerDepthCompare_states;
}

double __C3DTextureSamplerDepthCompare_block_invoke()
{
  uint64_t v0 = C3DTextureSamplerCreate();
  C3DTextureSamplerDepthCompare_states = v0;
  *(void *)(v0 + 32) = 2;
  *(void *)&double result = 0x100000001;
  *(_OWORD *)(v0 + 16) = xmmword_20B5CCF10;
  *(unsigned char *)(v0 + 6_Block_object_dispose(&STACK[0x2A0], 8) = 7;
  *(_DWORD *)(v0 + 72) = 2;
  *(_DWORD *)(v0 + 64) = 1065353216;
  *(void *)(v0 + 80) = 268904595;
  return result;
}

BOOL _C3DTextureSamplerCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _C3DTextureSamplerCFHash(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

CFStringRef _C3DTextureSamplerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTextureSampler>");
}

CFStringRef _C3DTextureSamplerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTextureSampler>");
}

uint64_t _C3DTextureSamplerInitWithPropertyList(uint64_t a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  IsDictionarfloat y = C3DCFTypeIsDictionary();
  if (IsDictionary)
  {
    if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
    {
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      if (a2) {
        goto LABEL_7;
      }
    }
    else if (a2)
    {
      goto LABEL_7;
    }
    CFNumberRef v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
    }
LABEL_7:
    *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = __DeserializeInt(a2, @"minFilter", a4);
    *(_DWORD *)(a1 + 32) = __DeserializeInt(a2, @"magFilter", a4);
    *(_DWORD *)(a1 + 36) = __DeserializeInt(a2, @"mipFilter", a4);
    *(_DWORD *)(a1 + 16) = __DeserializeInt(a2, @"wrapS", a4);
    *(_DWORD *)(a1 + 20) = __DeserializeInt(a2, @"wrapT", a4);
    float valuePtr = 1.0;
    if (!a2 && (uint64_t v24 = scn_default_log(), os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)))
    {
      _C3DTextureSamplerInitWithPropertyList_cold_2(v24, v25, v26, v27, v28, v29, v30, v31);
      if (!@"anisotropy")
      {
LABEL_10:
        uint64_t v32 = scn_default_log();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
          _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v32, v33, v34, v35, v36, v37, v38, v39);
        }
      }
    }
    else if (!@"anisotropy")
    {
      goto LABEL_10;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"anisotropy");
    if (Value)
    {
      int v41 = CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
      if (a4)
      {
        if (!v41 && !*a4) {
          *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
        }
      }
    }
    float v42 = valuePtr;
    if (valuePtr == 3.4028e38) {
      float v42 = 1.0;
    }
    *(float *)(a1 + 64) = v42;
    unsigned int v43 = 1;
    if (v42 <= 128.0) {
      unsigned int v43 = ((v42 * 65536.0 * 0.0078125) << 19) | 1;
    }
    int8x16_t v44 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(a1 + 16), (uint32x4_t)xmmword_20B5CCF20);
    *(int8x8_t *)v44.i8 = vorr_s8(*(int8x8_t *)v44.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL));
    *(void *)(a1 + 80) = v44.i32[0] | v44.i32[1] | (*(_DWORD *)(a1 + 32) << 12) | (*(_DWORD *)(a1 + 36) << 14) | (*(unsigned __int8 *)(a1 + 68) << 16) | v43;
    return IsDictionary;
  }
  uint64_t v45 = scn_default_log();
  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
    _C3DTextureSamplerInitWithPropertyList_cold_5(v45);
  }
  return IsDictionary;
}

CFMutableDictionaryRef _C3DTextureSamplerCopyPropertyList(int *cf)
{
  if (!cf)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFAllocatorRef v10 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v12 = __SerializeInt(Mutable, @"minFilter", cf[7]);
  int v13 = __SerializeInt(Mutable, @"magFilter", cf[8]) & v12;
  int v14 = __SerializeInt(Mutable, @"mipFilter", cf[9]);
  int v15 = v14 & __SerializeInt(Mutable, @"wrapS", cf[4]);
  int v16 = __SerializeInt(Mutable, @"wrapT", cf[5]);
  int valuePtr = cf[16];
  if (!Mutable)
  {
    uint64_t v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      _C3DTextureSamplerInitWithPropertyList_cold_2(v17, v18, v19, v20, v21, v22, v23, v24);
    }
  }
  int v25 = v13 & v15;
  if (!@"anisotropy")
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v26, v27, v28, v29, v30, v31, v32, v33);
    }
  }
  int v34 = v25 & v16;
  CFAllocatorRef v35 = CFGetAllocator(Mutable);
  CFNumberRef v36 = CFNumberCreate(v35, kCFNumberFloatType, &valuePtr);
  if (v36)
  {
    CFNumberRef v37 = v36;
    CFDictionarySetValue(Mutable, @"anisotropy", v36);
    CFRelease(v37);
    int v38 = 1;
  }
  else
  {
    int v38 = 0;
  }
  if ((v34 & v38) == 0)
  {
    uint64_t v39 = scn_default_log();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      _C3DTextureSamplerCopyPropertyList_cold_1(v39);
    }
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t __DeserializeInt(CFDictionaryRef theDict, void *key, CFErrorRef *a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  unsigned int valuePtr = 2;
  if (!theDict && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  int v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value && !CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
  {
    uint64_t v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 138412802;
      uint64_t v27 = key;
      __int16 v28 = 2112;
      CFDictionaryRef v29 = theDict;
      __int16 v30 = 1024;
      int v31 = 2;
      _os_log_impl(&dword_20B249000, v24, OS_LOG_TYPE_DEFAULT, "Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead", buf, 0x1Cu);
    }
    if (a3 && !*a3) {
      *a3 = C3DSceneSourceCreateMalformedDocumentError(0);
    }
  }
  return valuePtr;
}

uint64_t __SerializeInt(void *cf, const void *a2, int a3)
{
  int valuePtr = a3;
  if (!cf && (uint64_t v5 = scn_default_log(), os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)))
  {
    _C3DTextureSamplerInitWithPropertyList_cold_2(v5, v6, v7, v8, v9, v10, v11, v12);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v13 = scn_default_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
LABEL_6:
  CFAllocatorRef v21 = CFGetAllocator(cf);
  uint64_t result = (uint64_t)CFNumberCreate(v21, kCFNumberIntType, &valuePtr);
  if (result)
  {
    uint64_t v23 = (const void *)result;
    CFDictionarySetValue((CFMutableDictionaryRef)cf, a2, (const void *)result);
    CFRelease(v23);
    return 1;
  }
  return result;
}

__CFArray *_C3DTextureSamplerCopyInstanceVariables(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 16;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v5, @"name", @"wrapS");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 20;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v9, @"name", @"wrapT");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 24;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v13, @"name", @"wrapP");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 28;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v17, @"name", @"minFilter");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  CFAllocatorRef v21 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 32;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v21, @"name", @"magFilter");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  int v25 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 2;
  uint64_t v38 = a1 + 36;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v25, @"name", @"mipFilter");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  CFDictionaryRef v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 13;
  uint64_t v38 = a1 + 48;
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v29, @"name", @"borderColor");
  CFDictionarySetValue(v29, @"type", v30);
  CFDictionarySetValue(v29, @"address", v32);
  CFDictionarySetValue(v29, @"semantic", v31);
  CFArrayAppendValue(Mutable, v29);
  CFRelease(v31);
  CFRelease(v29);
  CFRelease(v32);
  CFRelease(v30);
  uint64_t v33 = CFDictionaryCreateMutable(0, 4, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v39 = 0;
  int valuePtr = 1;
  uint64_t v38 = a1 + 64;
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &v39);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberLongType, &v38);
  CFDictionarySetValue(v33, @"name", @"anisotropy");
  CFDictionarySetValue(v33, @"type", v34);
  CFDictionarySetValue(v33, @"address", v36);
  CFDictionarySetValue(v33, @"semantic", v35);
  CFArrayAppendValue(Mutable, v33);
  CFRelease(v35);
  CFRelease(v33);
  CFRelease(v36);
  CFRelease(v34);
  return Mutable;
}

uint64_t C3DBezierCurveGeometryCreatePositionSourceForDeformerStack(uint64_t a1)
{
  return C3DBezierCurveCreateControlPointsPositionSource(*(void *)(a1 + 224));
}

uint64_t C3DBezierCurveGeometryGetMeshElementCountForDeformerBasedDynamicMesh()
{
  return 1;
}

uint64_t C3DBezierCurveGeometryCreate()
{
  if (C3DBezierCurveGeometryGetTypeID_onceToken != -1) {
    dispatch_once(&C3DBezierCurveGeometryGetTypeID_onceToken, &__block_literal_global_30);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DBezierCurveGeometryGetTypeID_typeID, 0x120uLL);
  double v1 = C3DGeometryInit(Instance);
  *(void *)(Instance + 12_Block_object_dispose(&STACK[0x2A0], 8) = &kC3DBezierCurveGeometryMeshlessGeometryCallBacks;
  Default = (void *)C3DMaterialCreateDefault(v1);
  C3DGeometryAppendMaterial(Instance, Default);
  CFRelease(Default);
  uint64_t v3 = MEMORY[0x263EF89A8];
  long long v4 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
  *(_OWORD *)(Instance + 240) = *MEMORY[0x263EF89A8];
  *(_OWORD *)(Instance + 256) = v4;
  long long v5 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(Instance + 272) = *(_OWORD *)(v3 + 32);
  *(_OWORD *)(Instance + 28_Block_object_dispose(&STACK[0x2A0], 8) = v5;
  return Instance;
}

void C3DBezierCurveGeometryFinalize(uint64_t a1)
{
  unsigned int v2 = *(const void **)(a1 + 216);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 216) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 224);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 224) = 0;
  }
}

void C3DBezierCurveGeometrySetPath(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 216) = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *(void *)(a1 + 216) = v5;
    CFNumberRef v6 = C3DBezierCurveCreateWithCGPath((const CGPath *)cf);
    CFNumberRef v7 = *(float32x2_t **)(a1 + 224);
    if (v7 != v6)
    {
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1 + 224) = 0;
      }
      if (v6) {
        CFTypeRef v8 = CFRetain(v6);
      }
      else {
        CFTypeRef v8 = 0;
      }
      *(void *)(a1 + 224) = v8;
    }
    CFRelease(v6);
  }
}

__n128 C3DBezierCurveGeometryGetTransform(__n128 *a1)
{
  return a1[15];
}

__n128 *C3DBezierCurveGeometrySetTransform(__n128 *result, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  result[15] = a2;
  result[16] = a3;
  result[17] = a4;
  result[18] = a5;
  return result;
}

uint64_t C3DBezierCurveGeometryGetBezierCurve(uint64_t a1)
{
  return *(void *)(a1 + 224);
}

id _C3DBezierCurveGeometryCFFinalize(__C3DGeometry *a1)
{
  C3DBezierCurveGeometryFinalize((uint64_t)a1);

  return _C3DGeometryCFFinalize(a1);
}

void *_C3DBezierCurveGeometrySetValue(int a1, void *__dst, void *__src, size_t __n)
{
  return memcpy(__dst, __src, __n);
}

uint64_t _C3DBezierCurveGeometryGetBoundingBox(float32x4_t *a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x2_t v24 = 0;
  float32x2_t v25 = 0;
  C3DBezierCurveGetBoundingBox(a1[14].i64[0], &v25, (double *)&v24);
  float32x4_t v7 = a1[15];
  float32x4_t v8 = a1[16];
  float32x4_t v9 = a1[17];
  float32x4_t v10 = a1[18];
  float32x4_t v11 = vmulq_lane_f32(v8, v25, 1);
  float32x4_t v12 = vmlaq_f32(vmlaq_n_f32(v11, v7, v25.f32[0]), (float32x4_t)0, v9);
  float32x4_t v13 = vmulq_lane_f32(v8, v24, 1);
  float32x4_t v14 = vmlaq_f32(vmlaq_n_f32(v13, v7, v25.f32[0]), (float32x4_t)0, v9);
  float32x4_t v15 = vaddq_f32(v10, vmlaq_f32(vmlaq_n_f32(v11, v7, v24.f32[0]), (float32x4_t)0, v9));
  float32x4_t v16 = vaddq_f32(v10, vmlaq_f32(vmlaq_n_f32(v13, v7, v24.f32[0]), (float32x4_t)0, v9));
  v15.i32[3] = 0;
  v16.i32[3] = 0;
  float32x4_t v17 = vaddq_f32(v10, v14);
  float32x4_t v18 = vminnmq_f32(v15, v16);
  v17.i32[3] = 0;
  v18.i32[3] = 0;
  float32x4_t v19 = vaddq_f32(v10, v12);
  float32x4_t v20 = vminnmq_f32(v17, v18);
  v19.i32[3] = 0;
  v20.i32[3] = 0;
  float32x4_t v21 = vmaxnmq_f32(v15, v16);
  v21.i32[3] = 0;
  float32x4_t v22 = vmaxnmq_f32(v17, v21);
  v22.i32[3] = 0;
  *a3 = vminnmq_f32(v19, v20);
  *a4 = vmaxnmq_f32(v19, v22);
  return 1;
}

uint64_t _C3DBezierCurveGeometryGetBoundingSphere(float32x4_t *a1, uint64_t a2, _OWORD *a3)
{
  v11.i32[2] = 0;
  v11.i64[0] = 0;
  v10.i32[2] = 0;
  v10.i64[0] = 0;
  _C3DBezierCurveGeometryGetBoundingBox(a1, 0, &v11, &v10);
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v11, v4, vsubq_f32(v10, v11));
  float32x4_t v6 = vsubq_f32(v5, v11);
  float32x4_t v7 = vmulq_f32(v6, v6);
  float32x4_t v9 = v5;
  C3DSphereMake(a3, (long long *)&v9, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]));
  return 1;
}

uint64_t _C3DBezierCurveGeometryCreateCopy(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DBezierCurveGeometryCreateCopy_cold_1(v2);
    }
  }
  uint64_t v3 = C3DBezierCurveGeometryCreate();
  C3DGeometryCopy(a1, v3);
  C3DBezierCurveGeometrySetPath(v3, *(CFTypeRef *)(a1 + 216));
  return v3;
}

C3D::DrawNodesPass *C3D::FloorPass::FloorPass(C3D::FloorPass *this, RenderGraph *a2, C3D::Pass *a3, __C3DNode *a4, char a5, const Parameters *a6, const Parameters *a7)
{
  uint64_t result = C3D::ScenePass::ScenePass(this, a2, a3, a6, a7);
  *(void *)uint64_t result = &unk_26BF6E950;
  *((void *)result + 681) = a4;
  *((unsigned char *)result + 5456) = a5;
  return result;
}

const char *C3D::FloorPass::name(C3D::FloorPass *this)
{
  return "FloorPass";
}

C3D::Pass *C3D::FloorPass::setup(C3D::FloorPass *this)
{
  unsigned int v2 = (char *)this + 4949;
  uint64_t Floor = C3DNodeGetFloor(*((void *)this + 681));
  if (!Floor)
  {
    float32x4_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3D::FloorPass::setup(v4);
    }
  }
  *((unsigned char *)this + 112) = 1;
  *((unsigned char *)this + 296) = 1;
  *((unsigned char *)this + 303) = 0;
  *((void *)this + 625) = *((void *)this + 681);
  v2[59] = 0;
  *((void *)this + 628) &= C3DFloorGetReflectionCategoryBitMask(Floor);
  *unsigned int v2 = v2[507];
  *((unsigned char *)this + 306) = C3DEngineContextGetViewpointCoordinateSpace(*((void *)this + 2));
  C3D::ScenePass::setup(this);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::FloorPass *)((char *)this + 32), 0);
  *(void *)(v5 + _Block_object_dispose(&STACK[0x2A0], 8) = C3D::Pass::nameWithPrefixAndPointer(this, "SceneKit-floor-color-", *((void **)this + 681));
  *(unsigned char *)(v5 + 24) = 2;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v24);
  *(_OWORD *)(v5 + 16) = v24;
  *(_DWORD *)(v5 + 32) = v25;
  LOWORD(v6) = *(_WORD *)(v5 + 16);
  *(float *)&unsigned int v7 = (float)v6;
  *(_WORD *)(v5 + 16) = (int)(float)(*(float *)(Floor + 228) * *(float *)&v7);
  LOWORD(v7) = *(_WORD *)(v5 + 18);
  *(_WORD *)(v5 + 1_Block_object_dispose(&STACK[0x2A0], 8) = (int)(float)(*(float *)(Floor + 228) * (float)v7);
  __int16 v8 = *(_WORD *)(v5 + 66);
  *(void *)(v5 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  *(void *)(v5 + 56) = 0;
  *(_WORD *)(v5 + 66) = v8 & 0xFFBC | 0x42;
  *(_WORD *)(v5 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 115;
  uint64_t v9 = C3D::PassDescriptor::outputAtIndex((C3D::FloorPass *)((char *)this + 32), 1u);
  C3D::Pass::parentDepthDesc(this, (uint64_t)&v24);
  *(_OWORD *)(v9 + 16) = v24;
  *(_DWORD *)(v9 + 32) = v25;
  *(unsigned char *)(v9 + 64) = 2;
  *(void *)(v9 + _Block_object_dispose(&STACK[0x2A0], 8) = C3D::Pass::nameWithPrefixAndPointer(this, "SceneKit-floor-depth-", *((void **)this + 681));
  *(_WORD *)(v9 + 66) = *(_WORD *)(v9 + 66) & 0xFFFC | 2;
  LOWORD(v10) = *(_WORD *)(v9 + 16);
  *(float *)&unsigned int v11 = (float)v10;
  *(_WORD *)(v9 + 16) = (int)(float)(*(float *)(Floor + 228) * *(float *)&v11);
  LOWORD(v11) = *(_WORD *)(v9 + 18);
  *(_WORD *)(v9 + 1_Block_object_dispose(&STACK[0x2A0], 8) = (int)(float)(*(float *)(Floor + 228) * (float)v11);
  if (*((unsigned char *)this + 306) != 2 && !v2[67])
  {
    float32x4_t v12 = (_WORD *)(v5 + 16);
    EyeCFIndex Count = C3DEngineContextGetEyeCount(*((void *)this + 2));
    *((unsigned char *)this + 121) = 1;
    if (EyeCount)
    {
      uint64_t v14 = EyeCount;
      float32x4_t v15 = (_OWORD *)((char *)this + 128);
      *(void *)&long long v16 = 0;
      do
      {
        v17.i32[0] = (unsigned __int16)*v12;
        v17.i32[1] = *(unsigned __int16 *)(v5 + 18);
        float32x2_t v18 = vcvt_f32_u32(v17);
        LODWORD(v19) = vadd_f32(*(float32x2_t *)&v16, v18).u32[0];
        HIDWORD(v19) = DWORD1(v16);
        *((float32x2_t *)&v16 + 1) = v18;
        *v15++ = v16;
        *(void *)&long long v16 = v19;
        --v14;
      }
      while (v14);
    }
    *v12 *= (_WORD)EyeCount;
    *(_WORD *)(v9 + 16) *= (_WORD)EyeCount;
  }
  if (*(int *)(Floor + 232) < 2)
  {
    LOBYTE(v20) = 0;
    *(unsigned char *)(v5 + 31) = 0;
  }
  else
  {
    *(unsigned char *)(v5 + 24) = 4;
    *(unsigned char *)(v9 + 24) = 4;
    *(unsigned char *)(v5 + 31) = *(_DWORD *)(Floor + 232);
    int v20 = *(_DWORD *)(Floor + 232);
  }
  *(unsigned char *)(v9 + 31) = v20;
  if (C3DFloorGetReflectionFalloffEnd(Floor) == 0.0) {
    *(_WORD *)(v9 + 66) |= 8u;
  }
  *(_WORD *)(v9 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 252;
  uint64_t result = (C3D::Pass *)*((void *)this + 680);
  if (result != this)
  {
    uint64_t v22 = *(void *)(v5 + 8);
    CFNumberRef v23 = (C3D::PassDescriptor *)C3D::Pass::descriptor(result);
    uint64_t result = (C3D::Pass *)C3D::PassDescriptor::outputAtIndex(v23, 0);
    *((void *)result + 1) = v22;
  }
  return result;
}

uint64_t C3D::FloorPass::mirrorNode(C3D::FloorPass *this)
{
  return *((void *)this + 681);
}

void C3D::FloorPass::_setupPointOfViewMatrices(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  C3D::DrawNodesPass::_setupPointOfViewMatrices(a1, a2, a3);
  float32x4_t v4 = *(float32x4_t **)(a1 + 5448);

  C3DCullingContextSetupMirrorMatrices(a1 + 320, v4);
}

void C3D::FloorPass::_didSetupCullingFrustumPlanes(float32x4_t **this)
{
}

void __C3DEngineContextApplyModifiers_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t Morpher = C3DNodeGetMorpher(a2);
  if (Morpher)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    C3DMorpherUpdateIfNeeded(Morpher, a2, v5);
  }
}

uint64_t __C3DEngineContextApplyModifiers_block_invoke_2(uint64_t a1, float32x4_t *a2)
{
  uint64_t result = C3DNodeGetSkinner((uint64_t)a2);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    return C3DSkinnerUpdateCurrentMesh(result, a2, v5);
  }
  return result;
}

void C3DEngineContextReloadShadersIfNeeded(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 208))
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)unsigned int v7 = 0;
      _os_log_impl(&dword_20B249000, v2, OS_LOG_TYPE_INFO, "Info: Reload Shaders", v7, 2u);
    }
    uint64_t v3 = *(CFDictionaryRef **)(a1 + 152);
    if (v3)
    {
      if (*(void *)(a1 + 136)) {
        C3DResourceManagerRemoveAllPrograms(v3);
      }
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    uint64_t Scene = (const void *)C3DEngineContextGetScene(a1);
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", Scene, 0, 1u);
    [*(id *)(a1 + 216) emptyShaderCache];
    uint64_t v6 = -[SCNMTLRenderContext resourceManager](*(void *)(a1 + 1704));
    -[SCNMTLResourceManager removeAllShaders](v6);
    C3DRenderGraphClearRenderGraphResources(*(void *)(a1 + 1728));
    *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
}

uint64_t C3DEngineContextRenderScene(__n128 *a1, double a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    unsigned int v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  a1[26].n128_u64[1] = 0x7FF0000000000000;
  uint64_t FXContext = C3DEngineContextGetFXContext((uint64_t)a1);
  if (FXContext)
  {
    long long v16 = *(void **)(FXContext + 264);
    if (v16) {
      [v16 clearCaches];
    }
  }
  a1[28].n128_f64[0] = a2;
  uint64_t result = C3DEngineContextGetScene((uint64_t)a1);
  if (result)
  {
    uint64_t v18 = result;
    uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a1);
    if (!RendererContextGL)
    {
      int v20 = scn_default_log();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
        C3DEngineContextRenderScene_cold_2(v20, v21, v22, v23, v24, v25, v26, v27);
      }
    }
    uint64_t ResourceManager = C3DEngineContextGetResourceManager((uint64_t)a1);
    C3DResourceManagerLockVRAMResourceAccess(ResourceManager);
    C3DRendererContextInvalidateCache(RendererContextGL);
    C3DEngineContextReloadShadersIfNeeded((uint64_t)a1);
    CFDictionaryRef v29 = (id *)a1[9].n128_u64[0];
    if (v29) {
      C3DAuthoringEnvironmentBeginFrame(v29);
    }
    uint64_t Stats = C3DEngineContextGetStats((uint64_t)a1);
    double v31 = CACurrentMediaTime();
    uint64_t EnginePipeline = C3DSceneGetEnginePipeline(v18);
    if (!EnginePipeline)
    {
      uint64_t v33 = scn_default_log();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
        C3DEngineContextRenderScene_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
      }
    }
    v41[0] = EnginePipeline;
    v41[1] = (uint64_t)a1;
    long long v42 = 0u;
    long long v43 = 0u;
    C3DEnginePipelineApplyNotificationQueue(v41);
    *(double *)(Stats + 152) = *(double *)(Stats + 152) + CACurrentMediaTime() - v31;
    C3DRendererContextPushGroupMarker(RendererContextGL, "Resource Manager Flush");
    C3DResourceManagerFlush(ResourceManager);
    C3DRendererContextPopGroupMarker();
    C3DEngineContextApplyModifiers((uint64_t)a1, EnginePipeline);
    C3DEngineContextRenderMainTechnique(a1);
    if (a4) {
      (*(void (**)(uint64_t))(a4 + 16))(a4);
    }
    C3DRendererContextUnbindTextureUnits(RendererContextGL);
    C3DRendererContextResetToDefaultStates(RendererContextGL);
    C3DRendererContextResetVolatileObjects(RendererContextGL);
    C3DResourceManagerUnlockVRAMResourceAccess(ResourceManager);
    return 1;
  }
  return result;
}

void *C3DEngineContextResetNextFrameTime(uint64_t a1)
{
  *(void *)(a1 + 424) = 0x7FF0000000000000;
  uint64_t result = (void *)C3DEngineContextGetFXContext(a1);
  if (result)
  {
    uint64_t result = (void *)result[33];
    if (result)
    {
      return (void *)[result clearCaches];
    }
  }
  return result;
}

uint64_t C3DEngineContextGetResourceManager(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 152);
}

void C3DEngineContextSynchronizeDefaultLight(uint64_t a1, float32x4_t *a2)
{
  if (a2)
  {
    unsigned int v2 = *(float32x4_t **)(a1 + 48);
    if (v2)
    {
      WorldMatrifloat x = C3DNodeGetWorldMatrix(a2);
      C3DNodeSetMatrix(v2, (uint64_t)WorldMatrix);
    }
  }
}

uint64_t C3DEngineContextGetEnvironmentCubeMesh(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t result = *(void *)(a1 + 400);
  if (!result)
  {
    long long v18 = xmmword_20B5CCF64;
    long long v19 = unk_20B5CCF74;
    long long v20 = xmmword_20B5CCF84;
    long long v21 = unk_20B5CCF94;
    *(_OWORD *)bytes = xmmword_20B5CCF44;
    long long v17 = unk_20B5CCF54;
    *(_OWORD *)uint64_t v13 = xmmword_20B5CCFA4;
    long long v14 = unk_20B5CCFB4;
    int v15 = 132612;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 96);
    values = (void *)C3DMeshSourceCreate(v4, 0, 8, 3, 1);
    CFRelease(v4);
    CFDataRef v5 = CFDataCreate(v3, v13, 36);
    CFTypeRef cf = (CFTypeRef)C3DMeshElementCreate();
    C3DMeshElementInit((uint64_t)cf, 0, 12, v5, 1);
    CFRelease(v5);
    char v10 = 0;
    uint64_t v6 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
    CFArrayRef v7 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x263EFFF70]);
    CFArrayRef v8 = CFArrayCreate(v3, &cf, 1, v6);
    uint64_t v9 = C3DMeshCreateWithMeshSourcesAndMeshElements(v7, v8, (uint64_t)&v10);
    *(void *)(a1 + 400) = v9;
    C3DEntitySetName(v9, @"Environment cube");
    CFRelease(v8);
    CFRelease(v7);
    CFRelease(cf);
    return *(void *)(a1 + 400);
  }
  return result;
}

void C3DEngineContextRenderBackgroundMap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!C3DEffectSlotGetColorIfApplicable(a2))
  {
    uint64_t RenderContext = C3DEngineContextGetRenderContext(a1);
    if (RenderContext)
    {
      CFArrayRef v7 = (void *)RenderContext;
      ImageProxfloat y = C3DEffectSlotGetImageProxy(a2);
      if (ImageProxy
        && (uint64_t v9 = (__C3DImageProxy *)ImageProxy, C3DImageProxyGetSourceType(ImageProxy) - 4 >= 0xFFFFFFFD))
      {
        -[SCNMTLRenderContext renderVideoBackground:engineContext:slot:](v7, v9, (__n128 *)a1, a2);
      }
      else
      {
        -[SCNMTLRenderContext renderBackground:engineContext:passInstance:]((uint64_t)v7, a2, a1, a3);
      }
    }
    else
    {
      uint64_t RendererContextGL = (float32x2_t *)C3DEngineContextGetRendererContextGL(a1);
      uint64_t v11 = C3DEffectSlotGetImageProxy(a2);
      if (v11)
      {
        uint64_t v12 = v11;
        uint64_t Default = C3DTextureSamplerGetDefault();
        TextureProxfloat y = C3DImageProxyCreateTextureProxy(v12, Default, a1);
        if (TextureProxy)
        {
          int v15 = (const void *)TextureProxy;
          uint64_t TextureSampler = C3DEffectSlotGetTextureSampler(a2);
          if (!TextureSampler) {
            uint64_t TextureSampler = C3DTextureSamplerGetDefault();
          }
          C3DTextureProxyRenderInCurrentContext((uint64_t)v15, a1, TextureSampler);
          CFRelease(v15);
        }
      }
      else
      {
        uint64_t Image = C3DEffectSlotGetImage(a2);
        if (!Image) {
          return;
        }
        long long v18 = (void *)Image;
        uint64_t ResourceManager = C3DEngineContextGetResourceManager(a1);
        long long v50 = 0u;
        long long v51 = 0u;
        *(_OWORD *)value = 0u;
        long long v49 = 0u;
        Imageint Type = C3DImageGetImageType((uint64_t)v18);
        if (ImageType - 3 >= 5)
        {
          if (ImageType > 1) {
            return;
          }
          Quaduint64_t Mesh = (void *)C3DEngineContextGetQuadMesh(a1);
          uint64_t v22 = *(void **)(a1 + 416);
          if (!v22)
          {
            BuiltInProgramWithuint64_t Name = (CFMutableDictionaryRef *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-EnvMap2D");
            C3DFXGLSLProgramSetUniformIndex(BuiltInProgramWithName, @"textureSampler0", 0);
            C3DFXGLSLProgramSetUniformIndex(BuiltInProgramWithName, @"u_textureMatrix", (char *)1);
            uint64_t v26 = *(CFMutableDictionaryRef **)(a1 + 416);
            uint64_t v22 = BuiltInProgramWithName;
            if (v26 != BuiltInProgramWithName)
            {
              if (v26)
              {
                CFRelease(v26);
                *(void *)(a1 + 416) = 0;
              }
              if (BuiltInProgramWithName) {
                uint64_t v22 = (void *)CFRetain(BuiltInProgramWithName);
              }
              else {
                uint64_t v22 = 0;
              }
              *(void *)(a1 + 416) = v22;
            }
            if (BuiltInProgramWithName)
            {
              CFRelease(BuiltInProgramWithName);
              uint64_t v22 = *(void **)(a1 + 416);
            }
          }
          if (C3DKeyframeControllerHasInterpolationModesPerKey(a2))
          {
            ImageTransforuint64_t m = (long long *)C3DEffectSlotGetImageTransform(a2);
            long long v41 = ImageTransform[3];
            long long v43 = *ImageTransform;
            long long v42 = ImageTransform[1];
            long long v50 = ImageTransform[2];
            long long v51 = v41;
            *(_OWORD *)value = v43;
            long long v49 = v42;
          }
          else
          {
            C3DMatrix4x4MakeIdentity((uint64_t)value);
          }
        }
        else
        {
          Quaduint64_t Mesh = (void *)C3DEngineContextGetEnvironmentCubeMesh(a1);
          uint64_t v22 = *(void **)(a1 + 408);
          if (!v22)
          {
            uint64_t v23 = (CFMutableDictionaryRef *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-EnvMapCube");
            C3DFXGLSLProgramSetUniformIndex(v23, @"textureSampler0", 0);
            C3DFXGLSLProgramSetUniformIndex(v23, @"u_mvp", (char *)1);
            C3DFXGLSLProgramSetUniformIndex(v23, @"u_zfar", (char *)2);
            uint64_t v24 = *(CFMutableDictionaryRef **)(a1 + 408);
            uint64_t v22 = v23;
            if (v24 != v23)
            {
              if (v24)
              {
                CFRelease(v24);
                *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2A0], 8) = 0;
              }
              if (v23) {
                uint64_t v22 = (void *)CFRetain(v23);
              }
              else {
                uint64_t v22 = 0;
              }
              *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2A0], 8) = v22;
            }
            if (v23)
            {
              CFRelease(v23);
              uint64_t v22 = *(void **)(a1 + 408);
            }
          }
          memset(&v, 0, sizeof(v));
          C3DMatrix4x4Invert((simd_float4x4 *)(a1 + 864), &v);
          __n128 v46 = (__n128)v.columns[3];
          memset(v45, 0, sizeof(v45));
          C3DMatrix4x4MakeTranslation((uint64_t)v45, &v46);
          if (C3DKeyframeControllerHasInterpolationModesPerKey(a2))
          {
            uint64_t v27 = C3DEffectSlotGetImageTransform(a2);
            C3DMatrix4x4Mult(v27, v45, v45);
          }
          C3DMatrix4x4Mult((uint64_t)v45, (float32x4_t *)(a1 + 864), v45);
          C3DMatrix4x4Mult((uint64_t)v45, (float32x4_t *)(a1 + 480), value);
        }
        ProgramResident = C3DResourceManagerMakeProgramResident(ResourceManager, v22, (uint64_t)RendererContextGL);
        C3DRendererContextBindProgramObject((uint64_t)RendererContextGL, ProgramResident);
        BOOL IsEnabled = C3DRendererContextIsEnabled((uint64_t)RendererContextGL, 2);
        BOOL v30 = C3DRendererContextIsEnabled((uint64_t)RendererContextGL, 1);
        C3DRendererContextSetEnable((uint64_t)RendererContextGL, 2, 0);
        C3DRendererContextSetEnable((uint64_t)RendererContextGL, 1, 0);
        UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)ProgramResident, 0);
        if (UniformLocation == -1)
        {
          uint64_t Texture = 0;
        }
        else
        {
          uint64_t v32 = UniformLocation;
          BOOL v44 = v30;
          BOOL v33 = IsEnabled;
          uint64_t v34 = QuadMesh;
          uint64_t v35 = (const void *)C3DEffectSlotGetTextureSampler(a2);
          if (!v35) {
            uint64_t v35 = (const void *)C3DTextureSamplerGetDefault();
          }
          uint64_t Texture = (float32x2_t *)C3DEffectSlotGetTexture(a2);
          if (!Texture) {
            uint64_t Texture = C3DResourceManagerMakeImageResident(ResourceManager, v18, v35, RendererContextGL);
          }
          if (Texture && v35)
          {
            C3DRendererContextBindTexture((uint64_t)RendererContextGL, Texture, (uint64_t)v35, 0, 0);
            C3DRendererContextSetIntUniformAtLocation((uint64_t)RendererContextGL, v32, 0);
            C3DFXGLSLProgramObjectSetUniformValueAtIndex((uint64_t)ProgramResident, 0, 0);
          }
          Quaduint64_t Mesh = v34;
          BOOL IsEnabled = v33;
          BOOL v30 = v44;
        }
        uint64_t v37 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)ProgramResident, 1);
        if (v37 != -1) {
          C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)RendererContextGL, v37, value, 1);
        }
        uint64_t v38 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)ProgramResident, 2);
        if (v38 != -1)
        {
          v.columns[0].f32[0] = *(float *)(a1 + 536) / (float)(*(float *)(a1 + 520) + 1.0);
          C3DRendererContextSetFloatUniformAtLocation((uint64_t)RendererContextGL, v38, (GLfloat *)&v, 1);
        }
        C3DRendererContextBindMesh((uint64_t)RendererContextGL, ResourceManager, QuadMesh);
        ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)QuadMesh, 0, 1);
        C3DRendererContextBindMeshElement((uint64_t)RendererContextGL, ResourceManager, ElementAtIndex);
        C3DRendererContextRenderResidentMeshElement((uint64_t)RendererContextGL);
        C3DRendererContextSetEnable((uint64_t)RendererContextGL, 2, IsEnabled);
        C3DRendererContextSetEnable((uint64_t)RendererContextGL, 1, v30);
        if (ProgramResident) {
          C3DRendererContextUnbindProgramObject((uint64_t)RendererContextGL);
        }
        C3DRendererContextUnbindTexture((uint64_t)RendererContextGL, (uint64_t)Texture, 0);
      }
    }
  }
}

uint64_t C3DEngineContextGetQuadMesh(uint64_t a1)
{
  if (!*(void *)(a1 + 392))
  {
    Plane = (const void *)C3DMeshCreatePlane(0, 1, 1, 0, 2.0, -2.0, 0.0);
    uint64_t CopyWithInterleavedSources = C3DMeshCreateCopyWithInterleavedSources((uint64_t)Plane);
    *(void *)(a1 + 392) = CopyWithInterleavedSources;
    C3DEntitySetName(CopyWithInterleavedSources, @"Quad");
    if (Plane) {
      CFRelease(Plane);
    }
  }
  return *(void *)(a1 + 392);
}

uint64_t C3DEngineContextGetMatrix4x4(uint64_t a1, int a2)
{
  return a1 + 384 * a2 + 480;
}

void C3DEngineContextRenderNodeTree(uint64_t a1, uint64_t *a2, const void *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextGetStats_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  long long v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  uint64_t FXContext = C3DEngineContextGetFXContext(a1);
  uint64_t v23 = *a2;
  if (!*a2)
  {
    uint64_t v23 = __GetDefaultPass_dummyPass;
    if (!__GetDefaultPass_dummyPass)
    {
      uint64_t v23 = C3DFXPassCreate();
      __GetDefaultPass_dummyPass = v23;
    }
  }
  uint64_t EnginePipeline = C3DSceneGetEnginePipeline(*(void *)(a1 + 16));
  if (!EnginePipeline)
  {
    uint64_t v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
    }
  }
  CFRetain(a3);
  uint64_t v59 = 0;
  v58[0] = EnginePipeline;
  v58[1] = a1;
  __n128 v58[2] = a2;
  void v58[3] = 0;
  *(_DWORD *)((char *)&v59 + 2) = C3DFXPassGetIgnoreInifiniteFloor(v23);
  uint64_t MirrorNode = C3DFXContextGetMirrorNode((void *)FXContext);
  v58[4] = MirrorNode;
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
  uint64_t v35 = RendererContextGL;
  BOOL FrontFace = 0;
  if (MirrorNode)
  {
    if (RendererContextGL)
    {
      BOOL FrontFace = C3DRendererContextGetFrontFace(RendererContextGL);
      if (FrontFace) {
        C3DRendererContextSetFrontFace(v35, 0);
      }
    }
  }
  int v57 = FrontFace;
  if (C3DFXPassGetDrawOnlyShadowCaster(v23) && (uint64_t PointOfView = C3DFXPassGetPointOfView(v23)) != 0)
  {
    CFDictionaryRef Light = C3DNodeGetLight(PointOfView);
    int v39 = 0;
    if (Light && v35)
    {
      GLfloat v40 = C3DLightGetShadowBias((uint64_t)Light) * 4096.0;
      glEnable(0x8037u);
      glPolygonOffset(1.2, v40);
      int v39 = 1;
    }
  }
  else
  {
    int v39 = 0;
  }
  int v56 = v39;
  uint64_t v41 = 0;
  uint64_t v42 = a1 + 480;
  do
  {
    for (uint64_t i = 0; i != 384; i += 64)
      C3DMatrix4x4MakeIdentity(v42 + i);
    ++v41;
    v42 += 384;
  }
  while (v41 != 3);
  BOOL v44 = &a2[8 * (unint64_t)*(unsigned __int8 *)(FXContext + 120) + 10];
  long long v45 = *((_OWORD *)v44 + 217);
  long long v46 = *((_OWORD *)v44 + 218);
  long long v47 = *((_OWORD *)v44 + 220);
  *(_OWORD *)(a1 + 512) = *((_OWORD *)v44 + 219);
  *(_OWORD *)(a1 + 52_Block_object_dispose(&STACK[0x2A0], 8) = v47;
  *(_OWORD *)(a1 + 480) = v45;
  *(_OWORD *)(a1 + 496) = v46;
  uint64_t v48 = &a2[8 * (unint64_t)*(unsigned __int8 *)(FXContext + 120) + 10];
  long long v49 = *((_OWORD *)v48 + 193);
  long long v50 = *((_OWORD *)v48 + 194);
  long long v51 = *((_OWORD *)v48 + 196);
  *(_OWORD *)(a1 + 896) = *((_OWORD *)v48 + 195);
  *(_OWORD *)(a1 + 912) = v51;
  *(_OWORD *)(a1 + 864) = v49;
  *(_OWORD *)(a1 + 880) = v50;
  if (C3DFXPassGetUsesSceneBackgroundColor(v23))
  {
    uint64_t Scene = C3DEngineContextGetScene(a1);
    uint64_t BackgroundEffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0);
    if (BackgroundEffectSlot) {
      C3DEngineContextRenderBackgroundMap(a1, BackgroundEffectSlot, (uint64_t)a2);
    }
  }
  uint64_t v54 = *(void *)(a1 + 1704);
  if (v54) {
    -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v54);
  }
  kdebug_trace();
  C3DEnginePipelineRenderSubTree(v58, (uint64_t)a3);
  uint64_t v55 = *(void *)(a1 + 1704);
  if (v55) {
    -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v55);
  }
  kdebug_trace();
  CFRelease(a3);
  if (v35)
  {
    if (MirrorNode && v57) {
      C3DRendererContextSetFrontFace(v35, v57);
    }
    if (v56)
    {
      glDisable(0x8037u);
      glPolygonOffset(0.0, 0.0);
    }
  }
}

CFStringRef _C3DEngineContextCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DEngineContext>");
}

CFStringRef _C3DEngineContextCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DEngineContext>");
}

void __InstallGLContext(uint64_t a1, void *a2)
{
  if (!a1)
  {
    CFDataRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = C3DRendererContextCreateWithOptions();
  uint64_t v13 = *(const void **)(a1 + 136);
  if (!v13)
  {
    int v19 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = *(const void **)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    if (!v16) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  CFTypeRef v14 = CFRetain(v13);
  uint64_t v15 = v14;
  uint64_t v16 = *(const void **)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (!v14)
  {
    int v19 = 0;
    if (!v16) {
      goto LABEL_13;
    }
LABEL_12:
    CFRelease(v16);
    goto LABEL_13;
  }
  if (C3DRendererContextGetShowsAuthoringEnvironment((uint64_t)v14) && v16)
  {
    C3DAnimationManagerSetPausedForEditing((uint64_t)v12, 1);
    uint64_t AuthoringEnvironment = C3DEngineContextGetAuthoringEnvironment(a1, 1);
    C3DAuthoringEnvironmentCopySettings((uint64_t)v16, AuthoringEnvironment);
  }
  float ContentScaleFactor = C3DRendererContextGetContentScaleFactor((uint64_t)v15);
  C3DRendererContextSetContentScaleFactor((uint64_t)v12, ContentScaleFactor);
  int v19 = 1;
  if (v16) {
    goto LABEL_12;
  }
LABEL_13:
  ResourceManagerForContext = C3DResourceManagerRegistryGetResourceManagerForContext(a2, 1);
  uint64_t v21 = *(const void **)(a1 + 152);
  if (v21) {
    CFTypeRef v22 = CFRetain(v21);
  }
  else {
    CFTypeRef v22 = 0;
  }
  C3DRendererContextSetGLContext(v12, a2);
  uint64_t v23 = *(const void **)(a1 + 152);
  if (v23 != ResourceManagerForContext)
  {
    if (v23)
    {
      CFRelease(v23);
      *(void *)(a1 + 152) = 0;
    }
    if (ResourceManagerForContext) {
      CFTypeRef v24 = CFRetain(ResourceManagerForContext);
    }
    else {
      CFTypeRef v24 = 0;
    }
    *(void *)(a1 + 152) = v24;
  }
  uint64_t v25 = *(__n64 **)(a1 + 136);
  if (v25 != v12)
  {
    if (v25)
    {
      CFRelease(v25);
      *(void *)(a1 + 136) = 0;
    }
    if (v12) {
      CFTypeRef v26 = CFRetain(v12);
    }
    else {
      CFTypeRef v26 = 0;
    }
    *(void *)(a1 + 136) = v26;
  }
  *(void *)(a1 + 1696) = v12 + 23;
  *(_DWORD *)(a1 + 1712) = C3DMeshElementGetPrimitiveCount((uint64_t)v12);
  _C3DResourceManagerInstallRendererContext(*(void *)(a1 + 152), *(const void **)(a1 + 136));
  __InstallFXContext(a1);
  if (v22) {
    int v27 = v19;
  }
  else {
    int v27 = 0;
  }
  if (v27 == 1) {
    _C3DResourceManagerUninstallRendererContext((uint64_t)v22, v15);
  }
  _setupRendererContextWithSceneOptions(a1);
  if (v12) {
    CFRelease(v12);
  }
  if (v19) {
    CFRelease(v15);
  }
  if (v22) {
    CFRelease(v22);
  }
}

void C3DEngineContextSetGLContext(uint64_t a1, void *a2)
{
  if (!a1 && (CFDataRef v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DEngineContextSetGLContext_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  uint64_t v20 = *(void *)(a1 + 136);
  if (!v20 || *(void **)(v20 + 160) != a2) {
    __InstallGLContext(a1, a2);
  }
}

uint64_t C3DEngineContextGetGLContext(uint64_t a1)
{
  uint64_t result = C3DEngineContextGetRendererContextGL(a1);
  if (result)
  {
    return C3DRendererContextGetGLContext(result);
  }
  return result;
}

uint64_t C3DEngineContextSetCoordinatesSystemOptions(uint64_t result, __int16 a2, int a3)
{
  if (a3) {
    __int16 v3 = a2;
  }
  else {
    __int16 v3 = 0;
  }
  *(_WORD *)(result + 214) = *(_WORD *)(result + 214) & ~a2 | v3;
  return result;
}

void C3DEngineContextSetNextFrameTime(uint64_t a1, double a2)
{
  if (!a1)
  {
    CFDataRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  double v12 = *(double *)(a1 + 424);
  if (v12 > a2) {
    double v12 = a2;
  }
  *(double *)(a1 + 424) = v12;
}

void C3DEngineContextSetNextFrameTimeToAsap(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  double v10 = *(double *)(a1 + 440);
  if (v10 >= *(double *)(a1 + 424)) {
    double v10 = *(double *)(a1 + 424);
  }
  *(double *)(a1 + 424) = v10;
}

double C3DEngineContextGetNextFrameTime(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 424);
}

float32x4_t *C3DEngineContextGetDefaultLightNode(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  double v10 = *(float32x4_t **)(a1 + 48);
  if (!v10)
  {
    double v10 = (float32x4_t *)C3DNodeCreate();
    CFDictionaryRef v11 = (const __CFDictionary *)C3DLightCreate();
    if (C3DWasLinkedBeforeMajorOSYear2016()) {
      int v12 = 2;
    }
    else {
      int v12 = 1;
    }
    C3DLightSetType((uint64_t)v11, v12);
    C3DLightSetCategoryBitMask(v11, 0xDEFA017DEFA017);
    C3DNodeSetLight(v10, v11);
    CFRelease(v11);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v10;
  }
  return v10;
}

BOOL C3DEngineContextGetAllowsDefaultLightingEnvironmentFallback(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t Scene = C3DEngineContextGetScene(a1);
  BOOL result = 1;
  if (!C3DSceneGetAllowsDefaultLightingEnvironmentFallback(Scene)
    || C3DWasLinkedBeforeMajorOSYear2018())
  {
    RenderingOptionForKefloat y = C3DEngineContextGetRenderingOptionForKey(a1, @"defaultLight");
    if (!RenderingOptionForKey || !CFEqual(RenderingOptionForKey, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      return 0;
    }
  }
  return result;
}

CFTypeRef C3DEngineContextSetPointOfCulling(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 32);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 32) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 32) = result;
  }
  return result;
}

uint64_t C3DEngineContextGetPointOfCulling(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

uint64_t C3DEngineContextGetClearsOnDraw(uint64_t a1)
{
  if (!a1)
  {
    unsigned int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 210);
}

void C3DEngineContextSetForceShaderReload(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x2A0], 8) = a2 != 0;
}

void C3DEngineContextSetAutoAdjustZRange(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 209) = a2 != 0;
}

void _C3DEngineContextInvalidatePasses(int a1, uint64_t a2, int a3, int a4, CFDictionaryRef theDict)
{
  if (!theDict) {
    goto LABEL_5;
  }
  CFNumberRef Value = CFDictionaryGetValue(theDict, @"kCameraKey");
  uint64_t PointOfView = C3DEngineContextGetPointOfView(a2);
  if (PointOfView) {
    uint64_t PointOfView = C3DNodeGetCamera((uint64_t)PointOfView);
  }
  if (Value == PointOfView)
  {
LABEL_5:
    C3DFXInvalidatePasses(a2);
    uint64_t v8 = *(void *)(a2 + 1728);
    C3DRenderGraphInvalidateTechniques(v8);
  }
}

uint64_t C3DEngineContextSetDeltaTime(uint64_t result, double a2)
{
  *(double *)(result + 432) = a2;
  return result;
}

uint64_t C3DEngineContextSetSystemTime(uint64_t result, double a2)
{
  *(double *)(result + 440) = a2;
  return result;
}

uint64_t C3DEngineContextSetSceneTime(uint64_t result, double a2)
{
  *(double *)(result + 44_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  return result;
}

double C3DEngineContextGetSceneTime(uint64_t a1)
{
  return *(double *)(a1 + 448);
}

uint64_t C3DEngineContextGetIsolateMode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 460);
}

CFTypeRef C3DEngineContextSetBackgroundTextureProxy(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 192);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 192) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 192) = result;
  }
  return result;
}

void C3DEngineContextDrawFullScreenQuad(uint64_t a1)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
  uint64_t ResourceManager = C3DEngineContextGetResourceManager(a1);
  Quaduint64_t Mesh = (void *)C3DEngineContextGetQuadMesh(a1);
  C3DRendererContextSetEnable(RendererContextGL, 2, 0);
  C3DRendererContextSetEnable(RendererContextGL, 1, 0);
  C3DRendererContextBindMesh(RendererContextGL, ResourceManager, QuadMesh);
  ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)QuadMesh, 0, 1);
  C3DRendererContextBindMeshElement(RendererContextGL, ResourceManager, ElementAtIndex);
  C3DRendererContextRenderResidentMeshElement(RendererContextGL);
  C3DRendererContextSetEnable(RendererContextGL, 2, 1);

  C3DRendererContextSetEnable(RendererContextGL, 1, 1);
}

uint64_t C3DEngineContextGetRendererElementState(uint64_t a1)
{
  return *(void *)(a1 + 1640);
}

uint64_t C3DEngineContextGetMainClearColor(uint64_t a1)
{
  return *(void *)(a1 + 224);
}

void C3DEngineContextComputeNormalMatrix(float32x4_t *a1@<X0>, _OWORD *a2@<X8>)
{
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  memset(v3, 0, sizeof(v3));
  C3DMatrix4x4Mult((uint64_t)&a1[78], a1 + 54, v3);
  C3DMatrix4x4ComputeNormalMatrix(v3, a2);
}

__n128 C3DEngineContextSetViewportAtIndex(uint64_t a1, unsigned int a2, __n128 result)
{
  if (a2 >= 6)
  {
    __n128 v13 = result;
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetViewportAtIndex_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    CFTypeRef result = v13;
    *(__n128 *)(a1 + 16 * a2 + 240) = v13;
  }
  else
  {
    *(__n128 *)(a1 + 16 * a2 + 240) = result;
    if (!a2 && *(void *)(a1 + 136))
    {
      C3DRendererContextSetViewport(result);
    }
  }
  return result;
}

uint64_t C3DEngineContextGetInterfaceOrientation(uint64_t a1)
{
  return *(unsigned int *)(a1 + 368);
}

__n128 C3DEngineContextGetDrawableSafeAreaInsets(__n128 *a1)
{
  return a1[21];
}

__n128 *C3DEngineContextSetDrawableSafeAreaInsets(__n128 *result, __n128 a2)
{
  result[21] = a2;
  return result;
}

const void *C3DEngineContextGetTextureWithName(uint64_t a1, __CFString *a2)
{
  if (*(void *)(a1 + 1704))
  {
    uint64_t v3 = *(void *)(a1 + 1728);
    uint64_t v4 = [(__CFString *)a2 UTF8String];
    return (const void *)C3DRenderGraphGetTextureNamed(v3, v4);
  }
  else
  {
    uint64_t FXContext = C3DEngineContextGetFXContext(a1);
    uint64_t FramebufferRegistry = C3DFXContextGetFramebufferRegistry(FXContext);
    return C3DFramebufferRegistryGetTextureWithName(FramebufferRegistry, a2);
  }
}

float32x2_t *C3DEngineContextGetTextureForEffectSlot(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t TextureSampler = C3DEffectSlotGetTextureSampler(a2);
  if (!TextureSampler) {
    uint64_t TextureSampler = C3DTextureSamplerGetDefault();
  }
  *a3 = TextureSampler;
  uint64_t v7 = a1[213];
  if (v7)
  {
    return (float32x2_t *)-[SCNMTLRenderContext textureForEffectSlot:](v7, a2);
  }
  else
  {
    ImageProxfloat y = (void *)C3DEffectSlotGetImageProxy(a2);
    if (!ImageProxy
      || (CFTypeRef result = (float32x2_t *)C3DResourceManagerMakeImageProxyResident(a1[19], ImageProxy, *a3, a1[17], (uint64_t)a1)) == 0)
    {
      CFTypeRef result = (float32x2_t *)C3DEffectSlotGetImage(a2);
      if (result)
      {
        uint64_t v10 = result;
        uint64_t v11 = a1[19];
        uint64_t v12 = (const void *)*a3;
        __n128 v13 = (float32x2_t *)a1[17];
        return C3DResourceManagerMakeImageResident(v11, v10, v12, v13);
      }
    }
  }
  return result;
}

uint64_t C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(unsigned int a1)
{
  if (a1 > 7) {
    return 0;
  }
  else {
    return dword_20B5CCFC8[a1];
  }
}

uint64_t C3DEngineContextGetCommonProfileConditioners(uint64_t a1)
{
  uint64_t v1 = 16 * *(unsigned __int8 *)(a1 + 211);
  uint64_t v2 = *(void *)(a1 + 1704);
  if (v2) {
    return v1 | -[SCNMTLRenderContext disableLinearRendering](v2);
  }
  return v1;
}

uint64_t C3DEngineContextSetPreferredRenderMode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 213) = a2;
  return result;
}

uint64_t C3DEngineContextSetVertexAmplificationEnabled(uint64_t result, char a2)
{
  if ((*(unsigned char *)(result + 1713) & 0x20) != 0) {
    *(unsigned char *)(result + 372) = a2;
  }
  return result;
}

uint64_t C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 372)) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t C3DEngineContextSetEyeCount(uint64_t result, char a2)
{
  *(unsigned char *)(result + 212) = a2;
  return result;
}

CFTypeRef C3DEngineContextSetRenderPassDescriptorForEye(uint64_t a1, CFTypeRef cf, unsigned int a3)
{
  uint64_t v3 = a1 + 8 * a3;
  CFTypeRef result = *(CFTypeRef *)(v3 + 1648);
  if (result != cf)
  {
    uint64_t v6 = (void *)(v3 + 1648);
    if (result)
    {
      CFRelease(result);
      void *v6 = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    void *v6 = result;
  }
  return result;
}

uint64_t C3DEngineContextGetRenderPassDescriptorForEye(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 8 * a2 + 1648);
}

__n128 C3DEngineContextSetEyeMatrix4x4(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  if (a4 >= 6)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetEyeMatrix4x4_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  __n128 result = *(__n128 *)a3;
  long long v17 = *(_OWORD *)(a3 + 16);
  long long v18 = *(_OWORD *)(a3 + 48);
  unint64_t v19 = a1 + 384 * a2 + ((unint64_t)a4 << 6);
  *(_OWORD *)(v19 + 512) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v19 + 52_Block_object_dispose(&STACK[0x2A0], 8) = v18;
  *(__n128 *)(v19 + 480) = result;
  *(_OWORD *)(v19 + 496) = v17;
  return result;
}

uint64_t C3DEngineContextSetViewpointCoordinateSpace(uint64_t result, char a2)
{
  *(unsigned char *)(result + 1632) = a2;
  return result;
}

uint64_t C3DEngineContextSetSuperSamplingFactor(uint64_t result, float a2)
{
  *(float *)(result + 204) = a2;
  return result;
}

uint64_t C3DEngineContextSetJitteringEnabled(uint64_t result, int a2)
{
  char v2 = *(unsigned char *)(result + 1716);
  if (((((v2 & 1) == 0) ^ a2) & 1) == 0)
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 1716) = v2 & 0xFE | a2;
    if (!*(void *)(result + 1704))
    {
      uint64_t FXContext = C3DEngineContextGetFXContext(result);
      __n128 result = *(void *)(FXContext + 40);
      if (*(unsigned char *)(v3 + 1716))
      {
        if (result) {
          return result;
        }
        __n128 result = C3DFXTechniqueCreateJittering();
      }
      else
      {
        if (!result) {
          return result;
        }
        CFRelease((CFTypeRef)result);
        __n128 result = 0;
      }
      *(void *)(FXContext + 40) = result;
    }
  }
  return result;
}

uint64_t C3DEngineContextSetJitteringStep(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1720) = a2;
  return result;
}

uint64_t C3DEngineContextGetJitteringStep(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1720);
}

void C3DEngineContextSetUpdateMainFramebuffer(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 1724) = a2;
  if (!*(void *)(a1 + 1704))
  {
    uint64_t FXContext = C3DEngineContextGetFXContext(a1);
    if (FXContext)
    {
      uint64_t v4 = FXContext;
      uint64_t v5 = *(void *)(FXContext + 40);
      if (v5)
      {
        PassCFIndex Count = C3DFXTechniqueGetPassCount(v5);
        PassAtuint64_t Index = C3DFXTechniqueGetPassAtIndex(*(void *)(v4 + 40), PassCount - 1);
        if (PassAtIndex)
        {
          C3DFXPassSetUpdatesMainFrameBuffer(PassAtIndex, a2);
        }
      }
    }
  }
}

void C3DEngineContextComputeJitterMatrix(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  float v6 = *(float *)(a1 + 248);
  float v5 = *(float *)(a1 + 252);
  if (v6 <= 0.0 || v5 <= 0.0)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      C3DEngineContextComputeJitterMatrix_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      if (a2) {
        goto LABEL_5;
      }
LABEL_30:
      int v19 = 4;
      int v17 = 4;
      goto LABEL_31;
    }
  }
  if (!a2) {
    goto LABEL_30;
  }
LABEL_5:
  int v15 = (int)((sqrt((double)a2) + -1.0) * 0.5 + 1.0);
  if (a2 <= 0) {
    int v16 = -(-a2 & 3);
  }
  else {
    int v16 = a2 & 3;
  }
  switch(v16)
  {
    case 0:
      int v17 = 4 - v15;
      if (v15 >= 0) {
        int v18 = v15;
      }
      else {
        int v18 = v15 + 1;
      }
      int v19 = 4 - (v18 >> 1);
      break;
    case 1:
      int v19 = 4 - v15;
      int v17 = 4 - v15;
      break;
    case 2:
      int v17 = v15 + 4;
      int v19 = 4 - v15;
      break;
    case 3:
      if (v15 >= 0) {
        int v20 = v15;
      }
      else {
        int v20 = v15 + 1;
      }
      int v17 = 4 - (v20 >> 1);
      int v19 = v15 + 4;
      break;
    default:
      int v19 = 4;
      int v17 = 4;
      break;
  }
  int v21 = 2 * v15;
  int v22 = a2 - (v21 - 1) * (v21 - 1);
  int v23 = v22 / 4;
  int v24 = v22 / 8;
  int v25 = v23 + 2;
  if (v23 >= -1) {
    int v25 = v23 + 1;
  }
  int v26 = -(v25 >> 1);
  if (v23) {
    int v24 = v26;
  }
  int v27 = v24 + v15;
  switch(v16)
  {
    case 0:
      v19 += v21 + ~v27;
      break;
    case 1:
      v17 += v27;
      break;
    case 2:
      v19 += v27;
      break;
    case 3:
      v17 += v21 + ~v27;
      break;
    default:
      break;
  }
LABEL_31:
  *(float *)&unint64_t v28 = (float)((float)(int)(float)((float)v17 + -4.0) * -0.25) / v6;
  *((float *)&v28 + 1) = (float)((float)(int)(float)((float)v19 + -4.0) * -0.25) / v5;
  __n128 v29 = (__n128)v28;
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  C3DMatrix4x4MakeTranslation((uint64_t)a3, &v29);
}

uint64_t C3DEngineContextSetTemporalAntialiasingEnabled(uint64_t result, char a2)
{
  *(unsigned char *)(result + 1864) = *(unsigned char *)(result + 1864) & 0xFE | a2;
  return result;
}

float32x2_t C3DEngineContextGetTAAJitter(float32x2_t *a1, int a2)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext((uint64_t)a1);
  uint64_t v5 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](RenderContext) + a2;
  uint64_t v6 = v5 & 0xF;
  uint64_t v8 = -v5;
  BOOL v7 = v8 < 0;
  uint64_t v9 = v8 & 0xF;
  if (v7) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = -v9;
  }
  float32x2_t v11 = a1[v10 + 217];
  if (a1[31].f32[0] <= 0.0 || a1[31].f32[1] <= 0.0)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetTAAJitter_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return vdiv_f32(v11, a1[31]);
}

C3D::RenderPass *C3D::OutlinePass::OutlinePass(C3D::OutlinePass *this, RenderGraph *a2, C3D::Pass *a3)
{
  __n128 result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)__n128 result = &unk_26BF6CB60;
  return result;
}

const char *C3D::OutlinePass::name(C3D::OutlinePass *this)
{
  return "OutlinePass";
}

const char *C3D::OutlinePass::programHashCodeStoreName(C3D::OutlinePass *this)
{
  return "OutlinePass";
}

void C3D::OutlinePass::setup(C3D::OutlinePass *this)
{
  C3D::Pass::setInputCount(this, 4u);
  C3D::Pass::setOutputCount(this, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v20);
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0);
  *(_OWORD *)(v2 + 16) = v20;
  *(_DWORD *)(v2 + 32) = v21;
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0);
  *(_WORD *)(v3 + 66) = *(_WORD *)(v3 + 66) & 0xFFFC | 1;
  uint64_t v4 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0);
  *(_WORD *)(v4 + 66) |= 4u;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "DEPTH";
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 1u) + 64) = 2;
  C3D::Pass::parentDepthDesc(this, (uint64_t)&v20);
  uint64_t v5 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 1u);
  *(_OWORD *)(v5 + 16) = v20;
  *(_DWORD *)(v5 + 32) = v21;
  uint64_t v6 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 1u);
  *(_WORD *)(v6 + 66) = *(_WORD *)(v6 + 66) & 0xFFFC | 1;
  uint64_t v7 = C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 1u);
  *(_WORD *)(v7 + 66) |= 4u;
  *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR_OUTLINE";
  *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::OutlinePass *)((char *)this + 32), 0) + 65) = 0;
  uint64_t v8 = *((void *)this + 3);
  *(void *)&long long v20 = this;
  uint64_t v9 = C3D::RenderGraph::createPass<C3D::PickedObjectPass,C3D::OutlinePass *>(v8, (C3D::Pass **)&v20);
  uint64_t v10 = (_OWORD *)C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)v9 + 32), 0);
  float32x2_t v11 = (_OWORD *)C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 2u);
  *float32x2_t v11 = *v10;
  long long v12 = v10[4];
  long long v14 = v10[1];
  long long v13 = v10[2];
  _OWORD v11[3] = v10[3];
  float32x4_t v11[4] = v12;
  v11[1] = v14;
  v11[2] = v13;
  uint64_t v15 = (_OWORD *)C3D::PassDescriptor::outputAtIndex((C3D::PickedObjectPass *)((char *)v9 + 32), 1u);
  uint64_t v16 = (_OWORD *)C3D::PassDescriptor::inputAtIndex((C3D::OutlinePass *)((char *)this + 32), 3u);
  *uint64_t v16 = *v15;
  long long v17 = v15[4];
  long long v19 = v15[1];
  long long v18 = v15[2];
  v16[3] = v15[3];
  unsigned int v16[4] = v17;
  v16[1] = v19;
  _OWORD v16[2] = v18;
  C3D::Pass::addDependency(this, v9);
}

C3D::PickedObjectPass *C3D::RenderGraph::createPass<C3D::PickedObjectPass,C3D::OutlinePass *>(uint64_t a1, C3D::Pass **a2)
{
  Aligned = (C3D::PickedObjectPass *)C3DScratchAllocatorAllocateAligned(*(void *)(a1 + 16), 5376, 16, 0);
  C3D::PickedObjectPass::PickedObjectPass(Aligned, (RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(unsigned char *)(a1 + 209)) {
    (*(void (**)(C3D::PickedObjectPass *))(*(void *)Aligned + 8))(Aligned);
  }
  return Aligned;
}

uint64_t C3D::OutlinePass::compile(C3D::OutlinePass *this)
{
  uint64_t v2 = (*(uint64_t (**)(C3D::OutlinePass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v2);
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::OutlinePass::execute(C3D::Pass *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((void *)a1 + 30) + 16) state];
  if (*(void *)(v4 + 3376) != v5)
  {
    *(void *)(v4 + 3376) = v5;
    [*(id *)(v4 + 3392) setRenderPipelineState:v5];
  }
  uint64_t v6 = *a2;
  uint64_t v7 = C3D::Pass::inputTextureAtIndex(a1, 2u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v7, 0);
  uint64_t v8 = *a2;
  uint64_t v9 = C3D::Pass::inputTextureAtIndex(a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v8, v9, 1uLL);
  uint64_t v10 = *a2;
  float32x2_t v11 = C3D::Pass::inputTextureAtIndex(a1, 1u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v10, v11, 2uLL);
  uint64_t v12 = *a2;
  long long v13 = C3D::Pass::inputTextureAtIndex(a1, 3u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v12, v13, 3uLL);
  long long v14 = (SCNMTLRenderCommandEncoder *)*a2;

  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle(v14);
}

void C3D::OutlinePassResource::~OutlinePassResource(C3D::OutlinePassResource *this)
{
  *(void *)this = &unk_26BF6DD30;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6DD30;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

__n128 __copy_helper_block_e16_32c14_ZTS9btVector3(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

void sub_20B344D64(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

double btC3DDynamicCharacterController::setup(btC3DDynamicCharacterController *this, float a2, float a3, float a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  v29[0] = a3;
  v29[1] = a3;
  float v5 = a2 * 0.5;
  LODWORD(v6) = 0;
  LODWORD(v7) = 0;
  *((float *)&v7 + 1) = v5 - a3;
  *((float *)&v6 + 1) = a3 - v5;
  btVector3 v30 = (btVector3)v7;
  long long v31 = v6;
  *((float *)this + 2) = v5;
  uint64_t v8 = (btMultiSphereShape *)btAlignedAllocInternal(192, 16);
  btMultiSphereShape::btMultiSphereShape(v8, &v30, v29, 2);
  *((void *)this + 2) = v8;
  uint64_t v9 = btAlignedAllocInternal(224, 16);
  __n128 Identity = btTransform::getIdentity((btTransform *)v9);
  *(void *)uint64_t v9 = &unk_26BF6B010;
  *(_OWORD *)(v9 + 16) = xmmword_20B5CB820;
  *(_OWORD *)(v9 + 32) = xmmword_20B5CB7D0;
  *(_OWORD *)(v9 + 4_Block_object_dispose(&STACK[0x2A0], 8) = xmmword_20B5CB520;
  *(_OWORD *)(v9 + 64) = xmmword_20B5CD010;
  *(_OWORD *)(v9 + 80) = *Identity;
  *(_OWORD *)(v9 + 96) = Identity[1];
  *(_OWORD *)(v9 + 112) = Identity[2];
  *(_OWORD *)(v9 + 12_Block_object_dispose(&STACK[0x2A0], 8) = Identity[3];
  *(_OWORD *)(v9 + 144) = xmmword_20B5CB820;
  *(_OWORD *)(v9 + 160) = xmmword_20B5CB7D0;
  *(_OWORD *)(v9 + 176) = xmmword_20B5CB520;
  *(_OWORD *)(v9 + 192) = xmmword_20B5CD010;
  *(void *)(v9 + 20_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  uint64_t v11 = *((void *)this + 2);
  int v14 = 1065353216;
  uint64_t v15 = v9;
  uint64_t v20 = 0;
  uint64_t v21 = v11;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  long long v25 = xmmword_20B5CD020;
  int v26 = 1065353216;
  char v27 = 0;
  long long v28 = xmmword_20B5CD030;
  long long v16 = xmmword_20B5CB820;
  long long v17 = xmmword_20B5CB7D0;
  long long v18 = xmmword_20B5CB520;
  uint64_t v19 = 0;
  uint64_t v12 = btAlignedAllocInternal(704, 16);
  btRigidBody::btRigidBody((btCollisionObject *)v12, (uint64_t)&v14);
  *((void *)this + 3) = v12;
  *(void *)(v12 + 524) = 0;
  double result = 0.0;
  *(_OWORD *)(v12 + 624) = 0u;
  return result;
}

void sub_20B344F2C(_Unwind_Exception *a1)
{
  btAlignedFreeInternal(v1);
  _Unwind_Resume(a1);
}

void btC3DGhostIgnoreCharacterBody::~btC3DGhostIgnoreCharacterBody(btC3DGhostIgnoreCharacterBody *this)
{
}

BOOL btC3DGhostIgnoreCharacterBody::needBroadphaseCollision(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *a3;
  return (*a2 != v3 || v4 != *(void *)(a1 + 16))
      && (v4 != v3 || *a2 != *(void *)(a1 + 16))
      && (a3[2] & a2[1]) != 0
      && (a2[2] & a3[1]) != 0;
}

void btC3DDynamicCharacterController::~btC3DDynamicCharacterController(btC3DDynamicCharacterController *this)
{
  btC3DDynamicCharacterController::~btC3DDynamicCharacterController(this);

  JUMPOUT(0x210534FE0);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_26BF6C140;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    *((void *)this + 3) = 0;
  }
}

uint64_t btC3DDynamicCharacterController::updateAction(uint64_t a1, uint64_t a2, float a3)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, __n128))(*(void *)a1 + 72);
  v7.n128_f32[0] = a3;

  return v6(a1, a2, v7);
}

uint64_t btC3DDynamicCharacterController::preStep(float32x4_t *this, btCollisionWorld *a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v4 = &this[1].i64[1];
  (*(void (**)(void, uint64_t *))(**(void **)(this[1].i64[1] + 536) + 16))(*(void *)(this[1].i64[1] + 536), &v22);
  uint64_t v5 = 0;
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  float32x4_t v7 = (float32x4_t)veorq_s8(v23, v6);
  int8x16_t v8 = (int8x16_t)vmulq_f32(v7, v7);
  float32x4_t v9 = vmulq_n_f32(v7, 1.0/ sqrtf(vadd_f32(vpadd_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)v8.i8), (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)).f32[0]));
  int8x16_t v10 = (int8x16_t)vmulq_f32(v24, v24);
  float32x4_t v11 = vmulq_n_f32(v24, 1.0/ sqrtf(vadd_f32(vpadd_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v10.i8), (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL)).f32[0]));
  float32x4_t v12 = v25;
  this[2] = v25;
  this[3] = v12;
  float v13 = this->f32[2];
  float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3F8CCCCDu);
  float32x4_t v15 = vmulq_f32(vmulq_n_f32(v9, v13), v14);
  v15.i32[3] = 0;
  float32x4_t v16 = vmulq_f32(vmulq_n_f32(v11, v13), v14);
  v16.i32[3] = 0;
  this[4] = vaddq_f32(v12, v15);
  this[5] = vaddq_f32(v12, v16);
  uint64_t v17 = *v4;
  uint64_t v28 = 0;
  long long v29 = xmmword_20B5CD040;
  uint64_t v30 = 0;
  int v31 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  int v26 = &unk_26BF6ED38;
  uint64_t v34 = v17;
  char v18 = 1;
  do
  {
    char v19 = v18;
    *(float *)&int v27 = 1.0;
    uint64_t result = (*(uint64_t (**)(btCollisionWorld *, float32x4_t *, float32x4_t *, void **))(*(void *)a2 + 64))(a2, &this[v5 + 2], &this[v5 + 4], &v26);
    char v18 = 0;
    float v21 = *(float *)&v27;
    if (!v28) {
      float v21 = 1.0;
    }
    this[6].f32[v5] = v21;
    uint64_t v5 = 1;
  }
  while ((v19 & 1) != 0);
  return result;
}

void btC3DDynamicCharacterController::playerStep(btC3DDynamicCharacterController *this, btCollisionWorld *a2, float a3)
{
  (*(void (**)(void, btTransform *))(**(void **)(*((void *)this + 3) + 536) + 16))(*(void *)(*((void *)this + 3) + 536), &v14);
  __float2 v5 = __sincosf_stret(*((float *)this + 36) * 0.5);
  float v6 = v5.__sinval / sqrtf(vpadd_f32((float32x2_t)0x3F80000000000000, (float32x2_t)0x3F80000000000000).f32[0] + 0.0);
  v13.var0.var0[0] = v6 * 0.0;
  v13.var0.var0[1] = v6;
  v13.var0.var0[2] = v6 * 0.0;
  v13.var0.var0[3] = v5.__cosval;
  btMatrix3x3::setRotation(&v14.var0, (float32x4_t *)&v13);
  float32x4_t v12 = *(float32x4_t *)(*((void *)this + 3) + 352);
  float v7 = *((float *)this + 38);
  if ((*(unsigned int (**)(btC3DDynamicCharacterController *))(*(void *)this + 96))(this))
  {
    float32x4_t v8 = vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3E4CCCCDu));
LABEL_5:
    *(float32x4_t *)(*((void *)this + 3) + 352) = v8;
    goto LABEL_6;
  }
  int8x16_t v9 = (int8x16_t)vmulq_f32(v12, v12);
  int32x2_t v10 = (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL), vpadd_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v9.i8));
  if (sqrtf(*(float *)v10.i32) < *((float *)this + 37))
  {
    *(float *)v10.i32 = (float)(v7 * a3) * 0.0;
    float32x4_t v11 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v11.i32[3] = 0;
    float32x4_t v8 = vaddq_f32(v12, v11);
    goto LABEL_5;
  }
LABEL_6:
  (*(void (**)(void, btTransform *))(**(void **)(*((void *)this + 3) + 536) + 24))(*(void *)(*((void *)this + 3) + 536), &v14);
  btRigidBody::setCenterOfMassTransform(*((btRigidBody **)this + 3), &v14);
}

uint64_t btC3DDynamicCharacterController::canJump(btC3DDynamicCharacterController *this)
{
  return 1;
}

uint64_t btC3DDynamicCharacterController::onGround(btC3DDynamicCharacterController *this)
{
  return 1;
}

void btC3DDynamicCharacterController::preStep(btCollisionWorld *)::ClosestNotMe::~ClosestNotMe()
{
}

uint64_t btCollisionWorld::RayResultCallback::needsCollision(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  BOOL v3 = (a1[4] & v2) != 0 && (*(void *)(a2 + 16) & a1[3]) != 0;
  return (a1[5] & v2) != 0 || v3;
}

float btC3DDynamicCharacterController::preStep(btCollisionWorld *)::ClosestNotMe::addSingleResult(float32x4_t *a1, uint64_t a2, int a3)
{
  if (*(void *)a2 == a1[8].i64[0]) {
    return 1.0;
  }
  else {
    return btCollisionWorld::ClosestRayResultCallback::addSingleResult(a1, a2, a3);
  }
}

float btCollisionWorld::ClosestRayResultCallback::addSingleResult(float32x4_t *a1, uint64_t a2, int a3)
{
  a1->i32[2] = *(_DWORD *)(a2 + 32);
  BOOL v3 = *(float32x4_t **)a2;
  a1[1].i64[0] = *(void *)a2;
  float32x4_t v4 = *(float32x4_t *)(a2 + 16);
  if (!a3)
  {
    int8x16_t v5 = (int8x16_t)vmulq_f32(v3[1], v4);
    int8x16_t v6 = (int8x16_t)vmulq_f32(v4, v3[2]);
    int8x16_t v7 = (int8x16_t)vmulq_f32(v4, v3[3]);
    v7.i32[3] = 0;
    *(float32x2_t *)v4.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v5.i8, *(float32x2_t *)v6.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)));
    *(float32x2_t *)&v4.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)), 0);
  }
  a1[6] = v4;
  a1[7] = vaddq_f32(a1[4], vmulq_n_f32(vsubq_f32(a1[5], a1[4]), *(float *)(a2 + 32)));
  return *(float *)(a2 + 32);
}

float btMatrix3x3::setRotation(btMatrix3x3 *this, float32x4_t *a2)
{
  float32x4_t v2 = vmulq_f32(*a2, *a2);
  v2.i64[0] = vpaddq_f32(v2, v2).u64[0];
  v2.f32[0] = 2.0 / vpadd_f32(*(float32x2_t *)v2.f32, *(float32x2_t *)v2.f32).f32[0];
  float v3 = v2.f32[0] * COERCE_FLOAT(*a2);
  float v4 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  v2.f32[0] = vmuls_lane_f32(v2.f32[0], *a2, 2);
  float v5 = vmuls_lane_f32(v3, *a2, 3);
  float v6 = vmuls_lane_f32(v4, *a2, 3);
  float v7 = vmuls_lane_f32(v2.f32[0], *a2, 3);
  float v8 = v3 * COERCE_FLOAT(*a2);
  float v9 = v4 * COERCE_FLOAT(*a2);
  float v10 = v2.f32[0] * COERCE_FLOAT(*a2);
  float v11 = vmuls_lane_f32(v4, *(float32x2_t *)a2->f32, 1);
  float v12 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  float v13 = vmuls_lane_f32(v2.f32[0], *a2, 2);
  this->var0[0].var0.var0[0] = 1.0 - (float)(v11 + v13);
  this->var0[0].var0.var0[1] = v9 - v7;
  this->var0[0].var0.var0[2] = v10 + v6;
  this->var0[0].var0.var0[3] = 0.0;
  this->var0[1].var0.var0[0] = v9 + v7;
  this->var0[1].var0.var0[1] = 1.0 - (float)(v8 + v13);
  this->var0[1].var0.var0[2] = v12 - v5;
  this->var0[1].var0.var0[3] = 0.0;
  this->var0[2].var0.var0[0] = v10 - v6;
  this->var0[2].var0.var0[1] = v12 + v5;
  float result = 1.0 - (float)(v8 + v11);
  *(void *)&this->var0[2].var0.var0[2] = LODWORD(result);
  return result;
}

long long *btTransform::getIdentity(btTransform *this)
{
  {
    if (v2)
    {
      __n128 Identity = btMatrix3x3::getIdentity(v2);
      long long v4 = Identity[1];
      btTransform::getIdentity(void)::identityTransforuint64_t m = *Identity;
      unk_2676940C0 = v4;
      xmmword_2676940D0 = Identity[2];
      qword_2676940E0 = 0;
      unk_2676940E8 = 0;
    }
  }
  return &btTransform::getIdentity(void)::identityTransform;
}

void sub_20B3456D8(_Unwind_Exception *a1)
{
}

long long *btMatrix3x3::getIdentity(btMatrix3x3 *this)
{
  {
    btMatrix3x3::getIdentity(void)::identityMatrifloat x = xmmword_20B5CB820;
    *(_OWORD *)algn_267694110 = xmmword_20B5CB7D0;
    xmmword_267694120 = xmmword_20B5CB520;
  }
  return &btMatrix3x3::getIdentity(void)::identityMatrix;
}

__n128 btDefaultMotionState::getWorldTransform(btDefaultMotionState *this, btTransform *a2)
{
  float32x4_t v2 = *((float32x4_t *)this + 5);
  float32x4_t v3 = *((float32x4_t *)this + 6);
  float32x4_t v4 = *((float32x4_t *)this + 7);
  float32x4_t v6 = *((float32x4_t *)this + 1);
  float32x4_t v5 = *((float32x4_t *)this + 2);
  float32x4_t v8 = *((float32x4_t *)this + 3);
  float32x4_t v7 = *((float32x4_t *)this + 4);
  float32x4_t v9 = (float32x4_t)vtrn1q_s32((int32x4_t)v2, (int32x4_t)v3);
  v10.i64[0] = vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL).u64[0];
  v10.i64[1] = vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u32[0];
  v11.i64[0] = 0x8000000080000000;
  v11.i64[1] = 0x8000000080000000;
  float32x4_t v12 = (float32x4_t)veorq_s8(*((int8x16_t *)this + 8), v11);
  int8x16_t v13 = (int8x16_t)vmulq_f32(v10, v12);
  v13.i32[3] = 0;
  v8.i32[3] = 0;
  v5.i32[3] = 0;
  int32x2_t v14 = vzip2_s32(*(int32x2_t *)v4.f32, 0);
  v6.i32[3] = 0;
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v6, v2, 2), v5, v3, 2), v8, v4, 2);
  float32x4_t v16 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v6, *(float32x2_t *)v2.f32, 1), v5, *(float32x2_t *)v3.f32, 1), v8, *(float32x2_t *)v4.f32, 1);
  float32x4_t v17 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v6, v2.f32[0]), v5, v3.f32[0]), v8, v4.f32[0]);
  v9.i64[1] = v4.u32[0];
  int8x16_t v18 = (int8x16_t)vmulq_f32(v9, v12);
  *(int32x2_t *)v2.f32 = vzip2_s32(*(int32x2_t *)v2.f32, *(int32x2_t *)v3.f32);
  *(int32x2_t *)&v2.u32[2] = v14;
  int8x16_t v19 = (int8x16_t)vmulq_f32(v2, v12);
  *(float32x2_t *)v19.i8 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL)), vpadd_f32(*(float32x2_t *)v18.i8, *(float32x2_t *)v19.i8));
  int8x16_t v20 = (int8x16_t)vmulq_f32(v10, v7);
  v20.i32[3] = 0;
  int8x16_t v21 = (int8x16_t)vmulq_f32(v9, v7);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v2, v7);
  result.n128_u64[0] = (unint64_t)vadd_f32(*(float32x2_t *)v19.i8, vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), vpadd_f32(*(float32x2_t *)v21.i8, *(float32x2_t *)v22.i8)));
  *(float32x2_t *)&result.n128_i8[8] = vadd_f32(vpadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL)), 0), vpadd_f32(vpadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL)), 0));
  a2->var0.var0[0] = (btVector3)v17;
  a2->var0.var0[1] = (btVector3)v16;
  a2->var0.var0[2] = (btVector3)v15;
  a2->var1 = (btVector3)result;
  return result;
}

__n128 btDefaultMotionState::setWorldTransform(float32x4_t *this, const btTransform *a2)
{
  __n128 result = (__n128)a2->var0.var0[0];
  float32x4_t v3 = (float32x4_t)a2->var0.var0[1];
  float32x4_t v4 = this[5];
  float32x4_t v5 = this[6];
  float32x4_t v6 = this[7];
  float32x4_t v7 = this[8];
  float32x4_t v8 = (float32x4_t)a2->var0.var0[2];
  float32x4_t v9 = vmulq_f32((float32x4_t)a2->var0.var0[0], v7);
  int8x16_t v10 = (int8x16_t)vmulq_f32(v3, v7);
  *(float32x2_t *)v9.f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL)), vpadd_f32(*(float32x2_t *)v9.f32, *(float32x2_t *)v10.i8));
  int8x16_t v11 = (int8x16_t)vmulq_f32(v8, v7);
  v11.i32[3] = 0;
  *(float32x2_t *)&v9.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL)), 0);
  v6.i32[3] = 0;
  float32x4_t v12 = vaddq_f32((float32x4_t)a2->var1, v9);
  v5.i32[3] = 0;
  v4.i32[3] = 0;
  this[1] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v4, COERCE_FLOAT(*(_OWORD *)a2->var0.var0)), v5, *(float32x2_t *)a2->var0.var0[0].var0.var0, 1), v6, (float32x4_t)a2->var0.var0[0], 2);
  this[2] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v4, v3.f32[0]), v5, *(float32x2_t *)v3.f32, 1), v6, v3, 2);
  this[3] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v4, v8.f32[0]), v5, *(float32x2_t *)v8.f32, 1), v6, v8, 2);
  this[4] = v12;
  return result;
}

void *C3DEngineStatsEndFrameAndCopy(int *a1, uint64_t a2, uint64_t a3)
{
  double v5 = 0.0;
  double v6 = 1.17549435e-38;
  double v7 = 3.40282347e38;
  for (uint64_t i = 88; i != 208; i += 2)
  {
    double v9 = *(double *)&a1[i];
    if (v7 >= v9) {
      double v7 = *(double *)&a1[i];
    }
    if (v6 < v9) {
      double v6 = *(double *)&a1[i];
    }
    double v5 = v5 + v9;
  }
  *((double *)a1 + 42) = v7;
  *((double *)a1 + 43) = v6;
  *((double *)a1 + 41) = v5 / 60.0;
  unsigned int v50 = a1[2];
  unsigned int v51 = a1[1];
  unsigned int v10 = a1[4];
  int v52 = a1[3];
  unsigned int v53 = *a1;
  unsigned int v11 = a1[6];
  unsigned int v12 = a1[7];
  unsigned int v13 = a1[9];
  unsigned int v14 = a1[10];
  unsigned int v15 = a1[11];
  unsigned int v16 = a1[12];
  unsigned int v46 = a1[5];
  unsigned int v47 = a1[13];
  unsigned int v48 = a1[14];
  int v49 = a1[8];
  long long v17 = *(_OWORD *)(a1 + 15);
  long long v18 = *(_OWORD *)(a1 + 19);
  int v65 = a1[23];
  long long v63 = v17;
  long long v64 = v18;
  float64x2_t v43 = *((float64x2_t *)a1 + 7);
  float64x2_t v44 = *((float64x2_t *)a1 + 6);
  float64x2_t v45 = *((float64x2_t *)a1 + 9);
  float64x2_t v40 = *((float64x2_t *)a1 + 10);
  float64x2_t v41 = *((float64x2_t *)a1 + 11);
  float64x2_t v42 = *((float64x2_t *)a1 + 8);
  double v19 = *((double *)a1 + 24);
  long long v20 = *(_OWORD *)(a1 + 50);
  long long v21 = *(_OWORD *)(a1 + 54);
  long long v22 = *(_OWORD *)(a1 + 62);
  long long v57 = *(_OWORD *)(a1 + 58);
  long long v58 = v22;
  long long v55 = v20;
  long long v56 = v21;
  long long v23 = *(_OWORD *)(a1 + 66);
  long long v24 = *(_OWORD *)(a1 + 70);
  long long v25 = *(_OWORD *)(a1 + 74);
  uint64_t v62 = *((void *)a1 + 39);
  long long v60 = v24;
  long long v61 = v25;
  long long v59 = v23;
  __n128 result = memcpy(__dst, a1 + 80, sizeof(__dst));
  if (v10 <= 1) {
    unsigned int v27 = 1;
  }
  else {
    unsigned int v27 = v10;
  }
  if (a2)
  {
    uint64_t v62 = *(void *)(a2 + 312);
    long long v28 = *(_OWORD *)(a2 + 232);
    long long v56 = *(_OWORD *)(a2 + 216);
    long long v57 = v28;
    long long v29 = *(_OWORD *)(a2 + 264);
    long long v30 = *(_OWORD *)(a2 + 280);
    long long v58 = *(_OWORD *)(a2 + 248);
    long long v59 = v29;
    long long v31 = *(_OWORD *)(a2 + 296);
    long long v60 = v30;
    long long v61 = v31;
  }
  if (a3)
  {
    float64x2_t v32 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v27), 0);
    long long v33 = v63;
    *(_OWORD *)(a3 + 76) = v64;
    *(_DWORD *)a3 = v53 / v27;
    *(_DWORD *)(a3 + 4) = v51 / v27;
    *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x2A0], 8) = v50 / v27;
    *(_DWORD *)(a3 + 12) = v52;
    *(_DWORD *)(a3 + 16) = v10;
    *(_DWORD *)(a3 + 20) = v46 / v27;
    *(_DWORD *)(a3 + 24) = v11 / v27;
    *(_DWORD *)(a3 + 2_Block_object_dispose(&STACK[0x2A0], 8) = v12 / v27;
    *(_DWORD *)(a3 + 32) = v49;
    *(_DWORD *)(a3 + 36) = v13 / v27;
    *(_DWORD *)(a3 + 40) = v14 / v27;
    *(_DWORD *)(a3 + 44) = v15 / v27;
    *(_DWORD *)(a3 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v16 / v27;
    *(_DWORD *)(a3 + 52) = v47 / v27;
    *(_DWORD *)(a3 + 56) = v48 / v27;
    *(_DWORD *)(a3 + 92) = v65;
    *(_OWORD *)(a3 + 60) = v33;
    *(float64x2_t *)(a3 + 96) = vdivq_f64(v44, v32);
    *(float64x2_t *)(a3 + 112) = vdivq_f64(v43, v32);
    *(float64x2_t *)(a3 + 12_Block_object_dispose(&STACK[0x2A0], 8) = vdivq_f64(v42, v32);
    *(float64x2_t *)(a3 + 144) = vdivq_f64(v45, v32);
    *(float64x2_t *)(a3 + 160) = vdivq_f64(v40, v32);
    *(float64x2_t *)(a3 + 176) = vdivq_f64(v41, v32);
    *(double *)(a3 + 192) = v19 / (double)v27;
    long long v34 = v55;
    long long v35 = v56;
    long long v36 = v57;
    *(_OWORD *)(a3 + 24_Block_object_dispose(&STACK[0x2A0], 8) = v58;
    *(_OWORD *)(a3 + 232) = v36;
    *(_OWORD *)(a3 + 216) = v35;
    *(_OWORD *)(a3 + 200) = v34;
    long long v37 = v59;
    long long v38 = v60;
    long long v39 = v61;
    *(void *)(a3 + 312) = v62;
    *(_OWORD *)(a3 + 280) = v38;
    *(_OWORD *)(a3 + 296) = v39;
    *(_OWORD *)(a3 + 264) = v37;
    return memcpy((void *)(a3 + 320), __dst, 0x218uLL);
  }
  return result;
}

double C3DEngineStatsResetResourceStats(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineStatsResetResourceStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 216) = 0u;
  unsigned int v11 = (_OWORD *)(a1 + 216);
  v11[5] = 0u;
  v11[6] = 0u;
  _OWORD v11[3] = 0u;
  float32x4_t v11[4] = 0u;
  v11[1] = 0u;
  v11[2] = 0u;
  return result;
}

void C3DEngineStatsMergeResourceStats(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineStatsMergeResourceStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  unint64_t v12 = 216;
  do
  {
    *(_DWORD *)(a2 + v12) += *(_DWORD *)(a1 + v12);
    BOOL v13 = v12 >= 0x144;
    v12 += 4;
  }
  while (!v13);
}

void C3DEngineStatsReset(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineStatsResetResourceStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&STACK[0x2A0], 8) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(CFTimeInterval *)(a1 + 840) = CACurrentMediaTime();
}

CFTimeInterval C3DEngineStatsFinish(uint64_t a1)
{
  if (!a1)
  {
    float32x4_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineStatsResetResourceStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFTimeInterval result = CACurrentMediaTime();
  CFTimeInterval v11 = result - *(double *)(a1 + 848);
  *(CFTimeInterval *)(a1 + 96) = result - *(double *)(a1 + 840);
  *(CFTimeInterval *)(a1 + 84_Block_object_dispose(&STACK[0x2A0], 8) = result;
  uint64_t v12 = *(unsigned int *)(a1 + 832);
  *(CFTimeInterval *)(a1 + 8 * v12 + 352) = v11;
  *(_DWORD *)(a1 + 832) = ((int)v12 + 1) % 0x3Cu;
  ++*(_DWORD *)(a1 + 16);
  return result;
}

void C3D::DownSampleBloomCoCPass::DownSampleBloomCoCPass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *uint64_t v5 = &unk_26BF6E2B0;
  v5[14] = a4;
}

const char *C3D::DownSampleBloomCoCPass::name(C3D::DownSampleBloomCoCPass *this)
{
  return "DownSampleBloomCoCPass";
}

double C3D::DownSampleBloomCoCPass::setup(C3D::DownSampleBloomCoCPass *this)
{
  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(this, *(unsigned __int8 *)(*((void *)this + 14) + 12) + *(unsigned __int8 *)(*((void *)this + 14) + 10));
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::DownSampleBloomCoCPass *)((char *)this + 32), 0) + 64) = 2;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::DownSampleBloomCoCPass *)((char *)this + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::DownSampleBloomCoCPass *)((char *)this + 32), 2u) + _Block_object_dispose(&STACK[0x2A0], 8) = "AverageLuminance";
  uint64_t v2 = (*(uint64_t (**)(C3D::DownSampleBloomCoCPass *))(*(void *)this + 88))(this);
  uint64_t v4 = *((void *)this + 14);
  if (*(unsigned char *)(v4 + 10))
  {
    uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::DownSampleBloomCoCPass *)((char *)this + 32), 0);
    *(_WORD *)(v5 + 16) = (int)fmax((float)((float)(*(float *)(v2 + 8) * 0.5) / **((float **)this + 14)), 1.0);
    double result = fmax((float)((float)(*(float *)(v2 + 12) * 0.5) / **((float **)this + 14)), 1.0);
    *(_WORD *)(v5 + 1_Block_object_dispose(&STACK[0x2A0], 8) = (int)result;
    *(unsigned char *)(v5 + 30) = *(_DWORD *)(*((void *)this + 14) + 24);
    *(_WORD *)(v5 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 115;
    *(void *)(v5 + _Block_object_dispose(&STACK[0x2A0], 8) = "Bloom";
    uint64_t v4 = *((void *)this + 14);
  }
  if (*(unsigned char *)(v4 + 12))
  {
    uint64_t v6 = C3D::PassDescriptor::outputAtIndex((C3D::DownSampleBloomCoCPass *)((char *)this + 32), *(unsigned __int8 *)(v4 + 10));
    *(_WORD *)(v6 + 16) = (int)fmax((float)((float)(*(float *)(v2 + 8) * 0.5) / **((float **)this + 14)), 1.0);
    double result = fmax((float)((float)(*(float *)(v2 + 12) * 0.5) / **((float **)this + 14)), 1.0);
    *(_WORD *)(v6 + 1_Block_object_dispose(&STACK[0x2A0], 8) = (int)result;
    *(_WORD *)(v6 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 115;
    *(void *)(v6 + _Block_object_dispose(&STACK[0x2A0], 8) = "DofColorCoC";
  }
  return result;
}

uint64_t C3D::DownSampleBloomCoCPass::compile(C3D::DownSampleBloomCoCPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::DownSampleBloomCoCPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v3);
  *((void *)this + 15) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::DownSampleBloomCoCPass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(SCNMTLComputeCommandEncoder **)a2;
  __n128 ViewportAtIndex = C3DEngineContextGetViewportAtIndex(a1[2], *(unsigned __int16 *)(a2 + 8));
  int32x4_t v30 = (int32x4_t)xmmword_20B5CD060;
  if (C3DEngineContextGetEyeCount(a1[2]) >= 2)
  {
    int8x16_t v29 = vextq_s8((int8x16_t)ViewportAtIndex, (int8x16_t)ViewportAtIndex, 8uLL);
    int32x4_t v4 = *(int32x4_t *)(*(uint64_t (**)(uint64_t *))(*a1 + 88))(a1);
    int32x2_t v26 = (int32x2_t)vextq_s8(v29, v29, 8uLL).u64[0];
    *(float32x2_t *)v4.i8 = vdiv_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v29.i8, v26), (float32x2_t)vdup_laneq_s32(v4, 2));
    int32x4_t v27 = v4;
    int32x4_t v5 = *(int32x4_t *)(*(uint64_t (**)(uint64_t *))(*a1 + 88))(a1);
    *(float32x2_t *)v5.i8 = vdiv_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v29.i8, v26), (float32x2_t)vdup_laneq_s32(v5, 3));
    int32x4_t v30 = vzip1q_s32(v27, v5);
  }
  uint64_t v6 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  if ((void **)v3->_textures[0] != v6)
  {
    v3->_textures[0] = (MTLTexture *)v6;
    v3->_texturesToBind[0] |= 1uLL;
  }
  uint64_t v7 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
  if ((void **)v3->_textures[1] != v7)
  {
    v3->_textures[1] = (MTLTexture *)v7;
    v3->_texturesToBind[0] |= 2uLL;
  }
  uint64_t v8 = a1[14];
  if (*(unsigned char *)(v8 + 12))
  {
    uint64_t v9 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, *(unsigned __int8 *)(v8 + 10));
    if (v3->_textures[2] != v9)
    {
      v3->_textures[2] = v9;
      v3->_texturesToBind[0] |= 4uLL;
    }
  }
  if (*(unsigned char *)(a1[14] + 10))
  {
    uint64_t v10 = (MTLTexture *)C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
    if (v3->_textures[3] != v10)
    {
      v3->_textures[3] = v10;
      v3->_texturesToBind[0] |= 8uLL;
    }
  }
  CFTimeInterval v11 = (void *)a1[14];
  BOOL v13 = (MTLBuffer *)v11[5];
  unint64_t v12 = v11[6];
  if (v3->_buffers[0] == v13)
  {
    if (v3->_offsets[0] == v12) {
      goto LABEL_17;
    }
  }
  else
  {
    v3->_buffers[0] = v13;
    CFTimeInterval v11 = (void *)a1[14];
  }
  v3->_offsets[0] = v12;
  v3->_buffersToBind[0] |= 1uLL;
LABEL_17:
  unsigned int v14 = (MTLBuffer *)v11[7];
  if (v3->_buffers[1] == v14)
  {
    if (!v3->_offsets[1]) {
      goto LABEL_21;
    }
  }
  else
  {
    v3->_buffers[1] = v14;
  }
  v3->_offsets[1] = 0;
  v3->_buffersToBind[0] |= 2uLL;
LABEL_21:
  SCNMTLComputeCommandEncoder::setBytes(v3, &v30, 0x10uLL, 2uLL);
  uint64_t v15 = a1[14];
  uint64_t v16 = (int)(float)((float)(*(float *)v15 + -1.0) * 3.0);
  if (*(unsigned char *)(v15 + 10))
  {
    int v17 = *(unsigned __int8 *)(v15 + 12);
    long long v18 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
    uint64_t v19 = a1[15] + 8 * v16;
    uint64_t v20 = v19 + 16;
    uint64_t v21 = v19 + 32;
    if (v17) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = v20;
    }
  }
  else
  {
    long long v18 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
    uint64_t v22 = a1[15] + 8 * v16 + 24;
  }
  uint64_t v23 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(v22);
  long long v24 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v23);
  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v18, v24);
}

void C3D::DownSampleBloomCoCPassResource::~DownSampleBloomCoCPassResource(C3D::DownSampleBloomCoCPassResource *this)
{
  *(void *)this = &unk_26BF6E6A0;
  for (uint64_t i = 56; i != 8; i -= 8)
  {
    uint64_t v3 = *(void **)((char *)this + i);
    if (v3) {
  }
    }
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E6A0;
  uint64_t v2 = 56;
  while (1)
  {
    uint64_t v3 = *(void **)((char *)this + v2);
    if (v3) {

    }
    v2 -= 8;
    if (v2 == 8)
    {
      JUMPOUT(0x210534FE0);
    }
  }
}

uint64_t _fillInfoFromFormat(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  if (a4 == a3) {
    return 0;
  }
  uint64_t v5 = 0;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x2A0], 8) = a5;
  *(_WORD *)(a1 + 7) = 257;
  *(unsigned char *)(a1 + 9) = 1;
  if (a4 > 36755)
  {
    if (a4 > 37807)
    {
      switch(a4)
      {
        case 37808:
        case 37840:
          int v6 = 2;
          goto LABEL_66;
        case 37809:
        case 37841:
          *(_DWORD *)a1 = 2;
          int v7 = 83952768;
          goto LABEL_86;
        case 37810:
        case 37842:
          *(_DWORD *)a1 = 2;
          int v14 = 83952768;
          goto LABEL_49;
        case 37811:
        case 37843:
          *(_DWORD *)a1 = 2;
          int v14 = 100729984;
          goto LABEL_49;
        case 37812:
        case 37844:
          *(_DWORD *)a1 = 2;
          int v15 = 100729984;
          goto LABEL_51;
        case 37813:
        case 37845:
          *(_DWORD *)a1 = 2;
          int v14 = 134284416;
          goto LABEL_49;
        case 37814:
        case 37846:
          *(_DWORD *)a1 = 2;
          int v15 = 134284416;
          goto LABEL_51;
        case 37815:
        case 37847:
          *(_DWORD *)a1 = 2;
          int v16 = 134284416;
          goto LABEL_53;
        case 37816:
        case 37848:
          *(_DWORD *)a1 = 2;
          int v14 = 167838848;
LABEL_49:
          *(_DWORD *)(a1 + 4) = v14;
          char v8 = 5;
          goto LABEL_87;
        case 37817:
        case 37849:
          *(_DWORD *)a1 = 2;
          int v15 = 167838848;
LABEL_51:
          *(_DWORD *)(a1 + 4) = v15;
          char v8 = 6;
          goto LABEL_87;
        case 37818:
        case 37850:
          *(_DWORD *)a1 = 2;
          int v16 = 167838848;
LABEL_53:
          *(_DWORD *)(a1 + 4) = v16;
          char v8 = 8;
          goto LABEL_87;
        case 37819:
        case 37851:
          *(_DWORD *)a1 = 2;
          int v17 = 167838848;
          goto LABEL_56;
        case 37820:
        case 37852:
          *(_DWORD *)a1 = 2;
          int v17 = 201393280;
LABEL_56:
          *(_DWORD *)(a1 + 4) = v17;
          char v8 = 10;
          goto LABEL_87;
        case 37821:
        case 37853:
          *(_DWORD *)a1 = 2;
          *(_DWORD *)(a1 + 4) = 201393280;
          char v8 = 12;
          goto LABEL_87;
        default:
          return v5;
      }
    }
    switch(a4)
    {
      case 37488:
      case 37489:
        *(_DWORD *)a1 = 5;
        int v7 = 67109184;
        goto LABEL_86;
      case 37490:
      case 37491:
        *(_DWORD *)a1 = 5;
        int v7 = 67109504;
        goto LABEL_86;
      case 37492:
      case 37493:
        int v12 = 5;
        goto LABEL_60;
      case 37494:
      case 37495:
        int v13 = 5;
        goto LABEL_85;
      case 37496:
      case 37497:
        int v6 = 5;
        goto LABEL_66;
      default:
        switch(a4)
        {
          case 36756:
            goto LABEL_26;
          case 36757:
            goto LABEL_69;
          case 36758:
          case 36762:
            return v5;
          case 36759:
            *(unsigned char *)(a1 + 6) = 1;
            *(_WORD *)(a1 + 4) = 1056;
LABEL_119:
            LODWORD(v5) = 72;
            goto LABEL_210;
          case 36760:
            goto LABEL_70;
          case 36761:
            goto LABEL_71;
          case 36763:
            goto LABEL_72;
          default:
            if (a4 == 36975) {
              goto LABEL_79;
            }
            break;
        }
        break;
    }
    return v5;
  }
  if (a4 > 35839)
  {
    if (a4 > 36193)
    {
      if (a4 > 36491)
      {
        if ((a4 - 36492) < 2)
        {
          char v8 = 4;
          *(_DWORD *)a1 = 4;
          int v9 = 67175552;
        }
        else
        {
          if ((a4 - 36494) >= 2) {
            return v5;
          }
          char v8 = 4;
          *(_DWORD *)a1 = 4;
          int v9 = 67109760;
        }
      }
      else if ((a4 - 36283) < 2)
      {
        char v8 = 4;
        *(_DWORD *)a1 = 4;
        int v9 = 67109184;
      }
      else
      {
        if ((a4 - 36285) >= 2)
        {
          if (a4 != 36194) {
            return v5;
          }
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 784;
          goto LABEL_118;
        }
        char v8 = 4;
        *(_DWORD *)a1 = 4;
        int v9 = 67109504;
      }
      *(_DWORD *)(a1 + 4) = v9;
      goto LABEL_87;
    }
    if (a4 > 35900)
    {
      if (a4 <= 35917)
      {
        if (a4 == 35901)
        {
LABEL_74:
          *(unsigned char *)(a1 + 6) = 1;
          __int16 v10 = 800;
LABEL_80:
          *(_WORD *)(a1 + 4) = v10;
          goto LABEL_88;
        }
        if (a4 == 35907)
        {
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1056;
          BOOL v18 = a3 == 32993;
          LODWORD(v5) = 71;
          int v19 = 81;
LABEL_139:
          if (v18) {
            LODWORD(v5) = v19;
          }
          goto LABEL_210;
        }
        int v11 = 35917;
LABEL_83:
        if (a4 != v11) {
          return v5;
        }
        int v13 = 3;
LABEL_85:
        *(_DWORD *)a1 = v13;
        int v7 = 67175488;
        goto LABEL_86;
      }
      if ((a4 - 35918) >= 2) {
        return v5;
      }
LABEL_65:
      int v6 = 3;
LABEL_66:
      *(_DWORD *)a1 = v6;
      int v7 = 67175552;
LABEL_86:
      *(_DWORD *)(a1 + 4) = v7;
      char v8 = 4;
LABEL_87:
      *(unsigned char *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = v8;
LABEL_88:
      uint64_t v5 = 1;
      if (a4 > 36755)
      {
        if (a4 > 37807)
        {
          switch(a4)
          {
            case 37808:
              LODWORD(v5) = 204;
              goto LABEL_210;
            case 37809:
              LODWORD(v5) = 205;
              goto LABEL_210;
            case 37810:
              LODWORD(v5) = 206;
              goto LABEL_210;
            case 37811:
              LODWORD(v5) = 207;
              goto LABEL_210;
            case 37812:
              LODWORD(v5) = 208;
              goto LABEL_210;
            case 37813:
              LODWORD(v5) = 210;
              goto LABEL_210;
            case 37814:
              LODWORD(v5) = 211;
              goto LABEL_210;
            case 37815:
              LODWORD(v5) = 212;
              goto LABEL_210;
            case 37816:
              LODWORD(v5) = 213;
              goto LABEL_210;
            case 37817:
              LODWORD(v5) = 214;
              goto LABEL_210;
            case 37818:
              LODWORD(v5) = 215;
              goto LABEL_210;
            case 37819:
              LODWORD(v5) = 216;
              goto LABEL_210;
            case 37820:
              LODWORD(v5) = 217;
              goto LABEL_210;
            case 37821:
              LODWORD(v5) = 218;
              goto LABEL_210;
            case 37840:
              LODWORD(v5) = 186;
              goto LABEL_210;
            case 37841:
              LODWORD(v5) = 187;
              goto LABEL_210;
            case 37842:
              LODWORD(v5) = 188;
              goto LABEL_210;
            case 37843:
              LODWORD(v5) = 189;
              goto LABEL_210;
            case 37844:
              LODWORD(v5) = 190;
              goto LABEL_210;
            case 37845:
              LODWORD(v5) = 192;
              goto LABEL_210;
            case 37846:
              LODWORD(v5) = 193;
              goto LABEL_210;
            case 37847:
              LODWORD(v5) = 194;
              goto LABEL_210;
            case 37848:
              LODWORD(v5) = 195;
              goto LABEL_210;
            case 37849:
              LODWORD(v5) = 196;
              goto LABEL_210;
            case 37850:
              LODWORD(v5) = 197;
              goto LABEL_210;
            case 37851:
              LODWORD(v5) = 198;
              goto LABEL_210;
            case 37852:
              LODWORD(v5) = 199;
              goto LABEL_210;
            case 37853:
              LODWORD(v5) = 200;
              goto LABEL_210;
            default:
              return v5;
          }
          return v5;
        }
        switch(a4)
        {
          case 37488:
            LODWORD(v5) = 170;
            break;
          case 37489:
            LODWORD(v5) = 172;
            break;
          case 37490:
            LODWORD(v5) = 174;
            break;
          case 37491:
            LODWORD(v5) = 176;
            break;
          case 37492:
            LODWORD(v5) = 180;
            break;
          case 37493:
            LODWORD(v5) = 181;
            break;
          case 37494:
            LODWORD(v5) = 182;
            break;
          case 37495:
            LODWORD(v5) = 183;
            break;
          case 37496:
            LODWORD(v5) = 178;
            break;
          case 37497:
            LODWORD(v5) = 179;
            break;
          default:
            switch(a4)
            {
              case 36756:
                LODWORD(v5) = 12;
                goto LABEL_210;
              case 36757:
                LODWORD(v5) = 32;
                goto LABEL_210;
              case 36758:
              case 36762:
                return v5;
              case 36759:
                goto LABEL_119;
              case 36760:
                LODWORD(v5) = 22;
                goto LABEL_210;
              case 36761:
                LODWORD(v5) = 62;
                goto LABEL_210;
              case 36763:
                LODWORD(v5) = 112;
                goto LABEL_210;
              default:
                if (a4 != 36975) {
                  return v5;
                }
                LODWORD(v5) = 91;
                break;
            }
            break;
        }
LABEL_210:
        *(_DWORD *)(a1 + 36) = v5;
        return 1;
      }
      if (a4 <= 34835)
      {
        uint64_t v5 = 25;
        switch(a4)
        {
          case 33321:
            LODWORD(v5) = 10;
            goto LABEL_210;
          case 33322:
            LODWORD(v5) = 20;
            goto LABEL_210;
          case 33323:
            LODWORD(v5) = 30;
            goto LABEL_210;
          case 33324:
            LODWORD(v5) = 60;
            goto LABEL_210;
          case 33325:
            goto LABEL_210;
          case 33326:
            goto LABEL_132;
          case 33327:
            goto LABEL_134;
          case 33328:
            goto LABEL_136;
          case 33329:
            LODWORD(v5) = 14;
            goto LABEL_210;
          case 33330:
            LODWORD(v5) = 13;
            goto LABEL_210;
          case 33331:
            LODWORD(v5) = 24;
            goto LABEL_210;
          case 33332:
            LODWORD(v5) = 23;
            goto LABEL_210;
          case 33333:
            LODWORD(v5) = 54;
            goto LABEL_210;
          case 33334:
            LODWORD(v5) = 53;
            goto LABEL_210;
          case 33335:
            LODWORD(v5) = 34;
            goto LABEL_210;
          case 33336:
            LODWORD(v5) = 33;
            goto LABEL_210;
          case 33337:
            LODWORD(v5) = 64;
            goto LABEL_210;
          case 33338:
            LODWORD(v5) = 63;
            goto LABEL_210;
          case 33339:
            LODWORD(v5) = 104;
            goto LABEL_210;
          case 33340:
            LODWORD(v5) = 103;
            goto LABEL_210;
          default:
            if (a4 == 32857)
            {
              LODWORD(v5) = 90;
            }
            else
            {
              if (a4 != 32859) {
                return v5;
              }
              LODWORD(v5) = 110;
            }
            break;
        }
        goto LABEL_210;
      }
      if (a4 <= 35897)
      {
        if (a4 <= 35839)
        {
          switch(a4)
          {
            case 35412:
              LODWORD(v5) = 161;
              goto LABEL_210;
            case 35413:
              LODWORD(v5) = 163;
              goto LABEL_210;
            case 35414:
              LODWORD(v5) = 165;
              goto LABEL_210;
            case 35415:
              LODWORD(v5) = 167;
              goto LABEL_210;
            default:
              if (a4 == 34836) {
                goto LABEL_123;
              }
              if (a4 == 34842) {
                goto LABEL_122;
              }
              return v5;
          }
        }
        switch(a4)
        {
          case 35840:
            LODWORD(v5) = 162;
            goto LABEL_210;
          case 35841:
            LODWORD(v5) = 160;
            goto LABEL_210;
          case 35842:
            LODWORD(v5) = 166;
            goto LABEL_210;
          case 35843:
            LODWORD(v5) = 164;
            goto LABEL_210;
          default:
            return v5;
        }
        return v5;
      }
      if (a4 > 36213)
      {
        if (a4 <= 36225)
        {
          if (a4 == 36214)
          {
            LODWORD(v5) = 113;
          }
          else
          {
            if (a4 != 36220) {
              return v5;
            }
            LODWORD(v5) = 73;
          }
        }
        else
        {
          switch(a4)
          {
            case 36226:
              LODWORD(v5) = 124;
              break;
            case 36232:
              LODWORD(v5) = 114;
              break;
            case 36238:
              LODWORD(v5) = 74;
              break;
            default:
              return v5;
          }
        }
        goto LABEL_210;
      }
      if (a4 <= 35906)
      {
        if (a4 == 35898)
        {
          LODWORD(v5) = 92;
        }
        else
        {
          if (a4 != 35901) {
            return v5;
          }
          LODWORD(v5) = 93;
        }
        goto LABEL_210;
      }
      if (a4 != 36194)
      {
        if (a4 != 36208) {
          return v5;
        }
        LODWORD(v5) = 123;
        goto LABEL_210;
      }
LABEL_118:
      LODWORD(v5) = 40;
      goto LABEL_210;
    }
    switch(a4)
    {
      case 35840:
LABEL_38:
        int v12 = 1;
LABEL_60:
        *(_DWORD *)a1 = v12;
        int v7 = 67109696;
        goto LABEL_86;
      case 35841:
LABEL_34:
        *(_DWORD *)a1 = 1;
        int v7 = 134218560;
        goto LABEL_86;
      case 35842:
LABEL_40:
        int v13 = 1;
        goto LABEL_85;
      case 35843:
LABEL_39:
        *(_DWORD *)a1 = 1;
        int v7 = 134284352;
        goto LABEL_86;
      default:
        if (a4 == 35898) {
          goto LABEL_74;
        }
        break;
    }
  }
  else
  {
    if (a4 <= 33777)
    {
      switch(a4)
      {
        case 33321:
LABEL_26:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v10 = 264;
          goto LABEL_80;
        case 33322:
LABEL_70:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v10 = 272;
          goto LABEL_80;
        case 33323:
LABEL_69:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v10 = 528;
          goto LABEL_80;
        case 33324:
LABEL_71:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v10 = 544;
          goto LABEL_80;
        case 33325:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 272;
          LODWORD(v5) = 25;
          goto LABEL_210;
        case 33326:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 288;
LABEL_132:
          LODWORD(v5) = 55;
          goto LABEL_210;
        case 33327:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 544;
LABEL_134:
          LODWORD(v5) = 65;
          goto LABEL_210;
        case 33328:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 576;
LABEL_136:
          LODWORD(v5) = 105;
          goto LABEL_210;
        default:
          switch(a4)
          {
            case 32854:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v5) = 42;
              goto LABEL_210;
            case 32855:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v5) = 41;
              goto LABEL_210;
            case 32856:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1056;
              BOOL v18 = a3 == 32993;
              LODWORD(v5) = 70;
              int v19 = 80;
              goto LABEL_139;
            case 32857:
LABEL_79:
              *(unsigned char *)(a1 + 6) = 1;
              __int16 v10 = 1056;
              goto LABEL_80;
            case 32858:
              return v5;
            case 32859:
LABEL_72:
              *(unsigned char *)(a1 + 6) = 1;
              __int16 v10 = 1088;
              goto LABEL_80;
            default:
              int v11 = 33777;
              goto LABEL_83;
          }
      }
      return v5;
    }
    if (a4 <= 35411)
    {
      if ((a4 - 33778) >= 2)
      {
        if (a4 == 34836)
        {
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1152;
LABEL_123:
          LODWORD(v5) = 125;
        }
        else
        {
          if (a4 != 34842) {
            return v5;
          }
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1088;
LABEL_122:
          LODWORD(v5) = 115;
        }
        goto LABEL_210;
      }
      goto LABEL_65;
    }
    switch(a4)
    {
      case 35412:
        goto LABEL_34;
      case 35413:
        goto LABEL_38;
      case 35414:
        goto LABEL_39;
      case 35415:
        goto LABEL_40;
      default:
        return v5;
    }
  }
  return v5;
}

uint64_t _loadKTX(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  kdebug_trace();
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _applyCIFilter_cold_2(v2);
    }
  }
  CFDataRef Data = (const __CFData *)C3DImageGetData(a1);
  if (Data)
  {
    CFDataRef v4 = Data;
    CFRetain(Data);
    goto LABEL_6;
  }
  uint64_t URL = C3DImageGetURL(a1);
  if (URL)
  {
    CFDataRef v4 = (const __CFData *)C3DCreateDataWithContentOfURL(URL, 0);
    if (v4)
    {
LABEL_6:
      unint64_t Length = CFDataGetLength(v4);
      if (Length > 0x3F)
      {
        unint64_t v8 = Length;
        BytePtr = CFDataGetBytePtr(v4);
        if (*(void *)BytePtr == 0xBB31312058544BABLL && *((_DWORD *)BytePtr + 2) == 169478669)
        {
          int v11 = BytePtr;
          if (*((_DWORD *)BytePtr + 3) == 67305985)
          {
            _C3DImageDeleteTextureRawDataIfNeeded(a1);
            _C3DImageCreateTextureRawData(a1, 0, 0, COERCE_DOUBLE(vcvt_f32_u32(*(uint32x2_t *)(v11 + 36))));
            if (*((_DWORD *)v11 + 13) == 6) {
              C3DImageSetImageType(a1, 3);
            }
            TextureRawCFDataRef Data = C3DImageGetTextureRawData(a1);
            if (_fillInfoFromFormat(TextureRawData, v13, *((_DWORD *)v11 + 6), *((_DWORD *)v11 + 7), *((_DWORD *)v11 + 8)))
            {
              int v14 = *(_DWORD *)TextureRawData;
              if (!*(_DWORD *)TextureRawData) {
                goto LABEL_24;
              }
              char v15 = (v14 - 5) < 0xFFFFFFFE;
              if (v14 == 2)
              {
                char v15 = C3DASTCIsSupported();
                int v14 = *(_DWORD *)TextureRawData;
              }
              if (v14 == 5) {
                char v15 = C3DASTCIsSupported();
              }
              if (v15)
              {
LABEL_24:
                int v16 = 0;
                unint64_t v17 = *((unsigned int *)v11 + 15) + 64;
                if (*((_DWORD *)v11 + 13) <= 1u) {
                  int v18 = 1;
                }
                else {
                  int v18 = *((_DWORD *)v11 + 13);
                }
                if (*((_DWORD *)v11 + 14) <= 1u) {
                  int v19 = 1;
                }
                else {
                  int v19 = *((_DWORD *)v11 + 14);
                }
                int v32 = v19;
                while (v17 <= v8)
                {
                  int v20 = 0;
                  CFIndex v21 = *(unsigned int *)&v11[v17];
                  v17 += 4;
                  while (1)
                  {
                    unint64_t v22 = v17 + v21;
                    if (v17 + v21 > v8) {
                      break;
                    }
                    CFDataRef v23 = CFDataCreate(0, &v11[v17], v21);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(TextureRawData + 40), v23);
                    CFRelease(v23);
                    unint64_t v17 = (v22 + 3) & 0xFFFFFFFFFFFFFFFCLL;
                    if (v18 == ++v20) {
                      goto LABEL_38;
                    }
                  }
                  long long v24 = scn_default_log();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)uint8_t buf = 67109888;
                    int v34 = v20;
                    __int16 v35 = 1024;
                    *(_DWORD *)long long v36 = v16;
                    *(_WORD *)&_OWORD v36[4] = 2048;
                    *(void *)&v36[6] = v22;
                    *(_WORD *)&v36[14] = 2048;
                    *(void *)&v36[16] = v8;
                    _os_log_error_impl(&dword_20B249000, v24, OS_LOG_TYPE_ERROR, "Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)", buf, 0x22u);
                  }
LABEL_38:
                  ++v16;
                  uint64_t v7 = 1;
                  if (v16 == v32) {
                    goto LABEL_49;
                  }
                }
                int8x16_t v29 = scn_default_log();
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)uint8_t buf = 67109632;
                  int v34 = v16;
                  __int16 v35 = 2048;
                  *(void *)long long v36 = v17;
                  *(_WORD *)&v36[8] = 2048;
                  *(void *)&v36[10] = v8;
                  _os_log_error_impl(&dword_20B249000, v29, OS_LOG_TYPE_ERROR, "Error: overflow reading mip[%d] (%zu > %zu)", buf, 0x1Cu);
                }
                uint64_t v7 = 1;
                goto LABEL_49;
              }
              int32x4_t v30 = scn_default_log();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                int v31 = *(_DWORD *)TextureRawData;
                *(_DWORD *)uint8_t buf = 67109120;
                int v34 = v31;
                _os_log_impl(&dword_20B249000, v30, OS_LOG_TYPE_DEFAULT, "Warning: Compression type %d not supported", buf, 8u);
              }
            }
            else
            {
              int32x4_t v27 = scn_default_log();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                _loadKTX_cold_1(v27);
              }
            }
            _C3DImageDeleteTextureRawDataIfNeeded(a1);
          }
          else
          {
            int32x2_t v26 = scn_default_log();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              _loadKTX_cold_2(v26);
            }
          }
        }
      }
      else
      {
        int v6 = scn_default_log();
        uint64_t v7 = 0;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
LABEL_49:
          CFRelease(v4);
          goto LABEL_50;
        }
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl(&dword_20B249000, v6, OS_LOG_TYPE_DEFAULT, "Warning: KTX file seems too small or is not a KTX", buf, 2u);
      }
      uint64_t v7 = 0;
      goto LABEL_49;
    }
  }
  uint64_t v7 = 0;
LABEL_50:
  kdebug_trace();
  return v7;
}

uint64_t _createKTXDataRepresentation(void *a1)
{
  id v1 = a1;
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v2 = [a1 width];
  uint64_t v3 = [v1 height];
  signed int v4 = [v1 depth];
  if ([v1 textureType] == 5) {
    uint64_t v5 = 6;
  }
  else {
    uint64_t v5 = 1;
  }
  uint64_t v6 = [v1 mipmapLevelCount];
  uint64_t v35 = v6;
  if ([v1 storageMode] == 2)
  {
    uint64_t v32 = v3;
    uint64_t v33 = v2;
    id v7 = objc_alloc_init(MEMORY[0x263F12A50]);
    objc_msgSend(v7, "setTextureType:", objc_msgSend(v1, "textureType"));
    objc_msgSend(v7, "setPixelFormat:", objc_msgSend(v1, "pixelFormat"));
    objc_msgSend(v7, "setWidth:", objc_msgSend(v1, "width"));
    objc_msgSend(v7, "setHeight:", objc_msgSend(v1, "height"));
    objc_msgSend(v7, "setDepth:", objc_msgSend(v1, "depth"));
    objc_msgSend(v7, "setMipmapLevelCount:", objc_msgSend(v1, "mipmapLevelCount"));
    [v7 setUsage:0];
    unint64_t v8 = objc_msgSend((id)objc_msgSend(v1, "device"), "newTextureWithDescriptor:", v7);
    int v9 = objc_msgSend((id)objc_msgSend(v1, "device"), "newCommandQueue");
    __int16 v10 = (void *)[v9 commandBuffer];
    int v11 = (void *)[v10 blitCommandEncoder];
    if (v6)
    {
      uint64_t v13 = 0;
      *(void *)&long long v12 = __PAIR64__(v32, v33);
      signed int v14 = v4;
      do
      {
        uint64_t v15 = 0;
        *(_OWORD *)v34[0].i8 = v12;
        *(void *)&long long v16 = (int)v12;
        *((void *)&v16 + 1) = SDWORD1(v12);
        long long v36 = v16;
        uint64_t v17 = v14;
        do
        {
          long long v40 = v36;
          uint64_t v41 = v17;
          unint64_t v42 = 0;
          uint64_t v43 = 0;
          *(void *)&long long v44 = 0;
          memset(v39, 0, sizeof(v39));
          [v11 copyFromTexture:v1 sourceSlice:v15 sourceLevel:v13 sourceOrigin:&v42 sourceSize:&v40 toTexture:v8 destinationSlice:v15 destinationLevel:v13 destinationOrigin:v39];
          ++v15;
        }
        while (v5 != v15);
        *((uint32x2_t *)&v12 + 1) = v34[1];
        *(uint32x2_t *)&long long v12 = vshl_u32(v34[0], (uint32x2_t)vcgt_s32((int32x2_t)v34[0], (int32x2_t)0x100000001));
        signed int v14 = v17 >> ((int)v17 > 1);
        ++v13;
        uint64_t v6 = v35;
      }
      while (v13 != v35);
    }
    [v11 endEncoding];
    [v10 commit];
    [v10 waitUntilCompleted];

    id v1 = v8;
    uint64_t v3 = v32;
    uint64_t v2 = v33;
  }
  memset(v45, 0, sizeof(v45));
  long long v44 = 0u;
  unint64_t v42 = 0xBB31312058544BABLL;
  uint64_t v43 = 0x40302010A1A0A0DLL;
  uint64_t v18 = [v1 pixelFormat];
  uint64_t v19 = v18;
  if (v18 > 79)
  {
    switch(v18)
    {
      case 'P':
        long long v20 = xmmword_20B5CD0E0;
        goto LABEL_24;
      case 's':
        long long v20 = xmmword_20B5CD110;
        int v23 = 8;
        goto LABEL_26;
      case 'Q':
        long long v20 = xmmword_20B5CD130;
        goto LABEL_24;
    }
LABEL_37:
    int v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      _createKTXDataRepresentation_cold_1(v19);
    }
    return 0;
  }
  switch(v18)
  {
    case 10:
      long long v20 = xmmword_20B5CD100;
      int v21 = 1;
      break;
    case 25:
      long long v20 = xmmword_20B5CD0F0;
      int v21 = 2;
      break;
    case 71:
      long long v20 = xmmword_20B5CD120;
LABEL_24:
      int v23 = 4;
LABEL_26:
      unsigned int v37 = v23;
      int v22 = 6408;
      goto LABEL_27;
    default:
      goto LABEL_37;
  }
  unsigned int v37 = v21;
  int v22 = 6403;
LABEL_27:
  long long v44 = v20;
  LODWORD(v45[0]) = v22;
  if ([v1 textureType] != 2 && objc_msgSend(v1, "textureType") != 5)
  {
    int32x4_t v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      _createKTXDataRepresentation_cold_2(v1);
    }
    return 0;
  }
  DWORD1(v45[0]) = [v1 width];
  DWORD2(v45[0]) = [v1 height];
  *(void *)((char *)v45 + 12) = 0;
  *(void *)((char *)&v45[1] + 4) = __PAIR64__(v6, v5);
  long long v24 = (void *)[MEMORY[0x263EFF990] dataWithCapacity:0];
  [v24 appendBytes:&v42 length:64];
  long long v25 = malloc_type_malloc(v3 * v2 * v37, 0x55733F60uLL);
  if (v6)
  {
    uint64_t v26 = 0;
    int v27 = v3;
    do
    {
      LODWORD(v39[0]) = v2 * v37 * v27;
      [v24 appendBytes:v39 length:4];
      for (uint64_t i = 0; i != v5; ++i)
      {
        memset(v38, 0, 24);
        v38[3] = (int)v2;
        _OWORD v38[4] = v27;
        v38[5] = 1;
        [v1 getBytes:v25 bytesPerRow:(int)(v2 * v37) bytesPerImage:LODWORD(v39[0]) fromRegion:v38 mipmapLevel:v26 slice:i];
        [v24 appendBytes:v25 length:LODWORD(v39[0])];
      }
      LODWORD(v2) = v2 >> ((int)v2 > 1);
      int v27 = v27 >> (v27 > 1);
      ++v26;
    }
    while (v26 != v35);
  }
  free(v25);
  return [v24 copy];
}

void OUTLINED_FUNCTION_0_4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void _C3DRendererElementFinalize(uint64_t a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationRendererElementWillDie", (const void *)a1, 0, 1u);
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 32) = 0;
  }
  signed int v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 48);
  if (v6)
  {
    CFTypeID v7 = CFGetTypeID(*(CFTypeRef *)(a1 + 48));
    if (v7 == C3DMeshElementGetTypeID() || (CFTypeID v8 = CFGetTypeID(v6), v8 == CFNumberGetTypeID()))
    {
      int v9 = *(const void **)(a1 + 48);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
      }
    }
  }
  uint64_t v10 = *(const void **)(a1 + 40);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 40) = 0;
  }
}

const void *C3DGeometryOsdGetCPUSubdividedC3DMesh(uint64_t a1)
{
  C3DSubdivInitializeIfNeeded();
  uint64_t v2 = *(const void **)(a1 + 160);
  if (!v2)
  {
    uint64_t Mesh = (const void *)C3DGeometryGetMesh(a1);
    uint64_t v2 = Mesh;
    if (*(unsigned char *)(a1 + 136))
    {
      kdebug_trace();
      if (C3DGeometryInitSubdivTopologyInfoIfNeeded((__C3DGeometry *)a1))
      {
        C3DGeometrySubdivTopologyInfoInitCreasesAndCorners((void *)(a1 + 136), (uint64_t)v2);
        memset(v6, 0, sizeof(v6));
        C3DSubdivInitCPUPrimvarContext((uint64_t)v6, a1 + 136, (uint64_t)v2);
        C3DSubdivCreateRefiner(a1 + 136);
      }
      CFTypeRef v4 = CFRetain(v2);
    }
    else
    {
      CFTypeRef v4 = CFRetain(Mesh);
      uint64_t v2 = v4;
    }
    *(void *)(a1 + 160) = v4;
  }
  return v2;
}

void C3DSubdivCPUPrimvarContext::~C3DSubdivCPUPrimvarContext(C3DSubdivCPUPrimvarContext *this)
{
  CFTypeRef v4 = (void **)((char *)this + 216);
  std::vector<C3DSubdivCPUPrimvarDataGroup>::__destroy_vector::operator()[abi:nn180100](&v4);
  CFTypeRef v4 = (void **)((char *)this + 192);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 168);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 144);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 120);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 96);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 72);
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v4);
  CFTypeRef v4 = (void **)((char *)this + 48);
  std::vector<C3DSubdivCPUFVarPrimvarInfo>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

void std::vector<C3DSubdivCPUPrimvarDataGroup>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    CFTypeRef v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        std::allocator<C3DSubdivCPUPrimvarDataGroup>::destroy[abi:nn180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<C3DSubdivCPUPrimvarDataGroup>::destroy[abi:nn180100](uint64_t a1, void **a2)
{
  uint64_t v3 = a2 + 6;
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v3);
  uint64_t v3 = a2 + 3;
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v3);
  uint64_t v3 = a2;
  _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(&v3);
}

void _ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn180100Ev(void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112;
        _ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEE7destroyB8nn180100EPS3_((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void _ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEE7destroyB8nn180100EPS3_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 48);
  if (v3)
  {
    *(void *)(a2 + 56) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a2 + 24);
  if (v4)
  {
    *(void *)(a2 + 32) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + _Block_object_dispose(&STACK[0x2A0], 8) = v5;
    operator delete(v5);
  }
}

void std::vector<C3DSubdivCPUFVarPrimvarInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<C3DSubdivCPUFVarPrimvarInfo>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<C3DSubdivCPUFVarPrimvarInfo>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

CFStringRef _C3DRendererElementStateCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DRendererElementState>");
}

CFStringRef _C3DRendererElementStateCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DRendererElementState>");
}

uint64_t C3DRendererElementStateBeginProcessing(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a3);
  C3DRendererElementStateReset(a1, a3);
  uint64_t Scene = C3DEngineContextGetScene(a3);
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 16) = RendererContextGL;
  *(void *)(a1 + 24) = C3DEngineContextGetResourceManager(a3);
  uint64_t LightingSystem = C3DSceneGetLightingSystem(Scene);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = LightingSystem;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;

  return C3DSceneSourcePerformConsistencyCheck(LightingSystem);
}

void C3DRendererElementStateReset(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
  C3DRendererContextUnbindBufferObjects(RendererContextGL);
  __RendererElementStateUnbindLastUsedCommonProfile(a1, 1);
  C3DRendererContextBindProgramObject(RendererContextGL, 0);
  uint64_t v13 = *(const void **)(a1 + 328);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 32_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 412) = -1;
  *(void *)(a1 + 424) = -1;
  if (!*(_DWORD *)(a1 + 404)) {
    C3DRendererContextSetEnableWriteToDepth(RendererContextGL, 1);
  }
  *(_DWORD *)(a1 + 404) = -1;
  if (!*(_DWORD *)(a1 + 408)) {
    C3DRendererContextSetEnableReadsFromDepth(RendererContextGL, 1);
  }
  *(_DWORD *)(a1 + 40_Block_object_dispose(&STACK[0x2A0], 8) = -1;
  *(_DWORD *)(a1 + 420) = 0;
}

void __RendererElementStateUnbindLastUsedCommonProfile(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 56);
    if (v3)
    {
      C3DRendererContextUnbindCommonProfile(*(void *)(a1 + 16), v3, a1 + 64);
      C3DRendererContextUnbindTextureUnits(*(void *)(a1 + 16));
      *(void *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)(a1 + 400) = 0;
}

void C3DRendererElementStateEndProcessing(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 && (uint64_t v5 = scn_default_log(), os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererElementStateCreate_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v13 = scn_default_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
    C3DEngineContextGetStats_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
LABEL_6:
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(a3);
  C3DRendererElementStateReset(a1, a3);
  uint64_t v22 = C3DBlendStatesDefaultReplace();
  C3DRendererContextSetBlendStates(RendererContextGL, v22);
  C3DLightingSystemEndProcessing(*(void *)(a1 + 40), a3, v23);
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
}

uint64_t __getShaderModifierOwner(uint64_t a1, int a2)
{
  if (a2 == 1) {
    return C3DRendererElementGetGeometry(a1);
  }
  if (a2) {
    return 0;
  }
  return C3DRendererElementGetMaterial(a1);
}

void __UpdateMatrixUniforms(void *a1, uint64_t a2)
{
  memset(&v45, 0, sizeof(v45));
  memset(&v44, 0, sizeof(v44));
  memset(&v43, 0, sizeof(v43));
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[4];
  uint64_t v6 = a1[42];
  uint64_t Matrix4x4 = (float32x4_t *)C3DEngineContextGetMatrix4x4(v5, 1);
  uint64_t v8 = (simd_float4 *)C3DEngineContextGetMatrix4x4(v5, 2);
  simd_float4 v9 = v8[3];
  simd_float4 v11 = *v8;
  simd_float4 v10 = v8[1];
  value.columns[2] = v8[2];
  value.columns[3] = v9;
  value.columns[0] = v11;
  value.columns[1] = v10;
  uint64_t v12 = (float32x4_t *)C3DEngineContextGetMatrix4x4(v5, 0);
  uint64_t Node = C3DRendererElementGetNode(a2);
  if (Node)
  {
    uint64_t v14 = Node;
    uint64_t Skinner = C3DNodeGetSkinner(Node);
    if (Skinner)
    {
      uint64_t v16 = Skinner;
      int EffectiveCalculationMode = C3DSkinnerGetEffectiveCalculationMode(Skinner, *(__C3DGeometry **)(v14 + 240));
      *(double *)v18.i64 = C3DSkinnerAdjustTransformIfUsesNodeTransformCalculationMode(v16, EffectiveCalculationMode, (float32x4_t)value.columns[0], (float32x4_t)value.columns[1], (float32x4_t)value.columns[2], (float32x4_t)value.columns[3]);
      value.columns[0] = v18;
      value.columns[1] = v19;
      value.columns[2] = v20;
      value.columns[3] = v21;
    }
  }
  UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation(v6, 2);
  if (UniformLocation != -1) {
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, UniformLocation, (GLfloat *)&value, 1);
  }
  uint64_t v23 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 3);
  if (v23 != -1)
  {
    uint64_t v24 = v23;
    C3DMatrix4x4Invert(&value, &v44);
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v24, (GLfloat *)&v44, 1);
  }
  uint64_t v25 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 4);
  C3DMatrix4x4Mult((uint64_t)&value, Matrix4x4, &v43);
  if (v25 != -1) {
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v25, (GLfloat *)&v43, 1);
  }
  uint64_t v26 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 5);
  if (v26 != -1)
  {
    uint64_t v27 = v26;
    C3DMatrix4x4Invert(&v43, &v44);
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v27, (GLfloat *)&v44, 1);
  }
  uint64_t v28 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 7);
  if (v28 != -1)
  {
    uint64_t v29 = v28;
    C3DMatrix4x4Mult((uint64_t)&v43, v12, &v45);
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v29, (GLfloat *)&v45, 1);
  }
  uint64_t v30 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 8);
  if (v30 != -1)
  {
    uint64_t v31 = v30;
    C3DMatrix4x4Mult((uint64_t)&v43, v12, &v45);
    C3DMatrix4x4Invert(&v45, &v44);
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v31, (GLfloat *)&v44, 1);
  }
  uint64_t v32 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 6);
  if (v32 != -1)
  {
    uint64_t v33 = v32;
    C3DMatrix4x4ComputeNormalMatrix((__n128 *)&v43, &v44);
    C3DRendererContextSetMatrix4x4UniformAtLocation(v4, v33, (GLfloat *)&v44, 1);
  }
  uint64_t v34 = C3DFXGLSLProgramObjectGetUniformLocation(v6, 188);
  if (v34 != -1)
  {
    uint64_t v35 = v34;
    double v36 = C3DMatrix4x4Determinant3x3((uint64_t)&value);
    float v37 = *(float *)&v36;
    int v38 = *(float *)&v36 > 0.0;
    uint64_t FXContext = (void *)C3DEngineContextGetFXContext(a1[4]);
    if (FXContext) {
      int v38 = (v37 > 0.0) ^ (C3DFXContextGetMirrorNode(FXContext) != 0);
    }
    float v40 = -1.0;
    if (v38) {
      float v40 = 1.0;
    }
    GLfloat v = v40;
    C3DRendererContextSetFloatUniformAtLocation(v4, v35, &v, 1);
  }
}

void *__BindValueForSymbol(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  uint64_t v8 = a3[2];
  uint64_t v7 = a3[3];
  uint64_t UserInfo = C3DFXProgramDelegateGetUserInfo(v6);
  uint64_t result = (void *)C3DFXProgramDelegateGetCallbacks(v6);
  if (result)
  {
    uint64_t result = (void *)*result;
    if (result)
    {
      uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))result;
      uint64_t ProgramID = C3DFXGLSLProgramObjectGetProgramID(v8);
      uint64_t Node = C3DRendererElementGetNode(v7);
      return (void *)v13(v5, a1, ProgramID, (a2 - 1), Node, UserInfo);
    }
  }
  return result;
}

uint64_t __UnbindValueForSymbol(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  uint64_t v8 = a3[2];
  uint64_t v7 = a3[3];
  uint64_t UserInfo = C3DFXProgramDelegateGetUserInfo(v6);
  uint64_t result = C3DFXProgramDelegateGetCallbacks(v6);
  if (result)
  {
    uint64_t result = *(void *)(result + 8);
    if (result)
    {
      uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))result;
      uint64_t ProgramID = C3DFXGLSLProgramObjectGetProgramID(v8);
      uint64_t Node = C3DRendererElementGetNode(v7);
      return v13(v5, a1, ProgramID, (a2 - 1), Node, UserInfo);
    }
  }
  return result;
}

uint64_t C3DRendererElementStateBindProgramRendererElement(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *(void *)((char *)&v213[1] + 4) = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  uint64_t MaterialForRenderPass = C3DRendererElementGetMaterialForRenderPass(a2, (uint64_t)a4);
  uint64_t Technique = C3DMaterialGetTechnique(MaterialForRenderPass);
  *(void *)(a1 + 36_Block_object_dispose(&STACK[0x2A0], 8) = Technique;
  if (Technique)
  {
    SinglePrograuint64_t m = C3DFXTechniqueGetSingleProgram(Technique);
    int Profile = C3DFXProgramGetProfile(SingleProgram);
    Commonint Profile = 0;
    *(_DWORD *)(a1 + 384) = Profile;
  }
  else
  {
    *(_DWORD *)(a1 + 384) = 0;
    Commonint Profile = C3DMaterialGetCommonProfile(MaterialForRenderPass);
  }
  *(void *)(a1 + 376) = CommonProfile;
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a3);
  unsigned int PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(a3);
  uint64_t ProgramHashCodeForRenderElement = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)a2, a4, PreferredRenderMode);
  *(void *)(a1 + 392) = ProgramHashCodeForRenderElement;
  if (ProgramHashCodeForRenderElement)
  {
    BOOL HasShaderModifiers = C3DProgramHashCodeHasShaderModifiers(ProgramHashCodeForRenderElement);
    uint64_t v25 = (unsigned char *)(a1 + 389);
    *(unsigned char *)(a1 + 389) = HasShaderModifiers;
    uint64_t v26 = (unsigned char *)(a1 + 390);
    *(unsigned char *)(a1 + 390) = 0;
    if (HasShaderModifiers)
    {
      int v27 = 0;
      char v28 = 1;
      do
      {
        char v29 = v28;
        CFArrayRef ShaderModifiers = (const __CFArray *)C3DProgramHashCodeGetShaderModifiers(*(void *)(a1 + 392), v27);
        if (ShaderModifiers)
        {
          CFArrayRef v31 = ShaderModifiers;
          if (!CFArrayGetCount(ShaderModifiers))
          {
            uint64_t v32 = scn_default_log();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
              C3DRendererElementStateBindProgramRendererElement_cold_1(buf, v213, v32);
            }
          }
          CFIndex Count = CFArrayGetCount(v31);
          if (Count >= 1)
          {
            CFIndex v34 = Count;
            for (CFIndex i = 0; i != v34; ++i)
            {
              ValueAtuint64_t Index = CFArrayGetValueAtIndex(v31, i);
              *v26 |= C3DShaderModifierGetFlags((uint64_t)ValueAtIndex) & 1;
            }
          }
        }
        char v28 = 0;
        int v27 = 1;
      }
      while ((v29 & 1) != 0);
      uint64_t v25 = (unsigned char *)(a1 + 389);
    }
  }
  else
  {
    uint64_t v25 = (unsigned char *)(a1 + 389);
    *(_WORD *)(a1 + 389) = 0;
    uint64_t v26 = (unsigned char *)(a1 + 390);
  }
  uint64_t v37 = *(void *)(a1 + 32);
  int v38 = *(float32x2_t **)(a1 + 16);
  uint64_t v196 = *(void *)(a1 + 24);
  uint64_t v39 = C3DEngineContextGetProgramHashCodeStore(v37);
  if (a4) {
    int v40 = C3DFXPassRequiresLighting((uint64_t)a4);
  }
  else {
    int v40 = 1;
  }
  unsigned int v41 = C3DEngineContextGetPreferredRenderMode(v37);
  uint64_t v42 = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(v39, (unsigned __int16 *)a2, a4, v41);
  float v43 = 1.0;
  uint64_t Node = C3DRendererElementGetNode(a2);
  if (Node && !*v26)
  {
    C3DNodeGetWorldAlpha(Node);
    if (v56 == 0.0) {
      return 0;
    }
    float v43 = v56;
  }
  uint64_t v44 = C3DRendererElementGetMaterialForRenderPass(a2, (uint64_t)a4);
  if (!v44)
  {
    __RendererElementStateUnbindLastUsedCommonProfile(a1, 1);
    if (*(void *)(a1 + 328))
    {
      C3DRendererContextUnbindProgramObject((uint64_t)v38);
      long long v55 = *(const void **)(a1 + 328);
      if (v55)
      {
        CFRelease(v55);
        *(void *)(a1 + 32_Block_object_dispose(&STACK[0x2A0], 8) = 0;
      }
      *(void *)(a1 + 336) = 0;
    }
    goto LABEL_140;
  }
  float32x4_t v210 = 0;
  uint64_t v191 = v44;
  int v198 = (__n128 *)v37;
  if (C3DMaterialGetTechnique(v44))
  {
    int v45 = 0;
    uint64_t v46 = 0;
    char v189 = 0;
    BOOL v195 = 0;
    int v193 = 0;
LABEL_28:
    BOOL v47 = 0;
    goto LABEL_29;
  }
  if (!v42) {
    return 0;
  }
  uint64_t v46 = C3DMaterialGetCommonProfile(v191);
  int v57 = C3DProgramHashCodeNeedTangents(v42);
  BOOL v195 = v40
      && C3DEffectCommonProfileGetLightingModel(v46) != 4
      && C3DEffectCommonProfileGetLightingModel(v46) != 0;
  int HasConstantAlpha = C3DProgramHashCodeHasConstantAlpha(v42);
  if (a4 && HasConstantAlpha) {
    int HasConstantAlpha = C3DFXPassHasConstantAlpha((uint64_t)a4);
  }
  char v189 = HasConstantAlpha;
  if (!*v25 && (v43 < 1.0 || (C3DEffectCommonProfileIsOpaque(v46) & HasConstantAlpha & 1) == 0))
  {
    CFNumberRef v146 = v25;
    int TransparencyMode = C3DEffectCommonProfileGetTransparencyMode(v46);
    float ConstantAlpha = C3DEffectCommonProfileGetConstantAlpha((float *)v46);
    _ZF = TransparencyMode == 1;
    uint64_t v25 = v146;
    if (!_ZF && (float)(v43 * ConstantAlpha) <= 0.0) {
      return 0;
    }
  }
  int v193 = v57;
  if (!v46)
  {
    int v45 = 0;
    goto LABEL_28;
  }
  __int16 v143 = *(_WORD *)(v46 + 196);
  if ((v143 & 0x1FFF) != 1)
  {
    if ((*(_WORD *)(v46 + 196) & 0x1FFF) != 0)
    {
      if ((v143 & 2) != 0)
      {
        uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(v46, 0, 0);
        if (EffectSlot) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), EffectSlot);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 4) != 0)
      {
        uint64_t v150 = C3DEffectCommonProfileGetEffectSlot(v46, 2, 0);
        if (v150) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v150);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 8) != 0)
      {
        uint64_t v151 = C3DEffectCommonProfileGetEffectSlot(v46, 3, 0);
        if (v151) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v151);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x10) != 0)
      {
        uint64_t v152 = C3DEffectCommonProfileGetEffectSlot(v46, 4, 0);
        if (v152) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v152);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x20) != 0)
      {
        uint64_t v153 = C3DEffectCommonProfileGetEffectSlot(v46, 5, 0);
        if (v153) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v153);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x40) != 0)
      {
        uint64_t v154 = C3DEffectCommonProfileGetEffectSlot(v46, 6, 0);
        if (v154) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v154);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x80) != 0)
      {
        uint64_t v155 = C3DEffectCommonProfileGetEffectSlot(v46, 7, 0);
        if (v155) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v155);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x100) != 0)
      {
        uint64_t v156 = C3DEffectCommonProfileGetEffectSlot(v46, 1, 0);
        if (v156) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v156);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x200) != 0)
      {
        uint64_t v157 = C3DEffectCommonProfileGetEffectSlot(v46, 8, 0);
        if (v157) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v157);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x400) != 0)
      {
        uint64_t v158 = C3DEffectCommonProfileGetEffectSlot(v46, 9, 0);
        if (v158) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v158);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x800) != 0)
      {
        uint64_t v159 = C3DEffectCommonProfileGetEffectSlot(v46, 10, 0);
        if (v159) {
          C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v159);
        }
      }
      if ((*(_WORD *)(v46 + 196) & 0x1000) == 0) {
        goto LABEL_263;
      }
      uint64_t v160 = v46;
      int v161 = 11;
    }
    else
    {
      *(_WORD *)(v46 + 196) = v143 & 0xE000 | 1;
      uint64_t v144 = C3DEffectCommonProfileGetEffectSlot(v46, 0, 0);
      if (v144)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v144))
        {
          __int16 v145 = 2;
        }
        else
        {
          __int16 v145 = 0;
        }
      }
      else
      {
        __int16 v145 = 0;
      }
      *(_WORD *)(v46 + 196) |= v145;
      uint64_t v162 = C3DEffectCommonProfileGetEffectSlot(v46, 2, 0);
      if (v162)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v162))
        {
          __int16 v163 = 4;
        }
        else
        {
          __int16 v163 = 0;
        }
      }
      else
      {
        __int16 v163 = 0;
      }
      *(_WORD *)(v46 + 196) |= v163;
      uint64_t v164 = C3DEffectCommonProfileGetEffectSlot(v46, 3, 0);
      if (v164)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v164))
        {
          __int16 v165 = 8;
        }
        else
        {
          __int16 v165 = 0;
        }
      }
      else
      {
        __int16 v165 = 0;
      }
      *(_WORD *)(v46 + 196) |= v165;
      uint64_t v166 = C3DEffectCommonProfileGetEffectSlot(v46, 4, 0);
      if (v166)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v166))
        {
          __int16 v167 = 16;
        }
        else
        {
          __int16 v167 = 0;
        }
      }
      else
      {
        __int16 v167 = 0;
      }
      *(_WORD *)(v46 + 196) |= v167;
      uint64_t v168 = C3DEffectCommonProfileGetEffectSlot(v46, 5, 0);
      if (v168)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v168))
        {
          __int16 v169 = 32;
        }
        else
        {
          __int16 v169 = 0;
        }
      }
      else
      {
        __int16 v169 = 0;
      }
      *(_WORD *)(v46 + 196) |= v169;
      uint64_t v170 = C3DEffectCommonProfileGetEffectSlot(v46, 6, 0);
      if (v170)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v170))
        {
          __int16 v171 = 64;
        }
        else
        {
          __int16 v171 = 0;
        }
      }
      else
      {
        __int16 v171 = 0;
      }
      *(_WORD *)(v46 + 196) |= v171;
      uint64_t v172 = C3DEffectCommonProfileGetEffectSlot(v46, 7, 0);
      if (v172)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v172))
        {
          __int16 v173 = 128;
        }
        else
        {
          __int16 v173 = 0;
        }
      }
      else
      {
        __int16 v173 = 0;
      }
      *(_WORD *)(v46 + 196) |= v173;
      uint64_t v174 = C3DEffectCommonProfileGetEffectSlot(v46, 1, 0);
      if (v174)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v174))
        {
          __int16 v175 = 256;
        }
        else
        {
          __int16 v175 = 0;
        }
      }
      else
      {
        __int16 v175 = 0;
      }
      *(_WORD *)(v46 + 196) |= v175;
      uint64_t v176 = C3DEffectCommonProfileGetEffectSlot(v46, 8, 0);
      if (v176)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v176))
        {
          __int16 v177 = 512;
        }
        else
        {
          __int16 v177 = 0;
        }
      }
      else
      {
        __int16 v177 = 0;
      }
      *(_WORD *)(v46 + 196) |= v177;
      uint64_t v178 = C3DEffectCommonProfileGetEffectSlot(v46, 9, 0);
      if (v178)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v178))
        {
          __int16 v179 = 1024;
        }
        else
        {
          __int16 v179 = 0;
        }
      }
      else
      {
        __int16 v179 = 0;
      }
      *(_WORD *)(v46 + 196) |= v179;
      uint64_t v180 = C3DEffectCommonProfileGetEffectSlot(v46, 10, 0);
      if (v180)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v180))
        {
          __int16 v181 = 2048;
        }
        else
        {
          __int16 v181 = 0;
        }
      }
      else
      {
        __int16 v181 = 0;
      }
      *(_WORD *)(v46 + 196) |= v181;
      uint64_t v182 = C3DEffectCommonProfileGetEffectSlot(v46, 11, 0);
      if (v182)
      {
        if (C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v182))
        {
          __int16 v183 = 4096;
        }
        else
        {
          __int16 v183 = 0;
        }
      }
      else
      {
        __int16 v183 = 0;
      }
      *(_WORD *)(v46 + 196) |= v183;
      uint64_t v184 = C3DEffectCommonProfileGetEffectSlot(v46, 15, 0);
      if (v184) {
        C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v184);
      }
      uint64_t v185 = C3DEffectCommonProfileGetEffectSlot(v46, 12, 0);
      if (v185) {
        C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v185);
      }
      uint64_t v186 = C3DEffectCommonProfileGetEffectSlot(v46, 13, 0);
      if (v186) {
        C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v186);
      }
      uint64_t v160 = v46;
      int v161 = 14;
    }
    uint64_t v187 = C3DEffectCommonProfileGetEffectSlot(v160, v161, 0);
    if (v187) {
      C3DRendererContextExecuteSlotTextureProxy(*(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), v187);
    }
LABEL_263:
    BOOL v47 = (*(_WORD *)(v46 + 196) & 0x1FFF) != 1;
    goto LABEL_264;
  }
  BOOL v47 = 0;
LABEL_264:
  int v45 = 1;
LABEL_29:
  uint64_t v192 = v46;
  int v194 = v45;
  if (*v25)
  {
    int v48 = 0;
    *(unsigned char *)(a1 + 38_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    char v49 = 1;
    do
    {
      char v50 = v49;
      if (C3DProgramHashCodeGetShaderModifiers(v42, v48))
      {
        ShaderModifieruint64_t Owner = __getShaderModifierOwner(a2, v48);
        value.columns[0].i64[0] = MEMORY[0x263EF8330];
        value.columns[0].i64[1] = 0x40000000;
        value.columns[1].i64[0] = (uint64_t)___ExecuteShaderModifiersTextureProxy_block_invoke;
        value.columns[1].i64[1] = (uint64_t)&__block_descriptor_tmp_12;
        value.columns[2].i64[0] = a1;
        C3DEntityEnumerateKeyValuesWithBlock(ShaderModifierOwner, (uint64_t)&value);
      }
      char v49 = 0;
      int v48 = 1;
    }
    while ((v50 & 1) != 0);
    if (*(unsigned char *)(a1 + 388)) {
      char v52 = 1;
    }
    else {
      char v52 = v47;
    }
    uint64_t v46 = v192;
    if (v52) {
      goto LABEL_38;
    }
  }
  else if (v47)
  {
LABEL_38:
    uint64_t v53 = (uint64_t)v198;
    C3DRendererElementStateReset(a1, (uint64_t)v198);
    int v54 = 1;
    goto LABEL_51;
  }
  int v54 = 0;
  uint64_t v53 = (uint64_t)v198;
LABEL_51:
  C3DEnginePipelineGetRenderComponentsForRenderPass(a2, a4, v53, 0, 0, (uint64_t *)&v210, 0);
  if (v210 && (ProgramResident = C3DResourceManagerMakeProgramResident(v196, v210, (uint64_t)v38)) != 0)
  {
    long long v59 = ProgramResident;
    long long v60 = v210;
  }
  else
  {
    long long v60 = 0;
    long long v59 = 0;
    float32x4_t v210 = 0;
  }
  long long v61 = *(void **)(a1 + 328);
  if (v61 != v60)
  {
    CFTypeRef v62 = v60;
    if (v61)
    {
      CFRelease(*(CFTypeRef *)(a1 + 328));
      *(void *)(a1 + 32_Block_object_dispose(&STACK[0x2A0], 8) = 0;
      CFTypeRef v62 = v210;
    }
    if (v62) {
      CFTypeRef v62 = CFRetain(v62);
    }
    *(void *)(a1 + 32_Block_object_dispose(&STACK[0x2A0], 8) = v62;
    if (*(const void **)(a1 + 336) != v59)
    {
      *(void *)(a1 + 336) = v59;
      C3DRendererContextBindProgramObject((uint64_t)v38, v59);
    }
  }
  BOOL v63 = v195;
  if (v195)
  {
    uint64_t v64 = *(void *)(a2 + 56);
    BOOL v63 = *(void *)(a1 + 344) != v64;
    *(void *)(a1 + 344) = v64;
  }
  BOOL v190 = v63;
  if (v61 != v60) {
    BOOL v63 = 1;
  }
  if (((v54 | v63) & 1) != 0 || *(void *)(a1 + 56) != v46 || (C3DRendererElementIsOpaque(a2) & 1) == 0)
  {
    int v188 = v54;
    __RendererElementStateUnbindLastUsedCommonProfile(a1, v61 != v60);
    char v65 = v45 ^ 1;
    if (!v59) {
      char v65 = 1;
    }
    if ((v65 & 1) == 0 && v61 != v60)
    {
      UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 187);
      if (UniformLocation != -1)
      {
        uint64_t v67 = UniformLocation;
        uint64_t PointOfView = C3DEngineContextGetPointOfView((uint64_t)v198);
        long long v208 = 0u;
        long long v209 = 0u;
        long long v206 = 0u;
        long long v207 = 0u;
        long long v204 = 0u;
        long long v205 = 0u;
        long long v202 = 0u;
        long long v203 = 0u;
        long long v200 = 0u;
        long long v201 = 0u;
        memset(&value, 0, sizeof(value));
        if (PointOfView)
        {
          if (C3DNodeGetProjectionInfos((uint64_t)PointOfView, (uint64_t)&value))
          {
            v[0] = 0.0;
            double ZFar = C3DProjectionInfosGetZFar((uint64_t)&value);
            GLfloat v70 = 1.0 / (ZFar - C3DProjectionInfosGetZNear((uint64_t)&value));
            v[0] = v70;
            C3DRendererContextSetFloatUniformAtLocation((uint64_t)v38, v67, v, 1);
          }
        }
      }
      uint64_t v71 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 190);
      if (v71 != -1)
      {
        uint64_t v72 = v71;
        float PointOfViewScale = C3DEngineContextGetPointOfViewScale((uint64_t)v198);
        uint64_t Scene = C3DEngineContextGetScene((uint64_t)v198);
        value.columns[0] = 0uLL;
        value.columns[0] = *(simd_float4 *)C3DSceneGetFogColor(Scene);
        C3DRendererContextSetColor4UniformAtLocation((uint64_t)v38, v72, (float32x4_t *)&value, 1);
        uint64_t v75 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 191);
        if (v75 != -1)
        {
          uint64_t v76 = v75;
          *(void *)&v[1] = 0;
          v[0] = 0.0;
          *(__n64 *)&long long v77 = C3DSceneComputeFogParameters(Scene, PointOfViewScale);
          *(_OWORD *)GLfloat v = v77;
          C3DRendererContextSetVector3UniformAtLocation((uint64_t)v38, v76, v, 1);
        }
        uint64_t v46 = v192;
      }
      uint64_t v78 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 189);
      int v45 = v194;
      if (v78 != -1)
      {
        uint64_t v79 = v78;
        if ((__UpdateEffectIfNeeded_initialized & 1) == 0)
        {
          __UpdateEffectIfNeeded_initialized = 1;
          C3DSetupHaltonFilterKernelConic(__UpdateEffectIfNeeded_s_kernel, 31, 1.0, 1.0, -2.0);
        }
        C3DRendererContextSetVector4UniformAtLocation((uint64_t)v38, v79, __UpdateEffectIfNeeded_s_kernel[0].f32, 31);
      }
      uint64_t v80 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 0);
      if (v80 != -1)
      {
        uint64_t v81 = v80;
        double SystemTime = C3DEngineContextGetSystemTime((uint64_t)v198);
        double v83 = *(double *)&__UpdateEffectIfNeeded_t0;
        if (*(double *)&__UpdateEffectIfNeeded_t0 == 0.0)
        {
          __UpdateEffectIfNeeded_t0 = *(void *)&SystemTime;
          double v83 = SystemTime;
        }
        float v84 = SystemTime - v83;
        value.columns[0].f32[0] = v84;
        C3DRendererContextSetFloatUniformAtLocation((uint64_t)v38, v81, (GLfloat *)&value, 1);
      }
      uint64_t v85 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 1);
      if (v85 != -1)
      {
        uint64_t v86 = v85;
        __n128 Viewport = C3DEngineContextGetViewport(v198);
        __asm { FMOV            V1.2S, #1.0 }
        *(float32x2_t *)value.columns[0].f32 = vdiv_f32(_D1, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL));
        C3DRendererContextSetVector2UniformAtLocation((uint64_t)v38, v86, (GLfloat *)&value, 1);
      }
      uint64_t v93 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 14);
      if (v93 != -1)
      {
        uint64_t v94 = v93;
        uint64_t Matrix4x4 = (GLfloat *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 0);
        C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)v38, v94, Matrix4x4, 1);
      }
      uint64_t v96 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 15);
      if (v96 != -1)
      {
        uint64_t v97 = v96;
        memset(&value, 0, sizeof(value));
        uint64_t v98 = (simd_float4x4 *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 0);
        C3DMatrix4x4Invert(v98, &value);
        C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)v38, v97, (GLfloat *)&value, 1);
      }
      uint64_t v99 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 17);
      if (v99 != -1)
      {
        uint64_t v100 = v99;
        memset(&value, 0, sizeof(value));
        long long v101 = (simd_float4x4 *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 1);
        C3DMatrix4x4Invert(v101, &value);
        *(void *)&v[1] = 0;
        v[0] = 0.0;
        C3DMatrix4x4GetTranslation((__n128 *)&value, (__n128 *)v);
        C3DRendererContextSetVector3UniformAtLocation((uint64_t)v38, v100, v, 1);
      }
      uint64_t v102 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 12);
      if (v102 != -1)
      {
        uint64_t v103 = v102;
        uint64_t v104 = (GLfloat *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 1);
        C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)v38, v103, v104, 1);
      }
      uint64_t v105 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 13);
      if (v105 != -1)
      {
        uint64_t v106 = v105;
        memset(&value, 0, sizeof(value));
        __n128 v107 = (simd_float4x4 *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 1);
        C3DMatrix4x4Invert(v107, &value);
        C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)v38, v106, (GLfloat *)&value, 1);
      }
      uint64_t v108 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 16);
      if (v108 != -1)
      {
        uint64_t v109 = v108;
        memset(&value, 0, sizeof(value));
        float64x2_t v110 = (simd_float4 *)C3DEngineContextGetMatrix4x4((uint64_t)v198, 1);
        simd_float4 v111 = v110[3];
        simd_float4 v113 = *v110;
        simd_float4 v112 = v110[1];
        value.columns[2] = v110[2];
        value.columns[3] = v111;
        value.columns[0] = v113;
        value.columns[1] = v112;
        int v45 = v194;
        long long v114 = (__n128 *)C3DEngineContextGetScene((uint64_t)v198);
        C3DSceneComputeViewToCubemapMatrix(v114, (uint64_t)&value);
        C3DRendererContextSetMatrix4x4UniformAtLocation((uint64_t)v38, v109, (GLfloat *)&value, 1);
      }
    }
    *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 400);
    int v115 = *(_DWORD *)(a1 + 384);
    if (v115 == 1)
    {
      uint64_t v118 = C3DBlendStatesDefaultOver();
      C3DRendererContextSetBlendStates((uint64_t)v38, v118);
    }
    else if (!v115)
    {
      GLfloat v116 = v43 * v38[19].f32[1];
      int BlendMode = C3DMaterialGetBlendMode(v191);
      C3DRendererContextBindCommonProfile(v38, v196, v46, a1 + 64, v189, BlendMode, v116);
    }
    *(_DWORD *)(a1 + 400) = *(_DWORD *)(a1 + 320);
    if (v45)
    {
      if (v59) {
        BOOL v119 = v195;
      }
      else {
        BOOL v119 = 0;
      }
      int v120 = v190;
      if (v61 != v60) {
        int v120 = 1;
      }
      if (v119 && v120)
      {
        uint64_t v121 = *(void *)(a1 + 16);
        *(void *)&long long v204 = 0;
        long long v202 = 0u;
        long long v203 = 0u;
        long long v200 = 0u;
        long long v201 = 0u;
        uint64_t v122 = *(void *)(a1 + 40);
        uint64_t v123 = *(void *)(a1 + 48) + 56;
        memset(&value, 0, sizeof(value));
        C3DLightingSystemGetLightingSetDesc(v122, v123, (unint64_t *)&value);
        uint64_t v124 = value.columns[0].i64[0];
        if (value.columns[0].i64[0] >= 1)
        {
          uint64_t v125 = 0;
          do
          {
            float v126 = (char *)&value + 8 * v125;
            uint64_t v127 = (float32x4_t *)*((void *)v126 + 1);
            if (v127)
            {
              uint64_t v128 = *((void *)v126 + 9);
              if (v128)
              {
                C3DRendererContextSetLight(v121, v125, v127, v128, (unsigned int *)(a1 + 400));
                uint64_t v124 = value.columns[0].i64[0];
              }
            }
            ++v125;
          }
          while (v125 < v124);
        }
        uint64_t v129 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 184);
        if (v129 != -1)
        {
          uint64_t v130 = v129;
          *(void *)GLfloat v = C3DLightingSystemGetAmbientLighting(*(void *)(a1 + 40));
          *(void *)&v[2] = v131;
          C3DRendererContextSetColor4UniformAtLocation(v121, v130, (float32x4_t *)v, 1);
        }
      }
      if (v188)
      {
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 0, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 1, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 2, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 3, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 4, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 5, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 6, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 7, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 9, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 8, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 10, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 11, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 15, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 12, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 13, 0);
        _C3DEffectCommonProfileSetTextureForTextureProxy(v46, 14, 0);
      }
    }
    *(void *)(a1 + 56) = v46;
  }
  if (Node)
  {
    uint64_t Skinner = C3DNodeGetSkinner(Node);
    if (Skinner)
    {
      uint64_t v133 = Skinner;
      if (C3DGeometryGetOverrideMaterial(Skinner))
      {
        uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry(Node);
        if (C3DSkinnerGetEffectiveCalculationMode(v133, Geometry) == 1)
        {
          if (C3DRendererElementGetMeshElement(a2))
          {
            value.columns[0].i64[0] = 0;
            uint64_t JointMatrices = C3DSkinnerGetJointMatrices(v133, &value);
            if (value.columns[0].i64[0] >= 1)
            {
              float v136 = (GLfloat *)JointMatrices;
              uint64_t v137 = C3DFXGLSLProgramObjectGetUniformLocation((uint64_t)v59, 186);
              if (v137 != -1) {
                C3DRendererContextSetVector4UniformAtLocation((uint64_t)v38, v137, v136, value.columns[0].i64[0]);
              }
            }
          }
        }
      }
    }
  }
  if (v193)
  {
    uint64_t Mesh = C3DRendererElementGetMesh(a2);
    C3DMeshCreateTangentsIfNeeded(Mesh, 1);
  }
  if (v46)
  {
    int v139 = C3DEffectCommonProfileGetLightingModel(v46) != 4;
    if (C3DEngineContextGetScene((uint64_t)v198))
    {
      if (*(_DWORD *)(a1 + 428) != v139) {
        *(_DWORD *)(a1 + 42_Block_object_dispose(&STACK[0x2A0], 8) = v139;
      }
    }
  }
LABEL_140:
  uint64_t RasterizerStates = C3DFXPassGetRasterizerStates((uint64_t)a4);
  if (RasterizerStates || (uint64_t RasterizerStates = C3DRendererElementGetRaterizerStates(a2)) != 0) {
    C3DRendererContextSetRasterizerStates((uint64_t)v38, RasterizerStates);
  }
  return 1;
}

void C3DRendererElementStateDrawRendererElement(uint64_t a1, uint64_t a2, float32x4_t *a3, void *a4, int a5)
{
  *(void *)&v85[5] = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  if ((!a5 || C3DRendererElementStateBindProgramRendererElement(a1, a2, (uint64_t)a3, a4))
    && *(void *)(a1 + 328))
  {
    uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a3);
    uint64_t ResourceManager = C3DEngineContextGetResourceManager((uint64_t)a3);
    uint64_t Node = (float32x4_t *)C3DRendererElementGetNode(a2);
    uint64_t Mesh = (void *)C3DRendererElementGetMesh(a2);
    MeshElement = C3DRendererElementGetMeshElement(a2);
    uint64_t v23 = *(void *)(a1 + 328);
    if (v23)
    {
      uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial(v23);
      if (!Node)
      {
LABEL_10:
        if (Mesh) {
          C3DRendererContextBindMesh(RendererContextGL, ResourceManager, Mesh);
        }
        uint64_t v26 = *(void *)(a1 + 336);
        if (!*(void *)(v26 + 40))
        {
          __UpdateMatrixUniforms((void *)a1, a2);
          goto LABEL_47;
        }
        if (*(_DWORD *)(a1 + 384) == 1)
        {
          C3DGLSLProfileBindProfileInputs(a3, v26, *(void *)(a1 + 368));
LABEL_47:
          ImageResident = 0;
LABEL_48:
          if (MeshElement) {
            C3DRendererContextBindMeshElement(RendererContextGL, ResourceManager, MeshElement);
          }
          if (OverrideMaterial) {
            __FireProgramDelegateCallback(a1, a2, OverrideMaterial, (void (__cdecl *)(const void *, const void *, void *))__BindValueForSymbol);
          }
          uint64_t v58 = OverrideMaterial;
          if (*(unsigned char *)(a1 + 389))
          {
            uint64_t v81 = ImageResident;
            uint64_t v83 = RendererContextGL;
            int v59 = 0;
            uint64_t v60 = *(void *)(a1 + 392);
            char v61 = 1;
            do
            {
              char v62 = v61;
              CFArrayRef ShaderModifiers = (const __CFArray *)C3DProgramHashCodeGetShaderModifiers(v60, v59);
              if (ShaderModifiers)
              {
                CFArrayRef v64 = ShaderModifiers;
                if (!CFArrayGetCount(ShaderModifiers))
                {
                  char v65 = scn_default_log();
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT)) {
                    C3DRendererElementStateBindProgramRendererElement_cold_1((uint8_t *)&valuePtr, v85, v65);
                  }
                }
                ShaderModifieruint64_t Owner = __getShaderModifierOwner(a2, v59);
                CFIndex Count = CFArrayGetCount(v64);
                if (Count >= 1)
                {
                  CFIndex v68 = Count;
                  for (CFIndex i = 0; i != v68; ++i)
                  {
                    ValueAtuint64_t Index = CFArrayGetValueAtIndex(v64, i);
                    if (C3DShaderModifierGetLanguage((uint64_t)ValueAtIndex) == 1) {
                      *(_DWORD *)(a1 + 400) += C3DShaderModifierBindUniforms((uint64_t)ValueAtIndex, *(void *)(a1 + 32), ShaderModifierOwner, *(unsigned int *)(a1 + 400));
                    }
                  }
                }
              }
              char v61 = 0;
              int v59 = 1;
            }
            while ((v62 & 1) != 0);
            ImageResident = v81;
            uint64_t RendererContextGL = v83;
            if (*(unsigned char *)(a1 + 388))
            {
              int v71 = 0;
              uint64_t v72 = *(void *)(a1 + 392);
              char v73 = 1;
              do
              {
                char v74 = v73;
                if (C3DProgramHashCodeGetShaderModifiers(v72, v71))
                {
                  uint64_t v75 = __getShaderModifierOwner(a2, v71);
                  C3DEntityEnumerateKeyValuesWithBlock(v75, (uint64_t)&__block_literal_global_22_0);
                }
                char v73 = 0;
                int v71 = 1;
              }
              while ((v74 & 1) != 0);
              *(unsigned char *)(a1 + 38_Block_object_dispose(&STACK[0x2A0], 8) = 0;
            }
          }
          C3DRendererContextRenderResidentMeshElement(RendererContextGL);
          if (v58) {
            __FireProgramDelegateCallback(a1, a2, v58, (void (__cdecl *)(const void *, const void *, void *))__UnbindValueForSymbol);
          }
          if (ImageResident)
          {
            uint64_t v76 = (const void *)ImageResident[1];
            if (v76)
            {
              CFRelease(v76);
              ImageResident[1] = 0;
            }
            long long v77 = (const void *)ImageResident[3];
            if (v77)
            {
              CFRelease(v77);
              ImageResident[3] = 0;
            }
            --*(_DWORD *)(a1 + 400);
          }
          return;
        }
        __UpdateMatrixUniforms((void *)a1, a2);
        uint64_t v27 = C3DRendererElementGetNode(a2);
        if (!v27) {
          goto LABEL_47;
        }
        CFDictionaryRef LightmapInfo = C3DNodeGetLightmapInfo(v27);
        if (!LightmapInfo) {
          goto LABEL_47;
        }
        CFDictionaryRef v29 = LightmapInfo;
        uint64_t v82 = RendererContextGL;
        CFNumberRef Value = (void *)CFDictionaryGetValue(LightmapInfo, @"image");
        if (Value)
        {
          CFArrayRef v31 = Value;
          uint64_t v80 = OverrideMaterial;
          uint64_t v32 = C3DEngineContextGetResourceManager((uint64_t)a3);
          uint64_t v33 = (float32x2_t *)C3DEngineContextGetRendererContextGL((uint64_t)a3);
          uint64_t v34 = *(unsigned int *)(a1 + 400);
          *(_DWORD *)(a1 + 400) = v34 + 1;
          uint64_t TypeID = C3DImageGetTypeID();
          if (TypeID != CFGetTypeID(v31))
          {
            ImageResident = 0;
            uint64_t RendererContextGL = v82;
LABEL_82:
            uint64_t OverrideMaterial = v80;
            goto LABEL_48;
          }
          CommonProfileIfNouint64_t Technique = C3DMaterialGetCommonProfileIfNoTechnique(*(void *)(a2 + 32));
          uint64_t OverrideMaterial = v80;
          if (CommonProfileIfNoTechnique)
          {
            CFTypeRef TextureSampler = (CFTypeRef)C3DEffectCommonProfileGetTextureSampler(CommonProfileIfNoTechnique, 2);
            ImageResident = C3DResourceManagerMakeImageResident(v32, v31, TextureSampler, v33);
            if (!ImageResident)
            {
LABEL_80:
              uint64_t RendererContextGL = v82;
              goto LABEL_48;
            }
            unsigned int valuePtr = 1;
            uint64_t v38 = C3DRendererElementGetMesh(a2);
            CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(v29, @"uv_set");
            if (v39) {
              CFNumberGetValue(v39, kCFNumberIntType, &valuePtr);
            }
            SourcesCountForint Semantic = C3DMeshGetSourcesCountForSemantic(v38, 3);
            if (SourcesCountForSemantic)
            {
              uint64_t v41 = SourcesCountForSemantic - 1 >= valuePtr ? valuePtr : (SourcesCountForSemantic - 1);
              unsigned int valuePtr = v41;
              if (C3DMeshGetSourceWithSemanticAtIndex(v38, 3, v41, 1))
              {
                uint64_t v42 = ImageResident;
                ImageResident = (float32x2_t *)(a1 + 64 + 32 * v34);
                ImageResident[2].i32[0] = v34;
                ImageResident->i8[0] = 6;
                uint64_t v44 = ImageResident + 1;
                float v43 = (float32x2_t *)ImageResident[1];
                CFTypeRef cf = v42;
                if (v43 != v42)
                {
                  if (v43)
                  {
                    CFRelease(v43);
                    *uint64_t v44 = 0;
                  }
                  *uint64_t v44 = (float32x2_t)CFRetain(cf);
                }
                uint64_t v46 = ImageResident + 3;
                CFTypeRef v45 = (CFTypeRef)ImageResident[3];
                if (v45 != TextureSampler)
                {
                  if (v45)
                  {
                    CFRelease(v45);
                    *uint64_t v46 = 0;
                  }
                  CFTypeRef v47 = TextureSampler;
                  if (TextureSampler) {
                    CFTypeRef v47 = CFRetain(TextureSampler);
                  }
                  *uint64_t v46 = (float32x2_t)v47;
                }
                uint64_t v48 = *(void *)(a1 + 336);
                uint64_t RendererContextGL = v82;
                if (!v48)
                {
                  char v49 = scn_default_log();
                  if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT)) {
                    C3DRendererElementStateDrawRendererElement_cold_2(v49, v50, v51, v52, v53, v54, v55, v56);
                  }
                }
                if (v34 != C3DFXGLSLProgramObjectGetUniformValueAtIndex(v48, 178))
                {
                  UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation(v48, 178);
                  C3DRendererContextSetIntUniformAtLocation((uint64_t)v33, UniformLocation, v34);
                  C3DFXGLSLProgramObjectSetUniformValueAtIndex(v48, 178, v34);
                }
                C3DRendererContextBindTexture((uint64_t)v33, cf, (uint64_t)TextureSampler, 0, v34);
                goto LABEL_82;
              }
            }
          }
        }
        ImageResident = 0;
        goto LABEL_80;
      }
    }
    else
    {
      uint64_t OverrideMaterial = 0;
      if (!Node) {
        goto LABEL_10;
      }
    }
    WorldMatrifloat x = C3DNodeGetWorldMatrix(Node);
    C3DEngineContextSetMatrix4x4((uint64_t)a3, 2, (uint64_t)WorldMatrix);
    goto LABEL_10;
  }
}

void __FireProgramDelegateCallback(uint64_t a1, uint64_t a2, uint64_t a3, void (__cdecl *a4)(const void *, const void *, void *))
{
  context[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 336);
  if (v4)
  {
    if (C3DFXProgramDelegateGetCallbacks(a3))
    {
      context[0] = *(void *)(a1 + 32);
      context[1] = a3;
      context[2] = v4;
      context[3] = a2;
      C3DFXGLSLProgramObjectApplyFunctionForAttributes(v4, a4, context);
      C3DFXGLSLProgramObjectApplyFunctionForUniforms(v4, a4, context);
    }
  }
}

void C3DRendererElementStateProcessRendererElement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(float32x4_t **)(a3 + 8);
  uint64_t v6 = *(void *)(a3 + 16);
  if (!v6)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateProcessRendererElement_cold_6(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  Pass = (void *)C3DFXPassInstanceGetPass(v6);
  uint64_t Node = (float32x4_t *)C3DRendererElementGetNode(a2);
  if (!a1 && (uint64_t v17 = scn_default_log(), os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererElementStateCreate_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    if (a2) {
      goto LABEL_9;
    }
  }
  else if (a2)
  {
    goto LABEL_9;
  }
  uint64_t v25 = scn_default_log();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
    _C3DRendererElementSync_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
  }
LABEL_9:
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  if (C3DRendererElementIsHidden(a2))
  {
    uint64_t v33 = scn_default_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
    {
      C3DRendererElementStateProcessRendererElement_cold_3(v33, v34, v35, v36, v37, v38, v39, v40);
      if (Node) {
        goto LABEL_12;
      }
LABEL_22:
      if (C3DRendererElementIsRendererDelegate(a2)) {
        return;
      }
      goto LABEL_23;
    }
  }
  if (!Node) {
    goto LABEL_22;
  }
LABEL_12:
  if (C3DNodeGetOpacity((uint64_t)Node) <= 0.0 && (*(_WORD *)(a2 + 72) & 7) != 2)
  {
    uint64_t v41 = scn_default_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateProcessRendererElement_cold_2(v41, v42, v43, v44, v45, v46, v47, v48);
    }
  }
  if (C3DRendererElementIsRendererDelegate(a2))
  {
    CFDictionaryRef RendererDelegate = C3DNodeGetRendererDelegate((uint64_t)Node);
    if (RendererDelegate)
    {
      uint64_t v50 = (uint64_t)RendererDelegate;
      C3DRendererElementStateReset(a1, (uint64_t)v5);
      WorldMatrifloat x = C3DNodeGetWorldMatrix(Node);
      C3DEngineContextSetMatrix4x4((uint64_t)v5, 2, (uint64_t)WorldMatrix);
      C3DRendererDelegateFireWithNode(v50, (uint64_t)v5, (uint64_t)Node, (uint64_t)Pass);
      return;
    }
    uint64_t v52 = scn_default_log();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateProcessRendererElement_cold_1(v52, v53, v54, v55, v56, v57, v58, v59);
    }
  }
LABEL_23:
  uint64_t v60 = *(void *)(a2 + 40);
  if (v60)
  {
    if (v60 != C3DFXTechniqueGetNullTechnique())
    {
      C3DEngineContextRenderSubTechnique((uint64_t)v5, v60, v6, a2);
      C3DRendererElementStateReset(a1, (uint64_t)v5);
    }
  }
  else
  {
    C3DRendererElementStateDrawRendererElement(a1, a2, v5, Pass, 1);
  }
}

uint64_t C3DRendererElementStateGetCurrentProgram(uint64_t a1)
{
  return *(void *)(a1 + 328);
}

uint64_t C3DRendererElementStateGetCurrentProgramObject(uint64_t a1)
{
  return *(void *)(a1 + 336);
}

uint64_t C3DRendererElementStateGetActiveTextureUnit(uint64_t a1)
{
  return *(unsigned int *)(a1 + 400);
}

uint64_t C3DRendererElementStateSetActiveTextureUnit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 400) = a2;
  return result;
}

void C3DRendererContextDestroyAllVertexArrayObjects(void *context)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)context + 15);
  if (v2)
  {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)_destroyVertexArray, context);
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)context + 15));
    uint64_t v3 = (const void *)*((void *)context + 16);
    if (v3)
    {
      CFRelease(v3);
      *((void *)context + 16) = 0;
    }
  }
}

uint64_t _destroyVertexArray(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = a2;
  uint64_t result = (*(uint64_t (**)(uint64_t, int *))(a3 + 1944))(1, &v5);
  --*(_DWORD *)(a3 + 428);
  return result;
}

void _C3DRendererContextCFFinalize(char *context)
{
  if (context)
  {
    CFDictionaryApplyFunction(*((CFDictionaryRef *)context + 15), (CFDictionaryApplierFunction)_destroyVertexArray, context);
    CFDictionaryRef v2 = (const void *)*((void *)context + 15);
    if (v2)
    {
      CFRelease(v2);
      *((void *)context + 15) = 0;
    }
    uint64_t v3 = (const void *)*((void *)context + 16);
    if (v3)
    {
      CFRelease(v3);
      *((void *)context + 16) = 0;
    }
    uint64_t v4 = 0;
    char v5 = 1;
    do
    {
      char v6 = v5;
      uint64_t v7 = &context[24 * v4];
      uint64_t v8 = (const void *)*((void *)v7 + 251);
      if (v8)
      {
        CFRelease(v8);
        *((void *)v7 + 251) = 0;
      }
      uint64_t v9 = (CFTypeRef *)(v7 + 1992);
      CFTypeRef v10 = *v9;
      v21[0] = MEMORY[0x263EF8330];
      v21[1] = 0x40000000;
      v21[2] = ___C3DRendererContextCFFinalize_block_invoke;
      v21[3] = &__block_descriptor_tmp_44;
      v21[4] = context;
      C3DArrayApply((uint64_t)v10, (uint64_t)v21);
      if (*v9)
      {
        CFRelease(*v9);
        CFTypeRef *v9 = 0;
      }
      char v5 = 0;
      uint64_t v4 = 1;
    }
    while ((v6 & 1) != 0);
    uint64_t v11 = *((void *)context + 255);
    v20[0] = MEMORY[0x263EF8330];
    v20[1] = 0x40000000;
    _DWORD v20[2] = ___C3DRendererContextCFFinalize_block_invoke_2;
    v20[3] = &__block_descriptor_tmp_45_0;
    v20[4] = context;
    C3DArrayApply(v11, (uint64_t)v20);
    uint64_t v12 = (const void *)*((void *)context + 255);
    if (v12)
    {
      CFRelease(v12);
      *((void *)context + 255) = 0;
    }
    uint64_t v13 = (const void *)*((void *)context + 20);
    if (v13)
    {
      C3DResourceManagerRegistryReleaseContext((uint64_t)context, v13);
      C3DEAGLWrapperContextRelease(*((id *)context + 20));
    }
    uint64_t v14 = (const void *)*((void *)context + 12);
    if (v14)
    {
      CFRelease(v14);
      *((void *)context + 12) = 0;
    }
    uint64_t v15 = (const void *)*((void *)context + 9);
    if (v15)
    {
      CFRelease(v15);
      *((void *)context + 9) = 0;
    }
    uint64_t v16 = (const void *)*((void *)context + 14);
    if (v16)
    {
      CFRelease(v16);
      *((void *)context + 14) = 0;
    }
    uint64_t v17 = (const void *)*((void *)context + 8);
    if (v17)
    {
      CFRelease(v17);
      *((void *)context + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
    uint64_t v18 = (const void *)*((void *)context + 22);
    if (v18)
    {
      CFRelease(v18);
      *((void *)context + 22) = 0;
    }
    uint64_t v19 = (const void *)*((void *)context + 257);
    if (v19)
    {
      CFRelease(v19);
      *((void *)context + 257) = 0;
    }
  }
}

CFStringRef _C3DRendererContextCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DRendererContext>");
}

CFStringRef _C3DRendererContextCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DRendererContext>");
}

uint64_t __C3DRendererContextGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DRendererContextGetTypeID_typeID = result;
  return result;
}

__n64 C3DRendererContextSetupCommonPipeline(__n64 *a1)
{
  a1[2].n64_u32[1] = 4;
  a1[6].n64_u32[0] = 1;
  C3DRendererContextSetPlatformSpecificImplementations_ES2((uint64_t)&a1[144]);
  a1[2].n64_u32[0] = 1;
  GLint params = 0;
  glGetIntegerv(0xD33u, &params);
  result.n64_u64[0] = a1[3].n64_u64[0];
  if (result.n64_f32[0] == 0.0)
  {
    result.n64_f32[0] = (float)params;
    a1[3].n64_u64[0] = result.n64_u64[0];
  }
  if (result.n64_f32[1] == 0.0)
  {
    result.n64_f32[1] = (float)params;
    a1[3].n64_u64[0] = result.n64_u64[0];
  }
  return result;
}

__n64 __InitStateVarsIfNeeded(__n64 *a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DRendererContextSetupCommonPipeline(a1);
}

__n64 *C3DRendererContextCreateWithOptions()
{
  if (C3DRendererContextGetTypeID_onceToken != -1) {
    dispatch_once(&C3DRendererContextGetTypeID_onceToken, &__block_literal_global_34);
  }
  uint64_t Instance = (__n64 *)C3DTypeCreateInstance_(C3DRendererContextGetTypeID_typeID, 0x800uLL);
  Instance[21].n64_u64[0] = 0;
  Instance[6].n64_u32[1] = 1065353216;
  Instance[11].n64_u16[0] = 256;
  C3DColor4Make((float *)&Instance[18], 1.0, 1.0, 1.0, 1.0);
  Instance[3].n64_u64[0] = 0;
  __InitStateVarsIfNeeded(Instance);
  Instance[22].n64_u64[0] = 0;
  Instance[15].n64_u64[0] = (unint64_t)CFDictionaryCreateMutable(0, 0, 0, 0);
  CFAllocatorRef v1 = (_DWORD *)C3DArrayCreate(32, 0);
  Instance[249].n64_u64[0] = (unint64_t)v1;
  C3DArraySetCount(v1, 3u);
  Instance[250].n64_u32[1] = 0;
  CFDictionaryRef v2 = (_DWORD *)C3DArrayCreate(32, 0);
  Instance[252].n64_u64[0] = (unint64_t)v2;
  C3DArraySetCount(v2, 3u);
  Instance[253].n64_u32[1] = 0;
  Instance[255].n64_u64[0] = C3DArrayCreate(4, 10);
  Instance[256].n64_u32[0] = 0;
  return Instance;
}

void C3DRendererContextSetMaxTextureSize(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 24) = a2;
}

void C3DRendererContextClear(uint64_t a1, GLbitfield mask, float32x4_t *a3)
{
  *(void *)(a1 + 1096) = 0;
  if (a3 && (mask & 0x4000) != 0)
  {
    float32x4_t v4 = *a3;
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToNonLinear(&v4);
    }
    glClearColor(v4.f32[0], v4.f32[1], v4.f32[2], v4.f32[3]);
  }
  if ((mask & 0x100) != 0) {
    glDepthMask(1u);
  }
  if ((mask & 0x400) != 0) {
    glStencilMask(0xFFFFFFFF);
  }
  glClear(mask);
}

BOOL C3DRendererContextTextureSamplerImpliesPow2TextureSize()
{
  return C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler(1u) == 3553;
}

uint64_t C3DRendererContextGetTextureUnitOffset(uint64_t a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 168);
}

uint64_t C3DRendererContextGetStats(uint64_t a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 184;
}

BOOL C3DRendererContextIsEnabled(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    GLenum v2 = 2929;
    return glIsEnabled(v2) != 0;
  }
  if (a2 == 2)
  {
    GLenum v2 = 2884;
    return glIsEnabled(v2) != 0;
  }
  return 0;
}

void C3DRendererContextSetEnable(uint64_t a1, int a2, int a3)
{
  if (a2 == 1)
  {
    GLenum v3 = 2929;
    if (!a3)
    {
LABEL_4:
      glDisable(v3);
      return;
    }
  }
  else
  {
    if (a2 != 2) {
      return;
    }
    GLenum v3 = 2884;
    if (!a3) {
      goto LABEL_4;
    }
  }
  glEnable(v3);
}

void C3DRendererContextResetToDefaultStates(uint64_t a1)
{
  glPushGroupMarkerEXT(0, "Reset all states");
  glActiveTexture(0x84C0u);
  glDisable(0xB71u);
  glDisable(0xB44u);
  C3DRendererContextUnbindProgramObject(a1);
  C3DRendererContextBindMesh(a1, 0, 0);
  C3DRendererContextBindMeshElement(a1, 0, 0);
  uint64_t v2 = C3DBlendStatesDefaultReplace();
  C3DRendererContextSetBlendStates(a1, v2);

  glPopGroupMarkerEXT();
}

void C3DRendererContextUnbindProgramObject(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 176);
  if (v2)
  {
    if (!*(_DWORD *)(a1 + 1076)
      || (*(_DWORD *)(a1 + 1076) = 0, glUseProgram(0), ++*(_DWORD *)(a1 + 228), (uint64_t v2 = *(const void **)(a1 + 176)) != 0))
    {
      CFRelease(v2);
      *(void *)(a1 + 176) = 0;
    }
  }
}

void C3DRendererContextUnbindBufferObjects(uint64_t a1)
{
  C3DRendererContextBindMesh(a1, 0, 0);

  C3DRendererContextBindMeshElement(a1, 0, 0);
}

void C3DRendererContextSetBlendStates(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 1088))
  {
    uint64_t v2 = a2;
    if (*(void *)(a1 + 1080) != a2)
    {
      if (!a2) {
        uint64_t v2 = C3DBlendStatesDefaultReplace();
      }
      unint64_t Desc = C3DBlendStatesGetDesc(v2, 0);
      unint64_t v5 = HIBYTE(Desc);
      uint64_t v6 = *(void *)(a1 + 1080);
      if (v6)
      {
        unint64_t v7 = C3DBlendStatesGetDesc(v6, 0);
        int v8 = BYTE2(v7);
        if ((v7 & 1) != (Desc & 1))
        {
          if (Desc)
          {
            glEnable(0xBE2u);
            int v8 = 15;
          }
          else
          {
            glDisable(0xBE2u);
          }
          ++*(_DWORD *)(a1 + 236);
        }
        if ((Desc & 0x100) != 0)
        {
          if (v8 != BYTE2(Desc) || BYTE3(v7) != BYTE3(Desc) || ((v7 ^ Desc) & 0xFFFF0000000000) != 0)
          {
            glBlendFuncSeparate(gl_BlendModes[BYTE2(Desc)], gl_BlendModes[BYTE3(Desc)], gl_BlendModes[BYTE5(Desc)], gl_BlendModes[BYTE6(Desc)]);
            ++*(_DWORD *)(a1 + 236);
          }
          if (BYTE4(v7) == BYTE4(Desc) && HIBYTE(v7) == v5) {
            goto LABEL_32;
          }
          glBlendEquationSeparate(*(_DWORD *)(a1 + 1160 + 4 * BYTE4(Desc)), *(_DWORD *)(a1 + 1160 + 4 * v5));
        }
        else
        {
          if (v8 != BYTE2(Desc) || BYTE3(v7) != BYTE3(Desc))
          {
            glBlendFunc(gl_BlendModes[BYTE2(Desc)], gl_BlendModes[BYTE3(Desc)]);
            ++*(_DWORD *)(a1 + 236);
          }
          if (BYTE4(v7) == BYTE4(Desc)) {
            goto LABEL_32;
          }
          glBlendEquation(*(_DWORD *)(a1 + 4 * BYTE4(Desc) + 1160));
        }
        uint64_t v9 = (_DWORD *)(a1 + 236);
      }
      else
      {
        if (Desc) {
          glEnable(0xBE2u);
        }
        else {
          glDisable(0xBE2u);
        }
        uint64_t v9 = (_DWORD *)(a1 + 236);
        ++*(_DWORD *)(a1 + 236);
        GLenum v10 = gl_BlendModes[BYTE2(Desc)];
        GLenum v11 = gl_BlendModes[BYTE3(Desc)];
        if ((Desc & 0x100) != 0)
        {
          glBlendFuncSeparate(v10, v11, gl_BlendModes[BYTE5(Desc)], gl_BlendModes[BYTE6(Desc)]);
          glBlendEquationSeparate(*(_DWORD *)(a1 + 1160 + 4 * BYTE4(Desc)), *(_DWORD *)(a1 + 1160 + 4 * v5));
        }
        else
        {
          glBlendFunc(v10, v11);
          glBlendEquation(*(_DWORD *)(a1 + 4 * BYTE4(Desc) + 1160));
        }
      }
      ++*v9;
LABEL_32:
      *(void *)(a1 + 1080) = v2;
    }
  }
}

void C3DRendererContextSetMatrix4x4UniformAtLocation(uint64_t a1, uint64_t location, GLfloat *value, uint64_t count)
{
  GLsizei v4 = count;
  if (!count)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (location != -1)
  {
    glUniformMatrix4fv(location, v4, 0, value);
    if (a1) {
      *(_DWORD *)(a1 + 264) += v4;
    }
  }
}

void C3DRendererContextSetColor4UniformAtLocation(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!a4)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a2 != -1)
  {
    uint64_t IsEnabled = C3DLinearRenderingIsEnabled();
    if (!IsEnabled)
    {
      GLint v18 = a2;
      GLsizei v19 = a4;
      uint64_t v17 = a3;
LABEL_9:
      glUniform4fv(v18, v19, v17->f32);
      if (!a1) {
        return;
      }
      goto LABEL_10;
    }
    if (a4 == 1)
    {
      float32x4_t v23 = *a3;
      C3DColor4ConvertToNonLinear(&v23);
      uint64_t v17 = &v23;
      GLint v18 = a2;
      GLsizei v19 = 1;
      goto LABEL_9;
    }
    MEMORY[0x270FA5388](IsEnabled);
    memcpy(&v23 - a4, a3, v20);
    if (a4 >= 1)
    {
      uint64_t v21 = &v23 - a4;
      uint64_t v22 = a4;
      do
      {
        C3DColor4ConvertToNonLinear(v21++);
        --v22;
      }
      while (v22);
    }
    glUniform4fv(a2, a4, &v23.f32[-4 * a4]);
    if (a1) {
LABEL_10:
    }
      *(_DWORD *)(a1 + 260) += a4;
  }
}

void C3DRendererContextSetVector4UniformAtLocation(uint64_t a1, uint64_t location, GLfloat *v, uint64_t count)
{
  GLsizei v4 = count;
  if (!count)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (location != -1)
  {
    glUniform4fv(location, v4, v);
    if (a1) {
      *(_DWORD *)(a1 + 260) += v4;
    }
  }
}

void C3DRendererContextSetVector3UniformAtLocation(uint64_t a1, uint64_t location, GLfloat *v, uint64_t count)
{
  GLsizei v4 = count;
  if (!count)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (location != -1)
  {
    glUniform3fv(location, v4, v);
    if (a1) {
      *(_DWORD *)(a1 + 256) += v4;
    }
  }
}

void C3DRendererContextSetVector2UniformAtLocation(uint64_t a1, uint64_t location, GLfloat *v, uint64_t count)
{
  GLsizei v4 = count;
  if (!count)
  {
    int v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (location != -1)
  {
    glUniform2fv(location, v4, v);
    if (a1) {
      *(_DWORD *)(a1 + 252) += v4;
    }
  }
}

void C3DRendererContextSetIntUniformAtLocation(uint64_t a1, uint64_t location, GLint x)
{
  if (location != -1)
  {
    glUniform1i(location, x);
    if (a1) {
      ++*(_DWORD *)(a1 + 248);
    }
  }
}

void C3DRendererContextSetInt2UniformAtLocation(uint64_t a1, uint64_t location, GLint *a3, uint64_t a4)
{
  if (!a4)
  {
    unint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  if (location != -1)
  {
    glUniform2i(location, *a3, a3[1]);
    if (a1) {
      ++*(_DWORD *)(a1 + 248);
    }
  }
}

void C3DRendererContextSetInt3UniformAtLocation(uint64_t a1, uint64_t location, GLint *a3, uint64_t a4)
{
  if (!a4)
  {
    unint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  if (location != -1)
  {
    glUniform3i(location, *a3, a3[1], a3[2]);
    if (a1) {
      ++*(_DWORD *)(a1 + 248);
    }
  }
}

void C3DRendererContextSetInt4UniformAtLocation(uint64_t a1, uint64_t location, GLint *a3, uint64_t a4)
{
  if (!a4)
  {
    unint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  if (location != -1)
  {
    glUniform4i(location, *a3, a3[1], a3[2], a3[3]);
    if (a1) {
      ++*(_DWORD *)(a1 + 248);
    }
  }
}

void C3DRendererContextSetFloatUniformAtLocation(uint64_t a1, uint64_t location, GLfloat *v, uint64_t count)
{
  GLsizei v4 = count;
  if (!count)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (location != -1)
  {
    glUniform1fv(location, v4, v);
    if (a1) {
      *(_DWORD *)(a1 + 244) += v4;
    }
  }
}

void C3DRendererContextBindProgramObject(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v4 = *(CFTypeRef *)(a1 + 176);
  if (v4 != cf)
  {
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 176) = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *(void *)(a1 + 176) = v5;
  }
  if (cf) {
    GLuint ProgramID = C3DFXGLSLProgramObjectGetProgramID((uint64_t)cf);
  }
  else {
    GLuint ProgramID = 0;
  }
  if (*(_DWORD *)(a1 + 1076) != ProgramID)
  {
    *(_DWORD *)(a1 + 1076) = ProgramID;
    glUseProgram(ProgramID);
    ++*(_DWORD *)(a1 + 228);
  }
}

BOOL C3DRendererContextExecuteSlotTextureProxy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a4) {
      goto LABEL_6;
    }
  }
  else if (a4)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextExecuteSlotTextureProxy_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  ImageProxfloat y = (void *)C3DEffectSlotGetImageProxy(a4);
  if (ImageProxy)
  {
    uint64_t TextureSampler = C3DEffectSlotGetTextureSampler(a4);
    if (!TextureSampler) {
      uint64_t TextureSampler = C3DTextureSamplerGetDefault();
    }
    C3DRendererContextResetToDefaultStates(a1);
    ImageProxyResident = C3DResourceManagerMakeImageProxyResident(a2, ImageProxy, TextureSampler, a1, a3);
    C3DEffectSlotSetTextureFromImageProxy(a4, ImageProxyResident);
    *(_DWORD *)(a1 + 1076) = -1;
    *(void *)(a1 + 1104) = -1;
    *(void *)(a1 + 1112) = -1;
    *(void *)(a1 + 1080) = 0;
    *(void *)(a1 + 1096) = 0;
  }
  return ImageProxy != 0;
}

uint64_t C3DRendererContextInvalidateCache(uint64_t result)
{
  *(_DWORD *)(result + 1076) = -1;
  *(void *)(result + 1104) = -1;
  *(void *)(result + 1112) = -1;
  *(void *)(result + 1080) = 0;
  *(void *)(result + 1096) = 0;
  return result;
}

void C3DRendererContextSetupResidentMeshSourceAtLocation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (a4 != -1)
  {
    uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(a2);
    uint64_t v17 = (uint64_t)Accessor;
    if (a3)
    {
      uint64_t v18 = *(uint64_t **)(a3 + 72);
      if (v18) {
        uint64_t v19 = *v18;
      }
      else {
        uint64_t v19 = 0;
      }
      ValuePtrAtuint64_t Index = (const UInt8 *)(v19 + C3DSourceAccessorGetOffset((uint64_t)Accessor));
    }
    else
    {
      ValuePtrAtuint64_t Index = C3DSourceAccessorGetValuePtrAtIndex(Accessor, 0);
    }
    int ComponentsCountPerValue = C3DMeshSourceGetComponentsCountPerValue(a2);
    glEnableVertexAttribArray(a4);
    if (a1) {
      ++*(_DWORD *)(a1 + 216);
    }
    ComponentsValueint Type = C3DSourceAccessorGetComponentsValueType(v17);
    if (C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue) == ComponentsValueType)
    {
      Componentint Type = C3DBaseTypeGetComponentType(ComponentsValueType);
      int ComponentsCountPerValue = C3DBaseTypeGetComponentCount(ComponentsValueType);
      ComponentsValueint Type = ComponentType;
    }
    unsigned int v24 = ComponentsValueType - 1;
    GLBOOLean v25 = 0;
    GLenum v26 = 5126;
    switch(v24)
    {
      case 0u:
        break;
      case 1u:
        GLBOOLean v25 = 0;
        GLenum v26 = 5124;
        break;
      case 3u:
        GLBOOLean v25 = 0;
        goto LABEL_31;
      case 5u:
        uint64_t v28 = scn_default_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          C3DRendererContextSetupResidentMeshSourceAtLocation_cold_2();
        }
        GLBOOLean v25 = 0;
        break;
      case 0xDu:
        GLBOOLean v25 = 1;
        GLenum v26 = 5122;
        break;
      case 0xEu:
        GLBOOLean v25 = 0;
        GLenum v26 = 5131;
        break;
      case 0xFu:
        GLBOOLean v25 = 0;
        goto LABEL_29;
      case 0x10u:
        GLBOOLean v25 = 1;
        GLenum v26 = 5123;
        break;
      case 0x14u:
        GLBOOLean v25 = 1;
LABEL_29:
        GLenum v26 = 5121;
        break;
      case 0x15u:
        GLBOOLean v25 = 1;
LABEL_31:
        GLenum v26 = 5120;
        break;
      case 0x16u:
        GLBOOLean v25 = 1;
        GLenum v26 = 33640;
        int ComponentsCountPerValue = 4;
        break;
      default:
        uint64_t v27 = scn_default_log();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          C3DRendererContextSetupResidentMeshSourceAtLocation_cold_1();
        }
        GLBOOLean v25 = 0;
        GLenum v26 = 5126;
        break;
    }
    GLsizei Library = C3DSceneSourceGetLibrary(v17);
    glVertexAttribPointer(a4, ComponentsCountPerValue, v26, v25, Library, ValuePtrAtIndex);
    if (a1) {
      ++*(_DWORD *)(a1 + 212);
    }
    if (*(unsigned char *)(a1 + 104))
    {
      GLuint InstancingDivisor = C3DMeshSourceGetInstancingDivisor(a2);
      glVertexAttribDivisor(a4, InstancingDivisor);
    }
  }
}

CFStringRef __CopyHashCodeFromShaderSources(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  CFStringUpdateHash(a1);
  CFStringUpdateHash(a2);
  CC_SHA256_Final(md, &c);
  uint64_t v4 = 0;
  CFTypeRef v5 = __str;
  do
  {
    snprintf(v5, 3uLL, "%02x", md[v4++]);
    v5 += 2;
  }
  while (v4 != 32);
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], __str, 0x8000100u);
}

void *C3DRendererContextCreateProgramObjectForProgram(uint64_t a1, uint64_t a2, CFDictionaryRef *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextCreateProgramObjectForProgram_cold_5(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  unsigned int Profile = C3DFXProgramGetProfile((uint64_t)a3);
  if (Profile >= 2)
  {
    if (Profile == 2)
    {
      uint64_t v30 = scn_default_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        C3DRendererContextCreateProgramObjectForProgram_cold_4();
      }
    }
    else
    {
      uint64_t v31 = scn_default_log();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        C3DRendererContextCreateProgramObjectForProgram_cold_1();
      }
    }
    return 0;
  }
  uint64_t ShaderSources = C3DFXGLSLProgramGetShaderSources(a3);
  if (!ShaderSources)
  {
    uint64_t v33 = scn_default_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateProgramObjectForProgram_cold_2();
    }
    return 0;
  }
  CFStringRef v25 = (const __CFString *)v24;
  if (!v24)
  {
    uint64_t v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateProgramObjectForProgram_cold_3();
    }
    return 0;
  }
  CFStringRef v26 = (const __CFString *)ShaderSources;
  CFStringRef v27 = __CopyHashCodeFromShaderSources(ShaderSources, v24);
  ValueForKefloat y = C3DKeyValueStoreGetValueForKey(a2, v27);
  if (ValueForKey)
  {
    uint64_t v29 = ValueForKey;
    C3DFXGLSLProgramObjectAttachWithProgram((uint64_t)ValueForKey);
    __FillProgramObjectLocations(a3, (uint64_t)v29);
    CFRelease(v27);
    CFRetain(v29);
    return v29;
  }
  GLint params = 0;
  glGetIntegerv(0x8B8Du, &params);
  if (a1) {
    ++*(_DWORD *)(a1 + 240);
  }
  uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)a3);
  uint64_t v37 = OverrideMaterial;
  if (!OverrideMaterial)
  {
    uint64_t v39 = 0;
    CFMutableStringRef Mutable = 0;
    if (!*(unsigned char *)(a1 + 92)) {
      goto LABEL_31;
    }
LABEL_30:
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    goto LABEL_31;
  }
  uint64_t Callbacks = C3DFXProgramDelegateGetCallbacks(OverrideMaterial);
  uint64_t v39 = Callbacks;
  if (Callbacks && *(void *)(Callbacks + 16)) {
    goto LABEL_30;
  }
  CFMutableStringRef Mutable = 0;
LABEL_31:
  IsClientPrograuint64_t m = C3DFXProgramIsClientProgram((uint64_t)a3);
  unsigned int v42 = C3DCreateProgram(a1, v26, v25, IsClientProgram, Mutable);
  if (Mutable)
  {
    if (CFStringGetLength(Mutable) >= 1)
    {
      if (v39)
      {
        CFErrorRef v43 = C3DErrorCreate(0, Mutable, &stru_26BF72F58);
        uint64_t v44 = *(void (**)(void, CFErrorRef, uint64_t))(v39 + 16);
        uint64_t UserInfo = C3DFXProgramDelegateGetUserInfo(v37);
        v44(0, v43, UserInfo);
        CFRelease(v43);
      }
      else if (*(unsigned char *)(a1 + 92))
      {
        uint64_t v46 = *(__CFDictionary **)(a1 + 96);
        if (!v46)
        {
          uint64_t v46 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
          *(void *)(a1 + 96) = v46;
        }
        CFDictionaryAddValue(v46, a3, Mutable);
      }
    }
    CFRelease(Mutable);
  }
  if (v42 && (uint64_t v47 = C3DFXGLSLProgramObjectCreateWithProgramID(v42)) != 0)
  {
    uint64_t v29 = (void *)v47;
    __FillProgramObjectLocations(a3, v47);
    glUseProgram(params);
    C3DResourceManagerSetGLSLProgramObjectForSourceHash(a2, v27, v29);
  }
  else
  {
    glUseProgram(params);
    uint64_t v29 = 0;
  }
  CFRelease(v27);
  return v29;
}

void __FillProgramObjectLocations(CFDictionaryRef *a1, uint64_t a2)
{
  *(void *)&v54[17] = *MEMORY[0x263EF8340];
  GLuint ProgramID = C3DFXGLSLProgramObjectGetProgramID(a2);
  int Profile = C3DFXProgramGetProfile((uint64_t)a1);
  CFTypeRef cf = a1;
  CFArrayRef v6 = C3DFXGLSLProgramCopyAttributesNames(a1);
  CFArrayRef v7 = v6;
  if (!v6 || !Profile)
  {
    for (uint64_t i = 0; i != 14; ++i)
    {
      CFStringGetCString(kC3DVertexAttribDefaultNames[i], buffer, 64, 0x600u);
      glBindAttribLocation(ProgramID, i, buffer);
    }
LABEL_9:
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  CFIndex Count = CFArrayGetCount(v6);
  if (Count >= 1)
  {
    CFIndex v9 = Count;
    for (CFIndex j = 0; j != v9; ++j)
    {
      ValueAtuint64_t Index = (const __CFString *)CFArrayGetValueAtIndex(v7, j);
      Attributeuint64_t Index = C3DFXGLSLProgramGetAttributeIndex(a1, ValueAtIndex);
      CFStringGetCString(ValueAtIndex, buffer, 64, 0x600u);
      glBindAttribLocation(ProgramID, AttributeIndex, buffer);
    }
    goto LABEL_9;
  }
LABEL_10:
  CFRelease(v7);
LABEL_11:
  glLinkProgram(ProgramID);
  *(void *)GLint params = 0;
  GLsizei length = 0;
  glGetProgramiv(ProgramID, 0x8B86u, &params[1]);
  glGetProgramiv(ProgramID, 0x8B87u, params);
  uint64_t v14 = (GLchar *)malloc_type_malloc(params[0] + 1, 0x9995C124uLL);
  uint64_t v15 = *(const void **)(a2 + 104);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a2 + 104) = 0;
  }
  *(void *)(a2 + 104) = CFDictionaryCreateMutable(0, params[1], MEMORY[0x263EFFF88], 0);
  CFMutableStringRef Mutable = CFArrayCreateMutable(0, params[1], MEMORY[0x263EFFF70]);
  if (params[1] >= 1)
  {
    signed int v17 = 0;
    do
    {
      glGetActiveUniform(ProgramID, v17, params[0], &length, 0, 0, v14);
      UniformLocatiouint64_t n = glGetUniformLocation(ProgramID, v14);
      GLsizei v19 = length;
      if (length)
      {
        uint64_t v20 = length;
        if (v14[length - 1] == 93)
        {
          do
          {
            GLsizei v19 = v20 - 1;
            GLsizei length = v20 - 1;
            if (v20 < 2) {
              break;
            }
            int v21 = v14[--v20];
          }
          while (v21 != 91);
        }
      }
      v14[v19] = 0;
      CFStringRef v22 = CFStringCreateWithCString(0, v14, 0x8000100u);
      CFArrayAppendValue(Mutable, v22);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 104), v22, (const void *)(UniformLocation + 1));
      CFRelease(v22);
      ++v17;
    }
    while (v17 < params[1]);
  }
  free(v14);
  GLint v50 = 0;
  glGetProgramiv(ProgramID, 0x8B89u, &v50);
  glGetProgramiv(ProgramID, 0x8B8Au, params);
  uint64_t v23 = (GLchar *)malloc_type_malloc(params[0] + 1, 0xA605503BuLL);
  uint64_t v24 = *(const void **)(a2 + 112);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a2 + 112) = 0;
  }
  *(void *)(a2 + 112) = CFDictionaryCreateMutable(0, v50, MEMORY[0x263EFFF88], 0);
  if (v50 >= 1)
  {
    for (signed int k = 0; k < v50; ++k)
    {
      glGetActiveAttrib(ProgramID, k, params[0], &length, 0, 0, v23);
      AttribLocatiouint64_t n = glGetAttribLocation(ProgramID, v23);
      v23[length] = 0;
      CFStringRef v27 = CFStringCreateWithCString(0, v23, 0x8000100u);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 112), v27, (const void *)(AttribLocation + 1));
      CFRelease(v27);
    }
  }
  free(v23);
  if (Mutable)
  {
    CFIndex v28 = CFArrayGetCount(Mutable);
    MaxUniformuint64_t Index = _C3DFXGLSLProgramGetMaxUniformIndex(a1);
    uint64_t v30 = (uint64_t)MaxUniformIndex + 1;
    uint64_t v31 = (uint64_t)MaxUniformIndex + v28;
    size_t v32 = 8 * ((void)MaxUniformIndex + v28) + 8;
    uint64_t v33 = malloc_type_malloc(v32, 0x100004000313F17uLL);
    uint64_t v34 = v33;
    if ((v31 & 0x8000000000000000) == 0) {
      memset(v33, 255, v32);
    }
    uint64_t v46 = v34;
    if (v28 >= 1)
    {
      for (CFIndex m = 0; m != v28; ++m)
      {
        CFStringRef v36 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, m);
        Uniformuint64_t Index = C3DFXGLSLProgramGetUniformIndex(cf, v36);
        if (UniformIndex == -1)
        {
          if (v30 > v31)
          {
            uint64_t v39 = scn_default_log();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT)) {
              __FillProgramObjectLocations_cold_2((uint8_t *)buffer, v54, v39);
            }
          }
          uint64_t v38 = v30 + 1;
        }
        else
        {
          uint64_t v38 = v30;
          uint64_t v30 = UniformIndex;
        }
        uint64_t v40 = v30;
        uint64_t v30 = v38;
        CFIndex v41 = CFStringGetLength(v36) + 1;
        unsigned int v42 = (char *)malloc_type_calloc(v41, 1uLL, 0xD9776BA1uLL);
        CFStringGetCString(v36, v42, v41, 0x600u);
        GLuint v43 = C3DFXGLSLProgramObjectGetProgramID(a2);
        int v44 = glGetUniformLocation(v43, v42);
        if (v42) {
          free(v42);
        }
        if (v40 <= v31)
        {
          v46[v40] = v44;
        }
        else
        {
          uint64_t v45 = scn_default_log();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
            __FillProgramObjectLocations_cold_1(&buf, v49, v45);
          }
        }
      }
    }
    C3DFXGLSLProgramObjectSetUniformsLocations(a2, v46, v30);
    free(v46);
    CFRelease(Mutable);
  }
}

void C3DRendererContextDeleteProgramObject(uint64_t a1, const void *a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererElementStateDrawRendererElement_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!C3DVRAMResourceLockCount((uint64_t)a2) && (C3DVRAMResourceIsAttachment((uint64_t)a2) & 1) == 0)
  {
    CFTypeID v12 = CFGetTypeID(a2);
    if (v12 == C3DFXGLSLProgramObjectGetTypeID())
    {
      GLuint ProgramID = C3DFXGLSLProgramObjectGetProgramID((uint64_t)a2);
      if (ProgramID)
      {
        if (a1) {
          --*(_DWORD *)(a1 + 400);
        }
        glDeleteProgram(ProgramID);
      }
    }
  }
}

void C3DRendererContextDeleteBufferObject(_DWORD *a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextDeleteBufferObject_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!C3DVRAMResourceLockCount(a2) && (C3DVRAMResourceIsAttachment(a2) & 1) == 0)
  {
    GLuint buffers = C3DBufferObjectGetBufferID(a2);
    if (!buffers)
    {
      uint64_t v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v15 = 0;
        _os_log_impl(&dword_20B249000, v14, OS_LOG_TYPE_DEFAULT, "Warning: Trying to delete an empty or already released VBO", v15, 2u);
      }
      goto LABEL_17;
    }
    int Size = C3DBufferObjectGetSize(a2);
    int v13 = *(_DWORD *)(a2 + 64);
    if (v13 == 1)
    {
      if (a1)
      {
        --a1[105];
        a1[111] -= Size;
        goto LABEL_16;
      }
    }
    else if (v13)
    {
      if (a1) {
        goto LABEL_16;
      }
    }
    else if (a1)
    {
      --a1[103];
      a1[110] -= Size;
LABEL_16:
      glDeleteBuffers(1, &buffers);
    }
LABEL_17:
    C3DVRAMResourceSetID(a2, 0);
  }
}

void C3DRendererContextApplyTextureSampler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DRendererContextApplyTextureSampler_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DTextureSamplerSetAnisotropy_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  GLenum v22 = *(_DWORD *)(a2 + 88);
  int WrapModeS = C3DTextureSamplerGetWrapModeS(a3);
  GLfloat v24 = 33071.0;
  GLfloat v25 = 33071.0;
  if (v22 == 3553)
  {
    if ((WrapModeS - 1) > 3) {
      GLfloat v25 = 10497.0;
    }
    else {
      GLfloat v25 = flt_20B5CD350[WrapModeS - 1];
    }
  }
  glTexParameterf(v22, 0x2802u, v25);
  int WrapModeT = C3DTextureSamplerGetWrapModeT(a3);
  if (v22 == 3553)
  {
    if ((WrapModeT - 1) > 3) {
      GLfloat v24 = 10497.0;
    }
    else {
      GLfloat v24 = flt_20B5CD350[WrapModeT - 1];
    }
  }
  glTexParameterf(v22, 0x2803u, v24);
  ComparisonFunCC_SHA256_CTX c = C3DTextureSamplerGetComparisonFunc(a3);
  if (ComparisonFunc)
  {
    int v28 = ComparisonFunc;
    glTexParameteri(v22, 0x884Cu, 34894);
    GLint v29 = gl_ComparisonFunc[v28];
    GLenum v30 = v22;
    GLenum v31 = 34893;
  }
  else
  {
    GLenum v30 = v22;
    GLenum v31 = 34892;
    GLint v29 = 0;
  }
  glTexParameteri(v30, v31, v29);
  unsigned int MinFilter = C3DTextureSamplerGetMinFilter(a3);
  unsigned int MagFilter = C3DTextureSamplerGetMagFilter(a3);
  int v34 = (*(unsigned __int8 *)(a2 + 80) << 31 >> 31) & C3DTextureSamplerGetMipFilter(a3);
  float v35 = 9729.0;
  float v36 = 9729.0;
  switch(v34)
  {
    case 2:
      if (MinFilter > 2) {
        break;
      }
      uint64_t v37 = (unsigned int *)&unk_20B5CD300;
      goto LABEL_26;
    case 1:
      if (MinFilter >= 3) {
        break;
      }
      uint64_t v37 = (unsigned int *)&unk_20B5CD2F4;
      goto LABEL_26;
    case 0:
      float v36 = 9729.0;
      if (MinFilter < 3)
      {
        uint64_t v37 = dword_20B5CD30C;
LABEL_26:
        float v36 = (float)v37[MinFilter];
      }
      break;
  }
  if (MagFilter <= 2) {
    float v35 = (float)dword_20B5CD30C[MagFilter];
  }
  glTexParameterf(v22, 0x2800u, v35);
  glTexParameterf(v22, 0x2801u, v36);
  float v38 = *(float *)(a3 + 64);
  if (*(float *)&C3DRendererContextApplyTextureSampler_largest_supported_anisotropy < 0.0)
  {
    glGetFloatv(0x84FFu, (GLfloat *)&C3DRendererContextApplyTextureSampler_largest_supported_anisotropy);
    if (a1) {
      ++*(_DWORD *)(a1 + 240);
    }
  }
  float v39 = 1.0;
  if (v38 == -1.0) {
    float v40 = 1.0;
  }
  else {
    float v40 = v38;
  }
  if (*(float *)&C3DRendererContextApplyTextureSampler_largest_supported_anisotropy < v40) {
    float v40 = *(float *)&C3DRendererContextApplyTextureSampler_largest_supported_anisotropy;
  }
  if (v40 >= 1.0) {
    float v39 = v40;
  }
  glTexParameterf(v22, 0x84FEu, v39);
}

uint64_t C3DGLTextureTypePixelSize(int a1, int a2)
{
  if ((a2 - 5120) > 6)
  {
    uint64_t result = 2;
    if (((a2 - 33635) > 3 || a2 == 33636) && (a2 - 32819) >= 2) {
      return 4;
    }
  }
  else if (((1 << a2) & 0x70) != 0)
  {
    if (a1 != 6407)
    {
      if (a1 == 32993 || a1 == 6408) {
        return 16;
      }
      return 0;
    }
    return 12;
  }
  else if (((1 << a2) & 3) != 0)
  {
    if (a1 != 6407)
    {
      if (a1 == 32993 || a1 == 6408) {
        return 4;
      }
      return 0;
    }
    return 3;
  }
  else
  {
    if (a1 != 6407)
    {
      if (a1 == 32993 || a1 == 6408) {
        return 8;
      }
      return 0;
    }
    return 6;
  }
  return result;
}

uint64_t _C3DRendererContextComputeRenderBufferInternalSize(uint64_t a1, int a2, int a3, int a4)
{
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D50u, &params);
  GLint v7 = params;
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D51u, &params);
  int v8 = params + v7;
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D52u, &params);
  GLint v9 = params;
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D53u, &params);
  int v10 = v8 + v9 + params;
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D54u, &params);
  GLint v11 = params;
  GLint params = 0;
  glGetRenderbufferParameteriv(0x8D41u, 0x8D55u, &params);
  int v12 = v10 + v11 + params;
  if (v12 < 0 != __OFADD__(v10, v11 + params)) {
    v12 += 7;
  }
  return (v12 >> 3) * (uint64_t)(a3 * a2 * a4);
}

float32x2_t *__C3DRendererContextGetDefaultInvalidTexture(uint64_t a1)
{
  uint64_t result = *(float32x2_t **)(a1 + 64);
  if (!result)
  {
    long long v4 = xmmword_20B5CD340;
    uint64_t v3 = C3DTextureSamplerBilinearNoAnisotropy();
    uint64_t result = _C3DRendererContextCreateTextureWithSize((_DWORD *)a1, 4, 4, v3, 6408, 0x80E1u, 0x1401u, (float32x4_t *)&v4);
    *(void *)(a1 + 64) = result;
  }
  return result;
}

float32x2_t *_C3DRendererContextCreateTextureWithSize(_DWORD *a1, GLsizei a2, GLsizei a3, uint64_t a4, GLint a5, GLenum a6, GLenum a7, float32x4_t *a8)
{
  *(void *)GLint params = 0;
  glGetIntegerv(0x8069u, params);
  glGenTextures(1, (GLuint *)&params[1]);
  if (a1)
  {
    ++a1[101];
    glBindTexture(0xDE1u, params[1]);
    ++a1[58];
  }
  else
  {
    glBindTexture(0xDE1u, params[1]);
  }
  if (a5 == 6408 && a8)
  {
    pixels = C3DMalloc((4 * a3 * a2));
    int16x8_t v17 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(*a8, (float32x4_t)vdupq_n_s32(0x437F0000u)));
    *(int16x4_t *)v17.i8 = vrev32_s16(vmovn_s32((int32x4_t)v17));
    *(int8x8_t *)v17.i8 = vext_s8(*(int8x8_t *)v17.i8, *(int8x8_t *)v17.i8, 6uLL);
    unsigned __int32 __pattern4 = vmovn_s16(v17).u32[0];
    memset_pattern4(pixels, &__pattern4, (4 * a3 * a2));
    glTexImage2D(0xDE1u, 0, 6408, a2, a3, 0, 0x80E1u, 0x1401u, 0);
    if (pixels)
    {
      glTexSubImage2D(0xDE1u, 0, 0, 0, a2, a3, 0x80E1u, 0x1401u, pixels);
      if (a1) {
        a1[69] += a3 * a2 * C3DGLTextureTypePixelSize(32993, 5121);
      }
      free(pixels);
    }
  }
  else
  {
    glTexImage2D(0xDE1u, 0, a5, a2, a3, 0, a6, a7, 0);
  }
  uint64_t v18 = (float32x2_t *)C3DTextureCreate();
  C3DTextureSetID((uint64_t)v18, params[1], 3553);
  C3DTextureSetFormat((uint64_t)v18, a5);
  v18[8] = vcvt_f32_s32((int32x2_t)__PAIR64__(a3, a2));
  C3DTextureSetServerStorageSize((uint64_t)v18, 0);
  C3DRendererContextApplyTextureSampler((uint64_t)a1, (uint64_t)v18, a4);
  glBindTexture(0xDE1u, 0);
  if (a1) {
    ++a1[58];
  }
  glBindTexture(0xDE1u, params[0]);
  return v18;
}

void C3DRendererContextBindTexture(uint64_t a1, float32x2_t *DefaultInvalidTexture, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (a5 <= 7)
  {
    if (!a1)
    {
      GLint v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        C3DEngineContextRenderScene_cold_2(v9, v10, v11, v12, v13, v14, v15, v16);
      }
    }
    int TextureUnitOffset = C3DRendererContextGetTextureUnitOffset(a1);
    glActiveTexture(a5 + TextureUnitOffset + 33984);
    if (!DefaultInvalidTexture)
    {
      DefaultInvaliduint64_t Texture = __C3DRendererContextGetDefaultInvalidTexture(a1);
      if (!DefaultInvalidTexture)
      {
        uint64_t v18 = scn_default_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          C3DRendererContextApplyTextureSampler_cold_2(v18, v19, v20, v21, v22, v23, v24, v25);
        }
        DefaultInvaliduint64_t Texture = 0;
      }
    }
    GLenum TargetMode = C3DTextureGetTargetMode((uint64_t)DefaultInvalidTexture);
    GLuint ID = C3DTextureGetID((uint64_t)DefaultInvalidTexture);
    glBindTexture(TargetMode, ID);
    if (a1) {
      ++*(_DWORD *)(a1 + 232);
    }
    *(_DWORD *)(a1 + 4 * a5 + 1040) = TargetMode;
    if (*(_DWORD *)(a1 + 1072) <= a5) {
      *(_DWORD *)(a1 + 1072) = a5 + 1;
    }
    if (a3)
    {
      float32x2_t v28 = DefaultInvalidTexture[12];
      if (*(void *)&v28 != C3DMeshSourceGetMTLVertexFormat(a3))
      {
        C3DRendererContextApplyTextureSampler(a1, (uint64_t)DefaultInvalidTexture, a3);
        DefaultInvalidTexture[12] = (float32x2_t)C3DMeshSourceGetMTLVertexFormat(a3);
      }
    }
  }
}

void _C3DRendererContextBindTextureGL(uint64_t a1, GLenum target, GLuint texture)
{
  if (a1) {
    ++*(_DWORD *)(a1 + 232);
  }
}

void C3DRendererContextDeleteTexture(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    long long v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (!C3DVRAMResourceLockCount(a2) && (C3DVRAMResourceIsAttachment(a2) & 1) == 0)
  {
    GLuint textures = C3DVRAMResourceGetID(a2);
    if (textures)
    {
      if (a1)
      {
        *(_DWORD *)(a1 + 452) -= C3DTextureGetServerStorageSize(a2);
        --*(_DWORD *)(a1 + 404);
      }
      glDeleteTextures(1, &textures);
      *(void *)(a2 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
  }
}

int32x2_t *C3DRendererContextCreateTextureWithImage(float32x2_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  GLuint textures = 0;
  if (!a2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  GLint params = 0;
  glGetIntegerv(0x8069u, &params);
  Imageint Type = C3DImageGetImageType(v4);
  BOOL v15 = C3DTextureSamplerUseMipmaps(a3);
  Textureint Size = (float32x2_t)C3DImageGetTextureSize(v4);
  if (C3DImageIsCubeMap(v4))
  {
    CFTypeRef v17 = 0;
    BOOL v15 = 0;
    uint64_t v18 = 0;
    *(_DWORD *)(a3 + 36) = 0;
    GLenum v19 = 34067;
    goto LABEL_16;
  }
  GLenum v19 = C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler(ImageType);
  v20.n64_u64[0] = C3DRendererContextInferTextureSizeForImageAndTextureSampler(v4, a3).n64_u64[0];
  float32x2_t v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)v20.n64_u64[0], a1[3]), (int8x8_t)a1[3], (int8x8_t)v20.n64_u64[0]);
  uint32x2_t v22 = (uint32x2_t)vceq_f32(v21, TextureSize);
  if ((vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0)
  {
    uint64_t v23 = C3DImageCopyCGImage(v4);
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v18 = (const void *)C3DImageCreateWithCGImageAndSize(v23, *(double *)&v21);
      int v25 = C3DImageNeedsUnpremultiply(v4);
      C3DImageSetNeedsUnpremultiply((uint64_t)v18, v25);
      CFRelease(v24);
      uint64_t v4 = (uint64_t)v18;
      goto LABEL_12;
    }
    CFStringRef v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateTextureWithImage_cold_7(v4, v26);
    }
  }
  uint64_t v18 = 0;
LABEL_12:
  if (C3DImageHasTextureRawData(v4))
  {
    CFTypeRef v17 = 0;
    GLenum v19 = 3553;
  }
  else
  {
    CFTypeRef v27 = C3DImageCopyBitmap(v4, 1);
    if (!v27)
    {
      float v36 = 0;
      uint64_t v37 = 0;
      goto LABEL_129;
    }
    CFTypeRef v17 = v27;
  }
LABEL_16:
  glGenTextures(1, &textures);
  if (!textures)
  {
    float32x2_t v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      C3DRendererContextCreateTextureWithImage_cold_6(v28, v29, v30, v31, v32, v33, v34, v35);
      if (a1) {
        goto LABEL_19;
      }
LABEL_22:
      glBindTexture(v19, textures);
      goto LABEL_23;
    }
  }
  if (!a1) {
    goto LABEL_22;
  }
LABEL_19:
  ++a1[50].i32[1];
  glBindTexture(v19, textures);
  ++a1[29].i32[0];
LABEL_23:
  float v36 = (int32x2_t *)C3DTextureCreate();
  v36[8] = (int32x2_t)TextureSize;
  C3DTextureSetID((uint64_t)v36, textures, v19);
  v36[5] = (int32x2_t)v4;
  if (!v4)
  {
    float v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      C3DImageGetURL_cold_1(v38, v39, v40, v41, v42, v43, v44, v45);
    }
  }
  v138[0] = 0;
  glGetIntegerv(0x8069u, v138);
  float32x2_t v46 = (float32x2_t)C3DImageGetTextureSize(v4);
  v47.n64_u64[0] = C3DRendererContextInferTextureSizeForImageAndTextureSampler(v4, a3).n64_u64[0];
  float32x2_t v48 = a1[3];
  int32x2_t v49 = vcgt_f32((float32x2_t)v47.n64_u64[0], v48);
  v50.i32[0] = vbsl_s8((int8x8_t)vdup_lane_s32(v49, 0), (int8x8_t)v48, (int8x8_t)v47.n64_u64[0]).u32[0];
  __int32 v121 = v50.i32[0];
  v50.i32[1] = v47.n64_i32[1];
  __int32 v118 = vbsl_s8((int8x8_t)vdup_lane_s32(v49, 1), *(int8x8_t *)&v48, *(int8x8_t *)&v50).i32[1];
  v50.i32[1] = v118;
  uint32x2_t v51 = (uint32x2_t)vceq_f32(v50, v46);
  if ((vpmin_u32(v51, v51).u32[0] & 0x80000000) != 0
    || (v119 = *(double *)&v50, (uint64_t v52 = C3DImageCopyCGImage(v4)) == 0))
  {
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v53 = v52;
    uint64_t v54 = (const void *)C3DImageCreateWithCGImageAndSize(v52, v119);
    int v55 = C3DImageNeedsUnpremultiply(v4);
    C3DImageSetNeedsUnpremultiply((uint64_t)v54, v55);
    CFRelease(v53);
    uint64_t v4 = (uint64_t)v54;
  }
  uint64_t v125 = v17;
  if (C3DImageHasTextureRawData(v4))
  {
    int v120 = v54;
    TextureRawCFDataRef Data = C3DImageGetTextureRawData(v4);
    BOOL IsCubeMap = C3DImageIsCubeMap(v4);
    ValueAtuint64_t Index = *(const __CFArray **)(TextureRawData + 40);
    if (IsCubeMap) {
      ValueAtuint64_t Index = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    }
    CFIndex Count = CFArrayGetCount(ValueAtIndex);
    uint64_t v129 = MEMORY[0x263EF8330];
    v60.n128_u64[0] = 0x40000000;
    uint64_t v130 = 0x40000000;
    uint64_t v131 = ___C3DRendererContextFillTextureWithImage_block_invoke;
    float v132 = &__block_descriptor_tmp_51;
    v133.i64[0] = Count;
    v133.u64[1] = (unint64_t)v46;
    uint64_t v134 = TextureRawData;
    unint64_t v135 = (unint64_t)a1;
    if (IsCubeMap)
    {
      GLenum v61 = v19;
      for (CFIndex i = 0; i != 6; ++i)
      {
        BOOL v63 = CFArrayGetValueAtIndex(*(CFArrayRef *)(TextureRawData + 40), i);
        ((void (*)(uint64_t *, void, const void *, void))v131)(&v129, i, v63, (i + 34069));
      }
    }
    else
    {
      GLenum v61 = v19;
      ___C3DRendererContextFillTextureWithImage_block_invoke((uint64_t)&v129, 0, *(CFArrayRef *)(TextureRawData + 40), v19, v60);
    }
    int v76 = 0;
    BOOL v77 = Count == 1;
    goto LABEL_125;
  }
  CFArrayRef v64 = (CGContext *)C3DImageCopyBitmap(v4, 1);
  if (v64)
  {
    char v65 = v64;
    GLenum v116 = v19;
    int v115 = v18;
    BOOL v114 = v15;
    if ((C3DLinearRenderingIsEnabled() & 1) != 0 || C3DWideGamutIsUsed())
    {
      CGContextRef v66 = C3DCreateSRGBBitmapContextWithContext(v65);
      if (v66 != v65 && (_C3DRendererContextFillTextureWithImage_done & 1) == 0)
      {
        _C3DRendererContextFillTextureWithImage_done = 1;
        uint64_t v67 = scn_default_log();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
          C3DRendererContextCreateTextureWithImage_cold_4();
        }
      }
      CGContextRelease(v65);
      char v65 = v66;
    }
    CFDataRef Data = CGBitmapContextGetData(v65);
    if (Data)
    {
      uint64_t v69 = (uint64_t)Data;
      float32x2_t v122 = (float32x2_t)__PAIR64__(v118, v121);
      unsigned int BytesPerRow = CGBitmapContextGetBytesPerRow(v65);
      unsigned int BitsPerComponent = CGBitmapContextGetBitsPerComponent(v65);
      unsigned int v72 = CGBitmapContextGetBitsPerPixel(v65) / BitsPerComponent;
      uint64_t Width = CGBitmapContextGetWidth(v65);
      int Height = CGBitmapContextGetHeight(v65);
      if (BytesPerRow == ((BitsPerComponent * (unint64_t)v72 * Width) >> 3)
        || (unsigned int v74 = ~(BytesPerRow / v72 * v72) + BytesPerRow, v74 > 7))
      {
        GLint v75 = 1;
      }
      else
      {
        GLint v75 = dword_20B5CD318[v74];
      }
      glPixelStorei(0xCF5u, v75);
      __int16 BitmapInfo = CGBitmapContextGetBitmapInfo(v65);
      int v80 = BitmapInfo & 0x1B;
      if (v80 != 1 || (int v81 = BitmapInfo & 0x7000, (BitmapInfo & 0x7000) != 0) && v81 != 12288 && v81 != 0x4000) {
        int v80 = 0;
      }
      float64x2_t v82 = vcvtq_f64_f32(v122);
      int v120 = v54;
      unsigned int v112 = BitsPerComponent;
      if (v72 == 1)
      {
        int v76 = 6409;
      }
      else
      {
        int v83 = v80 | ((unsigned __int16)(BitmapInfo & 0x100) >> 8);
        if (v72 == 4)
        {
          int v76 = 6408;
          if (v83) {
            int v84 = 6408;
          }
          else {
            int v84 = 32993;
          }
          int v117 = v84;
          if ((BitmapInfo & 0x100) != 0) {
            int v85 = 5131;
          }
          else {
            int v85 = 5123;
          }
          if (BitsPerComponent != 16) {
            int v85 = 5121;
          }
          int v113 = v85;
          goto LABEL_88;
        }
        if (v83)
        {
          int v76 = 6407;
        }
        else
        {
          float64x2_t v123 = v82;
          float v87 = scn_default_log();
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR)) {
            C3DRendererContextCreateTextureWithImage_cold_3();
          }
          int v76 = 6407;
          float64x2_t v82 = v123;
        }
      }
      if (BitsPerComponent == 16) {
        int v88 = 5123;
      }
      else {
        int v88 = 5121;
      }
      int v113 = v88;
      int v117 = v76;
LABEL_88:
      uint64x2_t v124 = vcvtq_u64_f64(v82);
      if (C3DImageNeedsUnpremultiply(v4) && C3DImageHasAlpha(v4))
      {
        float v89 = 0;
        int v90 = v113;
        uint64x2_t v91 = v124;
        if (v113 != 5123 && v117 == 6408)
        {
          float v92 = (char *)C3DMalloc(Height * BytesPerRow);
          float v89 = v92;
          if (Height)
          {
            unsigned int v96 = 0;
            for (int j = 0; j != Height; ++j)
            {
              unsigned int v98 = v96;
              for (uint64_t k = Width; k; --k)
              {
                uint64_t v100 = (char *)(v69 + v98);
                long long v101 = &v92[v98];
                unsigned int v102 = v100[3];
                if (v100[3])
                {
                  if (v102 == 255)
                  {
                    *long long v101 = *v100;
                    v101[1] = v100[1];
                    LOBYTE(v103) = v100[2];
                  }
                  else
                  {
                    float v104 = 1.0 / (float)v102;
                    LOBYTE(v93) = *v100;
                    float v105 = v104 * (float)LODWORD(v93);
                    LOBYTE(v94) = v100[1];
                    float v94 = v104 * (float)LODWORD(v94);
                    LOBYTE(v95) = v100[2];
                    float v106 = v104 * (float)v95;
                    unsigned int v95 = 1132396544;
                    if (v105 <= 1.0) {
                      float v107 = v105 * 255.0;
                    }
                    else {
                      float v107 = 255.0;
                    }
                    *long long v101 = (int)v107;
                    if (v94 <= 1.0) {
                      float v93 = v94 * 255.0;
                    }
                    else {
                      float v93 = 255.0;
                    }
                    v101[1] = (int)v93;
                    if (v106 <= 1.0) {
                      float v108 = v106 * 255.0;
                    }
                    else {
                      float v108 = 255.0;
                    }
                    int v103 = (int)v108;
                  }
                  v101[2] = v103;
                  v101[3] = v100[3];
                }
                else
                {
                  *(_DWORD *)long long v101 = 0;
                }
                v98 += 4;
              }
              v96 += BytesPerRow;
            }
          }
          int v90 = v113;
          uint64x2_t v91 = v124;
        }
        if (v89) {
          uint64_t v69 = (uint64_t)v89;
        }
      }
      else
      {
        float v89 = 0;
        int v90 = v113;
        uint64x2_t v91 = v124;
      }
      uint64_t v129 = MEMORY[0x263EF8330];
      uint64_t v130 = 0x40000000;
      uint64_t v131 = ___C3DRendererContextFillTextureWithImage_block_invoke_52;
      float v132 = &__block_descriptor_tmp_54_0;
      uint64x2_t v133 = v91;
      unint64_t v135 = __PAIR64__(v117, v76);
      int v136 = v90;
      BOOL v137 = v114;
      uint64_t v134 = (uint64_t)a1;
      if (C3DImageIsCubeMap(v4))
      {
        unsigned int v109 = C3DImageGetImageType(v4);
        v128[0] = MEMORY[0x263EF8330];
        v128[1] = 0x40000000;
        v128[2] = ___C3DRendererContextFillTextureWithImage_block_invoke_2;
        v128[3] = &unk_264006858;
        v128[4] = &v129;
        C3DImageEnumerateCubeMapFacePixelBuffers(v109, v124.i64[0], BytesPerRow, v124.i64[0] * ((v72 * v112) >> 3), (v72 * v112) >> 3, v69, (uint64_t)v128);
      }
      else
      {
        ((void (*)(uint64_t *, void, uint64_t))v131)(&v129, v116, v69);
      }
      uint64_t v18 = v115;
      if (v65) {
        CFRelease(v65);
      }
      GLenum v61 = v116;
      if (v89) {
        free(v89);
      }
      BOOL v77 = 0;
LABEL_125:
      uint64_t v37 = v125;
      C3DTextureSetFormat((uint64_t)v36, v76);
      uint64_t v54 = v120;
      if (!v120) {
        goto LABEL_127;
      }
      goto LABEL_126;
    }
    uint64_t v86 = scn_default_log();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateTextureWithImage_cold_2();
    }
    GLenum v61 = v19;
    if (v65) {
      CFRelease(v65);
    }
    BOOL v77 = 0;
  }
  else
  {
    uint64_t v78 = scn_default_log();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateTextureWithImage_cold_1(v4, v78);
    }
    BOOL v77 = 0;
    GLenum v61 = v19;
  }
  uint64_t v37 = v125;
  if (v54)
  {
LABEL_126:
    C3DImageReleaseBitmapCache((uint64_t)v54);
    CFRelease(v54);
  }
LABEL_127:
  glBindTexture(0xDE1u, v138[0]);
  v36[10].i8[0] = (v36[10].i8[0] & 0xFE | v77) ^ 1;
  C3DTextureSetServerStorageSize((uint64_t)v36, 0);
  glBindTexture(v61, 0);
  if (a1) {
    ++a1[29].i32[0];
  }
LABEL_129:
  if (v18)
  {
    C3DImageReleaseBitmapCache((uint64_t)v18);
    CFRelease(v18);
  }
  glBindTexture(0xDE1u, params);
  if (v37) {
    CFRelease(v37);
  }
  return v36;
}

uint64_t C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler(unsigned int a1)
{
  int v1 = C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(a1);
  if (v1 != 2)
  {
    if (v1 == 4) {
      return 34067;
    }
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback", v4, 2u);
    }
  }
  return 3553;
}

__n64 C3DRendererContextInferTextureSizeForImageAndTextureSampler(uint64_t a1, uint64_t a2)
{
  Textureint Size = C3DImageGetTextureSize(a1);
  Imageint Type = C3DImageGetImageType(a1);
  if (C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler(ImageType) == 3553
    && ((int WrapModeS = C3DTextureSamplerGetWrapModeS(a2),
         int WrapModeT = C3DTextureSamplerGetWrapModeT(a2),
         C3DTextureSamplerGetMipFilter(a2))
     || (WrapModeS & 0xFFFFFFFD) != 1
     || (WrapModeT & 0xFFFFFFFD) != 1))
  {
    result.n64_u64[0] = (unint64_t)TextureSize;
    if (((int)*(float *)TextureSize.i32 & ((int)*(float *)TextureSize.i32 - 1)) != 0)
    {
      int v8 = 1;
      do
      {
        int v9 = v8;
        v8 *= 2;
      }
      while (v9 < (int)*(float *)TextureSize.i32);
      result.n64_f32[0] = (float)v9;
    }
    if (((int)*(float *)&TextureSize.i32[1] & ((int)*(float *)&TextureSize.i32[1] - 1)) != 0)
    {
      int v10 = 1;
      do
      {
        int v11 = v10;
        v10 *= 2;
      }
      while (v11 < (int)*(float *)&TextureSize.i32[1]);
      result.n64_f32[1] = (float)v11;
    }
  }
  else
  {
    return (__n64)TextureSize;
  }
  return result;
}

uint64_t C3DCreateTextureFromIOSurface(uint64_t a1, const void *a2, int a3, uint64_t a4, double a5)
{
  GLuint textures = 0;
  glGenTextures(1, &textures);
  glBindTexture(0xDE1u, textures);
  if (a1) {
    ++*(_DWORD *)(a1 + 232);
  }
  glTexParameteri(0xDE1u, 0x2801u, 9729);
  glTexParameteri(0xDE1u, 0x2800u, 9729);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  GLContext = (void *)C3DRendererContextGetGLContext(a1);
  C3DIOSurfaceToTexImage((uint64_t)a2, GLContext, 0xDE1u, a3, a5);
  uint64_t v11 = C3DTextureCreate();
  C3DTextureSetID(v11, textures, 3553);
  *(double *)(v11 + 64) = a5;
  *(unsigned char *)(v11 + 80) &= ~1u;
  *(void *)(v11 + 104) = CFRetain(a2);
  C3DTextureSetFormat(v11, a3);
  C3DTextureSetServerStorageSize(v11, 0);
  C3DRendererContextApplyTextureSampler(a1, v11, a4);
  glBindTexture(0xDE1u, 0);
  if (a1) {
    ++*(_DWORD *)(a1 + 232);
  }
  return v11;
}

double *C3DRendererContextCreateRenderTargetWithDescription(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = BYTE1(a2);
  if (BYTE1(a2) != C3DFramebufferGetSampleCount(a3))
  {
    BOOL v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextCreateRenderTargetWithDescription_cold_4(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  uint64_t v23 = (double *)C3DRenderTargetCreate();
  double Size = C3DFramebufferGetSize(a3);
  C3DRenderTargetSetDescription((uint64_t)v23, a2);
  double v24 = Size;
  v23[5] = Size;
  if ((a2 & 0x1000000) != 0)
  {
    if (!a1)
    {
      int v25 = scn_default_log();
      BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_FAULT);
      double v24 = Size;
      if (v26)
      {
        C3DEngineContextRenderScene_cold_2(v25, v27, v28, v29, v30, v31, v32, v33);
        double v24 = Size;
      }
    }
    if (*(float *)&v24 == 0.0 || (float v34 = *((float *)&v24 + 1), *((float *)&v24 + 1) == 0.0))
    {
      uint64_t v42 = scn_default_log();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        C3DRendererContextCreateRenderTargetWithDescription_cold_2();
      }
      goto LABEL_25;
    }
    uint64_t v35 = C3DTextureSamplerNearest();
    float v36 = (_DWORD *)(a1 + 12 * a2);
    int v37 = v36[295];
    if ((a2 & 0x8000000) != 0)
    {
      IOSurfaceRef v43 = SCNIOSurfaceCreateWithSize(Size);
      TextureWithdouble Size = (const void *)C3DCreateTextureFromIOSurface(a1, v43, v37, v35, Size);
      CFRelease(v43);
      if (!TextureWithSize)
      {
LABEL_25:
        CFRelease(v23);
        return 0;
      }
    }
    else
    {
      TextureWithdouble Size = _C3DRendererContextCreateTextureWithSize((_DWORD *)a1, (int)*(float *)&Size, (int)v34, v35, v37, v36[296], v36[297], 0);
      if (!TextureWithSize) {
        goto LABEL_25;
      }
    }
    C3DRenderTargetSetTexture((uint64_t)v23, TextureWithSize);
    *((void *)v23 + _Block_object_dispose(&STACK[0x2A0], 8) = C3DTextureGetServerStorageSize((uint64_t)TextureWithSize);
    CFRelease(TextureWithSize);
    return v23;
  }
  if (*(float *)&Size == 0.0 || *((float *)&Size + 1) == 0.0)
  {
    uint64_t v39 = scn_default_log();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextCreateRenderTargetWithDescription_cold_1();
    }
    uint64_t v40 = 0;
    GLuint v41 = 0;
  }
  else
  {
    renderGLuint buffers = 0;
    glGenRenderbuffers(1, &renderbuffers);
    if (a1)
    {
      ++*(_DWORD *)(a1 + 416);
      GLint params = 0;
      glGetIntegerv(0x8CA7u, &params);
      ++*(_DWORD *)(a1 + 240);
    }
    else
    {
      GLint params = 0;
      glGetIntegerv(0x8CA7u, &params);
    }
    glBindRenderbuffer(0x8D41u, renderbuffers);
    if (a2 == 41 || a2 == 44 || (uint64_t v44 = *(void *)(a3 + 136)) == 0)
    {
      uint64_t v48 = a1 + 4 * a2;
      int v46 = (int)*(float *)&Size;
      int v47 = (int)*((float *)&Size + 1);
      if (v14 < 2) {
        glRenderbufferStorage(0x8D41u, *(_DWORD *)(v48 + 1732), (int)*(float *)&Size, (int)*((float *)&Size + 1));
      }
      else {
        uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a1 + 1984))(36161, v14, *(unsigned int *)(v48 + 1732), (int)*(float *)&Size, (int)*((float *)&Size + 1));
      }
    }
    else
    {
      uint64_t v45 = (*(uint64_t (**)(void))(v44 + 16))();
      int v46 = (int)*(float *)&Size;
      int v47 = (int)*((float *)&Size + 1);
    }
    uint64_t v40 = _C3DRendererContextComputeRenderBufferInternalSize(v45, v46, v47, v14);
    glBindRenderbuffer(0x8D41u, params);
    GLuint v41 = renderbuffers;
  }
  C3DRenderTargetSetRenderBuffer((uint64_t)v23, v41);
  *((void *)v23 + _Block_object_dispose(&STACK[0x2A0], 8) = v40;
  if (a1) {
    *(_DWORD *)(a1 + 436) += v40;
  }
  return v23;
}

BOOL C3DRendererContextSetupFramebuffer(uint64_t a1, uint64_t a2)
{
  context[2] = *MEMORY[0x263EF8340];
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextSetupFramebuffer_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  int FBO = C3DFramebufferGetFBO(a2);
  if (FBO)
  {
    uint64_t v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextSetupFramebuffer_cold_1();
    }
  }
  else
  {
    frameGLuint buffers = 0;
    glGenFramebuffers(1, &framebuffers);
    if (a1) {
      ++*(_DWORD *)(a1 + 408);
    }
    C3DFramebufferSetFBO(a2, framebuffers);
    C3DRendererContextBindFramebuffer(a1, a2);
    CFDictionaryRef RenderTargetDescriptions = (const __CFDictionary *)C3DFramebufferGetRenderTargetDescriptions(a2);
    if (RenderTargetDescriptions
      && (CFDictionaryRef v23 = RenderTargetDescriptions, CFDictionaryGetCount(RenderTargetDescriptions) >= 1))
    {
      context[0] = a1;
      context[1] = a2;
      CFDictionaryApplyFunction(v23, (CFDictionaryApplierFunction)_attachRenderTargetDescription, context);
    }
    else
    {
      Renderuint64_t Target = C3DFramebufferGetRenderTarget(a2, 0);
      if (RenderTarget) {
        C3DRenderContextAttachRenderTargetToFramebuffer(a1, (uint64_t)RenderTarget, 0);
      }
      int v25 = C3DFramebufferGetRenderTarget(a2, 4);
      if (v25) {
        C3DRenderContextAttachRenderTargetToFramebuffer(a1, (uint64_t)v25, 4);
      }
      BOOL v26 = C3DFramebufferGetRenderTarget(a2, 5);
      if (v26) {
        C3DRenderContextAttachRenderTargetToFramebuffer(a1, (uint64_t)v26, 5);
      }
    }
    C3DRendererContextUnbindFramebuffer(a1);
  }
  return FBO == 0;
}

void C3DRendererContextBindFramebuffer(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetupFramebuffer_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (!v12)
  {
    uint64_t v12 = C3DStackCreate(8u, (uint64_t)kCFTypeStackCallBacks, 8uLL);
    *(void *)(a1 + 72) = v12;
  }
  if (!C3DStackGetCount(v12))
  {
    GLint params = 0;
    glGetIntegerv(0x8CA6u, &params);
    ++*(_DWORD *)(a1 + 240);
    *(void *)(a1 + 80) = params;
  }
  C3DStackPush(*(void *)(a1 + 72));
  C3DStackSetValue(*(void *)(a1 + 72), a2);
  _C3DRendererContextBindFramebuffer(a1, a2);
}

void _attachRenderTargetDescription(char a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  uint64_t v6 = C3DSceneSourcePerformConsistencyCheck(a2);
  RenderTargetWithDescriptiouint64_t n = C3DRendererContextCreateRenderTargetWithDescription(v4, v6, v5);
  uint64_t v8 = a1;
  C3DRenderContextAttachRenderTargetToFramebuffer(v4, (uint64_t)RenderTargetWithDescription, v8);
  C3DFramebufferAddRenderTarget(v5, RenderTargetWithDescription, v8);

  CFRelease(RenderTargetWithDescription);
}

uint64_t C3DRenderContextAttachRenderTargetToFramebuffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  GLenum v5 = (*(uint64_t (**)(uint64_t))(a1 + 1920))(a3);
  if (*(unsigned char *)(a2 + 19))
  {
    uint64_t Texture = C3DRenderTargetGetTexture(a2);
    GLuint ID = C3DTextureGetID(Texture);
    GLenum TargetMode = C3DTextureGetTargetMode(Texture);
    glFramebufferTexture2D(0x8D40u, v5, TargetMode, ID, 0);
  }
  else
  {
    GLuint RenderBuffer = C3DRenderTargetGetRenderBuffer(a2);
    glFramebufferRenderbuffer(0x8D40u, v5, 0x8D41u, RenderBuffer);
  }
  uint64_t result = C3DAnimationGetKeyPath(a2);
  *(_DWORD *)(a1 + 432) += result;
  return result;
}

void C3DRendererContextUnbindFramebuffer(uint64_t a1)
{
  uint64_t Value = C3DStackGetValue(*(void *)(a1 + 72));
  if (Value)
  {
    uint64_t v3 = Value;
    if ((*(unsigned char *)(Value + 128) & 1) == 0)
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        C3DRendererContextUnbindFramebuffer_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    *(unsigned char *)(v3 + 128) &= ~1u;
  }
  else
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextUnbindFramebuffer_cold_1();
    }
  }
  C3DStackPop(*(void *)(a1 + 72));
  if (C3DStackGetCount(*(void *)(a1 + 72)))
  {
    uint64_t v13 = C3DStackGetValue(*(void *)(a1 + 72));
    if (v13)
    {
      _C3DRendererContextBindFramebuffer(a1, v13);
      return;
    }
  }
  else
  {
    LODWORD(v13) = *(_DWORD *)(a1 + 80);
  }
  glBindFramebuffer(0x8D40u, v13);
  ++*(_DWORD *)(a1 + 204);
}

void _C3DRendererContextBindFramebuffer(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetupFramebuffer_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  GLuint FBO = C3DFramebufferGetFBO(a2);
  *(unsigned char *)(a2 + 128) |= 1u;
  glBindFramebuffer(0x8D40u, FBO);
  if (a1) {
    ++*(_DWORD *)(a1 + 204);
  }
}

void C3DRendererContextRestoreFramebuffer(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 72);
    if (v2)
    {
      uint64_t Value = C3DStackGetValue(v2);
      if (Value)
      {
        _C3DRendererContextBindFramebuffer(a1, Value);
      }
    }
  }
}

uint64_t C3DRendererContextGetBoundFramebuffer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 72)) != 0) {
    return C3DStackGetValue(v1);
  }
  else {
    return 0;
  }
}

uint64_t C3DRendererContextResolveFramebuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, long long *a6)
{
  GLuint FBO = C3DFramebufferGetFBO(a3);
  glBindFramebuffer(0x8CA8u, FBO);
  GLuint v12 = C3DFramebufferGetFBO(a2);
  glBindFramebuffer(0x8CA9u, v12);
  if (a1) {
    ++*(_DWORD *)(a1 + 204);
  }
  double Size = C3DFramebufferGetSize(a2);
  if (a6)
  {
    long long v14 = *a6;
  }
  else
  {
    *(void *)&long long v14 = 0;
    *((double *)&v14 + 1) = Size;
  }
  if (a4) {
    unsigned int v15 = 0x4000;
  }
  else {
    unsigned int v15 = 0;
  }
  if (a5) {
    v15 |= 0x100u;
  }
  return (*(uint64_t (**)(void, void, void, void, void, void, void, void, uint64_t, uint64_t))(a1 + 1952))((int)*(float *)&v14, (int)*((float *)&v14 + 1), (int)*((float *)&v14 + 2), (int)*((float *)&v14 + 3), (int)*(float *)&v14, (int)*((float *)&v14 + 1), (int)*((float *)&v14 + 2), (int)*((float *)&v14 + 3), v15 | 0x260000000000, a1);
}

void _C3DRendererContextDeleteRenderBuffer(uint64_t a1, GLuint a2)
{
  renderGLuint buffers = a2;
  if (a1)
  {
    --*(_DWORD *)(a1 + 416);
  }
  else
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  glDeleteRenderbuffers(1, &renderbuffers);
}

void C3DRendererContextDeleteRenderTarget(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 19))
  {
    uint64_t Texture = C3DRenderTargetGetTexture(a2);
    C3DRendererContextDeleteTexture(a1, Texture);
    if (!a1) {
      return;
    }
    int KeyPath = C3DAnimationGetKeyPath(a2);
    uint64_t v6 = (_DWORD *)(a1 + 452);
  }
  else
  {
    GLuint RenderBuffer = C3DRenderTargetGetRenderBuffer(a2);
    _C3DRendererContextDeleteRenderBuffer(a1, RenderBuffer);
    if (!a1) {
      return;
    }
    int KeyPath = C3DAnimationGetKeyPath(a2);
    uint64_t v6 = (_DWORD *)(a1 + 436);
  }
  *v6 -= KeyPath;
  *(_DWORD *)(a1 + 432) -= C3DAnimationGetKeyPath(a2);
}

void C3DRendererContextDeleteFramebuffer(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    context[0] = MEMORY[0x263EF8330];
    context[1] = 0x40000000;
    context[2] = __C3DRendererContextDeleteFramebuffer_block_invoke;
    void context[3] = &__block_descriptor_tmp_20_1;
    context[4] = a1;
    C3DFramebufferApplyToRenderTargets(a2, context);
  }
  frameGLuint buffers = C3DFramebufferGetFBO(a2);
  if (framebuffers)
  {
    if (a1) {
      --*(_DWORD *)(a1 + 408);
    }
    glDeleteFramebuffers(1, &framebuffers);
  }
  C3DFramebufferCleanup(a2);
}

void __C3DRendererContextDeleteFramebuffer_block_invoke(uint64_t a1, uint64_t a2)
{
}

uint64_t C3DRendererContextPushBlendStatesOverride(uint64_t result)
{
  return result;
}

uint64_t C3DRendererContextPopBlendStatesOverride(uint64_t result)
{
  return result;
}

void C3DRendererContextSetRasterizerStates(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!a2) {
    uint64_t v2 = C3DRasterizerStatesDefault();
  }
  if (*(void *)(a1 + 1096) != v2)
  {
    uint64_t v41 = 0;
    *(void *)flag = 0;
    int v44 = 0;
    uint64_t v43 = 0;
    C3DRasterizerStatesGetDesc(v2, (uint64_t)&v41);
    uint64_t v4 = *(void *)(a1 + 1096);
    if (!v4)
    {
      LOBYTE(v5) = -1;
      goto LABEL_27;
    }
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    int v40 = 0;
    uint64_t v39 = 0;
    C3DRasterizerStatesGetDesc(v4, (uint64_t)&v37);
    if (v38 == flag[0]) {
      int v5 = v37 != v41;
    }
    else {
      int v5 = (v37 != v41) | 2;
    }
    if (flag[0])
    {
      if (BYTE2(v38) != flag[2] || v38 == 0) {
        v5 |= 4u;
      }
      if ((_BYTE)v38 && BYTE1(v38) == flag[1]) {
        goto LABEL_21;
      }
    }
    else
    {
      if ((_BYTE)v38) {
        goto LABEL_21;
      }
      v5 |= 4u;
    }
    v5 |= 8u;
LABEL_21:
    if (flag[3] | BYTE3(v38))
    {
      LOBYTE(v5) = v5 | 0x10;
    }
    else if (!v5)
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        C3DRendererContextSetRasterizerStates_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
      }
      LOBYTE(v5) = 0;
    }
LABEL_27:
    int v15 = flag[0];
    GLBOOLean v16 = flag[1];
    uint64_t v17 = flag[2];
    int v18 = flag[3];
    int v19 = flag[4];
    uint64_t v20 = flag[5];
    GLuint v36 = flag[7];
    GLint v21 = v43;
    uint64_t v35 = BYTE1(v43);
    uint64_t v34 = BYTE2(v43);
    uint64_t v33 = BYTE3(v43);
    uint64_t v26 = BYTE4(v43);
    GLuint v28 = BYTE5(v43);
    GLuint v31 = BYTE6(v43);
    masuint64_t k = flag[6];
    uint64_t v30 = v44;
    uint64_t v29 = BYTE1(v44);
    uint64_t v27 = BYTE2(v44);
    if ((v5 & 1) == 0)
    {
      if ((v5 & 2) == 0) {
        goto LABEL_29;
      }
      goto LABEL_41;
    }
    if (v41 == 2)
    {
      glDisable(0xB44u);
    }
    else
    {
      if (v41 == 1)
      {
        glEnable(0xB44u);
        GLenum v22 = 1028;
      }
      else
      {
        if (v41) {
          goto LABEL_40;
        }
        glEnable(0xB44u);
        GLenum v22 = 1029;
      }
      glCullFace(v22);
    }
LABEL_40:
    ++*(_DWORD *)(a1 + 236);
    if ((v5 & 2) == 0)
    {
LABEL_29:
      if ((v5 & 4) == 0) {
        goto LABEL_30;
      }
      goto LABEL_45;
    }
LABEL_41:
    if (v15) {
      glEnable(0xB71u);
    }
    else {
      glDisable(0xB71u);
    }
    ++*(_DWORD *)(a1 + 236);
    if ((v5 & 4) == 0)
    {
LABEL_30:
      if ((v5 & 8) == 0) {
        goto LABEL_31;
      }
      goto LABEL_46;
    }
LABEL_45:
    glDepthFunc(gl_ComparisonFunc[v17]);
    ++*(_DWORD *)(a1 + 236);
    if ((v5 & 8) == 0)
    {
LABEL_31:
      if ((v5 & 0x10) == 0) {
        goto LABEL_54;
      }
      goto LABEL_47;
    }
LABEL_46:
    glDepthMask(v16);
    ++*(_DWORD *)(a1 + 236);
    if ((v5 & 0x10) == 0)
    {
LABEL_54:
      *(void *)(a1 + 1096) = v2;
      return;
    }
LABEL_47:
    if (v18)
    {
      glEnable(0xB90u);
      GLenum v23 = gl_ComparisonFunc[v20];
      if (v19)
      {
        glStencilFuncSeparate(0x404u, v23, v21, mask);
        glStencilOpSeparate(0x404u, gl_StencilOp[v33], gl_StencilOp[v34], gl_StencilOp[v35]);
        glStencilMaskSeparate(0x404u, v36);
        glStencilFuncSeparate(0x405u, gl_ComparisonFunc[v26], v21, v28);
        glStencilOpSeparate(0x405u, gl_StencilOp[v27], gl_StencilOp[v29], gl_StencilOp[v30]);
        GLenum v24 = 1029;
        GLuint v25 = v31;
      }
      else
      {
        glStencilFuncSeparate(0x408u, v23, v21, mask);
        glStencilOpSeparate(0x408u, gl_StencilOp[v33], gl_StencilOp[v34], gl_StencilOp[v35]);
        GLenum v24 = 1032;
        GLuint v25 = v36;
      }
      glStencilMaskSeparate(v24, v25);
    }
    else
    {
      glDisable(0xB90u);
    }
    ++*(_DWORD *)(a1 + 236);
    goto LABEL_54;
  }
}

void C3DRendererContextRenderResidentMeshElement(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  __drawCall(a1);
}

void __drawCall(uint64_t a1)
{
  GLenum v1 = *(_DWORD *)(a1 + 1124);
  unsigned int v2 = *(_DWORD *)(a1 + 1144);
  int32x2_t v3 = vadd_s32(*(int32x2_t *)(a1 + 188), (int32x2_t)(v2 | 0x100000000));
  *(int32x2_t *)(a1 + 18_Block_object_dispose(&STACK[0x2A0], 8) = v3;
  GLsizei v4 = *(_DWORD *)(a1 + 1128);
  int v5 = *(_DWORD *)(a1 + 184) + v4;
  *(_DWORD *)(a1 + 184) = v5;
  switch(*(_DWORD *)(a1 + 1120))
  {
    case 0:
      glDrawArrays(v1, 0, v4);
      break;
    case 1:
      GLenum v7 = *(_DWORD *)(a1 + 1132);
      uint64_t v8 = *(const GLvoid **)(a1 + 1136);
      glDrawElements(v1, v4, v7, v8);
      break;
    case 2:
      int v9 = *(_DWORD *)(a1 + 1148) - 1;
      *(_DWORD *)(a1 + 184) = v5 + v4 * v9;
      *(_DWORD *)(a1 + 18_Block_object_dispose(&STACK[0x2A0], 8) = v3.i32[0] + v9 * v2;
      __assert_rtn("__drawCall", "C3DRendererContextGL.c", 3465, "0");
    case 3:
      __drawCall_cold_2();
    default:
      uint64_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        __drawCall_cold_1();
      }
      break;
  }
}

double C3DRendererContextGetViewport()
{
  long long v1 = 0uLL;
  glGetFloatv(0xBA2u, (GLfloat *)&v1);
  return *(double *)&v1;
}

void C3DRendererContextSetViewport(__n128 a1)
{
}

float C3DRendererContextGetContentScaleFactor(uint64_t a1)
{
  return *(float *)(a1 + 52);
}

uint64_t C3DRendererContextSetContentScaleFactor(uint64_t result, float a2)
{
  *(float *)(result + 52) = a2;
  return result;
}

uint64_t C3DRendererContextGetSampleCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t C3DRendererContextSetSampleCount(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4_Block_object_dispose(&STACK[0x2A0], 8) = a2;
  return result;
}

void C3DRendererContextSetLight(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, unsigned int *a5)
{
  if (!*(void *)(a1 + 176))
  {
    uint64_t v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetLight_cold_3(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  if (a2 >= 8)
  {
    int v18 = scn_default_log();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetLight_cold_2(a2, v18);
    }
  }
  uint64_t v19 = *(void *)(a1 + 176);
  uint64_t v20 = 16 * a2;
  uint64_t v21 = 16 * a2 + 18;
  uint64_t v22 = 16 * a2 + 19;
  uint64_t v23 = 16 * a2 + 20;
  UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation(v19, v21);
  if (UniformLocation != -1)
  {
    C3DLightGetColorModulatedByIntensity((uint64_t)a3, v25, v26, v27, v28, v29, v30, v31);
    v58[0].i64[0] = v32;
    v58[0].i64[1] = v33;
    if (C3DLinearRenderingIsEnabled()) {
      C3DColor4ConvertToNonLinear(v58);
    }
    glUniform4fv(UniformLocation, 1, v58[0].f32);
  }
  GLint v34 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v22);
  if (v34 != -1) {
    glUniform4f(v34, *(GLfloat *)(a4 + 16), *(GLfloat *)(a4 + 20), *(GLfloat *)(a4 + 24), 0.0);
  }
  GLint v35 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v23);
  if (v35 != -1) {
    glUniform4f(v35, *(GLfloat *)(a4 + 32), *(GLfloat *)(a4 + 36), *(GLfloat *)(a4 + 40), 0.0);
  }
  GLint v36 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v20 + 23);
  if (v36 != -1) {
    glUniform4f(v36, *(GLfloat *)(a4 + 80), *(GLfloat *)(a4 + 84), *(GLfloat *)(a4 + 88), 0.0);
  }
  GLint v37 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v20 + 24);
  if (v37 != -1) {
    glUniform4f(v37, *(GLfloat *)(a4 + 96), *(GLfloat *)(a4 + 100), *(GLfloat *)(a4 + 104), 0.0);
  }
  if (*(void *)(a4 + 408) && *(void *)(a4 + 400))
  {
    if (a3 && a3[10].i8[8] && (a3[10].i8[9] & 1) == 0)
    {
      uint64_t v38 = v20 + 30;
      uint64_t v39 = v20 + 31;
      GLint v40 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v20 + 32);
      if (v40 == -1)
      {
LABEL_34:
        uint64_t v44 = v20 + 33;
        GLint v46 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v38);
        if (v46 != -1)
        {
          if (*a5 >= 8)
          {
            int v47 = scn_default_log();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
              C3DRendererContextSetLight_cold_1(v47, v48, v49, v45, v50, v51, v52, v53);
            }
          }
          C3DRendererContextBindTexture(a1, *(float32x2_t **)(a4 + 400), *(void *)(a4 + 408), v45, *a5);
          glUniform1i(v46, *a5);
          C3DFXGLSLProgramObjectSetUniformValueAtIndex(v19, v38, *a5);
          ++*a5;
        }
        GLint v54 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v39);
        if (v54 != -1)
        {
          float32x4_t v55 = *(float32x4_t *)(a4 + 144);
          v58[0] = *(float32x4_t *)(a4 + 128);
          v58[1] = v55;
          float32x4_t v56 = *(float32x4_t *)(a4 + 176);
          __n128 v58[2] = *(float32x4_t *)(a4 + 160);
          void v58[3] = v56;
          glUniformMatrix4fv(v54, 1, 0, v58[0].f32);
          ++*(_DWORD *)(a1 + 264);
        }
        GLint v57 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v44);
        if (v57 != -1)
        {
          v58[0] = a3[7];
          if (C3DLinearRenderingIsEnabled()) {
            C3DColor4ConvertToNonLinear(v58);
          }
          glUniform4fv(v57, 1, v58[0].f32);
        }
        return;
      }
      int8x8_t RealShadowMapSize = C3DLightGetRealShadowMapSize((uint64_t)a3);
      if (*(float *)RealShadowMapSize.i32 <= *(float *)&RealShadowMapSize.i32[1]) {
        RealShadowMapSize.i32[0] = RealShadowMapSize.i32[1];
      }
      if (*(float *)RealShadowMapSize.i32 < 1.0) {
        *(float *)RealShadowMapSize.i32 = 1.0;
      }
      v58[0].f32[0] = a3[8].f32[3] / *(float *)RealShadowMapSize.i32;
      uint64_t v42 = v58;
    }
    else
    {
      uint64_t v38 = v20 + 25;
      uint64_t v39 = v20 + 26;
      GLint v40 = C3DFXGLSLProgramObjectGetUniformLocation(v19, v20 + 27);
      if (v40 == -1) {
        goto LABEL_34;
      }
      uint64_t Gobo = C3DLightGetGobo((uint64_t)a3, 0);
      if (!Gobo) {
        goto LABEL_34;
      }
      uint64_t v42 = (float32x4_t *)(Gobo + 72);
    }
    glUniform1fv(v40, 1, v42->f32);
    ++*(_DWORD *)(a1 + 244);
    goto LABEL_34;
  }
}

void C3DRendererContextBindCommonProfile(float32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6, GLfloat a7)
{
  v37[0] = a3;
  v37[1] = a4;
  int v38 = 0;
  uint64_t v40 = a2;
  GLfloat v39 = a7;
  __SetupCommonProfileEffectProperty(a1, 7, v37);
  __SetupCommonProfileEffectProperty(a1, 2, v37);
  if (C3DEffectCommonProfileIsUsingSelfIllumination(a3)) {
    int v13 = 9;
  }
  else {
    int v13 = 0;
  }
  __SetupCommonProfileEffectProperty(a1, v13, v37);
  __SetupCommonProfileEffectProperty(a1, 6, v37);
  if (!__SetupCommonProfileEffectProperty(a1, 8, v37)) {
    __SetupCommonProfileEffectProperty(a1, 1, v37);
  }
  __SetupCommonProfileEffectProperty(a1, 3, v37);
  __SetupCommonProfileEffectProperty(a1, 16, v37);
  __SetupCommonProfileEffectProperty(a1, 19, v37);
  if (*(_DWORD *)(a3 + 24) == 5)
  {
    uint64_t v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      C3DRendererContextBindCommonProfile_cold_1();
    }
    *(_DWORD *)(a3 + 24) = 2;
  }
  if (a1[11].i8[1]) {
    __SetupCommonProfileEffectProperty(a1, 4, v37);
  }
  int TransparencyMode = C3DEffectCommonProfileGetTransparencyMode(a3);
  FloatPropertfloat y = C3DEffectCommonProfileGetFloatProperty((float *)a3, 18);
  *(unsigned char *)(a4 + 260) = TransparencyMode;
  BOOL v17 = __SetupCommonProfileEffectProperty(a1, 5, v37);
  if (a7 >= 1.0 && C3DEffectCommonProfileIsOpaque(a3) && (a5 & 1) != 0)
  {
    uint64_t v18 = C3DBlendStatesDefaultReplace();
    C3DRendererContextSetBlendStates((uint64_t)a1, v18);
    *(unsigned char *)(a4 + 260) = -1;
    goto LABEL_32;
  }
  uint64_t v19 = (uint64_t)a1[22];
  UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation(v19, 168);
  if (UniformLocation != -1)
  {
    float v21 = 1.0;
    if (TransparencyMode != 1) {
      float v21 = a7;
    }
    glUniform1f(UniformLocation, FloatProperty * v21);
  }
  uint64_t v22 = C3DFXGLSLProgramObjectGetUniformLocation(v19, 9);
  if (v22 != -1) {
    glUniform1f(v22, a7);
  }
  if (C3DEffectCommonProfileContainsContentForEffectProperty(a3, 2)) {
    int v23 = C3DEffectCommonProfileContentIsOpaqueForEffectProperty(a3, 2) ^ 1;
  }
  else {
    LOBYTE(v23) = 0;
  }
  char v24 = v17 | v23 | a5 ^ 1;
  if (TransparencyMode != 1)
  {
    if ((v24 & 1) == 0)
    {
      float ConstantAlpha = C3DEffectCommonProfileGetConstantAlpha((float *)a3);
      glBlendColor(0.0, 0.0, 0.0, ConstantAlpha * a7);
      uint64_t v34 = C3DBlendStatesDefaultConstantAlpha();
      goto LABEL_31;
    }
    goto LABEL_29;
  }
  if (v24)
  {
LABEL_29:
    uint64_t v34 = C3DBlendStatesDefaultOver();
    goto LABEL_31;
  }
  double v25 = a7;
  Color = (float *)C3DEffectCommonProfileGetColor(a3, 5);
  float v27 = Color[1];
  float v28 = Color[2];
  float v29 = v27 * 0.71516 + *Color * 0.212671 + v28 * 0.072169;
  GLfloat v30 = (1.0 - (float)(FloatProperty * *Color)) * v25;
  GLfloat v31 = (1.0 - (float)(FloatProperty * v27)) * v25;
  GLfloat v32 = (1.0 - (float)(FloatProperty * v28)) * v25;
  GLfloat v33 = (1.0 - (float)(FloatProperty * v29)) * v25;
  glBlendColor(v30, v31, v32, v33);
  uint64_t v34 = C3DBlendStatesDefaultConstantColor();
LABEL_31:
  C3DRendererContextSetBlendStates((uint64_t)a1, v34);
LABEL_32:
  switch(a6)
  {
    case 1:
      uint64_t v36 = C3DBlendStatesDefaultAdditive();
      goto LABEL_39;
    case 2:
      uint64_t v36 = C3DBlendStatesDefaultSubtract();
      goto LABEL_39;
    case 3:
      uint64_t v36 = C3DBlendStatesDefaultMultiplicative();
      goto LABEL_39;
    case 4:
      uint64_t v36 = C3DBlendStatesDefaultScreen();
      goto LABEL_39;
    case 5:
      uint64_t v36 = C3DBlendStatesDefaultReplace();
      goto LABEL_39;
    case 6:
      uint64_t v36 = C3DBlendStatesDefaultMax();
LABEL_39:
      C3DRendererContextSetBlendStates((uint64_t)a1, v36);
      break;
    default:
      return;
  }
}

BOOL __SetupCommonProfileEffectProperty(float32x2_t *a1, int a2, uint64_t *a3)
{
  if (!*(void *)&a1[22])
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetLight_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = (uint64_t)a1[22];
  uint64_t v15 = (float *)*a3;
  uint64_t v16 = a3[1];
  uint64_t EffectSlot = C3DEffectCommonProfileGetEffectSlot(*a3, a2, 0);
  if (!EffectSlot) {
    goto LABEL_45;
  }
  uint64_t v18 = EffectSlot;
  uint64_t Texture = C3DEffectSlotGetTexture(EffectSlot);
  uint64_t TextureSampler = (const void *)C3DEffectSlotGetTextureSampler(v18);
  if (!Texture)
  {
    uint64_t Texture = C3DEffectSlotGetImage(v18);
    if (!Texture) {
      goto LABEL_38;
    }
    uint64_t v30 = a3[3];
    uint64_t Default = TextureSampler;
    if (!TextureSampler) {
      uint64_t Default = (const void *)C3DTextureSamplerGetDefault();
    }
    uint64_t Texture = (uint64_t)C3DResourceManagerMakeImageResident(v30, (void *)Texture, Default, a1);
    if (!Texture)
    {
LABEL_38:
      if ((unint64_t)a2 - 10 >= 0xB)
      {
        UniformLocatiouint64_t n = C3DFXGLSLProgramObjectGetUniformLocation(v14, s_PropertyToTextureMatrixUniformIndex[a2]);
        if (UniformLocation != -1)
        {
          ImageTransforCFIndex m = (const GLfloat *)C3DEffectSlotGetImageTransform(v18);
          long long v73 = 0u;
          long long v74 = 0u;
          *(_OWORD *)GLfloat v = 0u;
          long long v72 = 0u;
          if (!ImageTransform)
          {
            ImageTransforCFIndex m = v;
            C3DMatrix4x4MakeIdentity((uint64_t)v);
          }
          glUniformMatrix4fv(UniformLocation, 1, 0, ImageTransform);
          ++a1[33].i32[0];
        }
      }
      if (Texture) {
        return 1;
      }
LABEL_45:
      BOOL result = 0;
      switch(a2)
      {
        case 0:
          uint64_t v42 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 160);
          if (v42 == -1) {
            return 0;
          }
          GLint v43 = v42;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 0;
          goto LABEL_62;
        case 1:
          uint64_t v46 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 152);
          if (v46 == -1) {
            return 0;
          }
          GLint v43 = v46;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 1;
          goto LABEL_62;
        case 2:
          uint64_t v47 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 148);
          if (v47 == -1) {
            return 0;
          }
          GLint v43 = v47;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 2;
          goto LABEL_62;
        case 3:
          uint64_t v48 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 156);
          if (v48 == -1) {
            return 0;
          }
          GLint v43 = v48;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 3;
          goto LABEL_62;
        case 4:
          uint64_t v49 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 179);
          if (v49 == -1) {
            return 0;
          }
          GLint v43 = v49;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 4;
          goto LABEL_62;
        case 5:
          uint64_t v50 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 169);
          if (v50 == -1) {
            return 0;
          }
          GLint v43 = v50;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 5;
          goto LABEL_62;
        case 6:
          uint64_t v51 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 164);
          if (v51 == -1) {
            return 0;
          }
          GLint v43 = v51;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 6;
          goto LABEL_62;
        case 9:
          uint64_t v52 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 160);
          if (v52 == -1) {
            return 0;
          }
          GLint v43 = v52;
          uint64_t v44 = (uint64_t)v15;
          int v45 = 9;
LABEL_62:
          ColorModulatedByIntensitfloat y = C3DEffectCommonProfileGetColorModulatedByIntensity(v44, v45);
          uint64_t v55 = v54;
          *(void *)GLfloat v = ColorModulatedByIntensity;
          *(void *)&v[2] = v54;
          if (C3DLinearRenderingIsEnabled())
          {
            C3DColor4ConvertToNonLinear((float32x4_t *)v);
            GLfloat v56 = v[0];
            GLfloat v57 = v[1];
            GLfloat v58 = v[2];
            GLfloat v59 = v[3];
          }
          else
          {
            GLfloat v57 = *((float *)&ColorModulatedByIntensity + 1);
            GLfloat v56 = *(float *)&ColorModulatedByIntensity;
            GLfloat v59 = *((float *)&v55 + 1);
            GLfloat v58 = *(float *)&v55;
          }
          glUniform4f(v43, v56, v57, v58, v59);
          return 0;
        case 16:
          uint64_t v60 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 147);
          if (v60 != -1)
          {
            GLint v61 = v60;
            int v62 = C3DWasLinkedBeforeMajorOSYear2014();
            FloatPropertfloat y = C3DEffectCommonProfileGetFloatProperty(v15, 16);
            if (v62)
            {
              BOOL v64 = FloatProperty < 1.0;
              FloatPropertfloat y = 1.0;
              if (v64) {
                FloatPropertfloat y = C3DEffectCommonProfileGetFloatProperty(v15, 16);
              }
            }
            glUniform1f(v61, FloatProperty * 128.0);
          }
          return 0;
        case 19:
          uint64_t v65 = C3DFXGLSLProgramObjectGetUniformLocation(v14, 183);
          if (v65 != -1)
          {
            GLint v66 = v65;
            float v67 = C3DEffectCommonProfileGetFloatProperty(v15, 19);
            float v68 = C3DEffectCommonProfileGetFloatProperty(v15, 20);
            GLfloat v69 = (float)((float)(1.0 - v67) * (float)(1.0 - v67)) / (float)((float)(v67 + 1.0) * (float)(v67 + 1.0));
            glUniform3f(v66, v69, 1.0 - v69, v68);
          }
          return 0;
        default:
          return result;
      }
    }
  }
  GLfloat v70 = v15;
  uint64_t v22 = *(unsigned int *)(v16 + 256);
  uint64_t v23 = v16 + 32 * v22;
  if (!TextureSampler) {
    uint64_t TextureSampler = (const void *)C3DTextureSamplerGetDefault();
  }
  double v25 = (CFTypeRef *)(v23 + 8);
  char v24 = *(const void **)(v23 + 8);
  if (v24 != (const void *)Texture)
  {
    if (v24)
    {
      CFRelease(v24);
      *double v25 = 0;
    }
    *double v25 = CFRetain((CFTypeRef)Texture);
  }
  uint64_t v26 = v16 + 32 * v22;
  float v28 = (void *)(v26 + 24);
  float v27 = *(const void **)(v26 + 24);
  if (v27 != TextureSampler)
  {
    if (v27)
    {
      CFRelease(v27);
      *float v28 = 0;
    }
    if (TextureSampler) {
      CFTypeRef v29 = CFRetain(TextureSampler);
    }
    else {
      CFTypeRef v29 = 0;
    }
    *float v28 = v29;
  }
  *(unsigned char *)uint64_t v23 = a2;
  unsigned int v32 = *(_DWORD *)(v16 + 256);
  *(_DWORD *)(v26 + 16) = v32;
  GLfloat v33 = (GLint *)(v26 + 16);
  if (v32 < 8)
  {
    C3DRendererContextBindTexture((uint64_t)a1, (float32x2_t *)Texture, (uint64_t)TextureSampler, v20, v32);
    ++*(_DWORD *)(v16 + 256);
    if ((unint64_t)a2 - 10 > 0xA)
    {
      uint64_t v37 = s_PropertyToTextureUniformIndex[a2];
      if (*v33 != C3DFXGLSLProgramObjectGetUniformValueAtIndex(v14, v37))
      {
        GLint v38 = C3DFXGLSLProgramObjectGetUniformLocation(v14, v37);
        if (v38 != -1)
        {
          glUniform1i(v38, *v33);
          C3DFXGLSLProgramObjectSetUniformValueAtIndex(v14, v37, *v33);
        }
      }
      GLint v39 = C3DFXGLSLProgramObjectGetUniformLocation(v14, s_PropertyToIntensityUniformIndex[a2]);
      if (v39 == -1)
      {
        LOBYTE(Texture) = 1;
      }
      else
      {
        v[0] = C3DEffectSlotGetIntensity(v18);
        LOBYTE(Texture) = 1;
        glUniform1fv(v39, 1, v);
        ++a1[30].i32[1];
      }
      uint64_t v15 = v70;
      goto LABEL_38;
    }
    if ((__SetupCommonProfileEffectProperty_done & 1) == 0)
    {
      __SetupCommonProfileEffectProperty_done = 1;
      uint64_t v36 = scn_default_log();
      BOOL result = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      __SetupCommonProfileEffectProperty_cold_2();
    }
  }
  else
  {
    uint64_t v34 = scn_default_log();
    BOOL result = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __SetupCommonProfileEffectProperty_cold_1();
  }
  return 0;
}

void C3DRendererContextUnbindCommonProfile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a3 + 256);
  if (v4)
  {
    int v5 = (CFTypeRef *)(a3 + 24);
    do
    {
      uint64_t v6 = *(v5 - 2);
      if (v6)
      {
        CFRelease(v6);
        *(v5 - 2) = 0;
        if (*v5)
        {
          CFRelease(*v5);
          *int v5 = 0;
        }
      }
      v5 += 4;
      --v4;
    }
    while (v4);
  }
  *(_DWORD *)(a3 + 256) = 0;
  if (*(unsigned __int8 *)(a3 + 260) != 255)
  {
    glBlendColor(0.0, 0.0, 0.0, 0.0);
  }
}

void C3DRendererContextSetFrontFace(uint64_t a1, int a2)
{
  if (a2) {
    GLenum v3 = 2305;
  }
  else {
    GLenum v3 = 2304;
  }
  glFrontFace(v3);
  if (a1) {
    ++*(_DWORD *)(a1 + 236);
  }
}

BOOL C3DRendererContextGetFrontFace(uint64_t a1)
{
  GLint params = 0;
  glGetIntegerv(0xB46u, &params);
  if (a1) {
    ++*(_DWORD *)(a1 + 240);
  }
  return params != 2304;
}

void C3DRendererContextSetEnableWriteToDepth(uint64_t a1, int a2)
{
  glDepthMask(a2 != 0);
  *(void *)(a1 + 1096) = 0;
  ++*(_DWORD *)(a1 + 236);
}

void C3DRendererContextSetEnableReadsFromDepth(uint64_t a1, int a2)
{
  if (a2) {
    GLenum v3 = 515;
  }
  else {
    GLenum v3 = 519;
  }
  glDepthFunc(v3);
  if (a1) {
    ++*(_DWORD *)(a1 + 236);
  }
}

uint64_t C3DRendererContextAllocateBufferObject(_DWORD *a1, int a2, GLsizeiptr a3, int a4)
{
  if (a4) {
    GLenum v7 = 35040;
  }
  else {
    GLenum v7 = 35044;
  }
  GLuint buffers = 0;
  glGenBuffers(1, &buffers);
  if (a2 == 1)
  {
    glBindBuffer(0x8893u, buffers);
    glBufferData(0x8893u, a3, 0, v7);
    if (a1)
    {
      ++a1[105];
      a1[111] += a3;
    }
  }
  else if (!a2)
  {
    glBindBuffer(0x8892u, buffers);
    glBufferData(0x8892u, a3, 0, v7);
    if (a1)
    {
      ++a1[103];
      a1[110] += a3;
    }
  }
  return C3DBufferObjectCreate(buffers, a2, a3, 0);
}

uint64_t C3DRendererContextCreateBufferObjectForMeshSource(uint64_t a1, uint64_t a2)
{
  GLuint buffers = 0;
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t Data = C3DMeshSourceGetData(a2);
  if (Data)
  {
    CFDataRef v13 = (const __CFData *)Data;
    glGenBuffers(1, &buffers);
    if (a1) {
      ++*(_DWORD *)(a1 + 412);
    }
    glBindBuffer(0x8892u, buffers);
    if (C3DMeshSourceIsMutable(a2)) {
      GLenum v14 = 35048;
    }
    else {
      GLenum v14 = 35044;
    }
    CFIndex Length = CFDataGetLength(v13);
    BytePtr = CFDataGetBytePtr(v13);
    glBufferData(0x8892u, Length, BytePtr, v14);
    if (a1) {
      *(_DWORD *)(a1 + 440) += Length;
    }
    return C3DBufferObjectCreate(buffers, 0, Length, (uint64_t)v13);
  }
  else
  {
    if ((C3DRendererContextCreateBufferObjectForMeshSource_done & 1) == 0)
    {
      C3DRendererContextCreateBufferObjectForMeshSource_done = 1;
      uint64_t v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        C3DRendererContextCreateBufferObjectForMeshSource_cold_1();
      }
    }
    return 0;
  }
}

uint64_t C3DRendererContextCreateBufferObjectForMeshElement(uint64_t a1, uint64_t a2)
{
  *(void *)GLuint buffers = 0;
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextCreateBufferObjectForMeshElement_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDataRef Indexes = (const __CFData *)C3DMeshElementGetIndexes(a2, buffers);
  CFIndex Length = CFDataGetLength(Indexes);
  glGenBuffers(1, &buffers[1]);
  if (a1)
  {
    ++*(_DWORD *)(a1 + 420);
    glBindBuffer(0x8893u, buffers[1]);
    BytePtr = CFDataGetBytePtr(Indexes);
    glBufferData(0x8893u, Length, BytePtr, 0x88E4u);
    *(_DWORD *)(a1 + 444) += Length;
  }
  else
  {
    glBindBuffer(0x8893u, buffers[1]);
    uint64_t v15 = CFDataGetBytePtr(Indexes);
    glBufferData(0x8893u, Length, v15, 0x88E4u);
  }
  return C3DBufferObjectCreate(buffers[1], 1, Length, a2);
}

void C3DRendererContextUnbindTexture(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a2)
  {
    if (*(_DWORD *)(a1 + 20) > a3)
    {
      int TextureUnitOffset = C3DRendererContextGetTextureUnitOffset(a1);
      glActiveTexture(a3 + TextureUnitOffset + 33984);
      GLenum TargetMode = C3DTextureGetTargetMode(a2);
      glBindTexture(TargetMode, 0);
      ++*(_DWORD *)(a1 + 232);
      *(_DWORD *)(a1 + 4 * a3 + 1040) = 0;
    }
  }
}

void C3DRendererContextUnbindTextureUnits(uint64_t a1)
{
  unint64_t v2 = *(unsigned int *)(a1 + 1072);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = a1 + 1040;
    do
    {
      GLenum v5 = *(_DWORD *)(v4 + 4 * v3);
      if (v5)
      {
        glActiveTexture(v3 + 33984);
        glBindTexture(v5, 0);
        ++*(_DWORD *)(a1 + 232);
        *(_DWORD *)(v4 + 4 * v3) = 0;
        unint64_t v2 = *(unsigned int *)(a1 + 1072);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  *(_DWORD *)(a1 + 1072) = 0;
}

void C3DRendererContextBindMesh(uint64_t a1, uint64_t a2, void *key)
{
  if (*(void **)(a1 + 1104) != key)
  {
    *(void *)(a1 + 1104) = key;
    *(void *)(a1 + 1112) = -1;
    if (!key)
    {
      glBindBuffer(0x8892u, 0);
      uint64_t Value = 0;
LABEL_9:
      (*(void (**)(const void *, uint64_t))(a1 + 1928))(Value, a1);
      ++*(_DWORD *)(a1 + 224);
      return;
    }
    uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), key);
    unsigned int v11 = Value;
    if (Value)
    {
      if (C3DMeshIsMutable((uint64_t)key))
      {
        if (!*(void *)(a1 + 128)) {
          *(void *)(a1 + 12_Block_object_dispose(&STACK[0x2A0], 8) = CFDictionaryCreateMutable(0, 0, 0, 0);
        }
        v9[0] = MEMORY[0x263EF8330];
        v9[1] = 0x40000000;
        v9[2] = __C3DRendererContextBindMesh_block_invoke_2;
        v9[3] = &__block_descriptor_tmp_31_1;
        v9[4] = a1;
        v9[5] = key;
        v9[6] = a2;
        C3DMeshApplySources((uint64_t)key, 1, (uint64_t)v9);
        glBindBuffer(0x8892u, 0);
        uint64_t v7 = *(__CFDictionary **)(a1 + 128);
        MutabilityTimeStamp = (const void *)C3DMeshGetMutabilityTimeStamp((uint64_t)key);
        CFDictionarySetValue(v7, key, MutabilityTimeStamp);
      }
      goto LABEL_9;
    }
    (*(void (**)(uint64_t, unsigned int *, uint64_t))(a1 + 1936))(1, &v11, a1);
    ++*(_DWORD *)(a1 + 428);
    (*(void (**)(void, uint64_t))(a1 + 1928))(v11, a1);
    ++*(_DWORD *)(a1 + 224);
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    v10[2] = __C3DRendererContextBindMesh_block_invoke;
    v10[3] = &__block_descriptor_tmp_30;
    void v10[4] = a2;
    v10[5] = a1;
    C3DMeshApplySources((uint64_t)key, 1, (uint64_t)v10);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), key, (const void *)v11);
    glBindBuffer(0x8892u, 0);
  }
}

void C3DRendererContextBindMeshElement(uint64_t a1, uint64_t a2, const void *a3)
{
  if (*(const void **)(a1 + 1112) == a3) {
    return;
  }
  *(void *)(a1 + 1112) = a3;
  if (!a3)
  {
    GLuint Value = 0;
    *(void *)(a1 + 112_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    *(void *)(a1 + 1120) = 0;
    *(_DWORD *)(a1 + 1144) = 0;
    *(void *)(a1 + 1136) = 0;
LABEL_41:
    glBindBuffer(0x8893u, Value);
    ++*(_DWORD *)(a1 + 220);
    return;
  }
  int v28 = 0;
  uint64_t Indexes = C3DMeshElementGetIndexes((uint64_t)a3, &v28);
  if (C3DMeshElementIsVolatile((uint64_t)a3))
  {
    if (!*(void *)(a1 + 2056))
    {
      uint64_t v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        C3DRendererContextBindMeshElement_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
      }
    }
    GLuint Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2056), a3);
    *(_DWORD *)(a1 + 1120) = 1;
    if (v28 != 4)
    {
      if (v28 != 2)
      {
        if (v28 != 1)
        {
          uint64_t v16 = scn_default_log();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            goto LABEL_44;
          }
          return;
        }
        goto LABEL_21;
      }
LABEL_23:
      int v20 = 5123;
      goto LABEL_24;
    }
LABEL_22:
    int v20 = 5125;
    goto LABEL_24;
  }
  if (!Indexes)
  {
    GLuint Value = 0;
    *(_DWORD *)(a1 + 1120) = 0;
    goto LABEL_25;
  }
  *(_DWORD *)(a1 + 1120) = 1;
  MeshElementResident = C3DResourceManagerMakeMeshElementResident(a2, (uint64_t)a3, a1);
  GLuint Value = C3DBufferObjectGetBufferID((uint64_t)MeshElementResident);
  uint64_t v18 = (unsigned int *)MeshElementResident[9];
  if (v18) {
    unsigned int SharedIndexBufferOffset = *v18;
  }
  else {
    unsigned int SharedIndexBufferOffset = C3DMeshElementGetSharedIndexBufferOffset((uint64_t)a3);
  }
  *(void *)(a1 + 1136) = SharedIndexBufferOffset;
  switch(v28)
  {
    case 4:
      goto LABEL_22;
    case 2:
      goto LABEL_23;
    case 1:
LABEL_21:
      int v20 = 5121;
LABEL_24:
      *(_DWORD *)(a1 + 1132) = v20;
LABEL_25:
      if (*(unsigned char *)(a1 + 104))
      {
        InstanceCFIndex Count = C3DMeshElementGetInstanceCount((uint64_t)a3);
        if (InstanceCount >= 2)
        {
          *(_DWORD *)(a1 + 114_Block_object_dispose(&STACK[0x2A0], 8) = InstanceCount;
          if (Indexes) {
            int v22 = 3;
          }
          else {
            int v22 = 2;
          }
          *(_DWORD *)(a1 + 1120) = v22;
        }
      }
      PrimitiveCFIndex Count = C3DMeshElementGetPrimitiveCount((uint64_t)a3);
      if (C3DMeshElementGetPrimitiveRange((uint64_t)a3) != -1) {
        PrimitiveCFIndex Count = v24;
      }
      int Type = C3DMeshElementGetType((uint64_t)a3);
      *(_DWORD *)(a1 + 1144) = PrimitiveCount;
      switch(Type)
      {
        case 0:
          *(_DWORD *)(a1 + 1124) = 4;
          PrimitiveCount *= 3;
          goto LABEL_40;
        case 1:
          int v26 = 5;
          goto LABEL_39;
        case 2:
          *(_DWORD *)(a1 + 1124) = 1;
          PrimitiveCount *= 2;
          goto LABEL_40;
        case 3:
          *(_DWORD *)(a1 + 1124) = 0;
          goto LABEL_40;
        case 5:
          int v26 = 6;
LABEL_39:
          *(_DWORD *)(a1 + 1124) = v26;
          PrimitiveCount += 2;
LABEL_40:
          *(_DWORD *)(a1 + 112_Block_object_dispose(&STACK[0x2A0], 8) = PrimitiveCount;
          break;
        default:
          goto LABEL_41;
      }
      goto LABEL_41;
  }
  float v27 = scn_default_log();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
LABEL_44:
  }
    C3DRendererContextBindMeshElement_cold_1();
}

void _C3DRendererContextMeshWillDie(uint64_t a1, const void *a2, NSObject *a3)
{
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), a2);
  if (Value)
  {
    C3DRendererContextRetainContext(a1);
    CFRetain((CFTypeRef)a1);
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 0x40000000;
    float32x4_t v8[2] = ___C3DRendererContextMeshWillDie_block_invoke;
    v8[3] = &__block_descriptor_tmp_28_1;
    v8[4] = a1;
    unsigned int v9 = Value;
    dispatch_async(a3, v8);
    *(void *)(a1 + 1104) = -1;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 120), a2);
    uint64_t v7 = *(__CFDictionary **)(a1 + 128);
    if (v7) {
      CFDictionaryRemoveValue(v7, a2);
    }
  }
}

void __C3DRendererContextBindMesh_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  MeshSourceResident = C3DResourceManagerMakeMeshSourceResident(*(void *)(a1 + 32), a2, *(void *)(a1 + 40));
  if (MeshSourceResident)
  {
    uint64_t v9 = (uint64_t)MeshSourceResident;
    BufferGLuint ID = C3DBufferObjectGetBufferID((uint64_t)MeshSourceResident);
    glBindBuffer(0x8892u, BufferID);
    uint64_t v11 = *(void *)(a1 + 40);
    if (v11) {
      ++*(_DWORD *)(v11 + 208);
    }
    uint64_t v12 = a3;
    switch(a3)
    {
      case 0u:
        break;
      case 1u:
        uint64_t v12 = 1;
        break;
      case 2u:
        uint64_t v12 = 3;
        break;
      case 3u:
        if (a4 == -1) {
          uint64_t v12 = 6;
        }
        else {
          uint64_t v12 = a4 + 6;
        }
        break;
      case 4u:
        uint64_t v12 = 2;
        break;
      case 5u:
        uint64_t v12 = 4;
        break;
      case 6u:
        uint64_t v12 = 5;
        break;
      default:
        uint64_t v12 = -1;
        break;
    }
    C3DRendererContextSetupResidentMeshSourceAtLocation(v11, a2, v9, v12);
  }
}

void __C3DRendererContextBindMesh_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (C3DMeshSourceIsMutable(a2))
  {
    if (C3DGenericSourceIsPrimary(a2))
    {
      unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 128), *(const void **)(a1 + 40));
      if ((const void *)C3DMeshGetMutabilityTimeStamp(*(void *)(a1 + 40)) != Value)
      {
        CFDataRef Data = (const __CFData *)C3DMeshSourceGetData(a2);
        if (Data)
        {
          CFDataRef v6 = Data;
          CFIndex Length = CFDataGetLength(Data);
          BytePtr = CFDataGetBytePtr(v6);
          MeshSourceResident = C3DResourceManagerMakeMeshSourceResident(*(void *)(a1 + 48), a2, *(void *)(a1 + 32));
          BufferGLuint ID = C3DBufferObjectGetBufferID((uint64_t)MeshSourceResident);
          glBindBuffer(0x8892u, BufferID);
          uint64_t v11 = *(void *)(a1 + 32);
          if (v11) {
            ++*(_DWORD *)(v11 + 208);
          }
          if (Length == MeshSourceResident[17])
          {
            uint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, void, CFIndex, uint64_t))(v11 + 1960))(34962, 0, Length, 38);
            memcpy(v12, BytePtr, Length);
            uint64_t v13 = *(void (**)(uint64_t))(*(void *)(a1 + 32) + 1976);
            v13(34962);
          }
          else
          {
            glBufferData(0x8892u, Length, BytePtr, 0x88E8u);
            MeshSourceResident[17] = Length;
          }
        }
      }
    }
  }
}

uint64_t C3DRendererContextGetProfile(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t C3DRendererContextBindEffectSlot(float32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  if (!a3)
  {
    uint64_t v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  if (a5 > 7) {
    return 0;
  }
  uint64_t Texture = (float32x2_t *)C3DEffectSlotGetTexture(a3);
  uint64_t TextureSampler = (const void *)C3DEffectSlotGetTextureSampler(a3);
  if (TextureSampler)
  {
    if (!Texture)
    {
LABEL_10:
      uint64_t Image = (void *)C3DEffectSlotGetImage(a3);
      if (Image) {
        uint64_t Texture = C3DResourceManagerMakeImageResident(a2, Image, TextureSampler, a1);
      }
      else {
        uint64_t Texture = 0;
      }
    }
  }
  else
  {
    uint64_t TextureSampler = (const void *)C3DTextureSamplerGetDefault();
    if (!Texture) {
      goto LABEL_10;
    }
  }
  if (a6 != -1)
  {
    ImageTransforCFIndex m = (const GLfloat *)C3DEffectSlotGetImageTransform(a3);
    memset(v26, 0, sizeof(v26));
    if (!ImageTransform)
    {
      ImageTransforCFIndex m = (const GLfloat *)v26;
      C3DMatrix4x4MakeIdentity((uint64_t)v26);
    }
    glUniformMatrix4fv(a6, 1, 0, ImageTransform);
    if (a1) {
      ++a1[33].i32[0];
    }
  }
  uint64_t result = 0;
  if (Texture && TextureSampler)
  {
    C3DRendererContextBindTexture((uint64_t)a1, Texture, (uint64_t)TextureSampler, v22, a5);
    if (a4 != -1)
    {
      glUniform1i(a4, a5);
      if (a1) {
        ++a1[31].i32[0];
      }
    }
    return 1;
  }
  return result;
}

uint64_t __ReserveAndBindVolatileVBO(_DWORD *a1, unint64_t a2, void *a3, int a4, int a5)
{
  GLenum v9 = gl_ArrayBufferType[a5];
  uint64_t v10 = &a1[6 * a5];
  uint64_t Count = C3DArrayGetCount(*((void *)v10 + 249));
  ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*((void *)v10 + 249), v10[501]);
  uint64_t v13 = *(void *)ValuePtrAtIndex;
  if (!*(void *)ValuePtrAtIndex)
  {
LABEL_25:
    uint64_t v23 = 0x800000;
    if (a2 > 0x800000) {
      uint64_t v23 = a2;
    }
    if (a4) {
      GLsizeiptr v24 = a2;
    }
    else {
      GLsizeiptr v24 = v23;
    }
    uint64_t result = C3DRendererContextAllocateBufferObject(a1, (char)a5, v24, 1);
    *(void *)ValuePtrAtuint64_t Index = result;
    *(void *)(ValuePtrAtIndex + _Block_object_dispose(&STACK[0x2A0], 8) = a2;
    *(_DWORD *)(ValuePtrAtIndex + 20) = a1[14];
    *a3 = 0;
    return result;
  }
  GLenum target = v9;
  uint64_t v14 = (uint64_t *)(v10 + 498);
  uint64_t v15 = v10 + 501;
  while (1)
  {
    unint64_t Size = C3DBufferObjectGetSize(v13);
    unint64_t v17 = Size;
    int v18 = a1[14] - *(_DWORD *)(ValuePtrAtIndex + 20);
    if (!v18) {
      int v18 = 0x7FFFFFFF;
    }
    uint64_t v19 = *(void *)(ValuePtrAtIndex + 8);
    if (Size > 0x800000 && !v19 && v18 >= 3)
    {
      uint64_t v19 = 0;
      if (*(_DWORD *)(ValuePtrAtIndex + 16) > 0x3Cu) {
        unint64_t v17 = 0;
      }
    }
    if (v19 + a2 > v17 || v18 < 3) {
      break;
    }
    if (!v19 || (a4 & 1) == 0)
    {
      BufferGLuint ID = C3DBufferObjectGetBufferID(*(void *)ValuePtrAtIndex);
      glBindBuffer(target, BufferID);
      ++a1[52];
      *(_DWORD *)(ValuePtrAtIndex + 20) = a1[14];
      uint64_t result = *(void *)ValuePtrAtIndex;
      *a3 = *(void *)(ValuePtrAtIndex + 8);
      *(void *)(ValuePtrAtIndex + 8) += a2;
      return result;
    }
LABEL_22:
    int v22 = (*v15 + 1) % Count;
    *uint64_t v15 = v22;
    if (a1[6 * a5 + 500] == v22) {
      C3DArraySetCount((_DWORD *)*v14, Count + 1);
    }
    uint64_t Count = C3DArrayGetCount(*v14);
    ValuePtrAtuint64_t Index = C3DArrayGetValuePtrAtIndex(*v14, *v15);
    uint64_t v13 = *(void *)ValuePtrAtIndex;
    if (!*(void *)ValuePtrAtIndex) {
      goto LABEL_25;
    }
  }
  if (v19 || v18 < 3) {
    goto LABEL_22;
  }
  uint64_t v27 = 0x800000;
  if (a2 > 0x800000) {
    uint64_t v27 = a2;
  }
  if (a4) {
    GLsizeiptr v28 = a2;
  }
  else {
    GLsizeiptr v28 = v27;
  }
  C3DRendererContextDeleteBufferObject(a1, *(void *)ValuePtrAtIndex);
  if (*(void *)ValuePtrAtIndex)
  {
    CFRelease(*(CFTypeRef *)ValuePtrAtIndex);
    *(void *)ValuePtrAtuint64_t Index = 0;
  }
  uint64_t result = C3DRendererContextAllocateBufferObject(a1, (char)a5, v28, 1);
  *(void *)ValuePtrAtuint64_t Index = result;
  *(void *)(ValuePtrAtIndex + _Block_object_dispose(&STACK[0x2A0], 8) = a2;
  *(_DWORD *)(ValuePtrAtIndex + 20) = a1[14];
  *a3 = 0;
  if (a4) {
    *(void *)(ValuePtrAtIndex + _Block_object_dispose(&STACK[0x2A0], 8) = v17;
  }
  return result;
}

uint64_t C3DRendererContextMapVolatileMesh(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, int a5)
{
  if (C3DMeshIsVolatile((uint64_t)a3))
  {
    uint64_t v40 = 0;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x2000000000;
    uint64_t v43 = 0;
    v39[0] = MEMORY[0x263EF8330];
    v39[1] = 0x40000000;
    v39[2] = __C3DRendererContextMapVolatileMesh_block_invoke;
    void v39[3] = &unk_2640066E8;
    v39[4] = &v40;
    v39[5] = a4;
    C3DMeshApplySources((uint64_t)a3, 1, (uint64_t)v39);
    unint64_t v10 = v41[3];
    if (v10
      && (uint64_t v38 = 0, (v11 = __ReserveAndBindVolatileVBO((_DWORD *)a1, v10, &v38, a5, 0)) != 0)
      && (uint64_t v12 = v11,
          uint64_t v13 = v38,
          (uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1960))(34962, v38, v41[3], 38, a1)) != 0))
    {
      uint64_t v15 = v14;
      *(void *)(C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 1992), *(unsigned int *)(a1 + 2004)) + 24) = v14;
      value_4[0] = 0;
      value_4[1] = value_4;
      value_4[2] = 0x2000000000;
      value_4[3] = 0;
      unsigned int value = 0;
      unsigned int v16 = *(_DWORD *)(a1 + 2048);
      if (v16 >= C3DArrayGetCount(*(void *)(a1 + 2040)))
      {
        (*(void (**)(uint64_t, unsigned int *, uint64_t))(a1 + 1936))(1, &value, a1);
        ++*(_DWORD *)(a1 + 428);
        C3DArrayAppendValue(*(void *)(a1 + 2040), &value);
        uint64_t v17 = value;
      }
      else
      {
        uint64_t v17 = *(unsigned int *)C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 2040), *(unsigned int *)(a1 + 2048));
        unsigned int value = v17;
      }
      ++*(_DWORD *)(a1 + 2048);
      (*(void (**)(uint64_t, uint64_t))(a1 + 1928))(v17, a1);
      ++*(_DWORD *)(a1 + 224);
      uint64_t v32 = 0;
      GLfloat v33 = &v32;
      uint64_t v34 = 0x2000000000;
      char v35 = 0;
      v31[0] = MEMORY[0x263EF8330];
      v31[1] = 0x40000000;
      void v31[2] = __C3DRendererContextMapVolatileMesh_block_invoke_2;
      v31[3] = &unk_264006710;
      v31[4] = &v32;
      v31[5] = value_4;
      _OWORD v31[6] = v15;
      v31[7] = v13;
      v31[8] = a1;
      v31[9] = v12;
      C3DMeshApplySources((uint64_t)a3, 1, (uint64_t)v31);
      if (*((unsigned char *)v33 + 24))
      {
        v30[0] = MEMORY[0x263EF8330];
        v30[1] = 0x40000000;
        v30[2] = __C3DRendererContextMapVolatileMesh_block_invoke_3;
        v30[3] = &__block_descriptor_tmp_36_0;
        v30[4] = a2;
        v30[5] = a1;
        C3DMeshApplySources((uint64_t)a3, 1, (uint64_t)v30);
        BufferGLuint ID = C3DBufferObjectGetBufferID(v12);
        glBindBuffer(0x8892u, BufferID);
        ++*(_DWORD *)(a1 + 208);
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), a3, (const void *)value);
      (*(void (**)(void, uint64_t))(a1 + 1928))(0, a1);
      CFMutableStringRef Mutable = *(__CFArray **)(a1 + 2008);
      if (!Mutable)
      {
        CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
        *(void *)(a1 + 200_Block_object_dispose(&STACK[0x2A0], 8) = Mutable;
      }
      CFArrayAppendValue(Mutable, a3);
      _Block_object_dispose(&v32, 8);
      _Block_object_dispose(value_4, 8);
      uint64_t v26 = 1;
    }
    else
    {
      uint64_t v26 = 0;
    }
    _Block_object_dispose(&v40, 8);
  }
  else
  {
    int v18 = scn_default_log();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextMapVolatileMesh_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    return 0;
  }
  return v26;
}

uint64_t __C3DRendererContextMapVolatileMesh_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = C3DMeshSourceIsVolatile(a2);
  if (result)
  {
    uint64_t Accessor = C3DMeshSourceGetAccessor(a2);
    C3DSourceAccessorSetCount(Accessor, *(void *)(a1 + 40));
    uint64_t result = C3DSourceAccessorGetLength(Accessor);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result;
  }
  return result;
}

void __C3DRendererContextMapVolatileMesh_block_invoke_2(void *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (C3DMeshSourceIsVolatile(a2))
  {
    uint64_t Accessor = C3DMeshSourceGetAccessor(a2);
    uint64_t Length = C3DSourceAccessorGetLength(Accessor);
    C3DMeshSourceSetVolatileData(a2, a1[6] + *(void *)(*(void *)(a1[5] + 8) + 24));
    C3DSourceAccessorSetOffset(Accessor, *(void *)(*(void *)(a1[5] + 8) + 24) + a1[7]);
    *(void *)(*(void *)(a1[5] + 8) + 24) += Length;
    uint64_t v10 = a3;
    switch(a3)
    {
      case 0u:
        break;
      case 1u:
        uint64_t v10 = 1;
        break;
      case 2u:
        uint64_t v10 = 3;
        break;
      case 3u:
        if (a4 == -1) {
          uint64_t v10 = 6;
        }
        else {
          uint64_t v10 = a4 + 6;
        }
        break;
      case 4u:
        uint64_t v10 = 2;
        break;
      case 5u:
        uint64_t v10 = 4;
        break;
      case 6u:
        uint64_t v10 = 5;
        break;
      default:
        uint64_t v10 = -1;
        break;
    }
    uint64_t v11 = a1[8];
    uint64_t v12 = a1[9];
    C3DRendererContextSetupResidentMeshSourceAtLocation(v11, a2, v12, v10);
  }
  else
  {
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
  }
}

void __C3DRendererContextMapVolatileMesh_block_invoke_3(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if ((C3DMeshSourceIsVolatile(a2) & 1) == 0)
  {
    MeshSourceResident = C3DResourceManagerMakeMeshSourceResident(*(void *)(a1 + 32), a2, *(void *)(a1 + 40));
    BufferGLuint ID = C3DBufferObjectGetBufferID((uint64_t)MeshSourceResident);
    glBindBuffer(0x8892u, BufferID);
    uint64_t v10 = *(void *)(a1 + 40);
    if (v10) {
      ++*(_DWORD *)(v10 + 208);
    }
    uint64_t v11 = a3;
    switch(a3)
    {
      case 0u:
        break;
      case 1u:
        uint64_t v11 = 1;
        break;
      case 2u:
        uint64_t v11 = 3;
        break;
      case 3u:
        if (a4 == -1) {
          uint64_t v11 = 6;
        }
        else {
          uint64_t v11 = a4 + 6;
        }
        break;
      case 4u:
        uint64_t v11 = 2;
        break;
      case 5u:
        uint64_t v11 = 4;
        break;
      case 6u:
        uint64_t v11 = 5;
        break;
      default:
        uint64_t v11 = -1;
        break;
    }
    C3DRendererContextSetupResidentMeshSourceAtLocation(v10, a2, (uint64_t)MeshSourceResident, v11);
  }
}

void C3DRendererContextUnmapVolatileMesh(uint64_t a1, uint64_t a2)
{
  v2[0] = MEMORY[0x263EF8330];
  v2[1] = 0x40000000;
  v2[2] = __C3DRendererContextUnmapVolatileMesh_block_invoke;
  v2[3] = &__block_descriptor_tmp_39_0;
  v2[4] = a1;
  C3DMeshApplySources(a2, 1, (uint64_t)v2);
  glBindBuffer(0x8892u, 0);
}

void __C3DRendererContextUnmapVolatileMesh_block_invoke(uint64_t a1, uint64_t a2)
{
  if (C3DMeshSourceIsVolatile(a2))
  {
    uint64_t Accessor = (void *)C3DMeshSourceGetAccessor(a2);
    VolatileValuePtrAtuint64_t Index = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(v6 + 1992);
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 0x40000000;
    float32x4_t v8[2] = __C3DRendererContextUnmapVolatileMesh_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_38;
    v8[4] = VolatileValuePtrAtIndex;
    void v8[5] = v6;
    C3DArrayApply(v7, (uint64_t)v8);
    C3DMeshSourceSetVolatileData(a2, 0);
  }
}

uint64_t __C3DRendererContextUnmapVolatileMesh_block_invoke_2(uint64_t result, uint64_t a2, uint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 32);
  unint64_t v4 = a3[3];
  if (v3 >= v4 && v3 < v4 + a3[1])
  {
    uint64_t v6 = result;
    BufferGLuint ID = C3DBufferObjectGetBufferID(*a3);
    glBindBuffer(0x8892u, BufferID);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(v6 + 40) + 1976))(34962);
    a3[3] = 0;
  }
  return result;
}

uint64_t C3DRendererContextMapVolatileMeshElement(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  if (C3DMeshElementIsVolatile((uint64_t)a2))
  {
    switch(C3DMeshElementGetType((uint64_t)a2))
    {
      case 0u:
        a3 *= 3;
        goto LABEL_8;
      case 1u:
      case 5u:
        a3 += 2;
        if (!a3) {
          goto LABEL_14;
        }
        goto LABEL_17;
      case 2u:
        a3 *= 2;
        if (!a3) {
          goto LABEL_14;
        }
        goto LABEL_17;
      case 4u:
        uint64_t v17 = scn_default_log();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
          C3DRendererContextMapVolatileMeshElement_cold_3(v17, v18, v19, v20, v21, v22, v23, v24);
        }
        goto LABEL_14;
      default:
LABEL_8:
        if (!a3)
        {
LABEL_14:
          uint64_t v25 = scn_default_log();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
            C3DRendererContextMapVolatileMeshElement_cold_2(v25, v26, v27, v28, v29, v30, v31, v32);
          }
          a3 = 0;
        }
LABEL_17:
        unint64_t v33 = a3 * C3DMeshElementGetBytesPerIndex((uint64_t)a2);
        if (!v33) {
          return 0;
        }
        uint64_t v47 = 0;
        uint64_t result = __ReserveAndBindVolatileVBO((_DWORD *)a1, v33, &v47, a4, 1);
        if (result)
        {
          uint64_t v34 = result;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 1960))(34963, v47, v33, 38, a1);
          if (result)
          {
            uint64_t v35 = result;
            *(void *)(C3DArrayGetValuePtrAtIndex(*(void *)(a1 + 2016), *(unsigned int *)(a1 + 2028)) + 24) = result;
            C3DMeshElementSetVolatileDataPtr((uint64_t)a2, v35);
            if (!*(void *)(a1 + 2056))
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 3, 0, 0);
              *(void *)(a1 + 2056) = Mutable;
              if (!Mutable)
              {
                uint64_t v37 = scn_default_log();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
                  C3DRendererContextMapVolatileMeshElement_cold_1(v37, v38, v39, v40, v41, v42, v43, v44);
                }
              }
            }
            BufferGLuint ID = C3DBufferObjectGetBufferID(v34);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 2056), a2, (const void *)BufferID);
            *(_DWORD *)(a1 + 1120) = 1;
            uint64_t v46 = *(__CFArray **)(a1 + 2032);
            if (!v46)
            {
              uint64_t v46 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
              *(void *)(a1 + 2032) = v46;
            }
            CFArrayAppendValue(v46, a2);
            uint64_t result = 1;
          }
        }
        break;
    }
  }
  else
  {
    uint64_t v8 = scn_default_log();
    uint64_t result = os_log_type_enabled(v8, OS_LOG_TYPE_FAULT);
    if (result)
    {
      C3DRendererContextMapVolatileMesh_cold_1(v8, v10, v11, v12, v13, v14, v15, v16);
      return 0;
    }
  }
  return result;
}

void C3DRendererContextUnmapVolatileMeshElement(uint64_t a1, uint64_t a2)
{
  if (!C3DMeshElementIsVolatile(a2))
  {
    unint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextUnmapVolatileMeshElement_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t VolatileDataPtr = C3DMeshElementGetVolatileDataPtr(a2);
  uint64_t v13 = *(void *)(a1 + 2016);
  v14[0] = MEMORY[0x263EF8330];
  v14[1] = 0x40000000;
  _OWORD v14[2] = __C3DRendererContextUnmapVolatileMeshElement_block_invoke;
  void v14[3] = &__block_descriptor_tmp_42_0;
  _OWORD v14[4] = VolatileDataPtr;
  v14[5] = a1;
  C3DArrayApply(v13, (uint64_t)v14);
  C3DMeshElementSetVolatileDataPtr(a2, 0);
  glBindBuffer(0x8893u, 0);
}

uint64_t __C3DRendererContextUnmapVolatileMeshElement_block_invoke(uint64_t result, uint64_t a2, uint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 32);
  unint64_t v4 = a3[3];
  if (v3 >= v4 && v3 < v4 + a3[1])
  {
    uint64_t v6 = result;
    BufferGLuint ID = C3DBufferObjectGetBufferID(*a3);
    glBindBuffer(0x8893u, BufferID);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(v6 + 40) + 1976))(34963);
    a3[3] = 0;
  }
  return result;
}

void C3DRendererContextResetVolatileObjects(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    int v5 = gl_ArrayBufferType[v2];
    uint64_t v6 = a1 + 24 * v2;
    CFArrayRef v7 = *(const __CFArray **)(v6 + 2008);
    if (v7)
    {
      uint64_t v8 = (CFArrayRef *)(v6 + 2008);
      CFIndex Count = CFArrayGetCount(v7);
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        for (CFIndex i = 0; i != v10; ++i)
        {
          if (v4)
          {
            ValueAtuint64_t Index = CFArrayGetValueAtIndex(*v8, i);
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 120), ValueAtIndex);
          }
        }
      }
      CFArrayRemoveAllValues(*v8);
    }
    uint64_t v13 = *(void *)(v6 + 1992);
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 0x40000000;
    _OWORD v18[2] = __C3DRendererContextResetVolatileObjects_block_invoke;
    v18[3] = &__block_descriptor_tmp_43_0;
    int v19 = v5;
    v18[4] = a1;
    C3DArrayApply(v13, (uint64_t)v18);
    uint64_t v14 = C3DArrayGetCount(*(void *)(v6 + 1992));
    char v3 = 0;
    uint64_t v15 = a1 + 24 * v2;
    int v16 = (*(_DWORD *)(v15 + 2004) + 1) % v14;
    *(_DWORD *)(v15 + 2004) = v16;
    *(_DWORD *)(v15 + 2000) = v16;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  uint64_t v17 = *(__CFDictionary **)(a1 + 2056);
  if (v17) {
    CFDictionaryRemoveAllValues(v17);
  }
  *(_DWORD *)(a1 + 204_Block_object_dispose(&STACK[0x2A0], 8) = 0;
}

unint64_t __C3DRendererContextResetVolatileObjects_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = *(void *)a3;
  if (*(void *)a3
    && (!*(void *)(a3 + 24)
     || (BufferGLuint ID = C3DBufferObjectGetBufferID(result),
         glBindBuffer(*(_DWORD *)(a1 + 40), BufferID),
         (*(void (**)(void))(*(void *)(a1 + 32) + 1976))(*(unsigned int *)(a1 + 40)),
         (unint64_t result = *(void *)a3) != 0))
    && (v7 = *(void *)(a3 + 8), unint64_t result = C3DBufferObjectGetSize(result), v7 < result))
  {
    ++*(_DWORD *)(a3 + 16);
  }
  else
  {
    *(_DWORD *)(a3 + 16) = 0;
  }
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
  return result;
}

uint64_t C3DRendererContextGetShowsAuthoringEnvironment(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 91);
}

uint64_t C3DRendererContextSetCompilationErrorsCollection(uint64_t result, char a2)
{
  *(unsigned char *)(result + 92) = a2;
  return result;
}

uint64_t C3DRendererContextGetCompilationErrorsCollection(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 92);
}

CFDictionaryRef C3DRendererContextGetCompilationErrors(uint64_t a1)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 96);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetCount(result);
    if (result) {
      return *(const __CFDictionary **)(a1 + 96);
    }
  }
  return result;
}

void C3DRendererContextPushGroupMarker(uint64_t a1, const char *a2)
{
}

void C3DRendererContextBumpTimeStamp(uint64_t a1)
{
  uint64_t v2 = *(__CFDictionary **)(a1 + 96);
  if (v2) {
    CFDictionaryRemoveAllValues(v2);
  }
  ++*(_DWORD *)(a1 + 56);
}

uint64_t kSCNMaterialPropertyTextureProviderSourceCallbackCreateTextureProxy(__C3DEngineContext *a1, __C3DTextureSampler *a2, const void *a3)
{
  if (!a3) {
    return 0;
  }
  v6[0] = xmmword_26BF71C78;
  v6[1] = *(_OWORD *)off_26BF71C88;
  uint64_t v4 = C3DTextureProxyCreate();
  C3DTextureProxySetCallbacks(v4, v6);
  C3DTextureProxySetSource(v4, a3);
  return v4;
}

uint64_t kSCNMaterialPropertyTextureProviderSourceCallbackIsOpaque(const void *a1)
{
  return 1;
}

uint64_t kSCNMaterialPropertyTextureProviderSourceCallbackIsPremultiplied(const void *a1)
{
  return 1;
}

uint64_t __renderToTexture(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke;
  v10[3] = &unk_2640068A8;
  void v10[4] = a4;
  v8[4] = a4;
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_72;
  v9[3] = &unk_2640068D0;
  v9[4] = a4;
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  float32x4_t v8[2] = ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_75;
  v8[3] = &unk_2640068F8;
  if (objc_opt_respondsToSelector()) {
    return [a1 renderToTexture:a2 computeCommandHandler:v10 blitCommandHandler:v9 completionHandler:v8 helper:a3];
  }
  else {
    return [a1 renderToTexture:a2 computeCommandHandler:v10 blitCommandHandler:v9 helper:a3];
  }
}

uint64_t ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    char v3 = (void *)-[SCNMTLRenderContext resourceComputeEncoder](*(void *)(result + 32));
    if (!v3[207])
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    bzero(v3, 0x678uLL);
    return (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, v3[207]);
  }
  return result;
}

uint64_t ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_72(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    char v3 = (void *)-[SCNMTLRenderContext resourceBlitEncoder](*(void *)(result + 32));
    if (!*v3)
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_72_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    return (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *v3);
  }
  return result;
}

uint64_t ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_75(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = -[SCNMTLRenderContext resourceComputeEncoder](*(void *)(result + 32));
    if (!*(void *)(v3 + 1656))
    {
      uint64_t v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        ___ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    return [*(id *)(v3 + 1664) addCompletedHandler:a2];
  }
  return result;
}

void C3DRendererContextSetGLContext(__n64 *a1, void *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetGLContext_cold_1(v4);
    }
  }
  uint64_t v5 = (const void *)a1[20].n64_u64[0];
  if (v5 != a2)
  {
    if (v5)
    {
      C3DResourceManagerRegistryReleaseContext((uint64_t)a1, v5);
      uint64_t v6 = (void *)a1[20].n64_u64[0];
      if (v6) {
        C3DEAGLWrapperContextRelease(v6);
      }
    }
    if (a2) {
      C3DEAGLWrapperContextRetain(a2);
    }
    a1[20].n64_u64[0] = (unint64_t)a2;
    __InitStateVarsIfNeeded(a1);
    uint64_t v7 = (const void *)a1[20].n64_u64[0];
    if (v7) {
      C3DResourceManagerRegistryRetainContext(v7);
    }
  }
}

uint64_t C3DRendererContextGetGLContext(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextSetGLContext_cold_1(v2);
    }
  }
  return *(void *)(a1 + 160);
}

void _C3DParticleManagerCFFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  uint64_t v3 = (const void *)a1[14];
  if (v3)
  {
    CFRelease(v3);
    a1[14] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  uint64_t v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  uint64_t v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0;
  }
  uint64_t v7 = (const void *)a1[8];
  if (v7)
  {
    CFRelease(v7);
    a1[8] = 0;
  }
  uint64_t v8 = (const void *)a1[6];
  if (v8)
  {
    CFRelease(v8);
    a1[6] = 0;
  }
  uint64_t v9 = (const void *)a1[10];
  if (v9)
  {
    CFRelease(v9);
    a1[10] = 0;
  }
  uint64_t v10 = (const void *)a1[11];
  if (v10)
  {
    CFRelease(v10);
    a1[11] = 0;
  }
  uint64_t v11 = (const void *)a1[12];
  if (v11)
  {
    CFRelease(v11);
    a1[12] = 0;
  }
  uint64_t v12 = (const void *)a1[13];
  if (v12)
  {
    CFRelease(v12);
    a1[13] = 0;
  }
}

CFStringRef _C3DParticleManagerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleManagerRef>");
}

CFStringRef _C3DParticleManagerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DParticleManagerRef>");
}

uint64_t __C3DParticleManagerGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DParticleManagerGetTypeID_typeGLuint ID = result;
  return result;
}

void *C3DParticleManagerCreate(uint64_t a1)
{
  if (C3DParticleManagerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DParticleManagerGetTypeID_onceToken, &__block_literal_global_35);
  }
  uint64_t Instance = (void *)C3DTypeCreateInstance_(C3DParticleManagerGetTypeID_typeID, 0x68uLL);
  Instance[2] = a1;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Instance[3] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  Instance[14] = CFDictionaryCreateMutable(v3, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  return Instance;
}

void C3DParticleManagerRegisterSystem(uint64_t a1, float32x4_t *a2)
{
  CFArrayRef ParticleSystems = C3DNodeGetParticleSystems((uint64_t)a2);
  if (ParticleSystems)
  {
    CFArrayRef v5 = ParticleSystems;
    CFIndex Count = CFArrayGetCount(ParticleSystems);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        ValueAtuint64_t Index = CFArrayGetValueAtIndex(v5, i);
        C3DParticleManagerAddSystem(a1, a2, ValueAtIndex, 0);
      }
    }
  }
}

double C3DParticleManagerAddSystem(uint64_t a1, float32x4_t *a2, const void *a3, long long *a4)
{
  if (C3DParticleSystemGetIsLocal((uint64_t)a3)) {
    goto LABEL_8;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count < 1) {
    goto LABEL_8;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (1)
  {
    ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v10);
    if ((const void *)C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex) == a3) {
      break;
    }
    if (v9 == ++v10) {
      goto LABEL_8;
    }
  }
  if (!ValueAtIndex)
  {
LABEL_8:
    ValueAtuint64_t Index = (const void *)C3DParticleSystemInstanceCreate((uint64_t)a2, a3, a1);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), ValueAtIndex);
    CFRelease(ValueAtIndex);
  }

  *(void *)&double result = C3DParticleSystemInstanceAddEmitter((uint64_t)ValueAtIndex, a4, a2).n128_u64[0];
  return result;
}

void C3DParticleManagerUnregisterSystem(uint64_t a1, uint64_t a2)
{
  if (C3DNodeGetParticleSystems(a2))
  {
    C3DParticleManagerRemoveAllInstanceOfSystemsOnNode(a1, a2);
  }
}

void C3DParticleManagerRemoveAllInstanceOfSystemsOnNode(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i < v5; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
      uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)ValueAtIndex);
      SysteCFIndex m = C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex);
      if (C3DParticleSystemGetIsLocal(System)) {
        BOOL v10 = Library == a2;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), i);
        --v5;
        --i;
      }
      else
      {
        if (Library == a2) {
          C3DParticleSystemInstanceSetNode((uint64_t)ValueAtIndex, 0);
        }
        C3DParticleSystemInstanceRemoveEmittersWithNode((uint64_t)ValueAtIndex, a2);
      }
    }
  }
}

void C3DParticleManagerRemoveSystem(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    do
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v8);
      if (C3DSceneSourceGetLibrary((uint64_t)ValueAtIndex) == a2
        && C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex) == a3)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), v8);
        --v7;
      }
      else
      {
        ++v8;
      }
    }
    while (v8 < v7);
  }
}

void C3DParticleManagerRemoveAllInstanceOfSystem(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    do
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v6);
      if (C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex) == a2)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), v6);
        --v5;
      }
      else
      {
        ++v6;
      }
    }
    while (v6 < v5);
  }
}

void C3DParticleManagerResetAllInstanceOfSystem(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
      if (C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex) == a2) {
        C3DParticleSystemInstanceReset((uint64_t)ValueAtIndex);
      }
    }
  }
}

__CFArray *C3DParticleManagerGetParticleSystemsForNode(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x263EFFF70]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
      if (C3DSceneSourceGetLibrary((uint64_t)ValueAtIndex) == a2)
      {
        SysteCFIndex m = (const void *)C3DParticleSystemInstanceGetSystem((uint64_t)ValueAtIndex);
        CFArrayAppendValue(Mutable, System);
      }
    }
  }
  return Mutable;
}

void C3DParticleManagerRemoveAllSystems(uint64_t a1)
{
}

void __C3DParticleManagerRemoveActiveSystemInstance(uint64_t a1, const void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    while (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v6) != a2)
    {
      if (v5 == ++v6) {
        return;
      }
    }
    CFIndex v7 = *(__CFArray **)(a1 + 24);
    CFArrayRemoveValueAtIndex(v7, v6);
  }
}

void C3DParticleManagerUpdate(uint64_t a1, uint64_t a2, double a3)
{
  v19[1] = *MEMORY[0x263EF8340];
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count)
  {
    CFIndex v7 = Count;
    MEMORY[0x270FA5388](Count);
    CFIndex v9 = (const void **)((char *)v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v8 >= 0x200) {
      size_t v10 = 512;
    }
    else {
      size_t v10 = v8;
    }
    bzero((char *)v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
    v20.locatiouint64_t n = 0;
    v20.GLsizei length = v7;
    CFArrayGetValues(*(CFArrayRef *)(a1 + 24), v20, v9);
    if (v7 < 1)
    {
      LOBYTE(v11) = 0;
    }
    else
    {
      int v11 = 0;
      do
      {
        uint64_t v12 = (uint64_t *)*v9;
        C3DParticleSystemInstanceSync((uint64_t)*v9, a2);
        C3DParticleSystemInstanceUpdate((uint64_t)v12, a3);
        if (C3DSceneSourceGetStatus((uint64_t)v12) == 2)
        {
          SysteCFIndex m = C3DParticleSystemInstanceGetSystem((uint64_t)v12);
          if ((C3DParticleSystemGetLoops(System) & 1) == 0 && (C3DIsRunningInXcode() & 1) == 0)
          {
            uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)v12);
            uint64_t v15 = C3DParticleSystemInstanceGetSystem((uint64_t)v12);
            SCNNodeRemoveDeadParticleInstance(Library, v15);
          }
          if (C3DIsRunningInXcode())
          {
            if (C3DParticleSystemGetLoops(System))
            {
              uint64_t v16 = C3DSceneSourceGetLibrary((uint64_t)v12);
              if (v16)
              {
                uint64_t v17 = (float32x4_t *)v16;
                if (C3DNodeGetParticleSystems(v16)) {
                  C3DParticleManagerRemoveAllInstanceOfSystemsOnNode(a1, (uint64_t)v17);
                }
                C3DParticleManagerRegisterSystem(a1, v17);
                C3DParticleSystemInstanceSetNode((uint64_t)v12, (uint64_t)v17);
              }
            }
          }
          else
          {
            __C3DParticleManagerRemoveActiveSystemInstance(a1, v12);
          }
        }
        else
        {
          v11 |= C3DParticleSystemGetSoftParticlesEnabled(v12[6]);
        }
        ++v9;
        --v7;
      }
      while (v7);
    }
    if (*(unsigned char *)(a1 + 32) != (v11 & 1))
    {
      Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationEngineContextInvalidatePasses", *(const void **)(a1 + 16), 0, 1u);
      *(unsigned char *)(a1 + 32) = v11 & 1;
    }
  }
}

void C3DParticleManagerCull(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int FrameStamp = C3DSceneGetFrameStamp(*(void *)(a1 + 16));
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v12 = Count;
    for (CFIndex i = 0; i != v12; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
      if (C3DParticleSystemInstanceGetParticlesCount((uint64_t)ValueAtIndex)
        && (!*(unsigned char *)(a2 + 4689) || C3DParticleSystemGetBlendMode(ValueAtIndex[6]) == 5))
      {
        float32x4_t v23 = 0u;
        float32x4_t v24 = 0u;
        WorldBoundingBofloat x = C3DParticleSystemInstanceGetWorldBoundingBox((uint64_t)ValueAtIndex);
        float32x4_t v23 = (float32x4_t)WorldBoundingBox;
        float32x4_t v24 = v16;
        if (*(unsigned char *)(a2 + 4692)) {
          goto LABEL_8;
        }
        float32x4_t v17 = *(float32x4_t *)(a2 + 96 * a4 + 64);
        v22[2] = *(float32x4_t *)(a2 + 96 * a4 + 48);
        v22[3] = v17;
        float32x4_t v18 = *(float32x4_t *)(a2 + 96 * a4 + 96);
        v22[4] = *(float32x4_t *)(a2 + 96 * a4 + 80);
        v22[5] = v18;
        float32x4_t v19 = *(float32x4_t *)(a2 + 96 * a4 + 32);
        v22[0] = *(float32x4_t *)(a2 + 96 * a4 + 16);
        v22[1] = v19;
        if (scn_frustum_classify_aabb(v22, (float32x4_t)WorldBoundingBox, v16) != 1) {
LABEL_8:
        }
          C3DParticleSystemInstancePushRendererElements((uint64_t)ValueAtIndex, (uint64_t *)a2, a3, FrameStamp, &v23, a4, a5, a6);
      }
    }
  }
}

uint64_t C3DParticleManagerGetSharedQuadsMeshElement(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4 || C3DMeshElementGetPrimitiveCount(v4) < 2 * a2)
  {
    unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
    unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
    int v7 = v6 | HIWORD(v6);
    if ((v7 + 1) > 0x100) {
      int v8 = v7 + 1;
    }
    else {
      int v8 = 256;
    }
    int v9 = 2 * v8;
    unsigned int v10 = 4 * v8;
    int v11 = (const void *)C3DMeshElementCreate();
    if ((4 * v8) > 0x10000) {
      int v12 = 4;
    }
    else {
      int v12 = 2;
    }
    if (v10 <= 0x10000) {
      char v13 = 1;
    }
    else {
      char v13 = 2;
    }
    BOOL v14 = v10 >= 0x101;
    if (v10 < 0x101) {
      int v15 = 1;
    }
    else {
      int v15 = v12;
    }
    if (!v14) {
      char v13 = 0;
    }
    size_t v16 = ((6 * v8) << v13);
    float32x4_t v17 = (const UInt8 *)C3DMallocWithName(v16);
    if (v15 == 1)
    {
      int v21 = 0;
      uint64_t v22 = (UInt8 *)v17;
      do
      {
        *uint64_t v22 = v21;
        v22[1] = v21 | 1;
        v22[2] = v21 | 2;
        v22[3] = v21;
        v22[4] = v21 | 2;
        v22[5] = v21 | 3;
        v22 += 6;
        v21 += 4;
        --v8;
      }
      while (v8);
    }
    else if (v15 == 2)
    {
      int v23 = 0;
      float32x4_t v24 = (UInt8 *)v17;
      do
      {
        *(_WORD *)float32x4_t v24 = v23;
        *((_WORD *)v24 + 1) = v23 | 1;
        __int16 v25 = v23 | 2;
        *((_WORD *)v24 + 2) = v23 | 2;
        *((_WORD *)v24 + 3) = v23;
        __int16 v26 = v23 | 3;
        v23 += 4;
        *((_WORD *)v24 + 4) = v25;
        *((_WORD *)v24 + 5) = v26;
        v24 += 12;
        --v8;
      }
      while (v8);
    }
    else
    {
      unsigned int v18 = 0;
      float32x4_t v19 = (int8x8_t *)v17;
      do
      {
        v19->i32[0] = v18;
        v19->i32[1] = v18 + 1;
        int8x8_t v20 = vorr_s8((int8x8_t)vdup_n_s32(v18), (int8x8_t)0x300000002);
        v19[1].i32[0] = v20.i32[0];
        v19[1].i32[1] = v18;
        void v19[2] = v20;
        v18 += 4;
        v19 += 3;
        --v8;
      }
      while (v8);
    }
    CFDataRef v27 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v17, v16, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
    C3DMeshElementSetPrimitives((uint64_t)v11, v9, v27, v15);
    CFRelease(v27);
    uint64_t v28 = *(const void **)(a1 + 40);
    if (v28 != v11)
    {
      if (v28)
      {
        CFRelease(v28);
        *(void *)(a1 + 40) = 0;
      }
      if (v11) {
        CFTypeRef v29 = CFRetain(v11);
      }
      else {
        CFTypeRef v29 = 0;
      }
      *(void *)(a1 + 40) = v29;
    }
    CFRelease(v11);
  }
  return *(void *)(a1 + 40);
}

const void *C3DParticleManagerGetSharedPyramidQuadsMeshElement(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4 && C3DMeshElementGetPrimitiveCount(v4) >= 4 * a2) {
    return *(const void **)(a1 + 56);
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 0x100) {
    int v8 = v7 + 1;
  }
  else {
    int v8 = 256;
  }
  int v9 = 4 * v8;
  unsigned int v10 = 5 * v8;
  int v11 = (const void *)C3DMeshElementCreate();
  if ((5 * v8) >= 0x10000) {
    int v12 = 4;
  }
  else {
    int v12 = 2;
  }
  if (v10 < 0x10000) {
    char v13 = 1;
  }
  else {
    char v13 = 2;
  }
  BOOL v14 = v10 >= 0x100;
  if (v10 < 0x100) {
    int v15 = 1;
  }
  else {
    int v15 = v12;
  }
  if (!v14) {
    char v13 = 0;
  }
  size_t v16 = ((12 * v8) << v13);
  float32x4_t v17 = (const UInt8 *)C3DMallocWithName(v16);
  if (v15 == 1)
  {
    int v21 = 0;
    uint64_t v22 = (UInt8 *)v17;
    do
    {
      *uint64_t v22 = v21;
      v22[1] = v21 + 1;
      v22[2] = v21 + 4;
      v22[3] = v21 + 1;
      v22[4] = v21 + 2;
      v22[5] = v21 + 4;
      float32x4_t v22[6] = v21 + 2;
      v22[7] = v21 + 3;
      v22[8] = v21 + 4;
      v22[9] = v21 + 3;
      v22[10] = v21;
      v22[11] = v21 + 4;
      v22 += 12;
      v21 += 5;
      --v8;
    }
    while (v8);
  }
  else if (v15 == 2)
  {
    int v23 = 0;
    float32x4_t v24 = (UInt8 *)v17;
    do
    {
      *(_WORD *)float32x4_t v24 = v23;
      *((_WORD *)v24 + 1) = v23 + 1;
      __int16 v25 = v23 + 4;
      *((_WORD *)v24 + 2) = v23 + 4;
      *((_WORD *)v24 + 3) = v23 + 1;
      *((_WORD *)v24 + 4) = v23 + 2;
      *((_WORD *)v24 + 5) = v23 + 4;
      *((_WORD *)v24 + 6) = v23 + 2;
      __int16 v26 = v23 + 3;
      *((_WORD *)v24 + 7) = v23 + 3;
      *((_WORD *)v24 + _Block_object_dispose(&STACK[0x2A0], 8) = v23 + 4;
      *((_WORD *)v24 + 10) = v23;
      v23 += 5;
      *((_WORD *)v24 + 9) = v26;
      *((_WORD *)v24 + 11) = v25;
      v24 += 24;
      --v8;
    }
    while (v8);
  }
  else
  {
    int v18 = 0;
    float32x4_t v19 = (UInt8 *)v17;
    do
    {
      *(_DWORD *)float32x4_t v19 = v18;
      *((_DWORD *)v19 + 1) = v18 + 1;
      int v20 = v18 + 4;
      *((_DWORD *)v19 + 2) = v18 + 4;
      *((_DWORD *)v19 + 3) = v18 + 1;
      *((_DWORD *)v19 + 4) = v18 + 2;
      *((_DWORD *)v19 + 5) = v18 + 4;
      *((_DWORD *)v19 + 6) = v18 + 2;
      *((_DWORD *)v19 + 7) = v18 + 3;
      *((_DWORD *)v19 + 9) = v18 + 3;
      *((_DWORD *)v19 + 10) = v18;
      v18 += 5;
      *((_DWORD *)v19 + _Block_object_dispose(&STACK[0x2A0], 8) = v20;
      *((_DWORD *)v19 + 11) = v20;
      v19 += 48;
      --v8;
    }
    while (v8);
  }
  CFDataRef v27 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v17, v16, (CFAllocatorRef)*MEMORY[0x263EFFB08]);
  C3DMeshElementSetPrimitives((uint64_t)v11, v9, v27, v15);
  CFRelease(v27);
  uint64_t v28 = *(const void **)(a1 + 56);
  if (v28 != v11)
  {
    if (v28)
    {
      CFRelease(v28);
      *(void *)(a1 + 56) = 0;
    }
    if (v11) {
      int v11 = CFRetain(v11);
    }
    *(void *)(a1 + 56) = v11;
  }
  return v11;
}

uint64_t C3DParticleManagerGetSharedQuadMeshSource(uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v2 = a1 + 80;
    if (!*(void *)(a1 + 80))
    {
      long long v7 = xmmword_20B5CD390;
      long long v8 = unk_20B5CD3A0;
      unint64_t v9 = 0xBF800000BF800000;
      CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)&v7, 40);
      CFDataRef v4 = v3;
      uint64_t v5 = 5;
LABEL_6:
      *(void *)uint64_t v2 = C3DMeshSourceCreate(v3, 3, v5, 2, 1);
      CFRelease(v4);
    }
  }
  else
  {
    uint64_t v2 = a1 + 64;
    if (!*(void *)(a1 + 64))
    {
      long long v7 = xmmword_20B5CD3B8;
      long long v8 = unk_20B5CD3C8;
      CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)&v7, 32);
      CFDataRef v4 = v3;
      uint64_t v5 = 4;
      goto LABEL_6;
    }
  }
  return *(void *)v2;
}

uint64_t C3DParticleManagerGetSharedPyramidMeshElement(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 88);
  if (!v1)
  {
    int v6 = 17039364;
    *(void *)bytes = 0x300030200020100;
    CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 12);
    uint64_t v1 = C3DMeshElementCreate();
    C3DMeshElementInit(v1, 0, 4, v3, 1);
    CFRelease(v3);
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = v1;
  }
  return v1;
}

uint64_t C3DParticleManagerGetSharedPyramidStereoMeshElement(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 104);
  if (!v1)
  {
    long long v5 = xmmword_20B5CD3E4;
    uint64_t v6 = 0x609050908050807;
    CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)&v5, 24);
    uint64_t v1 = C3DMeshElementCreate();
    C3DMeshElementInit(v1, 0, 4, v3, 1);
    CFRelease(v3);
    *(void *)(a1 + 104) = v1;
  }
  return v1;
}

uint64_t C3DParticleManagerGetSharedQuadsStereoMeshElement(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    int v6 = 67438340;
    *(void *)bytes = 0x706000103000302;
    CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, 12);
    uint64_t v1 = C3DMeshElementCreate();
    C3DMeshElementInit(v1, 0, 3, v3, 1);
    CFRelease(v3);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = v1;
  }
  return v1;
}

uint64_t C3DParticleManagerGetSharedQuadStereoMeshSource(uint64_t a1, int a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v2 = a1 + 96;
    if (!*(void *)(a1 + 96))
    {
      long long v9 = xmmword_20B5CD428;
      long long v10 = unk_20B5CD438;
      long long v11 = xmmword_20B5CD448;
      long long v7 = xmmword_20B5CD408;
      long long v8 = unk_20B5CD418;
      CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)&v7, 80);
      CFDataRef v4 = v3;
      uint64_t v5 = 10;
LABEL_6:
      *(void *)uint64_t v2 = C3DMeshSourceCreate(v3, 3, v5, 2, 1);
      CFRelease(v4);
    }
  }
  else
  {
    uint64_t v2 = a1 + 72;
    if (!*(void *)(a1 + 72))
    {
      long long v7 = xmmword_20B5CD458;
      long long v8 = unk_20B5CD468;
      long long v9 = xmmword_20B5CD478;
      long long v10 = unk_20B5CD488;
      CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)&v7, 64);
      CFDataRef v4 = v3;
      uint64_t v5 = 8;
      goto LABEL_6;
    }
  }
  return *(void *)v2;
}

void *C3DParticleManagerComputeTechniqueForSystem(uint64_t a1, __n128 *a2, char a3, uint64_t a4, int a5, int a6)
{
  v100[0] = a3;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a4);
  int RenderingMode = C3DParticleSystemGetRenderingMode((uint64_t)a2);
  char v13 = @"C3D-ParticleSystem_Trail";
  switch(RenderingMode)
  {
    case 0:
      char v13 = @"C3D-ParticleSystem";
      goto LABEL_8;
    case 1:
      char v13 = @"C3D-ParticleSystem_PointSprite";
      goto LABEL_8;
    case 2:
    case 3:
      goto LABEL_8;
    case 4:
      int v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        C3DParticleManagerComputeTechniqueForSystem_cold_2(v15, v16, v17, v18, v19, v20, v21, v22);
      }
      char v13 = &stru_26BF72F58;
LABEL_8:
      int BlackPassEnabled = C3DParticleSystemGetBlackPassEnabled((uint64_t)a2);
      char LightingEnabled = C3DParticleSystemGetLightingEnabled((uint64_t)a2);
      BOOL v98 = 0;
      if (C3DParticleSystemGetParticleColorController((uint64_t)a2)) {
        BOOL v24 = 1;
      }
      else {
        BOOL v24 = C3DParticleSystemGetParticleOpacityController((uint64_t)a2) != 0;
      }
      BOOL v98 = v24;
      BOOL v97 = 0;
      BOOL v26 = C3DParticleSystemGetStretchFactor((uint64_t)a2) != 0.0 && RenderingMode == 0;
      BOOL v97 = v26;
      HasTextureuint64_t Animation = C3DParticleSystemHasTextureAnimation((uint64_t)a2);
      int SoftParticlesEnabled = C3DParticleSystemGetSoftParticlesEnabled((uint64_t)a2);
      unsigned int BlendMode = C3DParticleSystemGetBlendMode((uint64_t)a2);
      unsigned int OrientationMode = C3DParticleSystemGetOrientationMode((uint64_t)a2);
      BOOL v93 = a5 == 2;
      unsigned int v28 = a5 - 1;
      BOOL v92 = a5 == 1;
      BOOL v91 = a6 == 2;
      char v90 = 0;
      if (-[SCNMTLRenderContext enableARMode](RenderContext)) {
        char v29 = 1;
      }
      else {
        char v29 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
      }
      char v90 = v29;
      EyeCFIndex Count = C3DEngineContextGetEyeCount(a4);
      uint32x4_t v30 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)C3DParticleSystemGetOrientationDirection(a2)));
      v30.i32[3] = v30.i32[2];
      if ((vmaxvq_u32(v30) & 0x80000000) != 0) {
        unsigned int OrientationMode = 4;
      }
      unsigned int ImageSequenceAnimationMode = C3DParticleSystemGetImageSequenceAnimationMode((uint64_t)a2);
      HasCubeMapuint64_t Texture = C3DParticleSystemHasCubeMapTexture((uint64_t)a2);
      int IsLocal = C3DParticleSystemGetIsLocal((uint64_t)a2);
      char v86 = IsLocal;
      CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      if (SoftParticlesEnabled) {
        uint64_t v33 = 68;
      }
      else {
        uint64_t v33 = 45;
      }
      if (IsLocal) {
        uint64_t v34 = 76;
      }
      else {
        uint64_t v34 = 71;
      }
      if (HasTextureAnimation) {
        uint64_t v35 = ImageSequenceAnimationMode;
      }
      else {
        uint64_t v35 = 0;
      }
      uint64_t v80 = v33;
      uint64_t v79 = v35;
      uint64_t v36 = 65;
      if (!HasTextureAnimation) {
        uint64_t v36 = 45;
      }
      uint64_t v37 = 66;
      if (!BlackPassEnabled) {
        uint64_t v37 = 45;
      }
      uint64_t v38 = 70;
      if (!v100[0]) {
        uint64_t v38 = 45;
      }
      uint64_t v39 = 75;
      if (!HasCubeMapTexture) {
        uint64_t v39 = 45;
      }
      uint64_t v40 = 83;
      if (!v97) {
        uint64_t v40 = 45;
      }
      if (LightingEnabled) {
        uint64_t v41 = 76;
      }
      else {
        uint64_t v41 = 45;
      }
      uint64_t v42 = 67;
      if (!v98) {
        uint64_t v42 = 45;
      }
      uint64_t v43 = 82;
      if (!v90) {
        uint64_t v43 = 45;
      }
      uint64_t v44 = 77;
      if (!v91) {
        uint64_t v44 = 45;
      }
      uint64_t v45 = 89;
      if (!v92) {
        uint64_t v45 = 95;
      }
      uint64_t v46 = 86;
      if (!v93) {
        uint64_t v46 = 45;
      }
      CFStringRef v47 = CFStringCreateWithFormat(v32, 0, @"%@%1d%1d%c%c%c%c%c%c%c%c%c%c%c%1dO%1d%c%c", v13, BlendMode, EyeCount, v46, v45, v44, v43, v42, v41, v40, v39, v38, v37, v36, v79, OrientationMode,
              v80,
              v34);
      BOOL v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), v47);
      if (v14) {
        goto LABEL_148;
      }
      if (RenderContext)
      {
        id v48 = objc_alloc_init(MEMORY[0x263F128B0]);
        [v48 setConstantValue:&LightingEnabled type:53 withName:@"enableLighting"];
        [v48 setConstantValue:&v98 type:53 withName:@"enableColorRamp"];
        [v48 setConstantValue:&HasCubeMapTexture type:53 withName:@"enableCubeMap"];
        [v48 setConstantValue:&v97 type:53 withName:@"enableStretch"];
        [v48 setConstantValue:&HasTextureAnimation type:53 withName:@"enableAnimation"];
        [v48 setConstantValue:v100 type:53 withName:@"enableFog"];
        [v48 setConstantValue:&v93 type:53 withName:@"enableMultipleViewport"];
        [v48 setConstantValue:&v92 type:53 withName:@"enableLayeredRendering"];
        [v48 setConstantValue:&v91 type:53 withName:@"useVertexAmplification"];
        [v48 setConstantValue:&EyeCount type:33 withName:@"eyeCount"];
        [v48 setConstantValue:&v90 type:53 withName:@"ARMode"];
        [v48 setConstantValue:&v86 type:53 withName:@"isLocal"];
        [v48 setConstantValue:&OrientationMode type:33 withName:@"orientation"];
        [v48 setConstantValue:&ImageSequenceAnimationMode type:33 withName:@"animationMode"];
        [v48 setConstantValue:&BlendMode type:33 withName:@"blendMode"];
        if (v28 >= 2) {
          uint64_t v49 = @"uberparticle_vert";
        }
        else {
          uint64_t v49 = @"uberparticle_stereo_vert";
        }
        if (HasCubeMapTexture) {
          uint64_t v50 = @"uberparticleCube_frag";
        }
        else {
          uint64_t v50 = @"uberparticle_frag";
        }
        uint64_t v51 = (const void *)C3DFXMetalProgramCreateFromLibraryWithConstants(v49, v50, 0, v48, 0, 0);

        goto LABEL_86;
      }
      int v83 = SoftParticlesEnabled;
      uint64_t v52 = (void *)[(__CFString *)v13 stringByAppendingString:@".vsh"];
      uint64_t v53 = (void *)[(__CFString *)v13 stringByAppendingString:@".fsh"];
      uint64_t v54 = (void *)C3DGetTextResourceWithNameAllowingHotReload(v52);
      uint64_t v55 = (void *)C3DGetTextResourceWithNameAllowingHotReload(v53);
      if (v54 && v55)
      {
        float64x2_t v82 = v55;
        GLfloat v56 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v32, 0, MEMORY[0x263EFFF70]);
        GLfloat v58 = CFArrayCreateMutable(v32, 0, v56);
        CFArrayAppendValue(Mutable, @"precision highp float;\n");
        CFArrayAppendValue(v58, @"precision mediump float;\n");
        if (LightingEnabled) {
          CFArrayAppendValue(Mutable, @"#define ENABLE_LIGHTING");
        }
        if (v98) {
          CFArrayAppendValue(Mutable, @"#define ENABLE_COLOR_RAMP");
        }
        if (HasCubeMapTexture)
        {
          CFArrayAppendValue(Mutable, @"#define ENABLE_CUBE_MAP");
          CFArrayAppendValue(v58, @"#define ENABLE_CUBE_MAP");
        }
        unsigned int value = v54;
        if (v97)
        {
          GLfloat v59 = @"#define ENABLE_STRETCH";
          int v60 = v83;
        }
        else
        {
          int v60 = v83;
          if (OrientationMode - 1 > 2) {
            GLfloat v59 = @"#define ENABLE_BILLBOARD_SCREEN";
          }
          else {
            GLfloat v59 = off_264006940[OrientationMode - 1];
          }
        }
        CFArrayAppendValue(Mutable, v59);
        if (v100[0])
        {
          CFArrayAppendValue(Mutable, @"#define ENABLE_FOG");
          int v60 = v83;
          CFArrayAppendValue(v58, @"#define ENABLE_FOG");
        }
        if (HasTextureAnimation)
        {
          CFStringRef v62 = CFStringCreateWithFormat(v32, 0, @"#define ENABLE_ANIMATION %d", ImageSequenceAnimationMode);
          CFArrayAppendValue(Mutable, v62);
          CFArrayAppendValue(v58, v62);
          int v60 = v83;
          CFRelease(v62);
        }
        if (v60)
        {
          CFArrayAppendValue(Mutable, @"#define ENABLE_SOFT");
          CFArrayAppendValue(v58, @"#define ENABLE_SOFT");
        }
        CFArrayAppendValue(Mutable, value);
        CFStringRef v63 = CFStringCreateByCombiningStrings(v32, Mutable, @"\n");
        CFRelease(Mutable);
        CFArrayAppendValue(v58, v82);
        CFStringRef v64 = CFStringCreateByCombiningStrings(v32, v58, @"\n");
        CFRelease(v58);
        uint64_t v51 = (const void *)C3DFXGLSLProgramCreateWithSources(v63, v64);
        CFRelease(v63);
        CFRelease(v64);
        int SoftParticlesEnabled = v83;
LABEL_86:
        if (BlackPassEnabled) {
          size_t v65 = 2;
        }
        else {
          size_t v65 = 1;
        }
        BOOL v14 = (void *)C3DFXTechniqueCreateWithCapacity(v65);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 112), v47, v14);
        CFRelease(v14);
        C3DFXProgramSetOpaque((uint64_t)v51, 0);
        C3DFXProgramSetClientProgram((uint64_t)v51, 0);
        memset(v85, 0, 28);
        C3DRasterizerStatesDescGetDefault(v85);
        BYTE9(v85[0]) = C3DParticleSystemGetWritesToDepthBuffer((uint64_t)a2);
        LODWORD(v85[0]) = 2;
        v84[0] = v85[0];
        *(_OWORD *)((char *)v84 + 12) = *(_OWORD *)((char *)v85 + 12);
        GLint v66 = (const void *)C3DRasterizerStatesCreate((uint64_t)v84);
        float v67 = 0;
        if (BlackPassEnabled)
        {
          float v67 = (const void *)C3DFXPassCreate();
          C3DFXPassSetClearBehavior((uint64_t)v67, 0, 0, 0);
          C3DFXPassSetName((uint64_t)v67, @"BlackPass");
          C3DFXPassSetInstallViewport((uint64_t)v67, 0);
          C3DFXPassSetDrawInstruction((uint64_t)v67, 1);
          C3DFXPassSetProgram((uint64_t)v67, v51);
          float v68 = (const void *)C3DBlendStatesDefaultOverBlack();
          C3DFXPassSetBlendStates((uint64_t)v67, v68);
          C3DFXPassSetRasterizerStates((uint64_t)v67, v66);
          C3DFXTechniqueAppendPass(v14, v67);
          CFRelease(v67);
        }
        switch(BlendMode)
        {
          case 0u:
            uint64_t v69 = C3DBlendStatesDefaultAdditive();
            goto LABEL_99;
          case 1u:
            uint64_t v69 = C3DBlendStatesDefaultSubtract();
            goto LABEL_99;
          case 2u:
            uint64_t v69 = C3DBlendStatesDefaultMultiplicative();
            goto LABEL_99;
          case 3u:
            uint64_t v69 = C3DBlendStatesDefaultScreen();
            goto LABEL_99;
          case 4u:
            uint64_t v69 = C3DBlendStatesDefaultOver();
            goto LABEL_99;
          case 5u:
            uint64_t v69 = C3DBlendStatesDefaultReplace();
LABEL_99:
            GLfloat v70 = (const void *)v69;
            break;
          default:
            GLfloat v70 = 0;
            break;
        }
        int v71 = (const void *)C3DFXPassCreate();
        C3DFXPassSetClearBehavior((uint64_t)v71, 0, 0, 0);
        C3DFXPassSetName((uint64_t)v71, v47);
        C3DFXPassSetInstallViewport((uint64_t)v71, 0);
        C3DFXPassSetDrawInstruction((uint64_t)v71, 1);
        C3DFXPassSetRasterizerStates((uint64_t)v71, v66);
        C3DFXPassSetBlendStates((uint64_t)v71, v70);
        C3DFXPassSetProgram((uint64_t)v71, v51);
        C3DRasterizerStatesRelease(v66);
        CFRelease(v51);
        C3DFXTechniqueAppendPass(v14, v71);
        CFRelease(v71);
        if (RenderContext)
        {
          if (!HasCubeMapTexture) {
            goto LABEL_110;
          }
        }
        else
        {
          C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"viewTransform", 11, 1u);
          C3DFXPassBindInputWithSymbol((uint64_t)v71, @"viewTransform", @"viewTransform");
          if (v67) {
            C3DFXPassBindInputWithSymbol((uint64_t)v67, @"viewTransform", @"viewTransform");
          }
          if (!HasCubeMapTexture)
          {
LABEL_110:
            if (LightingEnabled)
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_lightPosition0", 9, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_lightPosition0", @"u_lightPosition0");
              if (v67)
              {
                C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_lightPosition0", @"u_lightPosition0");
                C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_lightColor0", 13, 1u);
                C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_lightColor0", @"u_lightColor0");
                uint64_t v72 = (uint64_t)v67;
              }
              else
              {
                C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_lightColor0", 13, 1u);
                uint64_t v72 = (uint64_t)v71;
              }
              C3DFXPassBindInputWithSymbol(v72, @"u_lightColor0", @"u_lightColor0");
            }
            if (v98)
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_colorRamp", 5, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_colorRamp", @"u_colorRamp");
              if (v67) {
                C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_colorRamp", @"u_colorRamp");
              }
            }
            if (v97)
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_stretchFactor", 1, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_stretchFactor", @"u_stretchFactor");
              if (v67) {
                C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_stretchFactor", @"u_stretchFactor");
              }
            }
            if (HasTextureAnimation)
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_frameSize", 10, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_frameSize", @"u_frameSize");
              if (v67) {
                C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_frameSize", @"u_frameSize");
              }
            }
            if (RenderContext) {
              int v73 = 0;
            }
            else {
              int v73 = SoftParticlesEnabled;
            }
            if (v73 == 1)
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_softParameters", 10, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_softParameters", @"u_softParameters");
              if (v67)
              {
                C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_softParameters", @"u_softParameters");
                C3DFXPassBindInputWithSemantic((uint64_t)v71, @"u_invProj", 16);
                C3DFXPassBindInputWithSemantic((uint64_t)v67, @"u_invProj", 16);
                C3DFXPassBindInputWithSemantic((uint64_t)v71, @"u_depthSampler0", 28);
                uint64_t v74 = (uint64_t)v67;
              }
              else
              {
                C3DFXPassBindInputWithSemantic((uint64_t)v71, @"u_invProj", 16);
                uint64_t v74 = (uint64_t)v71;
              }
              C3DFXPassBindInputWithSemantic(v74, @"u_depthSampler0", 28);
            }
            if (v100[0])
            {
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_fogParameters", 9, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_fogParameters", @"u_fogParameters");
              if (!v67)
              {
                C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_fogColor", 13, 1u);
                C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_fogColor", @"u_fogColor");
                if (RenderContext)
                {
LABEL_141:
                  C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_textureSampler0", 5, 1u);
                  C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_textureSampler0", @"u_textureSampler0");
                  if (v67) {
                    C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_textureSampler0", @"u_textureSampler0");
                  }
                  int v76 = (const void *)C3DFXSamplerCreate();
                  C3DFXTechniqueSetValueForSymbol((uint64_t)v14, @"u_textureSampler0", v76);
                  if (HasTextureAnimation) {
                    BOOL v77 = (const void *)C3DTextureSamplerTrilinearRepeatNoAnisotropy();
                  }
                  else {
                    BOOL v77 = (const void *)C3DTextureSamplerBilinearMipMapClampNoAnisotropy();
                  }
                  C3DFXSamplerSetTextureSampler((uint64_t)v76, v77);
                  CFRelease(v76);
                  C3DFXPassSetWillExecuteCallback((uint64_t)v71, (uint64_t)_willExecuteParticleSystemPass);
                  C3DFloorSetReflectionCategoryBitMask((uint64_t)v71, (uint64_t)_executeParticleSystemPass);
                  if (v67)
                  {
                    C3DFXPassSetWillExecuteCallback((uint64_t)v67, (uint64_t)_willExecuteParticleSystemPass);
                    C3DFloorSetReflectionCategoryBitMask((uint64_t)v67, (uint64_t)_executeParticleSystemPass);
                  }
                  goto LABEL_148;
                }
                uint64_t v75 = (uint64_t)v71;
LABEL_140:
                C3DFXPassBindInputWithSemantic(v75, @"u_projectionTransform", 10);
                goto LABEL_141;
              }
              C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_fogParameters", @"u_fogParameters");
              C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_fogColor", 13, 1u);
              C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_fogColor", @"u_fogColor");
              C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_fogColor", @"u_fogColor");
            }
            if (RenderContext) {
              goto LABEL_141;
            }
            C3DFXPassBindInputWithSemantic((uint64_t)v71, @"u_projectionTransform", 10);
            if (!v67) {
              goto LABEL_141;
            }
            uint64_t v75 = (uint64_t)v67;
            goto LABEL_140;
          }
          C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_viewToCubeWorld", 11, 1u);
          C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_viewToCubeWorld", @"u_viewToCubeWorld");
          if (v67) {
            C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_viewToCubeWorld", @"u_viewToCubeWorld");
          }
        }
        C3DFXTechniqueDeclareSymbol((uint64_t)v14, @"u_fresnelExponent", 1, 1u);
        C3DFXPassBindInputWithSymbol((uint64_t)v71, @"u_fresnelExponent", @"u_fresnelExponent");
        if (v67) {
          C3DFXPassBindInputWithSymbol((uint64_t)v67, @"u_fresnelExponent", @"u_fresnelExponent");
        }
        goto LABEL_110;
      }
      GLint v61 = scn_default_log();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        C3DParticleManagerComputeTechniqueForSystem_cold_1((uint64_t)v13, v61);
      }
      BOOL v14 = 0;
LABEL_148:
      CFRelease(v47);
      return v14;
    default:
      return 0;
  }
}

CFTypeRef _willExecuteParticleSystemPass(void *a1)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  uint64_t v2 = a1[8];
  uint64_t v3 = *(void *)(*(void *)(v2 + 48) + 48);
  uint64_t Scene = (__n128 *)C3DEngineContextGetScene(a1[3]);
  uint64_t v5 = a1[1];
  int v6 = (float32x4_t *)a1[2];
  long long v7 = (float32x4_t *)a1[4];
  if (!v7)
  {
    long long v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      _willExecuteParticleSystemPass_cold_1(v8);
    }
  }
  float32x4_t v9 = v7[62];
  float32x4_t v80 = v7[61];
  float32x4_t v81 = v9;
  float32x4_t v10 = v7[64];
  float32x4_t v82 = v7[63];
  float32x4_t v83 = v10;
  if (C3DEngineContextGetRenderContext(a1[3]))
  {
    if ((C3DParticleSystemHasCubeMapTexture(v3) & 1) == 0) {
      goto LABEL_15;
    }
LABEL_14:
    v54.i32[0] = 0;
    v54.f32[0] = C3DParticleSystemGetFresnelExponent(v3) * 0.5;
    C3DFXTechniqueSetValueForSymbol(v5, @"u_fresnelExponent", &v54);
    goto LABEL_15;
  }
  float32x4_t v54 = v80;
  float32x4_t v55 = v81;
  float32x4_t v56 = v82;
  float32x4_t v57 = v83;
  int IsLocal = C3DParticleSystemGetIsLocal(v3);
  if (v6) {
    int v12 = IsLocal;
  }
  else {
    int v12 = 0;
  }
  if (v12 == 1)
  {
    WorldMatrifloat x = C3DNodeGetWorldMatrix(v6);
    C3DMatrix4x4Mult((uint64_t)WorldMatrix, &v54, &v54);
  }
  C3DFXTechniqueSetValueForSymbol(v5, @"viewTransform", &v54);
  if (C3DParticleSystemHasCubeMapTexture(v3))
  {
    float32x4_t v54 = v80;
    float32x4_t v55 = v81;
    float32x4_t v56 = v82;
    float32x4_t v57 = v83;
    C3DSceneComputeViewToCubemapMatrix(Scene, (uint64_t)&v54);
    C3DFXTechniqueSetValueForSymbol(v5, @"u_viewToCubeWorld", &v54);
    goto LABEL_14;
  }
LABEL_15:
  if (C3DParticleSystemGetLightingEnabled(v3))
  {
    CFDictionaryRef LightingSystem = (const __CFDictionary *)C3DSceneGetLightingSystem((uint64_t)Scene);
    uint64_t v71 = 0;
    uint64_t v72 = &v71;
    uint64_t v73 = 0x3010000000;
    uint64_t v74 = &unk_20B6AE426;
    long long v75 = xmmword_20B5CD380;
    uint64_t v76 = 0;
    BOOL v77 = (float32x4_t *)&v76;
    uint64_t v78 = 0x3020000000;
    long long v79 = xmmword_20B5CD370;
    if (C3DEngineContextIsClusteredShadingEnabled(a1[3]))
    {
      uint64_t v15 = *(void *)(v2 + 8);
      if (v15) {
        CategoryBitMasuint64_t k = C3DNodeGetCategoryBitMask(v15);
      }
      else {
        CategoryBitMasuint64_t k = -1;
      }
      uint64_t v26 = a1[3];
      v63[0] = MEMORY[0x263EF8330];
      v63[1] = 3221225472;
      void v63[2] = ___willExecuteParticleSystemPass_block_invoke;
      int v63[3] = &unk_264006920;
      float32x4_t v64 = v80;
      float32x4_t v65 = v81;
      float32x4_t v66 = v82;
      float32x4_t v67 = v83;
      float v68 = &v76;
      uint64_t v69 = &v71;
      uint64_t v70 = CategoryBitMask;
      C3DLightingSystemEnumerateGlobalLights(LightingSystem, v26, (uint64_t)v63);
      C3DFXTechniqueSetValueForSymbol(v5, @"u_lightPosition0", &v77[2]);
      C3DFXTechniqueSetValueForSymbol(v5, @"u_lightColor0", v72 + 4);
    }
    else
    {
      uint64_t v62 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      float32x4_t v56 = 0u;
      float32x4_t v57 = 0u;
      float32x4_t v54 = 0u;
      float32x4_t v55 = 0u;
      C3DLightingSystemGetLightingSetDesc((uint64_t)LightingSystem, v2 + 56, (unint64_t *)&v54);
      uint64_t v17 = v54.i64[1];
      if (v54.i64[1])
      {
        if (C3DLightGetType(v54.i64[1]) == 1)
        {
          BOOL v24 = v77;
          float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x47C35000u);
          float32x4_t v25 = vmulq_f32(*(float32x4_t *)(*((void *)&v58 + 1) + 32), v18);
        }
        else
        {
          float32x4_t v25 = *(float32x4_t *)(*((void *)&v58 + 1) + 16);
          BOOL v24 = v77;
        }
        v24[2] = v25;
        C3DLightGetColorModulatedByIntensity(v17, v25, v18, v19, v20, v21, v22, v23);
        CFDataRef v27 = v72;
        v72[4] = v28;
        v27[5] = v29;
      }
      C3DFXTechniqueSetValueForSymbol(v5, @"u_lightPosition0", &v77[2]);
      C3DFXTechniqueSetValueForSymbol(v5, @"u_lightColor0", v72 + 4);
    }
    _Block_object_dispose(&v76, 8);
    _Block_object_dispose(&v71, 8);
  }
  if (C3DParticleSystemHasFogSupport(v3))
  {
    float PointOfViewScale = C3DEngineContextGetPointOfViewScale(a1[3]);
    *(__n64 *)v31.f32 = C3DSceneComputeFogParameters((uint64_t)Scene, PointOfViewScale);
    float v52 = v31.f32[0];
    float32x4_t v54 = v31;
    FogColor = (const void *)C3DSceneGetFogColor((uint64_t)Scene);
    v54.f32[0] = -v52;
    C3DFXTechniqueSetValueForSymbol(v5, @"u_fogParameters", &v54);
    C3DFXTechniqueSetValueForSymbol(v5, @"u_fogColor", FogColor);
  }
  if (C3DParticleSystemGetSoftParticlesEnabled(v3))
  {
    __n128 Viewport = C3DEngineContextGetViewport((__n128 *)a1[3]);
    __asm { FMOV            V1.2S, #1.0 }
    Viewport.n128_u64[0] = (unint64_t)vdiv_f32(_D1, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL));
    v39.i64[0] = 0x400000003F800000;
    v39.i64[1] = Viewport.n128_u64[0];
    float32x4_t v54 = v39;
    C3DFXTechniqueSetValueForSymbol(v5, @"u_softParameters", &v54);
  }
  if (C3DParticleSystemGetParticleColorController(v3) || C3DParticleSystemGetParticleOpacityController(v3))
  {
    ColorRamp = C3DParticleSystemGetColorRamp(v3);
    C3DFXTechniqueSetValueForSymbol(v5, @"u_colorRamp", ColorRamp);
  }
  int RenderingMode = C3DParticleSystemGetRenderingMode(v3);
  if (C3DParticleSystemGetStretchFactor(v3) != 0.0 && !RenderingMode)
  {
    v54.i32[0] = C3DParticleSystemGetStretchFactor(v3);
    C3DFXTechniqueSetValueForSymbol(v5, @"u_stretchFactor", &v54);
  }
  if (C3DParticleSystemHasTextureAnimation(v3))
  {
    ImageSequenceRowCFIndex Count = C3DParticleSystemGetImageSequenceRowCount(v3);
    ImageSequenceColumnCFIndex Count = C3DParticleSystemGetImageSequenceColumnCount(v3);
    v44.i64[0] = ImageSequenceRowCount;
    v44.i64[1] = ImageSequenceColumnCount;
    __asm { FMOV            V1.2D, #1.0 }
    int32x2_t v53 = (int32x2_t)vcvt_f32_f64(vdivq_f64(_Q1, vcvtq_f64_u64(v44)));
    *(int32x2_t *)v46.f32 = vrev64_s32(v53);
    v46.f32[2] = (float)ImageSequenceColumnCount;
    float v51 = (float)(int)(ImageSequenceColumnCount * ImageSequenceRowCount);
    v46.f32[3] = v51;
    float32x4_t v54 = v46;
    if (C3DWasLinkedBeforeMajorOSYear2016())
    {
      *(int32x2_t *)v47.f32 = v53;
      v47.f32[2] = (float)ImageSequenceRowCount;
      v47.f32[3] = v51;
      float32x4_t v54 = v47;
    }
    C3DFXTechniqueSetValueForSymbol(v5, @"u_frameSize", &v54);
  }
  Particleuint64_t Texture = (const void *)C3DParticleSystemGetParticleTexture(v3);
  if (!ParticleTexture) {
    Particleuint64_t Texture = C3DImageGetDefault();
  }
  uint64_t ValueForSymbol = C3DFXTechniqueGetValueForSymbol(v5, @"u_textureSampler0", 0);
  return C3DFXSamplerSetImage(ValueForSymbol, ParticleTexture);
}

void sub_20B354DA0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

double _executeParticleSystemPass(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(a1 + 64) + 48);
  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 != C3DParticleSystemInstanceGetTypeID())
  {
    CFDataRef v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _executeParticleSystemPass_cold_1(v4);
    }
  }
  *(void *)&double result = C3DParticleSystemInstanceDraw((uint64_t)v2, *(void *)(a1 + 24), *(void *)(a1 + 64), *(void *)a1, *(unsigned __int8 *)(a1 + 80), *(unsigned __int8 *)(a1 + 81)).n128_u64[0];
  return result;
}

void C3DParticleManagerEnumerateInstancesWithLightEmission(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
      if (ValueAtIndex)
      {
        long long v8 = ValueAtIndex;
        uint64_t v9 = ValueAtIndex[6];
        if (v9)
        {
          if (C3DParticleSystemGetLightEmissionRadiusFactor(v9) > 0.0) {
            (*(void (**)(uint64_t, void *))(a2 + 16))(a2, v8);
          }
        }
      }
    }
  }
}

uint64_t C3DParticleManagerGetUpdateQueue()
{
  return 0;
}

BOOL C3DParticleManagerNeedRedraw(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 24)) != 0;
}

void ___willExecuteParticleSystemPass_block_invoke(float32x4_t *a1, unsigned int a2, float32x4_t **a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v7 = a2;
    while (1)
    {
      uint64_t v8 = *a4;
      if ((a1[7].i64[0] & C3DLightGetCategoryBitMask(*a4)) != 0) {
        break;
      }
      ++a3;
      ++a4;
      if (!--v7) {
        return;
      }
    }
    float32x4_t v30 = a1[3];
    float32x4_t v32 = a1[2];
    float32x4_t v28 = a1[5];
    float32x4_t v29 = a1[4];
    WorldMatrifloat x = C3DNodeGetWorldMatrix(*a3);
    uint64_t v10 = 0;
    float32x4_t v11 = WorldMatrix[1];
    float32x4_t v12 = WorldMatrix[2];
    float32x4_t v13 = WorldMatrix[3];
    v34[0] = *WorldMatrix;
    v34[1] = v11;
    v34[2] = v12;
    uint32x2_t v34[3] = v13;
    memset(v35, 0, sizeof(v35));
    float32x4_t v36 = 0u;
    float32x4_t v37 = 0u;
    do
    {
      v35[v10] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v32, COERCE_FLOAT(v34[v10])), v30, *(float32x2_t *)&v34[v10], 1), v29, (float32x4_t)v34[v10], 2), v28, (float32x4_t)v34[v10], 3);
      ++v10;
    }
    while (v10 != 4);
    float32x4_t v31 = v37;
    float32x4_t v33 = v36;
    if (C3DLightGetType(v8) == 1)
    {
      float32x4_t v16 = v33;
      int32x4_t v20 = (int32x4_t)vmulq_f32(v16, v16);
      v20.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v20, 2), vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v20.i8, 1))).u32[0];
      float32x2_t v21 = vrsqrte_f32((float32x2_t)v20.u32[0]);
      float32x2_t v22 = vmul_f32(v21, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(v21, v21)));
      float32x2_t v15 = vmul_f32(v22, v22);
      *(float32x4_t *)(*(void *)(a1[6].i64[0] + 8) + 32) = vmulq_n_f32(v33, vmul_f32(v22, vrsqrts_f32((float32x2_t)v20.u32[0], v15)).f32[0]);
      __n128 v23 = *(float32x4_t **)(a1[6].i64[0] + 8);
      float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x47C35000u);
      float32x4_t v24 = vmulq_f32(v23[2], v14);
    }
    else
    {
      __n128 v23 = *(float32x4_t **)(a1[6].i64[0] + 8);
      float32x4_t v24 = v31;
    }
    v23[2] = v24;
    C3DLightGetColorModulatedByIntensity(v8, v24, v14, *(double *)&v15, *(double *)v16.i64, v17, v18, v19);
    uint64_t v25 = *(void *)(a1[6].i64[1] + 8);
    *(void *)(v25 + 32) = v26;
    *(void *)(v25 + 40) = v27;
  }
}

uint64_t C3DMeshSourceCreatedDeindexedCopy(const __C3DMeshSource *a1, unsigned int a2, unsigned int *a3)
{
  uint64_t Content = C3DMeshSourceGetContent((uint64_t)a1);
  unint64_t v8 = v7;
  size_t v9 = BYTE5(v7);
  uint64_t v10 = a2;
  unint64_t v11 = BYTE5(v7) * (unint64_t)a2;
  float32x4_t v12 = (const UInt8 *)malloc_type_malloc(v11, 0x4F15DC75uLL);
  float32x4_t v13 = v12;
  if (a2)
  {
    uint64_t v14 = a2;
    float32x2_t v15 = (UInt8 *)v12;
    do
    {
      unsigned int v16 = *a3++;
      memcpy(v15, (const void *)(Content + v9 * (unint64_t)v16), v9);
      v15 += v9;
      --v14;
    }
    while (v14);
  }
  CFDataRef v17 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v13, v11, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
  __int16 Semantic = C3DMeshSourceGetSemantic((uint64_t)a1);
  uint64_t v19 = C3DMeshSourceCreateWithData(Semantic, v17, BYTE6(v8), HIBYTE(v8), v10, v9, 0);
  CFRelease(v17);
  return v19;
}

uint64_t SCNMTLComputeCommandEncoder::setBuffers(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    uint64_t v5 = 0;
    uint64_t v6 = result + 8 * a4;
    for (CFIndex i = (void *)(v6 + 248); ; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 8 * v5);
      uint64_t v9 = *(void *)(a3 + 8 * v5);
      unint64_t v10 = v5 + a4;
      if (*(void *)(v6 + 8 * v5) != v8) {
        break;
      }
      unint64_t v11 = i;
      if (*(void *)(v6 + 8 * v5 + 248) != v9) {
        goto LABEL_6;
      }
LABEL_7:
      if (a5 == ++v5) {
        return result;
      }
    }
    *(void *)(v6 + 8 * v5) = v8;
    unint64_t v11 = (void *)(result + 8 * v10 + 248);
LABEL_6:
    *unint64_t v11 = v9;
    *(void *)(result + 8 * (v10 >> 6) + 1704) |= 1 << (a4 + v5);
    goto LABEL_7;
  }
  return result;
}

uint64_t C3DFXTechniqueCreateJittering()
{
  uint64_t v0 = (const void *)C3DDictionaryNamed(@"C3DFXJitteringPass.plist");
  uint64_t v1 = C3DFXTechniqueCreateWithDescription(v0, 0);
  uint64_t PassNamed = C3DFXTechniqueGetPassNamed(v1, @"SceneKit_JitterCopyFirstFrame");
  C3DFXPassSetInitializeCallback(PassNamed, (uint64_t)_initializeCopy);
  uint64_t v3 = C3DFXTechniqueGetPassNamed(v1, @"SceneKit_JitterToEven");
  C3DFXPassSetWillExecuteCallback(v3, (uint64_t)_willExecuteJittering);
  C3DFXPassSetInitializeCallback(v3, (uint64_t)_initialize);
  uint64_t v4 = C3DFXTechniqueGetPassNamed(v1, @"SceneKit_JitterToOdd");
  C3DFXPassSetWillExecuteCallback(v4, (uint64_t)_willExecuteJittering);
  C3DFXPassSetInitializeCallback(v4, (uint64_t)_initialize);
  uint64_t v5 = C3DFXTechniqueGetPassNamed(v1, @"SceneKit_JitterResolve");
  C3DFXPassSetWillExecuteCallback(v5, (uint64_t)_willExecuteJitteringResolve);
  C3DFXPassSetInitializeCallback(v5, (uint64_t)_initializeResolve);
  return v1;
}

void _initializeCopy(uint64_t *a1, int a2)
{
  if (a2) {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-Copy");
  }
  else {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"Copy_vert", @"Copy_frag");
  }
  uint64_t v4 = BuiltInProgramWithName;
  C3DFXPassSetProgram(*a1, BuiltInProgramWithName);
  C3DFXProgramSetClientProgram((uint64_t)v4, *(unsigned __int8 *)(*a1 + 80));
  if (v4)
  {
    CFRelease(v4);
  }
}

float _willExecuteJittering(uint64_t a1)
{
  float JitteringStep = (float)C3DEngineContextGetJitteringStep(*(void *)(a1 + 24));
  C3DFXTechniqueSetValueForSymbol(*(void *)(a1 + 8), @"C3D-jitter-factor", &JitteringStep);
  return result;
}

void _initialize(uint64_t *a1, int a2)
{
  if (a2) {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-IncrementalAverage");
  }
  else {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"IncrementalAverage_vert", @"IncrementalAverage_frag");
  }
  uint64_t v4 = BuiltInProgramWithName;
  C3DFXPassSetProgram(*a1, BuiltInProgramWithName);
  C3DFXProgramSetClientProgram((uint64_t)v4, *(unsigned __int8 *)(*a1 + 80));
  if (v4)
  {
    CFRelease(v4);
  }
}

void _initializeResolve(uint64_t *a1, int a2)
{
  if (a2) {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXGLSLProgramCreateBuiltInProgramWithName(@"C3D-Copy");
  }
  else {
    BuiltInProgramWithuint64_t Name = (const void *)C3DFXMetalProgramCreateFromDefaultLibrary(@"Copy_vert", @"Copy_frag");
  }
  uint64_t v4 = BuiltInProgramWithName;
  C3DFXPassSetProgram(*a1, BuiltInProgramWithName);
  C3DFXProgramSetClientProgram((uint64_t)v4, *(unsigned __int8 *)(*a1 + 80));
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t C3DBufferObjectGetTypeID()
{
  if (C3DBufferObjectGetTypeID_onceToken != -1) {
    dispatch_once(&C3DBufferObjectGetTypeID_onceToken, &__block_literal_global_37);
  }
  return C3DBufferObjectGetTypeID_typeID;
}

CFStringRef _C3DBufferObjectCFCopyDebugDescription(unsigned int *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t ID = C3DVRAMResourceGetID((uint64_t)a1);
  uint64_t v4 = a1[14];
  uint64_t v5 = a1[16];
  CFIndex v6 = CFGetRetainCount(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DBufferObject vbo:%ld addr:%p lockCount:%d target:%d retainCount:%d>", ID, a1, v4, v5, v6);
}

uint64_t __C3DBufferObjectGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DBufferObjectGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DBufferObjectCreate(unsigned int a1, int a2, int a3, uint64_t a4)
{
  if (C3DBufferObjectGetTypeID_onceToken != -1) {
    dispatch_once(&C3DBufferObjectGetTypeID_onceToken, &__block_literal_global_37);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DBufferObjectGetTypeID_typeID, 0x40uLL);
  *(_DWORD *)(Instance + 6_Block_object_dispose(&STACK[0x2A0], 8) = a3;
  *(void *)(Instance + 40) = a4;
  C3DVRAMResourceSetID(Instance, a1);
  *(_DWORD *)(Instance + 64) = a2;
  return Instance;
}

uint64_t C3DBufferObjectGetBufferID(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextDeleteBufferObject_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DVRAMResourceGetID(a1);
}

uint64_t C3DBufferObjectGetTarget(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextDeleteBufferObject_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 64);
}

uint64_t C3DBufferObjectGetSize(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextDeleteBufferObject_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 68);
}

uint64_t (*C3DConvertGetConverter(int a1, int a2))(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a1 <= 22)
  {
    switch(a1)
    {
      case 8:
        if (a2 == 40) {
          uint64_t v3 = C3DConvert_short2n_to_float2;
        }
        else {
          uint64_t v3 = 0;
        }
        BOOL v4 = a2 == 36;
        uint64_t v5 = C3DConvert_ushort2n_to_float2;
        break;
      case 9:
        if (a2 == 24) {
          uint64_t v3 = C3DConvert_unorm10a2_to_float3;
        }
        else {
          uint64_t v3 = 0;
        }
        BOOL v4 = a2 == 23;
        uint64_t v5 = C3DConvert_snorm10a2_to_float3;
        break;
      case 10:
        if (a2 == 28) {
          uint64_t v3 = C3DConvert_char4n_to_float4;
        }
        else {
          uint64_t v3 = 0;
        }
        BOOL v4 = a2 == 27;
        uint64_t v5 = C3DConvert_uchar4n_to_float4;
        break;
      default:
        return 0;
    }
LABEL_33:
    if (v4) {
      return (uint64_t (*)(uint64_t, int, uint64_t, int, unsigned int))v5;
    }
    else {
      return (uint64_t (*)(uint64_t, int, uint64_t, int, unsigned int))v3;
    }
  }
  else
  {
    switch(a1)
    {
      case 23:
        CFAllocatorRef v2 = C3DConvert_float3_to_snorm10a2;
        goto LABEL_15;
      case 24:
        CFAllocatorRef v2 = C3DConvert_float3_to_unorm10a2;
LABEL_15:
        if (a2 == 9) {
          goto LABEL_16;
        }
        return 0;
      case 25:
      case 26:
        return 0;
      case 27:
        if (a2 == 10) {
          uint64_t v3 = C3DConvert_float4_to_uchar4n;
        }
        else {
          uint64_t v3 = 0;
        }
        BOOL v4 = a2 == 9;
        uint64_t v5 = C3DConvert_float3_to_uchar4n;
        goto LABEL_33;
      case 28:
        if (a2 == 10) {
          uint64_t v3 = C3DConvert_float4_to_char4n;
        }
        else {
          uint64_t v3 = 0;
        }
        BOOL v4 = a2 == 9;
        uint64_t v5 = C3DConvert_float3_to_char4n;
        goto LABEL_33;
      default:
        if (a1 == 36)
        {
          CFAllocatorRef v2 = C3DConvert_float2_to_ushort2n;
        }
        else
        {
          if (a1 != 40) {
            return 0;
          }
          CFAllocatorRef v2 = C3DConvert_float2_to_short2n;
        }
        if (a2 != 8) {
          return 0;
        }
LABEL_16:
        uint64_t result = v2;
        break;
    }
  }
  return result;
}

uint64_t C3DConvert_float3_to_snorm10a2(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    __asm
    {
      FMOV            V1.4S, #-1.0
      FMOV            V2.4S, #1.0
    }
    do
    {
      uint64_t v14 = a3 + v5;
      v15.i64[0] = *(void *)v14;
      v15.i32[2] = *(_DWORD *)(v14 + 8);
      v15.i32[3] = 1.0;
      int8x16_t v16 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmulq_f32(vminnmq_f32(vmaxnmq_f32(v15, _Q1), _Q2), (float32x4_t)xmmword_20B5CD4A0)), (int8x16_t)xmmword_20B5CD4B0);
      LODWORD(v14) = v16.i32[0] | (v16.i32[1] << 10);
      *(uint32x2_t *)v16.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), (uint32x2_t)0x1E00000014);
      *(_DWORD *)(result + v6) = v14 | v16.i32[0] | v16.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float3_to_uchar4n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x4_t v8 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v9.i64[0] = 0xFF000000FFLL;
    v9.i64[1] = 0xFF000000FFLL;
    do
    {
      uint64_t v10 = a3 + v5;
      v11.i64[0] = *(void *)v10;
      v11.i64[1] = *(unsigned int *)(v10 + 8);
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      int8x16_t v13 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32(v12, v8, v11)), v9);
      LODWORD(v10) = v13.i32[0] | (v13.i32[1] << 8);
      *(uint32x2_t *)v13.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (uint32x2_t)0x1800000010);
      *(_DWORD *)(result + v6) = v10 | v13.i32[0] | v13.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float4_to_uchar4n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x4_t v8 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v9.i64[0] = 0xFF000000FFLL;
    v9.i64[1] = 0xFF000000FFLL;
    do
    {
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      int8x16_t v11 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32(v10, v8, *(float32x4_t *)(a3 + v5))), v9);
      __int32 v12 = v11.i32[0] | (v11.i32[1] << 8);
      *(uint32x2_t *)v11.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), (uint32x2_t)0x1800000010);
      *(_DWORD *)(result + v6) = v12 | v11.i32[0] | v11.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float3_to_char4n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x42FF0000u);
    v14.i64[0] = 0xFF000000FFLL;
    v14.i64[1] = 0xFF000000FFLL;
    do
    {
      uint64_t v15 = a3 + v5;
      v16.i64[0] = *(void *)v15;
      v16.i64[1] = *(unsigned int *)(v15 + 8);
      int8x16_t v17 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32((float32x4_t)vandq_s8(_Q0, (int8x16_t)vcgezq_f32(v16)), v13, v16)), v14);
      LODWORD(v15) = v17.i32[0] | (v17.i32[1] << 8);
      *(uint32x2_t *)v17.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), (uint32x2_t)0x1800000010);
      *(_DWORD *)(result + v6) = v15 | v17.i32[0] | v17.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float4_to_char4n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x42FF0000u);
    v14.i64[0] = 0xFF000000FFLL;
    v14.i64[1] = 0xFF000000FFLL;
    do
    {
      int8x16_t v15 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32((float32x4_t)vandq_s8(_Q0, (int8x16_t)vcgezq_f32(*(float32x4_t *)(a3 + v5))), v13, *(float32x4_t *)(a3 + v5))), v14);
      __int32 v16 = v15.i32[0] | (v15.i32[1] << 8);
      *(uint32x2_t *)v15.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), (uint32x2_t)0x1800000010);
      *(_DWORD *)(result + v6) = v16 | v15.i32[0] | v15.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float3_to_unorm10a2(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    do
    {
      uint64_t v8 = a3 + v5;
      v9.i64[0] = *(void *)v8;
      v9.i32[2] = *(_DWORD *)(v8 + 8);
      v9.i32[3] = 1.0;
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      int32x4_t v11 = vcvtq_s32_f32(vmlaq_f32(v10, (float32x4_t)xmmword_20B5CD4C0, v9));
      v10.i32[0] = vmovn_s32(v11).u32[0];
      *(uint32x2_t *)v11.i8 = vshl_u32((uint32x2_t)vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL), (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1E00000014);
      *(_DWORD *)(result + v6) = v10.u16[0] | (v10.u16[1] << 10) | v11.i32[0] | v11.i32[1];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float2_to_ushort2n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x2_t v8 = (float32x2_t)vdup_n_s32(0x46FFFE00u);
    do
    {
      float32x4_t v9 = (_WORD *)(result + v6);
      int32x2_t v10 = vcvt_s32_f32(vmul_f32(*(float32x2_t *)(a3 + v5), v8));
      _WORD *v9 = v10.i16[0];
      v9[1] = v10.i16[2];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_float2_to_short2n(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x2_t v8 = (float32x2_t)vdup_n_s32(0x46FFFE00u);
    do
    {
      float32x4_t v9 = (_WORD *)(result + v6);
      int32x2_t v10 = vcvt_s32_f32(vmul_f32(*(float32x2_t *)(a3 + v5), v8));
      _WORD *v9 = v10.i16[0];
      v9[1] = v10.i16[2];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_ushort2n_to_float2(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    int32x2_t v8 = vdup_n_s32(0x4B400000u);
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0xCB400000);
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x38000100u);
    do
    {
      int32x4_t v11 = (__int16 *)(a3 + v5);
      v12.i32[0] = *v11;
      v12.i32[1] = v11[1];
      *(float32x2_t *)(result + v6) = vmul_f32(vadd_f32((float32x2_t)vadd_s32(v12, v8), v9), v10);
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_short2n_to_float2(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    int32x2_t v8 = vdup_n_s32(0x4B400000u);
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0xCB400000);
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x38000100u);
    do
    {
      int32x4_t v11 = (__int16 *)(a3 + v5);
      v12.i32[0] = *v11;
      v12.i32[1] = v11[1];
      *(float32x2_t *)(result + v6) = vmul_f32(vadd_f32((float32x2_t)vadd_s32(v12, v8), v9), v10);
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_snorm10a2_to_float3(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x4_t v8 = (float32x4_t)vdupq_n_s32(0x3B004020u);
    do
    {
      float32x2_t v9 = (const float *)(a3 + v5);
      uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
      float32x4_t v11 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0)), v8);
      uint64_t v12 = result + v6;
      *(void *)uint64_t v12 = v11.i64[0];
      *(_DWORD *)(v12 + _Block_object_dispose(&STACK[0x2A0], 8) = v11.i32[2];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t C3DConvert_unorm10a2_to_float3(uint64_t result, int a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = a5;
    float32x4_t v8 = (float32x4_t)vdupq_n_s32(0x3A802008u);
    do
    {
      float32x2_t v9 = (const float *)(a3 + v5);
      uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
      float32x4_t v11 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0)), v8);
      uint64_t v12 = result + v6;
      *(void *)uint64_t v12 = v11.i64[0];
      *(_DWORD *)(v12 + _Block_object_dispose(&STACK[0x2A0], 8) = v11.i32[2];
      v6 += a2;
      v5 += a4;
      --v7;
    }
    while (v7);
  }
  return result;
}

void C3DConvert_uchar4n_to_float4()
{
  uint64_t v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    C3DConvert_uchar4n_to_float4_cold_1();
  }
}

void C3DConvert_char4n_to_float4()
{
  uint64_t v0 = scn_default_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    C3DConvert_uchar4n_to_float4_cold_1();
  }
}

uint64_t C3DConvertIsConvertible(unsigned int a1, unsigned int a2)
{
  if (C3DBaseTypeIsFloatingValue(a1)) {
    IsFloatingunsigned int Value = C3DBaseTypeIsFloatingValue(a2);
  }
  else {
    IsFloatingunsigned int Value = 0;
  }
  if (C3DConvertGetConverter(a1, a2)) {
    return 1;
  }
  else {
    return IsFloatingValue;
  }
}

void C3DConvertBatch(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unsigned __int16 v4 = a4;
  unsigned __int16 v6 = a2;
  unint64_t v8 = a2 >> 16;
  unint64_t v9 = HIDWORD(a2);
  unint64_t v10 = a4 >> 16;
  if (HIDWORD(a2) != HIDWORD(a4))
  {
    float32x4_t v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      C3DConvertBatch_cold_1(v11);
    }
  }
  unsigned int v12 = (__int16)v8;
  int v13 = (__int16)v10;
  Converter = C3DConvertGetConverter(v12, (__int16)v10);
  if (Converter)
  {
    Converter(a1, v6, a3, v4, v9);
  }
  else if (C3DBaseTypeIsFloatingValue(v12) {
         && C3DBaseTypeIsFloatingValue((__int16)v10)
  }
         && v9)
  {
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    do
    {
      *(double *)v20.i64 = C3DConvertFloatingTypeToFloat4(v13, (float *)(a3 + v18), v15, v16, v17);
      C3DConvertFloatingTypeFromFloat4(v12, a1 + v19, v20);
      v19 += v6;
      v18 += v4;
      --v9;
    }
    while (v9);
  }
}

double C3DConvertFloatingTypeToFloat4(int a1, float *a2, float32x4_t a3, float a4, float a5)
{
  __int16 v5 = a1;
  switch(a1)
  {
    case 1:
    case 7:
      a3.f32[0] = *a2;
      return *(double *)a3.i64;
    case 8:
      a3.i64[0] = *(void *)a2;
      return *(double *)a3.i64;
    case 9:
      a3.i64[0] = *(void *)a2;
      return *(double *)a3.i64;
    case 10:
      a3 = *(float32x4_t *)a2;
      return *(double *)a3.i64;
    case 15:
      unsigned int v8 = *(unsigned __int16 *)a2;
      int v9 = (v8 >> 10) & 0x1F;
      if (v9 == 31) {
        int v10 = 2139095040;
      }
      else {
        int v10 = (v8 >> 10) & 0x1F;
      }
      if (v9) {
        _ZF = v9 == 31;
      }
      else {
        _ZF = 1;
      }
      if (_ZF) {
        int v12 = v10;
      }
      else {
        int v12 = (v9 << 23) + 939524096;
      }
      LODWORD(v13) = v12 | (v8 << 16) & 0x80000000 | (v8 >> 7) & 7 | (8 * (v8 & 0x3FF)) & 0x1FFF | ((v8 & 0x3FF) << 13);
      goto LABEL_28;
    case 23:
      uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(a2);
      a3 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0));
      float32x4_t v15 = (float32x4_t)xmmword_20B5CD4F0;
      goto LABEL_34;
    case 24:
      uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(a2);
      a3 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0));
      float32x4_t v15 = (float32x4_t)xmmword_20B5CD4E0;
      goto LABEL_34;
    case 27:
      uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(a2);
      v18.i64[0] = 0xFF000000FFLL;
      v18.i64[1] = 0xFF000000FFLL;
      a3 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_20B5CCAD0), v18));
      unsigned int v19 = 998277249;
      goto LABEL_33;
    case 28:
      *(uint32x2_t *)v20.i8 = vshl_u32((uint32x2_t)vdup_n_s32(*(_DWORD *)a2), (uint32x2_t)0x1000000018);
      v20.i32[2] = *(_DWORD *)a2 << 8;
      v20.i32[3] = *(__int32 *)a2;
      __asm { FMOV            V1.4S, #-1.0 }
      a3 = vmaxnmq_f32(vmulq_f32(vcvtq_f32_s32(vshrq_n_s32(v20, 0x18uLL)), (float32x4_t)vdupq_n_s32(0x3C010204u)), _Q1);
      __asm { FMOV            V1.4S, #1.0 }
      a3.i64[0] = vminnmq_f32(a3, _Q1).u64[0];
      return *(double *)a3.i64;
    case 35:
      a3.i16[0] = *(_WORD *)a2;
      a3.f32[0] = (float)a3.u32[0];
      float v26 = 0.000015259;
      goto LABEL_27;
    case 36:
      a3.i16[0] = *(_WORD *)a2;
      v27.f32[0] = (float)a3.u32[0];
      LOWORD(a4) = *((_WORD *)a2 + 1);
      v27.f32[1] = (float)LODWORD(a4);
      *(float32x2_t *)a3.f32 = vmul_f32(v27, (float32x2_t)vdup_n_s32(0x37800080u));
      return *(double *)a3.i64;
    case 37:
      a3.i16[0] = *(_WORD *)a2;
      LOWORD(a4) = *((_WORD *)a2 + 1);
      LOWORD(a5) = *((_WORD *)a2 + 2);
      v28.f32[0] = (float)a3.u32[0];
      v28.f32[1] = (float)LODWORD(a4);
      v28.i64[1] = COERCE_UNSIGNED_INT((float)LODWORD(a5));
      a3.i64[0] = vmulq_f32(v28, (float32x4_t)vdupq_n_s32(0x37800080u)).u64[0];
      return *(double *)a3.i64;
    case 38:
      a3 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)a2));
      unsigned int v19 = 931135616;
      goto LABEL_33;
    case 39:
      a3.f32[0] = (float)*(__int16 *)a2;
      float v26 = 0.000030519;
LABEL_27:
      float v13 = a3.f32[0] * v26;
LABEL_28:
      a3.i64[0] = LODWORD(v13);
      return *(double *)a3.i64;
    case 40:
      v29.i32[0] = *(__int16 *)a2;
      v29.i32[1] = *((__int16 *)a2 + 1);
      *(float32x2_t *)a3.f32 = vmul_f32(vadd_f32((float32x2_t)vadd_s32(v29, vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x38000100u));
      return *(double *)a3.i64;
    case 41:
      v30.i32[0] = *(__int32 *)a2;
      v30.i32[1] = *((unsigned __int16 *)a2 + 2);
      float32x4_t v31 = (float32x4_t)vdupq_n_s32(0xCB400000);
      float32x4_t v32 = (float32x4_t)vaddw_s16(vdupq_n_s32(0x4B400000u), v30);
      goto LABEL_32;
    case 42:
      float32x4_t v31 = (float32x4_t)vdupq_n_s32(0xCB400000);
      float32x4_t v32 = (float32x4_t)vaddw_s16(vdupq_n_s32(0x4B400000u), *(int16x4_t *)a2);
LABEL_32:
      a3 = vaddq_f32(v32, v31);
      unsigned int v19 = 939524352;
LABEL_33:
      float32x4_t v15 = (float32x4_t)vdupq_n_s32(v19);
LABEL_34:
      a3.i64[0] = vmulq_f32(a3, v15).u64[0];
      break;
    case 43:
      unsigned int v33 = *(unsigned __int16 *)a2;
      int v34 = (v33 >> 10) & 0x1F;
      if (v34 == 31) {
        int v35 = 2139095040;
      }
      else {
        int v35 = (v33 >> 10) & 0x1F;
      }
      if (v34) {
        BOOL v36 = v34 == 31;
      }
      else {
        BOOL v36 = 1;
      }
      if (v36) {
        int v37 = v35;
      }
      else {
        int v37 = (v34 << 23) + 939524096;
      }
      unsigned int v38 = *((unsigned __int16 *)a2 + 1);
      int v39 = (v38 >> 10) & 0x1F;
      if (v39 == 31) {
        int v40 = 2139095040;
      }
      else {
        int v40 = (v38 >> 10) & 0x1F;
      }
      if (v39) {
        BOOL v41 = v39 == 31;
      }
      else {
        BOOL v41 = 1;
      }
      if (!v41) {
        int v40 = (v39 << 23) + 939524096;
      }
      v42.i32[0] = v33 & 0x3FF;
      v42.i32[1] = v38 & 0xFFFF03FF;
      *(int8x8_t *)a3.f32 = vorr_s8((int8x8_t)__PAIR64__(v40, v37), vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32((int32x2_t)__PAIR64__(v38, v33), 0x10uLL), (int8x8_t)0x8000000080000000), (int8x8_t)vshr_n_u32(v42, 7uLL)), (int8x8_t)vmul_s32((int32x2_t)v42, vdup_n_s32(0x2008u))));
      break;
    case 44:
      unsigned int v43 = *(unsigned __int16 *)a2;
      int v44 = (v43 >> 10) & 0x1F;
      if (v44 == 31) {
        int v45 = 2139095040;
      }
      else {
        int v45 = (v43 >> 10) & 0x1F;
      }
      if (v44) {
        BOOL v46 = v44 == 31;
      }
      else {
        BOOL v46 = 1;
      }
      if (!v46) {
        int v45 = (v44 << 23) + 939524096;
      }
      unsigned int v47 = *((unsigned __int16 *)a2 + 1);
      int v48 = (v47 >> 10) & 0x1F;
      if (v48 == 31) {
        int v49 = 2139095040;
      }
      else {
        int v49 = (v47 >> 10) & 0x1F;
      }
      int v50 = (v48 << 23) + 939524096;
      if (v48) {
        BOOL v51 = v48 == 31;
      }
      else {
        BOOL v51 = 1;
      }
      if (v51) {
        int v50 = v49;
      }
      v52.i32[0] = v43 & 0x3FF;
      v52.i32[1] = v47 & 0xFFFF03FF;
      *(int8x8_t *)a3.f32 = vorr_s8((int8x8_t)__PAIR64__(v50, v45), vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32((int32x2_t)__PAIR64__(v47, v43), 0x10uLL), (int8x8_t)0x8000000080000000), (int8x8_t)vshr_n_u32(v52, 7uLL)), (int8x8_t)vmul_s32((int32x2_t)v52, vdup_n_s32(0x2008u))));
      break;
    case 45:
      *(double *)a3.i64 = unpack_half4_to_float((int16x4_t *)a2);
      break;
    default:
      unsigned __int16 v6 = scn_default_log();
      BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      a3.i64[0] = 0;
      if (v7)
      {
        C3DConvertFloatingTypeToFloat4_cold_1(v5);
        a3.i64[0] = 0;
      }
      break;
  }
  return *(double *)a3.i64;
}

void C3DConvertFloatingTypeFromFloat4(int a1, uint64_t a2, float32x4_t a3)
{
  __int16 v3 = a1;
  switch(a1)
  {
    case 1:
    case 7:
      *(_DWORD *)a2 = a3.i32[0];
      return;
    case 8:
      *(void *)a2 = a3.i64[0];
      return;
    case 9:
      *(void *)a2 = a3.i64[0];
      *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x2A0], 8) = a3.i32[2];
      return;
    case 10:
      *(float32x4_t *)a2 = a3;
      return;
    case 15:
      unsigned __int32 v5 = HIWORD(a3.i32[0]) & 0x8000;
      unsigned int v6 = ((unsigned __int32)a3.i32[0] >> 23);
      unsigned int v7 = v6 - 112;
      unsigned int v8 = v6 - 113;
      __int16 v9 = v5 | 0x7BFF;
      if (v6 == 255) {
        __int16 v9 = v5 | ((a3.i32[0] & 0x7FFFFF) != 0) | 0x7C00;
      }
      if (v6 >= 0x71) {
        __int16 v10 = v9;
      }
      else {
        __int16 v10 = a3.i16[1] & 0x8000;
      }
      unsigned __int32 v11 = HIWORD(a3.i32[0]) & 0x8000 | ((unsigned __int32)a3.i32[0] >> 13) & 0x3FF | (v7 << 10);
      if (v8 > 0x1D) {
        LOWORD(v11) = v10;
      }
      goto LABEL_28;
    case 23:
      __asm { FMOV            V1.4S, #-1.0; jumptable 000000020B358F00 case 23 }
      float32x4_t v17 = vmaxnmq_f32(a3, _Q1);
      __asm { FMOV            V1.4S, #1.0 }
      int8x16_t v19 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmulq_f32(vminnmq_f32(v17, _Q1), (float32x4_t)xmmword_20B5CD4A0)), (int8x16_t)xmmword_20B5CD4B0);
      uint32x2_t v20 = (uint32x2_t)vextq_s8(v19, v19, 8uLL).u64[0];
      int v21 = v19.i32[0] | (v19.i32[1] << 10);
      uint32x2_t v22 = (uint32x2_t)0x1E00000014;
      goto LABEL_21;
    case 24:
      v23.i64[0] = 0x3F0000003F000000;
      v23.i64[1] = 0x3F0000003F000000;
      int32x4_t v24 = vcvtq_s32_f32(vmlaq_f32(v23, (float32x4_t)xmmword_20B5CD4C0, a3));
      unsigned __int32 v25 = vmovn_s32(v24).u32[0];
      int v21 = (unsigned __int16)v25 | (HIWORD(v25) << 10);
      uint32x2_t v26 = vshl_u32((uint32x2_t)vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1E00000014);
      goto LABEL_22;
    case 27:
      v27.i64[0] = 0x3F0000003F000000;
      v27.i64[1] = 0x3F0000003F000000;
      int8x16_t v28 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32(v27, (float32x4_t)vdupq_n_s32(0x437F0000u), a3));
      goto LABEL_20;
    case 28:
      __asm { FMOV            V2.4S, #-1.0 }
      int8x16_t v28 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32((float32x4_t)vandq_s8(_Q2, (int8x16_t)vcgezq_f32(a3)), (float32x4_t)vdupq_n_s32(0x42FF0000u), a3));
LABEL_20:
      v30.i64[0] = 0xFF000000FFLL;
      v30.i64[1] = 0xFF000000FFLL;
      int8x16_t v31 = vandq_s8(v28, v30);
      uint32x2_t v20 = (uint32x2_t)vextq_s8(v31, v31, 8uLL).u64[0];
      int v21 = v31.i32[0] | (v31.i32[1] << 8);
      uint32x2_t v22 = (uint32x2_t)0x1800000010;
LABEL_21:
      uint32x2_t v26 = vshl_u32(v20, v22);
LABEL_22:
      *(_DWORD *)a2 = v21 | v26.i32[0] | v26.i32[1];
      return;
    case 35:
      unsigned __int32 v11 = (int)vmla_n_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)vdup_n_s32(0x477FFF00u), a3.f32[0]).f32[0];
      goto LABEL_28;
    case 36:
      int32x2_t v32 = vcvt_s32_f32(vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)vdup_n_s32(0x477FFF00u), *(float32x2_t *)a3.f32));
      LOWORD(v33) = v32.i16[2];
      *(_WORD *)a2 = v32.i16[0];
      goto LABEL_57;
    case 37:
      v34.i64[0] = 0x3F0000003F000000;
      v34.i64[1] = 0x3F0000003F000000;
      int32x4_t v35 = vcvtq_s32_f32(vmlaq_f32(v34, (float32x4_t)vdupq_n_s32(0x477FFF00u), a3));
      goto LABEL_31;
    case 38:
      v36.i64[0] = 0x3F0000003F000000;
      v36.i64[1] = 0x3F0000003F000000;
      int32x4_t v37 = vcvtq_s32_f32(vmlaq_f32(v36, (float32x4_t)vdupq_n_s32(0x477FFF00u), a3));
      goto LABEL_33;
    case 39:
      unsigned __int32 v11 = (int)(float)(32767.0 * a3.f32[0]);
LABEL_28:
      *(_WORD *)a2 = v11;
      break;
    case 40:
      int32x2_t v38 = vcvt_s32_f32(vmul_f32(*(float32x2_t *)a3.f32, (float32x2_t)vdup_n_s32(0x46FFFE00u)));
      *(_WORD *)a2 = v38.i16[0];
      *(_WORD *)(a2 + 2) = v38.i16[2];
      break;
    case 41:
      int32x4_t v35 = vcvtq_s32_f32(vmulq_f32(a3, (float32x4_t)vdupq_n_s32(0x46FFFE00u)));
LABEL_31:
      int16x4_t v39 = vmovn_s32(v35);
      *(_DWORD *)a2 = v39.i32[0];
      *(_WORD *)(a2 + 4) = v39.i16[2];
      break;
    case 42:
      int32x4_t v37 = vcvtq_s32_f32(vmulq_f32(a3, (float32x4_t)vdupq_n_s32(0x46FFFE00u)));
LABEL_33:
      *(int16x4_t *)a2 = vmovn_s32(v37);
      break;
    case 43:
      unsigned __int32 v40 = HIWORD(a3.i32[0]) & 0x8000;
      unsigned int v41 = ((unsigned __int32)a3.i32[0] >> 23);
      if (v41 - 113 > 0x1D)
      {
        if (v41 >= 0x71)
        {
          if (v41 == 255) {
            LOWORD(v40) = a3.i16[1] & 0x8000 | ((a3.i32[0] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v40) = v40 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v40 = HIWORD(a3.i32[0]) & 0x8000 | ((unsigned __int32)a3.i32[0] >> 13) & 0x3FF | ((v41 - 112) << 10);
      }
      *(_WORD *)a2 = v40;
      unsigned __int32 v46 = HIWORD(a3.i32[1]) & 0x8000;
      unsigned int v47 = ((unsigned __int32)a3.i32[1] >> 23);
      unsigned int v48 = v47 - 112;
      unsigned int v49 = v47 - 113;
      __int16 v50 = v46 | 0x7BFF;
      if (v47 == 255) {
        __int16 v50 = v46 | ((a3.i32[1] & 0x7FFFFF) != 0) | 0x7C00;
      }
      if (v47 >= 0x71) {
        __int16 v51 = v50;
      }
      else {
        __int16 v51 = a3.i16[3] & 0x8000;
      }
      unsigned __int32 v33 = HIWORD(a3.i32[1]) & 0x8000 | ((unsigned __int32)a3.i32[1] >> 13) & 0x3FF | (v48 << 10);
      if (v49 > 0x1D) {
        LOWORD(v33) = v51;
      }
LABEL_57:
      *(_WORD *)(a2 + 2) = v33;
      break;
    case 44:
      unsigned __int32 v42 = HIWORD(a3.i32[0]) & 0x8000;
      unsigned int v43 = ((unsigned __int32)a3.i32[0] >> 23);
      if (v43 - 113 > 0x1D)
      {
        if (v43 >= 0x71)
        {
          if (v43 == 255) {
            LOWORD(v42) = a3.i16[1] & 0x8000 | ((a3.i32[0] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v42) = v42 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v42 = HIWORD(a3.i32[0]) & 0x8000 | ((unsigned __int32)a3.i32[0] >> 13) & 0x3FF | ((v43 - 112) << 10);
      }
      *(_WORD *)a2 = v42;
      unsigned __int32 v52 = HIWORD(a3.i32[1]) & 0x8000;
      unsigned int v53 = ((unsigned __int32)a3.i32[1] >> 23);
      unsigned int v54 = v53 - 112;
      unsigned int v55 = v53 - 113;
      __int16 v56 = v52 | 0x7BFF;
      if (v53 == 255) {
        __int16 v56 = v52 | ((a3.i32[1] & 0x7FFFFF) != 0) | 0x7C00;
      }
      if (v53 >= 0x71) {
        __int16 v57 = v56;
      }
      else {
        __int16 v57 = a3.i16[3] & 0x8000;
      }
      unsigned __int32 v58 = HIWORD(a3.i32[1]) & 0x8000 | ((unsigned __int32)a3.i32[1] >> 13) & 0x3FF | (v54 << 10);
      if (v55 > 0x1D) {
        LOWORD(v5_Block_object_dispose(&STACK[0x2A0], 8) = v57;
      }
      *(_WORD *)(a2 + 2) = v58;
      unsigned __int32 v59 = HIWORD(a3.i32[2]) & 0x8000;
      unsigned int v60 = ((unsigned __int32)a3.i32[2] >> 23);
      unsigned int v61 = v60 - 112;
      unsigned int v62 = v60 - 113;
      __int16 v63 = v59 | 0x7BFF;
      if (v60 == 255) {
        __int16 v63 = v59 | ((a3.i32[2] & 0x7FFFFF) != 0) | 0x7C00;
      }
      if (v60 >= 0x71) {
        __int16 v64 = v63;
      }
      else {
        __int16 v64 = a3.i16[5] & 0x8000;
      }
      unsigned __int32 v65 = HIWORD(a3.i32[2]) & 0x8000 | ((unsigned __int32)a3.i32[2] >> 13) & 0x3FF | (v61 << 10);
      if (v62 > 0x1D) {
        LOWORD(v65) = v64;
      }
      *(_WORD *)(a2 + 4) = v65;
      break;
    case 45:
      unsigned __int32 v44 = HIWORD(a3.i32[0]) & 0x8000;
      unsigned int v45 = ((unsigned __int32)a3.i32[0] >> 23);
      if (v45 - 113 > 0x1D)
      {
        if (v45 >= 0x71)
        {
          if (v45 == 255) {
            LOWORD(v44) = a3.i16[1] & 0x8000 | ((a3.i32[0] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v44) = v44 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v44 = HIWORD(a3.i32[0]) & 0x8000 | ((unsigned __int32)a3.i32[0] >> 13) & 0x3FF | ((v45 - 112) << 10);
      }
      *(_WORD *)a2 = v44;
      unsigned __int32 v66 = HIWORD(a3.i32[1]) & 0x8000;
      unsigned int v67 = ((unsigned __int32)a3.i32[1] >> 23);
      if (v67 - 113 > 0x1D)
      {
        if (v67 >= 0x71)
        {
          if (v67 == 255) {
            LOWORD(v66) = a3.i16[3] & 0x8000 | ((a3.i32[1] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v66) = v66 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v66 = HIWORD(a3.i32[1]) & 0x8000 | ((unsigned __int32)a3.i32[1] >> 13) & 0x3FF | ((v67 - 112) << 10);
      }
      *(_WORD *)(a2 + 2) = v66;
      unsigned __int32 v68 = HIWORD(a3.i32[2]) & 0x8000;
      unsigned int v69 = ((unsigned __int32)a3.i32[2] >> 23);
      if (v69 - 113 > 0x1D)
      {
        if (v69 >= 0x71)
        {
          if (v69 == 255) {
            LOWORD(v6_Block_object_dispose(&STACK[0x2A0], 8) = a3.i16[5] & 0x8000 | ((a3.i32[2] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v6_Block_object_dispose(&STACK[0x2A0], 8) = v68 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v68 = HIWORD(a3.i32[2]) & 0x8000 | ((unsigned __int32)a3.i32[2] >> 13) & 0x3FF | ((v69 - 112) << 10);
      }
      *(_WORD *)(a2 + 4) = v68;
      unsigned __int32 v70 = HIWORD(a3.i32[3]) & 0x8000;
      unsigned int v71 = ((unsigned __int32)a3.i32[3] >> 23);
      if (v71 - 113 > 0x1D)
      {
        if (v71 >= 0x71)
        {
          if (v71 == 255) {
            LOWORD(v70) = a3.i16[7] & 0x8000 | ((a3.i32[3] & 0x7FFFFF) != 0) | 0x7C00;
          }
          else {
            LOWORD(v70) = v70 | 0x7BFF;
          }
        }
      }
      else
      {
        unsigned __int32 v70 = HIWORD(a3.i32[3]) & 0x8000 | ((unsigned __int32)a3.i32[3] >> 13) & 0x3FF | ((v71 - 112) << 10);
      }
      *(_WORD *)(a2 + 6) = v70;
      break;
    default:
      unsigned __int16 v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        C3DConvertFloatingTypeToFloat4_cold_1(v3);
      }
      break;
  }
}

double unpack_half4_to_float(int16x4_t *a1)
{
  unsigned int v1 = a1->u16[0];
  int v2 = (v1 >> 10) & 0x1F;
  if (v2 == 31) {
    int v3 = 2139095040;
  }
  else {
    int v3 = (v1 >> 10) & 0x1F;
  }
  if (v2) {
    BOOL v4 = v2 == 31;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    int v5 = v3;
  }
  else {
    int v5 = (v2 << 23) + 939524096;
  }
  unsigned int v6 = a1->u16[1];
  int v7 = (v6 >> 10) & 0x1F;
  if (v7 == 31) {
    int v8 = 2139095040;
  }
  else {
    int v8 = (v6 >> 10) & 0x1F;
  }
  if (v7) {
    BOOL v9 = v7 == 31;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int v10 = v8;
  }
  else {
    int v10 = (v7 << 23) + 939524096;
  }
  unsigned int v11 = a1->u16[2];
  int v12 = (v11 >> 10) & 0x1F;
  if (v12 && v12 != 31)
  {
    int v13 = (v12 << 23) + 939524096;
  }
  else if (v12 == 31)
  {
    int v13 = 2139095040;
  }
  else
  {
    int v13 = (v11 >> 10) & 0x1F;
  }
  unsigned int v14 = a1->u16[3];
  int v15 = (v14 >> 10) & 0x1F;
  if (v15 && v15 != 31)
  {
    int v15 = (v15 << 23) + 939524096;
  }
  else if (v15 == 31)
  {
    int v15 = 2139095040;
  }
  v16.i32[0] = v1 & 0x3FF;
  v16.i32[1] = v6 & 0xFFFF03FF;
  v16.i32[2] = v11 & 0xFFFF03FF;
  v16.i32[3] = v14 & 0xFFFF03FF;
  v17.i64[0] = 0x8000000080000000;
  v17.i64[1] = 0x8000000080000000;
  v18.i64[0] = __PAIR64__(v10, v5);
  v18.i64[1] = __PAIR64__(v15, v13);
  *(void *)&double result = vorrq_s8(vorrq_s8(v18, vorrq_s8(vandq_s8((int8x16_t)vmovl_s16(*a1), v17), (int8x16_t)vshrq_n_u32(v16, 7uLL))), (int8x16_t)vmull_u16((uint16x4_t)vmovn_s32((int32x4_t)v16), (uint16x4_t)vdup_n_s16(0x2008u))).u64[0];
  return result;
}

double (*C3DConvertGetReadToFloat4Function(int a1))()
{
  if (a1 >= 46)
  {
    int v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DConvertGetReadToFloat4Function_cold_2(v2);
    }
  }
  uint64_t v3 = a1 - 1;
  if v3 < 0x2D && ((0x1FFC0CC043C1uLL >> v3)) {
    return (double (*)())off_26BF71C98[v3];
  }
  BOOL v4 = scn_default_log();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
    C3DConvertFloatingTypeToFloat4_cold_1(a1);
  }
  return scn_read_from_none;
}

float scn_read_from_float(uint64_t a1)
{
  return *(float *)a1;
}

float scn_read_from_C3DFloat(uint64_t a1)
{
  return *(float *)a1;
}

double scn_read_from_float2(uint64_t a1)
{
  return *(double *)a1;
}

double scn_read_from_float3(uint64_t a1)
{
  return *(double *)a1;
}

__n128 scn_read_from_float4(uint64_t a1)
{
  return *(__n128 *)a1;
}

double scn_read_from_char4n(unsigned int *a1)
{
  *(uint32x2_t *)v1.i8 = vshl_u32((uint32x2_t)vdup_n_s32(*a1), (uint32x2_t)0x1000000018);
  v1.i32[2] = *a1 << 8;
  v1.i32[3] = *a1;
  __asm { FMOV            V1.4S, #-1.0 }
  float32x4_t v7 = vmaxnmq_f32(vmulq_f32(vcvtq_f32_s32(vshrq_n_s32(v1, 0x18uLL)), (float32x4_t)vdupq_n_s32(0x3C010204u)), _Q1);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v7, _Q1).u64[0];
  return result;
}

double scn_read_from_uchar4n(const float *a1)
{
  uint32x4_t v1 = (uint32x4_t)vld1q_dup_f32(a1);
  v2.i64[0] = 0xFF000000FFLL;
  v2.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v1, (uint32x4_t)xmmword_20B5CCAD0), v2)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double scn_read_from_snorm10a2(const float *a1)
{
  uint32x4_t v1 = (uint32x4_t)vld1q_dup_f32(a1);
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v1, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0)), (float32x4_t)xmmword_20B5CD4F0).u64[0];
  return result;
}

double scn_read_from_unorm10a2(const float *a1)
{
  uint32x4_t v1 = (uint32x4_t)vld1q_dup_f32(a1);
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v1, (uint32x4_t)xmmword_20B5CD4D0), (int8x16_t)xmmword_20B5CD4B0)), (float32x4_t)xmmword_20B5CD4E0).u64[0];
  return result;
}

float scn_read_from_ushortn(_WORD *a1, float a2)
{
  LOWORD(a2) = *a1;
  return (float)LODWORD(a2) * 0.000015259;
}

float32x2_t scn_read_from_ushort2n(_WORD *a1, float a2, float a3)
{
  LOWORD(a2) = *a1;
  v3.f32[0] = (float)LODWORD(a2);
  LOWORD(a3) = a1[1];
  v3.f32[1] = (float)LODWORD(a3);
  return vmul_f32(v3, (float32x2_t)vdup_n_s32(0x37800080u));
}

double scn_read_from_ushort3n(_WORD *a1, float a2, float a3, float a4)
{
  LOWORD(a2) = *a1;
  LOWORD(a3) = a1[1];
  LOWORD(a4) = a1[2];
  v4.f32[0] = (float)LODWORD(a2);
  v4.f32[1] = (float)LODWORD(a3);
  v4.i64[1] = COERCE_UNSIGNED_INT((float)LODWORD(a4));
  *(void *)&double result = vmulq_f32(v4, (float32x4_t)vdupq_n_s32(0x37800080u)).u64[0];
  return result;
}

double scn_read_from_ushort4n(uint16x4_t *a1)
{
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*a1)), (float32x4_t)vdupq_n_s32(0x37800080u)).u64[0];
  return result;
}

float scn_read_from_shortn(__int16 *a1)
{
  return (float)*a1 * 0.000030519;
}

float32x2_t scn_read_from_short2n(__int16 *a1)
{
  v1.i32[0] = *a1;
  v1.i32[1] = a1[1];
  return vmul_f32(vadd_f32((float32x2_t)vadd_s32(v1, vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x38000100u));
}

double scn_read_from_short3n(uint64_t a1)
{
  v1.i32[0] = *(_DWORD *)a1;
  v1.i32[1] = *(unsigned __int16 *)(a1 + 4);
  *(void *)&double result = vmulq_f32(vaddq_f32((float32x4_t)vaddw_s16(vdupq_n_s32(0x4B400000u), v1), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x38000100u)).u64[0];
  return result;
}

double scn_read_from_short4n(int16x4_t *a1)
{
  *(void *)&double result = vmulq_f32(vaddq_f32((float32x4_t)vaddw_s16(vdupq_n_s32(0x4B400000u), *a1), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x38000100u)).u64[0];
  return result;
}

float scn_read_from_half1(unsigned __int16 *a1)
{
  unsigned int v1 = *a1;
  int v2 = (v1 >> 10) & 0x1F;
  if (v2 == 31) {
    int v3 = 2139095040;
  }
  else {
    int v3 = (v1 >> 10) & 0x1F;
  }
  if (v2) {
    BOOL v4 = v2 == 31;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    int v5 = v3;
  }
  else {
    int v5 = (v2 << 23) + 939524096;
  }
  LODWORD(result) = v5 | (v1 << 16) & 0x80000000 | (v1 >> 7) & 7 | (8 * (v1 & 0x3FF)) & 0x1FFF | ((v1 & 0x3FF) << 13);
  return result;
}

int8x8_t scn_read_from_half2(unsigned __int16 *a1)
{
  unsigned int v1 = *a1;
  int v2 = (v1 >> 10) & 0x1F;
  if (v2 == 31) {
    int v3 = 2139095040;
  }
  else {
    int v3 = (v1 >> 10) & 0x1F;
  }
  if (v2) {
    BOOL v4 = v2 == 31;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    int v5 = v3;
  }
  else {
    int v5 = (v2 << 23) + 939524096;
  }
  unsigned int v6 = a1[1];
  int v7 = (v6 >> 10) & 0x1F;
  if (v7 == 31) {
    int v8 = 2139095040;
  }
  else {
    int v8 = (v6 >> 10) & 0x1F;
  }
  if (v7) {
    BOOL v9 = v7 == 31;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    int v8 = (v7 << 23) + 939524096;
  }
  v10.i32[0] = v1 & 0x3FF;
  v10.i32[1] = v6 & 0xFFFF03FF;
  return vorr_s8((int8x8_t)__PAIR64__(v8, v5), vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32((int32x2_t)__PAIR64__(v6, v1), 0x10uLL), (int8x8_t)0x8000000080000000), (int8x8_t)vshr_n_u32(v10, 7uLL)), (int8x8_t)vmul_s32((int32x2_t)v10, vdup_n_s32(0x2008u))));
}

int8x8_t scn_read_from_half3(unsigned __int16 *a1)
{
  unsigned int v1 = *a1;
  int v2 = (v1 >> 10) & 0x1F;
  if (v2 == 31) {
    int v3 = 2139095040;
  }
  else {
    int v3 = (v1 >> 10) & 0x1F;
  }
  if (v2) {
    BOOL v4 = v2 == 31;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    int v3 = (v2 << 23) + 939524096;
  }
  unsigned int v5 = a1[1];
  int v6 = (v5 >> 10) & 0x1F;
  if (v6 == 31) {
    int v7 = 2139095040;
  }
  else {
    int v7 = (v5 >> 10) & 0x1F;
  }
  int v8 = (v6 << 23) + 939524096;
  if (v6) {
    BOOL v9 = v6 == 31;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int v8 = v7;
  }
  v10.i32[0] = v1 & 0x3FF;
  v10.i32[1] = v5 & 0xFFFF03FF;
  return vorr_s8((int8x8_t)__PAIR64__(v8, v3), vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32((int32x2_t)__PAIR64__(v5, v1), 0x10uLL), (int8x8_t)0x8000000080000000), (int8x8_t)vshr_n_u32(v10, 7uLL)), (int8x8_t)vmul_s32((int32x2_t)v10, vdup_n_s32(0x2008u))));
}

double scn_read_from_none()
{
  return 0.0;
}

void sub_20B35A17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20B35A9D8(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
}

void _C3DFramebufferCFFinalize(uint64_t a1)
{
  C3DFramebufferCleanup(a1);
  CFRelease(*(CFTypeRef *)(a1 + 24));
  int v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

CFStringRef _C3DFramebufferCFCopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  if (*(void *)(a1 + 32))
  {
    int v3 = 0;
    do
    {
      unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v3);
      if (Value) {
        CFStringAppendFormat(Mutable, 0, @"slot%d: %@ ", v3, Value);
      }
      ++v3;
    }
    while (v3 != (char *)6);
  }
  CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
  int v6 = C3DRenderBufferFormatToString(*(unsigned __int8 *)(a1 + 48));
  int v7 = C3DRenderBufferFormatToString(*(unsigned __int8 *)(a1 + 112));
  CFStringRef v8 = CFStringCreateWithFormat(v5, 0, @"<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>", a1, v6, v7, *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 113), Mutable);
  CFRelease(Mutable);
  return v8;
}

uint64_t __C3DFramebufferGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFramebufferGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DFramebufferCreate()
{
  if (C3DFramebufferGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFramebufferGetTypeID_onceToken, &__block_literal_global_39);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFramebufferGetTypeID_typeID, 0x80uLL);
  if (Instance)
  {
    *(void *)(Instance + 24) = CFDictionaryCreateMutable(0, 0, 0, 0);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 6, 0, MEMORY[0x263EFFF90]);
    uint64_t v2 = 0;
    *(void *)(Instance + 32) = Mutable;
    *(unsigned char *)(Instance + 120) = *(unsigned char *)(Instance + 120) & 0xF8 | 1;
    do
    {
      *(unsigned char *)(Instance + 49 + v2) = 1;
      v2 += 8;
    }
    while (v2 != 64);
    *(unsigned char *)(Instance + 113) = 1;
  }
  return Instance;
}

void C3DFramebufferSetFBO(uint64_t a1, int a2)
{
  if (!a1)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 16) = a2;
}

uint64_t C3DFramebufferGetFBO(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 16);
}

void C3DFramebufferAddRenderTarget(uint64_t a1, _DWORD *value, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  ++value[18];
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), (const void *)a3, value);
}

double C3DFramebufferGetSize(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 40);
}

void C3DFramebufferSetSize(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 40) = a2;
}

void C3DFramebufferCleanup(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  C3DFramebufferApplyToRenderTargets(a1, &__block_literal_global_6_0);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
  *(unsigned char *)(a1 + 128) |= 2u;
}

void C3DFramebufferApplyToRenderTargets(uint64_t a1, void *context)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)_applyToRenderTargets, context);
}

void __C3DFramebufferCleanup_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 72))
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      __C3DFramebufferCleanup_block_invoke_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  --*(_DWORD *)(a2 + 72);
}

void C3DFramebufferDescriptionSetSampleCount(uint64_t a1, unsigned int a2)
{
  *(void *)&void v24[5] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferDescriptionSetSampleCount_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2 >= 2)
  {
    if (*(unsigned char *)(a1 + 75))
    {
      uint64_t v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
        C3DFramebufferDescriptionSetSampleCount_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
      }
    }
    for (uint64_t i = 0; i != 64; i += 8)
    {
      if (*(unsigned char *)(a1 + 11 + i))
      {
        int v21 = scn_default_log();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          C3DFramebufferDescriptionSetSampleCount_cold_1(v23, v24, v21);
        }
      }
    }
  }
  uint64_t v22 = 0;
  *(unsigned char *)(a1 + 73) = a2;
  do
  {
    *(unsigned char *)(a1 + 9 + v22) = a2;
    v22 += 8;
  }
  while (v22 != 64);
}

void C3DFramebufferDescriptionSetViewportDependant(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferDescriptionSetSampleCount_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t v12 = 0;
  if (a2) {
    char v13 = 8;
  }
  else {
    char v13 = 0;
  }
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a1 + 80) & 0xF7 | v13;
  if (a2) {
    char v14 = 4;
  }
  else {
    char v14 = 0;
  }
  do
  {
    *(unsigned char *)(a1 + 11 + v12) = *(unsigned char *)(a1 + 11 + v12) & 0xFB | v14;
    v12 += 8;
  }
  while (v12 != 64);
  *(unsigned char *)(a1 + 75) = *(unsigned char *)(a1 + 75) & 0xFB | v14;
}

void C3DFramebufferSetSampleCount(uint64_t a1, unsigned int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  C3DFramebufferDescriptionSetSampleCount(a1 + 40, a2);
}

uint64_t C3DFramebufferGetSampleCount(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 49);
}

void C3DFramebufferAddRenderTargetDescription(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  char v14 = (const void *)C3DSceneSourcePerformConsistencyCheck(a3);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)a2, v14);
}

uint64_t C3DFramebufferGetRenderTargetDescriptions(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

const void *C3DFramebufferGetRenderTarget(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), (const void *)a2);
}

const void *C3DFramebufferGetTextureWithSlot(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFramebufferSetFBO_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = C3DFramebufferGetRenderTarget(a1, a2);
  if (result) {
    return (const void *)C3DRenderTargetGetTexture((uint64_t)result);
  }
  return result;
}

uint64_t _applyToRenderTargets(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t C3DRenderBufferFormatFromString()
{
  CFStringRef v0 = (const __CFString *)C3DStringLowercase();
  if (CFEqual(v0, @"rgba")) {
    return 2;
  }
  if (CFStringHasPrefix(v0, @"rgba"))
  {
    if (CFStringHasPrefix(v0, @"rgba8"))
    {
      if (CFEqual(v0, @"rgba8unorm") || CFEqual(v0, @"rgba8")) {
        return 28;
      }
      if (CFEqual(v0, @"rgba8snorm") || CFEqual(v0, @"rgba8s")) {
        return 29;
      }
      if (CFEqual(v0, @"rgba8uint") || CFEqual(v0, @"rgba8ui")) {
        return 30;
      }
      if (CFEqual(v0, @"rgba8sint") || CFEqual(v0, @"rgba8i")) {
        return 31;
      }
    }
    else if (CFStringHasPrefix(v0, @"rgba16"))
    {
      if (CFEqual(v0, @"rgba16unorm") || CFEqual(v0, @"rgba16")) {
        return 32;
      }
      if (CFEqual(v0, @"rgba16snorm") || CFEqual(v0, @"rgba16s")) {
        return 33;
      }
      if (CFEqual(v0, @"rgba16uint") || CFEqual(v0, @"rgba16ui")) {
        return 34;
      }
      if (CFEqual(v0, @"rgba16sint") || CFEqual(v0, @"rgba16i")) {
        return 35;
      }
      if (CFEqual(v0, @"rgba16float") || CFEqual(v0, @"rgba16f")) {
        return 36;
      }
    }
    else if (CFStringHasPrefix(v0, @"rgba32"))
    {
      if (CFEqual(v0, @"rgba32uint") || CFEqual(v0, @"rgba32ui")) {
        return 37;
      }
      if (CFEqual(v0, @"rgba32sint") || CFEqual(v0, @"rgba32i")) {
        return 38;
      }
      if (CFEqual(v0, @"rgba32float") || CFEqual(v0, @"rgba32f")) {
        return 39;
      }
    }
  }
  else if (CFStringHasPrefix(v0, @"rg"))
  {
    if (CFStringHasPrefix(v0, @"rg8"))
    {
      if (CFEqual(v0, @"rg8unorm") || CFEqual(v0, @"rg8")) {
        return 15;
      }
      if (CFEqual(v0, @"rg8snorm") || CFEqual(v0, @"rg8s")) {
        return 16;
      }
      if (CFEqual(v0, @"rg8uint") || CFEqual(v0, @"rg8ui")) {
        return 17;
      }
      if (CFEqual(v0, @"rg8sint") || CFEqual(v0, @"rg8i")) {
        return 18;
      }
    }
    else if (CFStringHasPrefix(v0, @"rg16"))
    {
      if (CFEqual(v0, @"rg16unorm") || CFEqual(v0, @"rg16")) {
        return 19;
      }
      if (CFEqual(v0, @"rg16snorm") || CFEqual(v0, @"rg16s")) {
        return 20;
      }
      if (CFEqual(v0, @"rg16uint") || CFEqual(v0, @"rg16ui")) {
        return 21;
      }
      if (CFEqual(v0, @"rg16sint") || CFEqual(v0, @"rg16i")) {
        return 22;
      }
      if (CFEqual(v0, @"rg16float") || CFEqual(v0, @"rg16f")) {
        return 23;
      }
    }
    else if (CFStringHasPrefix(v0, @"rg32"))
    {
      if (CFEqual(v0, @"rg32uint") || CFEqual(v0, @"rg32ui")) {
        return 24;
      }
      if (CFEqual(v0, @"rg32sint") || CFEqual(v0, @"rg32i")) {
        return 25;
      }
      if (CFEqual(v0, @"rg32float") || CFEqual(v0, @"rg32f")) {
        return 26;
      }
    }
  }
  else if (CFStringHasPrefix(v0, @"r"))
  {
    if (CFStringHasPrefix(v0, @"r8"))
    {
      if (CFEqual(v0, @"r8unorm") || CFEqual(v0, @"r8")) {
        return 3;
      }
      if (CFEqual(v0, @"r8snorm") || CFEqual(v0, @"r8s")) {
        return 4;
      }
      if (CFEqual(v0, @"r8uint") || CFEqual(v0, @"r8ui")) {
        return 5;
      }
      if (CFEqual(v0, @"r8sint") || CFEqual(v0, @"r8i")) {
        return 6;
      }
    }
    else if (CFStringHasPrefix(v0, @"r16"))
    {
      if (CFEqual(v0, @"r16unorm") || CFEqual(v0, @"r16")) {
        return 7;
      }
      if (CFEqual(v0, @"r16snorm") || CFEqual(v0, @"r16s")) {
        return 8;
      }
      if (CFEqual(v0, @"r16uint") || CFEqual(v0, @"r16ui")) {
        return 9;
      }
      if (CFEqual(v0, @"r16sint") || CFEqual(v0, @"r16i")) {
        return 10;
      }
      if (CFEqual(v0, @"r16float") || CFEqual(v0, @"r16f")) {
        return 11;
      }
    }
    else if (CFStringHasPrefix(v0, @"r32"))
    {
      if (CFEqual(v0, @"r32uint") || CFEqual(v0, @"r32ui")) {
        return 12;
      }
      if (CFEqual(v0, @"r32sint") || CFEqual(v0, @"r32i")) {
        return 13;
      }
      if (CFEqual(v0, @"r32float") || CFEqual(v0, @"r32f")) {
        return 14;
      }
    }
  }
  if (CFEqual(v0, @"bgra8unorm") || CFEqual(v0, @"bgra8")) {
    return 27;
  }
  if (!CFStringHasPrefix(v0, @"depth")) {
    goto LABEL_145;
  }
  if (CFEqual(v0, @"depth16unorm") || CFEqual(v0, @"depth16")) {
    return 40;
  }
  if (CFEqual(v0, @"depth24unorm") || CFEqual(v0, @"depth24")) {
    return 41;
  }
  if (CFEqual(v0, @"depth32float") || CFEqual(v0, @"depth32f")) {
    return 42;
  }
  if (CFEqual(v0, @"depth24unorm_stencil8")) {
    return 44;
  }
  if (CFEqual(v0, @"depth32float_stencil8")) {
    return 45;
  }
LABEL_145:
  if (CFEqual(v0, @"stencil8")) {
    return 43;
  }
  return 0;
}

__CFString *C3DRenderBufferFormatToString(int a1)
{
  if ((a1 - 1) > 0x2C) {
    return 0;
  }
  else {
    return off_264006A50[(char)(a1 - 1)];
  }
}

uint64_t SCNMTLRenderCommandEncoder::drawPrimitives(SCNMTLRenderCommandEncoder *this, MTLPrimitiveType a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  SCNMTLRenderCommandEncoder::_bindPendingTextures(this);
  SCNMTLRenderCommandEncoder::applyChangedStates(this);
  uint64_t var1_low = LODWORD(this->var14[0].var1);
  uint64_t v13 = var1_low * a6;
  char v14 = (void *)this->var24[1];
  if ((unint64_t)(var1_low * a5) <= 1 && v13 == 0)
  {
    return [v14 drawPrimitives:a2 vertexStart:a3 vertexCount:a4];
  }
  else if (v13)
  {
    return objc_msgSend(v14, "drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:", a2, a3, a4);
  }
  else
  {
    return objc_msgSend(v14, "drawPrimitives:vertexStart:vertexCount:instanceCount:", a2, a3, a4);
  }
}

__n128 __textureCoordinatesForCaptureDeviceImageProxy(__C3DImageProxy *a1, __n128 *a2)
{
  char v20 = 0;
  uint64x2_t v19 = 0uLL;
  C3DImageProxyGetCaptureDeviceInfo((uint64_t)a1, (uint64_t)&v20, (uint64_t)&v19.i64[1], (uint64_t)&v19);
  Interfaceint Orientation = C3DEngineContextGetInterfaceOrientation((uint64_t)a2);
  unsigned int v5 = InterfaceOrientation;
  if (!v20)
  {
    switch(InterfaceOrientation)
    {
      case 4u:
        _Q0.n128_u64[0] = 1065353216;
        goto LABEL_14;
      case 3u:
        _Q0.n128_u64[0] = 0x3F80000000000000;
LABEL_16:
        __n128 v18 = _Q0;
        __asm { FMOV            V0.2S, #1.0 }
        goto LABEL_19;
      case 2u:
        goto LABEL_11;
    }
LABEL_17:
    __asm { FMOV            V0.2S, #1.0 }
    goto LABEL_18;
  }
  if (InterfaceOrientation == 4) {
    goto LABEL_17;
  }
  if (InterfaceOrientation != 3)
  {
    if (InterfaceOrientation == 2)
    {
      _Q0.n128_u64[0] = 0x3F80000000000000;
LABEL_14:
      __n128 v18 = _Q0;
      __asm { FMOV            V0.2S, #1.0 }
      goto LABEL_19;
    }
    _Q0.n128_u64[0] = 1065353216;
    goto LABEL_16;
  }
LABEL_11:
  __asm { FMOV            V0.2S, #1.0 }
  _Q0.n128_u64[0] = 0;
LABEL_18:
  __n128 v18 = _Q0;
LABEL_19:
  __n128 Viewport = C3DEngineContextGetViewport(a2);
  Viewport.n128_u64[0] = vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL).u64[0];
  float32x2_t v14 = vmul_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v5 < 3), 0x1FuLL)), (int8x8_t)vrev64_s32((int32x2_t)Viewport.n128_u64[0]), (int8x8_t)Viewport.n128_u64[0]), vcvt_f32_f64(vcvtq_f64_u64(v19)));
  if (v14.f32[0] <= v14.f32[1])
  {
    if (v14.f32[0] < v14.f32[1])
    {
      float v17 = v14.f32[0] / v14.f32[1];
      __n128 result = v18;
      result.n128_f32[0] = (float)((float)(v18.n128_f32[0] + -0.5) * v17) + 0.5;
    }
    else
    {
      return v18;
    }
  }
  else
  {
    float v15 = v14.f32[1] / v14.f32[0];
    __n128 result = v18;
    result.n128_f32[1] = (float)((float)(v18.n128_f32[1] + -0.5) * v15) + 0.5;
  }
  return result;
}

uint64_t SCNMTLRenderCommandEncoder::drawFullScreenQuad(SCNMTLRenderCommandEncoder *this)
{
  SCNMTLRenderCommandEncoder::_bindPendingTextures(this);
  SCNMTLRenderCommandEncoder::applyChangedStates(this);
  uint64_t v2 = (void *)this->var24[1];
  if (LODWORD(this->var14[0].var1) < 2)
  {
    return [v2 drawPrimitives:4 vertexStart:0 vertexCount:4];
  }
  else
  {
    return objc_msgSend(v2, "drawPrimitives:vertexStart:vertexCount:instanceCount:", 4, 0, 4);
  }
}

void SCNMTLRenderCommandEncoder::setVertexTexture(uint64_t a1, void *a2, unint64_t a3)
{
  if (a2)
  {
    if (([a2 conformsToProtocol:&unk_26C0078D8] & 1) == 0)
    {
      uint64_t v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        SCNMTLRenderCommandEncoder::setVertexTexture(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }
  uint64_t v14 = a1 + 8 * a3;
  if (*(void **)(v14 + 576) != a2)
  {
    *(void *)(v14 + 576) = a2;
    *(void *)(a1 + 8 * (a3 >> 6) + 3408) |= 1 << a3;
  }
}

char *std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((void *)v11 + 2) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = (char *)operator new(0xB0uLL);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((void *)v11 + 2) = **a4;
  *((void *)v11 + 21) = 0;
  *(_OWORD *)(v11 + 152) = 0u;
  *(_OWORD *)(v11 + 136) = 0u;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_OWORD *)(v11 + 104) = 0u;
  *(_OWORD *)(v11 + 8_Block_object_dispose(&STACK[0x2A0], 8) = 0u;
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  char v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *(void *)uint64_t v11 = *v20;
LABEL_38:
    *char v20 = v11;
    goto LABEL_39;
  }
  *(void *)uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*(void *)v11)
  {
    unint64_t v21 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    char v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_20B3636F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v_Block_object_dispose(&STACK[0x2A0], 8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + _Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
}

void OUTLINED_FUNCTION_5_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void OUTLINED_FUNCTION_6_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

CFStringRef _C3DConstraintSliderCFCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v2, 0, @"<C3DConstraintAcceleration>");
}

CFStringRef _C3DConstraintSliderCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DConstraintAcceleration>");
}

double __closestPointOnTriangle(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a3, a1);
  float32x4_t v6 = vsubq_f32(a4, a1);
  float32x4_t v7 = vmulq_f32(v4, v6);
  float32x4_t v8 = vmulq_f32(v5, v6);
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
  float32x4_t v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  if (v9.f32[0] <= 0.0)
  {
    unint64_t v11 = a1.i64[0];
    if (v10.f32[0] <= 0.0) {
      return *(double *)&v11;
    }
  }
  float32x4_t v12 = vsubq_f32(a4, a2);
  float32x4_t v13 = vmulq_f32(v4, v12);
  float32x4_t v14 = vmulq_f32(v5, v12);
  float32x4_t v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1)));
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1)));
  if (v15.f32[0] >= 0.0)
  {
    unint64_t v11 = a2.i64[0];
    if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v15, v16))).u8[0] & 1) == 0) {
      return *(double *)&v11;
    }
  }
  float v18 = (float)(v9.f32[0] * v16.f32[0]) - (float)(v15.f32[0] * v10.f32[0]);
  if (v15.f32[0] <= 0.0 && v9.f32[0] >= 0.0 && v18 <= 0.0)
  {
    *(void *)&double result = vmlaq_n_f32(a1, v4, vdivq_f32(v9, vsubq_f32(v9, v15)).f32[0]).u64[0];
    return result;
  }
  float32x4_t v19 = vsubq_f32(a4, a3);
  float32x4_t v20 = vmulq_f32(v4, v19);
  float32x4_t v21 = vmulq_f32(v5, v19);
  float32x4_t v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1)));
  float32x4_t v23 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1)));
  if (v23.f32[0] >= 0.0)
  {
    unint64_t v11 = a3.i64[0];
    if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v23, v22))).u8[0] & 1) == 0) {
      return *(double *)&v11;
    }
  }
  float v24 = (float)(v22.f32[0] * v10.f32[0]) - (float)(v9.f32[0] * v23.f32[0]);
  if (v23.f32[0] <= 0.0 && v24 <= 0.0 && v10.f32[0] >= 0.0)
  {
    LODWORD(v25) = vdivq_f32(v10, vsubq_f32(v10, v23)).u32[0];
LABEL_20:
    *(void *)&double result = vmlaq_n_f32(a1, v5, v25).u64[0];
    return result;
  }
  float v26 = (float)(v15.f32[0] * v23.f32[0]) - (float)(v22.f32[0] * v16.f32[0]);
  if (v26 > 0.0 || (float32x4_t v27 = vsubq_f32(v16, v15), v27.f32[0] < 0.0) || (v28 = vsubq_f32(v22, v23), v28.f32[0] < 0.0))
  {
    float v29 = 1.0 / (float)(v18 + (float)(v26 + v24));
    float v30 = v24 * v29;
    float v25 = v18 * v29;
    a1 = vmlaq_n_f32(a1, v4, v30);
    goto LABEL_20;
  }
  *(void *)&double result = vmlaq_n_f32(a2, vsubq_f32(a3, a2), vdivq_f32(v27, vaddq_f32(v27, v28)).f32[0]).u64[0];
  return result;
}

void CheckPolygonContact(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, float a5, double a6)
{
  float32x4_t v8 = *a1;
  float32x4_t v7 = a1[1];
  float32x4_t v9 = vsubq_f32(v7, *a1);
  float32x4_t v10 = a1[2];
  float32x4_t v11 = vsubq_f32(v10, *a1);
  float32x4_t v12 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v9)), v11, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL));
  int32x4_t v13 = (int32x4_t)vmulq_f32(v12, v12);
  v13.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), *(float32x2_t *)v13.i8)).u32[0];
  *(float32x2_t *)v11.f32 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  *(float32x2_t *)v11.f32 = vmul_f32(*(float32x2_t *)v11.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v11.f32)));
  float32x4_t v14 = vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), vmul_f32(*(float32x2_t *)v11.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v11.f32))).f32[0]);
  float32x4_t v15 = vmulq_f32(*a1, v14);
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1)));
  float32x4_t v17 = *a2;
  float32x4_t v18 = vmulq_f32(*a2, v14);
  float32x4_t v19 = vmulq_f32(v14, vnegq_f32(v14));
  float32x2_t v20 = (float32x2_t)vdivq_f32(vsubq_f32(v16, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1)))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1)))).u64[0];
  if (v20.f32[0] >= 0.0)
  {
    if (v20.f32[0] <= *(float *)&a6)
    {
      float v39 = *(float *)&a6;
      float32x4_t v29 = vmlsq_lane_f32(v17, v14, v20, 0);
    }
    else
    {
      float32x4_t v25 = vmlsq_lane_f32(v17, v14, *(float32x2_t *)&a6, 0);
      float32x4_t v26 = vmulq_f32(v14, v25);
      float32x4_t v27 = vmulq_f32(v14, *a3);
      float v28 = (float)(v16.f32[0]
                  - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0])/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0];
      if (v28 < 0.0) {
        return;
      }
      float v39 = *(float *)&a6;
      float32x4_t v29 = vmlaq_n_f32(v25, *a3, v28);
    }
    float32x4_t v38 = v29;
    float32x4_t v42 = v29;
    v40[2] = v10;
    float32x4_t v41 = v29;
    v40[0] = v8;
    v40[1] = v7;
    BOOL v30 = C3DTriangle3ContainsPoint(v40, &v42);
    float32x4_t v31 = v38;
    if (!v30)
    {
      *(double *)v31.i64 = __closestPointOnTriangle(*a1, a1[1], a1[2], v42);
      float32x4_t v41 = v31;
    }
    float32x4_t v32 = vsubq_f32(*a2, v31);
    float32x4_t v33 = vmulq_f32(v32, v32);
    v33.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0]);
    float32x4_t v34 = vmulq_f32(v32, vnegq_f32(*a3));
    v34.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0];
    float v35 = -(float)((float)((float)((float)-v34.f32[0] * v34.f32[0]) + (float)(v33.f32[0] * v33.f32[0]))
                 - (float)(v39 * v39));
    float v36 = v34.f32[0] - sqrtf(v35);
    if (v35 < 0.0) {
      float v36 = -1.0;
    }
    if (v36 >= 0.0 && v36 <= a5) {
      (*(void (**)(uint64_t, float32x4_t *, float32x4_t *))(a4 + 16))(a4, a1, &v41);
    }
  }
}

float32x4_t __slideWithinWorld(float32x4_t *a1, double a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v8 = LODWORD(a2);
  uint64_t v74 = *MEMORY[0x263EF8340];
  *(float *)&a2 = *(float *)&a2 + 0.001;
  float32x4_t v42 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  while (1)
  {
    float32x4_t v11 = vmulq_f32(a4, a4);
    LODWORD(v12) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
    float v13 = sqrtf(v12);
    if (v13 < 0.001) {
      break;
    }
    uint64_t v65 = 0;
    unsigned __int32 v66 = &v65;
    uint64_t v67 = 0x2000000000;
    char v68 = 0;
    uint64_t v61 = 0;
    unsigned int v62 = (float *)&v61;
    uint64_t v63 = 0x2000000000;
    int v64 = 2139095039;
    uint64_t v69 = 0;
    unsigned __int32 v70 = (float32x4_t *)&v69;
    float v14 = v12;
    uint64_t v71 = 0x3000000000;
    float32x2_t v15 = vrsqrte_f32((float32x2_t)LODWORD(v12));
    float32x2_t v16 = vmul_f32(v15, vrsqrts_f32((float32x2_t)LODWORD(v14), vmul_f32(v15, v15)));
    float32x4_t v17 = vmulq_n_f32(a4, vmul_f32(v16, vrsqrts_f32((float32x2_t)LODWORD(v14), vmul_f32(v16, v16))).f32[0]);
    float32x4_t v18 = vaddq_f32(a4, a3);
    float32x4_t v45 = a4;
    float32x4_t v19 = vsubq_f32(a3, v42);
    float32x4_t v20 = vsubq_f32(v18, v42);
    v19.i32[3] = 0;
    v20.i32[3] = 0;
    float32x4_t v21 = vminnmq_f32(v19, v20);
    float32x4_t v22 = vaddq_f32(v42, a3);
    float32x4_t v43 = v18;
    float32x4_t v23 = vaddq_f32(v42, v18);
    v22.i32[3] = 0;
    v23.i32[3] = 0;
    float32x4_t v24 = vmaxnmq_f32(v22, v23);
    v25.i64[0] = 0x3F0000003F000000;
    v25.i64[1] = 0x3F0000003F000000;
    float32x4_t v26 = vmulq_f32(vaddq_f32(v21, v24), v25);
    v26.i32[3] = 1.0;
    float32x4_t v27 = vmulq_f32(vsubq_f32(v24, v21), v25);
    v27.i32[3] = 0;
    uint64_t v72 = 0;
    uint64_t v73 = 0;
    a1[13] = v26;
    a1[14] = v27;
    a1[11].i64[0] = a1[10].i64[1];
    uint64_t v60 = 0;
    memset(v59, 0, sizeof(v59));
    v47[0] = MEMORY[0x263EF8330];
    v47[1] = 0x40000000;
    v47[2] = ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke;
    v47[3] = &unk_264006EE0;
    float32x4_t v48 = v26;
    float32x4_t v49 = v27;
    uint64_t v55 = a7;
    __int16 v56 = a1;
    float32x4_t v50 = a3;
    float32x4_t v51 = v17;
    float32x4_t v44 = v17;
    float v57 = v13;
    int v58 = v8;
    unsigned __int32 v52 = &v65;
    unsigned int v53 = &v61;
    unsigned int v54 = &v69;
    float32x4_t v46 = a3;
    C3DCullingSystemQueryMake((uint64_t)v47, (uint64_t)v59);
    *(void *)&v59[0] = a1[10].i64[0];
    C3DCullingSystemAABBIntersect(a6);
    int v28 = *((unsigned __int8 *)v66 + 24);
    if (*((unsigned char *)v66 + 24))
    {
      float32x4_t v29 = v70[2];
      float v30 = v62[6];
      float32x4_t v31 = vsubq_f32(vmlaq_n_f32(v46, v44, v30), v29);
      int32x4_t v32 = (int32x4_t)vmulq_f32(v31, v31);
      v32.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))).u32[0];
      float32x2_t v33 = vrsqrte_f32((float32x2_t)v32.u32[0]);
      float32x2_t v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v33, v33)));
      float32x4_t v35 = vmulq_n_f32(v31, vmul_f32(v34, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v34, v34))).f32[0]);
      float32x4_t v36 = vmulq_f32(v29, v35);
      float32x4_t v37 = vmlaq_n_f32(v46, v44, v13 + -0.001);
      float32x4_t v38 = vmulq_f32(v37, v35);
      float32x4_t v39 = vmulq_f32(v35, v35);
      float32x4_t v45 = vsubq_f32(vmlaq_n_f32(v37, v35, (float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]- vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0])/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]), v29);
      float32x4_t v46 = vmlaq_n_f32(v46, v44, v30 + -0.001);
    }
    else
    {
      float32x4_t v41 = v43;
    }
    _Block_object_dispose(&v69, 8);
    _Block_object_dispose(&v61, 8);
    _Block_object_dispose(&v65, 8);
    a4 = v45;
    a3 = v46;
    if (!v28) {
      return v41;
    }
  }
  return a3;
}

void ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)((char *)&v65[1] + 4) = *MEMORY[0x263EF8340];
  if (a3 >= 1)
  {
    uint64_t v4 = 0;
    float32x2_t v5 = (float32x2_t)vdup_n_s32(0x3727C5ACu);
    do
    {
      float32x4_t v6 = *(float32x4_t **)(a2 + 8 * v4);
      uint64_t v7 = *(void *)(a1 + 120);
      if (v6 != (float32x4_t *)v7 && !C3DNodeIsAncestor(*(void *)(a2 + 8 * v4), v7))
      {
        uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry((uint64_t)v6);
        Renderinguint64_t Mesh = C3DGeometryGetRenderingMesh(Geometry);
        WorldMatrifloat x = C3DNodeGetWorldMatrix(v6);
        float32x4_t v11 = WorldMatrix;
        v14.columns[0] = (simd_float4)*WorldMatrix;
        v14.columns[1] = (simd_float4)WorldMatrix[1];
        v14.columns[2] = (simd_float4)WorldMatrix[2];
        int8x16_t v12 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14.columns[2], (int32x4_t)v14.columns[2]), (int8x16_t)v14.columns[2], 0xCuLL), vnegq_f32((float32x4_t)v14.columns[1])), (float32x4_t)v14.columns[2], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14.columns[1], (int32x4_t)v14.columns[1]), (int8x16_t)v14.columns[1], 0xCuLL));
        v14.columns[3] = (simd_float4)vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), v12, 0xCuLL));
        BOOL v13 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14.columns[3], 2), vaddq_f32((float32x4_t)v14.columns[3], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.columns[3].f32, 1))).f32[0] < 0.0;
        v14.columns[3].i32[0] = 1.0;
        if (v13) {
          v14.columns[3].f32[0] = -1.0;
        }
        float32x4_t v15 = vmulq_f32((float32x4_t)v14.columns[0], (float32x4_t)v14.columns[0]);
        float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1)));
        v16.f32[0] = sqrtf(v16.f32[0]);
        float32x4_t v17 = vmulq_f32((float32x4_t)v14.columns[1], (float32x4_t)v14.columns[1]);
        float32x4_t v18 = vmulq_f32((float32x4_t)v14.columns[2], (float32x4_t)v14.columns[2]);
        v16.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]);
        v16.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0]);
        int32x4_t v19 = (int32x4_t)vmulq_n_f32(v16, v14.columns[3].f32[0]);
        *(int32x2_t *)v19.i8 = vcgt_f32(v5, vabd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_laneq_s32(v19, 2)));
        if ((vpmin_u32(*(uint32x2_t *)v19.i8, *(uint32x2_t *)v19.i8).u32[0] & 0x80000000) != 0)
        {
          v14.columns[3] = (simd_float4)WorldMatrix[3];
          simd_float4x4 v66 = __invert_f4(v14);
          int32x4_t v32 = *(int32x4_t *)(a1 + 48);
          v66.columns[3] = (simd_float4)vaddq_f32((float32x4_t)v66.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v66.columns[1], *(float32x2_t *)(a1 + 32), 1), (float32x4_t)v66.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 32))), (float32x4_t)v66.columns[2], *(float32x4_t *)(a1 + 32), 2));
          v66.columns[3].i32[3] = 1.0;
          float32x4_t v33 = (float32x4_t)v32;
          v33.i32[1] = v32.i32[0];
          v33.i32[2] = v32.i32[0];
          v56[0] = MEMORY[0x263EF8330];
          v56[1] = 0x40000000;
          v56[2] = ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_2;
          v56[3] = &unk_264006E68;
          uint64_t v34 = *(void *)(a1 + 128);
          uint64_t v61 = v11;
          uint64_t v62 = v34;
          v66.columns[1] = (simd_float4)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32((float32x4_t)v66.columns[0], v33)), vabsq_f32(vmulq_f32((float32x4_t)v66.columns[1], (float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v32.i8, 1), v32)))), vabsq_f32(vmulq_f32((float32x4_t)v66.columns[2], (float32x4_t)vzip2q_s32(vtrn1q_s32(v32, v32), v32))));
          v66.columns[2] = *(simd_float4 *)(a1 + 80);
          long long v57 = *(_OWORD *)(a1 + 64);
          simd_float4 v58 = v66.columns[2];
          uint64_t v63 = *(void *)(a1 + 136);
          long long v59 = *(_OWORD *)(a1 + 96);
          uint64_t v60 = *(void *)(a1 + 112);
          C3DMeshQueryTrianglesIntersectingBox((uint64_t)RenderingMesh, (uint64_t)v56, (float32x4_t)v66.columns[3], (float32x4_t)v66.columns[1]);
        }
        else
        {
          CFArrayRef ElementsCount = C3DMeshGetElementsCount((uint64_t)RenderingMesh);
          if (ElementsCount)
          {
            uint64_t v21 = (uint64_t)ElementsCount;
            Positionuint64_t Source = C3DMeshGetPositionSource((uint64_t)RenderingMesh, 0);
            if (C3DMeshSourceGetCount((uint64_t)PositionSource))
            {
              uint64_t Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
              uint64_t v24 = v23;
              if ((v23 & 0xFF00000000) != 0x900000000)
              {
                float32x4_t v25 = scn_default_log();
                if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
                  ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_cold_1(v64, v65, v25);
                }
              }
              uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex((uint64_t)RenderingMesh, 0, 0);
              if (v21 >= 1)
              {
                uint64_t v27 = ChannelForSourceWithSemanticAtIndex;
                for (CFIndex i = 0; i != v21; ++i)
                {
                  ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)RenderingMesh, i, 0);
                  uint64_t v55 = 0;
                  long long v53 = 0u;
                  long long v54 = 0u;
                  long long v52 = 0u;
                  C3DMeshElementGetContent((uint64_t)ElementAtIndex, v27, (uint64_t)&v52);
                  if ((BYTE10(v53) & 0xFA) != 0)
                  {
                    float v30 = scn_default_log();
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)uint8_t buf = 0;
                      _os_log_impl(&dword_20B249000, v30, OS_LOG_TYPE_DEFAULT, "Warning: Slider can only process triangles.", buf, 2u);
                    }
                  }
                  else
                  {
                    v49[0] = v52;
                    v49[1] = v53;
                    v49[2] = v54;
                    uint64_t v50 = v55;
                    v38[0] = MEMORY[0x263EF8330];
                    v38[1] = 0x40000000;
                    v38[2] = ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_9;
                    v38[3] = &unk_264006EB8;
                    int v47 = v24 - 1;
                    uint64_t v44 = v24;
                    float32x4_t v45 = v11;
                    uint64_t v46 = *(void *)(a1 + 128);
                    long long v31 = *(_OWORD *)(a1 + 80);
                    long long v39 = *(_OWORD *)(a1 + 64);
                    long long v40 = v31;
                    uint64_t v48 = *(void *)(a1 + 136);
                    __n128 v41 = *(__n128 *)(a1 + 96);
                    uint64_t v42 = *(void *)(a1 + 112);
                    uint64_t v43 = Content;
                    C3DIndicesContentEnumeratePrimitives((uint64_t *)v49, (uint64_t)v38, v41);
                  }
                }
              }
            }
          }
        }
      }
      ++v4;
    }
    while (v4 != a3);
  }
}

uint64_t ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_2(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = (float32x4_t *)(a1 + 32);
    uint64_t v7 = (float32x4_t *)(a1 + 48);
    uint64_t v8 = a3;
    do
    {
      float32x4_t v9 = *(float32x4_t *)(a2 + 16 * (3 * v5 + 1));
      float32x4_t v10 = *(float32x4_t *)(a2 + 16 * (3 * v5 + 2));
      float32x4_t v42 = *(float32x4_t *)(a2 + 16 * (3 * v5));
      float32x4_t v43 = v9;
      float32x4_t v44 = v10;
      float32x4_t v11 = *(float32x4_t **)(a1 + 88);
      int8x16_t v12 = *(void **)(a1 + 96);
      float32x4_t v13 = v11[1];
      float32x4_t v14 = v11[2];
      float32x4_t v15 = v11[3];
      float32x4_t v42 = vaddq_f32(v15, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v13, *(float32x2_t *)v42.f32, 1), *v11, v42.f32[0]), v14, v42, 2));
      float32x4_t v43 = vaddq_f32(v15, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v13, *(float32x2_t *)v9.f32, 1), *v11, v9.f32[0]), v14, v9, 2));
      float32x4_t v16 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v11[1], *(float32x2_t *)v10.f32, 1), *v11, v10.f32[0]), v14, v10, 2);
      float32x4_t v44 = vaddq_f32(v15, v16);
      if (v12[16])
      {
        float32x4_t v18 = (float32x4_t *)v12[31];
        unint64_t v17 = v12[32];
        if ((unint64_t)v18 >= v17)
        {
          uint64_t v22 = v12[30];
          unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - v22) >> 4);
          unint64_t v24 = v23 + 1;
          if (v23 + 1 > 0x555555555555555) {
            abort();
          }
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v22) >> 4);
          if (2 * v25 > v24) {
            unint64_t v24 = 2 * v25;
          }
          if (v25 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v26 = 0x555555555555555;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26) {
            uint64_t v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v12 + 32), v26);
          }
          else {
            uint64_t v27 = 0;
          }
          int v28 = (float32x4_t *)&v27[48 * v23];
          float32x4_t v29 = v42;
          v16.i32[1] = v43.i32[1];
          float32x4_t v30 = v44;
          v28[1] = v43;
          v28[2] = v30;
          *int v28 = v29;
          int32x4_t v32 = (float32x4_t *)v12[30];
          long long v31 = (float32x4_t *)v12[31];
          float32x4_t v33 = v28;
          if (v31 != v32)
          {
            do
            {
              float32x4_t v34 = v31[-3];
              float32x4_t v16 = v31[-2];
              float32x4_t v35 = v31[-1];
              v33[-2] = v16;
              v33[-1] = v35;
              v33[-3] = v34;
              v33 -= 3;
              v31 -= 3;
            }
            while (v31 != v32);
            long long v31 = (float32x4_t *)v12[30];
          }
          f32 = (_OWORD *)v28[3].f32;
          v12[30] = v33;
          v12[31] = v28 + 3;
          v12[32] = &v27[48 * v26];
          if (v31) {
            operator delete(v31);
          }
        }
        else
        {
          float32x4_t v19 = v42;
          v16.i32[1] = v43.i32[1];
          float32x4_t v20 = v44;
          v18[1] = v43;
          _OWORD v18[2] = v20;
          *float32x4_t v18 = v19;
          f32 = (_OWORD *)v18[3].f32;
        }
        v12[31] = f32;
        int8x16_t v12 = *(void **)(a1 + 96);
      }
      float v36 = *(float *)(a1 + 104);
      v16.i32[0] = *(_DWORD *)(a1 + 108);
      v38[0] = MEMORY[0x263EF8330];
      v38[1] = 0x40000000;
      v38[2] = ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_3;
      v38[3] = &unk_264006E40;
      long long v39 = *(_OWORD *)(a1 + 64);
      uint64_t v40 = *(void *)(a1 + 80);
      __n128 v41 = v12;
      CheckPolygonContact(&v42, v6, v7, (uint64_t)v38, v36, *(double *)v16.i64);
      ++v5;
    }
    while (v5 != v8);
  }
  return 0;
}

void ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_3(void *a1, long long *a2, _OWORD *a3, float a4)
{
  uint64_t v6 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24) || (float v7 = *(float *)(v6 + 24), v7 > a4))
  {
    *(float *)(v6 + 24) = a4;
    *(_OWORD *)(*(void *)(a1[6] + 8) + 32) = *a3;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    uint64_t v8 = a1[7];
    if (!*(void *)(v8 + 128)) {
      return;
    }
    *(void *)(v8 + 248) -= 48;
    float32x4_t v9 = (void *)a1[7];
    float32x4_t v10 = (_OWORD *)v9[34];
    unint64_t v11 = v9[35];
    if ((unint64_t)v10 >= v11)
    {
      uint64_t v27 = v9[33];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v10 - v27) >> 4);
      unint64_t v29 = v28 + 1;
      if (v28 + 1 > 0x555555555555555) {
        goto LABEL_55;
      }
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v27) >> 4);
      if (2 * v30 > v29) {
        unint64_t v29 = 2 * v30;
      }
      if (v30 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v31 = 0x555555555555555;
      }
      else {
        unint64_t v31 = v29;
      }
      if (v31) {
        int32x4_t v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v9 + 35), v31);
      }
      else {
        int32x4_t v32 = 0;
      }
      float32x4_t v33 = &v32[48 * v28];
      float32x4_t v34 = &v32[48 * v31];
      long long v35 = *a2;
      long long v36 = a2[2];
      *((_OWORD *)v33 + 1) = a2[1];
      *((_OWORD *)v33 + 2) = v36;
      *(_OWORD *)float32x4_t v33 = v35;
      float32x4_t v14 = v33 + 48;
      float32x4_t v38 = (char *)v9[33];
      float32x4_t v37 = (char *)v9[34];
      if (v37 != v38)
      {
        do
        {
          long long v39 = *((_OWORD *)v37 - 3);
          long long v40 = *((_OWORD *)v37 - 1);
          *((_OWORD *)v33 - 2) = *((_OWORD *)v37 - 2);
          *((_OWORD *)v33 - 1) = v40;
          *((_OWORD *)v33 - 3) = v39;
          v33 -= 48;
          v37 -= 48;
        }
        while (v37 != v38);
        float32x4_t v37 = (char *)v9[33];
      }
      v9[33] = v33;
      v9[34] = v14;
      v9[35] = v34;
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      long long v12 = *a2;
      long long v13 = a2[2];
      v10[1] = a2[1];
      v10[2] = v13;
      *float32x4_t v10 = v12;
      float32x4_t v14 = v10 + 3;
    }
    v9[34] = v14;
    float32x4_t v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v41 = v18[23];
    if ((unint64_t)v19 < v41) {
      goto LABEL_34;
    }
    uint64_t v45 = v18[21];
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v45) >> 4);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 <= 0x555555555555555)
    {
      unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - v45) >> 4);
      if (2 * v48 > v47) {
        unint64_t v47 = 2 * v48;
      }
      if (v48 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v49 = 0x555555555555555;
      }
      else {
        unint64_t v49 = v47;
      }
      if (v49) {
        uint64_t v50 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v18 + 23), v49);
      }
      else {
        uint64_t v50 = 0;
      }
      float32x4_t v51 = &v50[48 * v46];
      long long v52 = &v50[48 * v49];
      long long v53 = *a2;
      long long v54 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v54;
      *(_OWORD *)float32x4_t v51 = v53;
      float32x4_t v44 = v51 + 48;
      __int16 v56 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v56) {
        goto LABEL_51;
      }
      do
      {
        long long v57 = *((_OWORD *)v55 - 3);
        long long v58 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v58;
        *((_OWORD *)v51 - 3) = v57;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v56);
LABEL_50:
      uint64_t v55 = (char *)v18[21];
LABEL_51:
      v18[21] = v51;
      v18[22] = v44;
      v18[23] = v52;
      if (v55) {
        operator delete(v55);
      }
      goto LABEL_53;
    }
LABEL_55:
    abort();
  }
  float v15 = v7 + -0.001;
  float v16 = v7 + 0.001;
  if (v15 < a4 && v16 > a4)
  {
    float32x4_t v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v20 = v18[23];
    if ((unint64_t)v19 < v20)
    {
LABEL_34:
      long long v42 = *a2;
      long long v43 = a2[2];
      v19[1] = a2[1];
      void v19[2] = v43;
      *float32x4_t v19 = v42;
      float32x4_t v44 = v19 + 3;
LABEL_53:
      v18[22] = v44;
      return;
    }
    uint64_t v21 = v18[21];
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v21) >> 4);
    unint64_t v23 = v22 + 1;
    if (v22 + 1 <= 0x555555555555555)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v21) >> 4);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v25 = 0x555555555555555;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25) {
        unint64_t v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v18 + 23), v25);
      }
      else {
        unint64_t v26 = 0;
      }
      float32x4_t v51 = &v26[48 * v22];
      long long v52 = &v26[48 * v25];
      long long v59 = *a2;
      long long v60 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v60;
      *(_OWORD *)float32x4_t v51 = v59;
      float32x4_t v44 = v51 + 48;
      uint64_t v61 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v61) {
        goto LABEL_51;
      }
      do
      {
        long long v62 = *((_OWORD *)v55 - 3);
        long long v63 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v63;
        *((_OWORD *)v51 - 3) = v62;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v61);
      goto LABEL_50;
    }
    goto LABEL_55;
  }
}

void ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_9(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  if (a4 <= 2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_9_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void *)(a1 + 88);
  int v15 = *(unsigned __int8 *)(a1 + 101);
  unsigned int v16 = *(_DWORD *)(a1 + 120);
  unsigned int v17 = *a3;
  if (v16 < *a3) {
    unsigned int v17 = *(_DWORD *)(a1 + 120);
  }
  float32x4_t v18 = (float *)(v14 + v17 * v15);
  float v19 = *v18;
  float v20 = v18[1];
  float v21 = v18[2];
  if (v16 >= a3[1]) {
    unsigned int v22 = a3[1];
  }
  else {
    unsigned int v22 = *(_DWORD *)(a1 + 120);
  }
  unint64_t v23 = (float *)(v14 + v22 * v15);
  if (v16 >= a3[2]) {
    unsigned int v16 = a3[2];
  }
  unint64_t v24 = (float *)(v14 + v16 * v15);
  float v25 = *v24;
  float v26 = v24[1];
  float v27 = v24[2];
  unint64_t v28 = *(float32x4_t **)(a1 + 104);
  unint64_t v29 = *(void **)(a1 + 112);
  float32x4_t v30 = v28[1];
  float32x4_t v31 = v28[2];
  float32x4_t v32 = v28[3];
  float32x4_t v33 = vaddq_f32(v32, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v28, v19), v30, v20), v31, v21));
  float32x4_t v34 = vaddq_f32(v32, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v28, *v23), v30, v23[1]), v31, v23[2]));
  float32x4_t v35 = vaddq_f32(v32, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v28, v25), v30, v26), v31, v27));
  float32x4_t v60 = v33;
  float32x4_t v61 = v34;
  float32x4_t v62 = v35;
  if (v29[16])
  {
    float32x4_t v37 = (float32x4_t *)v29[31];
    unint64_t v36 = v29[32];
    if ((unint64_t)v37 >= v36)
    {
      uint64_t v41 = v29[30];
      unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v37 - v41) >> 4);
      unint64_t v43 = v42 + 1;
      if (v42 + 1 > 0x555555555555555) {
        abort();
      }
      unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - v41) >> 4);
      if (2 * v44 > v43) {
        unint64_t v43 = 2 * v44;
      }
      if (v44 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v45 = 0x555555555555555;
      }
      else {
        unint64_t v45 = v43;
      }
      if (v45) {
        unint64_t v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v29 + 32), v45);
      }
      else {
        unint64_t v46 = 0;
      }
      unint64_t v47 = (float32x4_t *)&v46[48 * v42];
      unint64_t v48 = &v46[48 * v45];
      float32x4_t v49 = v60;
      v34.i32[1] = v61.i32[1];
      float32x4_t v50 = v62;
      v47[1] = v61;
      v47[2] = v50;
      *unint64_t v47 = v49;
      f32 = (_OWORD *)v47[3].f32;
      long long v52 = (float32x4_t *)v29[30];
      float32x4_t v51 = (float32x4_t *)v29[31];
      if (v51 != v52)
      {
        do
        {
          float32x4_t v53 = v51[-3];
          float32x4_t v34 = v51[-2];
          float32x4_t v54 = v51[-1];
          v47[-2] = v34;
          v47[-1] = v54;
          v47[-3] = v53;
          v47 -= 3;
          v51 -= 3;
        }
        while (v51 != v52);
        float32x4_t v51 = (float32x4_t *)v29[30];
      }
      v29[30] = v47;
      v29[31] = f32;
      v29[32] = v48;
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      float32x4_t v38 = v60;
      v34.i32[1] = v61.i32[1];
      float32x4_t v39 = v62;
      v37[1] = v61;
      uint64_t v37[2] = v39;
      *float32x4_t v37 = v38;
      f32 = (_OWORD *)v37[3].f32;
    }
    v29[31] = f32;
    unint64_t v29 = *(void **)(a1 + 112);
  }
  float v55 = *(float *)(a1 + 124);
  v34.i32[0] = *(_DWORD *)(a1 + 128);
  v56[0] = MEMORY[0x263EF8330];
  v56[1] = 0x40000000;
  v56[2] = ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_11;
  v56[3] = &unk_264006E90;
  long long v57 = *(_OWORD *)(a1 + 64);
  uint64_t v58 = *(void *)(a1 + 80);
  long long v59 = v29;
  CheckPolygonContact(&v60, (float32x4_t *)(a1 + 32), (float32x4_t *)(a1 + 48), (uint64_t)v56, v55, *(double *)v34.i64);
}

void ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_11(void *a1, long long *a2, _OWORD *a3, float a4)
{
  uint64_t v6 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24) || (float v7 = *(float *)(v6 + 24), v7 > a4))
  {
    *(float *)(v6 + 24) = a4;
    *(_OWORD *)(*(void *)(a1[6] + 8) + 32) = *a3;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    uint64_t v8 = a1[7];
    if (!*(void *)(v8 + 128)) {
      return;
    }
    *(void *)(v8 + 248) -= 48;
    uint64_t v9 = (void *)a1[7];
    uint64_t v10 = (_OWORD *)v9[34];
    unint64_t v11 = v9[35];
    if ((unint64_t)v10 >= v11)
    {
      uint64_t v27 = v9[33];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v10 - v27) >> 4);
      unint64_t v29 = v28 + 1;
      if (v28 + 1 > 0x555555555555555) {
        goto LABEL_55;
      }
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v27) >> 4);
      if (2 * v30 > v29) {
        unint64_t v29 = 2 * v30;
      }
      if (v30 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v31 = 0x555555555555555;
      }
      else {
        unint64_t v31 = v29;
      }
      if (v31) {
        float32x4_t v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v9 + 35), v31);
      }
      else {
        float32x4_t v32 = 0;
      }
      float32x4_t v33 = &v32[48 * v28];
      float32x4_t v34 = &v32[48 * v31];
      long long v35 = *a2;
      long long v36 = a2[2];
      *((_OWORD *)v33 + 1) = a2[1];
      *((_OWORD *)v33 + 2) = v36;
      *(_OWORD *)float32x4_t v33 = v35;
      uint64_t v14 = v33 + 48;
      float32x4_t v38 = (char *)v9[33];
      float32x4_t v37 = (char *)v9[34];
      if (v37 != v38)
      {
        do
        {
          long long v39 = *((_OWORD *)v37 - 3);
          long long v40 = *((_OWORD *)v37 - 1);
          *((_OWORD *)v33 - 2) = *((_OWORD *)v37 - 2);
          *((_OWORD *)v33 - 1) = v40;
          *((_OWORD *)v33 - 3) = v39;
          v33 -= 48;
          v37 -= 48;
        }
        while (v37 != v38);
        float32x4_t v37 = (char *)v9[33];
      }
      v9[33] = v33;
      v9[34] = v14;
      v9[35] = v34;
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      long long v12 = *a2;
      long long v13 = a2[2];
      v10[1] = a2[1];
      v10[2] = v13;
      *uint64_t v10 = v12;
      uint64_t v14 = v10 + 3;
    }
    v9[34] = v14;
    float32x4_t v18 = (void *)a1[7];
    float v19 = (_OWORD *)v18[22];
    unint64_t v41 = v18[23];
    if ((unint64_t)v19 < v41) {
      goto LABEL_34;
    }
    uint64_t v45 = v18[21];
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v45) >> 4);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 <= 0x555555555555555)
    {
      unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - v45) >> 4);
      if (2 * v48 > v47) {
        unint64_t v47 = 2 * v48;
      }
      if (v48 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v49 = 0x555555555555555;
      }
      else {
        unint64_t v49 = v47;
      }
      if (v49) {
        float32x4_t v50 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v18 + 23), v49);
      }
      else {
        float32x4_t v50 = 0;
      }
      float32x4_t v51 = &v50[48 * v46];
      long long v52 = &v50[48 * v49];
      long long v53 = *a2;
      long long v54 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v54;
      *(_OWORD *)float32x4_t v51 = v53;
      unint64_t v44 = v51 + 48;
      __int16 v56 = (char *)v18[21];
      float v55 = (char *)v18[22];
      if (v55 == v56) {
        goto LABEL_51;
      }
      do
      {
        long long v57 = *((_OWORD *)v55 - 3);
        long long v58 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v58;
        *((_OWORD *)v51 - 3) = v57;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v56);
LABEL_50:
      float v55 = (char *)v18[21];
LABEL_51:
      v18[21] = v51;
      v18[22] = v44;
      v18[23] = v52;
      if (v55) {
        operator delete(v55);
      }
      goto LABEL_53;
    }
LABEL_55:
    abort();
  }
  float v15 = v7 + -0.001;
  float v16 = v7 + 0.001;
  if (v15 < a4 && v16 > a4)
  {
    float32x4_t v18 = (void *)a1[7];
    float v19 = (_OWORD *)v18[22];
    unint64_t v20 = v18[23];
    if ((unint64_t)v19 < v20)
    {
LABEL_34:
      long long v42 = *a2;
      long long v43 = a2[2];
      v19[1] = a2[1];
      void v19[2] = v43;
      *float v19 = v42;
      unint64_t v44 = v19 + 3;
LABEL_53:
      v18[22] = v44;
      return;
    }
    uint64_t v21 = v18[21];
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v21) >> 4);
    unint64_t v23 = v22 + 1;
    if (v22 + 1 <= 0x555555555555555)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v21) >> 4);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v25 = 0x555555555555555;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25) {
        float v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>((uint64_t)(v18 + 23), v25);
      }
      else {
        float v26 = 0;
      }
      float32x4_t v51 = &v26[48 * v22];
      long long v52 = &v26[48 * v25];
      long long v59 = *a2;
      long long v60 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v60;
      *(_OWORD *)float32x4_t v51 = v59;
      unint64_t v44 = v51 + 48;
      float32x4_t v61 = (char *)v18[21];
      float v55 = (char *)v18[22];
      if (v55 == v61) {
        goto LABEL_51;
      }
      do
      {
        long long v62 = *((_OWORD *)v55 - 3);
        long long v63 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v63;
        *((_OWORD *)v51 - 3) = v62;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v61);
      goto LABEL_50;
    }
    goto LABEL_55;
  }
}

uint64_t C3DConstraintApplySlider(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  if (!a2)
  {
    float v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  float v15 = *(float32x4_t **)(a2 + 16);
  v49.i32[2] = 0;
  v49.i64[0] = 0;
  C3DNodeGetWorldPosition(a3, (__n128 *)&v49);
  uint64_t v16 = C3DGetScene(a3);
  if (v16)
  {
    unsigned int v17 = *(float32x4_t **)(a2 + 56);
    uint64_t CullingSystem = C3DSceneGetCullingSystem(v16);
    WorldMatrifloat x = C3DNodeGetWorldMatrix(a3);
    float32x4_t v21 = *WorldMatrix;
    float32x4_t v22 = WorldMatrix[1];
    float32x4_t v23 = WorldMatrix[2];
    int8x16_t v24 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), vnegq_f32(v22)), v23, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL));
    float32x4_t v25 = vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL));
    BOOL v26 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0] < 0.0;
    float v27 = 1.0;
    float32x4_t v28 = vmulq_f32(v21, v21);
    float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1)));
    float32x4_t v29 = vmulq_f32(v22, v22);
    float32x4_t v30 = vmulq_f32(v23, v23);
    v31.f32[0] = sqrtf(v31.f32[0]);
    v31.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]);
    v31.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
    if (v26) {
      float v27 = -1.0;
    }
    float32x4_t v32 = vmulq_n_f32(v31, v27);
    float v33 = v32.f32[2];
    if (v32.f32[0] >= v32.f32[2]) {
      float v33 = v32.f32[0];
    }
    v32.i32[0] = v32.i32[1];
    if (v33 >= v32.f32[1]) {
      v32.f32[0] = v33;
    }
    float32x4_t v34 = v15[9];
    float32x4_t v35 = vsubq_f32(vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v22, *(float32x2_t *)v34.f32, 1), v21, v34.f32[0]), v23, v34, 2)), v49);
    float32x4_t v38 = *v17;
    float32x4_t v36 = vaddq_f32(*v17, v35);
    float32x4_t v46 = v35;
    float32x4_t v37 = vaddq_f32(v49, v35);
    v38.f32[0] = vmuls_lane_f32(v32.f32[0], v34, 3);
    float32x4_t v39 = v37;
    v39.i32[3] = v38.i32[0];
    uint8_t v15[12] = v39;
    if (v15[8].i64[0])
    {
      v15[15].i64[1] = v15[15].i64[0];
      v15[17].i64[0] = v15[16].i64[1];
    }
    float32x4_t v47 = vsubq_f32(__slideWithinWorld(v15, *(double *)v38.i64, v36, vsubq_f32(v37, v36), v20, CullingSystem, (uint64_t)a3), v46);
    *unsigned int v17 = v47;
    uint64_t Parent = (float32x4_t *)C3DNodeGetParent((uint64_t)a3);
    if (Parent) {
      unint64_t v41 = (simd_float4x4 *)C3DNodeGetWorldMatrix(Parent);
    }
    else {
      unint64_t v41 = (simd_float4x4 *)MEMORY[0x263EF89A8];
    }
    simd_float4x4 v50 = __invert_f4(*v41);
    float32x4_t v48 = vaddq_f32((float32x4_t)v50.columns[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v50.columns[1], *(float32x2_t *)v47.f32, 1), (float32x4_t)v50.columns[0], v47.f32[0]), (float32x4_t)v50.columns[2], v47, 2));
    uint64_t Target = (const void *)C3DModelTargetGetTarget(a4);
    uint64_t TargetAddress = (void *)C3DModelTargetGetTargetAddress(a4);
    size_t v44 = C3DSizeOfBaseType(9);
    C3DSetValue(Target, TargetAddress, &v48, v44, 6, 0);
  }
  return 1;
}

void C3DContraintSliderAppendDebugInfo(__C3DConstraint *a1, uint64_t a2)
{
  float32x4_t v4 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 16);
  float32x4_t v5 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 32);
  float32x4_t v6 = *(float32x4_t *)(MEMORY[0x263EF89A8] + 48);
  v24[0] = *(float32x4_t *)MEMORY[0x263EF89A8];
  v24[1] = v4;
  v24[2] = v5;
  v24[3] = v6;
  long long v23 = xmmword_20B5CB6E0;
  C3DAuthoringEnvironmentAppendDebugBoundingSphere(a2, a1[1].var0.var6, (uint64_t)a1[1].var1, v24, &v23);
  long long v22 = xmmword_20B5CB700;
  C3DAuthoringEnvironmentAppendDebugBoundingBox(a2, (float32x4_t *)&a1[1].var2, v24, (float *)&v22);
  var3 = (float32x4_t *)a1[1].var5.var3;
  var4 = (float32x4_t *)a1[1].var5.var4;
  long long v21 = xmmword_20B5CB6E0;
  while (var3 != var4)
  {
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v21, 0, *var3, var3[1]);
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v21, 0, var3[1], var3[2]);
    float32x4_t v9 = var3[2];
    float32x4_t v10 = *var3;
    var3 += 3;
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v21, 0, v9, v10);
  }
  uint64_t v11 = (float32x4_t *)a1[1].var0.var3;
  uint64_t v12 = a1[1].var0.var4;
  long long v20 = xmmword_20B5CB700;
  while (v11 != (float32x4_t *)v12)
  {
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v20, 0, *v11, v11[1]);
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v20, 0, v11[1], v11[2]);
    float32x4_t v13 = v11[2];
    float32x4_t v14 = *v11;
    v11 += 3;
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v20, 0, v13, v14);
  }
  var6 = (float32x4_t *)a1[1].var6;
  unint64_t var0 = a1[2].var0.var0.var0;
  long long v19 = xmmword_20B5CBCA0;
  while (var6 != (float32x4_t *)var0)
  {
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v19, 0, *var6, var6[1]);
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v19, 0, var6[1], var6[2]);
    float32x4_t v17 = var6[2];
    float32x4_t v18 = *var6;
    var6 += 3;
    C3DAuthoringEnvironmentAppendDebugSegment(a2, 0, (float *)&v19, 0, v17, v18);
  }
}

uint64_t C3DConstraintSliderInit(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  v6.n128_u32[2] = 0;
  v6.n128_u64[0] = 0;
  C3DNodeGetWorldPosition(a3, &v6);
  float32x4_t v4 = (__n128 *)malloc_type_calloc(1uLL, 0x10uLL, 0x1000040451B5BE8uLL);
  *(void *)(a2 + 56) = v4;
  *float32x4_t v4 = v6;
  return 1;
}

__CFString *C3DConstraintSliderCopyTargetPath(__C3DConstraint *a1)
{
  return @"transform";
}

uint64_t C3DConstraintCreateSlider()
{
  if (C3DConstraintSliderGetTypeID::onceToken != -1) {
    dispatch_once(&C3DConstraintSliderGetTypeID::onceToken, &__block_literal_global_41);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DConstraintSliderGetTypeID::typeID, 0x110uLL);
  C3DConstraintInit(Instance);
  *(void *)(Instance + 160) = -1;
  *(_DWORD *)(Instance + 156) = 1065353216;
  *(void *)(Instance + 80) = C3DConstraintSliderInit;
  *(void *)(Instance + 8_Block_object_dispose(&STACK[0x2A0], 8) = C3DConstraintApplySlider;
  *(void *)(Instance + 96) = C3DConstraintSliderCopyTargetPath;
  *(void *)(Instance + 112) = C3DContraintSliderAppendDebugInfo;
  return Instance;
}

void C3DConstaintSliderSetCategoryBitMask(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    float32x4_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(void *)(a1 + 160) = a2;
}

void C3DConstaintSliderSetRadius(uint64_t a1, float a2)
{
  if (!a1)
  {
    float32x4_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(float *)(a1 + 156) = a2;
}

__n128 C3DConstaintSliderSetOffset(__n128 *a1, __n128 result)
{
  if (!a1)
  {
    __n128 v12 = result;
    uint64_t v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    double result = v12;
    if (v4)
    {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v3, v5, v6, v7, v8, v9, v10, v11);
      double result = v12;
    }
  }
  result.n128_u32[3] = a1[9].n128_u32[3];
  a1[9] = result;
  return result;
}

void _C3DConstraintAvoidOccluderCFFinalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[17];
  if (v2)
  {
    CFRelease(v2);
    a1[17] = 0;
  }
  uint64_t v3 = (const void *)a1[18];
  if (v3)
  {
    CFRelease(v3);
    a1[18] = 0;
  }

  _C3DConstraintCFFinalize((uint64_t)a1);
}

CFStringRef _C3DConstraintAvoidOccluderCFCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v3, 0, @"<C3DConstraintAvoidOccluder %p>", a1);
}

CFStringRef _C3DConstraintAvoidOccluderCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DConstraintAvoidOccluder %p>", a1);
}

CFTypeRef C3DConstraintAvoidOccluderSetDelegate(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 144);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 144) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 144) = result;
  }
  return result;
}

CFTypeRef C3DConstraintAvoidOccluderSetTarget(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 136);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 136) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 136) = result;
  }
  return result;
}

void C3DConstraintAvoidOccluderSetOffset(uint64_t a1, float a2)
{
  if (!a1)
  {
    BOOL v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DConstaintSliderSetCategoryBitMask_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  float v12 = 0.0001;
  if (a2 >= 0.0001) {
    float v12 = a2;
  }
  *(float *)(a1 + 16_Block_object_dispose(&STACK[0x2A0], 8) = v12;
}

BOOL C3DConstraintApplyAvoidOccluder(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  if (!a2)
  {
    uint64_t v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  uint64_t v15 = C3DGetScene(a3);
  if (!v15) {
    return 0;
  }
  uint64_t CullingSystem = C3DSceneGetCullingSystem(v15);
  uint64_t v17 = *(void *)(a2 + 16);
  float32x4_t v18 = *(float32x4_t **)(v17 + 136);
  float32x4_t v61 = v18;
  BOOL v19 = v18 != 0;
  if (v18)
  {
    uint64_t v20 = CullingSystem;
    uint64_t v58 = 0xA00000000;
    long long v59 = (unint64_t *)v60;
    v57[0] = 0;
    v57[1] = v57;
    v57[2] = 0x2000000000;
    v57[3] = &v58;
    if (*(unsigned char *)(v17 + 152))
    {
      C3DAppendFlattenNodeHierarchy<C3D::Array<__C3DNode *,10u,C3D::MallocAllocator>>((uint64_t)&v58, (uint64_t)v18);
      C3DAppendFlattenNodeHierarchy<C3D::Array<__C3DNode *,10u,C3D::MallocAllocator>>((uint64_t)&v58, (uint64_t)a3);
    }
    else
    {
      C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>((uint64_t)&v58, &v61);
      *(void *)&v45[0] = a3;
      C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>((uint64_t)&v58, v45);
    }
    unint64_t v21 = 126 - 2 * __clz(v58);
    if (v58) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **,false>((uint64_t)v59, &v59[v58], (uint64_t)v45, v22, 1);
    v56.i32[2] = 0;
    v56.i64[0] = 0;
    C3DNodeGetWorldPosition(a3, (__n128 *)&v56);
    v55.i32[2] = 0;
    v55.i64[0] = 0;
    C3DNodeGetWorldPosition(v61, (__n128 *)&v55);
    float32x4_t v23 = vsubq_f32(v56, v55);
    float32x4_t v24 = vmulq_f32(v23, v23);
    v24.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).u64[0];
    v24.f32[0] = sqrtf(v24.f32[0]);
    float32x4_t v25 = vdivq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0));
    __asm { FMOV            V2.4S, #1.0 }
    float32x4_t v35 = v25;
    uint64_t v51 = 0;
    long long v52 = (float *)&v51;
    uint64_t v53 = 0x2000000000;
    int v54 = 2139095039;
    uint64_t v47 = 0;
    float32x4_t v48 = &v47;
    uint64_t v49 = 0x2000000000;
    char v50 = 0;
    uint64_t v46 = 0;
    memset(v45, 0, sizeof(v45));
    v37[0] = MEMORY[0x263EF8330];
    v37[1] = 0x40000000;
    uint64_t v37[2] = ___Z31C3DConstraintApplyAvoidOccluderP18__C3DEngineContextP25__C3DConstraintControllerPKvP16__C3DModelTargetf_block_invoke;
    v37[3] = &unk_264006F50;
    long long v40 = &v47;
    unint64_t v41 = &v51;
    float32x4_t v38 = v55;
    float32x4_t v39 = v56;
    long long v42 = v57;
    uint64_t v43 = v17;
    size_t v44 = a3;
    C3DCullingSystemQueryMake((uint64_t)v37, (uint64_t)v45);
    *(void *)&v45[0] = *(void *)(v17 + 160);
    C3DCullingSystemRayIntersect(v20);
    if (*((unsigned char *)v48 + 24))
    {
      float32x4_t v36 = vmlaq_n_f32(v55, v35, v52[6] - *(float *)(v17 + 168));
      uint64_t Target = (const void *)C3DModelTargetGetTarget(a4);
      uint64_t TargetAddress = (void *)C3DModelTargetGetTargetAddress(a4);
      size_t v33 = C3DSizeOfBaseType(9);
      C3DSetValue(Target, TargetAddress, &v36, v33, 6, 0);
    }
    _Block_object_dispose(&v47, 8);
    _Block_object_dispose(&v51, 8);
    _Block_object_dispose(v57, 8);
    if (v59 != (unint64_t *)v60) {
      free(v59);
    }
  }
  return v19;
}

uint64_t C3DAppendFlattenNodeHierarchy<C3D::Array<__C3DNode *,10u,C3D::MallocAllocator>>(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>(a1, &v5);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 0x40000000;
  v4[2] = ___Z29C3DAppendFlattenNodeHierarchyIN3C3D5ArrayIP9__C3DNodeLj10ENS0_15MallocAllocatorEEEEvRT_S3__block_invoke;
  v4[3] = &__block_descriptor_tmp_34_1;
  v4[4] = a1;
  return C3DNodeApplyHierarchy(v5, (uint64_t)v4);
}

void ___Z31C3DConstraintApplyAvoidOccluderP18__C3DEngineContextP25__C3DConstraintControllerPKvP16__C3DModelTargetf_block_invoke(int8x16_t *a1, uint64_t a2, uint64_t a3)
{
  *(void *)((char *)&v82[1] + 4) = *MEMORY[0x263EF8340];
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v4 = a2;
    uint64_t v5 = (float32x4_t *)a1;
    uint64_t v6 = 0;
    BOOL v7 = *(unsigned char *)(*(void *)(a1[4].i64[0] + 8) + 24) != 0;
    float v8 = *(float *)(*(void *)(a1[4].i64[1] + 8) + 24);
    do
    {
      uint64_t v9 = *(float32x4_t **)(v4 + 8 * v6);
      uint64_t v10 = *(unsigned int **)(*(void *)(v5[5].i64[0] + 8) + 24);
      unint64_t v11 = *v10;
      if (!v11) {
        goto LABEL_11;
      }
      uint64_t v12 = (void *)*((void *)v10 + 1);
      uint64_t v13 = &v12[v11];
      do
      {
        unint64_t v14 = v11 >> 1;
        uint64_t v15 = &v12[v11 >> 1];
        unint64_t v17 = *v15;
        uint64_t v16 = v15 + 1;
        v11 += ~(v11 >> 1);
        if (v17 < (unint64_t)v9) {
          uint64_t v12 = v16;
        }
        else {
          unint64_t v11 = v14;
        }
      }
      while (v11);
      if (v12 == v13 || (unint64_t)v9 < *v12)
      {
LABEL_11:
        uint64_t Geometry = (__C3DGeometry *)C3DNodeGetGeometry(*(void *)(v4 + 8 * v6));
        WorldMatrifloat x = C3DNodeGetWorldMatrix(v9);
        v20.columns[0] = (simd_float4)*WorldMatrix;
        v20.columns[1] = (simd_float4)WorldMatrix[1];
        v20.columns[2] = (simd_float4)WorldMatrix[2];
        int8x16_t v21 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20.columns[2], (int32x4_t)v20.columns[2]), (int8x16_t)v20.columns[2], 0xCuLL), vnegq_f32((float32x4_t)v20.columns[1])), (float32x4_t)v20.columns[2], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20.columns[1], (int32x4_t)v20.columns[1]), (int8x16_t)v20.columns[1], 0xCuLL));
        float32x4_t v22 = vmulq_f32(*WorldMatrix, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL));
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0] >= 0.0)float v23 = 1.0; {
        else
        }
          float v23 = -1.0;
        float32x4_t v24 = vmulq_f32((float32x4_t)v20.columns[0], (float32x4_t)v20.columns[0]);
        float32x4_t v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1)));
        v25.f32[0] = sqrtf(v25.f32[0]);
        float32x4_t v26 = vmulq_f32((float32x4_t)v20.columns[1], (float32x4_t)v20.columns[1]);
        float32x4_t v27 = vmulq_f32((float32x4_t)v20.columns[2], (float32x4_t)v20.columns[2]);
        v25.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
        v25.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]);
        float32x4_t v28 = vmulq_n_f32(v25, v23);
        float v29 = v28.f32[2];
        if (v28.f32[0] >= v28.f32[2]) {
          float v29 = v28.f32[0];
        }
        if (v29 < v28.f32[1]) {
          float v30 = v28.f32[1];
        }
        else {
          float v30 = v29;
        }
        v20.columns[3] = (simd_float4)WorldMatrix[3];
        simd_float4x4 v83 = __invert_f4(v20);
        float32x4_t v59 = (float32x4_t)v83.columns[2];
        float32x4_t v61 = (float32x4_t)v83.columns[0];
        float32x4_t v57 = (float32x4_t)v83.columns[1];
        float32x4_t v58 = (float32x4_t)v83.columns[3];
        float32x4_t v55 = v5[2];
        float32x4_t v56 = v5[3];
        Renderinguint64_t Mesh = C3DGeometryGetRenderingMesh(Geometry);
        CFArrayRef ElementsCount = C3DMeshGetElementsCount((uint64_t)RenderingMesh);
        if (ElementsCount)
        {
          uint64_t v33 = (uint64_t)ElementsCount;
          Positionuint64_t Source = C3DMeshGetPositionSource((uint64_t)RenderingMesh, 0);
          if (C3DMeshSourceGetCount((uint64_t)PositionSource))
          {
            BOOL v54 = v7;
            uint64_t Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
            uint64_t v36 = v35;
            uint64_t ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex((uint64_t)RenderingMesh, 0, 0);
            if ((v36 & 0xFF00000000) != 0x900000000)
            {
              float32x4_t v38 = scn_default_log();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
                ___Z31C3DConstraintApplyAvoidOccluderP18__C3DEngineContextP25__C3DConstraintControllerPKvP16__C3DModelTargetf_block_invoke_cold_1(v81, v82, v38);
              }
            }
            if (v33 >= 1)
            {
              CFIndex v39 = 0;
              float32x4_t v40 = vaddq_f32(v58, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v57, *(float32x2_t *)v55.f32, 1), v61, v55.f32[0]), v59, v55, 2));
              float32x4_t v41 = vaddq_f32(v58, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v57, *(float32x2_t *)v56.f32, 1), v61, v56.f32[0]), v59, v56, 2));
              float32x4_t v42 = vsubq_f32(v41, v40);
              int32x4_t v43 = (int32x4_t)vmulq_f32(v42, v42);
              v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
              float32x2_t v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
              float32x2_t v45 = vmul_f32(v44, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)));
              float32x4_t v60 = vmulq_n_f32(v42, vmul_f32(v45, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v45, v45))).f32[0]);
              float32x4_t v62 = v40;
              float32x4_t v46 = vsubq_f32(v40, v41);
              float32x4_t v47 = vmulq_f32(v46, v46);
              float v48 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]);
              do
              {
                ElementAtuint64_t Index = C3DMeshGetElementAtIndex((uint64_t)RenderingMesh, v39, 0);
                uint64_t v80 = 0;
                long long v78 = 0u;
                long long v79 = 0u;
                long long v77 = 0u;
                C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v77);
                if ((BYTE10(v78) & 0xFA) != 0)
                {
                  char v50 = scn_default_log();
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)uint8_t buf = 0;
                    _os_log_impl(&dword_20B249000, v50, OS_LOG_TYPE_DEFAULT, "Warning: Occluder can only process triangles.", buf, 2u);
                  }
                }
                else
                {
                  v74[0] = v77;
                  v74[1] = v78;
                  v74[2] = v79;
                  uint64_t v75 = v80;
                  v65[0] = MEMORY[0x263EF8330];
                  v65[1] = 0x40000000;
                  v65[2] = ___Z31C3DConstraintApplyAvoidOccluderP18__C3DEngineContextP25__C3DConstraintControllerPKvP16__C3DModelTargetf_block_invoke_25;
                  void v65[3] = &unk_264006F28;
                  uint64_t v69 = Content;
                  uint64_t v70 = v36;
                  int v71 = v36 - 1;
                  float32x4_t v66 = v62;
                  float32x4_t v67 = v60;
                  float v72 = v48;
                  float v73 = v30;
                  __n128 v68 = (__n128)vextq_s8(a1[4], a1[4], 8uLL);
                  C3DIndicesContentEnumeratePrimitives((uint64_t *)v74, (uint64_t)v65, v68);
                }
                ++v39;
              }
              while (v33 != v39);
            }
            uint64_t v5 = (float32x4_t *)a1;
            uint64_t v4 = a2;
            uint64_t v3 = a3;
            if (*(float *)(*(void *)(a1[4].i64[1] + 8) + 24) < v8)
            {
              uint64_t v51 = *(void *)(a1[5].i64[1] + 144);
              if (v51)
              {
                if (C3DAvoidOccluderConstraintDelegateShouldAvoidOccluder(v51, (uint64_t)v9, a1[6].i64[0]))
                {
                  C3DAvoidOccluderConstraintDelegateDidAvoidOccluder(*(void *)(a1[5].i64[1] + 144), (uint64_t)v9, a1[6].i64[0]);
                }
                else
                {
                  *(unsigned char *)(*(void *)(a1[4].i64[0] + 8) + 24) = v54;
                  *(float *)(*(void *)(a1[4].i64[1] + 8) + 24) = v8;
                }
              }
            }
            BOOL v7 = *(unsigned char *)(*(void *)(a1[4].i64[0] + 8) + 24) != 0;
            float v8 = *(float *)(*(void *)(a1[4].i64[1] + 8) + 24);
          }
        }
      }
      ++v6;
    }
    while (v6 != v3);
  }
}

float32_t ___Z31C3DConstraintApplyAvoidOccluderP18__C3DEngineContextP25__C3DConstraintControllerPKvP16__C3DModelTargetf_block_invoke_25(float32x4_t *a1, uint64_t a2, __int32 *a3, unsigned int a4)
{
  if (a4 <= 2)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      ___Z18__slideWithinWorldP15__C3DConstraintP18__C3DEngineContextP18__C3DCullingSystemP9__C3DNodefDv3_fS7__block_invoke_9_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = a1[5].i64[0];
  int v15 = a1[5].u8[13];
  unsigned __int32 v16 = a1[6].u32[0];
  __int32 v17 = *a3;
  if (v16 < *a3) {
    __int32 v17 = a1[6].i32[0];
  }
  uint64_t v18 = v14 + (v17 * v15);
  v19.i64[0] = *(void *)v18;
  v19.i32[2] = *(_DWORD *)(v18 + 8);
  v19.i32[3] = 1.0;
  if (v16 >= a3[1]) {
    __int32 v20 = a3[1];
  }
  else {
    __int32 v20 = a1[6].i32[0];
  }
  uint64_t v21 = v14 + (v20 * v15);
  v22.i64[0] = *(void *)v21;
  v22.i32[2] = *(_DWORD *)(v21 + 8);
  v22.i32[3] = 1.0;
  if (v16 >= a3[2]) {
    unsigned __int32 v16 = a3[2];
  }
  uint64_t v23 = v14 + v16 * v15;
  v24.i64[0] = *(void *)v23;
  v24.i32[2] = *(_DWORD *)(v23 + 8);
  v24.i32[3] = 1.0;
  float32x4_t v25 = vsubq_f32(v22, v19);
  float32x4_t v26 = vsubq_f32(v24, v19);
  float32x4_t v27 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), (int8x16_t)v26, 0xCuLL), vnegq_f32(v25)), v26, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL));
  int32x4_t v28 = (int32x4_t)vmulq_f32(v27, v27);
  v28.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v28.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v28, 2), *(float32x2_t *)v28.i8)).u32[0];
  *(float32x2_t *)v26.f32 = vrsqrte_f32((float32x2_t)v28.u32[0]);
  *(float32x2_t *)v26.f32 = vmul_f32(*(float32x2_t *)v26.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v26.f32, *(float32x2_t *)v26.f32)));
  float32x4_t v29 = vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), (int8x16_t)v27, 0xCuLL), vmul_f32(*(float32x2_t *)v26.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v26.f32, *(float32x2_t *)v26.f32))).f32[0]);
  float32x4_t v30 = vmulq_f32(v19, v29);
  float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1)));
  float32x4_t v32 = a1[2];
  float32x4_t v33 = a1[3];
  float32x4_t v34 = vmulq_f32(v32, v29);
  float32x4_t v35 = vmulq_f32(v33, v29);
  float v36 = vdivq_f32(vsubq_f32(v31, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1)))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1)))).f32[0];
  if (v36 > 0.0 && v36 < a1[6].f32[1])
  {
    float32x4_t v40 = vmlaq_n_f32(v32, v33, v36);
    v39[0] = v19;
    v39[1] = v22;
    v39[2] = v24;
    v19.f32[0] = v36 * a1[6].f32[2];
    if (v19.f32[0] < *(float *)(*(void *)(a1[4].i64[0] + 8) + 24))
    {
      float v38 = v36;
      if (C3DTriangle3ContainsPoint(v39, &v40))
      {
        *(unsigned char *)(*(void *)(a1[4].i64[1] + 8) + 24) = 1;
        v19.f32[0] = v38 * a1[6].f32[2];
        *(_DWORD *)(*(void *)(a1[4].i64[0] + 8) + 24) = v19.i32[0];
      }
    }
  }
  return v19.f32[0];
}

__CFString *C3DConstraintAvoidOccluderCopyTargetPath(__C3DConstraint *a1)
{
  return @"transform";
}

uint64_t C3DConstraintCreateAvoidOccluder()
{
  if (C3DConstraintAvoidOccluderGetTypeID::onceToken != -1) {
    dispatch_once(&C3DConstraintAvoidOccluderGetTypeID::onceToken, &__block_literal_global_22_1);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DConstraintAvoidOccluderGetTypeID::typeID, 0xA0uLL);
  C3DConstraintInit(Instance);
  *(void *)(Instance + 160) = 1;
  *(_DWORD *)(Instance + 16_Block_object_dispose(&STACK[0x2A0], 8) = 925353388;
  *(unsigned char *)(Instance + 152) = 1;
  *(void *)(Instance + 8_Block_object_dispose(&STACK[0x2A0], 8) = C3DConstraintApplyAvoidOccluder;
  *(void *)(Instance + 96) = C3DConstraintAvoidOccluderCopyTargetPath;
  return Instance;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Triangle>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a2);
}

uint64_t ___Z29C3DAppendFlattenNodeHierarchyIN3C3D5ArrayIP9__C3DNodeLj10ENS0_15MallocAllocatorEEEEvRT_S3__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (a2 && C3DNodeShouldBePutInCullingSystem(a2)) {
    C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>(*(void *)(a1 + 32), &v4);
  }
  return 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **,false>(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = (unint64_t *)result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v22 = *(a2 - 1);
          unint64_t v23 = *v11;
          if (v22 < *v11)
          {
            *uint64_t v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          CFTypeRef result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11, v11 + 1, a2 - 1);
          break;
        case 4uLL:
          CFTypeRef result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11, v11 + 1, v11 + 2, a2 - 1);
          break;
        case 5uLL:
          CFTypeRef result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **,__C3DNode **>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    __int32 v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11, &v11[v15 >> 1], a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11 + 1, v17 - 1, a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11 + 2, &v11[v16 + 1], a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v17 - 1, v17, &v11[v16 + 1]);
      unint64_t v18 = *v11;
      *uint64_t v11 = *v17;
      *__int32 v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) >= *v11)
    {
      CFTypeRef result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,__C3DNode **,std::__less<void,void> &>(v11, (uint64_t *)a2);
      uint64_t v11 = (unint64_t *)result;
      goto LABEL_19;
    }
LABEL_14:
    float32x4_t v19 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,__C3DNode **,std::__less<void,void> &>(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v11, v19);
    uint64_t v11 = v19 + 1;
    CFTypeRef result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      CFTypeRef result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **,false>(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  float32x4_t v24 = v11 + 1;
  BOOL v26 = v11 == a2 || v24 == a2;
  if (a5)
  {
    if (!v26)
    {
      uint64_t v27 = 0;
      int32x4_t v28 = v11;
      do
      {
        unint64_t v30 = *v28;
        unint64_t v29 = v28[1];
        int32x4_t v28 = v24;
        if (v29 < v30)
        {
          uint64_t v31 = v27;
          while (1)
          {
            *(unint64_t *)((char *)v11 + v31 + _Block_object_dispose(&STACK[0x2A0], 8) = v30;
            if (!v31) {
              break;
            }
            unint64_t v30 = *(unint64_t *)((char *)v11 + v31 - 8);
            v31 -= 8;
            if (v29 >= v30)
            {
              float32x4_t v32 = (unint64_t *)((char *)v11 + v31 + 8);
              goto LABEL_50;
            }
          }
          float32x4_t v32 = v11;
LABEL_50:
          *float32x4_t v32 = v29;
        }
        float32x4_t v24 = v28 + 1;
        v27 += 8;
      }
      while (v28 + 1 != a2);
    }
  }
  else if (!v26)
  {
    do
    {
      unint64_t v34 = *v10;
      unint64_t v33 = v10[1];
      uint64_t v10 = v24;
      if (v33 < v34)
      {
        do
        {
          *float32x4_t v24 = v34;
          unint64_t v34 = *(v24 - 2);
          --v24;
        }
        while (v33 < v34);
        *float32x4_t v24 = v33;
      }
      float32x4_t v24 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a1;
  unint64_t v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    unint64_t v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unint64_t *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,__C3DNode **,std::__less<void,void> &>(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    unint64_t v5 = (uint64_t *)(a1 + 1);
    do
    {
      unint64_t v3 = (unint64_t *)v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    unint64_t v3 = a1;
    do
    {
      unint64_t v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
      unint64_t v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < (unint64_t *)a2)
  {
    unint64_t v7 = *v3;
    unint64_t v8 = *a2;
    do
    {
      *unint64_t v3 = v8;
      *a2 = v7;
      do
      {
        unint64_t v9 = v3[1];
        ++v3;
        unint64_t v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        unint64_t v10 = *--a2;
        unint64_t v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - 1) = v2;
  return v3;
}

unint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,__C3DNode **,std::__less<void,void> &>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  do
    unint64_t v4 = a1[++v2];
  while (v4 < v3);
  unint64_t v5 = &a1[v2];
  unint64_t v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      unint64_t v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      unint64_t v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    unint64_t v9 = *a2;
    unint64_t v10 = &a1[v2];
    uint64_t v11 = a2;
    do
    {
      *unint64_t v10 = v9;
      *uint64_t v11 = v4;
      do
      {
        unint64_t v12 = v10[1];
        ++v10;
        unint64_t v4 = v12;
      }
      while (v12 < v3);
      do
      {
        unint64_t v13 = *--v11;
        unint64_t v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    unint64_t v6 = v10 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  unint64_t *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 1);
      unint64_t v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a1 + 1, a1 + 2);
      unint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    unint64_t v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 8;
        if (v14 == 8) {
          break;
        }
        unint64_t v13 = *(unint64_t *)((char *)a1 + v14 - 16);
        v14 -= 8;
        if (v12 >= v13)
        {
          unint64_t v16 = (unint64_t *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      unint64_t v16 = a1;
LABEL_12:
      *unint64_t v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a2, a3);
  unint64_t v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    unint64_t v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      unint64_t v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(a1, a2, a3, a4);
  unint64_t v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    unint64_t v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      unint64_t v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        unint64_t v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **,__C3DNode **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = v6;
    if (v6 != a3)
    {
      unint64_t v14 = v6;
      do
      {
        unint64_t v15 = *v14;
        if (*v14 < *a1)
        {
          *unint64_t v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      unint64_t v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = *a1;
        float32x4_t v19 = a1;
        do
        {
          char v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            unint64_t v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            unint64_t v22 = *v20;
            if (*v20 >= v20[1])
            {
              uint64_t v17 = v21;
            }
            else
            {
              unint64_t v22 = v20[1];
              ++v20;
            }
          }
          *float32x4_t v19 = v22;
          float32x4_t v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *char v20 = v18;
        }
        else
        {
          *char v20 = *v6;
          unint64_t *v6 = v18;
          uint64_t v23 = (char *)v20 - (char *)a1 + 8;
          if (v23 >= 9)
          {
            unint64_t v24 = (((unint64_t)v23 >> 3) - 2) >> 1;
            float32x4_t v25 = &a1[v24];
            unint64_t v26 = *v25;
            unint64_t v27 = *v20;
            if (*v25 < *v20)
            {
              do
              {
                *char v20 = v26;
                char v20 = v25;
                if (!v24) {
                  break;
                }
                unint64_t v24 = (v24 - 1) >> 1;
                float32x4_t v25 = &a1[v24];
                unint64_t v26 = *v25;
              }
              while (*v25 < v27);
              *char v20 = v27;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,__C3DNode **>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (unint64_t *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        unint64_t v10 = *v8;
      }
      else
      {
        unint64_t v10 = *v8;
        if (*v8 < v8[1])
        {
          unint64_t v10 = v8[1];
          ++v8;
          uint64_t v7 = v9;
        }
      }
      unint64_t v11 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v12 = (2 * v7) | 1;
          uint64_t v8 = (unint64_t *)(result + 8 * v12);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            unint64_t v10 = *v8;
            uint64_t v7 = v12;
          }
          else
          {
            unint64_t v10 = *v8;
            if (*v8 >= v8[1])
            {
              uint64_t v7 = v12;
            }
            else
            {
              unint64_t v10 = v8[1];
              ++v8;
            }
          }
        }
        while (v10 >= v11);
        *a4 = v11;
      }
    }
  }
  return result;
}

uint64_t _loadPVRTC(uint64_t a1)
{
  kdebug_trace();
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _applyCIFilter_cold_2(v2);
    }
  }
  CFDataRef Data = (const __CFData *)C3DImageGetData(a1);
  if (Data)
  {
    CFDataRef v4 = Data;
    CFRetain(Data);
  }
  else
  {
    uint64_t URL = C3DImageGetURL(a1);
    if (!URL || (CFDataRef v4 = (const __CFData *)C3DCreateDataWithContentOfURL(URL, 0)) == 0)
    {
      uint64_t v15 = 0;
      goto LABEL_23;
    }
  }
  if (CFDataGetLength(v4) >= 52)
  {
    BytePtr = CFDataGetBytePtr(v4);
    if (*((_DWORD *)BytePtr + 11) == 559044176)
    {
      uint64_t v6 = BytePtr;
      int v7 = *((_DWORD *)BytePtr + 4);
      if ((v7 & 0xFE) == 0x18)
      {
        int v8 = *((_DWORD *)BytePtr + 4);
        _C3DImageDeleteTextureRawDataIfNeeded(a1);
        int v9 = v7 & 0x8000 | (*((_DWORD *)v6 + 10) != 0);
        uint32x2_t v33 = *(uint32x2_t *)(v6 + 4);
        _C3DImageCreateTextureRawData(a1, 1, v9 != 0, COERCE_DOUBLE(vrev64_s32((int32x2_t)vcvt_f32_u32(v33))));
        TextureRawCFDataRef Data = C3DImageGetTextureRawData(a1);
        uint64_t v11 = TextureRawData;
        if (v8 == 24)
        {
          if (v9) {
            int v18 = 35843;
          }
          else {
            int v18 = 35841;
          }
          *(_DWORD *)(TextureRawData + 24) = v18;
          if (v9) {
            int v13 = 164;
          }
          else {
            int v13 = 160;
          }
          char v14 = 8;
        }
        else
        {
          if (v8 != 25) {
            goto LABEL_32;
          }
          if (v9) {
            int v12 = 35842;
          }
          else {
            int v12 = 35840;
          }
          *(_DWORD *)(TextureRawData + 24) = v12;
          if (v9) {
            int v13 = 166;
          }
          else {
            int v13 = 162;
          }
          char v14 = 4;
        }
        *(_DWORD *)(TextureRawData + 36) = v13;
        *(unsigned char *)(TextureRawData + 7) = v14;
        *(unsigned char *)(TextureRawData + _Block_object_dispose(&STACK[0x2A0], 8) = 4;
LABEL_32:
        unsigned int v19 = *((_DWORD *)v6 + 5);
        *(unsigned char *)(TextureRawData + 4) = *((_DWORD *)v6 + 6);
        uint64_t v15 = 1;
        if (v19)
        {
          CFDataRef v32 = v4;
          unsigned int v20 = 0;
          uint64_t v21 = v6 + 52;
          if (v8 == 25) {
            char v22 = 2;
          }
          else {
            char v22 = 1;
          }
          unsigned int v23 = v33.i32[0];
          unsigned int v24 = v33.u32[1];
          do
          {
            unsigned int v25 = *(unsigned __int8 *)(v11 + 7);
            unsigned int v26 = *(unsigned __int8 *)(v11 + 8);
            int v27 = v26 * v25;
            unsigned int v28 = v23 / v26;
            unsigned int v29 = v24 / v25;
            if (v29 <= 2) {
              unsigned int v29 = 2;
            }
            if (v28 <= 2) {
              unsigned int v28 = 2;
            }
            unsigned int v30 = v29 * v28 * ((v27 << v22) >> 3);
            CFDataRef v31 = CFDataCreate(0, &v21[v20], v30);
            CFArrayAppendValue(*(CFMutableArrayRef *)(v11 + 40), v31);
            CFRelease(v31);
            v20 += v30;
            if (v24 <= 1) {
              unsigned int v24 = 1;
            }
            else {
              v24 >>= 1;
            }
            if (v23 <= 1) {
              unsigned int v23 = 1;
            }
            else {
              v23 >>= 1;
            }
          }
          while (v20 < v19);
          uint64_t v15 = 1;
          CFDataRef v4 = v32;
        }
        goto LABEL_19;
      }
    }
  }
  uint64_t v15 = 0;
LABEL_19:
  CFRelease(v4);
LABEL_23:
  kdebug_trace();
  return v15;
}

C3D::RenderPass *C3D::MBFinalBlurPass::MBFinalBlurPass(C3D::RenderPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  uint64_t result = C3D::RenderPass::RenderPass(a1, a2, a3);
  *(void *)uint64_t result = &unk_26BF6D4E0;
  *((void *)result + 30) = a4;
  return result;
}

const char *C3D::MBFinalBlurPass::name(C3D::MBFinalBlurPass *this)
{
  return "MBFinalBlurPass";
}

double C3D::MBFinalBlurPass::setup(C3D::MBFinalBlurPass *this)
{
  CFAllocatorRef v1 = this;
  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(v1, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::MBFinalBlurPass *)((char *)v1 + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::MBFinalBlurPass *)((char *)v1 + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "VELOCITY";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::MBFinalBlurPass *)((char *)v1 + 32), 2u) + _Block_object_dispose(&STACK[0x2A0], 8) = "MB-TileMax";
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::MBFinalBlurPass *)((char *)v1 + 32), 0);
  *(void *)(v2 + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(unsigned char *)(v2 + 65) = 0;
  do
  {
    unint64_t v3 = v1;
    CFAllocatorRef v1 = (C3D::MBFinalBlurPass *)*((void *)v1 + 1);
  }
  while (v1);
  C3D::Pass::parentColorDesc(v3, (uint64_t)&v5);
  double result = *(double *)&v5;
  *(_OWORD *)(v2 + 16) = v5;
  *(_DWORD *)(v2 + 32) = v6;
  return result;
}

uint64_t C3D::MBFinalBlurPass::compile(C3D::MBFinalBlurPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  unint64_t v3 = *(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128);
  uint64_t v4 = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex((C3D::MBFinalBlurPass *)((char *)this + 32), 0) + 28);
  unint64_t v5 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::MBFinalBlurPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v4) ^ ((0xC6A4A7935BD1E995 * v4) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(v3, (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47));
  *((void *)this + 31) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::MBFinalBlurPass::execute(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  long long v14 = xmmword_20B5CD060;
  uint64_t v4 = (C3D::PassDescriptor *)(a1 + 4);
  uint64_t v5 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(a1 + 4), 0);
  uint64_t v6 = a1[31];
  if (*(_DWORD *)(v6 + 32) == *(unsigned __int16 *)(v5 + 16)
    && (uint64_t v7 = C3D::PassDescriptor::outputAtIndex(v4, 0),
        uint64_t v6 = a1[31],
        *(_DWORD *)(v6 + 36) == *(unsigned __int16 *)(v7 + 18)))
  {
    uint64_t v8 = v6 + 16;
  }
  else
  {
    uint64_t v8 = v6 + 24;
  }
  uint64_t v9 = objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v8), "state", v14);
  if (*(void *)(v3 + 3376) != v9)
  {
    *(void *)(v3 + 3376) = v9;
    [*(id *)(v3 + 3392) setRenderPipelineState:v9];
  }
  SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v3, &v14, 0x10uLL, 0);
  SCNMTLRenderCommandEncoder::setFragmentBuffer(v3, *(void *)(a1[30] + 40), *(void *)(a1[30] + 48), 0);
  unint64_t v10 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v10, 0);
  uint64_t v11 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 2u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v11, 1uLL);
  int v12 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v12, 2uLL);
  SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v3);
  *(_DWORD *)(a1[31] + 32) = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v4, 0) + 16);
  uint64_t result = C3D::PassDescriptor::outputAtIndex(v4, 0);
  *(_DWORD *)(a1[31] + 36) = *(unsigned __int16 *)(result + 18);
  return result;
}

void C3D::MBFinalBlurPassResource::~MBFinalBlurPassResource(C3D::MBFinalBlurPassResource *this)
{
  *(void *)this = &unk_26BF6E430;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E430;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

uint64_t __C3DDeformerStackGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DDeformerStackGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DDeformerStackCreate(uint64_t a1)
{
  if (C3DDeformerStackGetTypeID_onceToken != -1) {
    dispatch_once(&C3DDeformerStackGetTypeID_onceToken, &__block_literal_global_42);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DDeformerStackGetTypeID_typeID, 0x30uLL);
  *(void *)(Instance + 16) = a1;
  uint64_t v3 = *(void *)(Instance + 24);
  if (v3 != C3DNodeGetGeometry(a1))
  {
    uint64_t v4 = *(const void **)(Instance + 24);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(Instance + 24) = 0;
    }
    uint64_t Geometry = (const void *)C3DNodeGetGeometry(a1);
    if (Geometry) {
      uint64_t Geometry = CFRetain(Geometry);
    }
    *(void *)(Instance + 24) = Geometry;
  }
  return Instance;
}

uint64_t C3DDeformerStackCreateCopy(void *a1, uint64_t a2)
{
  if (C3DDeformerStackGetTypeID_onceToken != -1) {
    dispatch_once(&C3DDeformerStackGetTypeID_onceToken, &__block_literal_global_42);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DDeformerStackGetTypeID_typeID, 0x30uLL);
  *(void *)(Instance + 16) = a2;
  CFTypeRef v5 = *(CFTypeRef *)(Instance + 24);
  CFTypeRef v6 = (CFTypeRef)a1[3];
  if (v5 != v6)
  {
    if (v5)
    {
      CFRelease(v5);
      *(void *)(Instance + 24) = 0;
      CFTypeRef v6 = (CFTypeRef)a1[3];
    }
    if (v6) {
      CFTypeRef v6 = CFRetain(v6);
    }
    *(void *)(Instance + 24) = v6;
  }
  CFTypeRef v7 = *(CFTypeRef *)(Instance + 32);
  CFTypeRef v8 = (CFTypeRef)a1[4];
  if (v7 != v8)
  {
    if (v7)
    {
      CFRelease(*(CFTypeRef *)(Instance + 32));
      *(void *)(Instance + 32) = 0;
      CFTypeRef v8 = (CFTypeRef)a1[4];
    }
    if (v8) {
      CFTypeRef v8 = CFRetain(v8);
    }
    *(void *)(Instance + 32) = v8;
  }
  CFTypeRef v9 = *(CFTypeRef *)(Instance + 40);
  CFTypeRef v10 = (CFTypeRef)a1[5];
  if (v9 != v10)
  {
    if (v9)
    {
      CFRelease(*(CFTypeRef *)(Instance + 40));
      *(void *)(Instance + 40) = 0;
      CFTypeRef v10 = (CFTypeRef)a1[5];
    }
    if (v10) {
      CFTypeRef v10 = CFRetain(v10);
    }
    *(void *)(Instance + 40) = v10;
  }
  CFTypeRef v11 = *(CFTypeRef *)(Instance + 48);
  CFTypeRef v12 = (CFTypeRef)a1[6];
  if (v11 != v12)
  {
    if (v11)
    {
      CFRelease(*(CFTypeRef *)(Instance + 48));
      *(void *)(Instance + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
      CFTypeRef v12 = (CFTypeRef)a1[6];
    }
    if (v12) {
      CFTypeRef v12 = CFRetain(v12);
    }
    *(void *)(Instance + 4_Block_object_dispose(&STACK[0x2A0], 8) = v12;
  }
  CFTypeRef v13 = *(CFTypeRef *)(Instance + 56);
  CFTypeRef v14 = (CFTypeRef)a1[7];
  if (v13 != v14)
  {
    if (v13)
    {
      CFRelease(*(CFTypeRef *)(Instance + 56));
      *(void *)(Instance + 56) = 0;
      CFTypeRef v14 = (CFTypeRef)a1[7];
    }
    if (v14) {
      CFTypeRef v14 = CFRetain(v14);
    }
    *(void *)(Instance + 56) = v14;
  }
  return Instance;
}

BOOL C3DDeformerStackIsEmpty(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return !a1[4] && !a1[5] && !a1[6] && a1[7] == 0;
}

BOOL C3DDeformerStackWantsGPU(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (C3DDeformerStackIsEmpty((void *)a1)) {
    return 0;
  }
  if (*(void *)(a1 + 32)) {
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (!v11) {
    return 1;
  }
  return C3DSkinnerGetEffectiveCalculationMode(v11, *(__C3DGeometry **)(a1 + 24)) == 2;
}

uint64_t C3DDeformerStackGetBaseGeometry(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 24);
}

void C3DDeformerStackSetBaseGeometry(void *a1, __C3DGeometry *cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = (__C3DGeometry *)a1[3];
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      a1[3] = 0;
    }
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    a1[3] = v13;
    uint64_t v14 = a1[4];
    if (v14) {
      C3DMorpherSetBaseGeometry(v14, cf);
    }
    uint64_t v15 = a1[5];
    if (v15) {
      C3DSkinnerInputGeometryDidChange(v15);
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackDidChange", a1, 0, 1u);
  }
}

uint64_t C3DDeformerStackGetMorpher(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 32);
}

void C3DDeformerStackSetMorpher(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 32);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 32) = 0;
    }
    if (cf)
    {
      *(void *)(a1 + 32) = CFRetain(cf);
      C3DMorpherSetBaseGeometry((uint64_t)cf, *(__C3DGeometry **)(a1 + 24));
    }
    else
    {
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v13 = *(void *)(a1 + 40);
    if (v13)
    {
      C3DSkinnerInputGeometryDidChange(*(void *)(a1 + 40));
      uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial(v13);
      if (OverrideMaterial) {
        C3DSkinSetInfluencingMorpher(OverrideMaterial, cf);
      }
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackDidChange", (const void *)a1, 0, 1u);
  }
}

uint64_t C3DDeformerStackGetSkinner(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 40);
}

void C3DDeformerStackSetSkinner(void *a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef v12 = (CFTypeRef)a1[5];
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      a1[5] = 0;
    }
    if (cf)
    {
      a1[5] = CFRetain(cf);
      C3DSkinnerInputGeometryDidChange((uint64_t)cf);
      uint64_t v13 = (const void *)a1[4];
      if (v13)
      {
        uint64_t OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)cf);
        if (OverrideMaterial) {
          C3DSkinSetInfluencingMorpher(OverrideMaterial, v13);
        }
      }
    }
    else
    {
      a1[5] = 0;
    }
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackDidChange", a1, 0, 1u);
  }
}

uint64_t C3DDeformerStackGetPostMorphingDeformers(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

void C3DDeformerStackSetPostMorphingDeformers(void *a1, const __CFArray *cf)
{
  CFArrayRef v2 = cf;
  if (cf && !CFArrayGetCount(cf)) {
    CFArrayRef v2 = 0;
  }
  CFArrayRef v4 = (const __CFArray *)a1[6];
  if (v4 != v2)
  {
    if (v4)
    {
      CFRelease(v4);
      a1[6] = 0;
    }
    if (v2) {
      CFTypeRef v5 = CFRetain(v2);
    }
    else {
      CFTypeRef v5 = 0;
    }
    a1[6] = v5;
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackDidChange", a1, 0, 1u);
    uint64_t v7 = a1[2];
    C3DNodeBoundingBoxDidUpdate(v7);
  }
}

uint64_t C3DDeformerStackGetPostSkinningDeformers(uint64_t a1)
{
  if (!a1)
  {
    CFArrayRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      _C3DStackCFFinalize_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 56);
}

void C3DDeformerStackSetPostSkinningDeformers(void *a1, const __CFArray *cf)
{
  CFArrayRef v2 = cf;
  if (cf && !CFArrayGetCount(cf)) {
    CFArrayRef v2 = 0;
  }
  CFArrayRef v4 = (const __CFArray *)a1[7];
  if (v4 != v2)
  {
    if (v4)
    {
      CFRelease(v4);
      a1[7] = 0;
    }
    if (v2) {
      CFTypeRef v5 = CFRetain(v2);
    }
    else {
      CFTypeRef v5 = 0;
    }
    a1[7] = v5;
    Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackDidChange", a1, 0, 1u);
    uint64_t v7 = a1[2];
    C3DNodeBoundingBoxDidUpdate(v7);
  }
}

void C3DDeformerStackEnumerateDependencyStacks(uint64_t a1, uint64_t a2)
{
  CFArrayRef v4 = *(const __CFArray **)(a1 + 48);
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  void v7[2] = __C3DDeformerStackEnumerateDependencyStacks_block_invoke;
  v7[3] = &unk_264006F98;
  v7[4] = a2;
  C3DCFArrayApplyBlock(v4, (uint64_t)v7);
  CFArrayRef v5 = *(const __CFArray **)(a1 + 56);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  long long v6[2] = __C3DDeformerStackEnumerateDependencyStacks_block_invoke_2;
  v6[3] = &unk_264006F98;
  v6[4] = a2;
  C3DCFArrayApplyBlock(v5, (uint64_t)v6);
}

uint64_t __C3DDeformerStackEnumerateDependencyStacks_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  v5[2] = ____C3DDeformerStackEnumerateDependencyStacks_block_invoke;
  v5[3] = &unk_264006FE8;
  void v5[4] = v3;
  char v6 = 0;
  return [a3 _enumerateDependencyNodesUsingBlock:v5];
}

uint64_t __C3DDeformerStackEnumerateDependencyStacks_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  v5[2] = ____C3DDeformerStackEnumerateDependencyStacks_block_invoke;
  v5[3] = &unk_264006FE8;
  void v5[4] = v3;
  char v6 = 0;
  return [a3 _enumerateDependencyNodesUsingBlock:v5];
}

BOOL C3DDeformerStackGetLocalBoundingBox(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  CFTypeRef v12 = &v11;
  uint64_t v13 = 0x2020000000;
  char v14 = 0;
  CFArrayRef v4 = *(const __CFArray **)(a1 + 56);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = __C3DDeformerStackGetLocalBoundingBox_block_invoke;
  v10[3] = &unk_264006FC0;
  void v10[4] = &v11;
  void v10[5] = a2;
  C3DCFArrayApplyBlock(v4, (uint64_t)v10);
  if (!*((unsigned char *)v12 + 24))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    if (!v5)
    {
      CFArrayRef v8 = *(const __CFArray **)(a1 + 48);
      v9[0] = MEMORY[0x263EF8330];
      v9[1] = 3221225472;
      v9[2] = __C3DDeformerStackGetLocalBoundingBox_block_invoke_2;
      v9[3] = &unk_264006FC0;
      v9[4] = &v11;
      void v9[5] = a2;
      C3DCFArrayApplyBlock(v8, (uint64_t)v9);
      BOOL v6 = *((unsigned char *)v12 + 24) != 0;
      goto LABEL_5;
    }
    C3DSkinnerGetBoundingBox(v5, *(float32x4_t **)(a1 + 16), a2);
  }
  BOOL v6 = 1;
LABEL_5:
  _Block_object_dispose(&v11, 8);
  return v6;
}

void sub_20B368548(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __C3DDeformerStackGetLocalBoundingBox_block_invoke(uint64_t result, uint64_t a2, void *a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v3 = result;
    uint64_t result = [a3 _getDeformedMeshBoundingBox:*(void *)(result + 40)];
    *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __C3DDeformerStackGetLocalBoundingBox_block_invoke_2(uint64_t result, uint64_t a2, void *a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v3 = result;
    uint64_t result = [a3 _getDeformedMeshBoundingBox:*(void *)(result + 40)];
    *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

void _C3DDeformerStackCFFinalize(void *a1)
{
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, @"kC3DNotificationDeformerStackWillDie", a1, 0, 1u);
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  CFArrayRef v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  uint64_t v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  BOOL v6 = (const void *)a1[6];
  if (v6)
  {
    CFRelease(v6);
    a1[6] = 0;
  }
  uint64_t v7 = (const void *)a1[7];
  if (v7)
  {
    CFRelease(v7);
    a1[7] = 0;
  }
}

CFStringRef _C3DDeformerStackCFCopyDebugDescription(void *a1)
{
  IsEmptfloat y = C3DDeformerStackIsEmpty(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (IsEmpty) {
    return CFStringCreateWithFormat(v3, 0, @"<C3DDeformerStack %p>", a1);
  }
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"<C3DDeformerStack %p (geometry: %p)\n", a1, a1[3]);
  if (a1[4]) {
    CFStringAppendFormat(Mutable, 0, @"  morpher: %p\n", a1[4]);
  }
  CFArrayRef v6 = (const __CFArray *)a1[6];
  if (v6)
  {
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 3221225472;
    v9[2] = ___C3DDeformerStackCFCopyDebugDescription_block_invoke;
    v9[3] = &__block_descriptor_40_e13_v24__0q8r_v16l;
    v9[4] = Mutable;
    C3DCFArrayApplyBlock(v6, (uint64_t)v9);
  }
  if (a1[5]) {
    CFStringAppendFormat(Mutable, 0, @"  skinner: %p\n", a1[5]);
  }
  CFArrayRef v7 = (const __CFArray *)a1[7];
  if (v7)
  {
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 3221225472;
    float32x4_t v8[2] = ___C3DDeformerStackCFCopyDebugDescription_block_invoke_2;
    v8[3] = &__block_descriptor_40_e13_v24__0q8r_v16l;
    v8[4] = Mutable;
    C3DCFArrayApplyBlock(v7, (uint64_t)v8);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

void C3D::BloomDownSamplePass::BloomDownSamplePass(C3D::CustomPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::CustomPass::CustomPass(a1, a2, a3, 0);
  *uint64_t v5 = &unk_26BF6DC30;
  v5[16] = a4;
}

const char *C3D::BloomDownSamplePass::name(C3D::BloomDownSamplePass *this)
{
  return "BloomDownSamplePass";
}

uint64_t C3D::BloomDownSamplePass::setup(C3D::BloomDownSamplePass *this)
{
  uint64_t v1 = this;
  C3D::Pass::setInputCount(this, 1u);
  C3D::Pass::setOutputCount(v1, 1u);
  uint64_t v1 = (C3D::Pass *)((char *)v1 + 32);
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex(v1, 0);
  *(_WORD *)(v2 + 66) |= 4u;
  uint64_t v3 = C3D::PassDescriptor::inputAtIndex(v1, 0);
  *(_WORD *)(v3 + 66) |= 0x80u;
  uint64_t result = C3D::PassDescriptor::inputAtIndex(v1, 0);
  *(_WORD *)(result + 66) = *(_WORD *)(result + 66) & 0xFFFC | 1;
  return result;
}

uint64_t C3D::BloomDownSamplePass::compile(C3D::BloomDownSamplePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  uint64_t v3 = -[SCNMTLRenderContext resourceManager](RenderContext);
  [(id)-[SCNMTLResourceManager libraryManager](v3) frameworkLibrary];
  uint64_t v4 = (*(uint64_t (**)(C3D::BloomDownSamplePass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v4);
  *((void *)this + 17) = result;
  if (!result) {
    operator new();
  }
  return result;
}

void C3D::BloomDownSamplePass::execute(uint64_t *a1, void **a2)
{
  uint64_t v15 = a2;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(a1[2]);
  uint64_t v4 = -[SCNMTLRenderContext frameConstantBufferPool](RenderContext);
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(a1[2]);
  Zero = (char *)C3DStackAllocatorAllocateZero(StackAllocator, 0xD70uLL);
  id v16 = objc_alloc_init(MEMORY[0x263F129A0]);
  CFArrayRef v7 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  uint64_t v8 = objc_msgSend(v7, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v7, "pixelFormat"), objc_msgSend(v7, "textureType"), 0, 1, 0, 1);
  uint64_t v9 = (void *)v8;
  if (*(int *)(a1[16] + 24) < 2)
  {
    CFTypeRef v12 = (void *)v8;
  }
  else
  {
    int v10 = 0;
    int v11 = 0;
    do
    {
      CFTypeRef v12 = objc_msgSend(v7, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v7, "pixelFormat", v15), objc_msgSend(v7, "textureType"), (v10 + 1), 1, 0, 1);
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v16, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", v12);
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v16, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setResolveTexture:", 0);
      uint64_t v13 = *v15;
      bzero(Zero, 0xD70uLL);
      *((_DWORD *)Zero + 16) = 1;
      Zero[72] = 1;
      *((void *)Zero + 423) = v13;
      *((void *)Zero + 424) = [v13 renderCommandEncoderWithDescriptor:v16];
      *((void *)Zero + 425) = v4;
      *(_OWORD *)(Zero + _Block_object_dispose(&STACK[0x2A0], 8) = 0u;
      *(_OWORD *)(Zero + 24) = 0u;
      uint64_t v14 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[17] + 16) state];
      if (*((void *)Zero + 422) != v14)
      {
        *((void *)Zero + 422) = v14;
        [*((id *)Zero + 424) setRenderPipelineState:v14];
      }
      SCNMTLRenderCommandEncoder::setFragmentTexture((uint64_t)Zero, v9, 0);
      SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)Zero);
      SCNMTLRenderCommandEncoder::endEncoding((SCNMTLRenderCommandEncoder *)Zero);

      int v10 = ++v11;
      uint64_t v9 = v12;
    }
    while (*(_DWORD *)(a1[16] + 24) - 1 > v11);
  }
}

void C3D::BloomDownSamplePassResource::~BloomDownSamplePassResource(C3D::BloomDownSamplePassResource *this)
{
  *(void *)this = &unk_26BF6E590;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E590;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

void __StoreTexture(uint64_t a1, void *key, uint64_t a3, const void *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  id v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a3 && (unsigned int v24 = scn_default_log(), os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)))
  {
    C3DTextureSamplerSetAnisotropy_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    if (a4) {
      goto LABEL_11;
    }
  }
  else if (a4)
  {
    goto LABEL_11;
  }
  CFDataRef v32 = scn_default_log();
  if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextApplyTextureSampler_cold_2(v32, v33, v34, v35, v36, v37, v38, v39);
  }
LABEL_11:
  unsigned int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (!Value)
  {
    unsigned int Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), key, Value);
    CFRelease(Value);
    if (a3) {
      goto LABEL_13;
    }
LABEL_15:
    int32x4_t v43 = 0;
    goto LABEL_16;
  }
  if (!a3) {
    goto LABEL_15;
  }
LABEL_13:
  BOOL v41 = C3DTextureSamplerUseMipmaps(a3);
  Imageint Type = C3DImageGetImageType((uint64_t)key);
  int32x4_t v43 = (const void *)((int)(2 * C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(ImageType)) | (unint64_t)v41);
LABEL_16:
  CFDictionarySetValue((CFMutableDictionaryRef)Value, v43, a4);
}

uint64_t _C3DResourceManagerCFFinalize(uint64_t a1)
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, @"kC3DNotificationMeshSourceWillDie", 0);
  uint64_t v3 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v3, (const void *)a1, @"kC3DNotificationMeshElementWillDie", 0);
  uint64_t v4 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v4, (const void *)a1, @"kC3DNotificationImageWillDie", 0);
  uint64_t v5 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v5, (const void *)a1, @"kC3DNotificationImageProxyWillDie", 0);
  CFArrayRef v6 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v6, (const void *)a1, @"kC3DNotificationProgramWillDie", 0);
  CFArrayRef v7 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v7, (const void *)a1, @"kC3DNotificationMeshWillDie", 0);
  C3DResourceManagerFlush(a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  uint64_t v8 = *(const void **)(a1 + 40);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 56);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 32);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 16);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v13 = *(const void **)(a1 + 80);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v14 = *(const void **)(a1 + 24);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v15 = *(const void **)(a1 + 224);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 224) = 0;
  }
  id v16 = *(const void **)(a1 + 232);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 232) = 0;
  }
  uint64_t v17 = *(const void **)(a1 + 64);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 64) = 0;
  }
  dispatch_resume(*(dispatch_object_t *)(a1 + 216));
  dispatch_release(*(dispatch_object_t *)(a1 + 216));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 88));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 88));

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 152));
}

CFStringRef _C3DResourceManagerCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DResourceManager>");
}

CFStringRef _C3DResourceManagerCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DResourceManager>");
}

uint64_t __C3DResourceManagerGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DResourceManagerGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DResourceManagerCreate()
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (C3DResourceManagerGetTypeID_onceToken != -1) {
    dispatch_once(&C3DResourceManagerGetTypeID_onceToken, &__block_literal_global_43);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DResourceManagerGetTypeID_typeID, 0xE0uLL);
  if (Instance)
  {
    CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
    *(void *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
    *(void *)(Instance + 32) = CFDictionaryCreateMutable(v1, 0, 0, v2);
    *(void *)(Instance + 24) = CFDictionaryCreateMutable(v1, 0, 0, v2);
    *(_DWORD *)(Instance + 72) = 0;
    *(void *)(Instance + 80) = C3DListCreate();
    *(void *)(Instance + 40) = CFDictionaryCreateMutable(v1, 0, 0, v2);
    *(void *)(Instance + 4_Block_object_dispose(&STACK[0x2A0], 8) = CFDictionaryCreateMutable(v1, 0, 0, v2);
    *(void *)(Instance + 56) = CFDictionaryCreateMutable(v1, 0, 0, v2);
    uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
    *(void *)(Instance + 64) = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], v2);
    v12.__sig = 0;
    *(void *)v12.__opaque = 0;
    pthread_mutexattr_init(&v12);
    pthread_mutexattr_settype(&v12, 2);
    pthread_mutex_init((pthread_mutex_t *)(Instance + 88), &v12);
    pthread_mutex_init((pthread_mutex_t *)(Instance + 152), &v12);
    pthread_mutexattr_destroy(&v12);
    uint64_t v4 = dispatch_queue_create("com.apple.scenekit.resourceManagerDeletionQueue", 0);
    *(void *)(Instance + 216) = v4;
    dispatch_suspend(v4);
    *(void *)(Instance + 224) = CFDictionaryCreateMutable(v1, 0, v3, v2);
    *(void *)(Instance + 232) = CFArrayCreateMutable(v1, 0, MEMORY[0x263EFFF70]);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(LocalCenter, (const void *)Instance, (CFNotificationCallback)__MeshSourceWillDie, @"kC3DNotificationMeshSourceWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    CFArrayRef v6 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v6, (const void *)Instance, (CFNotificationCallback)__MeshElementWillDie, @"kC3DNotificationMeshElementWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    CFArrayRef v7 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v7, (const void *)Instance, (CFNotificationCallback)__ImageWillDie, @"kC3DNotificationImageWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    uint64_t v8 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v8, (const void *)Instance, (CFNotificationCallback)__ImageProxyWillDie, @"kC3DNotificationImageProxyWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    uint64_t v9 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v9, (const void *)Instance, (CFNotificationCallback)__ProgramWillDie, @"kC3DNotificationProgramWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    uint64_t v10 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v10, (const void *)Instance, (CFNotificationCallback)__MeshWillDie, @"kC3DNotificationMeshWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  return Instance;
}

uint64_t __MeshSourceWillDie(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = C3DGenericSourceIsPrimary(a4);
  if (result)
  {
    uint64_t result = C3DMeshSourceGetData(a4);
    if (result)
    {
      CFArrayRef v7 = (void *)result;
      uint64_t result = CFDataGetLength((CFDataRef)result);
      if (result)
      {
        return __EnqueueCommand(a2, @"kResourceManagerPendingMeshSourceRemoval", v7);
      }
    }
  }
  return result;
}

uint64_t __MeshElementWillDie(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return __EnqueueCommand(a2, @"kResourceManagerPendingMeshElementRemoval", a4);
}

uint64_t __ImageWillDie(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return __EnqueueCommand(a2, @"kResourceManagerPendingImageRemoval", a4);
}

uint64_t __ImageProxyWillDie(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return __EnqueueCommand(a2, @"kResourceManagerPendingImageProxyRemoval", a4);
}

uint64_t __ProgramWillDie(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return __EnqueueCommand(a2, @"kResourceManagerPendingProgramRemoval", a4);
}

uint64_t __MeshWillDie(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return __EnqueueCommand(a2, @"kResourceManagerPendingMeshRemoval", a4);
}

CFDictionaryRef __ResourceManagerGetTexture(uint64_t a1, void *key, const void *a3)
{
  if (!a1 && (CFArrayRef v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (a3)
  {
    BOOL v22 = C3DTextureSamplerUseMipmaps((uint64_t)a3);
    Imageint Type = C3DImageGetImageType((uint64_t)key);
    a3 = (const void *)((int)(2 * C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(ImageType)) | (unint64_t)v22);
  }
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), key);
  if (!result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
    if (result) {
      return (const __CFDictionary *)CFDictionaryGetValue(result, a3);
    }
  }
  return result;
}

void __ResourceManagerDeleteTexture(uint64_t a1, const void *a2, const void *a3)
{
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value
    || (CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2)) != 0
    && (unsigned int Value = CFDictionaryGetValue(v20, a3)) != 0)
  {
    uint64_t Library = C3DSceneSourceGetLibrary((uint64_t)Value);
    if (Library)
    {
      uint64_t v8 = (const void *)Library;
      AnyRendererContext = __GetAnyRendererContext(a1);
      if (!AnyRendererContext)
      {
        uint64_t v10 = scn_default_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          C3DEngineContextRenderScene_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
        }
      }
      C3DRendererContextDeleteTexture((uint64_t)AnyRendererContext, (uint64_t)Value);
      double Size = C3DTextureGetSize((uint64_t)Value);
      if (C3DTextureIsAttachment((uint64_t)Value))
      {
        uint64_t v18 = *(__CFDictionary **)(a1 + 24);
        uint64_t v19 = v8;
      }
      else
      {
        uint64_t v23 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v8);
        *(_DWORD *)(a1 + 76) -= vcvts_n_u32_f32(vmul_lane_f32(*(float32x2_t *)&Size, *(float32x2_t *)&Size, 1).f32[0], 2uLL);
        C3DListRemoveLinkableObject(*(void **)(a1 + 80), Value);
        if (!v23)
        {
          unsigned int v24 = scn_default_log();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            __ResourceManagerDeleteTexture_cold_3();
          }
          return;
        }
        uint64_t v18 = v23;
        uint64_t v19 = a3;
      }
      CFDictionaryRemoveValue(v18, v19);
      return;
    }
    BOOL v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      __ResourceManagerDeleteTexture_cold_2();
    }
  }
  else
  {
    uint64_t v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      __ResourceManagerDeleteTexture_cold_1();
    }
  }
}

float32x2_t *C3DResourceManagerMakeImageResident(uint64_t a1, void *key, const void *Default, float32x2_t *a4)
{
  if (!a1 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (a4 || (unsigned int v24 = scn_default_log(), !os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)))
  {
    if (Default) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  C3DEngineContextRenderScene_cold_2(v24, v25, v26, v27, v28, v29, v30, v31);
  if (!Default) {
LABEL_9:
  }
    uint64_t Default = (const void *)C3DTextureSamplerGetDefault();
LABEL_10:
  CFDictionaryRef Texture = __ResourceManagerGetTexture(a1, key, Default);
  if (!Texture)
  {
    if (C3DImageIsCatalogTexture((uint64_t)key))
    {
      CatalogTextureuint64_t Name = C3DImageGetCatalogTextureName((uint64_t)key);
      uint64_t v44 = 0;
      uint64_t v35 = [MEMORY[0x263F08DF0] textureWithName:CatalogTextureName scaleFactor:SCNGetResourceBundle() bundle:MEMORY[0x263EFFA78] options:&v44 error:1.0];
      if (v35)
      {
        uint64_t v36 = (void *)v35;
        TextureWithuint64_t Image = (float32x2_t *)C3DTextureCreate();
        unsigned int v37 = [v36 width];
        TextureWithImage[8] = vcvt_f32_u32((uint32x2_t)__PAIR64__([v36 height], v37));
        C3DTextureSetID((uint64_t)TextureWithImage, [v36 name], objc_msgSend(v36, "target"));
        goto LABEL_20;
      }
      uint64_t v38 = scn_default_log();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        C3DResourceManagerMakeImageResident_cold_1(CatalogTextureName, &v44, v38);
      }
    }
    if (!C3DImageIsCubeMap((uint64_t)key))
    {
      double Size = C3DImageGetSize((uint64_t)key);
      TextureWithuint64_t Image = 0;
      if (*(float *)&Size == 0.0 || *((float *)&Size + 1) == 0.0) {
        return TextureWithImage;
      }
      unsigned int v42 = *(_DWORD *)(a1 + 72);
      if (v42)
      {
        unsigned int v43 = vcvts_n_u32_f32(*(float *)&Size * *((float *)&Size + 1), 2uLL);
        if (v42 >= v43 && *(_DWORD *)(a1 + 76) + v43 > v42)
        {
          while (1)
            ;
        }
      }
    }
    TextureWithuint64_t Image = (float32x2_t *)C3DRendererContextCreateTextureWithImage(a4, (uint64_t)key, (uint64_t)Default);
    if (!TextureWithImage) {
      return TextureWithImage;
    }
LABEL_20:
    TextureWithImage[5] = (float32x2_t)key;
    double v39 = C3DTextureGetSize((uint64_t)TextureWithImage);
    *(_DWORD *)(a1 + 76) += vcvts_n_u32_f32(vmul_lane_f32(*(float32x2_t *)&v39, *(float32x2_t *)&v39, 1).f32[0], 2uLL);
    C3DListAddLinkableObjectFirst(*(void **)(a1 + 80), TextureWithImage);
    __StoreTexture(a1, key, (uint64_t)Default, TextureWithImage);
    C3DImageReleaseBitmapCache((uint64_t)key);
    CFRelease(TextureWithImage);
    return TextureWithImage;
  }
  TextureWithuint64_t Image = (float32x2_t *)Texture;
  if ((C3DTextureIsAttachment((uint64_t)Texture) & 1) == 0) {
    C3DListMoveLinkableObjectFirst(*(void *)(a1 + 80), (uint64_t)TextureWithImage);
  }
  return TextureWithImage;
}

BOOL __ResourceManagerIsImageResident(uint64_t a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), key)
    }
          || CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), key) != 0;
  }
  else if (key)
  {
    return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), key)
        || CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), key) != 0;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), key)
      || CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), key) != 0;
}

void __ResourceManagerRemoveResidentImage(uint64_t a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
  {
    CFDictionaryRef v21 = Value;
    CFIndex Count = CFDictionaryGetCount(Value);
    if (Count >= 1)
    {
      CFIndex v23 = Count;
      unsigned int v24 = (const void **)C3DMalloc(8 * Count);
      CFDictionaryGetKeysAndValues(v21, v24, 0);
      for (uint64_t i = 0; i != v23; ++i)
        __ResourceManagerDeleteTexture(a1, key, v24[i]);
      free(v24);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), key);
  }
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), key)) {
    __ResourceManagerDeleteTexture(a1, key, 0);
  }
}

void *C3DResourceManagerMakeImageProxyResident(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1 && (uint64_t v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v10, v11, v12, v13, v14, v15, v16, v17);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    C3DResourceManagerMakeImageProxyResident_cold_2(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  if (!a4)
  {
    uint64_t v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
    }
  }
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), key);
  if (!Value)
  {
    CFDictionaryRef Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), key, Value);
    CFRelease(Value);
  }
  BOOL v35 = C3DTextureSamplerGetMipFilter(a3) != 0;
  uint64_t v36 = CFDictionaryGetValue((CFDictionaryRef)Value, (const void *)v35);
  if (!v36)
  {
    CFDictionaryRef result = (void *)C3DImageProxyCreateTextureProxy((uint64_t)key, a3, a5);
    if (!result) {
      return result;
    }
    uint64_t v36 = result;
    result[5] = key;
    CFDictionaryAddValue((CFMutableDictionaryRef)Value, (const void *)v35, result);
    CFRelease(v36);
  }
  return (void *)C3DTextureProxyGetOpenGLTexture((uint64_t)v36, a5, a3);
}

void __ResourceManagerRemoveResidentImageProxy(CFDictionaryRef *a1, void *key)
{
  if (!a1 && (uint64_t v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    C3DImageGetURL_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
LABEL_6:
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1[4], key);
  if (Value)
  {
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)__deleteTextureProxies, a1);
    CFDictionaryRemoveValue(a1[4], key);
  }
}

void _C3DRemoveTextureProxy(void *key, uint64_t a2, CFDictionaryRef **a3)
{
}

const void *C3DResourceManagerMakeMeshSourceResident(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DMeshSourceCreateWithAccessor_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDataRef Data = (const void *)C3DMeshSourceGetData(a2);
  if (!Data) {
    return 0;
  }
  uint64_t v23 = Data;
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Data);
  if (!Value)
  {
    CFDictionaryRef Value = (const void *)C3DRendererContextCreateBufferObjectForMeshSource(a3, a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v23, Value);
    CFRelease(Value);
  }
  return Value;
}

const void *C3DResourceManagerMakeMeshElementResident(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SharedMeshElement = (const void *)C3DMeshElementGetSharedMeshElement(a2);
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (SharedMeshElement) {
      goto LABEL_6;
    }
  }
  else if (SharedMeshElement)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextCreateBufferObjectForMeshElement_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), SharedMeshElement);
  if (!Value)
  {
    CFDictionaryRef Value = (const void *)C3DRendererContextCreateBufferObjectForMeshElement(a3, (uint64_t)SharedMeshElement);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), SharedMeshElement, Value);
    CFRelease(Value);
  }
  return Value;
}

void __ResourceManagerRemoveResidentMeshElement(uint64_t a1, void *key, _DWORD *a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), key);
  if (Value)
  {
    C3DRendererContextDeleteBufferObject(a3, (uint64_t)Value);
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 48), key)) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), key);
    }
  }
}

void C3DResourceManagerSetGLSLProgramObjectForSourceHash(uint64_t a1, CFTypeRef cf, void *a3)
{
  a3[15] = cf;
  CFRetain(cf);
  uint64_t v6 = *(__CFDictionary **)(a1 + 64);

  CFDictionarySetValue(v6, cf, a3);
}

void *C3DResourceManagerMakeProgramResident(uint64_t a1, void *key, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DResourceManagerMakeProgramResident_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), key);
  if (!Value)
  {
    ProgramObjectForPrograCFIndex m = C3DRendererContextCreateProgramObjectForProgram(a3, a1, (CFDictionaryRef *)key);
    if (ProgramObjectForProgram)
    {
      CFDictionaryRef Value = ProgramObjectForProgram;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), key, ProgramObjectForProgram);
      CFRelease(Value);
      Value[5] = key;
    }
    else
    {
      uint64_t v24 = scn_default_log();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        C3DResourceManagerMakeProgramResident_cold_1();
      }
      DefaultPrograCFIndex m = (CFDictionaryRef *)C3DFXGLSLProgramGetDefaultProgram();
      CFDictionaryRef Value = C3DRendererContextCreateProgramObjectForProgram(a3, a1, DefaultProgram);
      Value[5] = 0;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), key, Value);
      CFRelease(Value);
    }
  }
  return Value;
}

void __ResourceManagerRemoveResidentProgram(uint64_t a1, void *key, uint64_t a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DEngineContextRenderScene_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (key)
  {
    CFDictionaryRef Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), key);
    if (Value)
    {
      uint64_t v23 = Value;
      C3DFXGLSLProgramObjectDetachOfProgram((uint64_t)Value);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 56), key);
      if (!*((_DWORD *)v23 + 16))
      {
        v24[0] = MEMORY[0x263EF8330];
        v24[1] = 3221225472;
        v24[2] = ____ResourceManagerRemoveResidentProgramObject_block_invoke;
        v24[3] = &__block_descriptor_48_e5_v8__0l;
        float32x4_t v24[4] = a3;
        void v24[5] = v23;
        C3DRendererContextExecuteOnContext(a3, (uint64_t)v24);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), v23[15]);
      }
    }
  }
}

void __ResourceManagerReleaseResidentVRAMResource(CFDictionaryRef *a1, CFTypeRef cf, _DWORD *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (cf) {
      goto LABEL_6;
    }
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    __ResourceManagerReleaseResidentVRAMResource_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFTypeID v30 = CFGetTypeID(cf);
  if (v30 == C3DBufferObjectGetTypeID())
  {
    if (C3DBufferObjectGetTarget((uint64_t)cf))
    {
      if (C3DBufferObjectGetTarget((uint64_t)cf) == 1)
      {
        uint64_t Library = (void *)C3DSceneSourceGetLibrary((uint64_t)cf);
        __ResourceManagerRemoveResidentMeshElement((uint64_t)a1, Library, a3);
      }
    }
    else
    {
      uint64_t v34 = (void *)C3DSceneSourceGetLibrary((uint64_t)cf);
      __ResourceManagerRemoveResidentMeshSourceData((uint64_t)a1, v34, a3);
    }
  }
  else if (v30 == C3DTextureGetTypeID())
  {
    uint64_t v32 = (void *)C3DSceneSourceGetLibrary((uint64_t)cf);
    __ResourceManagerRemoveResidentImage((uint64_t)a1, v32);
  }
  else if (v30 == C3DFXGLSLProgramObjectGetTypeID())
  {
    uint64_t v33 = (void *)C3DSceneSourceGetLibrary((uint64_t)cf);
    __ResourceManagerRemoveResidentProgram((uint64_t)a1, v33, (uint64_t)a3);
  }
  else if (v30 == C3DImageProxyGetTypeID())
  {
    BOOL v35 = (void *)C3DSceneSourceGetLibrary((uint64_t)cf);
    __ResourceManagerRemoveResidentImageProxy(a1, v35);
  }
}

void C3DResourceManagerRemoveAllImages(CFDictionaryRef *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __StoreTexture_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], a1[2]);
  CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveImageFromDic, a1);
  CFRelease(Copy);
}

void __RemoveImageFromDic(void *key, int a2, uint64_t a3)
{
  if (key)
  {
    __ResourceManagerRemoveResidentImage(a3, key);
  }
  else
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

void C3DResourceManagerRemoveAllMeshSources(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __StoreTexture_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRef v10 = (const __CFDictionary *)a1[5];
  if (v10)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v10);
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveVRAMResourceFromDic, a1);
    CFRelease(Copy);
  }
}

void C3DResourceManagerRemoveAllMeshElements(CFDictionaryRef *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __StoreTexture_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFDictionaryRef v12 = a1[6];
  if (v12)
  {
    if (CFDictionaryGetCount(v12) >= 1)
    {
      C3DRendererContextBindMeshElement(a2, (uint64_t)a1, 0);
      CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], a1[6]);
      CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveVRAMResourceFromDic, a1);
      CFRelease(Copy);
    }
  }
}

void C3DResourceManagerRemoveAllPrograms(CFDictionaryRef *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __StoreTexture_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFDictionaryRef v10 = a1[7];
  if (v10)
  {
    CFIndex Count = CFDictionaryGetCount(v10);
    CFDictionaryRef v12 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
    if (Count >= 1)
    {
      CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], a1[7]);
      CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveVRAMResourceFromDic, a1);
      CFRelease(Copy);
    }
    if (CFDictionaryGetCount(a1[7]) >= 1)
    {
      CFDictionaryRef v14 = CFDictionaryCreateCopy(*v12, a1[8]);
      CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)__RemoveVRAMResourceFromDic, a1);
      CFRelease(v14);
    }
  }
}

void C3DResourceManagerRemoveAllResources(CFDictionaryRef *a1, uint64_t a2)
{
  context[2] = *MEMORY[0x263EF8340];
  C3DResourceManagerFlush((uint64_t)a1);
  C3DResourceManagerRemoveAllImages(a1);
  C3DResourceManagerRemoveAllMeshElements(a1, a2);
  C3DResourceManagerRemoveAllMeshSources(a1);
  C3DResourceManagerRemoveAllPrograms(a1);
  context[0] = a1;
  context[1] = a2;
  CFDictionaryApplyFunction(a1[4], (CFDictionaryApplierFunction)_C3DRemoveTextureProxy, context);
}

uint64_t C3DResourceManagerFlush(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 224), (CFDictionaryApplierFunction)__HandleVRAMResourcesRemovalFromCommands, (void *)a1);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __C3DResourceManagerFlush_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a1;
  dispatch_block_t v3 = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS, block);
  dispatch_async(*(dispatch_queue_t *)(a1 + 216), v3);
  dispatch_resume(*(dispatch_object_t *)(a1 + 216));
  dispatch_block_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
  _Block_release(v3);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 152));
  return pthread_mutex_unlock(v2);
}

void __HandleVRAMResourcesRemovalFromCommands(__CFString *a1, const __CFArray *a2, uint64_t a3)
{
  *(void *)&void v15[5] = *MEMORY[0x263EF8340];
  AnyRendererContext = __GetAnyRendererContext(a3);
  CFIndex Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0; i != v7; ++i)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex(a2, i);
      C3DVRAMResourceUnlock((uint64_t)ValueAtIndex);
      if (a1 == @"kResourceManagerPendingImageRemoval")
      {
        C3DRendererContextDeleteTexture((uint64_t)AnyRendererContext, (uint64_t)ValueAtIndex);
      }
      else if (a1 == @"kResourceManagerPendingImageProxyRemoval")
      {
        if (!ValueAtIndex)
        {
          CFDictionaryRef v10 = scn_default_log();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
            __HandleVRAMResourcesRemovalFromCommands_cold_1(buf, v15, v10);
          }
        }
        if (!C3DVRAMResourceLockCount((uint64_t)ValueAtIndex) && *((void *)ValueAtIndex + 9))
        {
          uint64_t v11 = __GetAnyRendererContext(a3);
          (*((void (**)(const void *, void))ValueAtIndex + 9))(v11, *((void *)ValueAtIndex + 12));
        }
      }
      else if (a1 == @"kResourceManagerPendingProgramRemoval")
      {
        if (!*((_DWORD *)ValueAtIndex + 16))
        {
          v13[0] = MEMORY[0x263EF8330];
          v13[1] = 3221225472;
          v13[2] = ____ResourceManagerRemoveResidentProgramObject_block_invoke;
          v13[3] = &__block_descriptor_48_e5_v8__0l;
          uint8_t v13[4] = AnyRendererContext;
          void v13[5] = ValueAtIndex;
          C3DRendererContextExecuteOnContext((uint64_t)AnyRendererContext, (uint64_t)v13);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 64), *((const void **)ValueAtIndex + 15));
        }
      }
      else if (a1 == @"kResourceManagerPendingMeshSourceRemoval" {
             || a1 == @"kResourceManagerPendingMeshElementRemoval")
      }
      {
        C3DRendererContextDeleteBufferObject(AnyRendererContext, (uint64_t)ValueAtIndex);
      }
    }
  }
  CFArrayRemoveAllValues(a2);
}

void __C3DResourceManagerFlush_block_invoke(uint64_t a1)
{
}

uint64_t _C3DResourceManagerInstallRendererContext(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 152);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 232), a2);

  return pthread_mutex_unlock(v4);
}

uint64_t _C3DResourceManagerUninstallRendererContext(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 152);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 232));
  v10.locatiouint64_t n = 0;
  v10.GLsizei length = Count;
  FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 232), v10, a2);
  if (FirstIndexOfValue == -1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      _C3DResourceManagerUninstallRendererContext_cold_1();
    }
  }
  else
  {
    CFIndex v7 = FirstIndexOfValue;
    if (Count == 1) {
      C3DResourceManagerRemoveAllResources((CFDictionaryRef *)a1, (uint64_t)a2);
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 232), v7);
  }
  return pthread_mutex_unlock(v4);
}

uint64_t C3DResourceManagerLockVRAMResourceAccess(uint64_t a1)
{
  return pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
}

uint64_t C3DResourceManagerUnlockVRAMResourceAccess(uint64_t a1)
{
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 152));
}

const void *__GetAnyRendererContext(uint64_t a1)
{
  CFDictionaryRef result = (const void *)CFArrayGetCount(*(CFArrayRef *)(a1 + 232));
  if (result)
  {
    CFArrayRef v3 = *(const __CFArray **)(a1 + 232);
    return CFArrayGetValueAtIndex(v3, 0);
  }
  return result;
}

uint64_t __deleteTextureProxies(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      __deleteTextureProxies_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  uint64_t result = C3DVRAMResourceLockCount(a2);
  if (!result)
  {
    if (*(void *)(a2 + 72))
    {
      AnyRendererContext = __GetAnyRendererContext(a3);
      return (*(uint64_t (**)(const void *, void))(a2 + 72))(AnyRendererContext, *(void *)(a2 + 96));
    }
  }
  return result;
}

uint64_t __EnqueueCommand(uint64_t result, __CFString *a2, void *a3)
{
  if (*(void *)(result + 224))
  {
    uint64_t v5 = result;
    AnyRendererContext = __GetAnyRendererContext(result);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 88));
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 224), a2);
    if (!Value)
    {
      CFDictionaryRef Value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 224), a2, Value);
      CFRelease(Value);
    }
    if (a2 == @"kResourceManagerPendingImageRemoval")
    {
      if (__ResourceManagerIsImageResident(v5, a3))
      {
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
        if (!a3)
        {
          uint64_t v11 = scn_default_log();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
            C3DImageGetURL_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
          }
        }
        CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 16), a3);
        if (v19)
        {
          CFDictionaryRef v20 = v19;
          CFIndex Count = CFDictionaryGetCount(v19);
          if (Count >= 1)
          {
            CFIndex v22 = Count;
            uint64_t v23 = (const void **)C3DMalloc(8 * Count);
            CFDictionaryGetKeysAndValues(v20, v23, 0);
            for (uint64_t i = 0; i != v22; ++i)
            {
              uint64_t v25 = v23[i];
              uint64_t v26 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 24), a3);
              if (!v26)
              {
                CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 16), a3);
                if (!v27) {
                  continue;
                }
                uint64_t v26 = CFDictionaryGetValue(v27, v25);
                if (!v26) {
                  continue;
                }
              }
              CFArrayAppendValue(Mutable, v26);
            }
            free(v23);
          }
        }
        uint64_t v32 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 24), a3);
        if (v32) {
          CFArrayAppendValue(Mutable, v32);
        }
        if (Mutable)
        {
          CFIndex v33 = CFArrayGetCount(Mutable);
          if (v33 >= 1)
          {
            CFIndex v34 = v33;
            for (CFIndex j = 0; j != v34; ++j)
            {
              ValueAtuint64_t Index = CFArrayGetValueAtIndex(Mutable, j);
              C3DVRAMResourceLock((uint64_t)ValueAtIndex);
              CFArrayAppendValue((CFMutableArrayRef)Value, ValueAtIndex);
            }
          }
          CFRelease(Mutable);
          __ResourceManagerRemoveResidentImage(v5, a3);
        }
      }
    }
    else if (a2 == @"kResourceManagerPendingImageProxyRemoval")
    {
      CFDictionaryRef v28 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), a3);
      if (v28) {
        CFDictionaryApplyFunction(v28, (CFDictionaryApplierFunction)__lockAndAppendTextureProxyForRemoval, Value);
      }
      __ResourceManagerRemoveResidentImageProxy((CFDictionaryRef *)v5, a3);
    }
    else if (a2 == @"kResourceManagerPendingProgramRemoval")
    {
      uint64_t v29 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 56), a3);
      if (v29 && AnyRendererContext)
      {
        CFTypeID v30 = v29;
        C3DVRAMResourceLock((uint64_t)v29);
        CFArrayAppendValue((CFMutableArrayRef)Value, v30);
        __ResourceManagerRemoveResidentProgram(v5, a3, (uint64_t)AnyRendererContext);
      }
    }
    else if (a2 == @"kResourceManagerPendingMeshRemoval")
    {
      v39[0] = *(void *)(v5 + 216);
      v39[1] = a3;
      if (AnyRendererContext)
      {
        CFArrayRef v31 = *(const __CFArray **)(v5 + 232);
        v40.GLsizei length = CFArrayGetCount(v31);
        v40.locatiouint64_t n = 0;
        CFArrayApplyFunction(v31, v40, (CFArrayApplierFunction)__DeleteVertexArrayObject, v39);
      }
    }
    else if (a2 == @"kResourceManagerPendingMeshSourceRemoval")
    {
      unsigned int v37 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 40), a3);
      if (v37 && AnyRendererContext)
      {
        uint64_t v38 = v37;
        C3DVRAMResourceLock((uint64_t)v37);
        CFArrayAppendValue((CFMutableArrayRef)Value, v38);
        __ResourceManagerRemoveResidentMeshSourceData(v5, a3, AnyRendererContext);
      }
    }
    else if (a2 == @"kResourceManagerPendingMeshElementRemoval")
    {
      uint64_t v8 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 48), a3);
      if (v8)
      {
        if (AnyRendererContext)
        {
          uint64_t v9 = v8;
          C3DVRAMResourceLock((uint64_t)v8);
          CFArrayAppendValue((CFMutableArrayRef)Value, v9);
          __ResourceManagerRemoveResidentMeshElement(v5, a3, AnyRendererContext);
        }
      }
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
  }
  return result;
}

void __lockAndAppendTextureProxyForRemoval(uint64_t a1, const void *a2, __CFArray *a3)
{
  C3DVRAMResourceLock((uint64_t)a2);

  CFArrayAppendValue(a3, a2);
}

void __DeleteVertexArrayObject(uint64_t a1, uint64_t a2)
{
}

void __ResourceManagerRemoveResidentMeshSourceData(uint64_t a1, void *key, _DWORD *a3)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    __StoreTexture_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key) {
      goto LABEL_6;
    }
  }
  else if (key)
  {
    goto LABEL_6;
  }
  uint64_t v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    __ResourceManagerRemoveResidentMeshSourceData_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!a3)
  {
    CFIndex v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), key);
  if (Value)
  {
    C3DRendererContextDeleteBufferObject(a3, (uint64_t)Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), key);
  }
}

void __RemoveVRAMResourceFromDic(uint64_t a1, const void *a2, CFDictionaryRef *a3)
{
  if (!a2)
  {
    uint64_t v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  AnyRendererContext = __GetAnyRendererContext((uint64_t)a3);
  __ResourceManagerReleaseResidentVRAMResource(a3, a2, AnyRendererContext);
}

uint64_t C3DTextureGetTypeID()
{
  if (C3DTextureGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTextureGetTypeID_onceToken, &__block_literal_global_44);
  }
  return C3DTextureGetTypeID_typeID;
}

void _C3DTextureCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 104) = 0;
  }
}

CFStringRef _C3DTextureCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTexture>");
}

CFStringRef _C3DTextureCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTexture>");
}

uint64_t __C3DTextureGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DTextureGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DTextureCreate()
{
  if (C3DTextureGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTextureGetTypeID_onceToken, &__block_literal_global_44);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTextureGetTypeID_typeID, 0x60uLL);
  if (!Instance)
  {
    CFAllocatorRef v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  *(unsigned char *)(Instance + 80) |= 1u;
  *(unsigned char *)(Instance + 60) = 0;
  return Instance;
}

double C3DTextureGetSize(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(double *)(a1 + 64);
}

uint64_t C3DTextureGetIOSurface(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

void C3DTextureSetSize(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 64) = a2;
}

void C3DTextureSetOffset(uint64_t a1, double a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(double *)(a1 + 72) = a2;
}

uint64_t C3DTextureGetID(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return C3DVRAMResourceGetID(a1);
}

void C3DTextureSetID(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  C3DVRAMResourceSetID(a1, a2);
  *(_DWORD *)(a1 + 8_Block_object_dispose(&STACK[0x2A0], 8) = a3;
}

void C3DTextureSetFormat(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 92) = a2;
}

void C3DTextureSetServerStorageSize(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 84) = a2;
}

uint64_t C3DTextureGetServerStorageSize(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 84);
}

uint64_t C3DTextureGetTargetMode(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 88);
}

uint64_t C3DTextureIsAttachment(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t C3DTextureHasAlpha(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 80) >> 1) & 1;
}

void C3DTextureSetHasAlpha(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DRendererContextApplyTextureSampler_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a1 + 80) & 0xFD | v12;
}

void C3D::SSAOMinMaxOffsetPass::SSAOMinMaxOffsetPass(C3D::ComputePass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::ComputePass::ComputePass(a1, a2, a3);
  *uint64_t v5 = &unk_26BF6DEB0;
  v5[14] = 0;
  v5[15] = a4;
}

const char *C3D::SSAOMinMaxOffsetPass::name(C3D::SSAOMinMaxOffsetPass *this)
{
  return "SSAOMinMaxOffsetPass";
}

uint64_t C3D::SSAOMinMaxOffsetPass::setup(C3D::Pass ***this)
{
  C3D::Pass::setInputCount((C3D::Pass *)this, 1u);
  C3D::Pass::setOutputCount((C3D::Pass *)this, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(this + 4), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "SSAO-DepthNormal";
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(this + 4), 0);
  *(void *)(v2 + _Block_object_dispose(&STACK[0x2A0], 8) = "SSAO-MinMaxOffset";
  *(_WORD *)(v2 + 2_Block_object_dispose(&STACK[0x2A0], 8) = 13;
  uint64_t v3 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*this[15]);
  *(_WORD *)(v2 + 16) = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v3, 0) + 16)
                      / *((_DWORD *)this[15] + 3);
  uint64_t v4 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*this[15]);
  uint64_t result = C3D::PassDescriptor::outputAtIndex(v4, 0);
  *(_WORD *)(v2 + 1_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned __int16 *)(result + 18) / *((_DWORD *)this[15] + 3);
  if (*(unsigned char *)(v2 + 24) == 5) {
    __int16 v6 = 6;
  }
  else {
    __int16 v6 = 1;
  }
  *((_WORD *)this + 19) = v6;
  return result;
}

uint64_t C3D::SSAOMinMaxOffsetPass::compile(C3D::SSAOMinMaxOffsetPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = *(unsigned __int8 *)(*((void *)this + 15) + 16) | (2 * *(unsigned __int8 *)(*((void *)this + 15) + 17)) | (4 * *(_DWORD *)(*((void *)this + 15) + 12)) | (*(_DWORD *)(*((void *)this + 15) + 8) << 6);
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::SSAOMinMaxOffsetPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47))));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v4 ^ (v4 >> 47))) >> 47));
  *((void *)this + 14) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::SSAOMinMaxOffsetPass::execute(C3D::Pass *a1, SCNMTLComputeCommandEncoder **a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = C3D::Pass::inputTextureAtIndex(a1, 0);
  if ((void **)v3->_textures[0] != v4)
  {
    v3->_textures[0] = (MTLTexture *)v4;
    v3->_texturesToBind[0] |= 1uLL;
  }
  uint64_t v5 = (MTLTexture *)C3D::Pass::outputTextureAtIndex(a1, 0);
  if (v3->_textures[1] != v5)
  {
    v3->_textures[1] = v5;
    v3->_texturesToBind[0] |= 2uLL;
  }
  __int16 v6 = C3D::Pass::outputTextureAtIndex(a1, 0);
  uint64_t v7 = C3D::SmartPtr<SCNMTLComputePipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLComputePipeline *(*((void *)a1 + 14) + 16);
  uint64_t v8 = (MTLComputePipelineState *)-[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v7);

  return SCNMTLComputeCommandEncoder::dispatchOnTexture2D(v3, v6, v8);
}

void C3D::SSAOMinMaxOffsetPassResource::~SSAOMinMaxOffsetPassResource(C3D::SSAOMinMaxOffsetPassResource *this)
{
  *(void *)this = &unk_26BF6E660;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E660;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

C3D::RenderPass *C3D::CompositeARPass::CompositeARPass(C3D::CompositeARPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  uint64_t result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(void *)uint64_t result = &unk_26BF6D290;
  *((void *)result + 31) = 0;
  *((void *)result + 32) = 0;
  return result;
}

const char *C3D::CompositeARPass::name(C3D::CompositeARPass *this)
{
  return "CompositeARPass";
}

uint64_t C3D::CompositeARPass::setup(C3D::CompositeARPass *this)
{
  CFAllocatorRef v1 = this;
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  C3D::Pass::setInputCount(v1, 3u);
  uint64_t v3 = (C3D::CompositeARPass *)((char *)v1 + 32);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "DEPTH";
  *(unsigned char *)(C3D::PassDescriptor::inputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 1u) + 64) = 2;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 2u) + _Block_object_dispose(&STACK[0x2A0], 8) = "BACKGROUND";
  if (-[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext)) {
    unsigned int v4 = 2;
  }
  else {
    unsigned int v4 = 1;
  }
  C3D::Pass::setOutputCount(v1, v4);
  *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 0) + 65) = 0;
  uint64_t v5 = v1;
  do
  {
    __int16 v6 = v5;
    uint64_t v5 = (C3D::CompositeARPass *)*((void *)v5 + 1);
  }
  while (v5);
  C3D::Pass::parentColorDesc(v6, (uint64_t)&v11);
  uint64_t v7 = C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 0);
  *(_OWORD *)(v7 + 16) = v11;
  *(_DWORD *)(v7 + 32) = v12;
  *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 0) + 31) = 0;
  uint64_t result = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
  if (result)
  {
    *(void *)(C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "DEPTH";
    *(unsigned char *)(C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)v1 + 32), 1u) + 64) = 2;
    do
    {
      uint64_t v9 = v1;
      CFAllocatorRef v1 = (C3D::CompositeARPass *)*((void *)v1 + 1);
    }
    while (v1);
    C3D::Pass::parentDepthDesc(v9, (uint64_t)&v11);
    uint64_t v10 = C3D::PassDescriptor::outputAtIndex(v3, 1u);
    *(_OWORD *)(v10 + 16) = v11;
    *(_DWORD *)(v10 + 32) = v12;
    uint64_t result = C3D::PassDescriptor::outputAtIndex(v3, 1u);
    *(unsigned char *)(result + 31) = 0;
  }
  return result;
}

uint64_t C3D::CompositeARPass::compile(C3D::CompositeARPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t result = (uint64_t)C3DEngineContextGetPointOfView(*((void *)this + 2));
  if (result)
  {
    uint64_t result = (uint64_t)C3DNodeGetCamera(result);
    *((void *)this + 32) = result;
    if (result)
    {
      if (!C3DEngineContextGetPreferredRenderMode(*((void *)this + 2))) {
        *((_WORD *)this + 19) = C3DEngineContextGetEyeCount(*((void *)this + 2));
      }
      *((void *)this + 31) = C3DCameraGetARGrainTexture(*((void *)this + 32));
      char IsColored = C3DCameraGetGrainIsColored(*((void *)this + 32));
      uint64_t v4 = *((void *)this + 31);
      if (v4) {
        LOBYTE(v4) = C3DCameraGetGrainIntensity(*((void *)this + 32)) > 0.0;
      }
      *((unsigned char *)this + 264) = v4;
      int v5 = -[SCNMTLRenderContext reverseZ](RenderContext);
      char v16 = v5;
      uint64_t v6 = C3DEngineContextGetViewpointCoordinateSpace(*((void *)this + 2)) != 2;
      char v15 = v6;
      int v7 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
      char v14 = v7;
      uint64_t v8 = 4;
      if (!v5) {
        uint64_t v8 = 0;
      }
      uint64_t v9 = v8 | (2 * *((unsigned __int8 *)this + 264));
      uint64_t v10 = C3D::PassDescriptor::outputAtIndex((C3D::CompositeARPass *)((char *)this + 32), 0);
      uint64_t v11 = 2048;
      if (!v7) {
        uint64_t v11 = 0;
      }
      uint64_t v12 = v9 | (8 * *(unsigned __int16 *)(v10 + 28)) | (v6 << 10) | v11;
      unint64_t v13 = 0xC6A4A7935BD1E995
          * ((*(uint64_t (**)(C3D::CompositeARPass *))(*(void *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v12) ^ ((0xC6A4A7935BD1E995 * v12) >> 47))));
      uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), (0xC6A4A7935BD1E995 * (v13 ^ (v13 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v13 ^ (v13 >> 47))) >> 47));
      *((void *)this + 30) = result;
      if (!result) {
        operator new();
      }
    }
  }
  return result;
}

uint64_t C3D::CompositeARPass::execute(void *a1, uint64_t a2)
{
  uint64_t result = C3DEngineContextGetRenderContext(a1[2]);
  if (a1[32])
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)a2;
    if (*((unsigned char *)a1 + 264))
    {
      double v7 = -[SCNMTLRenderContext renderTime](result);
      float v8 = floor(*(float *)&v7 * 30.0);
      float GrainScale = C3DCameraGetGrainScale(a1[32]);
      if (GrainScale <= 0.0039062) {
        float v10 = 1.0;
      }
      else {
        float v10 = 0.0039062 / GrainScale;
      }
      BOOL v11 = -[SCNMTLRenderContext contentScaleFactor](v5) <= 1.0;
      double v12 = 2.0;
      if (!v11) {
        double v12 = 1.0;
      }
      float v13 = v12 * v10;
      float v29 = v13;
      v32[0] = C3DCameraGetGrainIntensity(a1[32]);
      double v14 = v8;
      long double v15 = sin(v14 * 0.01);
      *(float *)&long double v15 = fmin(v15 * 4242.0 - floor(v15 * 4242.0), 1.0);
      unsigned int v27 = LODWORD(v15);
      long double v16 = sin(v14 * 0.1 + 0.05);
      *(float *)&long double v16 = fmin(v16 * 4242.0 - floor(v16 * 4242.0), 1.0);
      *(float *)&long long v17 = v29;
      *((float *)&v17 + 1) = v29;
      *((void *)&v17 + 1) = __PAIR64__(LODWORD(v16), v27);
      long long v33 = v17;
      float ARGrainSlice = C3DCameraGetARGrainSlice(a1[32]);
    }
    uint64_t v18 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 16) state];
    if (*(void *)(v6 + 3376) != v18)
    {
      *(void *)(v6 + 3376) = v18;
      [*(id *)(v6 + 3392) setRenderPipelineState:v18];
    }
    int32x4_t v31 = (int32x4_t)xmmword_20B5CD060;
    if (C3DEngineContextGetEyeCount(a1[2]) >= 2
      && !C3DEngineContextGetPreferredRenderMode(a1[2]))
    {
      __n128 ViewportAtIndex = C3DEngineContextGetViewportAtIndex(a1[2], *(unsigned __int16 *)(a2 + 16));
      int8x16_t v30 = vextq_s8((int8x16_t)ViewportAtIndex, (int8x16_t)ViewportAtIndex, 8uLL);
      int32x4_t v20 = *(int32x4_t *)(*(uint64_t (**)(void *))(*a1 + 88))(a1);
      int32x2_t v26 = (int32x2_t)vextq_s8(v30, v30, 8uLL).u64[0];
      *(float32x2_t *)v20.i8 = vdiv_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v30.i8, v26), (float32x2_t)vdup_laneq_s32(v20, 2));
      int32x4_t v28 = v20;
      int32x4_t v21 = *(int32x4_t *)(*(uint64_t (**)(void *))(*a1 + 88))(a1);
      *(float32x2_t *)v21.i8 = vdiv_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v30.i8, v26), (float32x2_t)vdup_laneq_s32(v21, 3));
      int32x4_t v31 = vzip1q_s32(v28, v21);
    }
    if (-[SCNMTLRenderContext shouldDelegateARCompositing](v5)) {
      [*(id *)(v6 + 3392) setDepthStencilState:C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 24)];
    }
    SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v6, &v31, 0x10uLL, 0);
    SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v6, v32, 0x30uLL, 0);
    CFIndex v22 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v22, 0);
    uint64_t v23 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v23, 1uLL);
    if ((-[SCNMTLRenderContext shouldDelegateARCompositing](v5) & 1) == 0)
    {
      uint64_t v24 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 2u);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v24, 2uLL);
    }
    uint64_t v25 = (void *)a1[31];
    if (v25) {
      SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v25, 3uLL);
    }
    return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v6);
  }
  return result;
}

void C3D::CompositeARPassResource::~CompositeARPassResource(C3D::CompositeARPassResource *this)
{
  *(void *)this = &unk_26BF6E360;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4) {
}
  }

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E360;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4) {

  }
  JUMPOUT(0x210534FE0);
}

void sub_20B36C950(_Unwind_Exception *exception_object)
{
}

void sub_20B36CAC8(_Unwind_Exception *exception_object)
{
}

void sub_20B36D5D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

C3D::RenderPass *C3D::SSRBlurPass::SSRBlurPass(C3D::RenderPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4, char a5)
{
  uint64_t result = C3D::RenderPass::RenderPass(a1, a2, a3);
  *(void *)uint64_t result = &unk_26BF6CC40;
  *((unsigned char *)result + 24_Block_object_dispose(&STACK[0x2A0], 8) = a5;
  return result;
}

const char *C3D::SSRBlurPass::name(C3D::SSRBlurPass *this)
{
  if (*((unsigned char *)this + 248)) {
    return "SSRBlurPass-Y";
  }
  else {
    return "SSRBlurPass-X";
  }
}

uint64_t C3D::SSRBlurPass::setup(C3D::SSRBlurPass *this)
{
  C3D::Pass::setInputCount(this, 2u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRBlurPass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "SSR";
  uint64_t v2 = C3D::PassDescriptor::inputAtIndex((C3D::SSRBlurPass *)((char *)this + 32), 0);
  *(_WORD *)(v2 + 66) |= 4u;
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRBlurPass *)((char *)this + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "lobeFootprint";
  C3D::Pass::setOutputCount(this, 1u);
  uint64_t result = C3D::PassDescriptor::outputAtIndex((C3D::SSRBlurPass *)((char *)this + 32), 0);
  *(void *)(result + _Block_object_dispose(&STACK[0x2A0], 8) = "SSR";
  return result;
}

uint64_t C3D::SSRBlurPass::compile(C3D::SSRBlurPass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  uint64_t v3 = -[SCNMTLRenderContext resourceManager](RenderContext);
  [(id)-[SCNMTLResourceManager libraryManager](v3) frameworkLibrary];
  uint64_t v4 = (*(uint64_t (**)(C3D::SSRBlurPass *))(*(void *)this + 64))(this);
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v4);
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::SSRBlurPass::execute(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 240);
  if (*(unsigned char *)(a1 + 248)) {
    uint64_t v5 = v4 + 24;
  }
  else {
    uint64_t v5 = v4 + 16;
  }
  uint64_t v6 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v5) state];
  if (*(void *)(v3 + 3376) != v6)
  {
    *(void *)(v3 + 3376) = v6;
    objc_msgSend(*(id *)(v3 + 3392), "setRenderPipelineState:");
  }
  double v7 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v7, 0);
  float v8 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v8, 1uLL);

  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v3);
}

void C3D::SSRBlurPassResource::~SSRBlurPassResource(C3D::SSRBlurPassResource *this)
{
  *(void *)this = &unk_26BF6DDE0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {
}
  }

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26BF6DDE0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {

  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3) {

  }
  JUMPOUT(0x210534FE0);
}

const char *C3D::CIFilterEffectColorPrefix(C3D *this)
{
  return "SceneKit-CI-effect-color-";
}

const char *C3D::CIFilterEffectDepthPrefix(C3D *this)
{
  return "SceneKit-CI-effect-depth-";
}

uint64_t C3D::CreateCIFilterQuadBlendTechnique(C3D *this, __C3DNode *a2, __C3DEngineContext *a3)
{
  uint64_t v5 = [NSString stringWithFormat:@"%@%p", @"SceneKit-CI-effect-depth-", this];
  uint64_t v6 = [NSString stringWithFormat:@"%@%p", @"SceneKit-CI-effect-color-", this];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = ___ZN3C3D32CreateCIFilterQuadBlendTechniqueEP9__C3DNodeP18__C3DEngineContext_block_invoke;
  v13[3] = &unk_264007078;
  uint8_t v13[4] = &unk_26BFC1780;
  void v13[5] = v5;
  void v13[6] = v6;
  v13[7] = this;
  double v7 = (const void *)C3DJsonNamed(@"C3DFXCIFilterPassMetalRenderGraph.json", (uint64_t)v13);
  uint64_t v8 = C3DFXTechniqueCreateWithDescription(v7, (uint64_t)this);
  uint64_t PassNamed = (void *)C3DFXTechniqueGetPassNamed(v8, (CFTypeRef)[NSString stringWithFormat:@"%@%p", @"SceneKit_renderCIQuad", this]);
  C3DFXPassSetInitializeCallback((uint64_t)PassNamed, (uint64_t)C3D::_initializeRenderFilteredBuffer);
  C3DFXPassSetWillExecuteCallback((uint64_t)PassNamed, (uint64_t)C3D::_willRenderFilteredBuffer);
  C3DFloorSetReflectionCategoryBitMask((uint64_t)PassNamed, (uint64_t)C3D::_blendFilteredBuffer);
  v12[0] = (uint64_t)PassNamed;
  v12[1] = v8;
  void v12[2] = (uint64_t)this;
  v12[3] = (uint64_t)a2;
  float32x4_t v12[4] = 0;
  v12[5] = 0;
  memset(&v12[7], 0, 32);
  v12[6] = 0xBFF0000000000000;
  C3DFXPassInitialize(v12, 0);
  uint64_t Scene = C3DEngineContextGetScene((uint64_t)a2);
  C3DFXContextResolveNodeReferences(PassNamed, Scene);
  return v8;
}

uint64_t ___ZN3C3D32CreateCIFilterQuadBlendTechniqueEP9__C3DNodeP18__C3DEngineContext_block_invoke(void *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        a2 = (void *)[a2 stringByReplacingOccurrencesOfString:*(void *)(*((void *)&v10 + 1) + 8 * i), objc_msgSend(NSString, "stringWithFormat:", @"%@%p", *(void *)(*((void *)&v10 + 1) + 8 * i), a1[7]) withString];
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v6);
  }
  return objc_msgSend((id)objc_msgSend(a2, "stringByReplacingOccurrencesOfString:withString:", @"SceneKit-CI-effect-depth", a1[5]), "stringByReplacingOccurrencesOfString:withString:", @"SceneKit-CI-effect-color", a1[6]);
}

void C3D::_initializeRenderFilteredBuffer(uint64_t *a1)
{
  PrograCFIndex m = C3DFXPassGetProgram(*a1);

  C3DFXProgramSetOpaque(Program, 0);
}

void C3D::_willRenderFilteredBuffer(uint64_t a1)
{
  uint64_t RenderGraph = C3DEngineContextGetRenderGraph(*(void *)(a1 + 24));
  uint64_t v3 = *(void *)(RenderGraph + 120);
  uint64_t StackAllocator = C3DEngineContextGetStackAllocator(*(void *)(a1 + 24));
  C3D::RenderGraph::getPredecessors(RenderGraph, v3, StackAllocator, (uint64_t)v27);
  if (v28)
  {
    uint64_t v5 = v29;
    uint64_t v6 = 8 * v28;
    while (1)
    {
      uint64_t v7 = *v5;
      if ((*(uint64_t (**)(float32x4_t *))(*v5)->i64[0])(*v5))
      {
        uint64_t v8 = (const char *)(*(uint64_t (**)(float32x4_t *))v7->i64[0])(v7);
        if (!strcmp(v8, C3D::kCIFilterPassName) && v7[10].i64[0] == *(void *)(a1 + 16)) {
          break;
        }
      }
      ++v5;
      v6 -= 8;
      if (!v6) {
        return;
      }
    }
    uint64_t CullingContext = C3D::DrawNodesPass::getCullingContext((C3D::DrawNodesPass *)v7[8].i64[0]);
    WorldMatrifloat x = C3DNodeGetWorldMatrix(*(float32x4_t **)(a1 + 16));
    C3DMatrix4x4Mult((uint64_t)WorldMatrix, (float32x4_t *)(CullingContext + (*(void *)(a1 + 72) << 6) + 3088), v26);
    v25[0] = (float32x4_t)v26[0];
    v25[1] = (float32x4_t)v26[1];
    v25[2] = (float32x4_t)v26[2];
    _OWORD v25[3] = (float32x4_t)v26[3];
    C3DVector3MultMatrix4x4(v25, (float32x4_t)0);
    float v12 = fmax(*(double *)(CullingContext + 4752)/ (*(double *)(CullingContext + 4752) - *(double *)(CullingContext + 4744))- *(double *)(CullingContext + 4752)* *(double *)(CullingContext + 4744)/ (*(double *)(CullingContext + 4744) - *(double *)(CullingContext + 4752))/ v11, 0.0);
    float v24 = v12;
    float v13 = 0.0;
    if (C3DReverseZIsSupported())
    {
      float v13 = 1.0;
      float v24 = 1.0 - v12;
    }
    uint64_t v14 = *(void *)(a1 + 16);
    C3DFXTechniqueSetValueForSymbol(*(void *)(a1 + 8), (void *)[NSString stringWithFormat:@"%@%p", @"C3D-CIFilter_middleZ", v14], &v24);
    __asm { FMOV            V3.2D, #0.5 }
    float64x2_t v20 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(CullingContext + 4648)), _Q3);
    __asm { FMOV            V3.2D, #-1.0 }
    float32x4_t v23 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v7[9].f32), v20), _Q3)), vdivq_f64(vcvt_hight_f64_f32(v7[9]), v20));
    C3DFXTechniqueSetValueForSymbol(*(void *)(a1 + 8), (void *)[NSString stringWithFormat:@"%@%p", @"C3D-CIFilter_extent", v14], &v23);
    float v22 = v13;
    C3DFXTechniqueSetValueForSymbol(*(void *)(a1 + 8), (void *)[NSString stringWithFormat:@"%@%p", @"C3D-CIFilter_reverseZ", v14], &v22);
  }
}

double C3D::_blendFilteredBuffer(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t Stats = C3DEngineContextGetStats(v2);
  double v4 = CACurrentMediaTime();
  Quaduint64_t Mesh = C3DEngineContextGetQuadMesh(v2);
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v2);
  *(void *)(a1[8] + 24) = QuadMesh;
  *(void *)(a1[8] + 4_Block_object_dispose(&STACK[0x2A0], 8) = C3DMeshGetElementAtIndex(QuadMesh, 0, 1);
  -[SCNMTLRenderContext drawRenderElement:withPass:](RenderContext, a1[8], *a1);
  uint64_t v7 = a1[8];
  *(void *)(v7 + 24) = 0;
  *(void *)(v7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  double result = *(double *)(Stats + 160) + CACurrentMediaTime() - v4;
  *(double *)(Stats + 160) = result;
  return result;
}

uint64_t C3DImageProxyGetTypeID()
{
  if (C3DImageProxyGetTypeID_onceToken != -1) {
    dispatch_once(&C3DImageProxyGetTypeID_onceToken, &__block_literal_global_45);
  }
  return C3DImageProxyGetTypeID_typeID;
}

void _C3DImageProxyCFFinalize(void *a1)
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kC3DNotificationImageProxyWillDie", a1, 0, 1u);
  uint64_t v3 = (const void *)a1[6];
  if (v3)
  {
    CFRelease(v3);
    a1[6] = 0;
  }
}

CFStringRef _C3DImageProxyCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DImageProxy>");
}

CFStringRef _C3DImageProxyCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DImageProxy>");
}

uint64_t __C3DImageProxyGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DImageProxyGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DImageProxyCreate(char a1)
{
  if (C3DImageProxyGetTypeID_onceToken != -1) {
    dispatch_once(&C3DImageProxyGetTypeID_onceToken, &__block_literal_global_45);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DImageProxyGetTypeID_typeID, 0x30uLL);
  if (!Instance)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  *(unsigned char *)(Instance + 56) = a1;
  return Instance;
}

uint64_t C3DImageProxyCreateTextureProxy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16);
  if (!v14) {
    return 0;
  }
  uint64_t Source = C3DImageProxyGetSource(a1);
  uint64_t result = v14(a3, a2, Source);
  if (result) {
    *(void *)(result + 104) = a1;
  }
  return result;
}

uint64_t C3DImageProxyGetSource(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t C3DImageProxyIsOpaque(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t))(a1 + 24);
  if (!v10) {
    return 1;
  }
  uint64_t Source = C3DImageProxyGetSource(a1);
  return v10(Source);
}

uint64_t C3DImageProxyIsPremultiplied(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t))(a1 + 32);
  if (!v10) {
    return 1;
  }
  uint64_t Source = C3DImageProxyGetSource(a1);
  return v10(Source);
}

uint64_t C3DImageProxyGetCaptureDeviceInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  if (!*(void *)(a1 + 40))
  {
    long double v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyGetCaptureDeviceInfo_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  float v24 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40);
  uint64_t Source = C3DImageProxyGetSource(a1);
  return v24(Source, a2, a3, a4);
}

uint64_t C3DImageProxyGetSourceType(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned __int8 *)(a1 + 56);
}

CFTypeRef C3DImageProxySetSource(uint64_t a1, CFTypeRef cf, char a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 48);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = result;
    *(unsigned char *)(a1 + 56) = a3;
  }
  return result;
}

__n128 C3DImageProxySetCallbacks(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DImageProxyCreateTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  __n128 result = *(__n128 *)a2;
  long long v13 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 32) = v13;
  return result;
}

void _C3DTextureProxyCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 96) = 0;
  }
}

CFStringRef _C3DTextureProxyCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTextureProxy>");
}

CFStringRef _C3DTextureProxyCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<C3DTextureProxy>");
}

uint64_t __C3DTextureProxyGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DTextureProxyGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DTextureProxyCreate()
{
  if (C3DTextureProxyGetTypeID_onceToken != -1) {
    dispatch_once(&C3DTextureProxyGetTypeID_onceToken, &__block_literal_global_8);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DTextureProxyGetTypeID_typeID, 0x60uLL);
  if (!Instance)
  {
    CFAllocatorRef v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }
  }
  return Instance;
}

uint64_t C3DTextureProxyGetOpenGLTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
  if (!v14) {
    return 0;
  }
  uint64_t Source = C3DTextureProxyGetSource(a1);
  return v14(a2, Source, a3);
}

uint64_t C3DTextureProxyGetSource(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      __deleteTextureProxies_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 96);
}

uint64_t C3DTextureProxyGetMetalTexture(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DTextureCreate_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
  long double v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 80);
  if (!v16) {
    return 0;
  }
  uint64_t Source = C3DTextureProxyGetSource(a1);
  return v16(a2, Source, a3, a4);
}

void C3DTextureProxyRenderInCurrentContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __deleteTextureProxies_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 88);
  if (v14)
  {
    uint64_t Source = C3DTextureProxyGetSource(a1);
    v14(a2, Source, a3);
  }
}

CFTypeRef C3DTextureProxySetSource(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __deleteTextureProxies_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 96);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 96) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 96) = result;
  }
  return result;
}

void C3DTextureProxySetCallbacks(uint64_t a1, long long *a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      __deleteTextureProxies_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2)
  {
    long long v12 = *a2;
    *(_OWORD *)(a1 + 80) = a2[1];
  }
  else
  {
    long long v12 = 0uLL;
    *(_OWORD *)(a1 + 80) = 0u;
  }
  *(_OWORD *)(a1 + 64) = v12;
}

C3D::RenderPass *C3D::SSRCompositePass::SSRCompositePass(C3D::RenderPass *a1, RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  CFTypeRef result = C3D::RenderPass::RenderPass(a1, a2, a3);
  *(void *)CFTypeRef result = &unk_26BF6D970;
  *((void *)result + 31) = a4;
  return result;
}

const char *C3D::SSRCompositePass::name(C3D::SSRCompositePass *this)
{
  return "SSRCompositePass";
}

double C3D::SSRCompositePass::setup(C3D::SSRCompositePass *this)
{
  C3D::Pass::setInputCount(this, 4u);
  C3D::Pass::setOutputCount(this, 1u);
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRCompositePass *)((char *)this + 32), 0) + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRCompositePass *)((char *)this + 32), 1u) + _Block_object_dispose(&STACK[0x2A0], 8) = "Radiance";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRCompositePass *)((char *)this + 32), 2u) + _Block_object_dispose(&STACK[0x2A0], 8) = "ReflectanceRoughness";
  *(void *)(C3D::PassDescriptor::inputAtIndex((C3D::SSRCompositePass *)((char *)this + 32), 3u) + _Block_object_dispose(&STACK[0x2A0], 8) = "SSR";
  uint64_t v2 = C3D::PassDescriptor::outputAtIndex((C3D::SSRCompositePass *)((char *)this + 32), 0);
  *(void *)(v2 + _Block_object_dispose(&STACK[0x2A0], 8) = "COLOR";
  *(unsigned char *)(v2 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v4);
  double result = *(double *)&v4;
  *(_OWORD *)(v2 + 16) = v4;
  *(_DWORD *)(v2 + 32) = v5;
  *(_WORD *)(v2 + 66) &= 0xFFFCu;
  return result;
}

uint64_t C3D::SSRCompositePass::compile(C3D::SSRCompositePass *this)
{
  uint64_t RenderContext = C3DEngineContextGetRenderContext(*((void *)this + 2));
  -[SCNMTLRenderContext resourceManager](RenderContext);
  uint64_t v3 = (*(uint64_t (**)(C3D::SSRCompositePass *))(*(void *)this + 64))(this);
  unint64_t v4 = 0xC6A4A7935BD1E995
     * ((0xC6A4A7935BD1E995 * (v3 ^ 0x35253C9ADE8F4CA8)) ^ ((0xC6A4A7935BD1E995 * (v3 ^ 0x35253C9ADE8F4CA8)) >> 47));
  uint64_t result = C3D::RenderGraphResourceManager::get(*(C3D::RenderGraphResourceManager **)(*((void *)this + 3) + 128), v4 ^ (v4 >> 47));
  *((void *)this + 30) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t C3D::SSRCompositePass::execute(C3D::Pass *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = [(id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((void *)a1 + 30) + 16) state];
  if (*(void *)(v3 + 3376) != v4)
  {
    *(void *)(v3 + 3376) = v4;
    [*(id *)(v3 + 3392) setRenderPipelineState:v4];
  }
  int v5 = C3D::Pass::inputTextureAtIndex(a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v5, 0);
  uint64_t v6 = C3D::Pass::inputTextureAtIndex(a1, 1u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v6, 1uLL);
  uint64_t v7 = C3D::Pass::inputTextureAtIndex(a1, 2u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v7, 2uLL);
  uint64_t v8 = C3D::Pass::inputTextureAtIndex(a1, 3u);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v8, 3uLL);

  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v3);
}

void C3D::SSRCompositePassResource::~SSRCompositePassResource(C3D::SSRCompositePassResource *this)
{
  *(void *)this = &unk_26BF6E4F0;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {
}
  }

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_26BF6E4F0;
  CFAllocatorRef v1 = (void *)*((void *)this + 2);
  if (v1) {

  }
  JUMPOUT(0x210534FE0);
}

void _C3DEnginePipelineCFFinalize(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DEngineContextRenderScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  Shareduint64_t Instance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterRemoveObserver(SharedInstance, a1, @"kC3DNotificationNodeWillDie", 0);
  uint64_t v11 = (unsigned char *)a1[4];
  if (v11)
  {
    C3DEngineNotificationQueueStopObserving(v11);
    long long v12 = (const void *)a1[4];
    if (v12)
    {
      CFRelease(v12);
      a1[4] = 0;
    }
  }
  uint64_t v13 = (const void *)a1[3];
  if (v13)
  {
    CFRelease(v13);
    a1[3] = 0;
  }
  uint64_t v14 = (const void *)a1[5];
  if (v14)
  {
    CFRelease(v14);
    a1[5] = 0;
  }
  uint64_t v15 = (const void *)a1[6];
  if (v15)
  {
    CFRelease(v15);
    a1[6] = 0;
  }
}

CFStringRef _C3DEnginePipelineCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DEnginePipeline %p>", a1);
}

CFStringRef _C3DEnginePipelineCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DEnginePipeline %p>", a1);
}

void C3DEnginePipelineSyncNodeAttribute(uint64_t a1, void *a2, void *cf1, uint64_t a4)
{
  if (!cf1)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineSyncNodeAttribute_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    long double v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineSyncNodeAttribute_cold_2(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  if (CFEqual(cf1, @"kMeshKey")
    || CFEqual(cf1, @"kCameraKey")
    || CFEqual(cf1, @"kLightKey")
    || CFEqual(cf1, @"kDeformerStackKey")
    || CFEqual(cf1, @"rendererDelegate"))
  {
    CFRetain(a2);
    if (CFEqual(cf1, @"kMeshKey")) {
      goto LABEL_22;
    }
    uint64_t Attribute = (uint64_t)C3DEntityGetAttribute((uint64_t)a2, cf1);
    if (!Attribute)
    {
      if (!CFEqual(cf1, @"kDeformerStackKey"))
      {
        if (C3DNodeIsHidden((uint64_t)a2)) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
      uint64_t Attribute = C3DNodeGetDeformerStack((uint64_t)a2);
    }
    if (C3DNodeIsHidden((uint64_t)a2))
    {
      if (!Attribute)
      {
LABEL_22:
        if (CFEqual(cf1, @"kMeshKey")
          || CFEqual(cf1, @"rendererDelegate")
          || CFEqual(cf1, @"kLightKey"))
        {
          if (CFEqual(cf1, @"kMeshKey"))
          {
            char v25 = 0;
            char v26 = 0;
          }
          else if (CFEqual(cf1, @"rendererDelegate"))
          {
            char v25 = 1;
            char v26 = 1;
          }
          else if (CFEqual(cf1, @"kLightKey"))
          {
            char v25 = 0;
            char v26 = 4;
          }
          else
          {
            unsigned int v27 = scn_default_log();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              C3DEnginePipelineSyncNodeAttribute_cold_1((uint64_t)cf1, v27);
            }
            char v25 = 0;
            char v26 = -1;
          }
          int RenderableAttributeHash = C3DNodeGetRenderableAttributeHash((uint64_t)a2);
          if ((v25 & 1) != 0 || !RenderableAttributeHash || ((1 << v26) & RenderableAttributeHash) != 0)
          {
            uint64_t v29 = *(void *)(a4 + 8);
            uint64_t v30 = C3DGetScene(a2);
            if (v30 == C3DEngineContextGetScene(v29) && (C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)a2) & 1) == 0) {
              C3DEnginePipelineUpdateNode(a1, v29, (uint64_t)a2);
            }
          }
        }
        CFRelease(a2);
        return;
      }
    }
    else if (Attribute)
    {
      C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, cf1);
      goto LABEL_22;
    }
LABEL_21:
    C3DEnginePipelineRemoveNodeForKey(a1, a2, cf1);
    goto LABEL_22;
  }
}

void C3DEnginePipelineUpdateNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned int *)(a3 + 228);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      ElementInSpanAtuint64_t Index = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), *(void *)(a3 + 224), i);
      __UntrackRendererElementsDependencies(a1, ElementInSpanAtIndex);
    }
  }
  uint64_t v9 = *(_WORD **)(a3 + 232);
  if (v9)
  {
    uint64_t v10 = (unsigned __int16)*v9;
    if (*v9)
    {
      uint64_t v11 = 0;
      do
      {
        uint64_t v12 = *(void *)(a3 + 232) + 12 * v11;
        uint64_t v13 = *(unsigned int *)(v12 + 16);
        if (v13)
        {
          uint64_t v14 = 0;
          unint64_t v15 = *(unsigned int *)(v12 + 12) | (unint64_t)(v13 << 32);
          do
          {
            long double v16 = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), v15, v14);
            if (v16) {
              __UntrackRendererElementsDependencies(a1, v16);
            }
            ++v14;
          }
          while (v13 != v14);
        }
        ++v11;
      }
      while (v11 != v10);
    }
  }
  C3DRendererElementStoreDeallocateSpanForNode(a1, a3);
  if ((C3DNodeIsHidden(a3) & 1) == 0)
  {
    int RenderableAttributeHash = C3DNodeGetRenderableAttributeHash(a3);
    if (RenderableAttributeHash)
    {
      _C3DEnginePipelineAllocateAndTrackRendererElements(a1, a2, a3, RenderableAttributeHash);
    }
  }
}

uint64_t C3DEnginePipelineInvalidateAllProgramHashCode(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return C3DSceneEnumerateEngineContexts(result, (uint64_t)&__block_literal_global_5);
  }
  return result;
}

uint64_t __C3DEnginePipelineInvalidateAllProgramHashCode_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a2);
  C3DProgramHashCodeStoreClear(ProgramHashCodeStore);
  SortSysteCFIndex m = C3DEngineContextGetSortSystem(a2);

  return C3DSortSystemInvalidate(SortSystem);
}

uint64_t __ResyncAllNodes(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  uint64_t result = C3DEngineContextGetScene(v1);
  if (result)
  {
    uint64_t result = C3DSceneGetRootNode(result);
    if (result)
    {
      v4[0] = MEMORY[0x263EF8330];
      v4[1] = 3221225472;
      v4[2] = ____ResyncAllNodes_block_invoke;
      v4[3] = &__block_descriptor_48_e315_q16__0____C3DNode____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DNode_____C3DNode_____C3DNode_i____C3DMatrix4x4__16f__4_____4__________C3DMatrix4x4_BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1______SS_I_________C3DGeometry_____C3DDeformerStack_f_____8l;
      v4[4] = v2;
      void v4[5] = v1;
      return C3DNodeApplyHierarchy(result, (uint64_t)v4);
    }
  }
  return result;
}

void C3DEnginePipelineRemoveNodeFromRendering(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 228);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      ElementInSpanAtuint64_t Index = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), *(void *)(a2 + 224), i);
      __UntrackRendererElementsDependencies(a1, ElementInSpanAtIndex);
    }
  }
  uint64_t v7 = *(_WORD **)(a2 + 232);
  if (v7)
  {
    uint64_t v8 = (unsigned __int16)*v7;
    if (*v7)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = *(void *)(a2 + 232) + 12 * v9;
        uint64_t v11 = *(unsigned int *)(v10 + 16);
        if (v11)
        {
          uint64_t v12 = 0;
          unint64_t v13 = *(unsigned int *)(v10 + 12) | (unint64_t)(v11 << 32);
          do
          {
            uint64_t v14 = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(void *)(a1 + 48), v13, v12);
            if (v14) {
              __UntrackRendererElementsDependencies(a1, v14);
            }
            ++v12;
          }
          while (v11 != v12);
        }
        ++v9;
      }
      while (v9 != v8);
    }
  }
  __UntrackNodeDependencies(a1, (const void *)a2);

  C3DRendererElementStoreDeallocateSpanForNode(a1, a2);
}

uint64_t C3DEnginePipelineUpdateNodeRendererElements(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 228);
  if (v3)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(result + 48);
    unint64_t v8 = *(unsigned int *)(a2 + 224) | (unint64_t)(v3 << 32);
    do
    {
      ElementInSpanAtuint64_t Index = C3DRendererElementStoreGetElementInSpanAtIndex(v7, v8, v6);
      uint64_t result = C3DEnginePipelineSyncRendererElement(v5, ElementInSpanAtIndex, a3);
      ++v6;
    }
    while (v3 != v6);
  }
  return result;
}

void __HandleGeometryDidChangeNotifications(uint64_t a1, __int16 a2, long long *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v15 = *a3;
  if (a2 == 3 || (uint64_t v5 = scn_default_log(), !os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)))
  {
    if ((a2 & 0x400) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  __HandleGeometryDidChangeNotifications_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  if ((a2 & 0x400) != 0)
  {
LABEL_4:
    long long v16 = xmmword_26BF721A0;
    uint64_t v17 = qword_26BF721B0;
    *(void *)&long long v18 = v15;
    *((void *)&v18 + 1) = a1;
    uint64_t RootNode = C3DSceneGetRootNode(*(void *)(v15 + 16));
    C3DNodeIterateTree(RootNode, (uint64_t (**)(uint64_t, uint64_t))&v16, 0, (uint64_t)&v18);
  }
LABEL_5:
  if ((a2 & 0x800) != 0)
  {
    long long v16 = xmmword_26BF721B8;
    uint64_t v17 = qword_26BF721C8;
    long long v18 = v15;
    uint64_t v19 = a1;
    uint64_t v14 = C3DSceneGetRootNode(*(void *)(v15 + 16));
    C3DNodeIterateTree(v14, (uint64_t (**)(uint64_t, uint64_t))&v16, 0, (uint64_t)&v18);
  }
}

uint64_t __InvalidateRendererElementsHashCodeForGeometry(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (C3DNodeGetGeometry(a1) == v4) {
    C3DEnginePipelineUpdateNodeRendererElements(v3, a1, 3);
  }
  return 0;
}

uint64_t __RebuildRendererElementsForGeometry(_DWORD *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = a2[2];
  if (C3DNodeGetGeometry((uint64_t)a1) == v5)
  {
    C3DEnginePipelineRemoveNodeFromRendering(v3, (uint64_t)a1);
    C3DEnginePipelineAddNodeToRendering(v3, v4, a1);
  }
  return 0;
}

void __HandleLightDidChangeNotifications(uint64_t a1, __int16 a2, long long *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v5 = *a3;
  if (a2 != 4
    && (long long v16 = *a3, v6 = scn_default_log(), v7 = os_log_type_enabled(v6, OS_LOG_TYPE_FAULT), v5 = v16, v7))
  {
    __HandleLightDidChangeNotifications_cold_1(v6, v8, v9, v10, v11, v12, v13, v14);
    long long v5 = v16;
    if ((a2 & 0x200) == 0) {
      return;
    }
  }
  else if ((a2 & 0x200) == 0)
  {
    return;
  }
  long long v17 = xmmword_26BF721D0;
  uint64_t v18 = qword_26BF721E0;
  long long v19 = v5;
  uint64_t v20 = a1;
  uint64_t RootNode = C3DSceneGetRootNode(*(void *)(v5 + 16));
  C3DNodeIterateTree(RootNode, (uint64_t (**)(uint64_t, uint64_t))&v17, 0, (uint64_t)&v19);
}

uint64_t __RebuildRendererElementsForLight(_DWORD *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  CFDictionaryRef v5 = (const __CFDictionary *)a2[2];
  if (C3DNodeGetLight((uint64_t)a1) == v5)
  {
    C3DEnginePipelineRemoveNodeFromRendering(v3, (uint64_t)a1);
    C3DEnginePipelineAddNodeToRendering(v3, v4, a1);
  }
  return 0;
}

uint64_t __ResyncRendererElements(uint64_t a1, uint64_t a2)
{
  return C3DEnginePipelineSyncRendererElement(a2, a1, 16);
}

void __HandleNodeWillDieNotification(uint64_t a1, uint64_t a2, __CFString *a3, uint64_t a4)
{
  context[2] = *MEMORY[0x263EF8340];
  if (@"kC3DNotificationNodeWillDie" != a3)
  {
    uint64_t v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      __HandleNodeWillDieNotification_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  context[0] = a2;
  context[1] = a4;
  CFDictionaryRef v14 = *(const __CFDictionary **)(a2 + 24);
  if (v14) {
    CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)__RemoveValueFromAttributesCachedList, context);
  }
}

BOOL C3DEnginePipelineAddNodeForKeyIfAbsent(uint64_t a1, const void *a2, void *key)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  CFDictionaryRef v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!key)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  NodesForKefloat y = (const __CFSet *)__C3DEnginePipelineGetNodesForKey(a1, key, 1, 0);
  int v31 = CFSetContainsValue(NodesForKey, a2);
  if (!v31) {
    CFSetAddValue(NodesForKey, a2);
  }
  return v31 == 0;
}

void __UntrackRendererElementsDependencies(uint64_t a1, const void *a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      _C3DRendererElementSync_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t Material = (const void *)C3DRendererElementGetMaterial((uint64_t)a2);
  if (Material)
  {
    uint64_t v13 = Material;
    CFDictionaryRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Material);
    if (Value)
    {
      CFSetRef v15 = Value;
      CFSetRemoveValue(Value, a2);
      if (!CFSetGetCount(v15)) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), v13);
      }
    }
  }
}

uint64_t __UntrackNodeDependencies(uint64_t a1, const void *a2)
{
  if (!a2)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  C3DEnginePipelineRemoveNodeForKey(a1, a2, @"kCameraKey");
  return C3DEnginePipelineRemoveNodeForKey(a1, a2, @"kDeformerStackKey");
}

uint64_t C3DEnginePipelineRemoveNodeForKey(uint64_t a1, const void *a2, void *key)
{
  if (!a1 && (uint64_t v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2) {
      goto LABEL_6;
    }
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  CFDictionaryRef v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
    C3DGeometryTrackNode_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
LABEL_6:
  if (!key)
  {
    uint64_t v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      _C3DAnimationManagerGetAnimationNodeForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  uint64_t result = (uint64_t)__C3DEnginePipelineGetNodesForKey(a1, key, 0, 0);
  if (result)
  {
    CFSetRef v31 = (const __CFSet *)result;
    if (CFSetGetCount((CFSetRef)result) < 1)
    {
      return 0;
    }
    else
    {
      uint64_t result = CFSetContainsValue(v31, a2);
      if (result)
      {
        CFSetRemoveValue(v31, a2);
        return 1;
      }
    }
  }
  return result;
}

uint64_t __RemoveValueFromAttributesCachedList(void *key, uint64_t a2, uint64_t a3)
{
  return C3DEnginePipelineRemoveNodeForKey(*(void *)a3, *(const void **)(a3 + 8), key);
}

void C3DEnginePipelineRenderSubTree(void *a1, uint64_t a2)
{
  v128[1] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      __ApplyMaterialDidChange_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  uint64_t v11 = a1[1];
  uint64_t v12 = a1[2];
  uint64_t RenderContext = C3DEngineContextGetRenderContext(v11);
  uint64_t FXContext = C3DEngineContextGetFXContext(v11);
  SortSysteCFIndex m = (void *)C3DEngineContextGetSortSystem(v11);
  uint64_t v14 = *(unsigned __int8 *)(FXContext + 120);
  uint64_t Stats = C3DEngineContextGetStats(v11);
  uint64_t v15 = *(void *)(*a1 + 48);
  if (!v12)
  {
    uint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3DEnginePipelineRenderSubTree_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  uint64_t Pass = C3DFXPassInstanceGetPass(v12);
  uint64_t RendererContextGL = C3DEngineContextGetRendererContextGL(v11);
  uint64_t v90 = v15;
  if (RendererContextGL && (uint64_t RendererElementState = C3DEngineContextGetRendererElementState(v11)) != 0)
  {
    uint64_t v101 = RendererElementState;
    C3DRendererElementStateBeginProcessing(RendererElementState, Pass, v11);
    char v93 = 0;
  }
  else
  {
    uint64_t v101 = 0;
    char v93 = 1;
  }
  float v104 = a1;
  uint64_t v94 = Pass;
  uint64_t v95 = FXContext;
  uint64_t v96 = v11;
  int v107 = C3DFXPassRequiresLighting(*(void *)(v12 + 4736));
  uint64_t ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(*(void *)(v12 + 4816));
  uint64_t v27 = *(void *)(*(void *)(v12 + 80) + 48);
  Capacitfloat y = C3DRendererElementStoreGetCapacity(v27);
  C3DProgramHashCodeStoreSetCapacity(ProgramHashCodeStore, Capacity);
  BOOL IsClusteredShadingEnabled = C3DEngineContextIsClusteredShadingEnabled(*(void *)(v12 + 4816));
  uint64_t v29 = C3DEngineContextGetFXContext(*(void *)(v12 + 4816));
  unint64_t LightingSystem = C3DSceneGetLightingSystem(*(void *)(v12 + 4808));
  uint64_t v87 = v12 + 80;
  C3DLightingSystemBeginQueries(LightingSystem, v12 + 80 + ((unint64_t)*(unsigned __int8 *)(v29 + 120) << 6) + 3088, *(void *)(v12 + 4816));
  uint64_t v127 = 0;
  long long v125 = 0u;
  long long v126 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  float32x4_t v121 = 0u;
  int32x4_t v122 = 0u;
  C3DLightingSystemGetLightingContext(LightingSystem, *(void *)(v12 + 4816), (uint64_t)&v121);
  v128[0] = 0;
  int v120 = 0;
  uint64_t v98 = LightingSystem;
  int InfiniteLightSet = C3DLightingSystemGetInfiniteLightSet(LightingSystem, v128, &v120);
  if (InfiniteLightSet)
  {
    C3DLightingSystemCheckLightingSetTextureUsage(LightingSystem, (uint64_t)v128);
    unsigned __int8 LightingSetProgramHashCodes = C3DLightingSystemGetLightingSetProgramHashCodes(LightingSystem, (uint64_t)v128, &v121.i32[1]);
    v121.i16[0] = (LightingSetProgramHashCodes << 7) | v121.i16[0] & 0x807F;
  }
  uint64_t v88 = v14;
  uint64_t v97 = v12 + 16 * v14;
  uint64_t v32 = *(unsigned int *)(v97 + 5000);
  uint64_t v105 = v12;
  if (v32)
  {
    long long v33 = *(unsigned int **)(v97 + 4992);
    uint64_t v102 = ProgramHashCodeStore;
    uint64_t v103 = v27;
    do
    {
      unsigned int v34 = *v33++;
      unint64_t LightingSystem = LightingSystem & 0xFFFFFFFF00000000 | v34;
      uint64_t Element = C3DRendererElementStoreGetElement(v27, LightingSystem);
      if (!C3DRendererElementIsRendererDelegate(Element))
      {
        uint64_t v36 = *(float32x4_t **)(Element + 8);
        __int16 v37 = *(_WORD *)(Element + 72);
        if ((v37 & 0x40) != 0)
        {
          if (!IsClusteredShadingEnabled)
          {
            if (InfiniteLightSet)
            {
              *(void *)(Element + 56) = v128[0];
            }
            else
            {
              float32x4_t v111 = 0u;
              float32x4_t v112 = 0u;
              C3DNodeGetLocalBoundingBox((uint64_t)v36, &v111);
              WorldMatrifloat x = C3DNodeGetWorldMatrix(v36);
              float32x4_t v118 = 0u;
              float32x4_t v119 = 0u;
              float32x4_t v39 = WorldMatrix[1];
              float32x4_t v40 = WorldMatrix[2];
              float32x4_t v41 = vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v39, *(float32x2_t *)v111.f32, 1), *WorldMatrix, v111.f32[0]), v40, v111, 2));
              v41.i32[3] = 1.0;
              float32x4_t v42 = v112;
              v42.i32[1] = v112.i32[0];
              v42.i32[2] = v112.i32[0];
              float32x4_t v43 = vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(*WorldMatrix, v42)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v112.f32, 1), (int32x4_t)v112), v39))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v112, (int32x4_t)v112), (int32x4_t)v112), v40)));
              float32x4_t v118 = v41;
              float32x4_t v119 = v43;
              CategoryBitMasuint64_t k = C3DNodeGetCategoryBitMask((uint64_t)v36);
              C3DLightingSystemQuery(v98, &v118, CategoryBitMask, (void *)(Element + 56));
              unsigned __int8 v45 = C3DLightingSystemGetLightingSetProgramHashCodes(v98, Element + 56, &v121.i32[1]);
              v121.i16[0] = (v45 << 7) | v121.i16[0] & 0x807F;
              __int16 v37 = *(_WORD *)(Element + 72);
            }
          }
          *(_WORD *)(Element + 72) = (8 * v121.i16[0]) & 0x380 | v37 & 0xFC7F;
        }
        float32x4_t v46 = (void *)C3DFXPassInstanceGetPass(v12);
        unsigned int PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(*(void *)(v12 + 4816));
        uint64_t ProgramHashCodeForRenderElement = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)Element, v46, PreferredRenderMode);
        if (ProgramHashCodeForRenderElement)
        {
          if (v107)
          {
            if (!IsClusteredShadingEnabled) {
              goto LABEL_29;
            }
            long long v115 = v125;
            long long v116 = v126;
            uint64_t v117 = v127;
            float32x4_t v111 = v121;
            float32x4_t v112 = (float32x4_t)v122;
            long long v113 = v123;
            long long v114 = v124;
            if (!C3DProgramHashCodeMatchLightHashCodesAndLightingContext(ProgramHashCodeForRenderElement, (unsigned __int16 *)&v111))goto LABEL_29; {
          }
            }
        }
        else
        {
          uint64_t v49 = *(void **)(v12 + 4736);
          if (!v49 || !C3DFXPassGetOverridingProgramHashCode(0, v49, (unsigned __int16 *)Element))
          {
LABEL_29:
            uint64_t Mesh = C3DRendererElementGetMesh(Element);
            Meshuint64_t Element = C3DRendererElementGetMeshElement(Element);
            uint64_t Geometry = (__C3DGeometry *)C3DRendererElementGetGeometry(Element);
            uint64_t Material = C3DRendererElementGetMaterial(Element);
            uint64_t v54 = *(void *)(Element + 8);
            if (v54)
            {
              if ((*(unsigned char *)(v54 + 221) & 0x10) != 0)
              {
                uint64_t v55 = *(void *)(Element + 40);
                if (v55) {
                  C3DFXTechniqueEnsureThatPassesShouldExecute(v55);
                }
              }
            }
            uint64_t v12 = v105;
            unint64_t v109 = ((unint64_t)*(unsigned __int8 *)(v12 + 24) << 16) | ((unint64_t)((8
                                                                                                 * (*(unsigned char *)(v12 + 27) & 3)) & 0x9F | (*(unsigned __int16 *)(Element + 72) >> 11) & 7 | (32 * (*(unsigned char *)(v12 + 28) & 3u))) << 24) | C3DEngineContextGetCommonProfileConditioners(*(void *)(v105 + 4816)) | v109 & 0xFFFFFFFF00000000;
            float32x4_t v56 = (const void *)C3DProgramHashCodeCreate(v36, Geometry, Mesh, (uint64_t)MeshElement, &v121, Material, v109);
            uint64_t ProgramHashCodeStore = v102;
            C3DProgramHashCodeStoreRegisterProgramForRendererElement(v102, (unsigned int *)Element, v56, *(void *)(v105 + 4736), 0);
            if (v56) {
              CFRelease(v56);
            }
            uint64_t v27 = v103;
          }
        }
      }
      --v32;
    }
    while (v32);
  }
  if (C3DFXPassGetDrawInstruction(*(void *)v12) != 6)
  {
    double v57 = CACurrentMediaTime();
    ParticleManager = C3DSceneGetParticleManager(*(void *)(v12 + 4808), 0);
    if (ParticleManager)
    {
      uint64_t v59 = (uint64_t)ParticleManager;
      if (C3DFXPassGetLayerMask(*(void *)v12)) {
        C3DParticleManagerCull(v59, v87, v96, v88, 0, 0);
      }
    }
    *(double *)(Stats + 120) = *(double *)(Stats + 120) + CACurrentMediaTime() - v57;
  }
  if (v107)
  {
    uint64_t v60 = C3DSceneGetLightingSystem(*(void *)(v12 + 4808));
    C3DLightingSystemEndQueries(v60);
  }
  unint64_t v61 = *(unsigned int *)(v97 + 5000);
  unint64_t v62 = *(void *)(v97 + 4992);
  double v63 = CACurrentMediaTime();
  C3DSortSystemSyncKeys((uint64_t)SortSystem, v96, (unsigned int *)v62, v61, 0);
  C3DSortSystemSort(SortSystem, v96, (void *)v62, v61);
  *(double *)(Stats + 152) = *(double *)(Stats + 152) + CACurrentMediaTime() - v63;
  if (C3DEngineContextGetMaxDrawingCommand(v96))
  {
    uint64_t v64 = C3DEngineContextGetStats(v96);
    unsigned int v65 = C3DEngineContextGetMaxDrawingCommand(v96) + ~*(_DWORD *)(v64 + 12);
    if (v61 >= v65) {
      unsigned int v66 = v65;
    }
    else {
      unsigned int v66 = v61;
    }
    unsigned int v67 = 0;
    if (C3DEngineContextGetIsolateMode(v96) && v64)
    {
      unint64_t v61 = (v61 + *(_DWORD *)(v64 + 12) + 1);
      unsigned int MaxDrawingCommand = C3DEngineContextGetMaxDrawingCommand(v96);
      unsigned int v69 = v66 - 1;
      if (!v66) {
        unsigned int v69 = 0;
      }
      if (v61 >= MaxDrawingCommand) {
        unsigned int v67 = v69;
      }
      else {
        unsigned int v67 = 0;
      }
    }
  }
  else
  {
    unsigned int v67 = 0;
    unsigned int v66 = v61;
  }
  double v70 = CACurrentMediaTime();
  if (RenderContext)
  {
    v104[40] = v107;
    -[SCNMTLRenderContext processRendererElements:count:engineIterationContext:](RenderContext, v62, v66, (uint64_t)v104);
  }
  else
  {
    uint64_t WarmUpAbortHandler = C3DEngineContextGetWarmUpAbortHandler(v96);
    BOOL v72 = v66 >= v67;
    unsigned int v73 = v66 - v67;
    if (v73 != 0 && v72)
    {
      unint64_t v61 = WarmUpAbortHandler;
      uint64_t v74 = (unsigned int *)(v62 + 4 * v67);
      do
      {
        unsigned int v75 = *v74++;
        unint64_t v62 = v62 & 0xFFFFFFFF00000000 | v75;
        uint64_t v76 = C3DRendererElementStoreGetElement(v90, v62);
        C3DRendererElementStateProcessRendererElement(v101, v76, (uint64_t)v104);
        if (v61 && ((*(uint64_t (**)(unint64_t))(v61 + 16))(v61) & 1) != 0) {
          break;
        }
        ++*(_DWORD *)(Stats + 12);
        --v73;
      }
      while (v73);
    }
  }
  *(double *)(Stats + 152) = *(double *)(Stats + 152) + CACurrentMediaTime() - v70;
  if (RendererContextGL) {
    Showsuint64_t AuthoringEnvironment = C3DRendererContextGetShowsAuthoringEnvironment(RendererContextGL);
  }
  else {
    Showsuint64_t AuthoringEnvironment = 0;
  }
  BOOL v78 = RenderContext;
  if (RenderContext) {
    BOOL v78 = -[SCNMTLRenderContext showsAuthoringEnvironment](RenderContext);
  }
  if (v78 | ShowsAuthoringEnvironment)
  {
    uint64_t AuthoringEnvironment = C3DEngineContextGetAuthoringEnvironment(v96, 1);
    if (C3DAuthoringEnvironmentShouldDisplayConstraints(AuthoringEnvironment))
    {
      uint64_t ControllerManager = C3DSceneGetControllerManager(*(void *)(*(void *)v104 + 16));
      C3DConstraintManagerAppendAuthoringInfo(ControllerManager, AuthoringEnvironment);
    }
    if (*(void *)(v95 + 248) == v94)
    {
      uint64_t v82 = *(unsigned int *)(v105 + 5000);
      if (v82)
      {
        simd_float4x4 v83 = *(unsigned int **)(v105 + 4992);
        do
        {
          unsigned int v84 = *v83++;
          unint64_t v61 = v61 & 0xFFFFFFFF00000000 | v84;
          uint64_t v85 = C3DRendererElementStoreGetElement(v90, v61);
          char v86 = *(float32x4_t **)(v85 + 8);
          if (v86) {
            C3DAuthoringEnvironmentAppendDebugNode(AuthoringEnvironment, v86, v85);
          }
          --v82;
        }
        while (v82);
      }
      v110[0] = MEMORY[0x263EF8330];
      v110[1] = 3221225472;
      v110[2] = __C3DEnginePipelineRenderSubTree_block_invoke;
      v110[3] = &__block_descriptor_40_e315_q16__0____C3DNode____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DNode_____C3DNode_____C3DNode_i____C3DMatrix4x4__16f__4_____4__________C3DMatrix4x4_BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1______SS_I_________C3DGeometry_____C3DDeformerStack_f_____8l;
      v110[4] = AuthoringEnvironment;
      C3DNodeApplyHierarchy(a2, (uint64_t)v110);
      C3DAuthoringEnvironmentDrawZbufferDependant(AuthoringEnvironment);
    }
    if (v105 == *(void *)(v95 + 256)) {
      C3DAuthoringEnvironmentDrawZbufferIndependant(AuthoringEnvironment, v80);
    }
    C3DAuthoringEnvironmentDrawPending(AuthoringEnvironment);
  }
  if ((v93 & 1) == 0) {
    C3DRendererElementStateEndProcessing(v101, v94, v96);
  }
}

uint64_t __C3DEnginePipelineRenderSubTree_block_invoke(uint64_t a1, float32x4_t *a2)
{
  if (C3DNodeIsHiddenOrTransparent((uint64_t)a2)) {
    return 1;
  }
  C3DAuthoringEnvironmentAppendDebugNodeAttributes(*(void *)(a1 + 32), a2);
  return 0;
}

uint64_t C3DEnginePipelineInvalidateAllSkinnersTransfromTreeHandles(uint64_t result)
{
  *(unsigned char *)(result + 59) = 1;
  return result;
}

uint64_t C3DTriangle3PointAtIndex(uint64_t a1, unsigned int a2)
{
  return a1 + 16 * a2;
}

BOOL C3DTriangle3BarycentricCoordinates(_OWORD *a1, long long *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  long long v3 = *a1;
  long long v4 = a1[1];
  uint64_t v11 = *(void *)a1;
  int v12 = DWORD2(v3);
  int v13 = 1065353216;
  uint64_t v14 = v4;
  int v15 = DWORD2(v4);
  int v16 = 1065353216;
  long long v5 = a1[2];
  uint64_t v17 = *((void *)a1 + 4);
  int v18 = DWORD2(v5);
  int v19 = 1065353216;
  long long v6 = *a2;
  uint64_t v20 = *(void *)a2;
  int v21 = DWORD2(v6);
  int v22 = 1065353216;
  BOOL v7 = C3DGaussianSolve((uint64_t)&v11, 4u, 3, a3);
  if (!v7)
  {
    uint64_t v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl(&dword_20B249000, v8, OS_LOG_TYPE_DEFAULT, "Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation", v10, 2u);
    }
  }
  return v7;
}

BOOL C3DTriangle3ContainsPoint(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2 = vsubq_f32(a1[1], *a1);
  float32x4_t v3 = vsubq_f32(a1[2], *a1);
  float32x4_t v4 = vsubq_f32(*a2, *a1);
  float32x4_t v5 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL);
  float32x4_t v6 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL);
  float32x4_t v7 = vnegq_f32(v3);
  float32x4_t v8 = vmlaq_f32(vmulq_f32(v6, v7), v4, v5);
  float32x4_t v9 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL);
  float32x4_t v10 = vmulq_f32(vmlaq_f32(vmulq_f32(v9, v7), v2, v5), v8);
  if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), v10)).f32[0] < 0.0)return 0; {
  float32x4_t v11 = vnegq_f32(v2);
  }
  float32x4_t v12 = vmlaq_f32(vmulq_f32(v6, v11), v4, v9);
  float32x4_t v13 = vmlaq_f32(vmulq_f32(v5, v11), v3, v9);
  float32x4_t v14 = vmulq_f32(v13, v12);
  if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), v14)).f32[0] < 0.0)return 0; {
  BOOL result = 0;
  }
  float32x4_t v16 = vmulq_f32(v13, v13);
  float v17 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v16)).f32[0]);
  float32x4_t v18 = vmulq_f32(v8, v8);
  float v19 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), v18)).f32[0])/ v17;
  if (v19 <= 1.0)
  {
    float32x4_t v20 = vmulq_f32(v12, v12);
    float v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), v20)).f32[0])/ v17;
    if (v21 <= 1.0) {
      return (float)(v19 + v21) <= 1.0;
    }
  }
  return result;
}

void C3D::BlitPass::BlitPass(C3D::BlitPass *this, RenderGraph *a2, C3D::Pass *a3)
{
  C3D::Pass::Pass(this, a2, a3);
  *(void *)uint64_t v3 = &unk_26BF6E770;
  *(_DWORD *)(v3 + 32) = 4;
}

float compute_sh(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  LODWORD(v6) = 0;
  uint64_t v7 = (a4 * a4);
  memset(v40, 0, sizeof(v40));
  if (a2)
  {
    unsigned int v8 = 0;
    double v9 = (float)a2;
    double v6 = 1.0;
    float v10 = 1.0 / v9 + -1.0;
    float v11 = (1.0 - 1.0 / v9 + 1.0 - 1.0 / v9) / (v9 + -1.0);
    __asm
    {
      FMOV            V4.4S, #-1.0
      FMOV            V5.4S, #1.0
    }
    _S17 = 3.0;
    do
    {
      uint64_t v19 = 0;
      float v20 = v10 + (float)((float)v8 * v11);
      LODWORD(v21) = _Q4.i32[0];
      float32x4_t v22 = _Q5;
      do
      {
        *(float *)_Q24.i32 = v10 + (float)((float)v19 * v11);
        v23.f32[0] = *(float *)_Q24.i32;
        switch(a3)
        {
          case 0:
            v22.f32[1] = -v20;
            float32x4_t v24 = v22;
            v24.f32[2] = -*(float *)_Q24.i32;
            break;
          case 1:
            *((float *)&v21 + 1) = -v20;
            v24.i64[0] = v21;
            v24.i64[1] = _Q24.i64[0];
            break;
          case 2:
            float32x4_t v24 = _Q5;
            v24.f32[2] = v10 + (float)((float)v8 * v11);
            v24.i32[0] = _Q24.i32[0];
            break;
          case 3:
            float32x4_t v24 = _Q4;
            v24.f32[0] = v10 + (float)((float)v19 * v11);
            v24.f32[2] = -v20;
            break;
          case 4:
            v24.i64[1] = _Q5.i64[1];
            goto LABEL_11;
          case 5:
            *(float *)_Q24.i32 = -*(float *)_Q24.i32;
            v24.i64[1] = _Q4.i64[1];
LABEL_11:
            v24.i32[0] = _Q24.i32[0];
            v24.f32[1] = -v20;
            break;
          default:
            float32x4_t v24 = 0uLL;
            break;
        }
        if (a4 < 1) {
          goto LABEL_17;
        }
        int v41 = 1049652929;
        if (a4 != 1)
        {
          _Q24 = (int32x4_t)vmulq_f32(v24, v24);
          _Q24.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(_Q24, 2), vadd_f32(*(float32x2_t *)_Q24.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q24.i8, 1))).u32[0];
          float32x2_t v25 = vrsqrte_f32((float32x2_t)_Q24.u32[0]);
          float32x2_t v26 = vmul_f32(v25, vrsqrts_f32((float32x2_t)_Q24.u32[0], vmul_f32(v25, v25)));
          float32x4_t v27 = vmulq_n_f32(v24, vmul_f32(v26, vrsqrts_f32((float32x2_t)_Q24.u32[0], vmul_f32(v26, v26))).f32[0]);
          _Q24.i64[0] = vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL).u64[0];
          float32x2_t v42 = vmul_f32(*(float32x2_t *)_Q24.i8, (float32x2_t)0x3EFA2A2CBEFA2A2CLL);
          float v43 = -0.4886 * v27.f32[0];
          if (a4 >= 3)
          {
            _Q25 = vmulq_f32(v27, v27);
            *(float32x2_t *)_Q24.i8 = vmul_f32(*(float32x2_t *)_Q24.i8, vmul_f32(*(float32x2_t *)v27.f32, (float32x2_t)0xBF8BD89D3F8BD89DLL));
            uint64_t v44 = _Q24.i64[0];
            __asm { FMLA            S24, S17, V25.S[2] }
            float v45 = *(float *)_Q24.i32 * 0.31539;
            float v46 = vmuls_lane_f32(v27.f32[0] * -1.0925, v27, 2);
            float v47 = 0.54627 * vsubq_f32(_Q25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q25.f32, 1)).f32[0];
          }
LABEL_17:
          if (!v7) {
            goto LABEL_20;
          }
        }
        v23.f32[1] = v10 + (float)((float)v8 * v11);
        double v29 = vaddv_f32(vmul_f32(v23, v23)) + 1.0;
        *(float *)&double v29 = (float)(4.0 / (float)((float)a2 * (float)a2)) / (v29 * sqrt(v29));
        float32x4_t v30 = vmulq_n_f32(*(float32x4_t *)(a1 + 16 * (v8 * a2 + v19)), *(float *)&v29);
        CFSetRef v31 = (float *)&v41;
        uint64_t v32 = (float32x4_t *)v40;
        uint64_t v33 = (a4 * a4);
        do
        {
          float v34 = *v31++;
          _Q24 = (int32x4_t)vmlaq_n_f32(*v32, v30, v34);
          *v32++ = (float32x4_t)_Q24;
          --v33;
        }
        while (v33);
LABEL_20:
        ++v19;
      }
      while (v19 != a2);
      ++v8;
    }
    while (v8 != a2);
  }
  if (v7)
  {
    uint64_t v35 = 0;
    int v36 = 2 * v7;
    __int16 v37 = v40;
    do
    {
      long long v38 = *v37++;
      *(float *)(a5 + 4 * v35) = *(float *)(a5 + 4 * v35) + *(float *)&v38;
      *(float *)(a5 + 4 * (v7 + v35)) = *((float *)&v38 + 1)
                                                      + *(float *)(a5 + 4 * (v7 + v35));
      *(float *)&double v6 = *((float *)&v38 + 2) + *(float *)(a5 + 4 * (v36 + v35));
      *(float *)(a5 + 4 * (v36 + v35++)) = *(float *)&v6;
    }
    while (v7 != v35);
  }
  return *(float *)&v6;
}

void convert_rgba8unorm_to_rgbaf32(char *a1, int a2, char *a3, int a4, int a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v11 = 0;
    float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    uint64_t v12 = a6;
    do
    {
      if (a5)
      {
        float32x4_t v13 = (float *)&a1[(v11 * a2)];
        float32x4_t v14 = (const float *)&a3[(v11 * a4)];
        int v15 = a5;
        do
        {
          uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v14);
          v17.i64[0] = 0xFF000000FFLL;
          v17.i64[1] = 0xFF000000FFLL;
          float32x4_t v18 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_20B5CCAD0), v17)), v24);
          float32x4_t v25 = v18;
          if (v18.f32[0] <= 0.04045)
          {
            float v20 = v18.f32[0] / 12.92;
          }
          else
          {
            float v19 = powf((float)(v18.f32[0] + 0.055) / 1.055, 2.4);
            float32x4_t v18 = v25;
            float v20 = v19;
          }
          if (v18.f32[1] <= 0.04045)
          {
            float v22 = v18.f32[1] / 12.92;
          }
          else
          {
            float v21 = powf((float)(v18.f32[1] + 0.055) / 1.055, 2.4);
            v18.i64[1] = v25.i64[1];
            float v22 = v21;
          }
          if (v18.f32[2] <= 0.04045)
          {
            float v23 = v18.f32[2] / 12.92;
          }
          else
          {
            float v23 = powf((float)(v18.f32[2] + 0.055) / 1.055, 2.4);
            v18.i32[3] = v25.i32[3];
          }
          *float32x4_t v13 = v20;
          v13[1] = v22;
          v13[2] = v23;
          v13[3] = v18.f32[3];
          ++v14;
          v13 += 4;
          --v15;
        }
        while (v15);
      }
      ++v11;
    }
    while (v11 != v12);
  }
}

uint64_t convert_rgba16f_to_rgbaf32(uint64_t result, int a2, char *a3, int a4, int a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a6;
    do
    {
      if (a5)
      {
        unsigned int v8 = (unsigned int *)(result + (v6 * a2));
        double v9 = (unsigned __int16 *)&a3[(v6 * a4)];
        int v10 = a5;
        do
        {
          unsigned int v11 = *v9;
          int v12 = (v11 >> 10) & 0x1F;
          if (v12) {
            BOOL v13 = v12 == 31;
          }
          else {
            BOOL v13 = 1;
          }
          if (v13)
          {
            if (v12 == 31) {
              int v12 = 2139095040;
            }
          }
          else
          {
            int v12 = (v12 << 23) + 939524096;
          }
          unsigned int v14 = v9[1];
          int v15 = (v14 >> 10) & 0x1F;
          if (v15) {
            BOOL v16 = v15 == 31;
          }
          else {
            BOOL v16 = 1;
          }
          if (v16)
          {
            if (v15 == 31) {
              int v15 = 2139095040;
            }
          }
          else
          {
            int v15 = (v15 << 23) + 939524096;
          }
          unsigned int v17 = v9[2];
          int v18 = (v17 >> 10) & 0x1F;
          if (v18 && v18 != 31)
          {
            int v19 = (v18 << 23) + 939524096;
          }
          else if (v18 == 31)
          {
            int v19 = 2139095040;
          }
          else
          {
            int v19 = (v17 >> 10) & 0x1F;
          }
          unsigned int v20 = v9[3];
          int v21 = (v20 >> 10) & 0x1F;
          if (v21 && v21 != 31)
          {
            int v21 = (v21 << 23) + 939524096;
          }
          else if (v21 == 31)
          {
            int v21 = 2139095040;
          }
          unsigned int *v8 = v12 | (v11 << 16) & 0x80000000 | (v11 >> 7) & 7 | (8 * (v11 & 0x3FF)) & 0x1FFF | ((v11 & 0x3FF) << 13);
          v8[1] = v15 | (v14 << 16) & 0x80000000 | (v14 >> 7) & 7 | (8 * (v14 & 0x3FF)) & 0x1FFF | ((v14 & 0x3FF) << 13);
          float32x4_t v8[2] = v19 | (v17 << 16) & 0x80000000 | (v17 >> 7) & 7 | (8 * (v17 & 0x3FF)) & 0x1FFF | ((v17 & 0x3FF) << 13);
          v8[3] = v21 | (v20 << 16) & 0x80000000 | (v20 >> 7) & 7 | (8 * (v20 & 0x3FF)) & 0x1FFF | ((v20 & 0x3FF) << 13);
          v9 += 4;
          v8 += 4;
          --v10;
        }
        while (v10);
      }
      ++v6;
    }
    while (v6 != v7);
  }
  return result;
}

__n128 C3DRay3Make(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  *a1 = *a2;
  __n128 result = *a3;
  a1[1] = *a3;
  return result;
}

float32x4_t C3DRay3MakeWithSegment(float32x4_t *a1, float32x4_t *a2)
{
  *a1 = *a2;
  float32x4_t v2 = vsubq_f32(a2[1], *a2);
  int32x4_t v3 = (int32x4_t)vmulq_f32(v2, v2);
  v3.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v3, 2), vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1))).u32[0];
  float32x2_t v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  float32x2_t v5 = vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4)));
  float32x4_t result = vmulq_n_f32(v2, vmul_f32(v5, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v5, v5))).f32[0]);
  a1[1] = result;
  return result;
}

uint64_t C3DRay3Vector(uint64_t a1)
{
  return a1 + 16;
}

void C3DRendererContextSetTypedBytesUniformAtLocation(uint64_t a1, uint64_t location, int a3, float32x4_t *v, int a5)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!a1 && (int v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextRenderScene_cold_2(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a5) {
      goto LABEL_6;
    }
  }
  else if (a5)
  {
    goto LABEL_6;
  }
  int v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
    C3DRendererContextSetMatrix4x4UniformAtLocation_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
  }
LABEL_6:
  switch(a3)
  {
    case 1:
      uint64_t v26 = a5;
      uint64_t v27 = a1;
      uint64_t v28 = location;
      double v29 = v;
      goto LABEL_15;
    case 2:
      GLint v30 = v->i32[0];
      goto LABEL_10;
    case 3:
      GLint v30 = v->u8[0];
LABEL_10:
      C3DRendererContextSetIntUniformAtLocation(a1, location, v30);
      break;
    case 6:
      float v32 = *(double *)v->i64;
      *(float *)v34.i32 = v32;
      uint64_t v26 = a5;
      double v29 = (float32x4_t *)&v34;
      uint64_t v27 = a1;
      uint64_t v28 = location;
LABEL_15:
      C3DRendererContextSetFloatUniformAtLocation(v27, v28, v29->f32, v26);
      break;
    case 8:
      C3DRendererContextSetVector2UniformAtLocation(a1, location, v->f32, a5);
      break;
    case 9:
      C3DRendererContextSetVector3UniformAtLocation(a1, location, v->f32, a5);
      break;
    case 10:
      C3DRendererContextSetVector4UniformAtLocation(a1, location, v->f32, a5);
      break;
    case 11:
      C3DRendererContextSetMatrix4x4UniformAtLocation(a1, location, v->f32, a5);
      break;
    case 13:
      C3DRendererContextSetColor4UniformAtLocation(a1, location, v, a5);
      break;
    case 18:
      *(int32x2_t *)v34.i8 = vcvt_s32_f32(*(float32x2_t *)v->f32);
      C3DRendererContextSetInt2UniformAtLocation(a1, location, v34.i32, a5);
      break;
    case 19:
      for (uint64_t i = 0; i != 3; ++i)
        v34.i32[i] = (int)v->f32[i];
      C3DRendererContextSetInt3UniformAtLocation(a1, location, v34.i32, a5);
      break;
    case 20:
      int32x4_t v34 = vcvtq_s32_f32(*v);
      C3DRendererContextSetInt4UniformAtLocation(a1, location, v34.i32, a5);
      break;
    default:
      if ((C3DRendererContextSetTypedBytesUniformAtLocation_done & 1) == 0)
      {
        C3DRendererContextSetTypedBytesUniformAtLocation_done = 1;
        CFSetRef v31 = scn_default_log();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          C3DRendererContextSetTypedBytesUniformAtLocation_cold_1(a3, v31);
        }
      }
      break;
  }
}

void C3DRendererContextSetValueUniformAtLocation(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (!a3)
  {
    int v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      __RemoveVRAMResourceFromDic_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  int Type = C3DValueGetType(a3);
  if (Type == a4)
  {
    unsigned __int16 v19 = a4;
LABEL_27:
    Bytes = (float32x4_t *)C3DValueGetBytes(a3);
    C3DRendererContextSetTypedBytesUniformAtLocation(a1, a2, (__int16)v19, Bytes, a5);
  }
  else
  {
    unsigned __int16 v19 = Type;
    switch(a4)
    {
      case 1:
        BOOL v20 = Type == 6;
        goto LABEL_17;
      case 2:
        if ((Type - 18) >= 3) {
          unsigned __int16 v19 = Type;
        }
        else {
          unsigned __int16 v19 = a4;
        }
        goto LABEL_26;
      case 6:
        if (Type == 1) {
          LOWORD(a4) = 1;
        }
        goto LABEL_26;
      case 8:
        __int16 v21 = Type - 9;
        goto LABEL_21;
      case 9:
        BOOL v22 = Type == 10;
        goto LABEL_23;
      case 10:
        BOOL v20 = Type == 13;
        goto LABEL_17;
      case 11:
      case 20:
        goto LABEL_26;
      case 13:
        BOOL v20 = Type == 10;
LABEL_17:
        if (v20) {
          LOWORD(a4) = Type;
        }
        goto LABEL_26;
      case 18:
        __int16 v21 = Type - 19;
LABEL_21:
        BOOL v22 = (v21 & 0xFFFE) == 0;
        goto LABEL_23;
      case 19:
        BOOL v22 = Type == 20;
LABEL_23:
        if (v22) {
          unsigned __int16 v19 = a4;
        }
        else {
          unsigned __int16 v19 = Type;
        }
LABEL_26:
        int v23 = v19;
        unsigned __int16 v19 = a4;
        if (v23 == (unsigned __int16)a4) {
          goto LABEL_27;
        }
        if ((C3DRendererContextSetValueUniformAtLocation_done & 1) == 0)
        {
          C3DRendererContextSetValueUniformAtLocation_done = 1;
          uint64_t v25 = scn_default_log();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            C3DRendererContextSetValueUniformAtLocation_cold_1(v25);
          }
        }
        break;
      default:
        goto LABEL_27;
    }
  }
}

void _C3DFXProgramDelegateCFFinalize(uint64_t a1)
{
  float32x4_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
  }
}

CFStringRef _C3DFXProgramDelegateCFCopyFormatDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXProgramDelegate %p>", a1);
}

CFStringRef _C3DFXProgramDelegateCFCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<C3DFXProgramDelegate %p>", a1);
}

uint64_t __C3DFXProgramDelegateGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  C3DFXProgramDelegateGetTypeID_typeuint64_t ID = result;
  return result;
}

uint64_t C3DFXProgramDelegateCreate(_OWORD *a1, const void *a2)
{
  if (C3DFXProgramDelegateGetTypeID_onceToken != -1) {
    dispatch_once(&C3DFXProgramDelegateGetTypeID_onceToken, &__block_literal_global_48);
  }
  uint64_t Instance = C3DTypeCreateInstance_(C3DFXProgramDelegateGetTypeID_typeID, 0x28uLL);
  long long v5 = a1[1];
  *(_OWORD *)(Instance + 16) = *a1;
  *(_OWORD *)(Instance + 32) = v5;
  uint64_t v6 = *(const void **)(Instance + 48);
  if (v6 != a2)
  {
    if (v6)
    {
      CFRelease(v6);
      *(void *)(Instance + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0;
    }
    if (a2) {
      CFTypeRef v7 = CFRetain(a2);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *(void *)(Instance + 4_Block_object_dispose(&STACK[0x2A0], 8) = v7;
  }
  return Instance;
}

uint64_t C3DFXProgramDelegateGetUserInfo(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramDelegateGetUserInfo_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t C3DFXProgramGetProfile(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return *(unsigned int *)(a1 + 64);
}

void C3DFXProgramSetProfile(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 64) = a2;
}

uint64_t C3DFXProgramDelegateGetCallbacks(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramDelegateGetUserInfo_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return a1 + 16;
}

CFTypeRef C3DFXProgramSetDelegate(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 72) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 72) = result;
  }
  return result;
}

uint64_t C3DFXProgramIsClientProgram(uint64_t a1)
{
  if (!a1)
  {
    CFAllocatorRef v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return (*(unsigned __int8 *)(a1 + 68) >> 1) & 1;
}

void C3DFXProgramSetClientProgram(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 6_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned char *)(a1 + 68) & 0xFD | v12;
}

void C3DFXProgramSetOpaque(uint64_t a1, char a2)
{
  if (!a1)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DFXProgramGetProfile_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  *(unsigned char *)(a1 + 6_Block_object_dispose(&STACK[0x2A0], 8) = *(unsigned char *)(a1 + 68) & 0xFE | a2;
}

void SCNSetPerformanceStatisticsEnabled(int a1)
{
  if (SCNGetPerformanceStatisticsEnabled::onceToken != -1) {
    dispatch_once(&SCNGetPerformanceStatisticsEnabled::onceToken, &__block_literal_global_49);
  }
  {
    if (a1)
    {
      if (SCNInitializeForDebugging(void)::onceToken != -1)
      {
        dispatch_once(&SCNInitializeForDebugging(void)::onceToken, &__block_literal_global_97);
      }
    }
  }
}

float SCNConvertEngineStatsToPerformanceData(uint64_t a1, unsigned char *a2, int a3)
{
  *a2 = 2;
  double v3 = *(double *)(a1 + 328);
  if (v3 == 0.0) {
    float v4 = 0.0;
  }
  else {
    float v4 = 1.0 / v3;
  }
  uint64_t v5 = &a2[44 * a3];
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a1 + 4);
  *((_DWORD *)v5 + 2) = vcvtas_u32_f32(v4);
  v6.f64[0] = *(float64_t *)(a1 + 96);
  v7.f64[0] = *(float64_t *)(a1 + 120);
  v7.f64[1] = *(double *)(a1 + 128) + *(double *)(a1 + 136) + *(double *)(a1 + 144);
  v6.f64[1] = *(float64_t *)(a1 + 112);
  v8.f64[0] = *(float64_t *)(a1 + 168);
  *(float32x4_t *)(v5 + 12) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v7);
  v6.f64[0] = *(float64_t *)(a1 + 152);
  v8.f64[1] = *(float64_t *)(a1 + 184);
  v6.f64[1] = *(float64_t *)(a1 + 104);
  *(float32x4_t *)(v5 + 2_Block_object_dispose(&STACK[0x2A0], 8) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v8);
  *(float *)v6.f64 = *(double *)(a1 + 192);
  *((_DWORD *)v5 + 11) = LODWORD(v6.f64[0]);
  float result = *(double *)(a1 + 288);
  uint64_t v10 = (float *)&a2[8 * a3];
  v10[24] = result;
  v10[23] = *(float *)(a1 + 280);
  a2[1] = a3;
  return result;
}

void SCNPushPerformanceStatistics(uint64_t a1)
{
  SCNConvertEngineStatsToPerformanceData(a1, &_scnPerformanceData, (byte_267699355 & 1) == 0);
}

void __SCNPushPerformanceStatistics_block_invoke()
{
}

void SCNGetPerformanceStatistics(_OWORD *a1@<X8>)
{
  long long v2 = unk_2676993A4;
  a1[4] = xmmword_267699394;
  a1[5] = v2;
  *(_OWORD *)((char *)a1 + 92) = unk_2676993B0;
  long long v3 = unk_267699364;
  *a1 = _scnPerformanceData;
  a1[1] = v3;
  long long v4 = unk_267699384;
  a1[2] = xmmword_267699374;
  a1[3] = v4;
}

void __SCNGetPerformanceStatistics_block_invoke()
{
}

uint64_t SCNGetGraphicsPerformanceStatistics(void)
{
  double v0 = CACurrentMediaTime();
  if (v0 - *(double *)&_graphicsPerformanceStatisticsDictionaryQueryTime > 1.0)
  {
    io_registry_entry_t v1 = _accelerator;
    if (!_accelerator)
    {
      io_iterator_t existing = 0;
      mach_port_t v2 = *MEMORY[0x263F0EC88];
      CFDictionaryRef v3 = IOServiceMatching("IOAcceleratorES");
      if (!IOServiceGetMatchingServices(v2, v3, &existing)) {
        _accelerator = IOIteratorNext(existing);
      }
      IOObjectRelease(existing);
      io_registry_entry_t v1 = _accelerator;
    }
    CFPropertfloat y = IORegistryEntryCreateCFProperty(v1, @"PerformanceStatistics", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    if (CFProperty)
    {
      uint64_t v5 = (uint64_t)CFProperty;
      if (_graphicsPerformanceStatisticsDictionary) {
        CFRelease((CFTypeRef)_graphicsPerformanceStatisticsDictionary);
      }
      _graphicsPerformanceStatisticsDictionarfloat y = v5;
    }
    _graphicsPerformanceStatisticsDictionaryQueryTime = *(void *)&v0;
  }
  return [(id)_graphicsPerformanceStatisticsDictionary copy];
}

uint64_t _SCNStartCollectingPerformanceStatisticsForPid(int a1)
{
  int v18 = a1;
  uint64_t v1 = CSSymbolicatorCreateWithPid();
  uint64_t v3 = v2;
  if (CSIsNull()) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x4012000000;
  uint64_t v13 = __Block_byref_object_copy__4;
  uint64_t v14 = __Block_byref_object_dispose__4;
  uint64_t v15 = &unk_20B6AE426;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  CSSymbolicatorForeachSymbolWithMangledNameAtTime();
  uint64_t v5 = v11[6];
  uint64_t v6 = v11[7];
  if (CSIsNull()
    || (CSSymbolicatorGetTask(), (mapped_memory_cache_for_tasuint64_t k = create_mapped_memory_cache_for_task()) == 0))
  {
    CSRelease();
    uint64_t v4 = 0;
  }
  else
  {
    {
      getPerfDataMappingByPID(void)::perfDataMappingByPuint64_t ID = 0u;
      unk_267697D38 = 0u;
      dword_267697D48 = 1065353216;
      __cxa_atexit((void (*)(void *))std::unordered_map<int,SCNPerformanceDataMapping>::~unordered_map[abi:nn180100], &getPerfDataMappingByPID(void)::perfDataMappingByPID, &dword_20B249000);
    }
    unsigned __int16 v19 = &v18;
    float64x2_t v8 = std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&getPerfDataMappingByPID(void)::perfDataMappingByPID, &v18, (uint64_t)&std::piecewise_construct, &v19);
    *((void *)v8 + 3) = v1;
    *((void *)v8 + 4) = v3;
    *((void *)v8 + 5) = v5;
    *((void *)v8 + 6) = v6;
    uint64_t v4 = 1;
    *((void *)v8 + 7) = mapped_memory_cache_for_task;
  }
  _Block_object_dispose(&v10, 8);
  return v4;
}

void sub_20B3732E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _SCNStopCollectingPerformanceStatisticsForPid(int a1)
{
  int v4 = a1;
  {
    getPerfDataMappingByPID(void)::perfDataMappingByPuint64_t ID = 0u;
    unk_267697D38 = 0u;
    dword_267697D48 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_map<int,SCNPerformanceDataMapping>::~unordered_map[abi:nn180100], &getPerfDataMappingByPID(void)::perfDataMappingByPID, &dword_20B249000);
  }
  std::unordered_map<int,SCNPerformanceDataMapping>::unordered_map((uint64_t)v3, (uint64_t)&getPerfDataMappingByPID(void)::perfDataMappingByPID);
  uint64_t v1 = std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::find<int>(v3, &v4);
  if (v1)
  {
    destroy_mapped_memory_cache();
    v1[5] = 0;
    v1[6] = 0;
    v1[7] = 0;
    CSRelease();
    v1[3] = 0;
    v1[4] = 0;
    std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::erase(v3, v1);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)v3);
  return 1;
}

void sub_20B373434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *_SCNGetPerformanceStatisticsFromPerformanceData(unsigned __int8 *a1, int a2)
{
  int v4 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  uint64_t v5 = (unsigned int *)&a1[44 * a2];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v5[2]), @"scenekit.fps");
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v5[1]), @"scenekit.primcnt");
  LODWORD(v6) = v5[3];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v6), @"scenekit.frmtime");
  LODWORD(v7) = v5[4];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v7), @"scenekit.phytime");
  LODWORD(v_Block_object_dispose(&STACK[0x2A0], 8) = v5[5];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v8), @"scenekit.prttime");
  LODWORD(v9) = v5[6];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v9), @"scenekit.animtime");
  LODWORD(v10) = v5[9];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v10), @"scenekit.clientTime");
  LODWORD(v11) = v5[7];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v11), @"scenekit.rendertime");
  LODWORD(v12) = v5[8];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v12), @"scenekit.consttime");
  LODWORD(v13) = v5[10];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v13), @"scenekit.cpuidletime");
  LODWORD(v14) = v5[11];
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v14), @"scenekit.cawaittime");
  if (*a1 < 2u)
  {
    [v4 setObject:&unk_26BFC17F8 forKeyedSubscript:@"scenekit.shaderCompilationTime"];
    int v18 = v4;
    uint64_t v17 = &unk_26BFC17F8;
  }
  else
  {
    uint64_t v16 = &a1[8 * a2];
    LODWORD(v15) = *((_DWORD *)v16 + 24);
    objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithFloat:", v15), @"scenekit.shaderCompilationTime");
    uint64_t v17 = (void *)[NSNumber numberWithUnsignedInt:*((unsigned int *)v16 + 23)];
    int v18 = v4;
  }
  [v18 setObject:v17 forKeyedSubscript:@"scenekit.shaderGenerationCount"];
  unsigned __int16 v19 = (void *)SCNGetGraphicsPerformanceStatistics();
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(v19, "objectForKeyedSubscript:", @"Device Utilization %"), @"scenekit.deviceutil");
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(v19, "objectForKeyedSubscript:", @"Renderer Utilization %"), @"scenekit.rendererutil");
  objc_msgSend(v4, "setObject:forKeyedSubscript:", objc_msgSend(v19, "objectForKeyedSubscript:", @"Tiler Utilization %"), @"scenekit.tilerutil");

  return v4;
}

uint64_t *_SCNGetPerformanceStatisticsForPid(int a1)
{
  int v4 = a1;
  {
    getPerfDataMappingByPID(void)::perfDataMappingByPuint64_t ID = 0u;
    unk_267697D38 = 0u;
    dword_267697D48 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_map<int,SCNPerformanceDataMapping>::~unordered_map[abi:nn180100], &getPerfDataMappingByPID(void)::perfDataMappingByPID, &dword_20B249000);
  }
  std::unordered_map<int,SCNPerformanceDataMapping>::unordered_map((uint64_t)v3, (uint64_t)&getPerfDataMappingByPID(void)::perfDataMappingByPID);
  uint64_t v1 = std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::find<int>(v3, &v4);
  if (v1)
  {
    if (CSSymbolGetRange())
    {
      clear_mapped_memory();
      uint64_t v1 = 0;
      mapped_memory_read();
    }
    else
    {
      uint64_t v1 = 0;
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)v3);
  return v1;
}

void sub_20B37380C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void *_SCNGetCollectedShadersForPid()
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  CSSymbolicatorCreateWithPid();
  if (CSIsNull())
  {
    double v0 = &unk_26BFC1818;
  }
  else
  {
    v23[0] = 0;
    v23[1] = v23;
    v23[2] = 0x4012000000;
    v23[3] = __Block_byref_object_copy__4;
    uint8_t v23[4] = __Block_byref_object_dispose__4;
    v23[5] = &unk_20B6AE426;
    v23[6] = 0;
    void v23[7] = 0;
    uint64_t v18 = MEMORY[0x263EF8330];
    uint64_t v19 = 3221225472;
    BOOL v20 = ___ZL26_SCNGetDebuggingInfoForPidi_block_invoke;
    __int16 v21 = &unk_264007290;
    BOOL v22 = v23;
    CSSymbolicatorForeachSymbolWithMangledNameAtTime();
    if (CSIsNull())
    {
      CSRelease();
      double v0 = &unk_26BFC1840;
    }
    else
    {
      CSSymbolicatorGetTask();
      if (create_mapped_memory_cache_for_task())
      {
        if (CSSymbolGetRange())
        {
          clear_mapped_memory();
          uint64_t v17 = 0;
          double v0 = &unk_26BFC18B8;
          mapped_memory_read();
        }
        else
        {
          double v0 = &unk_26BFC1890;
        }
      }
      else
      {
        CSRelease();
        double v0 = &unk_26BFC1868;
      }
    }
    _Block_object_dispose(v23, 8);
  }
  double v12 = v0;
  if ([v0 valueForKey:@"containerPath"])
  {
    uint64_t v1 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "temporaryDirectory"), "URLByAppendingPathComponent:", @"SceneKitShaderCache"), "path");
    double v12 = (void *)[MEMORY[0x263EFF9A0] dictionary];
    double v11 = (void *)[MEMORY[0x263F08850] defaultManager];
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    uint64_t v2 = (void *)[v11 contentsOfDirectoryAtPath:v1 error:0];
    uint64_t v3 = [v2 countByEnumeratingWithState:&v13 objects:v24 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v14 != v4) {
            objc_enumerationMutation(v2);
          }
          double v6 = *(void **)(*((void *)&v13 + 1) + 8 * i);
          if ([v6 hasPrefix:@"commonProfile_"])
          {
            if (objc_msgSend((id)objc_msgSend(v6, "pathExtension"), "isEqualToString:", @"metal"))
            {
              uint64_t v7 = [v1 stringByAppendingPathComponent:v6];
              uint64_t v8 = [NSString stringWithContentsOfFile:v7 encoding:4 error:0];
              uint64_t v9 = objc_msgSend((id)objc_msgSend(v6, "substringFromIndex:", 14), "stringByDeletingPathExtension");
              if (v8)
              {
                if (v9)
                {
                  [v12 setValue:v8 forKey:v9];
                  objc_msgSend(v11, "removeItemAtURL:error:", objc_msgSend(NSURL, "fileURLWithPath:", v7), 0);
                }
              }
            }
          }
        }
        uint64_t v3 = [v2 countByEnumeratingWithState:&v13 objects:v24 count:16];
      }
      while (v3);
    }
  }
  return v12;
}

void sub_20B373C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SCNGetShaderCollectionOutputURL()
{
  double v0 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "temporaryDirectory");

  return [v0 URLByAppendingPathComponent:@"SceneKitShaderCache"];
}

CFTypeRef SCNSetShaderCollectionEnabled(CFTypeRef result)
{
  {
    if (result)
    {
      uint64_t v1 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "temporaryDirectory"), "URLByAppendingPathComponent:", @"SceneKitShaderCache");
      uint64_t v2 = (void *)[MEMORY[0x263F08850] defaultManager];
      if (objc_msgSend(v2, "fileExistsAtPath:", objc_msgSend(v1, "path"))) {
        [v2 removeItemAtURL:v1 error:0];
      }
      uint64_t v4 = 0;
      if (([v2 createDirectoryAtURL:v1 withIntermediateDirectories:1 attributes:0 error:&v4] & 1) == 0)
      {
        uint64_t v3 = scn_default_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          SCNSetShaderCollectionEnabled_cold_1((uint64_t)v1, &v4, v3);
        }
        uint64_t v1 = 0;
      }
      return C3DSetShaderCompilationDirectory(v1);
    }
  }
  return result;
}

char *___ZL25SCNInitializeForDebuggingv_block_invoke()
{
  float result = strncpy(byte_267699251, (const char *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "temporaryDirectory"), "path"), "stringByDeletingLastPathComponent"), "UTF8String"), 0x100uLL);
  result[256] = 0;
  return result;
}

uint64_t ___ZL26_SCNGetDebuggingInfoForPidi_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = CSIsNull();
  if ((result & 1) == 0)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    *(void *)(v7 + 4_Block_object_dispose(&STACK[0x2A0], 8) = a2;
    *(void *)(v7 + 56) = a3;
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    double v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      double v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          double v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  double v11 = (char *)operator new(0x40uLL);
  *(void *)double v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((void *)v11 + 7) = 0;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  BOOL v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *(void *)double v11 = *v20;
LABEL_38:
    *BOOL v20 = v11;
    goto LABEL_39;
  }
  *(void *)double v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*(void *)v11)
  {
    unint64_t v21 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    BOOL v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_20B374068(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<int,SCNPerformanceDataMapping>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(int **)(a2 + 16); i; uint64_t i = *(int **)i)
    std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::__emplace_unique_key_args<int,std::pair<int const,SCNPerformanceDataMapping> const&>(a1, i + 4, (_OWORD *)i + 1);
  return a1;
}

void sub_20B3740DC(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::__emplace_unique_key_args<int,std::pair<int const,SCNPerformanceDataMapping> const&>(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  double v10 = operator new(0x40uLL);
  *double v10 = 0;
  v10[1] = v6;
  long long v12 = a3[1];
  *((_OWORD *)v10 + 1) = *a3;
  *((_OWORD *)v10 + 2) = v12;
  *((_OWORD *)v10 + 3) = a3[2];
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  BOOL v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *double v10 = *v20;
LABEL_38:
    *BOOL v20 = v10;
    goto LABEL_39;
  }
  *double v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    BOOL v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_20B374304(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::find<int>(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *std::__hash_table<std::__hash_value_type<int,SCNPerformanceDataMapping>,std::__unordered_map_hasher<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,SCNPerformanceDataMapping>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,SCNPerformanceDataMapping>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  unint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    unint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x2A0], 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t C3DSerializeFloatAsNumber(void *cf, const void *a2, float a3)
{
  uint64_t result = 0;
  float valuePtr = a3;
  if (cf && a2)
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    uint64_t result = (uint64_t)CFNumberCreate(v6, kCFNumberFloatType, &valuePtr);
    if (result)
    {
      unint64_t v7 = (const void *)result;
      CFDictionarySetValue((CFMutableDictionaryRef)cf, a2, (const void *)result);
      CFRelease(v7);
      return 1;
    }
  }
  return result;
}

uint64_t _C3DInitNumberArrayWithPropertyList(const void *a1, char *a2, CFErrorRef *a3)
{
  if (a1 && (unint64_t v4 = a2) != 0)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 != CFArrayGetTypeID()) {
      return 1;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1) {
      return 1;
    }
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    while (1)
    {
      ValueAtuint64_t Index = CFArrayGetValueAtIndex((CFArrayRef)a1, v9);
      CFTypeID v11 = CFGetTypeID(ValueAtIndex);
      if (v11 != CFNumberGetTypeID()) {
        break;
      }
      if (!CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloatType, v4))
      {
        unint64_t v16 = scn_default_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          _C3DInitNumberArrayWithPropertyList_cold_2();
        }
        goto LABEL_12;
      }
      v4 += 4;
      if (v8 == ++v9) {
        return 1;
      }
    }
    BOOL v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      _C3DInitNumberArrayWithPropertyList_cold_3();
    }
  }
  else
  {
    float v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      _C3DInitNumberArrayWithPropertyList_cold_1();
    }
  }
LABEL_12:
  if (!a3 || *a3) {
    return 0;
  }
  CFErrorRef MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
  uint64_t result = 0;
  *a3 = MalformedDocumentError;
  return result;
}

__CFArray *_C3DCreatePropertyListFromBuffer(char *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  int8x8_t v3 = a1;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  if (a2 >= 1)
  {
    do
    {
      CFNumberRef v6 = CFNumberCreate(v4, kCFNumberFloatType, v3);
      CFArrayAppendValue(Mutable, v6);
      CFRelease(v6);
      v3 += 4;
      --a2;
    }
    while (a2);
  }
  return Mutable;
}

CFDataRef C3DCreateSerializedDataFromC3DFloatBuffer(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = 4 * a2;
  uint8x8_t v5 = (const UInt8 *)malloc_type_malloc(4 * a2, 0xDC03DFB5uLL);
  CFNumberRef v6 = (UInt8 *)v5;
  if (a2 >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      *(_DWORD *)&v5[4 * v7] = bswap32(*(_DWORD *)(a1 + 4 * v7));
      ++v7;
    }
    while (a2 != v7);
    CFDataRef v8 = CFDataCreate(0, v5, v4);
    goto LABEL_6;
  }
  CFDataRef v8 = CFDataCreate(0, v5, v4);
  if (v6) {
LABEL_6:
  }
    free(v6);
  return v8;
}

const UInt8 *C3DInitC3DFloatArrayWithSerializedData(const __CFData *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = CFDataGetBytePtr(a1);
  if (a2 >= 1)
  {
    do
    {
      unsigned int v6 = *(_DWORD *)result;
      result += 4;
      *a3++ = bswap32(v6);
      --a2;
    }
    while (a2);
  }
  return result;
}

CFMutableDictionaryRef C3DCreatePropertyListFromDictionary(const void *a1, uint64_t a2, uint64_t a3)
{
  v9[3] = *MEMORY[0x263EF8340];
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  v9[0] = Mutable;
  v9[1] = a3;
  v9[2] = a2;
  CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)_serializeDictionary, v9);
  return Mutable;
}

void _serializeDictionary(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(__CFDictionary **)a3;
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != CFStringGetTypeID()) {
    return;
  }
  CFTypeID v9 = CFGetTypeID(a2);
  if (C3DTypeConformsToProtocol(v9, 0))
  {
    uint64_t v10 = (const void *)C3DCopyPropertyList(a2, v5, v6, 0);
    if (!v10) {
      return;
    }
LABEL_10:
    CFTypeID v11 = v10;
    CFDictionaryAddValue(v7, a1, v10);
    CFRelease(v11);
    return;
  }
  if (v9 == CFDictionaryGetTypeID())
  {
    uint64_t v10 = (const void *)C3DCreatePropertyListFromDictionary(a2, v6, v5);
    if (!v10) {
      return;
    }
    goto LABEL_10;
  }
  if (v9 == CFDictionaryGetTypeID())
  {
    uint64_t v10 = C3DCreatePropertyListFromArray((const __CFArray *)a2, v6, v5);
    if (!v10) {
      return;
    }
    goto LABEL_10;
  }
  _serializableCFTypeIDs();
  uint64_t v12 = 0;
  while (_serializableCFTypeIDs_serializableTypes[v12] != v9)
  {
    if (++v12 == 6) {
      return;
    }
  }

  CFDictionaryAddValue(v7, a1, a2);
}

CFMutableArrayRef C3DCreatePropertyListFromArray(const __CFArray *a1, uint64_t a2, uint64_t a3)
{
  v8[3] = *MEMORY[0x263EF8340];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  v8[0] = Mutable;
  v8[1] = a3;
  float32x4_t v8[2] = a2;
  v9.GLsizei length = CFArrayGetCount(a1);
  v9.locatiouint64_t n = 0;
  CFArrayApplyFunction(a1, v9, (CFArrayApplierFunction)_serializeArray, v8);
  return Mutable;
}

void _serializeArray(const void *a1, uint64_t a2)
{
  CFIndex v4 = *(__CFArray **)a2;
  CFTypeID v5 = CFGetTypeID(a1);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 16);
  if (C3DTypeConformsToProtocol(v5, 0))
  {
    CFTypeID v8 = (const void *)C3DCopyPropertyList(a1, v6, v7, 0);
    if (!v8) {
      return;
    }
LABEL_9:
    CFRange v9 = v8;
    CFArrayAppendValue(v4, v8);
    CFRelease(v9);
    return;
  }
  if (v5 == CFDictionaryGetTypeID())
  {
    CFTypeID v8 = (const void *)C3DCreatePropertyListFromDictionary(a1, v7, v6);
    if (!v8) {
      return;
    }
    goto LABEL_9;
  }
  if (v5 == CFDictionaryGetTypeID())
  {
    CFTypeID v8 = (const void *)C3DCreatePropertyListFromArray(a1, v7, v6);
    if (!v8) {
      return;
    }
    goto LABEL_9;
  }
  _serializableCFTypeIDs();
  uint64_t v10 = 0;
  while (_serializableCFTypeIDs_serializableTypes[v10] != v5)
  {
    if (++v10 == 6) {
      return;
    }
  }

  CFArrayAppendValue(v4, a1);
}

uint64_t C3DBaseTypeForCFNumberType(uint64_t a1)
{
  uint64_t v1 = a1 - 5;
  if (unint64_t)(a1 - 5) < 9 && ((0x19Du >> v1))
  {
    return (__int16)word_20B5ED8BC[v1];
  }
  else
  {
    uint64_t v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      C3DBaseTypeForCFNumberType_cold_1();
    }
    return 0;
  }
}

BOOL C3DConvertToPlatformIndependentData(char *__src, char *__dst, unint64_t a3, unint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a8 * a7 > a3)
  {
    unint64_t v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      C3DConvertToPlatformIndependentData_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  if (a9 * a7 > a4)
  {
    uint64_t v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DConvertToPlatformIndependentData_cold_3(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  if (a7 >= 1)
  {
    uint64_t v32 = 0;
    int v33 = a5 - 1;
    while (2)
    {
      switch(v33)
      {
        case 0:
          if (a6 >= 1)
          {
            int v35 = 0;
            do
            {
              *(_DWORD *)&__dst[4 * (__int16)v35] = bswap32(*(_DWORD *)&__src[4 * (__int16)v35]);
              ++v35;
            }
            while (a6 > (__int16)v35);
          }
          goto LABEL_66;
        case 1:
          if (a6 >= 1)
          {
            int v36 = 0;
            do
            {
              *(_DWORD *)&__dst[4 * (__int16)v36] = *(_DWORD *)&__src[4 * (__int16)v36];
              ++v36;
            }
            while (a6 > (__int16)v36);
          }
          goto LABEL_66;
        case 2:
        case 3:
        case 15:
          memcpy(__dst, __src, a6);
          goto LABEL_66;
        case 4:
          __int16 v37 = scn_default_log();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            C3DConvertToPlatformIndependentData_cold_2(&buf, v61, v37);
          }
          goto LABEL_66;
        case 5:
          if (a6 >= 1)
          {
            int v38 = 0;
            do
            {
              *(void *)&__dst[8 * (__int16)v38] = bswap64(*(void *)&__src[8 * (__int16)v38]);
              ++v38;
            }
            while (a6 > (__int16)v38);
          }
          goto LABEL_66;
        case 6:
          if (a6 >= 1)
          {
            int v39 = 0;
            do
            {
              *(_DWORD *)&__dst[4 * (__int16)v39] = bswap32(*(_DWORD *)&__src[4 * (__int16)v39]);
              ++v39;
            }
            while (a6 > (__int16)v39);
          }
          goto LABEL_66;
        case 7:
          if (a6 >= 1)
          {
            int v40 = 0;
            int v41 = 0;
            do
            {
              *(int8x8_t *)&__dst[4 * (__int16)v41] = vrev32_s8(*(int8x8_t *)&__src[4 * (__int16)v41]);
              ++v40;
              v41 += 2;
            }
            while (a6 > (__int16)v40);
          }
          goto LABEL_66;
        case 8:
          if (a6 >= 1)
          {
            int v42 = 0;
            int v43 = 0;
            do
            {
              uint64_t v44 = 4 * (__int16)v43;
              *(int8x8_t *)&__dst[v44] = vrev32_s8(*(int8x8_t *)&__src[v44]);
              *(_DWORD *)&__dst[v44 + 8] = bswap32(*(_DWORD *)&__src[v44 + 8]);
              ++v42;
              v43 += 3;
            }
            while (a6 > (__int16)v42);
          }
          goto LABEL_66;
        case 9:
          if (a6 >= 1)
          {
            int v45 = 0;
            int v46 = 0;
            do
            {
              *(int8x16_t *)&__dst[4 * (__int16)v45] = vrev32q_s8(*(int8x16_t *)&__src[4 * (__int16)v45]);
              ++v46;
              v45 += 4;
            }
            while (a6 > (__int16)v46);
          }
          goto LABEL_66;
        case 10:
          if (a6 >= 1)
          {
            int v47 = 0;
            int v48 = 0;
            do
            {
              int v49 = 16 * v47;
              int v50 = 16 * v47 + 16;
              if (v50 > (__int16)(16 * v47))
              {
                do
                {
                  *(_DWORD *)&__dst[4 * (__int16)v49] = bswap32(*(_DWORD *)&__src[4 * (__int16)v49]);
                  ++v49;
                }
                while (v50 > (__int16)v49);
              }
              int v47 = (__int16)++v48;
            }
            while ((__int16)v48 < a6);
          }
          goto LABEL_66;
        case 11:
          if (a6 >= 1)
          {
            int v51 = 0;
            int v52 = 0;
            do
            {
              int v53 = 9 * v51;
              int v54 = v53 + 9;
              while (v54 > (__int16)v53)
              {
                *(_DWORD *)&__dst[4 * (__int16)v53] = bswap32(*(_DWORD *)&__src[4 * (__int16)v53]);
                LOWORD(v53) = v53 + 1;
              }
              int v51 = (__int16)++v52;
            }
            while ((__int16)v52 < a6);
          }
          goto LABEL_66;
        case 12:
          if (a6 >= 1)
          {
            int v55 = 0;
            int v56 = 0;
            do
            {
              *(int8x16_t *)&__dst[4 * (__int16)v55] = vrev32q_s8(*(int8x16_t *)&__src[4 * (__int16)v55]);
              ++v56;
              v55 += 4;
            }
            while (a6 > (__int16)v56);
          }
          goto LABEL_66;
        case 13:
        case 16:
          if (a6 >= 1)
          {
            int v34 = 0;
            do
            {
              *(_WORD *)&__dst[2 * (__int16)v34] = *(_WORD *)&__src[2 * (__int16)v34];
              ++v34;
            }
            while (a6 > (__int16)v34);
          }
          goto LABEL_66;
        case 14:
          if (a6 >= 1)
          {
            int v57 = 0;
            do
            {
              *(_WORD *)&__dst[2 * (__int16)v57] = *(_WORD *)&__src[2 * (__int16)v57];
              ++v57;
            }
            while (a6 > (__int16)v57);
          }
          goto LABEL_66;
        case 22:
        case 23:
          *(_DWORD *)__dst = *(_DWORD *)__src;
LABEL_66:
          __dst += a9;
          __src += a8;
          if (++v32 == a7) {
            return 1;
          }
          continue;
        default:
          uint64_t v59 = scn_default_log();
          BOOL result = os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
          if (result)
          {
            C3DConvertToPlatformIndependentData_cold_1();
            return 0;
          }
          return result;
      }
    }
  }
  return 1;
}

BOOL C3DConvertFromPlatformIndependentData(char *__src, char *__dst, unint64_t a3, unint64_t a4, unsigned int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a8 * a7 <= a3)
  {
    if (a9 * a7 <= a4)
    {
      if (a7 >= 1)
      {
        if (a5 - 6 >= 0xF && (a5 > 0x18 || ((1 << a5) & 0x1800016) == 0))
        {
          int v46 = scn_default_log();
          BOOL result = os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
          if (result)
          {
            C3DConvertFromPlatformIndependentData_cold_3();
            return 0;
          }
          return result;
        }
        uint64_t v17 = 0;
        unsigned int v18 = a5 - 1;
        do
        {
          switch(v18)
          {
            case 0u:
              if (a6 >= 1)
              {
                int v28 = 0;
                do
                {
                  *(_DWORD *)&__dst[4 * (__int16)v28] = bswap32(*(_DWORD *)&__src[4 * (__int16)v28]);
                  ++v28;
                }
                while (a6 > (__int16)v28);
              }
              break;
            case 1u:
              if (a6 >= 1)
              {
                int v29 = 0;
                do
                {
                  *(_DWORD *)&__dst[4 * (__int16)v29] = *(_DWORD *)&__src[4 * (__int16)v29];
                  ++v29;
                }
                while (a6 > (__int16)v29);
              }
              break;
            case 3u:
            case 0xFu:
              memcpy(__dst, __src, a6);
              break;
            case 5u:
              if (a6 >= 1)
              {
                int v30 = 0;
                do
                {
                  *(void *)&__dst[8 * (__int16)v30] = bswap64(*(void *)&__src[8 * (__int16)v30]);
                  ++v30;
                }
                while (a6 > (__int16)v30);
              }
              break;
            case 6u:
              if (a6 >= 1)
              {
                int v31 = 0;
                do
                {
                  *(_DWORD *)&__dst[4 * (__int16)v31] = bswap32(*(_DWORD *)&__src[4 * (__int16)v31]);
                  ++v31;
                }
                while (a6 > (__int16)v31);
              }
              break;
            case 7u:
            case 0x11u:
              if (a6 >= 1)
              {
                int v19 = 0;
                int v20 = 0;
                do
                {
                  *(_DWORD *)&__dst[4 * (__int16)v19] = bswap32(*(_DWORD *)&__src[4 * (__int16)v19]);
                  *(_DWORD *)&__dst[(4 * (__int16)v19) | 4] = bswap32(*(_DWORD *)&__src[(4 * (__int16)v19) | 4]);
                  ++v20;
                  v19 += 2;
                }
                while (a6 > (__int16)v20);
              }
              break;
            case 8u:
            case 0x12u:
              if (a6 >= 1)
              {
                int v21 = 0;
                int v22 = 0;
                do
                {
                  uint64_t v23 = 4 * (__int16)v21;
                  *(_DWORD *)&__dst[v23] = bswap32(*(_DWORD *)&__src[v23]);
                  *(_DWORD *)&__dst[v23 + 4] = bswap32(*(_DWORD *)&__src[v23 + 4]);
                  *(_DWORD *)&__dst[v23 + 8] = bswap32(*(_DWORD *)&__src[v23 + 8]);
                  ++v22;
                  v21 += 3;
                }
                while (a6 > (__int16)v22);
              }
              break;
            case 9u:
            case 0x13u:
              if (a6 >= 1)
              {
                int v24 = 0;
                int v25 = 0;
                do
                {
                  uint64_t v26 = 4 * (__int16)v24;
                  *(_DWORD *)&__dst[v26] = bswap32(*(_DWORD *)&__src[v26]);
                  *(_DWORD *)&__dst[v26 | 4] = bswap32(*(_DWORD *)&__src[v26 | 4]);
                  *(_DWORD *)&__dst[v26 | 8] = bswap32(*(_DWORD *)&__src[v26 | 8]);
                  *(_DWORD *)&__dst[v26 | 0xC] = bswap32(*(_DWORD *)&__src[v26 | 0xC]);
                  ++v25;
                  v24 += 4;
                }
                while (a6 > (__int16)v25);
              }
              break;
            case 0xAu:
              if (a6 >= 1)
              {
                __int16 v32 = 0;
                do
                {
                  uint64_t v33 = 0;
                  int v34 = 16 * v32;
                  int v35 = &__src[4 * v34];
                  int v36 = &__dst[4 * v34];
                  do
                  {
                    *(_DWORD *)&v36[v33] = bswap32(*(_DWORD *)&v35[v33]);
                    v33 += 4;
                  }
                  while (v33 != 64);
                  ++v32;
                }
                while (a6 > v32);
              }
              break;
            case 0xBu:
              if (a6 >= 1)
              {
                __int16 v37 = 0;
                do
                {
                  uint64_t v38 = 0;
                  int v39 = 9 * v37;
                  int v40 = &__src[4 * v39];
                  int v41 = &__dst[4 * v39];
                  do
                  {
                    *(_DWORD *)&v41[v38] = bswap32(*(_DWORD *)&v40[v38]);
                    v38 += 4;
                  }
                  while (v38 != 36);
                  ++v37;
                }
                while (a6 > v37);
              }
              break;
            case 0xCu:
              if (a6 >= 1)
              {
                int v42 = 0;
                int v43 = 0;
                do
                {
                  uint64_t v44 = 4 * (__int16)v42;
                  *(_DWORD *)&__dst[v44] = bswap32(*(_DWORD *)&__src[v44]);
                  *(_DWORD *)&__dst[v44 | 4] = bswap32(*(_DWORD *)&__src[v44 | 4]);
                  *(_DWORD *)&__dst[v44 | 8] = bswap32(*(_DWORD *)&__src[v44 | 8]);
                  *(_DWORD *)&__dst[v44 | 0xC] = bswap32(*(_DWORD *)&__src[v44 | 0xC]);
                  ++v43;
                  v42 += 4;
                }
                while (a6 > (__int16)v43);
              }
              break;
            case 0xDu:
            case 0x10u:
              if (a6 >= 1)
              {
                int v27 = 0;
                do
                {
                  *(_WORD *)&__dst[2 * (__int16)v27] = *(_WORD *)&__src[2 * (__int16)v27];
                  ++v27;
                }
                while (a6 > (__int16)v27);
              }
              break;
            case 0xEu:
              if (a6 >= 1)
              {
                int v45 = 0;
                do
                {
                  *(_WORD *)&__dst[2 * (__int16)v45] = *(_WORD *)&__src[2 * (__int16)v45];
                  ++v45;
                }
                while (a6 > (__int16)v45);
              }
              break;
            default:
              *(_DWORD *)__dst = *(_DWORD *)__src;
              break;
          }
          __dst += a9;
          __src += a8;
          ++v17;
        }
        while (v17 != a7);
      }
      return 1;
    }
    uint64_t v12 = scn_default_log();
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (result)
    {
      C3DConvertFromPlatformIndependentData_cold_2();
      return 0;
    }
  }
  else
  {
    CFRange v9 = scn_default_log();
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (result)
    {
      C3DConvertFromPlatformIndependentData_cold_1();
      return 0;
    }
  }
  return result;
}

CFDataRef C3DCopyLittleEndianToHostRepresentationOfData(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = C3DBaseTypeForCFNumberType(a2);
  uint64_t v7 = C3DSizeOfBaseType(v6);
  if (!a2) {
    return 0;
  }
  unint64_t v8 = v7 * a3;
  if (!(v7 * a3)) {
    return 0;
  }
  CFRange v9 = malloc_type_malloc(v7 * a3, 0x1869B659uLL);
  BytePtr = (char *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v12 = C3DSizeOfBaseType(v6);
  uint64_t v13 = C3DSizeOfBaseType(v6);
  if (!C3DConvertFromPlatformIndependentData(BytePtr, (char *)v9, Length, v8, v6, 1, a3, v12, v13))
  {
    free(v9);
    return 0;
  }
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x263EFFB08];

  return CFDataCreateWithBytesNoCopy(v14, (const UInt8 *)v9, v8, v15);
}

CFDataRef C3DCopyHostToLittleEndianRepresentationOfData(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  CFIndex Length = CFDataGetLength(a1);
  int v7 = C3DBaseTypeForCFNumberType(a2);
  uint64_t v8 = C3DSizeOfBaseType(v7);
  if (!a2) {
    return 0;
  }
  unint64_t v9 = v8 * a3;
  if (!(v8 * a3)) {
    return 0;
  }
  uint64_t v10 = malloc_type_malloc(v8 * a3, 0x8F45E2BEuLL);
  BytePtr = (char *)CFDataGetBytePtr(a1);
  uint64_t v12 = C3DSizeOfBaseType(v7);
  uint64_t v13 = C3DSizeOfBaseType(v7);
  if (!C3DConvertToPlatformIndependentData(BytePtr, (char *)v10, Length, v9, v7, 1, a3, v12, v13))
  {
    free(v10);
    return 0;
  }
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x263EFFB08];

  return CFDataCreateWithBytesNoCopy(v14, (const UInt8 *)v10, v9, v15);
}

uint64_t C3DBaseTypeArraySizeFromString(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (!v2.length) {
    return 1;
  }
  v6.GLsizei length = CFStringGetLength(a1) - v2.location - 2;
  v6.locatiouint64_t n = v2.location + 1;
  CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v6);
  IntCFDictionaryRef Value = CFStringGetIntValue(v3);
  CFRelease(v3);
  return IntValue;
}

CFComparisonResult C3DBaseTypeFromGLSLString(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (v2.length)
  {
    v7.GLsizei length = v2.location;
    v7.locatiouint64_t n = 0;
    CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v7);
    CFComparisonResult v4 = __C3DBaseTypeFromGLSLString(v3);
    CFRelease(v3);
    return v4;
  }
  else
  {
    return __C3DBaseTypeFromGLSLString(a1);
  }
}

CFComparisonResult __C3DBaseTypeFromGLSLString(const __CFString *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (CFEqual(a1, @"int")
    || CFEqual(a1, @"BOOL"))
  {
    return 2;
  }
  if (CFEqual(a1, @"sampler1D")
    || CFEqual(a1, @"sampler2D")
    || CFEqual(a1, @"sampler3D")
    || CFEqual(a1, @"samplerCube"))
  {
    return 5;
  }
  if (CFEqual(a1, @"float")) {
    return 1;
  }
  if (CFEqual(a1, @"vec2")) {
    return 8;
  }
  if (CFEqual(a1, @"vec3")) {
    return 9;
  }
  if (CFEqual(a1, @"vec4")) {
    return 10;
  }
  if (CFEqual(a1, @"ivec2")) {
    return 18;
  }
  if (CFEqual(a1, @"ivec3")) {
    return 19;
  }
  if (CFEqual(a1, @"ivec4")) {
    return 20;
  }
  if (CFEqual(a1, @"mat4")
    || CFEqual(a1, @"mat44"))
  {
    return 11;
  }
  CFComparisonResult result = CFStringCompare(a1, @"none", 0);
  if (result)
  {
    CFStringRef v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    CFComparisonResult result = kCFCompareEqualTo;
    if (v4)
    {
      int v5 = 138412290;
      CFStringRef v6 = a1;
      _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: C3DBaseTypeFromGLSLString: unknown type name '%@'", (uint8_t *)&v5, 0xCu);
      return 0;
    }
  }
  return result;
}

CFComparisonResult C3DBaseTypeFromMetalOrGLSLString(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (v2.length)
  {
    v7.GLsizei length = v2.location;
    v7.locatiouint64_t n = 0;
    CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v7);
    CFComparisonResult v4 = __C3DBaseTypeFromMetalOrGLSLString(v3);
    CFRelease(v3);
    return v4;
  }
  else
  {
    return __C3DBaseTypeFromMetalOrGLSLString(a1);
  }
}

CFComparisonResult __C3DBaseTypeFromMetalOrGLSLString(const __CFString *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (CFEqual(a1, @"int")) {
    return 2;
  }
  if (CFEqual(a1, @"BOOL")) {
    return 3;
  }
  if (CFEqual(a1, @"texture1d")
    || CFEqual(a1, @"sampler1D")
    || CFEqual(a1, @"texture2d")
    || CFEqual(a1, @"sampler2D")
    || CFEqual(a1, @"texture3d")
    || CFEqual(a1, @"sampler3D")
    || CFEqual(a1, @"texturecube")
    || CFEqual(a1, @"samplerCube"))
  {
    return 5;
  }
  if (CFEqual(a1, @"float")) {
    return 1;
  }
  if (CFEqual(a1, @"float2")
    || CFEqual(a1, @"vec2"))
  {
    return 8;
  }
  if (CFEqual(a1, @"float3")
    || CFEqual(a1, @"vec3"))
  {
    return 9;
  }
  if (CFEqual(a1, @"float4")
    || CFEqual(a1, @"vec4"))
  {
    return 10;
  }
  if (CFEqual(a1, @"int2")
    || CFEqual(a1, @"ivec2"))
  {
    return 18;
  }
  if (CFEqual(a1, @"int3")
    || CFEqual(a1, @"ivec3"))
  {
    return 19;
  }
  if (CFEqual(a1, @"int4")
    || CFEqual(a1, @"ivec4"))
  {
    return 20;
  }
  if (CFEqual(a1, @"float4x4")
    || CFEqual(a1, @"mat4")
    || CFEqual(a1, @"mat44"))
  {
    return 11;
  }
  CFComparisonResult result = CFStringCompare(a1, @"none", 0);
  if (result)
  {
    CFStringRef v3 = scn_default_log();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    CFComparisonResult result = kCFCompareEqualTo;
    if (v4)
    {
      int v5 = 138412290;
      CFStringRef v6 = a1;
      _os_log_impl(&dword_20B249000, v3, OS_LOG_TYPE_DEFAULT, "Warning: C3DBaseTypeFromMetalOrGLSLString: unknown type name '%@'", (uint8_t *)&v5, 0xCu);
      return 0;
    }
  }
  return result;
}

__CFString *C3DBaseTypeStringDescription(int a1)
{
  if (a1 >= 46)
  {
    CFRange v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      C3DSizeOfBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  else if (a1 <= 0x2D)
  {
    return __C3DBaseTypeStringDescriptionArray[(unsigned __int16)a1];
  }
  return @"unknown type";
}

uint64_t C3DBaseTypeGetComponentCount(unsigned int a1)
{
  if (a1 < 0x2E) {
    return HIBYTE(__C3DBaseTypeDescArray[3 * (unsigned __int16)a1 + 1]);
  }
  uint64_t v1 = scn_default_log();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    C3DBaseTypeGetComponentType_cold_1();
  }
  return 1;
}

uint64_t C3DBaseTypeGetBytesPerComponent(unsigned int a1)
{
  if (a1 < 0x2E) {
    return LOBYTE(__C3DBaseTypeDescArray[3 * (unsigned __int16)a1 + 1]);
  }
  uint64_t v1 = scn_default_log();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    C3DBaseTypeGetComponentType_cold_1();
  }
  return 0;
}

unint64_t C3DBaseTypeIsFloatingValue(unsigned int a1)
{
  if (a1 < 0x2E) {
    return (0x3FF819E0BFC2uLL >> a1) & 1;
  }
  uint64_t v1 = scn_default_log();
  unint64_t result = os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3DBaseTypeGetComponentType_cold_1();
    return 0;
  }
  return result;
}

BOOL C3DBaseTypeDescription(int a1, uint64_t *a2, uint64_t *a3, unsigned char *a4)
{
  if (a1 >= 46 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DSizeOfBaseType_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a2) {
      goto LABEL_4;
    }
  }
  else if (a2)
  {
LABEL_4:
    if (a3 && a4) {
      goto LABEL_8;
    }
  }
  unint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DBaseTypeDescription_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_8:
  int v24 = (unsigned __int8 *)&__C3DBaseTypeDescArray[3 * a1];
  uint64_t v25 = v24[2];
  uint64_t v26 = v24[3];
  LOBYTE(v24) = v24[4];
  *a2 = v25;
  *a3 = v26;
  *a4 = v24 & 1;
  return C3DBaseTypeFromDescription(*a2, v26, v24 & 1) == a1;
}

void C3DAddBaseType(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float32x4_t *a4)
{
  if (!a2 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DAddBaseType_cold_6(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  unint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DAddBaseType_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a4)
  {
    int v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DAddBaseType_cold_4(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  switch((int)a1)
  {
    case 1:
    case 7:
      a4->f32[0] = a2->f32[0] + a3->f32[0];
      break;
    case 2:
      a4->i32[0] = a3->i32[0] + a2->i32[0];
      break;
    case 3:
    case 4:
    case 5:
    case 12:
    case 16:
      __int16 v32 = scn_default_log();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        C3DAddBaseType_cold_2(a1, v32, v33, v34, v35, v36, v37, v38);
      }
      break;
    case 6:
      double v39 = *(double *)a2 + *(double *)a3;
      goto LABEL_20;
    case 8:
    case 18:
      double v39 = COERCE_DOUBLE(vadd_f32(*a2, *a3));
LABEL_20:
      *(double *)a4->i64 = v39;
      break;
    case 9:
    case 10:
    case 19:
    case 20:
      *a4 = vaddq_f32(*(float32x4_t *)a2->f32, *(float32x4_t *)a3->f32);
      break;
    case 11:
      C3DMatrix4x4Add((float32x4_t *)a2, (float32x4_t *)a3, a4);
      break;
    case 13:
      C3DColor4Add((float *)a2, (float *)a3, a4->f32);
      break;
    case 14:
    case 17:
      a4->i16[0] = a3->i16[0] + a2->i16[0];
      break;
    case 15:
      int v41 = scn_default_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        C3DAddBaseType_cold_3();
      }
      break;
    default:
      int v40 = scn_default_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        C3DAddBaseType_cold_1();
      }
      break;
  }
}

void C3DConcatBaseType(uint64_t a1, float32x2_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  if (!a2 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DAddBaseType_cold_6(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  unint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DAddBaseType_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a4)
  {
    int v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DAddBaseType_cold_4(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  if (a1 == 11) {
    C3DMatrix4x4Mult((uint64_t)a2, a3, a4);
  }
  else {
    C3DAddBaseType(a1, a2, (float32x2_t *)a3, a4);
  }
}

void C3DSubBaseType(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float32x4_t *a4)
{
  if (!a2 && (uint64_t v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DAddBaseType_cold_6(v8, v9, v10, v11, v12, v13, v14, v15);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  unint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
    C3DAddBaseType_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_6:
  if (!a4)
  {
    int v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      C3DAddBaseType_cold_4(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  switch((int)a1)
  {
    case 1:
    case 7:
      a4->f32[0] = a2->f32[0] - a3->f32[0];
      break;
    case 2:
      a4->i32[0] = a2->i32[0] - a3->i32[0];
      break;
    case 3:
    case 4:
    case 5:
    case 12:
    case 16:
      __int16 v32 = scn_default_log();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        C3DSubBaseType_cold_2(a1, v32, v33, v34, v35, v36, v37, v38);
      }
      break;
    case 6:
      double v39 = *(double *)a2 - *(double *)a3;
      goto LABEL_20;
    case 8:
    case 18:
      double v39 = COERCE_DOUBLE(vsub_f32(*a2, *a3));
LABEL_20:
      *(double *)a4->i64 = v39;
      break;
    case 9:
    case 10:
    case 19:
    case 20:
      *a4 = vsubq_f32(*(float32x4_t *)a2->f32, *(float32x4_t *)a3->f32);
      break;
    case 11:
      C3DMatrix4x4Sub((float32x4_t *)a2, (float32x4_t *)a3, a4);
      break;
    case 13:
      C3DColor4Sub((float *)a2, (float *)a3, a4->f32);
      break;
    case 14:
    case 17:
      a4->i16[0] = a2->i16[0] - a3->i16[0];
      break;
    case 15:
      int v41 = scn_default_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        C3DSubBaseType_cold_3();
      }
      break;
    default:
      int v40 = scn_default_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        C3DSubBaseType_cold_1();
      }
      break;
  }
}

uint64_t C3DGetByteCountDescriptionFromSize(uint64_t a1)
{
  return [MEMORY[0x263F086F0] stringFromByteCount:a1 countStyle:3];
}

UInt8 *C3DCreateCStringFromStringWithEncoding(CFStringRef theString, CFStringEncoding a2)
{
  if (!theString)
  {
    uint64_t v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      C3DCreateCStringFromStringWithEncoding_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  CFIndex Length = CFStringGetLength(theString);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, a2);
  if ((MaximumSizeForEncoding & 0x8000000000000000) == 0)
  {
    CFIndex v14 = MaximumSizeForEncoding + 1;
    uint64_t v15 = (UInt8 *)malloc_type_calloc(MaximumSizeForEncoding + 1, 1uLL, 0x8347A507uLL);
    v18.locatiouint64_t n = 0;
    v18.GLsizei length = Length;
    if (CFStringGetBytes(theString, v18, a2, 0x20u, 0, v15, v14, 0)) {
      return v15;
    }
    free(v15);
  }
  unint64_t v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    C3DCreateCStringFromStringWithEncoding_cold_1();
  }
  return 0;
}

UInt8 *C3DCreateCStringFromString(const __CFString *a1)
{
  return C3DCreateCStringFromStringWithEncoding(a1, 0x600u);
}

id C3DCopyRelativeFromFileURL(void *a1, void *a2)
{
  uint64_t v3 = (void *)[a1 URLByDeletingLastPathComponent];

  return C3DCopyRelativeFromFolderURL(v3, a2);
}

id C3DCopyRelativeFromFolderURL(void *a1, void *a2)
{
  uint64_t v3 = (void *)[a1 path];
  id v7 = (id)[a2 path];
  if (v3)
  {
    uint64_t v4 = &stru_26BF72F58;
    while (([v3 isEqualToString:@"/"] & 1) == 0)
    {
      if ([v7 hasPrefix:v3])
      {
        uint64_t v5 = objc_msgSend(v7, "stringByReplacingCharactersInRange:withString:", 0, objc_msgSend(v3, "length"), &stru_26BF72F58);
        if ([v5 characterAtIndex:0] == 47) {
          uint64_t v5 = (void *)[v5 substringFromIndex:1];
        }
        id v7 = (id)[(__CFString *)v4 stringByAppendingPathComponent:v5];
        break;
      }
      uint64_t v3 = (void *)[v3 stringByDeletingLastPathComponent];
      uint64_t v4 = (__CFString *)[(__CFString *)v4 stringByAppendingPathComponent:@".."];
      if (!v3) {
        break;
      }
    }
  }

  return v7;
}

CFErrorRef C3DErrorCreate(CFIndex a1, void *a2, void *a3)
{
  values[2] = *(void **)MEMORY[0x263EF8340];
  values[0] = a2;
  values[1] = a3;
  uint64_t v4 = (void *)*MEMORY[0x263EFFC80];
  keys[0] = *(void **)MEMORY[0x263EFFC70];
  keys[1] = v4;
  if (a3) {
    CFIndex v5 = 2;
  }
  else {
    CFIndex v5 = 1;
  }
  CFDictionaryRef v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v5, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFErrorRef v7 = CFErrorCreate(0, @"SCNKitErrorDomain", a1, v6);
  CFRelease(v6);
  return v7;
}

uint64_t C3DMakePowerOfTwo(int a1)
{
  uint64_t v1 = 1;
  do
  {
    uint64_t v2 = v1;
    uint64_t v1 = (2 * v1);
  }
  while ((int)v2 < a1);
  return v2;
}

double C3DParseVersionNumber(CFStringRef theString)
{
  if (theString)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, @".");
    if (CFArrayGetCount(ArrayBySeparatingStrings) < 1)
    {
      double v3 = 0.0;
    }
    else
    {
      CFIndex v2 = 0;
      double v3 = 0.0;
      double v4 = 1.0;
      do
      {
        ValueAtuint64_t Index = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v2);
        double v3 = v3 + (double)CFStringGetIntValue(ValueAtIndex) * v4;
        double v4 = v4 / 100.0;
        ++v2;
      }
      while (v2 < CFArrayGetCount(ArrayBySeparatingStrings));
    }
    CFRelease(ArrayBySeparatingStrings);
  }
  else
  {
    CFDictionaryRef v6 = scn_default_log();
    double v3 = 0.0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl(&dword_20B249000, v6, OS_LOG_TYPE_DEFAULT, "Warning: C3DParseVersionNumber - No version found", v8, 2u);
    }
  }
  return v3;
}

const char *SCNStringGetCString(const char *result)
{
  if (result)
  {
    uint64_t v1 = (char *)result;
    unint64_t result = CFStringGetCStringPtr((CFStringRef)result, 0x600u);
    if (!result)
    {
      return (const char *)[v1 UTF8String];
    }
  }
  return result;
}

IOSurfaceRef SCNIOSurfaceCreateWithSize(double a1)
{
  int v1 = (int)*(float *)&a1;
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v2 = (int)*((float *)&a1 + 1);
  v10[0] = *MEMORY[0x263F0EF50];
  v11[0] = [NSNumber numberWithInt:(int)*(float *)&a1];
  v10[1] = *MEMORY[0x263F0EDF8];
  uint64_t v3 = [NSNumber numberWithInt:v2];
  uint64_t v4 = *MEMORY[0x263F0ED48];
  v11[1] = v3;
  v11[2] = &unk_26BFC1210;
  uint64_t v5 = *MEMORY[0x263F0ED50];
  v10[2] = v4;
  v10[3] = v5;
  uint64_t v6 = [NSNumber numberWithInt:(4 * v1)];
  uint64_t v7 = *MEMORY[0x263F0EE48];
  _OWORD v11[3] = v6;
  float32x4_t v11[4] = &unk_26BFC1228;
  uint64_t v8 = *MEMORY[0x263F0ED30];
  void v10[4] = v7;
  void v10[5] = v8;
  v11[5] = [NSNumber numberWithInt:(4 * v2 * v1)];
  return IOSurfaceCreate((CFDictionaryRef)[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:6]);
}

uint64_t C3DIOSurfaceToTexImage(uint64_t a1, void *a2, unsigned int a3, int a4, double a5)
{
  if (a4 != 6408) {
    C3DIOSurfaceToTexImage_cold_1();
  }
  BYTE4(v6) = 0;
  LODWORD(v6) = 0;
  return objc_msgSend(a2, "texImageIOSurface:target:internalFormat:width:height:format:type:plane:invert:", a1, a3, 6408, (int)*(float *)&a5, (int)*((float *)&a5 + 1), 6408, 33639, v6);
}

CFURLRef C3DCopyResolvedURLFromFileURL(const __CFURL *a1)
{
  CFStringRef v2 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFStringRef v4 = C3DCopyResolvedPathFromPath(v2);
    if (v4)
    {
      CFStringRef v5 = v4;
      if (CFEqual(v3, v4))
      {
        CFURLRef v6 = 0;
      }
      else
      {
        Boolean v7 = CFURLHasDirectoryPath(a1);
        CFURLRef v6 = CFURLCreateWithFileSystemPath(0, v5, kCFURLPOSIXPathStyle, v7);
      }
      CFRelease(v5);
      CFRelease(v3);
      if (v6) {
        return v6;
      }
    }
    else
    {
      CFRelease(v3);
    }
  }

  return (CFURLRef)CFRetain(a1);
}

CFStringRef C3DCopyResolvedPathFromPath(const __CFString *a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  int v1 = C3DCreateCStringFromStringWithEncoding(a1, 0x8000100u);
  realpath_DARWIN_EXTSN((const char *)v1, cStr);
  CFStringRef v2 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  free(v1);
  return v2;
}

id C3DURLCreateCopyAppendingPathComponent(CFURLRef url, CFStringRef pathComponent)
{
  CFURLRef v2 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x263EFFB08], url, pathComponent, 0);
  CFStringRef v3 = (void *)[(__CFURL *)v2 standardizedURL];
  if (v2)
  {
    id v5 = v3;
    CFRelease(v2);
    CFStringRef v3 = v5;
  }

  return v3;
}

uint64_t C3DStringNamed(void *a1)
{
  CFURLRef v1 = C3DURLOfResourceNamed(a1);
  if (v1)
  {
    CFURLRef v2 = v1;
    CFStringRef v3 = NSString;
    return [v3 stringWithContentsOfURL:v2 encoding:4 error:0];
  }
  else
  {
    id v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      C3DStringNamed_cold_1();
    }
    return 0;
  }
}

CFURLRef C3DURLOfResourceNamed(void *a1)
{
  CFURLRef result = (CFURLRef)[a1 length];
  if (result)
  {
    CFStringRef v3 = (void *)[a1 lastPathComponent];
    if ([a1 isEqualToString:v3]) {
      CFStringRef v4 = 0;
    }
    else {
      CFStringRef v4 = (const __CFString *)[a1 stringByDeletingLastPathComponent];
    }
    CFStringRef v5 = (const __CFString *)[a1 pathExtension];
    CFStringRef v6 = (const __CFString *)[v3 stringByDeletingPathExtension];
    BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.SceneKit");
    CFURLRef v8 = CFBundleCopyResourceURL(BundleWithIdentifier, v6, v5, 0);
    if (!v8)
    {
      MainBundle = CFBundleGetMainBundle();
      CFURLRef v8 = CFBundleCopyResourceURL(MainBundle, v6, v5, v4);
    }
    return v8;
  }
  return result;
}

CFURLRef C3DCopyURLOfResourceNamed(void *a1)
{
  CFURLRef v1 = C3DURLOfResourceNamed(a1);
  CFURLRef v2 = v1;
  if (v1) {
    CFRetain(v1);
  }
  return v2;
}

uint64_t C3DURLIsInMainBundle(const __CFURL *a1)
{
  MainBundle = CFBundleGetMainBundle();
  uint64_t v3 = 0;
  if (!a1) {
    return v3;
  }
  CFStringRef v4 = MainBundle;
  if (!MainBundle) {
    return v3;
  }
  *(void *)packageCreator = 0;
  CFBundleGetPackageInfo(MainBundle, &packageCreator[1], packageCreator);
  uint64_t v3 = 0;
  if (packageCreator[1] != 1095782476) {
    return v3;
  }
  CFURLRef v5 = CFBundleCopyBundleURL(v4);
  if (!v5) {
    return 0;
  }
  CFURLRef v6 = v5;
  Boolean v7 = (__CFString *)CFURLCopyPath(v5);
  CFURLRef v8 = (__CFString *)CFURLCopyPath(a1);
  uint64_t v9 = v8;
  if (v7 && v8)
  {
    CFRange v10 = CFStringFind((CFStringRef)[(__CFString *)v8 stringByStandardizingPath], (CFStringRef)[(__CFString *)v7 stringByStandardizingPath], 1uLL);
    if (v10.location) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v10.length <= 0;
    }
    uint64_t v12 = !v11;
    goto LABEL_15;
  }
  uint64_t v12 = 0;
  uint64_t v3 = 0;
  if (v7)
  {
LABEL_15:
    CFRelease(v7);
    uint64_t v3 = v12;
  }
  if (v9) {
    CFRelease(v9);
  }
  CFRelease(v6);
  return v3;
}

uint64_t C3DDictionaryNamed(void *a1)
{
  CFURLRef v2 = (void *)C3DGetTextResourceWithNameAllowingHotReload(a1);
  if (!v2
    || (uint64_t v3 = [v2 dataUsingEncoding:4],
        uint64_t v7 = 0,
        (uint64_t result = [MEMORY[0x263F08AC0] propertyListWithData:v3 options:0 format:&v7 error:0]) == 0))
  {
    CFURLRef v5 = C3DURLOfResourceNamed(a1);
    if (v5)
    {
      return [NSDictionary dictionaryWithContentsOfURL:v5];
    }
    else
    {
      CFURLRef v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        C3DDictionaryNamed_cold_1();
      }
      return 0;
    }
  }
  return result;
}

uint64_t C3DJsonNamed(void *a1, uint64_t a2)
{
  uint64_t v14 = 0;
  CFStringRef v4 = (void *)C3DGetTextResourceWithNameAllowingHotReload(a1);
  if (v4)
  {
    CFURLRef v5 = v4;
    if (a2) {
      CFURLRef v5 = (void *)(*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v4);
    }
    uint64_t v6 = [v5 dataUsingEncoding:4];
    uint64_t result = [MEMORY[0x263F08900] JSONObjectWithData:v6 options:0 error:&v14];
    if (v14)
    {
      CFURLRef v8 = scn_default_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
LABEL_6:
      C3DJsonNamed_cold_2();
      return 0;
    }
    if (result) {
      return result;
    }
  }
  CFURLRef v9 = C3DURLOfResourceNamed(a1);
  if (!v9)
  {
    uint64_t v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      C3DJsonNamed_cold_1();
    }
    return 0;
  }
  CFRange v10 = (void *)[NSString stringWithContentsOfURL:v9 encoding:4 error:0];
  if (a2) {
    CFRange v10 = (void *)(*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v10);
  }
  uint64_t v11 = [v10 dataUsingEncoding:4];
  uint64_t result = [MEMORY[0x263F08900] JSONObjectWithData:v11 options:0 error:&v14];
  if (v14)
  {
    uint64_t v12 = scn_default_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    goto LABEL_6;
  }
  return result;
}

BOOL C3DEAGLContextAreShared(void *a1, void *a2)
{
  uint64_t v3 = [a1 sharegroup];
  return v3 == [a2 sharegroup];
}

uint64_t C3DPreserveOriginalTopologyDefaultValue()
{
  return C3DWasLinkedBeforeMajorOSYear2019() ^ 1;
}

uint64_t C3DPtrFromMTLBuffer(void *a1, void *a2)
{
  *a2 = [a1 length];

  return [a1 contents];
}

uint64_t C3DDataFromMTLBuffer(void *a1)
{
  if ([a1 storageMode] == 2)
  {
    if ((C3DDataFromMTLBuffer_done & 1) == 0)
    {
      C3DDataFromMTLBuffer_done = 1;
      CFURLRef v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        C3DDataFromMTLBuffer_cold_1();
      }
    }
    return 0;
  }
  else
  {
    CFStringRef v4 = (void *)MEMORY[0x263EFF8F8];
    uint64_t v5 = [a1 contents];
    uint64_t v6 = [a1 length];
    return [v4 dataWithBytesNoCopy:v5 length:v6 freeWhenDone:0];
  }
}